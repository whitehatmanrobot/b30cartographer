 the following must hold:
 *
 *              a.  The variable was live but becomes dead; in
 *                  this case a "pop" must be inserted. Note
 *                  that in order to prevent lots of such pops
 *                  from being added, we keep track of how
 *                  many would be necessary and not enregister
 *                  the variable if this count is excessive.
 *
 *              b.  The variable isn't live at the end of the
 *                  previous block, and it better not be live
 *                  on entry to the successor block; no action
 *                  need be taken in this case.
 *
 *              c.  The variable is live in both places; we
 *                  make sure any enregistered variables that
 *                  were live when the variable was born are
 *                  also live at the successor block, and that
 *                  the number of live enregistered FP vars
 *                  that were born after our variable matches
 *                  the number at the successor block.
 *
 *  We begin our search by looking for a block that starts with
 *  our variable dead but contains a reference to it. Of course
 *  since we need to keep track of which blocks we've already
 *  visited, we first make sure all the blocks are marked as
 *  "not yet visited" (everyone who uses the BBF_VISITED and
 *  BBF_MARKED flags is required to clear them on all blocks
 *  after using them).
 */

bool                Compiler::raEnregisterFPvar(unsigned lclNum, bool convert)
{
    bool            repeat;

    BasicBlock  *   block;

    bool            result  = false;
    bool            hadLife = false;

#ifdef DEBUG
    for (block = fgFirstBB; block; block = block->bbNext)
    {
        assert((block->bbFlags & BBF_VISITED) == 0);
        assert((block->bbFlags & BBF_MARKED ) == 0);
    }
    fgDebugCheckBBlist();
#endif

    assert(lclNum < lvaCount);
    LclVarDsc   *   varDsc = lvaTable + lclNum;
    VARSET_TP       varBit = genVarIndexToBit(varDsc->lvVarIndex);

    assert(varDsc->lvTracked);

    /* We're interested in enregistered FP variables + our variable */

    VARSET_TP       intVars = optAllFPregVars | varBit;

    VARSET_TP       allInnerVars = 0;
    unsigned        popCnt  = 0;
    unsigned        popMax  = 1 + (varDsc->lvRefCnt / 2);
    unsigned        blkNum;
    unsigned        blkMask;
    unsigned        popMask = 0;

#ifdef DEBUG
    if (compStressCompile(STRESS_ENREG_FP, 80))
        popMax = fgBBcount; // allow any number of pops
#endif

AGAIN:

    repeat = false;

    for (block = fgFirstBB; block; block = block->bbNext)
    {
        GenTreePtr      stmt;

        VARSET_TP       outerLife;

        /* number of FP-enreg vars whose lifetime is contained within
           the lifetime of the current var */
        unsigned        innerVcnt;

        bool            isLive;

        VARSET_TP       lastLife;

        /* Have we already visited this block? */

        if  (block->bbFlags & BBF_VISITED)
        {
            /* Has this block been completely processed? */

            if  (block->bbFlags & BBF_MARKED)
                continue;

            /*
                We have earlier seen an edge to this block from
                another one where our variable was live at the
                point of transfer. To avoid having to recurse, we
                simply marked the block as VISITED at that time
                and now we finish with it.
             */

            innerVcnt = block->bbFPinVars;
            outerLife = block->bbVarTmp;

            assert((outerLife & varBit) == 0);

            if  (block->bbFPoutVars & varBit)
            {
                /* Our variable is live on entry to this block */

                isLive = true;
            }
            else
            {
                /* Our variable is dead on entry to this block */

                isLive = false;

                /* If there is some "inner" life, this won't work */

                if  (innerVcnt)
                {
#ifdef  DEBUG
                    if (verbose)
                    {
                        printf("Can't enregister FP var V%02u,T%02u due to inner var's life.\n",
                               lclNum, varDsc->lvVarIndex);
                    }
#endif

                    assert(convert == false);
                    goto DONE_FP_RV;
                }
            }
        }
        else
        {
            /* We're seing this block for this first time just now */

            block->bbFlags    |= BBF_VISITED;

            /* The block had nothing interesting on entry */

            block->bbFPoutVars = block->bbLiveIn & intVars;
            block->bbFPinVars  = 0;                                     // innerVcnt
            block->bbVarTmp    = block->bbLiveIn & optAllFPregVars;     // outerLife

            /* Is the variable ever live in this block? */

            if (((block->bbVarUse | 
                  block->bbVarDef | 
                  block->bbLiveIn   ) & varBit) == 0)
            {
                continue;
            }

            /* Is the variable live on entry to the block? */

            isLive = ((block->bbLiveIn & varBit) != 0);

            if (isLive)
            {
                /*  We're looking for all the births of the given
                    variable, so this block doesn't look useful
                    at this point, since the variable was born
                    already by the time the block starts.

                    The exception to this are arguments and locals
                    which appear to have a read before write.
                    (a possible uninitialized read)

                    Such variables are effectively born on entry to
                    the method, and if they are enregistered are
                    automatically initialized in the prolog.

                    The order of initialization of these variables in
                    the prolog is the same as the weighted ref count order
                 */

                if  (block != fgFirstBB)
                {
                    /* We might have to revisit this block again */

                    block->bbFlags &= ~BBF_VISITED;
                    continue;
                }

                //  This is an argument or local with a possible
                //  read before write, thus is initialized in the prolog
            }

            //  We consider all arguments (and locals) that have
            //  already been assigned to registers as "outer"
            //  and none as "inner".

            innerVcnt = 0;
            outerLife = block->bbLiveIn & optAllFPregVars;
        }

        /* We're going to process this block now */

        block->bbFlags |= BBF_MARKED;

        /* Make sure that we recorded innerVcnt and outerLife */

        assert(block->bbFPinVars == innerVcnt);
        assert(block->bbVarTmp   == outerLife);

        unsigned    outerVcnt = genCountBits(outerLife);

        /* We'll look for lifetime changes of FP variables */

        lastLife = block->bbLiveIn & intVars;

        /* Walk all the statements of the block */

        for (stmt = block->bbTreeList; stmt; stmt = stmt->gtNext)
        {
            assert(stmt->gtOper == GT_STMT);

            for (GenTreePtr tree = stmt->gtStmt.gtStmtList;
                            tree;
                            tree = tree->gtNext)
            {
                // There better be space on the stack for another enreg var

                if (isLive && (outerVcnt + tree->gtFPlvl + innerVcnt + (riscCode?1:0)) >= FP_STK_SIZE)
                {
#ifdef DEBUG
                    if (verbose)
                    {
                        printf("Can't enregister FP var V%02u,T%02u: no space on fpu stack.\n", 
                               lclNum, varDsc->lvVarIndex);
                    }                    
#endif
                    goto DONE_FP_RV;
                }
                

                VARSET_TP       preLife = lastLife;
                VARSET_TP       curLife = tree->gtLiveSet & intVars;
                VARSET_TP       chgLife;

                // @TODO [FIXHACK] [04/16/01] [] Detect completely dead variables; 
                // get rid of this once dead store elimination is fixed.

                hadLife |= isLive;

//              if (convert) printf("Convert %08X in BB%02u\n", tree, block->bbNum);
//              gtDispTree(tree, 0, true);

                /* Make sure we're keeping track of life correctly */

                assert(isLive == ((lastLife & varBit) != 0));

                /* Compute the "change" mask */

                 chgLife = lastLife ^ curLife;
                lastLife =  curLife;

                /* Are we in the second pase (marking the trees) ? */

                if  (convert)
                {
                    /* We have to make changes to some tree nodes */

                    switch (tree->gtOper)
                    {
                    case GT_LCL_VAR:

                        /* Is this a reference to our own variable? */

                        if  (tree->gtLclVar.gtLclNum == lclNum)
                        {
                            /* Convert to a reg var node */

                            tree->ChangeOper(GT_REG_VAR);
                            tree->gtRegNum             =
                            tree->gtRegVar.gtRegNum    = (regNumber)innerVcnt;
                            tree->gtRegVar.gtRegVar    = lclNum;

//                          gtDispTree(tree, 0, true);
                        }
                        break;

                    case GT_REG_VAR:

                        /* Is our variable live along with any outer ones? */

                        if (isLive && outerLife)
                        {
                            LclVarDsc   *   tmpDsc;

                            /* Is this an "outer" register variable ref? */

                            assert(tree->gtRegVar.gtRegVar < lvaCount);
                            tmpDsc = lvaTable + tree->gtRegVar.gtRegVar;
                            assert(tmpDsc->lvTracked);

                            if  (outerLife & genVarIndexToBit(tmpDsc->lvVarIndex))
                            {
                                /* Outer variable - bump its stack level */

                                tree->gtRegNum          =
                                tree->gtRegVar.gtRegNum = (regNumber)(tree->gtRegNum+1);
                            }
                        }
                    }
                }

                /* Is there a change in the set of live FP vars? */

                if  (!chgLife)
                {
                    /* Special case: dead assignments */

                    if  (tree->gtOper            == GT_LCL_VAR &&
                         tree->gtLclVar.gtLclNum == lclNum     && !isLive)
                    {
                        // UNDONE: This should never happen, fix dead store removal!!!!

#ifdef  DEBUG
                        assert(!"Can't enregister FP var, due to the presence of a dead store.\n");
#endif

                        assert(convert == false);
                        goto DONE_FP_RV;
                    }

                    continue;
                }

                /* If anything strange happens (birth or death of fpu vars)
                   inside conditional executed code, bail out
                   @TODO [CONSIDER] [04/16/01] [dnotario]: Should do better analysis here*/
                if (tree->gtFlags & GTF_COLON_COND)
                {
                    assert(chgLife && "We only care if an interesting var has born or died");
#ifdef DEBUG
                    if (verbose)
                    {
                        printf("Can't enregister FP var V%02u,T%02u due to QMARK.\n", 
                               lclNum, varDsc->lvVarIndex);
                    }
                    
#endif
                    goto DONE_FP_RV;
                }

                /* We expect only one thing to change at a time */

                assert(genMaxOneBit(chgLife));

                /* Is the life of our variable changing here? */

                if  (chgLife & varBit)
                {
                    /* Flip the liveness indicator */

                    isLive ^= 1;

//                  printf("P%uL%u: ", convert, isLive); gtDispTree(tree, NULL, true);

                    /* Are we in the second phase already? */

                    if  (convert)
                    {
                        /* The node should have been converted into regvar */

                        assert(tree->gtOper            == GT_REG_VAR &&
                               tree->gtRegVar.gtRegVar == lclNum);

//                      printf("%s ", isLive ? "birth" : "death"); gtDispTree(tree, NULL, true);

                        /* Mark birth/death as appropriate */

                        tree->gtFlags |= isLive ? GTF_REG_BIRTH
                                                : GTF_REG_DEATH;
                    }
                    else
                    {
                        /* Is this the beginning or end of its life? */

                        if  (isLive)  /* the variable is becoming live here */
                        {
                            /* This better be a ref to our variable */

                            assert(tree->gtOper == GT_LCL_VAR);
                            assert(tree->gtLclVar.gtLclNum == lclNum);
                            
                            if (tree->gtFPlvl > 1)
                            {
#if 0 // [dnotario]
                                // This is OK, we will have to bubble up with fxchs
                                // @TODO [CONSIDER] [04/16/01] [dnotario]: tuning with a heuristic fxchs 
                                // we would need  vs weighted usage of the variable. 

                                // Restrict the places where births can occur 
#ifdef  DEBUG
                                if (verbose)
                                {
                                    printf("Can't enregister FP var V%02u,T%02u due to untimely birth.\n",
                                           lclNum, varDsc->lvVarIndex);
                                }
#endif
                                assert(convert == false);
                                goto DONE_FP_RV;                            
#endif // [dnotario]
                            }
                        }
                        else /* the variable is becoming dead here */
                        {
                            assert(!isLive);

                            /* Restrict the places where death can occur */

                            #if  FPU_DEFEREDDEATH
                            // @TODO [BROKEN] [04/16/01] [dnotario]
                            // This code has some bugs. Need to fix this and codegen to get defered deaths
                            // right. 

                            if (tree->gtFPlvl > 1)
                            {
//                              printf("Defer death: "); gtDispTree(tree, NULL, true);

                                /* Death with a non-empty stack is deferred */

                                GenTreePtr tmpExpr;
                                for (tmpExpr = tree;
                                     tmpExpr->gtNext;
                                     tmpExpr = tmpExpr->gtNext)
                                { /***/ }

                                if (tmpExpr->gtOper == GT_ASG)
                                    tmpExpr = tmpExpr->gtOp.gtOp2;

//                              printf("Defer death final   expr [%08X] L=%08X\n",
//                                     tmpExpr, (int)tmpExpr->gtLiveSet & (int)intVars);

                                if  ((tmpExpr->gtLiveSet & intVars) != curLife)
                                {
                                    /* We won't be able to defer the death */
#ifdef  DEBUG
                                    if (verbose)
                                    {
                                        printf("Can't enregister FP var V%02u,T%02u due to untimely death.\n", 
                                               lclNum, varDsc->lvVarIndex);
                                        gtDispTree(tmpExpr);
                                    }
#endif
                                    assert(convert == false);
                                    goto DONE_FP_RV;
                                }                                
                            }
                            #else
                            // If we don't defer deaths we don't have any restriction                             
                            #endif // FPU_DEFEREDDEATH                            
                        }
                    }

                    /* Make sure the same exact set of FP reg variables is live
                       here as was the case at the birth of our variable. If
                       this is not the case, it means that some lifetimes
                       "crossed" in an unacceptable manner.
                    */

                    if  (innerVcnt)
                    {
#ifdef  DEBUG
                        if (verbose)
                        {
                            printf("BB%02u, tree=[%08X]: Can't enregister FP var V%02u,T%02u due to inner var's life.\n",
                                   block->bbNum, tree,
                                   lclNum, varDsc->lvVarIndex);
                        }
#endif
                        assert(convert == false);
                        goto DONE_FP_RV;
                    }

                    if  (outerLife != (curLife & optAllFPregVars))
                    {
#ifdef DEBUG
                        if (verbose)
                        {
                            VARSET_TP diffLife = outerLife ^ (curLife & optAllFPregVars);
                            diffLife =  genFindLowestBit(diffLife);
                            unsigned varNumOuter = genLog2(diffLife);
                            unsigned lclNumOuter = lvaTrackedToVarNum[varNumOuter];
                            printf("BB%02u, tree=[%08X]: Can't enregister FP var V%02u,T%02u due to outer var V%02u,T%02u %s.\n",
                                   block->bbNum, tree, 
                                   lclNum, varDsc->lvVarIndex,
                                   lclNumOuter, varNumOuter,
                                   (diffLife & optAllFPregVars) ? "birth" : "death");
                        }
#endif
                        
                        assert(convert == false);
                        goto DONE_FP_RV;
                    }
                }
                else
                {
                    /* The life of a previously enregister variable is changing here */

                    /* Is our variable live at this node? */

                    if  (isLive)
                    {
                        VARSET_TP   inLife;
                        VARSET_TP   inDied;
                        VARSET_TP   inBorn;

                        /* Make sure none of the "outer" vars has died */

                        if  (chgLife & outerLife)
                        {
                            /* The lifetimes "cross", give up */

#ifdef  DEBUG
                            if (verbose)
                            {
                                unsigned varNumOuter = genLog2(chgLife);
                                unsigned lclNumOuter = lvaTrackedToVarNum[varNumOuter];
                                printf("BB%02u, tree=[%08X]: Can't enregister FP var V%02u,T%02u due to outer var V%02u,T%02u death.\n",
                                       block->bbNum, tree, 
                                       lclNum, varDsc->lvVarIndex,
                                       lclNumOuter, varNumOuter);

                            }
#endif

                            assert(convert == false);
                            goto DONE_FP_RV;
                        }

                        /* Update the "inner life" count */

                        inLife  = ~outerLife & optAllFPregVars;

                        inBorn = (~preLife &  curLife) & inLife;
                        inDied = ( preLife & ~curLife) & inLife;

                        /* We expect only one inner variable to change at one time */

                        assert(inBorn == 0 || inBorn == genFindLowestBit(inBorn));
                        assert(inDied == 0 || inDied == genFindLowestBit(inDied));

                        if  (inBorn)
                        {
                            innerVcnt++;
                            allInnerVars |= chgLife;
                        }
                        if  (inDied)
                        {
                            assert(innerVcnt > 0);
                            innerVcnt--;
                        }
                    }
                    else
                    {
                        // is an outer variable coming live?
                        if (chgLife &  curLife & ~outerLife)
                        {
                            outerLife |= (chgLife & curLife);
                            outerVcnt++;
                        }
                        // is an outer variable going dead?
                        else if (chgLife & ~curLife &  outerLife)
                        {
                            outerLife &= ~chgLife;
                            outerVcnt--;
                        }
                        assert(innerVcnt == 0);
                    }
                }
            }

            /* Is our variable is live at the end of the statement? */

            if  (isLive && convert)
            {
                assert(outerVcnt == stmt->gtStmtFPrvcOut - innerVcnt);

                /* Increment the count of FP regs enregisterd at this point */

                stmt->gtStmtFPrvcOut++;
            }
        }

        // Ensure we didnt go out of sync.
        assert(outerVcnt == genCountBits(outerLife));

        /* Remember the position from the bottom of the FP stack.
           Note that this will be invalid if another variable later gets
           enregistered on the FP stack, whose lifetime nests one but not
           all of the individual lifetime webs of the current variable. In
           such a case, this variable will have different positions from
           the bottom of the FP stack at different points of time.
         */

        if (convert)
            lvaTable[lclNum].lvRegNum = regNumber(outerVcnt);

        /* Consider this block's successors */

        switch (block->bbJumpKind)
        {
            BasicBlock * *  jmpTab;
            unsigned        jmpCnt;

            bool            death;

        case BBJ_COND:

            if  (raMarkFPblock(block, block->bbJumpDest, innerVcnt,
                                                          lastLife,
                                                         outerLife,
                                                         varBit,
                                                         intVars,
                                                         &death,
                                                         &repeat))
            {
                assert(convert == false);
                goto DONE_FP_RV;
            }

            if  (death)
            {
                if  (convert)
                    raInsertFPregVarPop(block, &block->bbJumpDest, lclNum);
                else
                {
                    blkNum  = block->bbJumpDest->bbNum;
                    blkMask = (blkNum < 32) ? (1 << (blkNum-1)) : 0;

                    if ((blkMask & popMask) == 0)
                    {
                        popCnt++;
                        popMask |= blkMask;
                    }
                }
            }

            // Fall through ...

        case BBJ_NONE:

            if  (raMarkFPblock(block, block->bbNext    , innerVcnt,
                                                          lastLife,
                                                         outerLife,
                                                         varBit,
                                                         intVars,
                                                         &death,
                                                         &repeat))
            {
                assert(convert == false);
                goto DONE_FP_RV;
            }

            if  (death)
            {
                if  (convert)
                    raInsertFPregVarPop(block, &block->bbNext, lclNum);
                else
                    blkNum  = block->bbNext->bbNum;
                    blkMask = (blkNum < 32) ? (1 << (blkNum-1)) : 0;

                    if ((blkMask & popMask) == 0)
                    {
                        popCnt++;
                        popMask |= blkMask;
                    }
            }

            break;

        case BBJ_ALWAYS:

            if  (raMarkFPblock(block, block->bbJumpDest, innerVcnt,
                                                          lastLife,
                                                         outerLife,
                                                         varBit,
                                                         intVars,
                                                         &death,
                                                         &repeat))
            {
                assert(convert == false);
                goto DONE_FP_RV;
            }

            if  (death)
            {
                if  (convert)
                    raInsertFPregVarPop(block, &block->bbJumpDest, lclNum);
                else
                    blkNum  = block->bbJumpDest->bbNum;
                    blkMask = (blkNum < 32) ? (1 << (blkNum-1)) : 0;

                    if ((blkMask & popMask) == 0)
                    {
                        popCnt++;
                        popMask |= blkMask;
                    }
            }

            break;

        case BBJ_RET:
        case BBJ_THROW:
        case BBJ_RETURN:
            break;

        case BBJ_CALL:
            assert(convert == false);
            goto DONE_FP_RV;

        case BBJ_SWITCH:

            jmpCnt = block->bbJumpSwt->bbsCount;
            jmpTab = block->bbJumpSwt->bbsDstTab;

            do
            {
                if  (raMarkFPblock(block, *jmpTab, innerVcnt,
                                                    lastLife,
                                                   outerLife,
                                                   varBit,
                                                   intVars,
                                                   &death,
                                                   &repeat))
                {
                    assert(convert == false);
                    goto DONE_FP_RV;
                }

                if  (death)
                {
                    if  (convert)
                        raInsertFPregVarPop(block, jmpTab, lclNum);
                    else
                    blkNum  = (*jmpTab)->bbNum;
                    blkMask = (blkNum < 32) ? (1 << (blkNum-1)) : 0;

                    if ((blkMask & popMask) == 0)
                    {
                        popCnt++;
                        popMask |= blkMask;
                    }
                }
            }
            while (++jmpTab, --jmpCnt);

            break;

        default:
            assert(!"unexpected jump kind");
        }
    }

    /* Do we have too many "pop" locations already? */

    if  (popCnt > popMax)
    {
        /* Yes, we have too many edges that require pops */

#ifdef  DEBUG
        if (verbose)
        {
            printf("Can't enregister FP var V%02u,T%02u, too many pops needed.\n", 
                   lclNum, varDsc->lvVarIndex);
        }
#endif

        assert(convert == false);
        goto DONE_FP_RV;
    }

    /* Did we skip past any blocks? */

    if  (repeat)
        goto AGAIN;

    if  (!hadLife)
    {
        /* Floating variable was never initialized */

#ifdef  DEBUG
        if (verbose) 
            printf("Can't enregister FP due to its complete absence of life\n");
#endif

        assert(convert == false);
        goto DONE_FP_RV;
    }

    /* Success: this variable will be enregistered */

    result = true;

DONE_FP_RV:

    /* If we're converting, we must succeed */

    assert(result == true || convert == false);

    /* Clear the 'visited' and 'marked' bits */

    for (block = fgFirstBB;
         block;
         block = block->bbNext)
    {
        block->bbFlags &= ~(BBF_VISITED|BBF_MARKED);
    }

    if (convert)
    {
        /* @TODO [REVISIT] [04/16/01] []:  lvRegNum is the (max) position from 
           the bottom of the FP stack, ie. the number of outer enregistered FP vars. Whenever a
           new variable gets enregistered, we need to increment lvRegNum for
           all inner FP vars 
         */

        for (VARSET_TP bit = 1; allInnerVars; bit <<= 1)
        {
            if ((bit & allInnerVars) == 0)
                continue;

            allInnerVars &= ~bit;

            unsigned lclNum = lvaTrackedToVarNum[genVarBitToIndex(bit)];
            assert(isFloatRegType(lvaTable[lclNum].lvType));
            assert(lvaTable[lclNum].lvRegister);
            lvaTable[lclNum].lvRegNum = REG_NEXT(lvaTable[lclNum].lvRegNum);
        }
    }

    return  result;
}

/*****************************************************************************
 *
 *  Try to enregister the FP var
 */

bool                Compiler::raEnregisterFPvar(LclVarDsc   *   varDsc,
                                                unsigned    *   pFPRegVarLiveInCnt)
{
    assert(isFloatRegType(varDsc->lvType));
    /* Figure out the variable's number */

    unsigned   lclNum      = varDsc - lvaTable;
    unsigned   varIndex    = varDsc->lvVarIndex;
    VARSET_TP  varBit      = genVarIndexToBit(varIndex);

#ifdef  DEBUG
    if (verbose)
    {
        printf("Consider FP var ");
        gtDispLclVar(lclNum);
        printf(" T%02u (refcnt=%2u,refwtd=%3u%s)\n",
               varIndex, varDsc->lvRefCnt, 
               varDsc->lvRefCntWtd/2, 
               (varDsc->lvRefCntWtd & 1) ? ".5" : "  ");
    }
#endif

    /* Try to find an available FP stack slot for this variable */

    unsigned        stkMin = FP_STK_SIZE;

    do
    {
        if  (varBit & raFPlvlLife[--stkMin])
            break;
    }
    while (stkMin > 1);

    /* Here stkMin is the lowest avaiable stack slot */

    if  (stkMin == FP_STK_SIZE - 1)
    {
        /* FP stack full or call present within lifetime */
#ifdef  DEBUG
        if (verbose)
        {
            printf("Can't enregister FP var "), 
            gtDispLclVar(lclNum);
            printf(" T%02u due to lifetime across a call.\n", varIndex);
        }
#endif

        goto NO_FPV;
    }

    /* Check the variable's lifetime behavior */

    if  (raEnregisterFPvar(lclNum, false))
    {
        /* The variable can be enregistered */
        //
        // If the varible is liveIn to the first Basic Block then
        // we must enregister this varible in the prolog,
        // Typically it will be an incoming argument, but for
        // variables that appear to have an uninitialized read before write
        // then we still must initialize the FPU stack with a 0.0
        //
        // We must remember the order of initialization so that we can
        // perform the FPU stack loads in the correct order
        //
        if (fgFirstBB->bbLiveIn & varBit)
        {
            lvaFPRegVarOrder[*pFPRegVarLiveInCnt] = lclNum;
            (*pFPRegVarLiveInCnt)++;
            lvaFPRegVarOrder[*pFPRegVarLiveInCnt] = -1;       // Mark the end of this table
            assert(*pFPRegVarLiveInCnt < FP_STK_SIZE);
        }

        /* Update the trees and statements */

        raEnregisterFPvar(lclNum, true);

        varDsc->lvRegister = true;

        /* Remember that we have a new enregistered FP variable */

        optAllFPregVars |= varBit;

#ifdef  DEBUG
        if  (verbose) {
            printf("; ");
            gtDispLclVar(lclNum);
            printf(" T%02u (refcnt=%2u,refwtd=%4u%s) enregistered on the FP stack above %d other variables\n",
                   varIndex, varDsc->lvRefCnt, 
                   varDsc->lvRefCntWtd/2,  (varDsc->lvRefCntWtd & 1) ? ".5" : "",
                   varDsc->lvRegNum);
        }
#endif
        return true;
    }
    else
    {
        /* This FP variable will not be enregistered */

    NO_FPV:

        varDsc->lvRegister = false;

        return false;
    }
}


/*****************************************************************************/
#else //not TGT_x86
/*****************************************************************************
 *
 *  Record the fact that all the variables in the 'vars' set interefere with
 *  with the registers in 'regs'.
 */

void                Compiler::raMarkRegSetIntf(VARSET_TP vars, regMaskTP regs)
{
    while (regs)
    {
        regMaskTP   temp;
        regNumber   rnum;

        /* Get the next bit in the mask */

        temp  = genFindLowestBit(regs);

        /* Convert the register bit to a register number */

        rnum  = genRegNumFromMask(temp);

//      printf("Register %s interferes with %08X\n", getRegName(rnum), int(vars));

        /* Mark interference with the corresponding register */

        raLclRegIntf[rnum] |= vars;

        /* Clear the bit and continue if any more left */

        regs -= temp;
    }
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/

void                Compiler::raSetRegVarOrder(regNumber * regVarOrder,
                                               regMaskTP   prefReg,
                                               regMaskTP   avoidReg)
{
    unsigned        index;
    unsigned        listIndex      = 0;
    regMaskTP       usedReg        = avoidReg;
    regMaskTP       regBit;
    regNumber       regNum;

    if (prefReg)
    {
        /* First place the preferred registers at the start of regVarOrder */

        for (index = 0;
             index < raRegVarOrderSize;
             index++)
        {
            regNum = raRegVarOrder[index];
            regBit = genRegMask(regNum);

            if (usedReg & regBit)
                continue;

            if (prefReg & regBit)
            {
                usedReg |= regBit;
                assert(listIndex < raRegVarOrderSize);
                regVarOrder[listIndex++] = regNum;
            }

        }

        /* Then if byteable registers are preferred place them */

        if (prefReg & RBM_BYTE_REG_FLAG)
        {
            for (index = 0;
                 index < raRegVarOrderSize;
                 index++)
            {
                regNum = raRegVarOrder[index];
                regBit = genRegMask(regNum);

                if (usedReg & regBit)
                    continue;

                if (RBM_BYTE_REGS & regBit)
                {
                    usedReg |= regBit;
                    assert(listIndex < raRegVarOrderSize);
                    regVarOrder[listIndex++] = regNum;
                }
            }
        }
    }

    /* Now place all the non-preferred registers */

    for (index = 0;
         index < raRegVarOrderSize;
         index++)
    {
        regNumber regNum = raRegVarOrder[index];
        regMaskTP regBit = genRegMask(regNum);

        if (usedReg & regBit)
            continue;

        usedReg |= regBit;
        assert(listIndex < raRegVarOrderSize);
        regVarOrder[listIndex++] = regNum;
    }

    /* Now place the "avoid" registers */

    for (index = 0;
         index < raRegVarOrderSize;
         index++)
    {
        regNumber regNum = raRegVarOrder[index];
        regMaskTP regBit = genRegMask(regNum);

        if (avoidReg & regBit)
        {
            assert(listIndex < raRegVarOrderSize);
            regVarOrder[listIndex++] = regNum;
        }
    }
}

/*****************************************************************************
 *
 *  Setup the raAvoidArgRegMask and rsCalleeRegArgMaskLiveIn
 */

void                Compiler::raSetupArgMasks()
{
    /* Determine the registers holding incoming register arguments */
    /*  and set raAvoidArgRegMask to the set of registers that we  */
    /*  may want to avoid when enregistering the locals.            */

    LclVarDsc *      argsEnd = lvaTable + info.compArgsCount;

    for (LclVarDsc * argDsc  = lvaTable; argDsc < argsEnd; argDsc++)
    {
        assert(argDsc->lvIsParam);

        // Is it a register argument ?
        if (!argDsc->lvIsRegArg)
            continue;

        // Is it dead on entry ? If compJmpOpUsed is true, then the arguments
        // have to be kept alive. So we have to consider it as live on entry.
        // This will work as long as arguments dont get enregistered for impParamsUsed.

        if (!compJmpOpUsed && argDsc->lvTracked &&
            (fgFirstBB->bbLiveIn & genVarIndexToBit(argDsc->lvVarIndex)) == 0)
        {
            continue;
        }

        regNumber inArgReg = argDsc->lvArgReg;

        assert(genRegMask(inArgReg) & RBM_ARG_REGS);

        rsCalleeRegArgMaskLiveIn |= genRegMask(inArgReg);

        // Do we need to try to avoid this incoming arg registers?

        // If the incoming arg is used after a call it is live accross
        //  a call and will have to be allocated to a caller saved
        //  register anyway (a very common case).
        //
        // In this case it is pointless to ask that the higher ref count
        //  locals to avoid using the incoming arg register

        unsigned    argVarIndex = argDsc->lvVarIndex;
        VARSET_TP   argVarBit   = genVarIndexToBit(argVarIndex);

        /* Does the incoming register and the arg variable interfere? */

        if  ((raLclRegIntf[inArgReg] & argVarBit) == 0)
        {
            // No the do not interfere, so add inArgReg to the set of
            //  registers that interfere.

            raAvoidArgRegMask |= genRegMask(inArgReg);
        }
    }
}

/*****************************************************************************
 *
 *  Assign variables to live in registers, etc.
 */

void                Compiler::raAssignVars()
{
#ifdef DEBUG
    if  (verbose) 
        printf("*************** In raAssignVars()\n");
#endif
    /* We need to keep track of which registers we ever touch */

    rsMaskModf = 0;

    //-------------------------------------------------------------------------

    if (!(opts.compFlags & CLFLG_REGVAR))
        return;  // This doesn't work!

    rsCalleeRegArgMaskLiveIn = RBM_NONE;
    raAvoidArgRegMask        = RBM_NONE;

    /* Predict registers used by code generation */

    rpPredictRegUse();  // New reg predictor/allocator
}

/*****************************************************************************/
#if TGT_x86
/*****************************************************************************/

    // This enumeration specifies register restrictions for the predictor
enum rpPredictReg
{
    PREDICT_NONE,            // any subtree
    PREDICT_ADDR,            // subtree is left side of an assignment
    PREDICT_REG,             // subtree must be any register
    PREDICT_SCRATCH_REG,     // subtree must be any writable register
    PREDICT_NOT_REG_EAX,     // subtree must be any writable register, except EAX
    PREDICT_NOT_REG_ECX,     // subtree must be any writable register, except ECX

    PREDICT_REG_EAX,         // subtree will write EAX
    PREDICT_REG_ECX,         // subtree will write ECX
    PREDICT_REG_EDX,         // subtree will write EDX
    PREDICT_REG_EBX,         // subtree will write EBX
    PREDICT_REG_ESP,         // subtree will write ESP
    PREDICT_REG_EBP,         // subtree will write EBP
    PREDICT_REG_ESI,         // subtree will write ESI
    PREDICT_REG_EDI,         // subtree will write EDI

    PREDICT_PAIR_EAXEDX,     // subtree will write EAX and EDX
    PREDICT_PAIR_ECXEBX,     // subtree will write ECX and EBX

    // The following are use whenever we have a ASG node into a LCL_VAR that
    // we predict to be enregistered.  This flags indicates that we can expect
    // to use the register that is being assigned into as the temporary to
    // compute the right side of the ASGN node.

    PREDICT_REG_VAR_T00,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T01,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T02,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T03,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T04,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T05,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T06,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T07,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T08,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T09,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T10,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T11,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T12,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T13,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T14,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T15,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T16,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T17,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T18,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T19,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T20,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T21,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T22,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T23,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T24,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T25,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T26,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T27,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T28,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T29,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T30,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T31,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T32,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T33,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T34,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T35,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T36,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T37,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T38,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T39,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T40,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T41,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T42,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T43,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T44,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T45,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T46,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T47,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T48,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T49,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T50,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T51,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T52,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T53,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T54,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T55,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T56,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T57,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T58,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T59,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T60,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T61,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T62,     // write the register used by tracked varable 00
    PREDICT_REG_VAR_T63,     // write the register used by tracked varable 00

    PREDICT_COUNT = PREDICT_REG_VAR_T00
};

/*****************************************************************************
 *
 *   Given a regNumber return the correct predictReg enum value
 */

inline static rpPredictReg rpGetPredictForReg(regNumber reg)
{
    return (rpPredictReg) ( ((int) reg) + ((int) PREDICT_REG_EAX) );
}

/*****************************************************************************
 *
 *   Given a varIndex return the correct predictReg enum value
 */

inline static rpPredictReg rpGetPredictForVarIndex(unsigned varIndex)
{
    return (rpPredictReg) ( varIndex + ((int) PREDICT_REG_VAR_T00) );
}

/*****************************************************************************
 *
 *   Given a rpPredictReg return the correct varNumber value
 */

inline static unsigned rpGetVarIndexForPredict(rpPredictReg predict)
{
    return (unsigned) predict - (unsigned) PREDICT_REG_VAR_T00;
}

/*****************************************************************************
 *
 *   Given a regmask return the correct predictReg enum value
 */

static rpPredictReg rpGetPredictForMask(regMaskTP regmask)
{
    rpPredictReg result;
    if (regmask == 0)                   /* Check if regmask has zero bits set */
    {
        result = PREDICT_NONE;
        goto RET;
    }
    else if (((regmask-1) & regmask) == 0)      /* Check if regmask has one bit set */
    {
        if  (regmask & RBM_EAX)             { result = PREDICT_REG_EAX; goto RET; }
        if  (regmask & RBM_EDX)             { result = PREDICT_REG_EDX; goto RET; }
        if  (regmask & RBM_ECX)             { result = PREDICT_REG_ECX; goto RET; }
        if  (regmask & RBM_ESI)             { result = PREDICT_REG_ESI; goto RET; }
        if  (regmask & RBM_EDI)             { result = PREDICT_REG_EDI; goto RET; }
        if  (regmask & RBM_EBX)             { result = PREDICT_REG_EBX; goto RET; }
        if  (regmask & RBM_EBP)             { result = PREDICT_REG_EBP; goto RET; }
    }
    else                                /* It has multiple bits set */
    {
        if (regmask == (RBM_EAX | RBM_EDX)) { result = PREDICT_PAIR_EAXEDX; goto RET; }
        if (regmask == (RBM_ECX | RBM_EBX)) { result = PREDICT_PAIR_ECXEBX; goto RET; }
        assert(!"unreachable");
    }
    result = PREDICT_NONE;
RET:
    return result;
}

/*****************************************************************************
 *
 *  Record a variable to register(s) interference
 */

void                 Compiler::rpRecordRegIntf(regMaskTP    regMask,
                                               VARSET_TP    life
                                     DEBUGARG( char *       msg))
{

#ifdef  DEBUG
    if  (verbose)
    {
        for (unsigned regInx  = 0;
             regInx < raRegVarOrderSize;
             regInx++)
        {
            regNumber  regNum = raRegVarOrder[regInx];
            regMaskTP  regBit = genRegMask(regNum);
            if  (regMask & regBit)
            {
                VARSET_TP  newIntf = life & ~raLclRegIntf[regNum];
                if (newIntf)
                {
                    VARSET_TP  varBit = 1;
                    while (varBit && (varBit <= newIntf))
                    {
                        if (newIntf & varBit)
                        {
                            unsigned varNum = genLog2(varBit);
                            unsigned lclNum = lvaTrackedToVarNum[varNum];
                            printf("Record interference between V%02u,T%02u and %s -- %s\n",
                                   lclNum, varNum, getRegName(regNum), msg);
                        }
                        varBit <<= 1;
                    }
                }
            }
        }
    }
#endif

    if  (regMask & (RBM_EAX|RBM_ECX|RBM_EDX|RBM_EBX))
    {
        if  (regMask & RBM_EAX)   raLclRegIntf[REG_EAX] |= life;
        if  (regMask & RBM_ECX)   raLclRegIntf[REG_ECX] |= life;
        if  (regMask & RBM_EDX)   raLclRegIntf[REG_EDX] |= life;
        if  (regMask & RBM_EBX)   raLclRegIntf[REG_EBX] |= life;
    }

    assert((regMask & RBM_ESP) == 0);
    
    if  (regMask & (RBM_ESI|RBM_EDI|RBM_EBP|RBM_ESP))
    {
        if  (regMask & RBM_EBP)   raLclRegIntf[REG_EBP] |= life;
        if  (regMask & RBM_ESI)   raLclRegIntf[REG_ESI] |= life;
        if  (regMask & RBM_EDI)   raLclRegIntf[REG_EDI] |= life;
    }
}


/*****************************************************************************
 *
 *  Record a new variable to variable(s) interference
 */

void                 Compiler::rpRecordVarIntf(int          varNum,
                                               VARSET_TP    intfVar
                                     DEBUGARG( char *       msg))
{
    assert((varNum >= 0) && (varNum < 64));
    assert(intfVar != 0);

    VARSET_TP oneVar = ((VARSET_TP) 1) << varNum;

    bool newIntf = false;

    fgMarkIntf(intfVar, oneVar, &newIntf);

    if (newIntf)
        rpAddedVarIntf = true;

#ifdef  DEBUG
    if  (verbose && newIntf)
    {
        unsigned oneNum = 0;
        oneVar = 1;
        while (oneNum < 64)
        {
            if (oneVar & intfVar)
            {
                unsigned lclNum = lvaTrackedToVarNum[varNum];
                unsigned lclOne = lvaTrackedToVarNum[oneNum];
                printf("Record interference between V%02u,T%02u and V%02u,T%02u -- %s\n",
                       lclNum, varNum, lclOne, oneNum, msg);
            }
            oneVar <<= 1;
            oneNum++;
        }
    }
#endif
}

/*****************************************************************************
 *
 *   Determine preferred register mask for a given predictReg value
 */

inline
regMaskTP Compiler::rpPredictRegMask(rpPredictReg predictReg)
{
    const static
    regMaskTP predictMap[PREDICT_COUNT] =
    {
        RBM_NONE,            // PREDICT_NONE,
        RBM_NONE,            // PREDICT_ADDR,
        RBM_ALL,             // PREDICT_REG,
        RBM_ALL,             // PREDICT_SCRATCH_REG
        RBM_ALL - RBM_EAX,   // PREDICT_NOT_REG_EAX
        RBM_ALL - RBM_ECX,   // PREDICT_NOT_REG_ECX
        RBM_EAX,             // PREDICT_REG_EAX,
        RBM_ECX,             // PREDICT_REG_ECX,
        RBM_EDX,             // PREDICT_REG_EDX,
        RBM_EBX,             // PREDICT_REG_EBX,
        RBM_ILLEGAL,         // PREDICT_REG_ESP,
        RBM_EBP,             // PREDICT_REG_EBP,
        RBM_ESI,             // PREDICT_REG_ESI,
        RBM_EDI,             // PREDICT_REG_EDI,
        RBM_EAX + RBM_EDX,   // PREDICT_REG_EAXEDX,
        RBM_ECX + RBM_EBX,   // PREDICT_REG_ECXEBX,
    };

    if  (predictReg >= PREDICT_REG_VAR_T00)
        predictReg = PREDICT_REG;

    assert(predictReg < sizeof(predictMap)/sizeof(predictMap[0]));
    assert(predictMap[predictReg] != RBM_ILLEGAL);
    return predictMap[predictReg];
}

/*****************************************************************************
 *
 *  Predict register choice for a type.
 */

regMaskTP            Compiler::rpPredictRegPick(var_types    type,
                                                rpPredictReg predictReg,
                                                regMaskTP    lockedRegs)
{
    regMaskTP preferReg = rpPredictRegMask(predictReg);
    regMaskTP result    = RBM_NONE;
    regPairNo regPair;

    /* Clear out the lockedRegs from preferReg */
    preferReg &= ~lockedRegs;

    if (rpAsgVarNum != -1)
    {
        assert((rpAsgVarNum >= 0) && (rpAsgVarNum < 64));

        /* Don't pick the register used by rpAsgVarNum either */
        LclVarDsc * tgtVar   = lvaTable + lvaTrackedToVarNum[rpAsgVarNum];
        assert(tgtVar->lvRegNum != REG_STK);

        preferReg &= ~genRegMask(tgtVar->lvRegNum);
    }

    switch (type)
    {
    case TYP_BOOL:
    case TYP_BYTE:
    case TYP_UBYTE:
    case TYP_SHORT:
    case TYP_CHAR:
    case TYP_INT:
    case TYP_UINT:
    case TYP_REF:
    case TYP_BYREF:

        // expand preferReg to all non-locked registers if no bits set
        preferReg = rsUseIfZero(preferReg, RBM_ALL & ~lockedRegs);

        if  (preferReg == 0)                         // no bits set?
        {
            // Add EAX to the registers if no bits set.
            // (The jit will introduce one spill temp)
            preferReg |= RBM_EAX;
            rpPredictSpillCnt++;
#ifdef  DEBUG
            if (verbose)
                printf("Predict one spill temp\n");
#endif
        }

        if  (preferReg & RBM_EAX)      { result = RBM_EAX; goto RET; }
        if  (preferReg & RBM_EDX)      { result = RBM_EDX; goto RET; }
        if  (preferReg & RBM_ECX)      { result = RBM_ECX; goto RET; }
        if  (preferReg & RBM_EBX)      { result = RBM_EBX; goto RET; }
        if  (preferReg & RBM_ESI)      { result = RBM_ESI; goto RET; }
        if  (preferReg & RBM_EDI)      { result = RBM_EDI; goto RET; }
        if  (preferReg & RBM_EBP)      { result = RBM_EBP; goto RET; }

        /* Otherwise we have allocated all registers, so do nothing */
        break;

    case TYP_LONG:

        if  (( preferReg                  == 0) ||   // no bits set?
             ((preferReg & (preferReg-1)) == 0)    ) // or only one bit set?
        {
            // expand preferReg to all non-locked registers
            preferReg = RBM_ALL & ~lockedRegs;
        }

        if  (preferReg == 0)                         // no bits set?
        {
            // Add EAX:EDX to the registers
            // (The jit will introduce two spill temps)
            preferReg = RBM_EAX | RBM_EDX;
            rpPredictSpillCnt += 2;
#ifdef  DEBUG
            if (verbose)
                printf("Predict two spill temps\n");
#endif
        }
        else if ((preferReg & (preferReg-1)) == 0)   // only one bit set?
        {
            if ((preferReg & RBM_EAX) == 0)
            {
                // Add EAX to the registers
                // (The jit will introduce one spill temp)
                preferReg |= RBM_EAX;
            }
            else
            {
                // Add EDX to the registers
                // (The jit will introduce one spill temp)
                preferReg |= RBM_EDX;
            }
            rpPredictSpillCnt++;
#ifdef  DEBUG
            if (verbose)
                printf("Predict one spill temp\n");
#endif
        }

        regPair = rsFindRegPairNo(preferReg);
        if (regPair != REG_PAIR_NONE)
        {
            result = genRegPairMask(regPair);
            goto RET;
        }

        /* Otherwise we have allocated all registers, so do nothing */
        break;

    case TYP_FLOAT:
    case TYP_DOUBLE:
        return RBM_NONE;

    default:
        assert(!"unexpected type in reg use prediction");
    }

    /* Abnormal return */
    assert(!"Ran out of registers in rpPredictRegPick");
    return RBM_NONE;

RET:
    /*
     *  If during the first prediction we need to allocate
     *  one of the registers that we used for coloring locals
     *  then flag this by setting rpPredictAssignAgain.
     *  We will have to go back and repredict the registers
     */
    if ((rpPasses == 0) && (rpPredictAssignMask & result))
        rpPredictAssignAgain = true;

    // Add a register interference to each of the last use variables
    if (rpLastUseVars)
    {
        VARSET_TP  varBit  = 1;
        VARSET_TP  lastUse = rpLastUseVars;
        // While we still have any lastUse bits
        while (lastUse)
        {
            // If this varBit and lastUse?
            if (varBit & lastUse)
            {
                // Clear the varBit from the lastUse
                lastUse &= ~varBit;

                // Record a register to variable interference
                rpRecordRegIntf(result, varBit  DEBUGARG( "last use RegPick"));
            }
            // Setup next varBit
            varBit <<= 1;
        }
    }
    return result;
}

/*****************************************************************************
 *
 *  Predict integer register use for generating an address mode for a tree,
 *  by setting tree->gtUsedRegs to all registers used by this tree and its
 *  children.
 *    tree       - is the child of a GT_IND node
 *    lockedRegs - are the registers which are currently held by 
 *                 a previously evaluated node.
 *    rsvdRegs   - registers which should not be allocated because they will
 *                 be needed to evaluate a node in the future
 *               - Also if rsvdRegs has the RBM_LASTUSE bit set then
 *                 the rpLastUseVars set should be saved and restored
 *                 so that we don't add any new variables to rpLastUseVars
 *    lenCSE     - is non-NULL only when we have a lenCSE expression
 *
 *  Return the scratch registers to be held by this tree. (one or two registers 
 *  to form an address expression)
 */

regMaskTP           Compiler::rpPredictAddressMode(GenTreePtr    tree,
                                                   regMaskTP     lockedRegs,
                                                   regMaskTP     rsvdRegs,
                                                   GenTreePtr    lenCSE)
{
    GenTreePtr   op1;
    GenTreePtr   op2;
    GenTreePtr   op3;
    genTreeOps   oper              = tree->OperGet();
    regMaskTP    op1Mask;
    regMaskTP    op2Mask;
    regMaskTP    regMask;
    int          sh;
    bool         rev;
    bool         restoreLastUseVars = false;
    VARSET_TP    oldLastUseVars;

    /* do we need to save and restore the rpLastUseVars set ? */
    if ((rsvdRegs & RBM_LASTUSE) && (lenCSE == NULL))
    {
        restoreLastUseVars = true;
        oldLastUseVars     = rpLastUseVars;
    }
    rsvdRegs &= ~RBM_LASTUSE;

    /* if not an add, then just force it to a register */

    if (oper != GT_ADD)
    {
        if (oper == GT_ARR_ELEM)
        {
            regMask = rpPredictTreeRegUse(tree, PREDICT_NONE, lockedRegs, rsvdRegs);
            goto DONE;
        }
        else
        {
            goto NO_ADDR_EXPR;
        }
    }

    op1 = tree->gtOp.gtOp1;
    op2 = tree->gtOp.gtOp2;
    rev = ((tree->gtFlags & GTF_REVERSE_OPS) != 0);

    assert(op1->OperGet() != GT_CNS_INT);

    /* look for (x + y) + icon address mode */

    if (op2->OperGet() == GT_CNS_INT)
    {
        /* if not an add, then just force op1 into a register */
        if (op1->OperGet() != GT_ADD)
            goto ONE_ADDR_EXPR;

        /* Record the 'rev' flag, reverse evaluation order */
        rev = ((op1->gtFlags & GTF_REVERSE_OPS) != 0);

        op2 = op1->gtOp.gtOp2;
        op1 = op1->gtOp.gtOp1;  // Overwrite op1 last!!
    }

    /* Check for LSH or 1 2 or 3 */

    if (op1->OperGet() != GT_LSH)
        goto TWO_ADDR_EXPR;

    op3 = op1->gtOp.gtOp2;

    if (op3->OperGet() != GT_CNS_INT)
        goto TWO_ADDR_EXPR;

    sh = op3->gtIntCon.gtIconVal;
    /* greater than 3, equal to zero */
    if ((sh > 3) || (sh == 0))
        goto TWO_ADDR_EXPR;

    /* Matched a leftShift by 'sh' subtree, move op1 down */
    op1 = op1->gtOp.gtOp1;

TWO_ADDR_EXPR:

    /* Now we have to evaluate op1 and op2 into registers */

    /* Evaluate op1 and op2 in the correct order */
    if (rev)
    {
        op2Mask = rpPredictTreeRegUse(op2, PREDICT_REG, lockedRegs,           rsvdRegs | op1->gtRsvdRegs);
        op1Mask = rpPredictTreeRegUse(op1, PREDICT_REG, lockedRegs | op2Mask, rsvdRegs);
    }
    else
    {
        op1Mask = rpPredictTreeRegUse(op1, PREDICT_REG, lockedRegs,           rsvdRegs | op2->gtRsvdRegs);
        op2Mask = rpPredictTreeRegUse(op2, PREDICT_REG, lockedRegs | op1Mask, rsvdRegs);
    }

    /*  If op1 and op2 must be spilled and reloaded then
     *  op1 and op2 might be reloaded into the same register
     *  This can only happen when all the registers are lockedRegs 
     */
    if ((op1Mask == op2Mask) && (op1Mask != 0))
    {
        /* We'll need to grab a different register for op2 */
        op2Mask = rpPredictRegPick(TYP_INT, PREDICT_REG, op1Mask);
    }

    tree->gtUsedRegs = op1->gtUsedRegs | op2->gtUsedRegs;
    regMask          = op1Mask         | op2Mask;

    goto DONE;

ONE_ADDR_EXPR:

    /* now we have to evaluate op1 into a register */

    regMask = rpPredictTreeRegUse(op1, PREDICT_REG, lockedRegs, rsvdRegs);
    tree->gtUsedRegs = op1->gtUsedRegs;

    goto DONE;

NO_ADDR_EXPR:

    if (oper == GT_CNS_INT)
    {
        /* Indirect of a constant does not require a register */
        regMask = RBM_NONE;
    }
    else
    {
        /* now we have to evaluate tree into a register */
        regMask = rpPredictTreeRegUse(tree, PREDICT_REG, lockedRegs, rsvdRegs);
    }

DONE:

    /* Do we need to resore the oldLastUseVars value */
    if (restoreLastUseVars && (rpLastUseVars != oldLastUseVars))
    {
        /*
         *  If we used a GT_ASG targeted register then we need to add
         *  a variable interference between any new last use variables
         *  and the GT_ASG targeted register
         */
        if (rpAsgVarNum != -1)
        {
            rpRecordVarIntf(rpAsgVarNum, 
                            (rpLastUseVars & ~oldLastUseVars)
                  DEBUGARG( "asgn conflict (gt_ind)"));
        }         
        rpLastUseVars = oldLastUseVars;
    }

    return regMask;
}

/*****************************************************************************
 *
 *
 */

void Compiler::rpPredictRefAssign(unsigned lclNum)
{
    LclVarDsc * varDsc = lvaTable + lclNum;

    varDsc->lvRefAssign = 1;

#ifdef  DEBUG
    if  (verbose)
    {
        if ((raLclRegIntf[REG_EDX] & genVarIndexToBit(varDsc->lvVarIndex)) == 0)
            printf("Record interference between V%02u,T%02u and EDX -- ref assign\n", 
                   lclNum, varDsc->lvVarIndex);
    }
#endif

    /* Make sure that write barrier pointer variables never land in EDX */
    raLclRegIntf[REG_EDX] |= genVarIndexToBit(varDsc->lvVarIndex);
}

/*****************************************************************************
 *
 *  Predict integer register usage for a tree, by setting tree->gtUsedRegs
 *  to all registers used by this tree and its children.
 *    tree       - is the child of a GT_IND node
 *    predictReg - what type of register does the tree need
 *    lockedRegs - are the registers which are currently held by 
 *                 a previously evaluated node. 
 *                 Don't modify lockRegs as it is used at the end to compute a spill mask
 *    rsvdRegs   - registers which should not be allocated because they will
 *                 be needed to evaluate a node in the future
 *               - Also if rsvdRegs has the RBM_LASTUSE bit set then
 *                 the rpLastUseVars set should be saved and restored
 *                 so that we don't add any new variables to rpLastUseVars
 *  Returns the registers predicted to be held by this tree.
 */

regMaskTP           Compiler::rpPredictTreeRegUse(GenTreePtr    tree,
                                                  rpPredictReg  predictReg,
                                                  regMaskTP     lockedRegs,
                                                  regMaskTP     rsvdRegs)
{
    regMaskTP       regMask;
    regMaskTP       op2Mask;
    regMaskTP       tmpMask;
    rpPredictReg    op1PredictReg;
    rpPredictReg    op2PredictReg;
    LclVarDsc *     varDsc;
    VARSET_TP       varBit;
    VARSET_TP       oldLastUseVars;
    bool            restoreLastUseVars = false;

#ifdef DEBUG
    assert(tree);
    assert(((RBM_ILLEGAL & RBM_ALL) == 0) && (RBM_ILLEGAL != 0));
    assert((lockedRegs & RBM_ILLEGAL) == 0);

    /* impossible values, to make sure that we set them */
    tree->gtUsedRegs = RBM_ILLEGAL;
    regMask          = RBM_ILLEGAL;
    oldLastUseVars   = -1;
#endif

    /* Figure out what kind of a node we have */

    genTreeOps  oper = tree->OperGet();
    var_types   type = tree->TypeGet();
    unsigned    kind = tree->OperKind();

    if ((predictReg == PREDICT_ADDR) && (oper != GT_IND))
        predictReg = PREDICT_NONE;
    else if (predictReg >= PREDICT_REG_VAR_T00)
    {
        unsigned   varIndex = rpGetVarIndexForPredict(predictReg);
        VARSET_TP  varBit   = genVarIndexToBit(varIndex);
        if (varBit & tree->gtLiveSet)
            predictReg = PREDICT_SCRATCH_REG;
    }

    if (rsvdRegs & RBM_LASTUSE)
    {
        restoreLastUseVars  = true;
        oldLastUseVars      = rpLastUseVars;
        rsvdRegs           &= ~RBM_LASTUSE;
    }

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST | GTK_LEAF))
    {
        bool      lastUse   = false;
        regMaskTP enregMask = RBM_NONE;
#ifdef DEBUG
        varBit = 0;
#endif

        switch(oper)
        {
        case GT_CNS_INT:
            if (opts.compReloc && (tree->gtFlags & GTF_ICON_HDL_MASK))
            {
                /* The constant is actually a handle that may need relocation
                   applied to it.  It will need to be loaded into a register.
                */

                predictReg = PREDICT_SCRATCH_REG;
            }
            break;

        case GT_BREAK:
        case GT_NO_OP:
            break;

        case GT_BB_QMARK:
            regMask = genTypeToReturnReg(type);
            tree->gtUsedRegs = regMask;
            goto RETURN_CHECK;

        case GT_CLS_VAR:
            if ((predictReg          == PREDICT_NONE) && 
                (genActualType(type) == TYP_INT)      && 
                (genTypeSize(type) < sizeof(int))         )
            {
                predictReg  = PREDICT_SCRATCH_REG;
            }
            break;

        case GT_LCL_VAR:
            // If it's a floating point var, there's nothing to do
            if (varTypeIsFloating(type))
            {
                tree->gtUsedRegs = regMask = RBM_NONE;
                goto RETURN_CHECK;
            }

            varDsc  = lvaTable + tree->gtLclVar.gtLclNum;

            /* Record whether this is the last use of the LCL_VAR */
            if (varDsc->lvTracked)
            {
                varBit  = genVarIndexToBit(varDsc->lvVarIndex);
                lastUse = ((tree->gtLiveSet & varBit) == 0);
            }

            /* Apply the type of predictReg to the LCL_VAR */

            if (predictReg == PREDICT_REG)
            {
PREDICT_REG_COMMON:
                if (varDsc->lvRegNum == REG_STK)
                    break;

                goto GRAB_COUNT;
            }
            else if (predictReg == PREDICT_SCRATCH_REG)
            {
TRY_SCRATCH_REG:
                assert(predictReg == PREDICT_SCRATCH_REG);

                /* Is this the last use of a local var?   */
                if (lastUse && ((rpUseInPlace & varBit) == 0))
                    goto PREDICT_REG_COMMON;
            }
            else if (predictReg >= PREDICT_REG_VAR_T00)
            {
                /* Get the tracked local variable that has an lvVarIndex of tgtIndex */

                unsigned    tgtIndex; tgtIndex = rpGetVarIndexForPredict(predictReg);
                VARSET_TP   tgtBit;   tgtBit   = genVarIndexToBit(tgtIndex);
                LclVarDsc * tgtVar;   tgtVar   = lvaTable + lvaTrackedToVarNum[tgtIndex];

                assert(tgtVar->lvVarIndex == tgtIndex);
                assert(tgtVar->lvRegNum   != REG_STK);  /* Must have been enregistered */
                assert((type != TYP_LONG) || (tgtVar->TypeGet() == TYP_LONG));

                /* Check to see if the tgt reg is still alive */
                if (tree->gtLiveSet & tgtBit)
                {
                    /* We will PREDICT_SCRATCH_REG */
                    predictReg  = PREDICT_SCRATCH_REG;
                    goto TRY_SCRATCH_REG;
                }

                unsigned    srcIndex; srcIndex = varDsc->lvVarIndex;

                // If this register has it's last use here then we will prefer
                // to color to the same register as tgtVar.
                if (lastUse)
                {
                    VARSET_TP   srcBit   = genVarIndexToBit(srcIndex);

                    /*
                     *  Add an entry in the lvaVarPref graph to indicate
                     *  that it would be worthwhile to color these two variables
                     *  into the same physical register.
                     *  This will help us avoid having an extra copy instruction
                     */
                    lvaVarPref[srcIndex] |= tgtBit;
                    lvaVarPref[tgtIndex] |= srcBit;
                }

                rpAsgVarNum = tgtIndex;

                // Add a variable interference from srcIndex to each of the last use variables
                if (rpLastUseVars)
                {
                    rpRecordVarIntf(srcIndex, 
                                    rpLastUseVars 
                          DEBUGARG( "src reg conflict"));
                }

                /* We will rely on the target enregistered variable from the GT_ASG */
                varDsc = tgtVar;
                varBit = tgtBit;

GRAB_COUNT:
                unsigned grabCount;     grabCount    = 0;

                enregMask = genRegMask(varDsc->lvRegNum);
                
                /* We can't trust a prediction of rsvdRegs or lockedRegs sets */
                if (enregMask & (rsvdRegs | lockedRegs))
                {
                    grabCount++;
                }

                if (type == TYP_LONG)
                {
                    if (varDsc->lvOtherReg != REG_STK)
                    {
                        tmpMask  = genRegMask(varDsc->lvOtherReg);
                        enregMask |= tmpMask;

                        /* We can't trust a prediction of rsvdRegs or lockedRegs sets */
                        if (tmpMask & (rsvdRegs | lockedRegs))
                            grabCount++;
                    }
                    else // lvOtherReg == REG_STK
                    {
                        grabCount++;
                    }
                }

                varDsc->lvDependReg = true;

                if (grabCount == 0)
                {
                    /* Does not need a register */
                    predictReg = PREDICT_NONE;
                    assert(varBit);
                    rpUseInPlace |= varBit;
                }
                else
                {
                    /* For TYP_LONG and we only need one register then change the type to TYP_INT */
                    if ((type == TYP_LONG) && (grabCount == 1))
                    {
                        /* We will need to pick one register */
                        type = TYP_INT;
                        assert(varBit);
                        rpUseInPlace |= varBit;
                    }
                    assert(grabCount == (genTypeSize(genActualType(type)) / sizeof(int)));
                }
            }
            break;  /* end of case GT_LCL_VAR */

        case GT_JMP:
            tree->gtUsedRegs = regMask = RBM_NONE;
            goto RETURN_CHECK;

        } /* end of switch(oper) */

        /* If we don't need to evaluate to register, regmask is the empty set */
        /* Otherwise we grab a temp for the local variable                    */

        if (predictReg == PREDICT_NONE)
            regMask = RBM_NONE;
        else
        {
            regMask = rpPredictRegPick(type, predictReg, lockedRegs | rsvdRegs | enregMask);
            if ((predictReg == PREDICT_SCRATCH_REG) && lastUse && ((rpUseInPlace & varBit) != 0))
            {
                rpRecordRegIntf(regMask, varBit  DEBUGARG( "rpUseInPlace and need scratch reg"));
            }
        }

        /* Update the set of lastUse variables that we encountered so far */
        if (lastUse)
        {
            assert(varBit);
            rpLastUseVars |= varBit;

            /*
             *  Add interference from any previously locked temps into this last use variable.
             */
            if (lockedRegs)
                rpRecordRegIntf(lockedRegs, varBit  DEBUGARG( "last use Predict lockedRegs"));
            /*
             *  Add interference from any reserved temps into this last use variable.
             */
            if (rsvdRegs)
                rpRecordRegIntf(rsvdRegs,   varBit  DEBUGARG( "last use Predict rsvdRegs"));
            /* 
             *  For partially enregistered longs add an interference with the 
             *  register return by rpPredictRegPick
             */
            if ((type == TYP_INT) && (tree->TypeGet() == TYP_LONG))
                rpRecordRegIntf(regMask,   varBit  DEBUGARG( "last use with partial enreg"));
        }

        tree->gtUsedRegs = regMask;
        goto RETURN_CHECK;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtGetOp2();

        GenTreePtr      opsPtr [3];
        regMaskTP       regsPtr[3];

        switch (oper)
        {
        case GT_ASG:

            /* Is the value being assigned into a LCL_VAR? */
            if  (op1->gtOper == GT_LCL_VAR)
            {
                varDsc = lvaTable + op1->gtLclVar.gtLclNum;

                /* Are we assigning a LCL_VAR the result of a call? */
                if  (op2->gtOper == GT_CALL)
                {
                    /* Set a preferred register for the LCL_VAR */
                    if (isRegPairType(varDsc->TypeGet()))
                        varDsc->addPrefReg(RBM_LNGRET, this);
                    else if (!varTypeIsFloating(varDsc->TypeGet()))
                        varDsc->addPrefReg(RBM_INTRET, this);
                    /*
                     *  When assigning the result of a call we don't
                     *  bother trying to target the right side of the
                     *  assignment, since we have a fixed calling convention.
                     */
                }
                else if (varDsc->lvTracked)
                {
                    varBit = genVarIndexToBit(varDsc->lvVarIndex);
                    /* Did we predict that this local will be fully enregistered? */
                    /* and it is dead on the right side of the assignment?  */
                    if  ((varDsc->lvRegNum != REG_STK) &&
                         ((type != TYP_LONG) || (varDsc->lvOtherReg != REG_STK)) &&
                         ((op2->gtLiveSet & varBit) == 0))
                    {
                        /*
                         *  Yes, we should try to target the right side of the
                         *  assignment into the tracked reg var
                         */
                        op1PredictReg = PREDICT_NONE; /* really PREDICT_REG, but we've already done the check */
                        op2PredictReg = rpGetPredictForVarIndex(varDsc->lvVarIndex);

                        // Add a variable interference from srcIndex to each of the last use variables
                        if (rpLastUseVars || rpUseInPlace)
                        {
                            rpRecordVarIntf(varDsc->lvVarIndex, 
                                            rpLastUseVars | rpUseInPlace
                                  DEBUGARG( "nested asgn conflict"));
                        }

                        goto ASG_COMMON;
                    }
                }
            }
            // Fall through

        case GT_CHS:

        case GT_ASG_OR:
        case GT_ASG_XOR:
        case GT_ASG_AND:
        case GT_ASG_SUB:
        case GT_ASG_ADD:
        case GT_ASG_MUL:
        case GT_ASG_DIV:
        case GT_ASG_UDIV:

            varBit = 0;
            /* We can't use "reg <op>= addr" for TYP_LONG or if op2 is a short type */
            if ((type != TYP_LONG) && !varTypeIsSmall(op2->gtType))
            {
                /* Is the value being assigned into an enregistered LCL_VAR? */
                /* For debug code we only allow a simple op2 to be assigned */
                if  ((op1->gtOper == GT_LCL_VAR) &&
                    (!opts.compDbgCode || rpCanAsgOperWithoutReg(op2, false)))
                {
                    varDsc = lvaTable + op1->gtLclVar.gtLclNum;
                    /* Did we predict that this local will be enregistered? */
                    if (varDsc->lvRegNum != REG_STK)
                    {
                        /* Yes, we can use "reg <op>= addr" */

                        op1PredictReg = PREDICT_NONE; /* really PREDICT_REG, but we've already done the check */
                        op2PredictReg = PREDICT_NONE;

                        goto ASG_COMMON;
                    }
                }
            }
            /*
             *  Otherwise, initialize the normal forcing of operands:
             *   "addr <op>= reg"
             */
            op1PredictReg = PREDICT_ADDR;
            op2PredictReg = PREDICT_REG;

ASG_COMMON:
            if (op2PredictReg != PREDICT_NONE)
            {
                /* Is the value being assigned a simple one? */
                if (rpCanAsgOperWithoutReg(op2, false))
                    op2PredictReg = PREDICT_NONE;
            }

            bool        simpleAssignment;
            regMaskTP   newRsvdRegs;
            
            simpleAssignment = false;
            newRsvdRegs      = RBM_NONE;

            if ((oper        == GT_ASG)         &&
                (op1->gtOper == GT_LCL_VAR))
            {                               
                // Add a variable interference from the assign target
                // to each of the last use variables
                if (rpLastUseVars)
                {
                    varDsc  = lvaTable + op1->gtLclVar.gtLclNum;
                    unsigned  varIndex = varDsc->lvVarIndex;
                    rpRecordVarIntf(varIndex, 
                                    rpLastUseVars
                          DEBUGARG( "Assign conflict"));
                }

                /*  Record whether this tree is a simple assignment to a local */

                simpleAssignment = ((type != TYP_LONG) || !opts.compDbgCode);
            }
            

            /* Byte-assignments need the byte registers, unless op1 is an enregistered local */

            if (varTypeIsByte(tree->TypeGet()) &&
                ((op1->gtOper != GT_LCL_VAR) || (lvaTable[op1->gtLclVar.gtLclNum].lvRegNum == REG_STK)))
            {
                newRsvdRegs = RBM_NON_BYTE_REGS;
            }

            /*  Are we supposed to evaluate RHS first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                op2Mask = rpPredictTreeRegUse(op2, op2PredictReg, lockedRegs,  rsvdRegs | op1->gtRsvdRegs | newRsvdRegs);

                /*
                 *  For a simple assignment we don't want the op2Mask to be
                 *  marked as interferring with the LCL_VAR, since it is likely
                 *  that we will want to enregister the LCL_VAR in exactly
                 *  the register that is used to compute op2
                 */
                tmpMask = lockedRegs;

                if  (!simpleAssignment)
                    tmpMask |= op2Mask;

                regMask = rpPredictTreeRegUse(op1, op1PredictReg, tmpMask, RBM_NONE);
            }
            else
            {
                // For the case of simpleAssignments op2 should always be evaluated first
                assert(!simpleAssignment);

                regMask = rpPredictTreeRegUse(op1, op1PredictReg, lockedRegs,  rsvdRegs | op2->gtRsvdRegs);
                op2Mask = rpPredictTreeRegUse(op2, op2PredictReg, lockedRegs | regMask, newRsvdRegs);
            }
            rpAsgVarNum = -1;

            if  (simpleAssignment)
            {
                /*
                 *  Consider a simple assignment to a local:
                 *
                 *   lcl = expr;
                 *
                 *  Since the "=" node is visited after the variable
                 *  is marked live (assuming it's live after the
                 *  assignment), we don't want to use the register
                 *  use mask of the "=" node but rather that of the
                 *  variable itself.
                 */
                tree->gtUsedRegs = op1->gtUsedRegs;
            }
            else
            {
                tree->gtUsedRegs = op1->gtUsedRegs | op2->gtUsedRegs;
            }

            if  (gcIsWriteBarrierAsgNode(tree))
            {
                /* Steer computation away from EDX as the pointer is
                   passed to the write-barrier call in EDX */

                tree->gtUsedRegs |= RBM_EDX;
                regMask = op2Mask;

                if (op1->gtOper == GT_IND)
                {
                    GenTreePtr  rv1, rv2;
                    unsigned    mul, cns;
                    bool        rev;

                    /* Special handling of indirect assigns for write barrier */

                    bool yes = genCreateAddrMode(op1->gtOp.gtOp1, -1, true, 0, &rev, &rv1, &rv2, &mul, &cns);

                    /* Check address mode for enregisterable locals */

                    if  (yes)
                    {
                        if  (rv1 != NULL && rv1->gtOper == GT_LCL_VAR)
                        {
                            rpPredictRefAssign(rv1->gtLclVar.gtLclNum);
                        }
                        if  (rv2 != NULL && rv2->gtOper == GT_LCL_VAR)
                        {
                            rpPredictRefAssign(rv2->gtLclVar.gtLclNum);
                        }
                    }
                }

                if  (op2->gtOper == GT_LCL_VAR)
                {
                    rpPredictRefAssign(op2->gtLclVar.gtLclNum);
                }
            }

            goto RETURN_CHECK;

        case GT_ASG_LSH:
        case GT_ASG_RSH:
        case GT_ASG_RSZ:
            /* assigning shift operators */

            assert(type != TYP_LONG);

            regMask = rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, rsvdRegs);

            /* shift count is handled same as ordinary shift */
            goto HANDLE_SHIFT_COUNT;

        case GT_ADDR:
        {
            rpPredictTreeRegUse(op1, PREDICT_ADDR, lockedRegs, RBM_LASTUSE);
            // Need to hold a scratch register for LEA instruction
            regMask = rpPredictRegPick(TYP_INT, predictReg, lockedRegs | rsvdRegs);
            tree->gtUsedRegs = op1->gtUsedRegs | regMask;
            goto RETURN_CHECK;
        }

        case GT_CAST:

            /* Cannot cast to VOID */
            assert(type != TYP_VOID);
                
            /* cast to long is special */
            if  (type == TYP_LONG && op1->gtType <= TYP_INT)
            {
                var_types   dstt = tree->gtCast.gtCastType;
                assert(dstt==TYP_LONG || dstt==TYP_ULONG);

                /* Too much work to special case tgt reg var here, so ignore it */

                if ((predictReg == PREDICT_NONE) || (predictReg >= PREDICT_REG_VAR_T00))
                    predictReg = PREDICT_SCRATCH_REG;

                regMask  = rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);
                // Now get one more reg
                regMask |= rpPredictRegPick(TYP_INT, PREDICT_REG, lockedRegs | rsvdRegs | regMask);
                tree->gtUsedRegs = op1->gtUsedRegs | regMask;
                goto RETURN_CHECK;
            }

            /* cast to float/double is special */
            if (varTypeIsFloating(type))
            {
                switch(op1->TypeGet())
                {
                /* uses fild, so don't need to be loaded to reg */
                case TYP_INT:
                case TYP_LONG:
                    
                    rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, rsvdRegs);
                    tree->gtUsedRegs = op1->gtUsedRegs;
                    regMask = 0;
                    goto RETURN_CHECK;
                }                
            }

            /* cast from long is special - it frees a register */
            if  (type <= TYP_INT && op1->gtType == TYP_LONG)
            {
                if ((predictReg == PREDICT_NONE) || (predictReg >= PREDICT_REG_VAR_T00))
                    predictReg = PREDICT_REG;

                regMask = rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);

                // If we have 2 or more regs, free one of them
                if (!genMaxOneBit(regMask))
                {
                    /* Clear the 2nd lowest bit in regMask */
                    /* First set tmpMask to the lowest bit in regMask */
                    tmpMask  = genFindLowestBit(regMask);
                    /* Next find the second lowest bit in regMask */
                    tmpMask  = genFindLowestBit(regMask & ~tmpMask);
                    /* Clear this bit from regmask */
                    regMask &= ~tmpMask;
                }
                tree->gtUsedRegs = op1->gtUsedRegs;
                goto RETURN_CHECK;
            }

            /* Casting from integral type to floating type is special */
            if (!varTypeIsFloating(type) && varTypeIsFloating(op1->TypeGet()))
            {
                assert(gtDblWasInt(op1));
                regMask = rpPredictRegPick(type, PREDICT_SCRATCH_REG, lockedRegs);
                tree->gtUsedRegs = regMask;
                goto RETURN_CHECK;
            }

            /* cast from (signed) byte is special - it uses byteable registers */
            if  (type == TYP_INT)
            {
                var_types smallType;

                if (genTypeSize(tree->gtCast.gtCastOp->TypeGet()) < genTypeSize(tree->gtCast.gtCastType))
                    smallType = tree->gtCast.gtCastOp->TypeGet();
                else
                    smallType = tree->gtCast.gtCastType;

                if (smallType == TYP_BYTE)
                {
                    regMask = rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);

                    if ((regMask & RBM_BYTE_REGS) == 0)
                        regMask = rpPredictRegPick(type, PREDICT_SCRATCH_REG, RBM_NON_BYTE_REGS);

                    tree->gtUsedRegs = regMask;
                    goto RETURN_CHECK;
                }
            }

            /* otherwise must load op1 into a register */
            goto GENERIC_UNARY;

#if INLINE_MATH
        case GT_MATH:
            if (tree->gtMath.gtMathFN==CORINFO_INTRINSIC_Round &&
                    tree->TypeGet()==TYP_INT)
            {
                // This is a special case to handle the following
                // optimization: conv.i4(round.d(d)) -> round.i(d) 
                // if flowgraph 3186

                // @TODO [CONSIDER] [04/16/01] [dnotario]: 
                // using another intrinsic in this optimization
                // or marking with a special flag. This type of special
                // cases is not good. dnotario
                if (predictReg <= PREDICT_REG)
                    predictReg = PREDICT_SCRATCH_REG;
                
                rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);

                regMask = rpPredictRegPick(TYP_INT, predictReg, lockedRegs | rsvdRegs);                

                tree->gtUsedRegs = op1->gtUsedRegs | regMask;
                goto RETURN_CHECK;                                
            }

            // Fall through
                 

#endif
        case GT_NOT:
        case GT_NEG:
            // these unary operators will write new values
            // and thus will need a scratch register

GENERIC_UNARY:
            /* generic unary operators */

            if (predictReg <= PREDICT_REG)
                predictReg = PREDICT_SCRATCH_REG;

        case GT_RET:
        case GT_NOP:
            // these unary operators do not write new values
            // and thus won't need a scratch register

#if INLINING || OPT_BOOL_OPS
            if  (!op1)
            {
                tree->gtUsedRegs = regMask = 0;
                goto RETURN_CHECK;
            }
#endif
            regMask = rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);
            tree->gtUsedRegs = op1->gtUsedRegs;
            goto RETURN_CHECK;

        case GT_IND:

            /* Codegen always forces indirections of TYP_LONG into registers */
            unsigned typeSize;     typeSize   = genTypeSize(type);
            bool     intoReg;

            if (predictReg == PREDICT_ADDR)
            {
                intoReg = false;
            }
            else if (predictReg == PREDICT_NONE)
            {
                if (typeSize <= sizeof(int))
                {
                   intoReg = false;
                }
                else
                {
                   intoReg    = true;
                   predictReg = PREDICT_REG;
                }
            }
            else
            {
                intoReg = true;
            }

            /* forcing to register? */
            if (intoReg && (type != TYP_LONG))
            {
                rsvdRegs |= RBM_LASTUSE;
            }
            
            GenTreePtr lenCSE; lenCSE = NULL;

#if CSELENGTH
            /* Some GT_IND have "secret" subtrees */

            if  (oper == GT_IND && (tree->gtFlags & GTF_IND_RNGCHK) &&
                 tree->gtInd.gtIndLen)
            {
                lenCSE = tree->gtInd.gtIndLen;

                assert(lenCSE->gtOper == GT_ARR_LENREF);

                lenCSE = lenCSE->gtArrLen.gtArrLenCse;

                if  (lenCSE)
                {
                    if  (lenCSE->gtOper == GT_COMMA)
                        lenCSE = lenCSE->gtOp.gtOp2;

                    assert(lenCSE->gtOper == GT_LCL_VAR);
                }
            }
#endif
            /* check for address mode */
            regMask = rpPredictAddressMode(op1, lockedRegs, rsvdRegs, lenCSE);

#if CSELENGTH
            /* Did we have a lenCSE ? */

            if  (lenCSE)
            {
                rpPredictTreeRegUse(lenCSE, PREDICT_REG, lockedRegs | regMask, rsvdRegs | RBM_LASTUSE);

                // Add a variable interference from the lenCSE variable 
                // to each of the last use variables
                if (rpLastUseVars)
                {
                    varDsc  = lvaTable + lenCSE->gtLclVar.gtLclNum;
                    unsigned  lenCSEIndex = varDsc->lvVarIndex;
                    rpRecordVarIntf(lenCSEIndex, 
                                    rpLastUseVars
                          DEBUGARG( "lenCSE conflict"));
                }
            }
#endif
            /* forcing to register? */
            if (intoReg)
            {
                tmpMask = lockedRegs | rsvdRegs;
                if (type == TYP_LONG)
                    tmpMask |= regMask;
                regMask = rpPredictRegPick(type, predictReg, tmpMask);
            }
            else if (predictReg != PREDICT_ADDR)
            {
                /* Unless the caller specified PREDICT_ADDR   */
                /* we don't return the temp registers used    */
                /* to form the address                        */
                regMask = RBM_NONE;
            }

            tree->gtUsedRegs = regMask;
            goto RETURN_CHECK;

        case GT_LOG0:
        case GT_LOG1:
            /* For SETE/SETNE (P6 only), we need an extra register */
            rpPredictTreeRegUse(op1,
                                (genCPU == 5) ? PREDICT_NONE
                                              : PREDICT_SCRATCH_REG,
                                lockedRegs,
                                RBM_NONE);
            regMask = rpPredictRegPick(type, predictReg, lockedRegs | rsvdRegs);
            tree->gtUsedRegs = op1->gtUsedRegs | regMask;
            goto RETURN_CHECK;

        case GT_EQ:
        case GT_NE:
        case GT_LT:
        case GT_LE:
        case GT_GE:
        case GT_GT:

            /* Floating point comparison uses EAX for flags */

            if  (varTypeIsFloating(op1->TypeGet()))
            {
                regMask = RBM_EAX;
            }
            else if (!(tree->gtFlags & GTF_RELOP_JMP_USED))
            {
                // Longs and float comparisons are converted to ?:
                assert(genActualType    (op1->TypeGet()) != TYP_LONG &&
                       varTypeIsFloating(op1->TypeGet()) == false);


                if (predictReg <= PREDICT_REG)
                    predictReg = PREDICT_SCRATCH_REG;

                // The set instructions need a byte register
                regMask = rpPredictRegPick(TYP_BYTE, predictReg, lockedRegs | rsvdRegs);
            }
            else
            {
                regMask = RBM_NONE;
                if (op1->gtOper == GT_CNS_INT)
                {
                    tmpMask = RBM_NONE;
                    if (op2->gtOper == GT_CNS_INT)
                        tmpMask = rpPredictTreeRegUse(op1, PREDICT_SCRATCH_REG, lockedRegs, rsvdRegs | op2->gtRsvdRegs);
                    rpPredictTreeRegUse(op2, PREDICT_NONE, lockedRegs | tmpMask, RBM_LASTUSE);
                    tree->gtUsedRegs = op2->gtUsedRegs;
                    goto RETURN_CHECK;
                }
                else if (op2->gtOper == GT_CNS_INT)
                {
                    rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, rsvdRegs);
                    tree->gtUsedRegs = op1->gtUsedRegs;
                    goto RETURN_CHECK;
                }
            }

            unsigned  op1TypeSize;
            unsigned  op2TypeSize;

            op1TypeSize = genTypeSize(op1->TypeGet());
            op2TypeSize = genTypeSize(op2->TypeGet());

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                if (op1TypeSize == sizeof(int))
                    predictReg = PREDICT_NONE;
                else
                    predictReg = PREDICT_REG;

                tmpMask = rpPredictTreeRegUse(op2, PREDICT_REG, lockedRegs,  rsvdRegs | op1->gtRsvdRegs);
                          rpPredictTreeRegUse(op1, predictReg,  lockedRegs | tmpMask, RBM_LASTUSE);
            }
            else
            {
                if (op2TypeSize == sizeof(int))
                    predictReg = PREDICT_NONE;
                else
                    predictReg = PREDICT_REG;

                tmpMask = rpPredictTreeRegUse(op1, PREDICT_REG, lockedRegs,  rsvdRegs | op2->gtRsvdRegs);
                          rpPredictTreeRegUse(op2, predictReg,  lockedRegs | tmpMask, RBM_LASTUSE);
            }

            tree->gtUsedRegs = regMask | op1->gtUsedRegs | op2->gtUsedRegs;
            goto RETURN_CHECK;

        case GT_MUL:

#if LONG_MATH_REGPARAM
        if  (type == TYP_LONG)
            goto LONG_MATH;
#endif
        if (type == TYP_LONG)
        {
            assert(tree->gtIsValid64RsltMul());

            /* look for any cast to Int node, and strip them out */

            if (op1->gtOper == GT_CAST)
                op1 = op1->gtCast.gtCastOp;

            if (op2->gtOper == GT_CAST)
                op2 = op2->gtCast.gtCastOp;

USE_MULT_EAX:
            // This will done by a 64-bit imul "imul eax, reg" 
            //   (i.e. EDX:EAX = EAX * reg)
            
            /* Are we supposed to evaluate op2 first? */
            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                rpPredictTreeRegUse(op2, PREDICT_REG_EAX, lockedRegs,  rsvdRegs | op1->gtRsvdRegs);
                rpPredictTreeRegUse(op1, PREDICT_REG,     lockedRegs | RBM_EAX, RBM_LASTUSE);
            }
            else
            {
                rpPredictTreeRegUse(op1, PREDICT_REG_EAX, lockedRegs,  rsvdRegs | op2->gtRsvdRegs);
                rpPredictTreeRegUse(op2, PREDICT_REG,     lockedRegs | RBM_EAX, RBM_LASTUSE);
            }

            /* set gtUsedRegs to EAX, EDX and the registers needed by op1 and op2 */

            tree->gtUsedRegs = RBM_EAX | RBM_EDX | op1->gtUsedRegs | op2->gtUsedRegs;

            /* set regMask to the set of held registers */

            regMask = RBM_EAX;

            if (type == TYP_LONG)
                regMask |= RBM_EDX;

            goto RETURN_CHECK;
        }
        else
        {
            /* We use imulEAX for most unsigned multiply operations */
            if (tree->gtOverflow())
            {
                if ((tree->gtFlags & GTF_UNSIGNED) ||
                    varTypeIsSmall(tree->TypeGet())  )
                {
                    goto USE_MULT_EAX;
                }
            }
        }

        case GT_OR:
        case GT_XOR:
        case GT_AND:

        case GT_SUB:
        case GT_ADD:
            tree->gtUsedRegs = 0;

            if (predictReg <= PREDICT_REG)
                predictReg = PREDICT_SCRATCH_REG;

GENERIC_BINARY:

            assert(op2);
            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                op1PredictReg = (genTypeSize(op1->gtType) >= sizeof(int)) ? PREDICT_NONE : PREDICT_REG;

                regMask = rpPredictTreeRegUse(op2, predictReg, lockedRegs, rsvdRegs | op1->gtRsvdRegs);
                          rpPredictTreeRegUse(op1, op1PredictReg, lockedRegs | regMask, RBM_LASTUSE);
            }
            else
            {
                op2PredictReg = (genTypeSize(op2->gtType) >= sizeof(int)) ? PREDICT_NONE : PREDICT_REG;                

                regMask = rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs | op2->gtRsvdRegs);
                          rpPredictTreeRegUse(op2, op2PredictReg, lockedRegs | regMask, RBM_LASTUSE);                          
            }
            tree->gtUsedRegs  = regMask | op1->gtUsedRegs | op2->gtUsedRegs;

            /* If the tree type is small, it must be an overflow instr.
               Special requirements for byte overflow instrs */

            if (varTypeIsByte(tree->TypeGet()))
            {
                assert(tree->gtOverflow());

                /* For 8 bit arithmetic, one operands has to be in a
                   byte-addressable register, and the other has to be
                   in a byte-addrble reg or in memory. Assume its in a reg */

                regMask = 0;
                if (!(op1->gtUsedRegs & RBM_BYTE_REGS))
                    regMask  = rpPredictRegPick(TYP_BYTE, PREDICT_REG, lockedRegs | rsvdRegs);
                if (!(op2->gtUsedRegs & RBM_BYTE_REGS))
                    regMask |= rpPredictRegPick(TYP_BYTE, PREDICT_REG, lockedRegs | rsvdRegs | regMask);

                tree->gtUsedRegs |= regMask;
            }
            goto RETURN_CHECK;

        case GT_DIV:
        case GT_MOD:

        case GT_UDIV:
        case GT_UMOD:

            /* non-integer division handled in generic way */
            if  (!varTypeIsIntegral(type))
            {
                tree->gtUsedRegs = 0;
                if (predictReg <= PREDICT_REG)
                    predictReg = PREDICT_SCRATCH_REG;
                goto GENERIC_BINARY;
            }

#if!LONG_MATH_REGPARAM
            if  (type == TYP_LONG && (oper == GT_MOD || oper == GT_UMOD))
            {
                /* Special case:  a mod with an int op2 is done inline using idiv or div
                   to avoid a costly call to the helper */

                assert((op2->gtOper == GT_CNS_LNG) &&
                       (op2->gtLngCon.gtLconVal == int(op2->gtLngCon.gtLconVal)));

                if (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    tmpMask  = rpPredictTreeRegUse(op2, PREDICT_REG, lockedRegs | RBM_EAX | RBM_EDX, rsvdRegs | op1->gtRsvdRegs);
                    tmpMask |= rpPredictTreeRegUse(op1, PREDICT_PAIR_EAXEDX, lockedRegs | tmpMask, RBM_LASTUSE);
                }
                else
                {
                    tmpMask  = rpPredictTreeRegUse(op1, PREDICT_PAIR_EAXEDX, lockedRegs, rsvdRegs | op2->gtRsvdRegs);
                    tmpMask |= rpPredictTreeRegUse(op2, PREDICT_REG, lockedRegs | tmpMask | RBM_EAX | RBM_EDX, RBM_LASTUSE);
                }
                
                regMask             = RBM_EAX | RBM_EDX;

                tree->gtUsedRegs    = regMask | 
                    op1->gtUsedRegs | 
                    op2->gtUsedRegs |
                    rpPredictRegPick(TYP_INT, PREDICT_SCRATCH_REG, regMask | tmpMask);

                goto RETURN_CHECK;
            }
#else
            if  (type == TYP_LONG)
            {
LONG_MATH:      /* LONG_MATH_REGPARAM case */

                assert(type == TYP_LONG);

                if  (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    rpPredictTreeRegUse(op2, PREDICT_PAIR_ECXEBX, lockedRegs,  rsvdRegs | op1->gtRsvdRegs);
                    rpPredictTreeRegUse(op1, PREDICT_PAIR_EAXEDX, lockedRegs | RBM_ECX | RBC_EBX, RBM_LASTUSE);
                }
                else
                {
                    rpPredictTreeRegUse(op1, PREDICT_PAIR_EAXEDX, lockedRegs,  rsvdRegs | op2->gtRsvdRegs);
                    rpPredictTreeRegUse(op2, PREDICT_PAIR_ECXEBX, lockedRegs | RBM_EAX | RBM_EDX, RBM_LASTUSE);
                }

                /* grab EAX, EDX for this tree node */

                regMask          |=  (RBM_EAX | RBM_EDX);

                tree->gtUsedRegs  = regMask  | (RBM_ECX | RBM_EBX);

                tree->gtUsedRegs |= op1->gtUsedRegs | op2->gtUsedRegs;
                
                regMask = RBM_EAX | RBM_EDX;

                goto RETURN_CHECK;
            }
#endif

            /* no divide immediate, so force integer constant which is not
             * a power of two to register
             */

            if (op2->gtOper == GT_CNS_INT)
            {
                long  ival = op2->gtIntCon.gtIconVal;

                /* Is the divisor a power of 2 ? */

                if (ival > 0 && genMaxOneBit(unsigned(ival)))
                {
                    goto GENERIC_UNARY;
                }
                else
                    op2PredictReg = PREDICT_SCRATCH_REG;
            }
            else
            {
                /* Non integer constant also must be enregistered */
                op2PredictReg = PREDICT_REG;
            }

            /*  Consider the case "a / b" - we'll need to trash EDX (via "CDQ") before
             *  we can safely allow the "b" value to die. Unfortunately, if we simply
             *  mark the node "b" as using EDX, this will not work if "b" is a register
             *  variable that dies with this particular reference. Thus, if we want to
             *  avoid this situation (where we would have to spill the variable from
             *  EDX to someplace else), we need to explicitly mark the interference
             *  of the variable at this point.
             */

            if (op2->gtOper == GT_LCL_VAR)
            {
                unsigned lclNum = op2->gtLclVar.gtLclNum;
                varDsc = lvaTable + lclNum;

#ifdef  DEBUG
                if  (verbose)
                {
                    if ((raLclRegIntf[REG_EAX] & genVarIndexToBit(varDsc->lvVarIndex)) == 0)
                        printf("Record interference between V%02u,T%02u and EAX -- int divide\n", 
                               lclNum, varDsc->lvVarIndex);
                    if ((raLclRegIntf[REG_EDX] & genVarIndexToBit(varDsc->lvVarIndex)) == 0)
                        printf("Record interference between V%02u,T%02u and EDX -- int divide\n", 
                               lclNum, varDsc->lvVarIndex);
                }
#endif
                raLclRegIntf[REG_EAX] |= genVarIndexToBit(varDsc->lvVarIndex);
                raLclRegIntf[REG_EDX] |= genVarIndexToBit(varDsc->lvVarIndex);
            }

            /* set the held register based on opcode */
            if (oper == GT_DIV || oper == GT_UDIV)
                regMask = RBM_EAX;
            else
                regMask = RBM_EDX;

            /* set the lvPref reg if possible */
            GenTreePtr dest;
            /*
             *  Walking the gtNext link twice from here should get us back
             *  to our parent node, if this is an simple assignment tree.
             */
            dest = tree->gtNext;
            if (dest         && (dest->gtOper == GT_LCL_VAR) &&
                dest->gtNext && (dest->gtNext->OperKind() & GTK_ASGOP) &&
                dest->gtNext->gtOp.gtOp2 == tree)
            {
                varDsc = lvaTable + dest->gtLclVar.gtLclNum;
                varDsc->addPrefReg(regMask, this);
            }

            op1PredictReg = PREDICT_REG_EDX;    /* Normally target op1 into EDX */

            /* are we supposed to evaluate op2 first? */
            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                tmpMask  = rpPredictTreeRegUse(op2, op2PredictReg, lockedRegs | RBM_EAX | RBM_EDX,  rsvdRegs | op1->gtRsvdRegs);
                rpPredictTreeRegUse(op1, op1PredictReg, lockedRegs | tmpMask, RBM_LASTUSE);
            }
            else
            {
                tmpMask  = rpPredictTreeRegUse(op1, op1PredictReg, lockedRegs,  rsvdRegs | op2->gtRsvdRegs);
                rpPredictTreeRegUse(op2, op2PredictReg, tmpMask | lockedRegs | RBM_EAX | RBM_EDX, RBM_LASTUSE);
            }

            /* grab EAX, EDX for this tree node */
            tree->gtUsedRegs  =  (RBM_EAX | RBM_EDX) | op1->gtUsedRegs | op2->gtUsedRegs;

            goto RETURN_CHECK;

        case GT_LSH:
        case GT_RSH:
        case GT_RSZ:

            if (predictReg <= PREDICT_REG)
                predictReg = PREDICT_SCRATCH_REG;

            if (type == TYP_LONG)
            {
                if  (op2->gtOper == GT_CNS_INT     &&
                     op2->gtIntCon.gtIconVal >= 0  &&
                     op2->gtIntCon.gtIconVal <= 32    )
                {
                    regMask = rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);
                    // no register used by op2
                    op2->gtUsedRegs  = 0;
                    tree->gtUsedRegs = op1->gtUsedRegs;
                }
                else
                {
                    // since EAX:EDX and ECX are hardwired we can't have then in the locked registers
                    tmpMask = lockedRegs & ~(RBM_EAX|RBM_EDX|RBM_ECX);

                    // op2 goes to ECX, op1 to the EAX:EDX pair
                    if  (tree->gtFlags & GTF_REVERSE_OPS)
                    {
                        rpPredictTreeRegUse(op2, PREDICT_REG_ECX,     tmpMask, RBM_NONE);
                        tmpMask |= RBM_ECX;
                        rpPredictTreeRegUse(op1, PREDICT_PAIR_EAXEDX, tmpMask, RBM_LASTUSE);
                    }
                    else
                    {
                        rpPredictTreeRegUse(op1, PREDICT_PAIR_EAXEDX, tmpMask, RBM_NONE);
                        tmpMask |= (RBM_EAX | RBM_EDX);
                        rpPredictTreeRegUse(op2, PREDICT_REG_ECX,     tmpMask, RBM_LASTUSE);
                    }
                    regMask           = (RBM_EAX | RBM_EDX);
                    op1->gtUsedRegs  |= (RBM_EAX | RBM_EDX);
                    op2->gtUsedRegs  |= RBM_ECX;
                    tree->gtUsedRegs  = op1->gtUsedRegs | op2->gtUsedRegs;
                }
            }
            else
            {
                if  (op2->gtOper != GT_CNS_INT)
                    regMask = rpPredictTreeRegUse(op1, PREDICT_NOT_REG_ECX, lockedRegs,  rsvdRegs | op2->gtRsvdRegs);
                else
                    regMask = rpPredictTreeRegUse(op1, predictReg,          lockedRegs,  rsvdRegs | op2->gtRsvdRegs);

        HANDLE_SHIFT_COUNT:
                /* this code is also used by assigning shift operators */
                if  (op2->gtOper != GT_CNS_INT)
                {
                    /* evaluate shift count into ECX */
                    rpPredictTreeRegUse(op2, PREDICT_REG_ECX, lockedRegs | regMask, RBM_LASTUSE);

                    /* grab ECX for this tree node */
                    tree->gtUsedRegs = RBM_ECX | op1->gtUsedRegs | op2->gtUsedRegs;

                    goto RETURN_CHECK;
                }
                tree->gtUsedRegs = op1->gtUsedRegs;
            }

            goto RETURN_CHECK;

        case GT_COMMA:
            if (tree->gtFlags & GTF_REVERSE_OPS)
            {
                if (predictReg == PREDICT_NONE)
                {
                    predictReg = PREDICT_REG;
                }
                else if (predictReg >= PREDICT_REG_VAR_T00)
                {
                    /* Don't propagate the use of tgt reg use in a GT_COMMA */
                    predictReg = PREDICT_SCRATCH_REG;
                }

                regMask = rpPredictTreeRegUse(op2, predictReg, lockedRegs, rsvdRegs);
                          rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs | regMask, RBM_LASTUSE);
            }   
            else
            {
                rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, RBM_LASTUSE);

                /* CodeGen will enregister the op2 side of a GT_COMMA */
                if (predictReg == PREDICT_NONE)
                {
                    predictReg = PREDICT_REG;
                }
                else if (predictReg >= PREDICT_REG_VAR_T00)
                {
                    /* Don't propagate the use of tgt reg use in a GT_COMMA */
                    predictReg = PREDICT_SCRATCH_REG;
                }

                regMask = rpPredictTreeRegUse(op2, predictReg, lockedRegs, rsvdRegs);                          
            }

            tree->gtUsedRegs = op1->gtUsedRegs | op2->gtUsedRegs;
            if ((op2->gtOper == GT_LCL_VAR) && (rsvdRegs != 0))
            {
                LclVarDsc *   varDsc = lvaTable + op2->gtLclVar.gtLclNum;
                
                if (varDsc->lvTracked)
                {
                    VARSET_TP varBit = genVarIndexToBit(varDsc->lvVarIndex);
                    rpRecordRegIntf(rsvdRegs, varBit  DEBUGARG( "comma use"));
                }
            }
            goto RETURN_CHECK;

        case GT_QMARK:
            assert(op1 != NULL && op2 != NULL);

            /*
             *  If the gtUsedRegs conflicts with lockedRegs 
             *  then we going to have to spill some registers
             *  into the non-trashed register set to keep it alive
             */
            unsigned spillCnt;    spillCnt = 0;

            while (lockedRegs)
            {
#ifdef  DEBUG
                /* Find the next register that needs to be spilled */
                tmpMask = genFindLowestBit(lockedRegs);

                if (verbose)
                {
                    printf("Predict spill  of   %s before: ", 
                           getRegName(genRegNumFromMask(tmpMask)));
                    gtDispTree(tree, 0, NULL, true);
                }
#endif
                /* In Codegen it will typically introduce a spill temp here */
                /* rather than relocating the register to a non trashed reg */
                rpPredictSpillCnt++;
                spillCnt++;

                /* Remove it from the lockedRegs */
                lockedRegs &= ~genFindLowestBit(lockedRegs);
            }

            /* Evaluate the <cond> subtree */
            rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, RBM_LASTUSE);

            tree->gtUsedRegs = op1->gtUsedRegs;

            assert(op2->gtOper == GT_COLON);

            op1 = op2->gtOp.gtOp1;
            op2 = op2->gtOp.gtOp2;

            assert(op1 != NULL && op2 != NULL);

            if (type == TYP_VOID)
            {
                /* Evaluate the <then> subtree */
                rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, RBM_LASTUSE);
                regMask    = RBM_NONE;
                predictReg = PREDICT_NONE;
            }
            else
            {
                /* Evaluate the <then> subtree */
                regMask    = rpPredictTreeRegUse(op1, PREDICT_SCRATCH_REG, lockedRegs, RBM_LASTUSE);
                predictReg = rpGetPredictForMask(regMask);
            }

            /* Evaluate the <else> subtree */
            rpPredictTreeRegUse(op2, predictReg, lockedRegs, RBM_LASTUSE);

            tree->gtUsedRegs |= op1->gtUsedRegs | op2->gtUsedRegs;

            if (spillCnt > 0)
            {
                regMaskTP reloadMask = RBM_NONE;

                while (spillCnt)
                {
                    regMaskTP reloadReg;

                    /* Get an extra register to hold it */
                    reloadReg = rpPredictRegPick(TYP_INT, PREDICT_REG, 
                                                 lockedRegs | regMask | reloadMask);
#ifdef  DEBUG
                    if (verbose)
                    {
                        printf("Predict reload into %s after : ", 
                               getRegName(genRegNumFromMask(reloadReg)));
                        gtDispTree(tree, 0, NULL, true);
                    }
#endif
                    reloadMask |= reloadReg;

                    spillCnt--;
                }

                /* update the gtUsedRegs mask */
                tree->gtUsedRegs |= reloadMask;
            }

            goto RETURN_CHECK;

        case GT_RETURN:
            tree->gtUsedRegs = regMask = RBM_NONE;

            /* Is there a return value? */
            if  (op1 != NULL)
            {
                /* Is the value being returned a simple LCL_VAR? */
                if (op1->gtOper == GT_LCL_VAR)
                {
                    varDsc = lvaTable + op1->gtLclVar.gtLclNum;

                    /* Set a preferred register for the LCL_VAR */
                    if (isRegPairType(varDsc->lvType))
                        varDsc->addPrefReg(RBM_LNGRET, this);
                    else if (!varTypeIsFloating(varDsc->TypeGet()))
                        varDsc->addPrefReg(RBM_INTRET, this);
                }
                if (isRegPairType(type))
                {
                    predictReg = PREDICT_PAIR_EAXEDX;
                    regMask    = RBM_LNGRET;
                }
                else
                {
                    predictReg = PREDICT_REG_EAX;
                    regMask    = RBM_INTRET;
                }
                rpPredictTreeRegUse(op1, predictReg, lockedRegs, RBM_LASTUSE);
                tree->gtUsedRegs = op1->gtUsedRegs | regMask;
            }
            goto RETURN_CHECK;

        case GT_BB_COLON:
        case GT_RETFILT:
            if (op1 != NULL)
            {
                rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, RBM_LASTUSE);
                regMask = genTypeToReturnReg(type);
                tree->gtUsedRegs = op1->gtUsedRegs | regMask;
                goto RETURN_CHECK;
            }
            tree->gtUsedRegs = regMask = 0;

            goto RETURN_CHECK;

        case GT_JTRUE:
            /* This must be a test of a relational operator */

            /* TODO: What if op1 is a comma operator? */
            assert(op1->OperIsCompare());

            /* Only condition code set by this operation */

            rpPredictTreeRegUse(op1, PREDICT_NONE, lockedRegs, RBM_NONE);

            tree->gtUsedRegs = op1->gtUsedRegs;
            regMask = 0;

            goto RETURN_CHECK;

        case GT_SWITCH:
            assert(type <= TYP_INT);
            rpPredictTreeRegUse(op1, PREDICT_REG, lockedRegs, RBM_NONE);
            tree->gtUsedRegs = op1->gtUsedRegs;
            regMask = 0;
            goto RETURN_CHECK;

        case GT_CKFINITE:
            if (predictReg <= PREDICT_REG)
                predictReg = PREDICT_SCRATCH_REG;

            rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);
            // Need a reg to load exponent into
            regMask = rpPredictRegPick(TYP_INT, PREDICT_SCRATCH_REG, lockedRegs | rsvdRegs);
            tree->gtUsedRegs = regMask | op1->gtUsedRegs;
            goto RETURN_CHECK;

        case GT_LCLHEAP:
            if (info.compInitMem)
            {
                tmpMask = rpPredictTreeRegUse(op1,  PREDICT_NOT_REG_ECX, lockedRegs, rsvdRegs);
                regMask = RBM_ECX;
                op2Mask = RBM_NONE;
            }
            else
            {
                tmpMask = rpPredictTreeRegUse(op1,  PREDICT_NONE,        lockedRegs, rsvdRegs);
                regMask = rpPredictRegPick(TYP_INT, PREDICT_SCRATCH_REG, lockedRegs | rsvdRegs | tmpMask);
                /* HACK: Since the emitter tries to track ESP adjustments,
                   we need an extra register to decrement ESP indirectly */
                op2Mask = rpPredictRegPick(TYP_INT,    PREDICT_SCRATCH_REG, lockedRegs | rsvdRegs | tmpMask | regMask);
            }

            op1->gtUsedRegs  |= regMask;
            tree->gtUsedRegs  = op1->gtUsedRegs | op2Mask;

            // The result will be put in the reg we picked for the size
            // regMask = <already set as we want it to be>

            goto RETURN_CHECK;

        case GT_INITBLK:
        case GT_COPYBLK:

            /* For COPYBLK & INITBLK we have special treatment for
               for constant lengths.
             */
            regMask = 0;
            assert(op2);
            if ((op2->OperGet() == GT_CNS_INT) &&
                ((oper == GT_INITBLK && (op1->gtOp.gtOp2->OperGet() == GT_CNS_INT)) ||
                 (oper == GT_COPYBLK && (op2->gtFlags & GTF_ICON_HDL_MASK) != GTF_ICON_CLASS_HDL)))
            {
                unsigned length = (unsigned) op2->gtIntCon.gtIconVal;

                if (length <= 16 && compCodeOpt() != SMALL_CODE)
                {
                    op2Mask = ((oper == GT_INITBLK)? RBM_EAX : RBM_ESI);

                    if (op1->gtFlags & GTF_REVERSE_OPS)
                    {
                        regMask |= rpPredictTreeRegUse(op1->gtOp.gtOp2, PREDICT_NONE, lockedRegs, RBM_LASTUSE);
                        regMask |= op2Mask;
                        op1->gtOp.gtOp2->gtUsedRegs |= op2Mask;

                        regMask |= rpPredictTreeRegUse(op1->gtOp.gtOp1, PREDICT_REG_EDI, lockedRegs | regMask, RBM_NONE);
                        regMask |= RBM_EDI;
                        op1->gtOp.gtOp1->gtUsedRegs |= RBM_EDI;
                    }
                    else
                    {
                        regMask |= rpPredictTreeRegUse(op1->gtOp.gtOp1, PREDICT_REG_EDI, lockedRegs, RBM_LASTUSE);
                        regMask |= RBM_EDI;
                        op1->gtOp.gtOp1->gtUsedRegs |= RBM_EDI;

                        regMask |= rpPredictTreeRegUse(op1->gtOp.gtOp2, PREDICT_NONE, lockedRegs | regMask, RBM_NONE);
                        regMask |= op2Mask;
                        op1->gtOp.gtOp2->gtUsedRegs |= op2Mask;
                    }

                    tree->gtUsedRegs = op1->gtOp.gtOp1->gtUsedRegs |
                                       op1->gtOp.gtOp2->gtUsedRegs |
                                       regMask;

                    regMask = 0;

                    goto RETURN_CHECK;
                }
            }
            // What order should the Dest, Val/Src, and Size be calculated

            fgOrderBlockOps(tree,
                    RBM_EDI, (oper == GT_INITBLK) ? RBM_EAX : RBM_ESI, RBM_ECX,
                    opsPtr, regsPtr);

            regMask |= rpPredictTreeRegUse(opsPtr[0],
                                           rpGetPredictForMask(regsPtr[0]),
                                           lockedRegs, RBM_LASTUSE);
            regMask |= regsPtr[0];
            opsPtr[0]->gtUsedRegs |= regsPtr[0];

            regMask |= rpPredictTreeRegUse(opsPtr[1],
                                           rpGetPredictForMask(regsPtr[1]),
                                           lockedRegs | regMask, RBM_LASTUSE);
            regMask |= regsPtr[1];
            opsPtr[1]->gtUsedRegs |= regsPtr[1];

            regMask |= rpPredictTreeRegUse(opsPtr[2],
                                           rpGetPredictForMask(regsPtr[2]),
                                           lockedRegs | regMask, RBM_NONE);
            regMask |= regsPtr[2];
            opsPtr[2]->gtUsedRegs |= regsPtr[2];

            tree->gtUsedRegs = opsPtr[0]->gtUsedRegs |
                               opsPtr[1]->gtUsedRegs |
                               opsPtr[2]->gtUsedRegs |
                               regMask;
            regMask = 0;

            goto RETURN_CHECK;


        case GT_LDOBJ:
            goto GENERIC_UNARY;

        case GT_MKREFANY:
            goto GENERIC_BINARY;

        case GT_VIRT_FTN:

            if (predictReg <= PREDICT_REG)
                predictReg = PREDICT_SCRATCH_REG;

            regMask = rpPredictTreeRegUse(op1, predictReg, lockedRegs, rsvdRegs);
            tree->gtUsedRegs = regMask;

            goto RETURN_CHECK;

        case GT_JMPI:
            /* We need EAX to evaluate the function pointer */
            tree->gtUsedRegs = regMask = RBM_EAX;
            goto RETURN_CHECK;

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected simple operator in reg use prediction");
            break;
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        GenTreePtr      args;
        GenTreePtr      list;
        GenTreePtr      realThis;
        regMaskTP       keepMask;
        unsigned        regArgsNum;
        unsigned        i;
        unsigned        regIndex;
        regMaskTP       regArgMask;

        struct tag_regArgTab
        {
            GenTreePtr  node;
            regNumber   regNum;
        } regArgTab[MAX_REG_ARG];

    case GT_CALL:

        /* initialize so we can just or in various bits */
        tree->gtUsedRegs = RBM_NONE;
        realThis         = NULL;


#if GTF_CALL_REG_SAVE
        /*
         *  Unless the GTF_CALL_REG_SAVE flag is set
         *  we can't preserved the RBM_CALLEE_TRASH registers
         *  (likewise we can't preserve the return registers)
         *  So we remove them from the lockedRegs set and
         *  record any of them in the keepMask
         */

        if  (tree->gtFlags & GTF_CALL_REG_SAVE)
        {
            regMaskTP trashMask = genTypeToReturnReg(type);

            keepMask    = lockedRegs & trashMask;
            lockedRegs &= ~trashMask;
        }
        else
#endif
        {
            keepMask    = lockedRegs & RBM_CALLEE_TRASH;
            lockedRegs &= ~RBM_CALLEE_TRASH;
        }

        regArgsNum = 0;
        regIndex   = 0;

        /* Construct the "shuffled" argument table */

        unsigned   shiftMask;   shiftMask  = tree->gtCall.regArgEncode;
        bool       hasThisArg;  hasThisArg = false;
        GenTreePtr unwrapArg;   unwrapArg  = NULL;

        for (list = tree->gtCall.gtCallRegArgs, regIndex = 0; 
             list; 
             regIndex++, shiftMask >>= 4)
        {
TOP:
            args = list;
            if  (args->gtOper == GT_LIST)
            {
                args = list->gtOp.gtOp1;
                list = list->gtOp.gtOp2;
            }
            else
            {
                list = 0;
            }

            regNumber regNum = (regNumber)(shiftMask & 0x000F);
            
            if (regNum == REG_EAX)
            {
                assert(unwrapArg == NULL);
                unwrapArg = args;
                if (list == NULL)
                    break;
                else
                    goto TOP;
            }

            assert(regIndex < MAX_REG_ARG);

            regArgTab[regIndex].node   = args;
            regArgTab[regIndex].regNum = regNum;

            /* the this pointer is passed in REG_ARG_0 */
            if (regNum == REG_ARG_0)
                hasThisArg = impIsThis(args);

        }

        assert(list == NULL);

        // An optimization for Contextful classes:
        // we may unwrap the proxy when we have a 'this reference'
        if (hasThisArg && unwrapArg)
        {
            realThis = unwrapArg;
        }

        /* Is there an object pointer? */
        if  (tree->gtCall.gtCallObjp)
        {
            /* Evaluate the instance pointer first */

            args = tree->gtCall.gtCallObjp;
            if (!gtIsaNothingNode(args))
            {
                rpPredictTreeRegUse(args, PREDICT_NONE, lockedRegs, RBM_LASTUSE);
            }

            /* the objPtr always goes to a register (through temp or directly) */
            assert(regArgsNum == 0);
            regArgsNum++;

            /* Must be passed in a register */

            assert(args->gtFlags & GTF_REG_ARG);

            /* Must be either a NOP node or a GT_ASG node */

            assert(gtIsaNothingNode(args) || (args->gtOper == GT_ASG));
        }

        /* process argument list */
        for (list = tree->gtCall.gtCallArgs; list; )
        {
            args = list;
            if  (args->gtOper == GT_LIST)
            {
                args = list->gtOp.gtOp1;
                list = list->gtOp.gtOp2;
            }
            else
            {
                list = 0;
            }

            if (args->gtFlags & GTF_REG_ARG)
            {
                /* Must be either a NOP node or a GT_ASG node */

                assert(gtIsaNothingNode(args) || (args->gtOper == GT_ASG));

                assert(regArgsNum < MAX_REG_ARG);

                if (!gtIsaNothingNode(args))
                {
                    rpPredictTreeRegUse(args, PREDICT_NONE, lockedRegs, RBM_LASTUSE);
                }

                regArgsNum++;
            }
            else
            {
                /* We'll generate a push for this argument */

                predictReg = PREDICT_NONE;
                if (varTypeIsSmall(args->TypeGet()))
                {
                    /* We may need to sign or zero extend a small type using a register */
                    predictReg = PREDICT_SCRATCH_REG;
                }

                rpPredictTreeRegUse(args, predictReg, lockedRegs, RBM_LASTUSE);
            }

            tree->gtUsedRegs |= args->gtUsedRegs;
        }

        /* Is there a register argument list */

        assert (regArgsNum <= MAX_REG_ARG);
        assert (regArgsNum == regIndex);

        regArgMask = 0;

        for (i = 0; i < regArgsNum; i++)
        {
            args = regArgTab[i].node;

            tmpMask = genRegMask(regArgTab[i].regNum);

            if (args->gtOper == GT_LCL_VAR)
            {
                // Set lvPrefReg to match the out-going register arg
                varDsc = lvaTable + args->gtLclVar.gtLclNum;
                varDsc->addPrefReg(tmpMask, this);
            }

            /* Target ECX or EDX */
            rpPredictTreeRegUse(args,
                                rpGetPredictForReg(regArgTab[i].regNum),
                                lockedRegs | regArgMask, RBM_LASTUSE);

            regArgMask       |= tmpMask;

            args->gtUsedRegs |= tmpMask;

            tree->gtUsedRegs |= args->gtUsedRegs;

            tree->gtCall.gtCallRegArgs->gtUsedRegs |= args->gtUsedRegs;
        }

        if (tree->gtCall.gtCallType == CT_INDIRECT)
        {
            args = tree->gtCall.gtCallAddr;
            predictReg = PREDICT_REG_EAX;

            /* EAX should be available here */
            assert(((lockedRegs|regArgMask) & genRegMask(REG_EAX)) == 0);

            /* Do not use the argument registers */
            tree->gtUsedRegs |= rpPredictTreeRegUse(args, predictReg, lockedRegs | regArgMask, RBM_LASTUSE);
        }

        if (realThis)
        {
            args = realThis;
            predictReg = PREDICT_REG_EAX;

            tmpMask = lockedRegs | regArgMask;

            /* EAX should be available here */
            assert((tmpMask & genRegMask(REG_EAX)) == 0);

            /* Do not use the argument registers */
            tree->gtUsedRegs |= rpPredictTreeRegUse(args, predictReg, tmpMask, RBM_LASTUSE);
        }

        /* After the call restore the orginal value of lockedRegs */
        lockedRegs |= keepMask;

        /* set the return register */
        regMask = genTypeToReturnReg(type);

        /* the return registers (if any) are killed */
        tree->gtUsedRegs |= regMask;

#if GTF_CALL_REG_SAVE
        if  (!(tree->gtFlags & GTF_CALL_REG_SAVE))
#endif
        {
            /* the RBM_CALLEE_TRASH set are killed (i.e. EAX,ECX,EDX) */
            tree->gtUsedRegs |= RBM_CALLEE_TRASH;
        }

        break;

#if CSELENGTH

    case GT_ARR_LENREF:
        if  (tree->gtFlags & GTF_ALN_CSEVAL)
        {
            assert(predictReg == PREDICT_NONE);

            /* check for address mode */
            rpPredictAddressMode(tree->gtArrLen.gtArrLenAdr, lockedRegs, RBM_LASTUSE, NULL);

            tree->gtUsedRegs = regMask = RBM_NONE;
        }
        break;

#endif

    case GT_ARR_ELEM:

        // Figure out which registers cant be touched
        for (unsigned dim = 0; dim < tree->gtArrElem.gtArrRank; dim++)
            rsvdRegs |= tree->gtArrElem.gtArrInds[dim]->gtRsvdRegs;

        regMask = rpPredictTreeRegUse(tree->gtArrElem.gtArrObj, PREDICT_REG, lockedRegs, rsvdRegs);

        regMaskTP dimsMask; dimsMask = 0;

        for (dim = 0; dim < tree->gtArrElem.gtArrRank; dim++)
        {
            /* We need scratch registers to compute index-lower_bound.
               Also, gtArrInds[0]'s register will be used as the second
               addressability register (besides gtArrObj's) */

            regMaskTP dimMask = rpPredictTreeRegUse(tree->gtArrElem.gtArrInds[dim], PREDICT_SCRATCH_REG, lockedRegs|regMask|dimsMask, rsvdRegs);
            if (dim == 0)
                regMask |= dimMask;
            dimsMask |= dimMask;
        }

#if TGT_x86
        // INS_imul doesnt have an immediate constant.
        if (!jitIsScaleIndexMul(tree->gtArrElem.gtArrElemSize))
            rpPredictRegPick(TYP_INT, PREDICT_SCRATCH_REG, lockedRegs|regMask|dimsMask);
#endif
        tree->gtUsedRegs = regMask;
        break;

    default:
        NO_WAY("unexpected special operator in reg use prediction");
        break;
    }

RETURN_CHECK:

#ifdef DEBUG
    /* make sure we set them to something reasonable */
    if (tree->gtUsedRegs & RBM_ILLEGAL)
        assert(!"used regs not set properly in reg use prediction");

    if (regMask & RBM_ILLEGAL)
        assert(!"return value not set propery in reg use prediction");

#endif

    /*
     *  If the gtUsedRegs conflicts with lockedRegs 
     *  then we going to have to spill some registers
     *  into the non-trashed register set to keep it alive
     */
    regMaskTP spillMask;
    spillMask = tree->gtUsedRegs & lockedRegs;

    if (spillMask)
    {
        while (spillMask)
        {
#ifdef  DEBUG
            /* Find the next register that needs to be spilled */
            tmpMask = genFindLowestBit(spillMask);

            if (verbose)
            {
                printf("Predict spill  of   %s before: ", 
                       getRegName(genRegNumFromMask(tmpMask)));
                gtDispTree(tree, 0, NULL, true);
                if ((tmpMask & regMask) == 0)
                {
                    printf("Predict reload of   %s after : ", 
                           getRegName(genRegNumFromMask(tmpMask)));
                    gtDispTree(tree, 0, NULL, true);
                }
            }
#endif
            /* In Codegen it will typically introduce a spill temp here */
            /* rather than relocating the register to a non trashed reg */
            rpPredictSpillCnt++;

            /* Remove it from the spillMask */
            spillMask &= ~genFindLowestBit(spillMask);
        }
    }

    /*
     *  If the return registers in regMask conflicts with the lockedRegs 
     *  then we allocate extra registers for the reload of the conflicting 
     *  registers
     *
     *  Set spillMask to the set of locked registers that have to be reloaded here
     *  reloadMask is set to the extar registers that are used to reload 
     *   the spilled lockedRegs
     */

    spillMask = lockedRegs & regMask;

    if (spillMask)
    {
        /* Remove the spillMask from regMask */
        regMask &= ~spillMask;

        regMaskTP reloadMask = RBM_NONE;
        while (spillMask)
        {
            regMaskTP reloadReg;

            /* Get an extra register to hold it */
            reloadReg = rpPredictRegPick(TYP_INT, PREDICT_REG, 
                                         lockedRegs | regMask | reloadMask);
#ifdef  DEBUG
            if (verbose)
            {
                printf("Predict reload into %s after : ", 
                       getRegName(genRegNumFromMask(reloadReg)));
                gtDispTree(tree, 0, NULL, true);
            }
#endif
            reloadMask |= reloadReg;

            /* Remove it from the spillMask */
            spillMask &= ~genFindLowestBit(spillMask);
        }

        /* Update regMask to use the reloadMask */
        regMask |= reloadMask;

        /* update the gtUsedRegs mask */
        tree->gtUsedRegs |= regMask;
    }

    VARSET_TP   life   = tree->gtLiveSet;
    regMaskTP   regUse = tree->gtUsedRegs;

    rpUseInPlace &= life;

    if (life)
    {
#if TGT_x86
        // Add interference between the current set of life variables and
        //  the set of temporary registers need to evaluate the sub tree
        if (regUse)
        {
            rpRecordRegIntf(regUse, life  DEBUGARG( "tmp use"));
        }

        /* Will the FP stack be non-empty at this point? */

        if  (tree->gtFPlvl)
        {
            /*
                Any variables that are live at this point
                cannot be enregistered at or above this
                stack level.
            */

          if (tree->gtFPlvl < FP_STK_SIZE)
              raFPlvlLife[tree->gtFPlvl] |= life;
          else
              raFPlvlLife[FP_STK_SIZE-1] |= life;
        }

#else
        if (regUse)
        {
            for (unsigned rnum = 0; rnum < regUse; rnum++)
                raLclRegIntf[rnum] |= life;

            if  (regInt && life)
                raMarkRegSetIntf(life, regInt);

        }
#endif
    }

    // Add interference between the current set of life variables and
    //  the assignment target variable
    if (regUse && (rpAsgVarNum != -1))
    {
        rpRecordRegIntf(regUse, genVarIndexToBit(rpAsgVarNum)  DEBUGARG( "tgt var tmp use"));
    }         

    /* Do we need to resore the oldLastUseVars value */
    if (restoreLastUseVars && (rpLastUseVars != oldLastUseVars))
    {
        /*
         *  If we used a GT_ASG targeted register then we need to add
         *  a variable interference between any new last use variables
         *  and the GT_ASG targeted register
         */
        if (rpAsgVarNum != -1)
        {
            rpRecordVarIntf(rpAsgVarNum, 
                            (rpLastUseVars & ~oldLastUseVars)
                  DEBUGARG( "asgn conflict"));
        }         
        rpLastUseVars = oldLastUseVars;
    }

    return regMask;
}

/*****************************************************************************
 *
 *  Predict which variables will be assigned to registers
 *  This is x86 specific and only predicts the integer registers and
 *  must be conservative, any register that is predicted to be enregister
 *  must end up being enregistered.
 *
 *  The rpPredictTreeRegUse takes advantage of the LCL_VARS that are
 *  predicted to be enregistered to minimize calls to rpPredictRegPick.
 *
 */

regMaskTP Compiler::rpPredictAssignRegVars(regMaskTP regAvail)
{
    /* We cannot change the lvVarIndexes at this point, so we  */
    /* can only re-order the existing set of tracked variables */
    /* Which will change the order in which we select the      */
    /* locals for enregistering.                               */

    if (lvaSortAgain)
        lvaSortOnly();

#ifdef DEBUG
    fgDebugCheckBBlist();
#endif

    unsigned   regInx;

    if (rpPasses <= rpPassesPessimize)
    {
        // Assume that we won't have to reverse EBP enregistration
        rpReverseEBPenreg = false;

        // Assuming that we don't need to double align the frame 
        // set the default rpFrameType based upon genFPreqd 
        if (genFPreqd)
            rpFrameType = FT_EBP_FRAME;
        else
            rpFrameType = FT_ESP_FRAME;
    }

    if (regAvail == RBM_NONE)
    {
        unsigned      lclNum;
        LclVarDsc *   varDsc;

        for (lclNum = 0, varDsc = lvaTable;
             lclNum < lvaCount;
             lclNum++, varDsc++)
        {
            varDsc->lvRegNum = REG_STK;
            if (isRegPairType(varDsc->lvType))
                varDsc->lvOtherReg = REG_STK;
        }

        return RBM_NONE;
    }

    /* Initialize the weighted count of variables that could have */
    /* been enregistered but weren't */
    rpStkPredict        = 0;
    rpPredictAssignMask = regAvail;

    unsigned    refCntStk       = 0; // sum of     ref counts for all stack based variables
    unsigned    refCntEBP       = 0; // sum of     ref counts for EBP enregistered variables
    unsigned    refCntWtdEBP    = 0; // sum of wtd ref counts for EBP enregistered variables
#if DOUBLE_ALIGN
    unsigned    refCntStkParam  = 0; // sum of     ref counts for all stack based parameters
    unsigned    refCntWtdStkDbl = 0; // sum of wtd ref counts for stack based doubles
#endif

    /* Set of registers used to enregister variables in the predition */
    regMaskTP   regUsed         = RBM_NONE;

    regMaskTP   avoidArgRegMask = raAvoidArgRegMask;

    /*-------------------------------------------------------------------------
     *
     *  Predict/Assign the enregistered locals in ref-count order
     *
     */

    unsigned      FPRegVarLiveInCnt   = 0;      // How many enregistered doubles are live on entry to the method

    LclVarDsc *   varDsc;

    for (unsigned sortNum = 0; sortNum < lvaCount; sortNum++)
    {
        varDsc   = lvaRefSorted[sortNum];

        /* Check the set of invariant things that would prevent enregistration */

        /* Ignore the variable if it's not tracked */

        if  (!varDsc->lvTracked)
            goto CANT_REG;

        /* Skip the variable if it's marked as 'volatile' */

        if  (varDsc->lvVolatile)
            goto CANT_REG;

        /* UNDONE: For now if we have JMP or JMPI all register args go to stack
         * UNDONE: Later consider extending the life of the argument or make a copy of it */

        if  (compJmpOpUsed && varDsc->lvIsRegArg)
            goto CANT_REG;

        /* Skip the variable if the ref count is zero */

        if (varDsc->lvRefCnt == 0)
            goto CANT_REG;

        /* Is the unweighted ref count too low to be interesting? */

        if  (varDsc->lvRefCnt <= 1)
        {

            /* Sometimes it's useful to enregister a variable with only one use */
            /*   arguments referenced in loops are one example */

            if (varDsc->lvIsParam && varDsc->lvRefCntWtd > BB_UNITY_WEIGHT)
                goto OK_TO_ENREGISTER;

            /* If the variable has a preferred register set it may be useful to put it there */
            if (varDsc->lvPrefReg && varDsc->lvIsRegArg)
                goto OK_TO_ENREGISTER;

            /* Keep going; the table is sorted by "weighted" ref count */
            goto CANT_REG;
        }

OK_TO_ENREGISTER:

        /* Get hold of the index and the interference mask for the variable */

        unsigned     varIndex;  varIndex = varDsc->lvVarIndex;
        VARSET_TP    varBit;    varBit   = genVarIndexToBit(varIndex);

        if (varTypeIsFloating(varDsc->TypeGet()))
        {

#if CPU_HAS_FP_SUPPORT
            /* For the first pass only we try to enregister this FP var     */
            /* Is this a floating-point variable that we can enregister?    */
            /* Don't enregister floating point vars if fJitNoFPRegLoc.val() is set */
            /* Don't enregister if code speed is not important */
            if(   (rpPasses == 0)                           &&
                  (isFloatRegType(varDsc->lvType))          &&
#ifdef  DEBUG
                 !(fJitNoFPRegLoc.val()) &&
#endif
                 !(opts.compDbgCode || opts.compMinOptim)      )
            {
                if (raEnregisterFPvar(varDsc, &FPRegVarLiveInCnt))
                    continue;
            }
#endif  // CPU_HAS_FP_SUPPORT
            if (varDsc->lvRegister)
                goto ENREG_VAR;
            else
                goto CANT_REG;
        }

        /* If we don't have any integer registers available then skip the enregistration attempt */
        if (regAvail == RBM_NONE)
            goto NO_REG;

        // On the pessimize passes don't even try to enregister LONGS 
        if  (isRegPairType(varDsc->lvType))
        {
            if (rpPasses > rpPassesPessimize)
               goto NO_REG;
            else if (rpLostEnreg && (rpPasses == rpPassesPessimize))
               goto NO_REG;
        }

        // Set of registers to avoid when performing register allocation
        regMaskTP  avoidReg;
        avoidReg = RBM_NONE;

        if (!varDsc->lvIsRegArg)
        {
            /* For local variables,
             *  avoid the incoming arguments,
             *  but only if you conflict with them */

            if (avoidArgRegMask != 0)
            {
                LclVarDsc *  argDsc;
                LclVarDsc *  argsEnd = lvaTable + info.compArgsCount;

                for (argDsc = lvaTable; argDsc < argsEnd; argDsc++)
                {
                    regNumber  inArgReg = argDsc->lvArgReg;
                    regMaskTP  inArgBit = genRegMask(inArgReg);

                    // Is this inArgReg in the avoidArgRegMask set?

                    if (!(avoidArgRegMask & inArgBit))
                        continue;

                    assert(argDsc->lvIsParam && argDsc->lvIsRegArg);
                    assert(inArgBit & RBM_ARG_REGS);

                    unsigned    locVarIndex  =  varDsc->lvVarIndex;
                    unsigned    argVarIndex  =  argDsc->lvVarIndex;
                    VARSET_TP   locVarBit    =  genVarIndexToBit(locVarIndex);
                    VARSET_TP   argVarBit    =  genVarIndexToBit(argVarIndex);

                    /* Does this variable interfere with the arg variable ? */
                    if  (lvaVarIntf[locVarIndex] & argVarBit)
                    {
                        assert( (lvaVarIntf[argVarIndex] & locVarBit) != 0 );
                        /* Yes, so try to avoid the incoming arg reg */
                        avoidReg |= inArgBit;
                    }
                    else
                    {
                        assert( (lvaVarIntf[argVarIndex] & locVarBit) == 0 );
                    }
                }
            }
        }

        // Now we will try to predict which register the variable
        // could  be enregistered in

        regNumber  regVarOrder[raRegVarOrderSize];

        raSetRegVarOrder(regVarOrder, varDsc->lvPrefReg, avoidReg);

        bool      firstHalf;       firstHalf      = false;
        regNumber saveOtherReg;    

        for (regInx = 0;
             regInx < raRegVarOrderSize;
             regInx++)
        {
            regNumber  regNum    = regVarOrder[regInx];
            regMaskTP  regBit    = genRegMask(regNum);

            /* Skip this register if it isn't available */

            if  (!(regAvail & regBit))
                continue;

            /* Skip this register if it interferes with the variable */

            if  (raLclRegIntf[regNum] & varBit)
                continue;

            /* Skip this register if the weighted ref count is less than two
               and we are considering a unused callee saved register */
            
            if  ((varDsc->lvRefCntWtd < (2 * BB_UNITY_WEIGHT)) &&
                 ((regBit & regUsed) == 0) &&  // first use of this register
                 (regBit & RBM_CALLEE_SAVED) ) // callee saved register
            {
                continue;       // not worth spilling a callee saved register
            }

            /* Looks good - mark the variable as living in the register */

            if  (isRegPairType(varDsc->lvType))
            {
                if  (firstHalf == false)
                {
                    /* Enregister the first half of the long */
                    varDsc->lvRegNum   = regNum;
                    saveOtherReg       = varDsc->lvOtherReg;
                    varDsc->lvOtherReg = REG_STK;
                    firstHalf          = true;
                }
                else
                {
                    /* Ensure 'well-formed' register pairs */
                    /* (those returned by gen[Pick|Grab]RegPair) */
                    
                    if  (regNum < varDsc->lvRegNum)
                    {
                        varDsc->lvOtherReg = varDsc->lvRegNum;
                        varDsc->lvRegNum   = regNum;
                    }
                    else
                    {
                        varDsc->lvOtherReg = regNum;                                                
                    }
                    firstHalf = false;
                }
            }
            else
            {
                varDsc->lvRegNum = regNum;
            }

            if (regNum == REG_EBP)
            {
                refCntEBP    += varDsc->lvRefCnt;
                refCntWtdEBP += varDsc->lvRefCntWtd;
#if DOUBLE_ALIGN
                if (varDsc->lvIsParam)
                {
                    refCntStkParam += varDsc->lvRefCnt;
                }
#endif
            }

            /* Record this register in the regUsed set */
            regUsed |= regBit;

            /* The register is now ineligible for all interefering variables */

            unsigned   intfIndex;
            VARSET_TP  intfBit;

            for (intfIndex = 0, intfBit = 1;
                 intfIndex < lvaTrackedCount;
                 intfIndex++  , intfBit <<= 1)
            {
                assert(genVarIndexToBit(intfIndex) == intfBit);

                if  (lvaVarIntf[varIndex] & intfBit)
                {
                    assert( (lvaVarIntf[intfIndex] & varBit) != 0 );
                    raLclRegIntf[regNum] |= intfBit;
                }
                else
                {
                    assert( (lvaVarIntf[intfIndex] & varBit) == 0 );
                }
            }

            /* If a register argument, remove its incoming register
             * from the "avoid" list */

            if (varDsc->lvIsRegArg)
                avoidArgRegMask &= ~genRegMask(varDsc->lvArgReg);

            /* A variable of TYP_LONG can take two registers */

            if (firstHalf)
                continue;

            // Since we have successfully enregistered this variable it is
            // now time to move on and consider the next variable

            goto ENREG_VAR;
        }
        
        if (firstHalf)
        {
            assert(isRegPairType(varDsc->lvType));

            /* This TYP_LONG is partially enregistered */
            if (varDsc->lvDependReg && (saveOtherReg != REG_STK))
                rpLostEnreg = true;

            rpStkPredict += varDsc->lvRefCntWtd;
            goto ENREG_VAR;
        }

NO_REG:;
        if (varDsc->lvDependReg)
            rpLostEnreg = true;

        /* Weighted count of variables that could have been enregistered but weren't */
        rpStkPredict += varDsc->lvRefCntWtd;

        if (isRegPairType(varDsc->lvType) && (varDsc->lvOtherReg == REG_STK))
            rpStkPredict += varDsc->lvRefCntWtd;

CANT_REG:;

        varDsc->lvRegister = false;

        varDsc->lvRegNum = REG_STK;
        if (isRegPairType(varDsc->lvType))
            varDsc->lvOtherReg = REG_STK;

        /* unweighted count of variables that were not enregistered */

        refCntStk += varDsc->lvRefCnt;
#if DOUBLE_ALIGN
        if (varDsc->lvIsParam)
        {
            refCntStkParam += varDsc->lvRefCnt;
        }
        else
        {
            /* Is it a stack based double? */
            /* Note that double params are excluded since they can not be double aligned */
            if (varDsc->lvType == TYP_DOUBLE)
            {
                refCntWtdStkDbl += varDsc->lvRefCntWtd;
            }
        }
#endif
#ifdef  DEBUG
        if  (verbose)
        {
            printf("; ");
            gtDispLclVar(varDsc - lvaTable);
            if (varDsc->lvTracked)
                printf(" T%02u", varDsc->lvVarIndex);
            else
                printf("    ");
            printf(" (refcnt=%2u,refwtd=%4u%s) not enregistered\n",
                   varDsc->lvRefCnt, 
                   varDsc->lvRefCntWtd/2, (varDsc->lvRefCntWtd & 1) ? ".5" : "");
        }
#endif
        continue;

ENREG_VAR:;

        varDsc->lvRegister = true;

#ifdef  DEBUG
        if  (verbose)
        {
            printf("; ");
            gtDispLclVar(varDsc - lvaTable);
            printf(" T%02u (refcnt=%2u,refwtd=%4u%s) predicted to be assigned to ",
                   varIndex, varDsc->lvRefCnt, varDsc->lvRefCntWtd/2, 
                   (varDsc->lvRefCntWtd & 1) ? ".5" : "");
            if (varTypeIsFloating(varDsc->TypeGet()))
                printf("the FPU stk\n");
            else if (isRegPairType(varDsc->lvType))
                printf("%s:%s\n", getRegName(varDsc->lvOtherReg),
                                  getRegName(varDsc->lvRegNum));
            else
                printf("%s\n",    getRegName(varDsc->lvRegNum));
        }
#endif
    }

    /* Determine how the EBP register should be used */

    if  (genFPreqd == false)
    {
#ifdef DEBUG
        if (verbose)
        {
            if (refCntStk > 0)
                printf("; refCntStk       = %u\n", refCntStk);
            if (refCntEBP > 0)
                printf("; refCntEBP       = %u\n", refCntEBP);
            if (refCntWtdEBP > 0)
                printf("; refCntWtdEBP    = %u\n", refCntWtdEBP);
#if DOUBLE_ALIGN
            if (refCntStkParam > 0)
                printf("; refCntStkParam  = %u\n", refCntStkParam);
            if (refCntWtdStkDbl > 0)
                printf("; refCntWtdStkDbl = %u\n", refCntWtdStkDbl);
#endif
        }
#endif

#if DOUBLE_ALIGN
        assert(s_canDoubleAlign < COUNT_DOUBLE_ALIGN);

        /*
            First let us decide if we should use EBP to create a
            double-aligned frame, instead of enregistering variables
        */

        if (s_canDoubleAlign == MUST_DOUBLE_ALIGN)
        {
            rpFrameType = FT_DOUBLE_ALIGN_FRAME;
            goto REVERSE_EBP_ENREG;
        }

#ifdef DEBUG
        if (compStressCompile(STRESS_DBL_ALN, 30))
        {
            // Bump up refCntWtdStkDbl to encourage double-alignment
            refCntWtdStkDbl += (1 + (info.compCodeSize%13)) * BB_UNITY_WEIGHT;
            if (verbose)
                printf("; refCntWtdStkDbl = %u (stress compile)\n", refCntWtdStkDbl);
        }
#endif

        if (s_canDoubleAlign == CAN_DOUBLE_ALIGN && (refCntWtdStkDbl > 0))
        {
            /* OK, there may be some benefit to double-aligning the frame */
            /* But let us compare the benefits vs. the costs of this      */

            /*
               One cost to consider is the benefit of smaller code
               when using EBP as a frame pointer register

               Each stack variable reference is an extra byte of code
               if we use a double-aligned frame, parameters are
               accessed via EBP for a double-aligned frame so they
               don't use an extra byte of code.

               We pay one byte of code for each refCntStk and we pay
               one byte or more for each refCntEBP but we save one
               byte for each refCntStkParam.

               We also pay 6 extra bytes for the MOV EBP,ESP,
               MOV ESP,EBP and the AND ESP,-8 to double align ESP

               Our savings are the elimination of a possible misaligned
               access and a possible DCU spilt when an access crossed
               a cache-line boundry.

               We use the loop weighted value of
                  refCntWtdStkDbl * misaligned_weight (0, 4, 16)
               to represent this savings.
            */
            unsigned bytesUsed = refCntStk + refCntEBP - refCntStkParam + 6;
            unsigned misaligned_weight = 4;

            if (compCodeOpt() == SMALL_CODE)
                misaligned_weight = 0;

            if (compCodeOpt() == FAST_CODE)
                misaligned_weight *= 4;

            if (bytesUsed > refCntWtdStkDbl * misaligned_weight / BB_UNITY_WEIGHT)
            {
                /* It's probably better to use EBP as a frame pointer */
#ifdef DEBUG
                if (verbose)
                    printf("; Predicting not to double-align ESP to save %d bytes of code.\n", bytesUsed);
#endif
                goto NO_DOUBLE_ALIGN;
            }

            /*
               Another cost to consider is the benefit of using EBP to enregister
               one or more integer variables

               We pay one extra memory reference for each refCntWtdEBP

               Our savings are the elimination of a possible misaligned
               access and a possible DCU spilt when an access crossed
               a cache-line boundry.

            */

            if (refCntWtdEBP * 3  > refCntWtdStkDbl * 2)
            {
                /* It's probably better to use EBP to enregister integer variables */
#ifdef DEBUG
                if (verbose)
                    printf("; Predicting not to double-align ESP to allow EBP to be used to enregister variables\n");
#endif
                goto NO_DOUBLE_ALIGN;
            }

            /*
               OK we passed all of the benefit tests
               so we'll predict a double aligned frame
            */
#ifdef DEBUG
            if  (verbose)
                printf("; Predicting to create a double-aligned frame\n");
#endif
            rpFrameType = FT_DOUBLE_ALIGN_FRAME;
            goto REVERSE_EBP_ENREG;
        }

NO_DOUBLE_ALIGN:

#endif

        /*
            Each stack reference is an extra byte of code if we use
            an ESP frame.

            Here we measure the savings that we get by using EBP to
            enregister variables vs. the cost in code size that we
            pay when using an ESP based frame.

            We pay one byte of code for each refCntStk
            but we save one byte (or more) for each refCntEBP
            we also pay 4 extra bytes for the MOV EBP,ESP and MOV ESP,EBP
            to set up an EBP frame in the prolog and epilog

            Our savings are the elimination of a stack memory read/write
            we use the loop weighted value of
               refCntWtdEBP * mem_access_weight (0, 3, 6)
            to represent this savings.

         */

        /*  If we are using EBP to enregister variables then
            will we actually save bytes by setting up an EBP frame? */

        if (refCntStk > refCntEBP + 4)
        {
            unsigned bytesSaved = refCntStk - refCntEBP - 4;
            unsigned mem_access_weight = 3;

            if (compCodeOpt() == SMALL_CODE)
                mem_access_weight = 0;

            if (compCodeOpt() == FAST_CODE)
                mem_access_weight *= 2;

            if (bytesSaved > refCntWtdEBP * mem_access_weight / BB_UNITY_WEIGHT)
            {
                /* It's not be a good idea to use EBP in our predictions */
#ifdef  DEBUG
                    if (verbose && (refCntEBP > 0))
                        printf("; Predicting that it's not worth using EBP to enregister variables\n");
#endif
                rpFrameType = FT_EBP_FRAME;
                goto REVERSE_EBP_ENREG;
            }
        }
        goto EXIT;

REVERSE_EBP_ENREG:

        assert(rpFrameType != FT_ESP_FRAME);

        rpReverseEBPenreg = true;

        if (refCntEBP > 0)
        {
            assert(regUsed & RBM_EBP);

            regUsed &= ~RBM_EBP;

            /* variables that were enregistered in EBP become stack based variables */
            rpStkPredict += refCntWtdEBP;

            unsigned      lclNum;
            
            /* We're going to have to undo some predicted enregistered variables */
            for (lclNum = 0, varDsc = lvaTable;
                 lclNum < lvaCount;
                 lclNum++  , varDsc++)
            {
                /* Is this a register variable? */
                if  (varDsc->lvRegNum != REG_STK)
                {
                    if (isRegPairType(varDsc->lvType))
                    {
                        /* Only one can be EBP */
                        if (varDsc->lvRegNum   == REG_EBP ||
                            varDsc->lvOtherReg == REG_EBP)
                        {
                            if (varDsc->lvRegNum == REG_EBP)
                                varDsc->lvRegNum = varDsc->lvOtherReg;

                            varDsc->lvOtherReg = REG_STK;
                            
                            if (varDsc->lvRegNum == REG_STK)
                                varDsc->lvRegister = false;
                            
                            if (varDsc->lvDependReg)
                                rpLostEnreg = true;
#ifdef DEBUG
                            if (verbose)
                                goto DUMP_MSG;
#endif
                        }
                    }
                    else
                    {
                        if ((varDsc->lvRegNum == REG_EBP) && (!isFloatRegType(varDsc->lvType)))
                        {
                            varDsc->lvRegNum = REG_STK;
                            
                            varDsc->lvRegister = false;
                            
                            if (varDsc->lvDependReg)
                                rpLostEnreg = true;
#ifdef DEBUG
                            if (verbose)
                            {
DUMP_MSG:
                                printf("; reversing enregisteration of V%02u,T%02u (refcnt=%2u,refwtd=%4u%s)\n",
                                       lclNum, varDsc->lvVarIndex, varDsc->lvRefCnt, 
                                       varDsc->lvRefCntWtd/2, (varDsc->lvRefCntWtd & 1) ? ".5" : "");
                            }
#endif
                        }
                    }
                }
            }
        }
    }

EXIT:;

    unsigned lclNum;
    for (lclNum = 0, varDsc = lvaTable;
         lclNum < lvaCount;
         lclNum++, varDsc++)
    {
        /* Clear the lvDependReg flag for next iteration of the predictor */
        varDsc->lvDependReg = false;

        // If we set rpLostEnreg and this is the first pessimize pass
        // then reverse the enreg of all TYP_LONG
        if  (rpLostEnreg                   && 
             isRegPairType(varDsc->lvType) && 
             (rpPasses == rpPassesPessimize))
        {
            varDsc->lvRegNum   = REG_STK;
            varDsc->lvOtherReg = REG_STK;
        }

    }

#ifdef  DEBUG
    if (verbose && raNewBlocks)
    {
        printf("\nAdded FP register killing blocks:\n");
        fgDispBasicBlocks();
        printf("\n");
    }
#endif
    assert(rpFrameType != FT_NOT_SET);

    /* return the set of registers used to enregister variables */
    return regUsed;
}

/****************************************************************************/
#endif // TGT_x86
/*****************************************************************************
 *
 *  Predict register use for every tree in the function. Note that we do this
 *  at different times (not to mention in a totally different way) for x86 vs
 *  RISC targets.
 */

void               Compiler::rpPredictRegUse()
{
#ifdef  DEBUG
    if (verbose)
        raDumpVarIntf();
#endif
       
    // We might want to adjust the ref counts based on interference
    raAdjustVarIntf();

    /* For debuggable code, genJumpToThrowHlpBlk() generates an inline call
       to acdHelper(). This is done implicitly, without creating a GT_CALL
       node. Hence, this interference is be handled implicitly by
       restricting the registers used for enregistering variables */

    /* @TODO: [REVISIT] [06/13/01] @BUGBUG 87357. Enregistering GC variables
       is incorrect as we would not GC-report any registers of a faulted/interrupted
       frame. However, chance of a GC happenning are low. */

    const regMaskTP allAcceptableRegs = opts.compDbgCode ? RBM_CALLEE_SAVED
                                                         : RBM_ALL;

    /* Compute the initial regmask to use for the first pass */

    /* Start with three caller saved registers */
    /* This allows for us to save EBX across a call */
    regMaskTP regAvail = (RBM_ESI | RBM_EDI | RBM_EBP) & allAcceptableRegs;
    regMaskTP regUsed;

    /* If we might need to generate a rep mov instruction */
    /* remove ESI and EDI */
    if (compBlkOpUsed)
        regAvail &= ~(RBM_ESI | RBM_EDI);

    /* If we using longs then we remove ESI to allow */
    /* ESI:EBX to be saved accross a call */
    if (compLongUsed)
        regAvail &= ~(RBM_ESI);

    /* If a frame pointer is required then we remove EBP */
    if (genFPreqd)
        regAvail &= ~RBM_EBP;


#ifdef  DEBUG
    static ConfigDWORD fJitNoRegLoc(L"JitNoRegLoc");
    if (fJitNoRegLoc.val())
        regAvail = RBM_NONE;
#endif
    if (opts.compMinOptim)
        regAvail = RBM_NONE;

    optAllNonFPvars = 0;
    optAllFloatVars = 0;

    // Calculate the set of all tracked FP/non-FP variables
    //  into optAllFloatVars and optAllNonFPvars
    
    unsigned     lclNum;
    LclVarDsc *  varDsc;

    for (lclNum = 0, varDsc = lvaTable;
         lclNum < lvaCount;
         lclNum++  , varDsc++)
    {
        /* Ignore the variable if it's not tracked */
            
        if  (!varDsc->lvTracked)
            continue;

        /* Get hold of the index and the interference mask for the variable */
            
        unsigned   varNum = varDsc->lvVarIndex;
        VARSET_TP  varBit = genVarIndexToBit(varNum);

        /* add to the set of all tracked FP/non-FP variables */
        
        if (isFloatRegType(varDsc->lvType))
            optAllFloatVars |= varBit;
        else
            optAllNonFPvars |= varBit;
    }

    // Mark the initial end of this table
    lvaFPRegVarOrder[0] = -1;

    raSetupArgMasks();

    memset(lvaVarPref,   0, sizeof(lvaVarPref));

    raNewBlocks          = false;
    rpPredictAssignAgain = false;
    rpPasses             = 0;

    bool     mustPredict = true;
    unsigned stmtNum     = 0;

    while (true)
    {    
        unsigned      oldStkPredict;
        VARSET_TP     oldLclRegIntf[REG_COUNT];

        regUsed = rpPredictAssignRegVars(regAvail);

        mustPredict |= rpLostEnreg;

        /* Is our new prediction good enough?? */
        if (!mustPredict)
        {
            /* For small methods (less than 12 stmts), we add a    */
            /*   extra pass if we are predicting the use of some   */
            /*   of the caller saved registers.                    */
            /* This fixes RAID perf bug 43440 VB Ackerman function */

            if ((rpPasses == 1) &&  (stmtNum <= 12) && 
                (regUsed & RBM_CALLEE_SAVED))
            {
                goto EXTRA_PASS;
            }
                
            /* If every varible was fully enregistered then we're done */
            if (rpStkPredict == 0)
                goto ALL_DONE;

            if (rpPasses > 1)
            {
                if (oldStkPredict < (rpStkPredict*2))
                    goto ALL_DONE;

                if (rpStkPredict < rpPasses * 8)
                    goto ALL_DONE;
                
                if (rpPasses >= (rpPassesMax-1))
                    goto ALL_DONE;
            }
EXTRA_PASS:;
        }

        assert(rpPasses < rpPassesMax);

#ifdef DEBUG
        if (verbose)
        {
            if (rpPasses > 0) 
            {
                if (rpLostEnreg)
                    printf("\n; Another pass due to rpLostEnreg");
                if (rpAddedVarIntf)
                    printf("\n; Another pass due to rpAddedVarIntf");
                if ((rpPasses == 1) && rpPredictAssignAgain)
                    printf("\n; Another pass due to rpPredictAssignAgain");
            }
            printf("\n; Register predicting pass# %d\n", rpPasses+1);
        }
#endif

        /*  Zero the variable/register interference graph */
        memset(raLclRegIntf, 0, sizeof(raLclRegIntf));

        stmtNum          = 0;
        rpAddedVarIntf   = false;
        rpLostEnreg      = false;

        /* Walk the basic blocks and predict reg use for each tree */

        for (BasicBlock *  block =  fgFirstBB;
                           block != NULL;
                           block =  block->bbNext)
        {
            GenTreePtr      stmt;

            for (stmt =  block->bbTreeList;
                 stmt != NULL;
                 stmt =  stmt->gtNext)
            {
                assert(stmt->gtOper == GT_STMT);

                rpPredictSpillCnt = 0;
                rpLastUseVars     = 0;
                rpUseInPlace      = 0;

                GenTreePtr tree = stmt->gtStmt.gtStmtExpr;
                stmtNum++;
#ifdef  DEBUG
                if (verbose && 1)
                {
                    printf("\nRegister predicting BB%02u, stmt %d\n", 
                           block->bbNum, stmtNum);
                    gtDispTree(tree);
                    printf("\n");
                }
#endif
                rpPredictTreeRegUse(tree, PREDICT_NONE, RBM_NONE, RBM_NONE);

                assert(rpAsgVarNum == -1);

                if (rpPredictSpillCnt > tmpIntSpillMax)
                    tmpIntSpillMax = rpPredictSpillCnt;
            }
        }
        rpPasses++;

        /* Decide wheather we need to set mustPredict */
        mustPredict = false;
        
        if (rpAddedVarIntf)
        {
            mustPredict = true;
#ifdef  DEBUG
            if (verbose)
                raDumpVarIntf();
#endif
        }

        if (rpPasses == 1)
        {
            if (opts.compMinOptim)
                goto ALL_DONE;

            if (rpPredictAssignAgain)
                mustPredict = true;
#ifdef  DEBUG
            if (fJitNoRegLoc.val())
                goto ALL_DONE;
#endif
        }

        /* Calculate the new value to use for regAvail */

        regAvail = allAcceptableRegs;

        /* If a frame pointer is required then we remove EBP */
        if (genFPreqd)
            regAvail &= ~RBM_EBP;

        // If we have done n-passes then we must continue to pessimize the
        // interference graph by or-ing the interferences from the previous pass

        if (rpPasses > rpPassesPessimize)
        {
            for (unsigned regInx = 0; regInx < REG_COUNT; regInx++)
                raLclRegIntf[regInx] |= oldLclRegIntf[regInx];

            /* If we reverse an EBP enregistration then keep it that way */
            if (rpReverseEBPenreg)
                regAvail &= ~RBM_EBP;
        }

#ifdef  DEBUG
        if (verbose)
            raDumpRegIntf();
#endif
        
        /*  Save the old variable/register interference graph */

        memcpy(oldLclRegIntf, raLclRegIntf, sizeof(raLclRegIntf));
        oldStkPredict = rpStkPredict;
    }   // end of while (true)

ALL_DONE:;

    switch(rpFrameType)
    {
    default:
        assert(!"rpFrameType not set correctly!");
        break;
    case FT_ESP_FRAME:
        assert(!genFPreqd);
        genDoubleAlign = false;
        genFPused      = false;
        break;
    case FT_EBP_FRAME:
        assert((regUsed & RBM_EBP) == 0);
        genDoubleAlign = false;
        genFPused      = true;
        break;
    case FT_DOUBLE_ALIGN_FRAME:
        assert((regUsed & RBM_EBP) == 0);
        genDoubleAlign = true;
        genFPused      = false;
        break;
    }
    
    /* Record the set of registers that we need */
    rsMaskModf = regUsed;
    
#if TGT_x86

    /* We need genFullPtrRegMap if :
     * The method is fully interruptible, or
     * We are generating an EBP-less frame (for stack-pointer deltas)
     */

    genFullPtrRegMap = (genInterruptible || !genFPused);

#endif

    raMarkStkVars();
#ifdef DEBUG
    if  (verbose)
        printf("# rpPasses was %d for %s\n", rpPasses, info.compFullName);
#endif

}

/*****************************************************************************
 *
 *  Mark all variables as to whether they live on the stack frame
 *  (part or whole), and if so what the base is (FP or SP).
 */

void                Compiler::raMarkStkVars()
{
    unsigned        lclNum;
    LclVarDsc *     varDsc;

    for (lclNum = 0, varDsc = lvaTable;
         lclNum < lvaCount;
         lclNum++  , varDsc++)
    {
        varDsc->lvOnFrame = false;

        /* Fully enregistered variables don't need any frame space */

        if  (varDsc->lvRegister)
        {
            if  (!isRegPairType(varDsc->TypeGet()))
                goto NOT_STK;

            /* For "large" variables make sure both halves are enregistered */

            if  (varDsc->lvRegNum   != REG_STK &&
                 varDsc->lvOtherReg != REG_STK)
            {
                goto NOT_STK;
            }
        }
        /* Unused variables typically don't get any frame space */
        else  if  (varDsc->lvRefCnt == 0) 
        {
            bool    needSlot = false;

            bool    stkFixedArgInVarArgs = info.compIsVarArgs &&
                                           varDsc->lvIsParam &&
                                           !varDsc->lvIsRegArg &&
                                           lclNum != lvaVarargsHandleArg;

            /* If its address has been taken, ignore lvRefCnt. However, exclude
               fixed arguments in varargs method as lvOnFrame shouldnt be set
               for them as we dont want to explicitly report them to GC. */

            if (!stkFixedArgInVarArgs)
                needSlot |= varDsc->lvAddrTaken;

            /* Is this the dummy variable representing GT_LCLBLK ? */
            needSlot |= lvaScratchMem && lclNum == lvaScratchMemVar;

#ifdef DEBUGGING_SUPPORT

            /* For debugging, note that we have to reserve space even for
               unused variables if they are ever in scope. However, this is not
               an issue as fgExtendDbgLifetimes() adds an initialization and
               variables in scope will not have a zero ref-cnt.
             */
#ifdef DEBUG
            if (opts.compDbgCode && !varDsc->lvIsParam && varDsc->lvTracked)
            {
                for (unsigned scopeCnt = 0; scopeCnt < info.compLocalVarsCount; scopeCnt++)
                    assert(info.compLocalVars[scopeCnt].lvdVarNum != lclNum);
            }
#endif
            /*
              For EnC, we have to reserve space even if the variable is never
              in scope. We will also need to initialize it if it is a GC var.
              So we set lvMustInit and artifically bump up the ref-cnt.
             */

            if (opts.compDbgEnC && !stkFixedArgInVarArgs &&
                lclNum < info.compLocalsCount)
            {
                needSlot           |= true;

                if (lvaTypeIsGC(lclNum))
                {
                    varDsc->lvRefCnt    = 1;

                    if (!varDsc->lvIsParam)
                        varDsc->lvMustInit  = true;
                }
            }
#endif

            if (!needSlot)
            {
                /* Clear the lvMustInit flag in case it is set */
                varDsc->lvMustInit = false;

                goto NOT_STK;
            }
        }

        /* The variable (or part of it) lives on the stack frame */

        varDsc->lvOnFrame = true;

    NOT_STK:;

        varDsc->lvFPbased = genFPused;

#if DOUBLE_ALIGN

        if  (genDoubleAlign)
        {
            assert(genFPused == false);

            /* All arguments are off of EBP with double-aligned frames */

            if  (varDsc->lvIsParam && !varDsc->lvIsRegArg)
                varDsc->lvFPbased = true;
        }

#endif

        /* Some basic checks */

        /* If neither lvRegister nor lvOnFrame is set, it must be unused */

        assert( varDsc->lvRegister ||  varDsc->lvOnFrame ||
                varDsc->lvRefCnt == 0);

        /* If both are set, it must be partially enregistered */

        assert(!varDsc->lvRegister || !varDsc->lvOnFrame ||
               (varDsc->lvType == TYP_LONG && varDsc->lvOtherReg == REG_STK));

#ifdef DEBUG

        // For varargs functions, there should be no direct references to
        // parameter variables except for 'this' (because these were morphed
        // in the importer) and the 'arglist' parameter (which is not a GC 
        // pointer). and the return buffer argument (if we are returning a 
        // struct).
        // This is important because we don't want to try to report them 
        // to the GC, as the frame offsets in these local varables would 
        // not be correct.

        if (varDsc->lvIsParam && raIsVarargsStackArg(lclNum))
        {
            assert( varDsc->lvRefCnt == 0 &&
                   !varDsc->lvRegister    &&
                   !varDsc->lvOnFrame        );
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\sched.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /************************************************************************/
    /*          Members/methods used for instruction scheduling             */
    /************************************************************************/

#if SCHEDULER

#if TGT_x86
#define EMIT_MAX_INSTR_STACK_CHANGE     sizeof(double)  // Max stk change effected by a single instr
#define SCHED_MAX_STACK_CHANGE          6*sizeof(void*) // Max stk change that will be scheduled
#endif

    struct  scDagNode
    {
        schedDepMap_tp      sdnDepsAll;     // mask of all  dependents
//      schedDepMap_tp      sdnDepsAGI;     // mask of AGI  dependents
        schedDepMap_tp      sdnDepsFlow;    // mask of flow dependents

        scDagNode    *      sdnNext;        // links the "ready" list

        schedInsCnt_tp      sdnIndex;       // node/ins index [0..count-1]
        schedInsCnt_tp      sdnPreds;       // count of predecessors

#ifdef  DEBUG
        schedInsCnt_tp      sdnIssued   :1; // ins. has already been issued
#endif

#if     MAX_BRANCH_DELAY_LEN
        unsigned char       sdnBranch   :1; // branch with delay slot(s)?
#endif

        unsigned short      sdnHeight;      // "height" of the node
    };

    schedDepMap_tp  scDagNodeX2mask(unsigned index)
    {
        assert(index < SCHED_INS_CNT_MAX);

        return  ((schedDepMap_tp)1) << index;   // @TODO [CONSIDER] [04/16/01] []: Is this fast enough?
    }

    schedDepMap_tp  scDagNodeP2mask(scDagNode *node)
    {
        return  scDagNodeX2mask(node->sdnIndex);
    }

    struct  scDagList
    {
        scDagList    *   sdlNext;
        scDagNode    *   sdlNode;
    };

    typedef
    scDagList     * schedUse_tp;            // tracks schedulable use(s)
    typedef
    scDagNode     * schedDef_tp;            // tracks schedulable def (0 or 1)

    instrDesc   * * scInsTab;               // table of schedulable instructions
    unsigned        scInsCnt;               // count of schedulable instructions
    instrDesc   * * scInsMax;               // table end
    scDagNode     * scDagTab;               // table of corresponding dag nodes
    instrDesc   * * scDagIns;               // base  of schedulable ins group

#if MAX_BRANCH_DELAY_LEN

    unsigned        scBDTmin;               // minimal time for branch
    unsigned        scBDTbeg;               // count when branch issued
    unsigned        scIssued;               // count of instr's issued so far

    bool            scIsBranchTooEarly(scDagNode *node);

#endif

    /*----------------------------------------------------------------------*/
    /*  The following macros to walk through the successor list of a node   */
    /*----------------------------------------------------------------------*/

    #define         scWalkSuccDcl(n)                                    \
                                                                        \
        schedDepMap_tp  n##deps;

    #define         scWalkSuccBeg(n,d)                                  \
                                                                        \
        n##deps = d->sdnDepsAll;                                        \
                                                                        \
        while (n##deps)                                                 \
        {                                                               \
            schedDepMap_tp  n##depm;                                    \
            unsigned        n##depx;                                    \
            scDagNode   *   n##depn;                                    \
                                                                        \
            n##depm  = genFindLowestBit(n##deps); assert(n##depm);      \
            n##depx  = genLog2(n##depm); assert((int)n##depx >= 0); \
            n##depn  = scDagTab + n##depx;                              \
                                                                        \
            assert(scDagNodeP2mask(n##depn) == n##depm);                \
                                                                        \
            n##deps -= n##depm;

    #define         scWalkSuccRmv(n,d)                                  \
                                                                        \
        assert(d->sdnDepsAll &  n##depm);                               \
               d->sdnDepsAll -= n##depm;

    #define         scWalkSuccCur(n) n##depn

    #define         scWalkSuccEnd(n) }

    /*----------------------------------------------------------------------*/
    /*               The following handle the "ready" list                  */
    /*----------------------------------------------------------------------*/

    scDagNode    *  scReadyList;
    scDagNode    *  scLastIssued;

    void            scReadyListAdd(scDagNode *node)
    {
        node->sdnNext = scReadyList;
                        scReadyList = node;
    }

    // pick the next ready node to issue

    enum scPick { PICK_SCHED, PICK_NO_SCHED, PICK_MAX_SCHED };
    scDagNode    *  scPickNxt(scPick pick = PICK_SCHED);    

    /*----------------------------------------------------------------------*/
    /*             Misc members/methods used for scheduling                 */
    /*----------------------------------------------------------------------*/

    unsigned        scLatency(scDagNode *node,
                              scDagNode *succ);

    unsigned        scGetDagHeight(scDagNode *node);

#ifdef  DEBUG
    void            scDispDag(bool         noDisp = false);
#endif

    instrDesc   *   scGetIns(unsigned     nodex)
    {
        assert(nodex < scInsCnt);

        return  scDagIns[nodex];
    }

    instrDesc   *   scGetIns(scDagNode   *node)
    {
        return  scGetIns(node->sdnIndex);
    }

    /*----------------------------------------------------------------------*/
    /*      The following detects and records dependencies in the dag       */
    /*----------------------------------------------------------------------*/

    schedUse_tp     scUseOld;          // list of free "use" entries

    schedUse_tp     scGetUse     ();
    void            scRlsUse     (schedUse_tp  use);

    instrDesc   *   scInsOfDef   (schedDef_tp  def);
    instrDesc   *   scInsOfUse   (schedUse_tp  use);

    void            scAddUse     (schedUse_tp *usePtr,
                                  scDagNode   *node);
    void            scClrUse     (schedUse_tp *usePtr);

    emitRegs        scSpecInsDep (instrDesc   *id,
                                  scDagNode   *dagDsc,
                                  scExtraInfo *xptr);

    void            scSpecInsUpd (instrDesc   *id,
                                  scDagNode   *dagDsc,
                                  scExtraInfo *xptr);

#ifndef DEBUG
    #define         scAddDep(src,dst,depn,dagn,flow) scAddDep(src,dst,flow)
#endif

    void            scAddDep(scDagNode   *src,
                             scDagNode   *dst,
                             const char * depName,
                             const char * dagName,
                             bool         isFlow);

    schedDef_tp     scRegDef[REG_COUNT];
    schedUse_tp     scRegUse[REG_COUNT];

    schedDef_tp     scIndDef[5];            // 8-bit/16-bit/32-bit/64-bit/GCref
    schedUse_tp     scIndUse[5];            // 8-bit/16-bit/32-bit/64-bit/GCref

    schedDef_tp   * scFrmDef;               // frame value def table
    schedUse_tp   * scFrmUse;               // frame value use table
    unsigned        scFrmUseSiz;            // frame value     table size

    schedDef_tp     scGlbDef;
    schedUse_tp     scGlbUse;

    scDagNode    *  scExcpt;                // most recent exceptional ins node

    scTgtDepDcl();                          // declare target-specific members

    /*
        Dependencies on flags are handled in a special manner, as we
        want to avoid creating tons of output dependencies for nodes
        that set flags but those flags are never used (which happens
        all the time). Instead, we do the following (note that we
        walk the instructions backward when constructing the dag):

            When an instruction that consumes flags is found (which
            is relativel rare), we set 'scFlgUse' to this node. The
            next instruction we encounter that sets the flags will
            have a flow dependency added and it will be recorded in
            'scFlgDef'. Any subsequent instruction that sets flags
            will have an output dependency on 'scFlgDef' which will
            prevent incorrect ordering.

            There is only one problem - when we encounter another
            instruction that uses flags, we somehow need to add
            anti-dependencies for all instructions that set flags
            which we've already processed (i.e. those that follow
            the flag-consuming instruction in the initial order).
            Since we don't want to keep a table of these nodes we
            simply walk the nodes we've already added and add the
            dependencies that way.
     */

#if SCHED_USE_FL

    bool            scFlgEnd;               // must set flags at end of group
    scDagNode   *   scFlgUse;               // last node consuming flags
    scDagNode   *   scFlgDef;               // node defining flags for above

#endif

    /*----------------------------------------------------------------------*/

#ifndef DEBUG
    #define         scDepDef(node,name,def,use) scDepDef(node,def,use)
    #define         scDepUse(node,name,def,use) scDepUse(node,def,use)
#endif

    void            scDepDef          (scDagNode   *node,
                                       const char  *name,
                                       schedDef_tp  def,
                                       schedUse_tp  use);
    void            scDepUse          (scDagNode   *node,
                                       const char  *name,
                                       schedDef_tp  def,
                                       schedUse_tp  use);

    void            scUpdDef          (scDagNode   *node,
                                       schedDef_tp *defPtr,
                                       schedUse_tp *usePtr);
    void            scUpdUse          (scDagNode   *node,
                                       schedDef_tp *defPtr,
                                       schedUse_tp *usePtr);

    /*----------------------------------------------------------------------*/

#if SCHED_USE_FL

    void            scDepDefFlg       (scDagNode   *node);
    void            scDepUseFlg       (scDagNode   *node,
                                       scDagNode   *begp,
                                       scDagNode   *endp);
    void            scUpdDefFlg       (scDagNode   *node);
    void            scUpdUseFlg       (scDagNode   *node);

#endif

    /*----------------------------------------------------------------------*/

    void            scDepDefReg       (scDagNode   *node,
                                       emitRegs    reg);
    void            scDepUseReg       (scDagNode   *node,
                                       emitRegs    reg);
    void            scUpdDefReg       (scDagNode   *node,
                                       emitRegs    reg);
    void            scUpdUseReg       (scDagNode   *node,
                                       emitRegs    reg);

    /*----------------------------------------------------------------------*/

    unsigned        scStkDepIndex     (instrDesc   *id,
                                       int          ebpLo,
                                       unsigned     ebpFrmSz,
                                       int          espLo,
                                       unsigned     espFrmSz,
                                       size_t      *opCntPtr);

    void            scDepDefFrm       (scDagNode   *node,
                                       unsigned     frm);
    void            scDepUseFrm       (scDagNode   *node,
                                       unsigned     frm);
    void            scUpdDefFrm       (scDagNode   *node,
                                       unsigned     frm);
    void            scUpdUseFrm       (scDagNode   *node,
                                       unsigned     frm);

    /*----------------------------------------------------------------------*/

    enum { IndIdxByte = 0, IndIdxGC = 4 };     // these are the return values for below (TODO actually use enum as ret) 
    unsigned        scIndDepIndex(instrDesc   *id);

    void            scDepDefInd       (scDagNode   *node,
                                       unsigned     am);
    void            scDepUseInd       (scDagNode   *node,
                                       unsigned     am);
    void            scUpdDefInd       (scDagNode   *node,
                                       unsigned     am);
    void            scUpdUseInd       (scDagNode   *node,
                                       unsigned     am);

    /*----------------------------------------------------------------------*/

    void            scDepDefGlb       (scDagNode   *node,
                                       CORINFO_FIELD_HANDLE MBH);
    void            scDepUseGlb       (scDagNode   *node,
                                       CORINFO_FIELD_HANDLE MBH);
    void            scUpdDefGlb       (scDagNode   *node,
                                       CORINFO_FIELD_HANDLE MBH);
    void            scUpdUseGlb       (scDagNode   *node,
                                       CORINFO_FIELD_HANDLE MBH);

    /*----------------------------------------------------------------------*/

    static
    unsigned        scFmtToISops[];

#ifdef  DEBUG
    static
    unsigned        scFmtToIScnt;
#endif

    unsigned        scInsSchedOpInfo  (instrDesc   *id)
    {
        assert((unsigned)id->idInsFmt < scFmtToIScnt);
        return  scFmtToISops[id->idInsFmt];
    }

    /*----------------------------------------------------------------------*/
    /*             Other members/methods used scheduling                    */
    /*----------------------------------------------------------------------*/

    void            scInsNonSched     (instrDesc   *id = NULL);

    int             scGetFrameOpInfo  (instrDesc   *id,
                                       size_t      *szp,
                                       bool        *ebpPtr);

    bool            scIsSchedulable   (instruction ins);
    bool            scIsSchedulable   (instrDesc   *id);

    bool            scIsBranchIns     (instruction ins);
    bool            scIsBranchIns     (scDagNode * node);

#if!MAX_BRANCH_DELAY_LEN
    #define         scGroup(ig,ni,dp,bp,ep,fl,fh,sl,sh,bl)      \
                    scGroup(ig,ni,dp,bp,ep,fl,fh,sl,sh)
#endif

    void            scGroup           (insGroup    *ig,
                                       instrDesc   *ni,
                                       BYTE *      *dp,
                                       instrDesc * *begPtr,
                                       instrDesc * *endPtr,
                                       int          fpLo,
                                       int          fpHi,
                                       int          spLo,
                                       int          spHi,
                                       unsigned     bdLen);

    void            scPrepare();

#else //SCHEDULER

    void            scPrepare() {}

#endif//SCHEDULER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\sched.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                             sched.cpp                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "alloc.h"
#include "instr.h"
#include "emit.h"
#include "target.h"

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************/

// #define VERBOSE verbose

#define VERBOSE 0

/*****************************************************************************/

const bool NO_REAL_SCHED = false;           // preserves instruction order
const bool MAXIMUM_SCHED = false;           // max. movement (for testing)

/*****************************************************************************
 *
 *  Prepare for scheduling the current method.
 */

void                emitter::scPrepare()
{
    /* Are we supposed to do instruction scheduling ? */

    if  (!emitComp->opts.compSchedCode)
        return;

#if EMITTER_STATS
    scdCntTable.histoRec(emitMaxIGscdCnt, 1);
#endif

#if TGT_x86

    /* Make sure the 'depmap' type matches the max. instruction count */

    assert(8*sizeof(schedDepMap_tp) == SCHED_INS_CNT_MAX);

    /* Make sure all the "IS_xx" values are different */

    assert(IS_R1_RD  != IS_R1_WR );
    assert(IS_R1_WR  != IS_R2_RD );
    assert(IS_R2_RD  != IS_R2_WR );
    assert(IS_R2_WR  != IS_SF_RD );
    assert(IS_SF_RD  != IS_SF_WR );
    assert(IS_SF_WR  != IS_GM_RD );
    assert(IS_GM_RD  != IS_GM_WR );
    assert(IS_GM_WR  != IS_AM_RD );
    assert(IS_AM_RD  != IS_AM_WR );
    assert(IS_AM_WR  != IS_FP_STK);
    assert(IS_FP_STK !=         0);

#else

    // UNDONE: need equivalent RISC asserts

#endif

    /* There is an upper limit on how many instructions we can handle */

    if  (emitMaxIGscdCnt > SCHED_INS_CNT_MAX)
         emitMaxIGscdCnt = SCHED_INS_CNT_MAX;

    /* We have not allocated the frame def/use tables yet */

#ifdef  DEBUG
    scFrmDef    = NULL;
    scFrmUse    = NULL;
#endif
    scFrmUseSiz = 0;

#if     USE_LCL_EMIT_BUFF

    size_t          space;
    unsigned        count;

    /* Is there any unused space at the end of the local buffer? */

    space = emitLclAvailMem();

    /* Compute how many entries we might be able to get */

    count = roundDn(space / (sizeof(*scFrmDef) + sizeof(*scFrmUse)));

    if  (count > 1)
    {
        /* Let's not get too greedy ... */

        count = min(count, SCHED_FRM_CNT_MAX);

        /* Grab the space for the two frame tracking tables */

        scFrmUseSiz = count;
        scFrmDef    = (schedDef_tp*)emitGetAnyMem(count*sizeof(*scFrmDef)); assert(scFrmDef);
        scFrmUse    = (schedUse_tp*)emitGetAnyMem(count*sizeof(*scFrmUse)); assert(scFrmUse);
    }

#endif

    /* Allocate the instruction table */

    scInsTab = (instrDesc**)emitGetAnyMem(emitMaxIGscdCnt*sizeof(*scInsTab));
    scInsMax = scInsTab + emitMaxIGscdCnt;

    /* Allocate the dag node    table */

    scDagTab = (scDagNode *)emitGetAnyMem(emitMaxIGscdCnt*sizeof(*scDagTab));

    /* We haven't allocated any "use" entries yet */

    scUseOld = NULL;
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Display the current state of the scheduling dag.
 */

void                emitter::scDispDag(bool noDisp)
{
    unsigned        num;
    scDagNode    *  node;

    unsigned        pcnt[SCHED_INS_CNT_MAX];

    memset(&pcnt, 0, sizeof(pcnt));

    if  (!noDisp) printf("Scheduling dag [%02u nodes]:\n", scInsCnt);

    for (num = 0, node = scDagTab;
         num < scInsCnt;
         num++  , node++)
    {
        bool            ready;

        unsigned        depn;
        scDagNode    *  depp;
        schedDepMap_tp  depm;
        unsigned        deps;

        scDagNode    *  temp;

        if  (!noDisp)
        {
            /* Figure out whether the node is on the "ready" list */

            ready = false;
            for (temp = scReadyList; temp; temp = temp->sdnNext)
            {
                if  (temp == node)
                {
                    ready = true;
                    break;
                }
            }

            printf("%c", node->sdnIssued ? 'I' : ' ');
            printf("%c", ready           ? 'R' : ' ');
            printf(" %02u:"  , num);
//          printf(" dep=%016I64X", node->sdnDepsAll);
            printf(" H=%03u ", node->sdnHeight);
            printf(" %03uP", node->sdnPreds);
        }

        for (depn = 0, depp = scDagTab, deps = 0;
             depn < scInsCnt;
             depn++  , depp++)
        {
            depm = scDagNodeP2mask(depp);

            if  (node->sdnDepsAll & depm)
            {
                if  (!noDisp)
                {
                    if  (!deps)
                        printf(" Deps:");

                    printf(" %u", depp->sdnIndex);

                    if  (node->sdnDepsFlow & depm)
                        printf("F");
                }

                deps++; pcnt[depp->sdnIndex]++;
            }
        }

        if  (!noDisp)
        {
            printf("\n");
            emitDispIns(scGetIns(node), false, false, true);
            printf("\n");
        }

        assert(node->sdnIndex == num);
    }

    for (num = 0; num < scInsCnt; num++)
    {
        if  (pcnt[num] != scDagTab[num].sdnPreds)
        {
            printf("ERROR: predecessor count wrong for ins #%u:", num);
            printf(" %u (expected %u)\n", scDagTab[num].sdnPreds, pcnt[num]);
        }

        assert(pcnt[num] == scDagTab[num].sdnPreds);
    }
}

/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************
 *
 *  This method is called when the instruction being added cannot participate
 *  in instruction scheduling (or we're at the end of a schedulable group) to
 *  perform the necessary book-keeping.
 */

void                emitter::scInsNonSched(instrDesc *id)
{
    unsigned        scdCnt;
    unsigned        begOfs;
    unsigned        endOfs;
    instrDescJmp  * jmpTmp;

    size_t          extras = 0;

    /* Figure out how many instructions are in this group */

    scdCnt = emitCurIGinsCnt - emitCurIGscd1st; assert((int)scdCnt >= 0);

    /* Did we just add a non-schedulable instruction? */

    if  (id)
    {
        extras = emitInstCodeSz(id);

        /* Don't include the added instruction in the total count */

        assert(scdCnt > 0); scdCnt--;
    }

    /* Keep track of the max. schedulable instruction count */

    if  (emitMaxIGscdCnt < scdCnt)
         emitMaxIGscdCnt = scdCnt;

    /* Compute the code offset range of the group */

    begOfs = emitCurIGscdOfs;
    endOfs = emitCurIGsize + extras;

//  printf("%2u schedulable instrs (max=%02u), offs = [%03X..%04X]\n", scdCnt, scMaxIGscdCnt, begOfs, endOfs);

    /* Fill in the offset range for any jumps within the group */

    for (jmpTmp = emitCurIGjmpList; jmpTmp; jmpTmp = jmpTmp->idjNext)
    {
        assert(jmpTmp->idjOffs < endOfs);

        if  (jmpTmp->idjOffs < begOfs)
            break;

//      printf("Schedulable jump #%02u: offset range is %04X..%04X\n", jmpTmp->idNum, begOfs, endOfs);
        jmpTmp->idjTemp.idjOffs[0] = begOfs;
        jmpTmp->idjTemp.idjOffs[1] = endOfs;
    }

    emitCurIGscd1st = emitCurIGinsCnt;
    emitCurIGscdOfs = endOfs;
}

/*****************************************************************************
 *
 *  Compute the latency between the given node and its successor (i.e. return
 *  the estimated number of cycles that will elapse between the beginning of
 *  execution of 'node' and that of 'succ'). Note that 'succ' will be NULL to
 *  indicate that the following instruction is not known.
 */

unsigned            emitter::scLatency(scDagNode *node, scDagNode *succ)
{
    unsigned        latency = 1;

#if MAX_BRANCH_DELAY_LEN

    if  (scIsBranchIns(node))
        latency += Compiler::instBranchDelayL(scGetIns(node)->idIns);

#endif

    return  latency;
}

/*****************************************************************************
 *
 *  Recursive method to compute the "dag height" of a given node.
 */

unsigned            emitter::scGetDagHeight(scDagNode *node)
{
    unsigned        height = node->sdnHeight;

    /* Have we computed the height of this node already? */

    if  (!height)
    {
        /* Compute the max. height + latency of all successors */

        if  (!node->sdnDepsAll)
        {
            /* This a leaf node (no successors) */

            height = scLatency(node, NULL);
            goto REC;
        }

        height = 1;

        scWalkSuccDcl(temp)

        scWalkSuccBeg(temp, node)
        {
            scDagNode   *   succ = scWalkSuccCur(temp);
            unsigned        shgt = succ->sdnHeight;

            if  (!shgt)
                shgt = scGetDagHeight(succ);

            shgt += scLatency(node, succ);

            if  (height < shgt)
                 height = shgt;
        }
        scWalkSuccEnd(temp)

    REC:

        /* Record the height in the node, making sure no precision is lost */

        node->sdnHeight = height; assert(node->sdnHeight == height);
    }

    return  height;
}

/*****************************************************************************
 *
 *  Define operand info for each instruction.
 */

unsigned            emitter::scFmtToISops[] =
{
    #define IF_DEF(en, op1, op2) op1,
    #include "emitfmts.h"
    #undef  IF_DEF
};

#ifdef  DEBUG
unsigned            emitter::scFmtToIScnt = sizeof(scFmtToISops)/sizeof(scFmtToISops[0]);
#endif

/*****************************************************************************
 *
 *  Convert a frame variable reference into a scheduling frame index. Also
 *  returns the count of referenced items in "*opCntPtr".
 */

unsigned            emitter::scStkDepIndex(instrDesc*id,
                                           int       ebpLo,
                                           unsigned  ebpFrmSz,
                                           int       espLo,
                                           unsigned  espFrmSz,
                                           size_t   *opCntPtr)
{
    int             ofs;
    bool            ebp;

    /* Get the frame location for the variable */

    ofs = scGetFrameOpInfo(id, opCntPtr, &ebp);

    if  (ebp)
    {
        assert(ebpLo                 <= ofs);
        assert(ebpLo + (int)ebpFrmSz >  ofs);

        return  ofs - ebpLo;
    }
    else
    {
        assert(espLo                 <= ofs);
        assert(espLo + (int)espFrmSz >  ofs);

        return  ofs - espLo + ebpFrmSz;
    }
}

/*****************************************************************************
 *
 *  Return the appropriate address mode index for the given instruction; note
 *  that currently only distinguish based on size, as follows:
 *
 *      0   ..   8-bit values
 *      1   ..  16-bit values
 *      2   ..  32-bit values
 *      3   ..  64-bit values
 *      4   ..  GC ref values
 */

unsigned            emitter::scIndDepIndex(instrDesc *id)
{
    //  if  (pessimisticAliasing) return 0; // UNDONE!

    assert(emitDecodeSize(0) == 1);
    assert(emitDecodeSize(1) == 2);
    assert(emitDecodeSize(2) == 4);
    assert(emitDecodeSize(3) == 8);

/**** @TODO [REVISIT] [04/16/01] []:
        Currently there is an issue in which we don't wish to allow writes that are 
        initializing GC objects to bypass the writes that 'publish' the object to
        other threads.   Ultimately we want to say that the 'publishing' variable 
        is volatile, and no reads or writes can pass a volatile piece of memory
        however we don't have logic in the scheduler which indicates that.  Currently
        the only writes that can pass one another are GC and nonGC writes since
        we know they don't alias.   Until we get support for volatile, I am making
        the sceduler think that GC refernces can alias non-GC references, and thus
        force the scheduler to keep them in order.  Since we only use the scheduler
        for the P5 this will no noticable impact on perf.  - vancem

#if TRACK_GC_REFS
    if  (id->idGCref)
        return  IndIdxGC;
#endif
****/

    /* ISSUE: Assume pessimistic aliasing allways */

    return  IndIdxByte; //id->idOpSize;
}

#ifdef  DEBUG

const   char    *   indDepIndex2string(unsigned amx)
{
    static
    const   char*   indNames[] =
    {
        "[08-bit]",
        "[16-bit]",
        "[32-bit]",
        "[64-bit]",
#if TRACK_GC_REFS
        "[GC-ref]",
#endif
    };

    assert(amx < sizeof(indNames)/sizeof(indNames[0]));

    return  indNames[amx];
}

#endif

/*****************************************************************************
 *
 *  Grab an available "use" entry.
 */

emitter::schedUse_tp  emitter::scGetUse()
{
    schedUse_tp     use;

    if  (scUseOld)
    {
        use = scUseOld;
              scUseOld = use->sdlNext;
    }
    else
    {
        use = (schedUse_tp)emitGetAnyMem(sizeof(*use));
    }

    return  use;
}

/*****************************************************************************
 *
 *  Relase the given "use" entry, it's no longer needed.
 */

void                emitter::scRlsUse(schedUse_tp use)
{
    use->sdlNext = scUseOld;
                   scUseOld = use;
}

/*****************************************************************************
 *
 *  Add the given dag node to the list of "use" entries at *usePtr.
 */

void                emitter::scAddUse(schedUse_tp *usePtr, scDagNode *node)
{
    schedUse_tp     use = scGetUse();

    use->sdlNode = node;
    use->sdlNext = *usePtr;
                   *usePtr = use;
}

/*****************************************************************************
 *
 *  Free up all the "use" entries at *usePtr.
 */

void                emitter::scClrUse(schedUse_tp *usePtr)
{
    schedUse_tp     use = *usePtr;

    while (use)
    {
        schedUse_tp     nxt = use->sdlNext;
        scRlsUse(use);
        use = nxt;
    }

    *usePtr = NULL;
}

/*****************************************************************************
 *
 *  Record a dependency of "dst" on "src" of the given type.
 */

void                emitter::scAddDep(scDagNode  *   src,
                                      scDagNode  *   dst,
                                      const char *   depName,
                                      const char *   dagName,
                                      bool           isFlow)
{
    schedDepMap_tp  dep = scDagNodeP2mask(dst);

    /* Do we already have a dependency between the nodes? */

    if  (!(src->sdnDepsAll & dep))
    {
        /* This is a new dependency */

        src->sdnDepsAll |= dep;

        /* The target node now has one more dependency */

        dst->sdnPreds++;

#ifdef  DEBUG
        if (VERBOSE) printf("    [%sDep] on %-8s refd at #%u\n", depName, dagName, dst->sdnIndex);
#endif
    }

    /* Record a flow dependency if appropriate */

    if  (isFlow)
        src->sdnDepsFlow |= dep;
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given indirection.
 */

void                emitter::scDepDefInd(scDagNode   *node,
					 unsigned     am)
{
    assert(am < sizeof(scIndUse));
    scDepDef(node, indDepIndex2string(am), scIndDef[am], scIndUse[am]);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given indirection.
 */

void                emitter::scDepUseInd(scDagNode   *node,
					 unsigned     am)
{
    assert(am < sizeof(scIndUse));
    scDepUse(node, indDepIndex2string(am), scIndDef[am], scIndUse[am]);
}

/*****************************************************************************
 *
 *  Pick the best ready instruction node to be issued next.
 */

emitter::scDagNode *  emitter::scPickNxt(scPick pick)
{
    assert(pick == PICK_SCHED || pick == PICK_NO_SCHED);
    assert(scReadyList);

    if (NO_REAL_SCHED)
        pick = PICK_NO_SCHED;
    else if (MAXIMUM_SCHED && pick == PICK_SCHED)
        pick = PICK_MAX_SCHED;

    scDagNode   * * lptr;
    scDagNode   *   node;

    if (pick != PICK_SCHED)
    {
        scDagNode   *   minp;               // node with min. instruction index
        unsigned        minx = (pick == PICK_MAX_SCHED) ? 0 : INT_MAX;
        scDagNode   * * minl;

        /*
            Walk the list of nodes that are ready to be issued, and pick
            the one that has min. instruction index. Doing this will have
            the effect that instructions will be issued in the same exact
            order as they appear in the original sequence.
         */

        for (lptr = &scReadyList; true; /**/)
        {
            /* Get the next node and stop if we're at the end of the list */

            node = *lptr;
            if  (!node)
                break;

#if MAX_BRANCH_DELAY_LEN

            /* Make sure this is not a branch instruction that isn't ready */

            if  (scIsBranchTooEarly(node))
                goto NEXT1;

#endif

            /* Compare the new node against the current best */

            bool betterChoice = (pick == PICK_MAX_SCHED) ? (minx <= node->sdnIndex)
                                                         : (minx  > node->sdnIndex);
            if (betterChoice)
            {
                /* This node looks best so far, remember it */

                minx = node->sdnIndex;
                minp = node;
                minl = lptr;
            }

#if MAX_BRANCH_DELAY_LEN
        NEXT1:
#endif

            /* Move on to the next node in the "ready" list */

            lptr = &node->sdnNext;
        }

        assert(minl && *minl == minp && minp->sdnIndex == minx);

        /* Remove the node from the "ready" list and return it */

        *minl = minp->sdnNext;

        return  minp;
    }

    scDagNode   *   mxap;               // node with max. height
    unsigned        mxax = 0;
    scDagNode   * * mxal;

    scDagNode   *   mxfp;               // node with max. height + no flow-dep
    unsigned        mxfx = 0;
    scDagNode   * * mxfl;

    schedDepMap_tp  flow;

    /*
        Walk the list of nodes that are ready to be issued, and pick
        the one that has max. height, preferring a node that doesn't
        have a dependency on the node we issued last.
     */

    flow = scLastIssued ? scLastIssued->sdnDepsFlow
                        : 0;

    for (lptr = &scReadyList; true; /**/)
    {
        unsigned        hgt;

        /* Get the next node and stop if we're at the end of the list */

        node = *lptr;
        if  (!node)
            break;

        /* Get the height of the current node */

        hgt = node->sdnHeight; assert(hgt);

        /* The restricted max. height should never exceed the overall one */

        assert(mxfx <= mxax);

        /* Does this node look like a potential candidate? */

        if  (hgt > mxfx)
        {
            schedDepMap_tp  mask;

#if MAX_BRANCH_DELAY_LEN

            /* Make sure this is not a branch instruction that isn't ready */

            if  (scIsBranchTooEarly(node))
                goto NEXT2;

#endif

            mask = scDagNodeP2mask(node);

            /* Is there a flow dependency on the node issued last? */

//          printf("[%c] node #%02u height = %u\n", (flow & mask) ? 'F' : 'N', node->sdnIndex, hgt);

            if  (flow & mask)
                goto FLOW_DEP;

            /* Compare against the current non-flow-dep max */

            if  (hgt > mxfx)
            {
                mxfx = hgt;
                mxfp = node;
                mxfl = lptr;
            }

        FLOW_DEP:

            /* Is the height higher than the overall best so far? */

            if  (hgt > mxax)
            {
                mxax = hgt;
                mxap = node;
                mxal = lptr;
            }
        }

#if MAX_BRANCH_DELAY_LEN
    NEXT2:
#endif

        /* Move on to the next node in the "ready" list */

        lptr = &node->sdnNext;
    }

    assert(mxfx == 0 || *mxfl == mxfp && mxfp->sdnHeight == mxfx);
    assert(mxax != 0 && *mxal == mxap && mxap->sdnHeight == mxax);

//  printf("Max. height for non-dep node #%02u = %03u\n", mxfx ? mxfp->sdnIndex : 0, mxfx);
//  printf("Max. height for   any   node #%02u = %03u\n", mxax ? mxap->sdnIndex : 0, mxax);

    /* Prefer the non-flow-dep node, if we found one */

    if  (mxfx)
    {
        /* Remove the node from the "ready" list and return it */

//      printf("Picked non-dep node #%02u [H=%03u]\n", mxfp->sdnIndex, mxfx);

        *mxfl = mxfp->sdnNext;
        return  mxfp;
    }
    else
    {
        /* Remove the node from the "ready" list and return it */

//      printf("Picked flowdep node #%02u [H=%03u]\n", mxap->sdnIndex, mxax);

        *mxal = mxap->sdnNext;
        return  mxap;
    }

}

/*****************************************************************************
 *
 *  Schedule and issue all the instructions recorded between the instruction
 *  table values 'begPtr' and 'endPtr'.
 */

void                emitter::scGroup(insGroup   *ig,        // Current insGroup
                                     instrDesc  *ni,        // Next instr in "ig", NULL if end of "ig"
                                     BYTE *     *dp,        // output buffer
                                     instrDesc* *begPtr,    // First instr to schedule
                                     instrDesc* *endPtr,    // Last+1  instr to schedule
                                     int         fpLo,      // FP relative vars
                                     int         fpHi,
                                     int         spLo,      // SP relative slots
                                     int         spHi,
                                     unsigned    bdLen)     // # of branch delay slots
{
    instrDesc   * * tmpPtr;
    unsigned        insCnt;
    unsigned        insNum;
    scDagNode     * dagPtr;
    scDagNode     * dagEnd;

    size_t           fpFrmSz;
    size_t           spFrmSz;
    size_t          stkFrmSz;

#ifdef  DEBUG
    if (VERBOSE) printf("Scheduler : G_%d (instr %d to inst %d):\n", 
        ig->igNum, (*begPtr)?(*begPtr)->idNum:-1, (*(endPtr-1))?(*(endPtr-1))->idNum:-1);
#endif

#if!MAX_BRANCH_DELAY_LEN
    const unsigned  bdLen = 0;
#endif

#if EMITTER_STATS
    for (tmpPtr = begPtr; tmpPtr != endPtr; tmpPtr++)
        schedFcounts[(*tmpPtr)->idInsFmt]++;
#endif

    /* Tell other methods where the instruction table starts */

    scDagIns = begPtr;

    /* If there are no stack references, clear the range[s] */

    if  (fpLo == INT_MAX)
    {
        assert(fpHi == INT_MIN);

        fpLo =
        fpHi = 0;
    }

    if  (spLo == INT_MAX)
    {
        assert(spHi == INT_MIN);

        spLo =
        spHi = 0;
    }

    /* Compute the number of frame values that we'll need to track */

    fpFrmSz = fpHi - fpLo;
    spFrmSz = spHi - spLo;

    stkFrmSz = fpFrmSz + spFrmSz;

#ifdef  DEBUG

    if  (verbose && stkFrmSz)
    {
        printf("Schedulable frame refs: %s[", getRegName(REG_FPBASE));
        if      (fpLo <  0)
        {
            printf("-%04X", -fpLo);
        }
        else if (fpLo >= 0)
        {
            printf("+%04X", +fpLo);
        }
        printf("..");
        if      (fpHi <  0)
        {
            printf("-%04X", -fpHi);
        }
        else if (fpHi >= 0)
        {
            printf("+%04X", +fpHi);
        }
        printf("] , %s[", getRegName(REG_SPBASE));
        if      (spLo <  0)
        {
            printf("-%04X", -spLo);
        }
        else if (spLo >= 0)
        {
            printf("+%04X", +spLo);
        }
        printf("..");
        if      (spHi <  0)
        {
            printf("-%04X", -spHi);
        }
        else if (spHi >= 0)
        {
            printf("+%04X", +spHi);
        }
        printf("] %3u items.\n", stkFrmSz);
    }

#endif

#if EMITTER_STATS
    scdFrmCntTable.histoRec(stkFrmSz, 1);
#endif

    /* Are there enough instructions to make scheduling worth our while? */

    scInsCnt = insCnt = endPtr - begPtr; assert((int)insCnt > 0 && insCnt <= SCHED_INS_CNT_MAX);

    if  (insCnt < SCHED_INS_CNT_MIN)
    {
        /* No scheduling, just issue the instructions in the original order */

    NO_SCHED:

        do
        {
            emitIssue1Instr(ig, *begPtr++, dp);
        }
        while (begPtr != endPtr);

        return;
    }

    /* Is the current stack frame tracking table big enough? */

    if  (stkFrmSz > scFrmUseSiz)
    {
        /* We don't have a big enough table - should we grow it? */

        if  (stkFrmSz > SCHED_FRM_CNT_MAX)
        {
            /* There are too many stack slots to track, just give up */

            // @TODO [CONSIDER] [04/16/01] []:
            //      Use hash table for tracking stack frame values
            //      when scheduling code with a very large frame.

            goto NO_SCHED;
        }

        /* Reallocate the stack tracking tables to have sufficient capacity */

        scFrmUseSiz = roundUp(stkFrmSz + stkFrmSz/2);
        scFrmDef    = (schedDef_tp*)emitGetMem(scFrmUseSiz*sizeof(*scFrmDef));
        scFrmUse    = (schedUse_tp*)emitGetMem(scFrmUseSiz*sizeof(*scFrmUse));
    }

#if MAX_BRANCH_DELAY_LEN

    /* Do we have any branch-delay slots to schedule? */

    scBDTmin = 0;
    scIssued = 0;

    if  (bdLen)
    {
        assert(insCnt > bdLen);

        /* Don't bother scheduling the branch-delay nop's at the end */

        scInsCnt = insCnt = insCnt - bdLen; assert(insCnt >= 1);

        /* Compute the earliest time the jump/call may be issued */

        scBDTmin = max(insCnt - bdLen - 1, 0);
    }

#endif

    /* Clear all of the tracking tables/values */

    memset(scFrmDef, 0, stkFrmSz*sizeof(*scFrmDef));
    memset(scFrmUse, 0, stkFrmSz*sizeof(*scFrmUse));
    memset(scDagTab, 0,   insCnt*sizeof(*scDagTab));

    memset(scRegDef, 0,    sizeof( scRegDef));
    memset(scRegUse, 0,    sizeof( scRegUse));

    memset(scIndDef, 0,    sizeof( scIndDef));
    memset(scIndUse, 0,    sizeof( scIndUse));

    scExcpt = 0;

    scGlbDef     = 0;
    scGlbUse     = 0;

    scTgtDepClr();

#if SCHED_USE_FL

    scFlgDef     = 0;
    scFlgUse     = 0;

    /*
        Since the group we're scheduling may in general end at an arbitrary
        point, we have to be careful about flags. If there is a possibility
        that one of the last instructions at the end of the group sets the
        flags which are later used by an instruction that follows the group
        we have to make sure to issue the instruction that sets the flags
        at the end of the scheduled group.
     */

    scFlgEnd = false;

     /* See if we know the instruction that will follow the group */

    if  (ni == NULL)
    {
        insGroup    *   ng;

        /* Check the IG that follows ours */

        ng = ig->igNext; 
        
        if (!ng) goto NO_FL;

        /* Is the next IG a target of a jump? */

        if  (ng->igFlags & IGF_HAS_LABEL)
        {
            // ISSUE: We assume labels don't ever expect flags to be set!

            goto NO_FL;
        }

        /* Get hold of the first instruction on the next IG */

        ni = (instrDesc *)ng->igData;
    }

    if  (ni != NULL)
    {
        /* We know the instruction that follows, check its flag effect 
           ISSUE: If ni doesnt use flags, can any of its successors ? */

        if  (Compiler::instUseFlags((instruction)ni->idIns) == 0)
        {
            /* The next doesn't read flags */

            goto NO_FL;
        }
    }

    /* Looks like we're going to have to set the flags at the end */

    scFlgEnd = true;

NO_FL:

#endif

    /*-------------------------------------------------------------------------
     * Build the dag by walking the instructions backwards 
     */

#ifdef  DEBUG
    if (VERBOSE) printf("Building scheduling dag [%2u instructions]:\n", insCnt);
#endif

    tmpPtr = endPtr - bdLen;
    insNum = insCnt;
    dagPtr = dagEnd = scDagTab + insNum;

    do
    {
        instrDesc   *   id;

        instruction     ins;
        insFormats      fmt;
        unsigned        inf;
        unsigned        flg;

        CORINFO_FIELD_HANDLE    MBH;
        int             frm;
        size_t          siz;
        unsigned        amx;

        emitRegs        rg1;
        emitRegs        rg2;

        bool            extraDep;
        bool            stackDep;
        emitRegs        extraReg;
        scExtraInfo     extraInf;

        /* We start past the end and go backwards */

        tmpPtr--;
        insNum--;
        dagPtr--;

        /* Make sure our variables are in synch */

        assert((int)insNum == dagPtr - scDagTab);
        assert((int)insNum == tmpPtr - begPtr);

        /* Get hold of the next (actually, previous) instruction */

        id = *tmpPtr;
        assert(scIsSchedulable(id));

        /* Fill in the instruction index in the dag descriptor */

        dagPtr->sdnIndex = insNum; assert((int)insNum == tmpPtr - scDagIns);

#ifdef  DEBUG
        if  (VERBOSE)
        {
            printf("Sched[%02u]%16s:\n", insNum, emitIfName(id->idInsFmt));
            emitDispIns(id, false, false, true);
        }
#endif

        /* Get hold of the instruction and its format */

        ins = id->idInsGet();
        fmt = (insFormats )id->idInsFmt;

#if MAX_BRANCH_DELAY_LEN

        /* Remember whether this a branch with delay slot(s) */

        if  (bdLen && scIsBranchIns(ins))
            dagPtr->sdnBranch = true;

        /* We should never encounter a nop, right? */

        assert(ins != INS_nop);

#endif

//      if  (id->idNum == <put instruction number here>) debugStop(0);

        /********************************************************************/
        /*             Record the dependencies of the instruction           */
        /********************************************************************/

        inf      = scInsSchedOpInfo(id);
        flg      = emitComp->instInfo[ins] & (INST_USE_FL|INST_DEF_FL);   // this is a bit rude ....

        extraDep =
        stackDep = false;
        extraReg = SR_NA;

        /* Is this an instruction that may cause an exception? */

        if  (!emitIsTinyInsDsc(id) && id->idInfo.idMayFault)
        {
            if  (scExcpt)
                scAddDep(dagPtr, scExcpt, "Out-", "except", false);

            scExcpt = dagPtr;
        }

        /* Does this instruction require "extra special" handling? */

        extraDep = emitComp->instSpecialSched(ins);
        if  (extraDep)
        {
            extraReg = scSpecInsDep(id, dagPtr, &extraInf);

            /* "xor reg,reg" doesn't actually read "reg" */

            if  (ins == INS_xor    &&
                 fmt == IF_RWR_RRD && id->idReg == id->idRg2)
            {
                assert(inf == (IS_R1_RW|IS_R2_RD));

                inf = IS_R1_WR;
            }
        }

#if     SCHED_USE_FL

        /* Does the instruction define or use flags? */

        if  (flg)
        {
            if  (flg & INST_DEF_FL)
                scDepDefFlg(dagPtr);
            if  (flg & INST_USE_FL)
                scDepUseFlg(dagPtr, dagPtr+1, dagEnd);
        }

#endif

        /* Does the instruction reference the "main"  register operand? */

        if  (inf & IS_R1_RW)
        {
            rg1 = id->idRegGet();

            if  (inf & IS_R1_WR)
                scDepDefReg(dagPtr, rg1);
            if  (inf & IS_R1_RD)
                scDepUseReg(dagPtr, rg1);
        }

        /* Does the instruction reference the "other" register operand? */

        if  (inf & IS_R2_RW)
        {
            rg2 = (emitRegs)id->idRg2;

            if  (inf & IS_R2_WR)
                scDepDefReg(dagPtr, rg2);
            if  (inf & IS_R2_RD)
                scDepUseReg(dagPtr, rg2);
        }

        /* Does the instruction reference a stack frame variable? */

        if  (inf & IS_SF_RW)
        {
            frm = scStkDepIndex(id, fpLo, fpFrmSz,
                                    spLo, spFrmSz, &siz);

            assert(siz == 1 || siz == 2);

//          printf("stkfrm[%u;%u]: %04X\n", frm, siz, (inf & IS_SF_RW));

            unsigned varNum = id->idAddr.iiaLclVar.lvaVarNum;

            if (varNum >= emitComp->info.compLocalsCount ||
                emitComp->lvaVarAddrTaken(varNum))
            {
                /* If the variable is aliased, then track it individually.
                   It will interfere with all indirections.
                   @TODO [CONSIDER] [04/16/01] []: We cant use lvaVarAddrTaken() 
                    for temps, so cant track them. Should be able to do this */

                amx = scIndDepIndex(id);

                if  (inf & IS_SF_WR)
                    scDepDefInd(dagPtr, amx);
                if  (inf & IS_SF_RD)
                    scDepUseInd(dagPtr, amx);
            }

            /* Now track it individually */

            if  (inf & IS_SF_WR)
            {
                scDepDefFrm(dagPtr, frm);
                if  (siz > 1)
                scDepDefFrm(dagPtr, frm+1);
            }
            if  (inf & IS_SF_RD)
            {
                scDepUseFrm(dagPtr, frm);
                if  (siz > 1)
                scDepUseFrm(dagPtr, frm+1);
            }
        }

        /* Does the instruction reference a global variable? */

        if  (inf & IS_GM_RW)
        {
            MBH = id->idAddr.iiaFieldHnd;
            amx = scIndDepIndex(id);

            if  (inf & IS_GM_WR)
            {
                scDepDefGlb(dagPtr, MBH);
                scDepDefInd(dagPtr, amx);	// globals interfere with any indirection
            }
            if  (inf & IS_GM_RD)
            {
                scDepUseGlb(dagPtr, MBH);
                scDepUseInd(dagPtr, amx);	// globals interfere with any indirection
            }
        }

        /* Does the instruction reference an indirection? */

        if  (inf & IS_INDIR_RW)
        {
            /* Process the indirected value */

            amx = scIndDepIndex(id);

            if  (inf & IS_INDIR_WR)
                scDepDefInd(dagPtr, amx);
            if  (inf & IS_INDIR_RD)
                scDepUseInd(dagPtr, amx);

            /* Process the address register(s) */

#if TGT_x86
            if  (id->idAddr.iiaAddrMode.amBaseReg != SR_NA)
                scDepUseReg(dagPtr, (emitRegs)id->idAddr.iiaAddrMode.amBaseReg);
            if  (id->idAddr.iiaAddrMode.amIndxReg != SR_NA)
                scDepUseReg(dagPtr, (emitRegs)id->idAddr.iiaAddrMode.amIndxReg);
#else
            if  (1)
                scDepUseReg(dagPtr, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);
#endif
        }

        /* Process any fixed target-specific dependencies */

        scTgtDepDep(id, inf, dagPtr);

        /********************************************************************/
        /*                    Update the dependency state                   */
        /********************************************************************/

        /* Does the instruction define or use flags? */

        if  (flg)
        {
            if  (flg & INST_DEF_FL)
                scUpdDefFlg(dagPtr);
            if  (flg & INST_USE_FL)
                scUpdUseFlg(dagPtr);
        }

        /* Does the instruction reference the "main"  register operand? */

        if  (inf & IS_R1_RW)
        {
            assert(rg1 == id->idReg);

            if  (inf & IS_R1_WR)
                scUpdDefReg(dagPtr, rg1);
            if  (inf & IS_R1_RD)
                scUpdUseReg(dagPtr, rg1);
        }

        /* Does the instruction reference the "other" register operand? */

        if  (inf & IS_R2_RW)
        {
            assert(rg2 == id->idRg2);

            if  (inf & IS_R2_WR)
                scUpdDefReg(dagPtr, rg2);
            if  (inf & IS_R2_RD)
                scUpdUseReg(dagPtr, rg2);
        }

        /* Does the instruction reference a stack frame variable? */

        if  (inf & IS_SF_RW)
        {
            unsigned varNum = id->idAddr.iiaLclVar.lvaVarNum;

            if (varNum >= emitComp->info.compLocalsCount ||
                emitComp->lvaVarAddrTaken(varNum))
            {
                /* If the variable is aliased, then track it individually.
                   It will interfere with all indirections.
                   @TODO [CONSIDER] [04/16/01] []: We cant use lvaVarAddrTaken() 
                    for temps, so cant track them. Should be able to do this */

                assert(amx == scIndDepIndex(id));

                if  (inf & IS_SF_WR)
                    scUpdDefInd(dagPtr, amx);
                if  (inf & IS_SF_RD)
                    scUpdUseInd(dagPtr, amx);
            }

            if  (inf & IS_SF_WR)
            {
                scUpdDefFrm(dagPtr, frm);
                if  (siz > 1)
                scUpdDefFrm(dagPtr, frm+1);
            }
            if  (inf & IS_SF_RD)
            {
                scUpdUseFrm(dagPtr, frm);
                if  (siz > 1)
                scUpdUseFrm(dagPtr, frm+1);
            }
        }

        /* Does the instruction reference a global variable? */

        if  (inf & IS_GM_RW)
        {
            assert(amx == scIndDepIndex(id));
            if  (inf & IS_GM_WR) 
			{
                scUpdDefGlb(dagPtr, MBH);
                scUpdDefInd(dagPtr, amx);	// globals interfere with any indirection
            }
            if  (inf & IS_GM_RD)
            {
                scUpdUseGlb(dagPtr, MBH);
                scUpdUseInd(dagPtr, amx);	// globals interfere with any indirection
            }
        }

        /* Does the instruction reference an indirection? */

        if  (inf & IS_INDIR_RW)
        {
            /* Process the indirected value */

            assert(amx == scIndDepIndex(id));

            if  (inf & IS_INDIR_WR)
                scUpdDefInd(dagPtr, amx);
            if  (inf & IS_INDIR_RD)
                scUpdUseInd(dagPtr, amx);

            /* Process the address register(s) */

#if TGT_x86
            if  (id->idAddr.iiaAddrMode.amBaseReg != SR_NA)
                scUpdUseReg(dagPtr, (emitRegs)id->idAddr.iiaAddrMode.amBaseReg);
            if  (id->idAddr.iiaAddrMode.amIndxReg != SR_NA)
                scUpdUseReg(dagPtr, (emitRegs)id->idAddr.iiaAddrMode.amIndxReg);
#else
            if  (1)
                scUpdUseReg(dagPtr, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);
#endif

        }

        /* Process any fixed target-specific dependencies */

        scTgtDepUpd(id, inf, dagPtr);

        /* Do we have an "extra" register dependency? */

        if  (extraReg != SR_NA)
        {
            scUpdDefReg(dagPtr, extraReg);
            scUpdUseReg(dagPtr, extraReg);
        }

        /* Any other "extra" dependencies we need to update? */

        if  (extraDep)
            scSpecInsUpd(id, dagPtr, &extraInf);

#ifdef  DEBUG
        if  (VERBOSE) printf("\n");
#endif

    }
    while (tmpPtr != begPtr);

    /* Make sure we ended up in the right place */

    assert(dagPtr == scDagTab);
    assert(tmpPtr == begPtr);
    assert(insNum == 0);

    /*-------------------------------------------------------------------------
        Create the "ready" list (which consists of all nodes with no
        predecessors), and also compute the height of each node in
        the dag.
     */

    scReadyList = NULL;

    for (insNum = scInsCnt, dagPtr = scDagTab;
         insNum;
         insNum--         , dagPtr++)
    {

#if     EMITTER_STATS

        unsigned        succ = 0;
        schedDepMap_tp  mask = dagPtr->sdnDepsAll;

        while (mask)
        {
            succ++;
            mask -= genFindLowestBit(mask);
        }

        scdSucTable.histoRec(succ, 1);

#endif

        if  (dagPtr->sdnPreds == 0)
        {
            scReadyListAdd(dagPtr);
            scGetDagHeight(dagPtr);
        }
    }

#ifdef  DEBUG
    if  (VERBOSE) printf("\n");
    scDispDag(!VERBOSE);
#endif

    /*-------------------------------------------------------------------------
     * Now issue the best-looking ready instruction until all are gone 
     */

#ifdef  DEBUG
    unsigned        issued = 0;
#endif

    scLastIssued = NULL;

#if TGT_x86
    const unsigned  startStackLvl = emitCurStackLvl;
#endif

    scPick          pick = PICK_SCHED;

    do
    {
        scDagNode   *   node;

        /* Pick the next node to be issued */

        node = scPickNxt(pick);

        /* Issue the corresponding instruction */

        emitIssue1Instr(ig, scGetIns(node), dp);

#ifdef  DEBUG
        node->sdnIssued = true; scDispDag(true); issued++;
#endif

#if MAX_BRANCH_DELAY_LEN

        /* Did we just issue a branch? */

        if  (scIsBranchIns(node))
        {
            /* Make sure we haven't issued the branch too early */

            assert(scIssued >= scBDTmin);

            /* Remember when we issued the branch */

            scBDTbeg = scIssued;
        }

        /* Update the number of instructions issued */

        scIssued++;

#endif

        /* Keep track of the most recently issued node */

        scLastIssued = node;

        /* Update the predecessor counts for all dependents */

        scWalkSuccDcl(temp)

        scWalkSuccBeg(temp, node)
        {
            scDagNode   *   succ = scWalkSuccCur(temp);

            scWalkSuccRmv(temp, node);

//          printf("Succ of %02u: %02u / predCnt=[%02u->%02u]\n", node->sdnIndex,
//                                                                succ->sdnIndex,
//                                                                succ->sdnPreds,
//                                                                succ->sdnPreds-1);

            assert(succ->sdnPreds != 0);
            if  (--succ->sdnPreds == 0)
            {
                /* This successor node is now ready to be issued */

                scReadyListAdd(succ);
            }
        }
        scWalkSuccEnd(temp)

#if TGT_x86
        if  (pick == PICK_SCHED && !emitEBPframe)
        {
            /* For non-EBP frames, locals are accessed related to ESP. If we have
               pushed any values on the stack, the offset reqd to access the 
               locals increases. Restrict this to a value such that our 
               estimation of the instruction encoding size isnt violated */

            // Make sure we allow atleast 2 pushes
            assert(SCHED_MAX_STACK_CHANGE > 2*EMIT_MAX_INSTR_STACK_CHANGE);

            /* If we have already emitted some pushes, dont take any chances
               scheduling any more pushes. Just emit all the remaining
               instructions and be done. */
           
            if  ((emitComp->compLclFrameSize + emitMaxStackDepth*sizeof(void*)) > (size_t)SCHAR_MAX &&
                 (emitCurStackLvl - startStackLvl) >= (SCHED_MAX_STACK_CHANGE - EMIT_MAX_INSTR_STACK_CHANGE))
            {
                pick = PICK_NO_SCHED;
            }
        }
#endif

    }
    while (scReadyList);

    /* Make sure all the instructions have been issued */

    assert(issued == insCnt);

    /* Do we need to fill any additional branch-delay slots? */

#if MAX_BRANCH_DELAY_LEN

    if  (bdLen)
    {
        int         nopCnt;

        /* Compute how many nop's we need to fill the remaining BD slots */

        nopCnt = scBDTbeg + bdLen + 1 - scIssued; assert(nopCnt >= 0);

        /* Point at the nop's at the tail of the scheduling table */

        tmpPtr = begPtr + insCnt;

        while (nopCnt)
        {
            assert((*tmpPtr)->idIns == INS_nop);

            emitIssue1Instr(ig, *tmpPtr, dp);

            tmpPtr++;
            nopCnt--;
        }

        // UNDONE: If some of the branch-delay slots were actually filled
        //         by useful instructions, we need to update the size of
        //         the instruction group, as we have generated less code
        //         then originally anticipated (i.e. we're ignoring some
        //         of the nop(s) that were added to fill the BD slots).
    }

#endif

    /*
        ISSUE:  When we rearrange instructions due to scheduling, it's not
                currently possible to keep track of their offsets. Thus,
                anyone who uses scCodeOffset() when scheduling is enabled
                is in for a rude surprise. What to do?
     */

    ig->igFlags |= IGF_UPD_ISZ;     // better than nothing, I suppose ....
}

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\typedefs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TYPEDEFS_H_
#define _TYPEDEFS_H_
/*****************************************************************************/

        struct  ident;
typedef struct  ident         * identPtr;

/*---------------------------------------------------------------------------*/

        struct  symLst;
typedef struct  symLst        * symLstPtr;

        struct  typLst;
typedef struct  typLst        * typLstPtr;

        struct  namLst;
typedef struct  namLst        * namLstPtr;

/*---------------------------------------------------------------------------*/

        struct  symDef;
typedef struct  symDef        * symDefPtr;

        struct  typDef;
typedef struct  typDef        * typDefPtr;

        struct  dimDef;
typedef struct  dimDef        * dimDefPtr;

        struct  argDef;
typedef struct  argDef        * argDefPtr;

        struct  attrDef;
typedef struct  attrDef       * attrDefPtr;

/*---------------------------------------------------------------------------*/

        struct  stmtExpr;
typedef struct  stmtExpr      * stmtExprPtr;

typedef struct  stmtExpr        parseTree;
typedef struct  stmtExpr      * parseTreePtr;

/*---------------------------------------------------------------------------*/

        struct PCblock;
typedef struct PCblock        * PCblockPtr;

        struct swtGenDsc;
typedef struct swtGenDsc      * swtGenDscPtr;

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\regsh3.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#if  !  TGT_SH3
#error  This file can only be used when targetting SH3!
#endif
/*****************************************************************************/
#ifndef REGDEF
#error  Must define REGDEF macro before including this file
#endif
/*****************************************************************************/
/*                  The following is SH3 specific                            */
/*****************************************************************************/

REGDEF(r00, "r0", 0,0x0001)
REGDEF(r01, "r1", 1,(0x1 << 01))
REGDEF(r02, "r2", 2,(0x1 << 02))
REGDEF(r03, "r3", 3,(0x1 << 03))
REGDEF(r04, "r4", 4,(0x1 << 04))
REGDEF(r05, "r5", 5,(0x1 << 05))
REGDEF(r06, "r6", 6,(0x1 << 06))
REGDEF(r07, "r7", 7,(0x1 << 07))
REGDEF(r08, "r8", 8,(0x1 <<  8))
REGDEF(r09, "r9", 9,(0x1 <<  9))
REGDEF(r10,"r10",10,(0x1 << 10))
REGDEF(r11,"r11",11,(0x1 << 11))
REGDEF(r12,"r12",12,(0x1 << 12))
REGDEF(r13,"r13",13,(0x1 << 13))
REGDEF(r14,"r14",14,(0x1 << 14))
REGDEF(r15,"sp" ,15,(0x1 << 15))

/* we recycle sp's mask for the pseudo register */
#ifndef SHX_SH4
REGDEF(STK,NULL ,16,0x8000)
#else
REGDEF(fr00, "fr0",16,(0x1 << 16))
REGDEF(fr01, "fr1",17,(0x1 << 17))
REGDEF(fr02, "fr2",18,(0x1 << 18))
REGDEF(fr03, "fr3",19,(0x1 << 19))
REGDEF(fr04, "fr4",20,(0x1 << 20))
REGDEF(fr05, "fr5",21,(0x1 << 21))
REGDEF(fr06, "fr6",22,(0x1 << 22))
REGDEF(fr07, "fr7",23,(0x1 << 23))
REGDEF(fr08, "fr8",24,(0x1 << 24))
REGDEF(fr09, "fr9",25,(0x1 << 25))
REGDEF(fr10,"fr10",26,(0x1 << 26))
REGDEF(fr11,"fr11",27,(0x1 << 27))
REGDEF(fr12,"fr12",28,(0x1 << 28))
REGDEF(fr13,"fr13",29,(0x1 << 29))
REGDEF(fr14,"fr14",30,(0x1 << 30))
REGDEF(fr15,"fr15",31,(0x1 << 31))
REGDEF(STK,NULL ,32,0x8000)
#endif
/*****************************************************************************/
#undef  REGDEF
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\schedx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           schedX86.cpp                                    XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "alloc.h"
#include "instr.h"
#include "emit.h"
#include "target.h"

/*****************************************************************************/
#if     SCHEDULER && TGT_x86
/*****************************************************************************
 *
 *  Records any "extra" target-dependent scheduling dependencies.
 */

emitRegs            emitter::scSpecInsDep(instrDesc   * id,
                                          scDagNode   * dagDsc,
                                          scExtraInfo * xptr)
{
    unsigned amx;
    emitRegs        extraReg;

    /* Assume no additional dependencies will be needed later */

    extraReg       = SR_NA;
    xptr->stackDep = false;

    /* Check for an interesting instruction */

    switch (id->idIns)
    {
    case INS_add:
    case INS_sub:

        /* Check for "add/sub sp, <icon>" */

        if  (id->idInsFmt != IF_RRW_CNS)
            break;
        if  (id->idReg != SR_ESP)
            break;

        // Fall through ...

    case INS_push:
    case INS_push_hide:
    case INS_pop:
    case INS_pop_hide:

    STACK_DEP:

        scDepUseReg(dagDsc, SR_ESP);
        scDepDefReg(dagDsc, SR_ESP);

        xptr->stackDep = true;
        break;

    case INS_jae:
    case INS_jbe:

        /*
            Can't move "jae/jbe indexError" across push/pop in FPO
            methods (for now), as it messes up ESP level tracking.
         */

        if  (!emitEBPframe)
            goto STACK_DEP;

        break;

    case INS_fstp:

        if  (id->idInsFmt != IF_AWR_TRD)
            break;
        if  (id->idAddr.iiaAddrMode.amBaseReg != SR_ESP)
            break;

        goto STACK_DEP;

    case INS_cdq:
        scDepUseReg(dagDsc, SR_EAX);
        scDepDefReg(dagDsc, SR_EDX);
        scUpdUseReg(dagDsc, SR_EAX);
        scUpdDefReg(dagDsc, SR_EDX);
        break;

    case INS_imulEAX:
    case INS_mulEAX:
        scDepDefReg(dagDsc, SR_EAX);
        scDepDefReg(dagDsc, SR_EDX);
        scDepUseReg(dagDsc, SR_EAX);
        break;

    case INS_div:
    case INS_idiv:
        scDepDefReg(dagDsc, SR_EAX);
        scDepDefReg(dagDsc, SR_EDX);
        scDepUseReg(dagDsc, SR_EAX);
        scDepUseReg(dagDsc, SR_EDX);
        break;

    case INS_sahf:
        scDepUseReg(dagDsc, SR_EAX);
        break;

    case INS_rcl:
    case INS_rcr:
    case INS_shl:
    case INS_shr:
    case INS_sar:

        /* Record dependency on "CL" (actually, ECX) */

        scDepUseReg(dagDsc, SR_ECX);
        break;

    case INS_imul_AX:
    case INS_imul_BX:
    case INS_imul_CX:
    case INS_imul_DX:
    case INS_imul_BP:
    case INS_imul_SI:
    case INS_imul_DI:
        extraReg = ((emitRegs) Compiler::inst3opImulReg((instruction)id->idIns));
        scDepDefReg(dagDsc, extraReg);
        scDepUseReg(dagDsc, extraReg);
        break;

    case INS_r_movsb:
    case INS_r_movsd:
        scDepUseReg(dagDsc, SR_ECX);
        scDepDefReg(dagDsc, SR_ECX);
        scUpdUseReg(dagDsc, SR_ECX);
        scUpdDefReg(dagDsc, SR_ECX);

        // fall through

    case INS_movsd:
    case INS_movsb:
        scDepUseReg(dagDsc, SR_ESI);
        scDepDefReg(dagDsc, SR_ESI);
        scDepUseReg(dagDsc, SR_EDI);
        scDepDefReg(dagDsc, SR_EDI);

        amx = scIndDepIndex(id);
        scDepDefInd(dagDsc, amx);
        scDepUseInd(dagDsc, amx);

        scUpdDefInd(dagDsc, amx);
        scUpdUseInd(dagDsc, amx);

        scUpdUseReg(dagDsc, SR_ESI);
        scUpdDefReg(dagDsc, SR_ESI);
        scUpdUseReg(dagDsc, SR_EDI);
        scUpdDefReg(dagDsc, SR_EDI);
        break;

    case INS_r_stosb:
    case INS_r_stosd:
        scDepUseReg(dagDsc, SR_ECX);
        scDepDefReg(dagDsc, SR_ECX);
        scUpdUseReg(dagDsc, SR_ECX);
        scUpdDefReg(dagDsc, SR_ECX);

        // fall through
    case INS_stosd:
    case INS_stosb:
        scDepUseReg(dagDsc, SR_EDI);
        scDepDefReg(dagDsc, SR_EDI);
        scDepUseReg(dagDsc, SR_EAX);

        amx = scIndDepIndex(id);
        scDepDefInd(dagDsc, amx);

#if TRACK_GC_REFS
        // stosd can also be used to set GC poitners, so mark the interference
        scDepDefInd(dagDsc, IndIdxGC);
        scUpdDefInd(dagDsc, IndIdxGC);
#endif

        scUpdDefInd(dagDsc, amx);

        scUpdUseReg(dagDsc, SR_EDI);
        scUpdDefReg(dagDsc, SR_EDI);
        scUpdUseReg(dagDsc, SR_EAX);
        break;
    }

    return  extraReg;
}

/*****************************************************************************
 *
 *  Updates any "extra" target-dependent scheduling dependencies.
 */

void                emitter::scSpecInsUpd(instrDesc   * id,
                                          scDagNode   * dagDsc,
                                          scExtraInfo * xptr)
{
    /* Do we have an "extra" stack dependency? */

    if  (xptr->stackDep)
    {
        scUpdDefReg(dagDsc, SR_ESP);
        scUpdUseReg(dagDsc, SR_ESP);
    }

    /* Check for an interesting instruction */

    switch (id->idIns)
    {
    case INS_imulEAX:
    case INS_mulEAX:
        scUpdDefReg(dagDsc, SR_EAX);
        scUpdDefReg(dagDsc, SR_EDX);
        scUpdUseReg(dagDsc, SR_EAX);
        break;

    case INS_div:
    case INS_idiv:
        scUpdDefReg(dagDsc, SR_EAX);
        scUpdDefReg(dagDsc, SR_EDX);
        scUpdUseReg(dagDsc, SR_EAX);
        scUpdUseReg(dagDsc, SR_EDX);
        break;

    case INS_sahf:
        scUpdUseReg(dagDsc, SR_EAX);
        break;

    case INS_rcl:
    case INS_rcr:
    case INS_shl:
    case INS_shr:
    case INS_sar:
        scUpdUseReg(dagDsc, SR_ECX);
        break;
    }
}

/*****************************************************************************/
#endif//SCHEDULER && TGT_x86
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\scopeinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                                  ScopeInfo                                XX
XX                                                                           XX
XX   Classes to gather the Scope information from the local variable info.   XX
XX   Translates the given LocalVarTab from instr offsets into EIP.        XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/******************************************************************************
 *                                  Debuggable code
 * 
 *  We break up blocks at the start and end IL ranges of the local variables. 
 *  This is because IL offsets do not correspond exactly to native offsets 
 *  except at block boundaries. No basic-blocks are deleted (not even 
 *  unreachable), so there will not be any missing address-ranges, though the 
 *  blocks themselves may not be ordered. (Also internal blocks may be added).
 *  o At the start of each basic block, siBeginBlock() checks if any variables 
 *    are coming in scope, adds an open scope to siOpenScopeList if needed.
 *  o At the end of each basic block, siEndBlock() checks if any variables 
 *    are going out of scope and moves the open scope from siOpenScopeLast 
 *    to siScopeList.
 *  
 *                                  Optimized code
 *  
 *  We cannot break up the blocks as this will produce different code under 
 *  the debugger. Instead we try to do a best effort.
 *  o At the start of each basic block, siBeginBlock() adds open scopes 
 *    corresponding to compCurBB->bbLiveIn to siOpenScopeList. Also siUpdate() 
 *    is called to close scopes for variables which are not live anymore.
 *  o siEndBlock() closes scopes for any variables which goes out of range 
 *    before (bbCodeOffs+bbCodeSize).
 *  o siCloseAllOpenScopes() closes any open scopes after all the blocks. 
 *    This should only be needed if some basic block are deleted/out of order, 
 *    etc.
 *  Also,
 *  o At every assignment to a variable, siCheckVarScope() adds an open scope 
 *    for the variable being assigned to.
 *  o genChangeLife() calls siUpdate() which closes scopes for variables which 
 *    are not live anymore.
 * 
 ******************************************************************************
 */

#include "jitpch.h"
#pragma hdrstop
#include "emit.h"

/*****************************************************************************/
#ifdef DEBUGGING_SUPPORT
/*****************************************************************************/

bool        Compiler::siVarLoc::vlIsInReg(regNumber     reg)
{
    switch(vlType)
    {
    case VLT_REG:       return ( vlReg.vlrReg      == reg);
    case VLT_REG_REG:   return ((vlRegReg.vlrrReg1 == reg) ||
                                (vlRegReg.vlrrReg2 == reg));
    case VLT_REG_STK:   return ( vlRegStk.vlrsReg  == reg);
    case VLT_STK_REG:   return ( vlStkReg.vlsrReg  == reg);

    case VLT_STK:
    case VLT_STK2:
    case VLT_FPSTK:     return false;

    default:            assert(!"Bad locType");
                        return false;
    }
}

bool        Compiler::siVarLoc::vlIsOnStk(regNumber     reg,
                                          signed        offset)
{
    switch(vlType)
    {

    case VLT_REG_STK:   return ((vlRegStk.vlrsStk.vlrssBaseReg == reg) &&
                                (vlRegStk.vlrsStk.vlrssOffset  == offset));
    case VLT_STK_REG:   return ((vlStkReg.vlsrStk.vlsrsBaseReg == reg) &&
                                (vlStkReg.vlsrStk.vlsrsOffset  == offset));
    case VLT_STK:       return ((vlStk.vlsBaseReg == reg) &&
                                (vlStk.vlsOffset  == offset));
    case VLT_STK2:      return ((vlStk2.vls2BaseReg == reg) &&
                                ((vlStk2.vls2Offset == offset) ||
                                 (vlStk2.vls2Offset == (offset - 4))));

    case VLT_REG:
    case VLT_REG_REG:
    case VLT_FPSTK:     return false;

    default:            assert(!"Bad locType");
                        return false;
    }
}

/*============================================================================
 *
 *              Implementation for ScopeInfo
 *
 *
 * Whenever a variable comes into scope, add it to the list.
 * When a varDsc goes dead, end its previous scope entry, and make a new one
 * which is unavailable
 * When a varDsc goes live, end its previous un-available entry (if any) and
 * set its new entry as available.
 *
 *============================================================================
 */


/*****************************************************************************
 *                      siNewScope
 *
 * Creates a new scope and adds it to the Open scope list.
 */

Compiler::siScope *         Compiler::siNewScope( unsigned short LVnum,
                                                  unsigned       varNum,
                                                  bool           avail)
{
    bool        tracked      = lvaTable[varNum].lvTracked;
    unsigned    varIndex     = lvaTable[varNum].lvVarIndex;

    if (tracked)
    {
        siEndTrackedScope(varIndex);
    }


    siScope * newScope       = (siScope*) compGetMem(sizeof(*newScope));

    newScope->scStartBlock   = genEmitter->emitCurBlock();
    newScope->scStartBlkOffs = genEmitter->emitCurOffset();

    assert(newScope->scStartBlock);

    newScope->scEndBlock     = NULL;
    newScope->scEndBlkOffs   = 0;

    newScope->scLVnum        = LVnum;
    newScope->scVarNum       = varNum;
    newScope->scAvailable    = avail;
    newScope->scNext         = NULL;
#if TGT_x86
    newScope->scStackLevel   = genStackLevel;       // used only by stack vars
#endif

    siOpenScopeLast->scNext  = newScope;
    newScope->scPrev         = siOpenScopeLast;
    siOpenScopeLast          = newScope;

    if (tracked)
    {
        siLatestTrackedScopes[varIndex] = newScope;
    }

    return newScope;
}



/*****************************************************************************
 *                          siRemoveFromOpenScopeList
 *
 * Removes a scope from the open-scope list and puts it into the done-scope list
 */

void        Compiler::siRemoveFromOpenScopeList(Compiler::siScope * scope)
{
    assert(scope);
    assert(scope->scEndBlock);

    // Remove from open-scope list

    scope->scPrev->scNext       = scope->scNext;
    if (scope->scNext)
    {
        scope->scNext->scPrev   = scope->scPrev;
    }
    else
    {
        siOpenScopeLast         = scope->scPrev;
    }

    // Add to the finished scope list. (Try to) filter out scopes of length 0.

    if (scope->scStartBlock   != scope->scEndBlock ||
        scope->scStartBlkOffs != scope->scEndBlkOffs)
    {
        siScopeLast->scNext     = scope;
        siScopeLast             = scope;
        siScopeCnt++;
    }
}



/*----------------------------------------------------------------------------
 * These functions end scopes given different types of parameters
 *----------------------------------------------------------------------------
 */


/*****************************************************************************
 * For tracked vars, we dont need to search for the scope in the list as we
 * have a pointer to the open scopes of all tracked variables
 */

void        Compiler::siEndTrackedScope(unsigned varIndex)
{
    siScope * scope     = siLatestTrackedScopes[varIndex];
    if (!scope)
        return;

    scope->scEndBlock    = genEmitter->emitCurBlock();
    scope->scEndBlkOffs  = genEmitter->emitCurOffset();

    assert(scope->scEndBlock);

    siRemoveFromOpenScopeList(scope);

    siLatestTrackedScopes[varIndex] = NULL;
}


/*****************************************************************************
 * If we dont know that the variable is tracked, this function handles both
 * cases.
 */

void        Compiler::siEndScope(unsigned varNum)
{
    for (siScope * scope = siOpenScopeList.scNext; scope; scope = scope->scNext)
    {
        if (scope->scVarNum == varNum)
        {
            scope->scEndBlock    = genEmitter->emitCurBlock();
            scope->scEndBlkOffs  = genEmitter->emitCurOffset();

            assert(scope->scEndBlock);

            siRemoveFromOpenScopeList(scope);

            LclVarDsc & lclVarDsc1  = lvaTable[varNum];
            if (lclVarDsc1.lvTracked)
            {
                siLatestTrackedScopes[lclVarDsc1.lvVarIndex] = NULL;
            }

            return;
        }
    }

    // At this point, we probably have a bad LocalVarTab

    if (opts.compDbgCode)
    {
        // LocalVarTab is good?? Then WE screwed up.
        assert(!siVerifyLocalVarTab());

        opts.compScopeInfo = false;
    }
}



/*****************************************************************************
 * If we have a handle to the siScope structure, we handle ending this scope
 * differenly than if we just had a variable number. This saves us searching
 * the open-scope list again.
 */

void        Compiler::siEndScope(siScope * scope)
{
    scope->scEndBlock    = genEmitter->emitCurBlock();
    scope->scEndBlkOffs  = genEmitter->emitCurOffset();

    assert(scope->scEndBlock);

    siRemoveFromOpenScopeList(scope);

    LclVarDsc & lclVarDsc1  = lvaTable[scope->scVarNum];
    if (lclVarDsc1.lvTracked)
    {
        siLatestTrackedScopes[lclVarDsc1.lvVarIndex] = NULL;
    }
}



/*****************************************************************************
 *                          siIgnoreBlock
 *
 * If the block is an internally created block, or does not correspond
 * to any instrs (eg. critSect-enter and exit), then we dont
 * need to update LocalVar info
 */

bool        Compiler::siIgnoreBlock(BasicBlock * block)
{
    if ((block->bbFlags & BBF_INTERNAL) || (block->bbCodeSize == 0))
    {
        return true;
    }

    return false;
}


/*****************************************************************************
 *                          siBeginBlockSkipSome
 *
 * If the current block does not follow the previous one in terms of
 * instr ordering, then we have to walk the scope lists to see if
 * there are any scopes beginning or closing at the missing instrs.
 */

/* static */
void        Compiler::siNewScopeCallback(LocalVarDsc * var, unsigned clientData)
{
    assert(var && clientData);

    ((Compiler*)clientData)->siNewScope(var->lvdLVnum, var->lvdVarNum);
}

/* static */
void        Compiler::siEndScopeCallback(LocalVarDsc * var, unsigned clientData)
{
    assert(var && clientData);

    ((Compiler*)clientData)->siEndScope(var->lvdVarNum);
}



/*****************************************************************************
 *                      siVerifyLocalVarTab
 *
 * Checks the LocalVarTab for consistency. The VM may not have properly
 * verified the LocalVariableTable.
 */

#ifdef DEBUG

bool            Compiler::siVerifyLocalVarTab()
{
    // No entries with overlapping lives should have the same slot.

    for (unsigned i=0; i<info.compLocalVarsCount; i++)
    {
        for (unsigned j=i+1; j<info.compLocalVarsCount; j++)
        {
            unsigned slot1  = info.compLocalVars[i].lvdVarNum;
            unsigned beg1   = info.compLocalVars[i].lvdLifeBeg;
            unsigned end1   = info.compLocalVars[i].lvdLifeEnd;

            unsigned slot2  = info.compLocalVars[j].lvdVarNum;
            unsigned beg2   = info.compLocalVars[j].lvdLifeBeg;
            unsigned end2   = info.compLocalVars[j].lvdLifeEnd;

            if (slot1==slot2 && (end1>beg2 && beg1<end2))
            {
                return false;
            }
        }
    }

    return true;
}

#endif



/*============================================================================
 *           INTERFACE (public) Functions for ScopeInfo
 *============================================================================
 */


void            Compiler::siInit()
{
    assert(ICorDebugInfo::REGNUM_EAX        == REG_EAX);
    assert(ICorDebugInfo::REGNUM_ECX        == REG_ECX);
    assert(ICorDebugInfo::REGNUM_EDX        == REG_EDX);
    assert(ICorDebugInfo::REGNUM_EBX        == REG_EBX);
    assert(ICorDebugInfo::REGNUM_ESP        == REG_ESP);
    assert(ICorDebugInfo::REGNUM_EBP        == REG_EBP);
    assert(ICorDebugInfo::REGNUM_ESI        == REG_ESI);
    assert(ICorDebugInfo::REGNUM_EDI        == REG_EDI);

    assert(ICorDebugInfo::VLT_REG       == Compiler::VLT_REG        );
    assert(ICorDebugInfo::VLT_STK       == Compiler::VLT_STK        );
    assert(ICorDebugInfo::VLT_REG_REG   == Compiler::VLT_REG_REG    );
    assert(ICorDebugInfo::VLT_REG_STK   == Compiler::VLT_REG_STK    );
    assert(ICorDebugInfo::VLT_STK_REG   == Compiler::VLT_STK_REG    );
    assert(ICorDebugInfo::VLT_STK2      == Compiler::VLT_STK2       );
    assert(ICorDebugInfo::VLT_FPSTK     == Compiler::VLT_FPSTK      );
    assert(ICorDebugInfo::VLT_FIXED_VA  == Compiler::VLT_FIXED_VA   ); 
    assert(ICorDebugInfo::VLT_MEMORY    == Compiler::VLT_MEMORY     ); 
    assert(ICorDebugInfo::VLT_COUNT     == Compiler::VLT_COUNT      );
    assert(ICorDebugInfo::VLT_INVALID   == Compiler::VLT_INVALID    ); 

    /* ICorDebugInfo::VarLoc and siVarLoc should overlap exactly as we cast
     * one to the other in eeSetLVinfo()
     * Below is a "reqired but not sufficient" condition
     */

    assert(sizeof(ICorDebugInfo::VarLoc) == sizeof(Compiler::siVarLoc));

    assert(opts.compScopeInfo);

    siOpenScopeList.scNext = NULL;
    siOpenScopeLast        = & siOpenScopeList;
    siScopeLast            = & siScopeList;

    siScopeCnt          = 0;
    siLastStackLevel    = 0;
    siLastLife          = 0;
    siLastEndOffs       = 0;

    if (info.compLocalVarsCount == 0)
        return;

    for (unsigned i=0; i<lclMAX_TRACKED; i++)
    {
        siLatestTrackedScopes[i] = NULL;
    }

    assert(compEnterScopeList);
    assert(compExitScopeList);
}



/*****************************************************************************
 *                          siBeginBlock
 *
 * Called at the beginning of code-gen for a block. Checks if any scopes
 * need to be opened.
 */

void        Compiler::siBeginBlock()
{
    assert(opts.compScopeInfo && info.compLocalVarsCount>0);

    LocalVarDsc * LocalVarDsc1;

    if (!opts.compDbgCode)
    {
        /* For non-debuggable code */
        
        // End scope of variable which are not live for this block

        siUpdate();

        // Check that vars which are live on entry have an open scope

        unsigned i;
        VARSET_TP varbit, liveIn = compCurBB->bbLiveIn;

        for (i = 0, varbit=1;
            (i < lvaTrackedCount) && (liveIn);
            varbit<<=1, i++)
        {
            if (!(varbit & liveIn))
                continue;

            liveIn &= ~varbit;
            siCheckVarScope(lvaTrackedToVarNum[genVarBitToIndex(varbit)],
                            compCurBB->bbCodeOffs);
        }
    }
    else
    {
        // For debuggable code, scopes can begin only on block-boundaries.
        // Check if there are any scopes on the current block's start boundary.

        if  (siIgnoreBlock(compCurBB))
            return;

        if  (siLastEndOffs != compCurBB->bbCodeOffs)
        {
            assert(siLastEndOffs < compCurBB->bbCodeOffs);
            siBeginBlockSkipSome();
            return;
        }

        LocalVarDsc1 = compGetNextEnterScope(compCurBB->bbCodeOffs);
        while (LocalVarDsc1)
        {
            siNewScope(LocalVarDsc1->lvdLVnum, LocalVarDsc1->lvdVarNum);

            assert(compCurBB);
            LclVarDsc * lclVarDsc1 = &lvaTable[LocalVarDsc1->lvdVarNum];
            assert(  !lclVarDsc1->lvTracked                                   \
                    || (genVarIndexToBit(lclVarDsc1->lvVarIndex) & compCurBB->bbLiveIn) );
            LocalVarDsc1 = compGetNextEnterScope(compCurBB->bbCodeOffs);
        }
    }
}

/*****************************************************************************
 *                          siEndBlock
 *
 * Called at the end of code-gen for a block. Any closing scopes are marked
 * as such. Note that if we are collecting LocalVar info, scopes can
 * only begin or end at block boundaries for debuggable code.
 */

void        Compiler::siEndBlock()
{
    assert(opts.compScopeInfo && info.compLocalVarsCount>0);

    if (siIgnoreBlock(compCurBB))
        return;

    LocalVarDsc * LocalVarDsc1;
    unsigned      endOffs = compCurBB->bbCodeOffs + compCurBB->bbCodeSize;

    // If non-debuggable code, find all scopes which end over this block
    // and close them. For debuggable code, scopes will only end on block
    // boundaries.

    LocalVarDsc1 = compGetNextExitScope(endOffs, !opts.compDbgCode);
    while (LocalVarDsc1)
    {
        unsigned    varNum     = LocalVarDsc1->lvdVarNum;
        LclVarDsc * lclVarDsc1 = &lvaTable[varNum];

        assert(lclVarDsc1);

        if (lclVarDsc1->lvTracked)
        {
            siEndTrackedScope(lclVarDsc1->lvVarIndex);
        }
        else
        {
            siEndScope(LocalVarDsc1->lvdVarNum);
        }
        LocalVarDsc1 = compGetNextExitScope(endOffs, !opts.compDbgCode);
    }

    siLastEndOffs = endOffs;

#ifdef DEBUG
    if (verbose&&0) siDispOpenScopes();
#endif

}

/*****************************************************************************
 *                          siUpdate
 *
 * Called at the start of basic blocks, and during code-gen of a block,
 * for non-debuggable code, whenever the
 * life of any tracked variable changes and the appropriate code has
 * been generated. For debuggable code, variables are
 * live over their enitre scope, and so they go live or dead only on
 * block boundaries.
 */

void        Compiler::siUpdate ()
{
    assert(opts.compScopeInfo && !opts.compDbgCode && info.compLocalVarsCount>0);

    unsigned        i;
    VARSET_TP       varbit, killed = siLastLife & ~genCodeCurLife & lvaTrackedVars;

    for (i = 0, varbit=1;
        (i < lvaTrackedCount) && (killed);
        varbit<<=1, i++)
    {
        if (! (varbit & killed))
            continue;

        killed             &= ~varbit;       // delete the bit
        unsigned varIndex   = genVarBitToIndex(varbit);
#ifdef DEBUG
        unsigned        lclNum = lvaTrackedToVarNum[varIndex];
        LclVarDsc *     lclVar = &lvaTable[lclNum];        
        assert(lclVar->lvTracked);
#endif

        siScope * scope = siLatestTrackedScopes[varIndex];
        siEndTrackedScope(varIndex);

        if (scope)
        {
            /* @TODO [REVISIT] [04/16/01] []: A variable dies when its GenTree is processed,
             * even before the corresponding instruction has been emitted.
             * We need to extend the lifetime a bit (even by 1 byte)
             * for correct results
             */

//          assert(!"Var should go dead *after* the current instr is emitted");
        }
    }

    siLastLife = genCodeCurLife;
}

/*****************************************************************************
 *  In optimized code, we may not have access to gtLclVar.gtLclILoffs.
 *  So there may be ambiguity as to which entry in info.compLocalVars
 *  to use. We search the entire table and find the entry whose life
 *  begins closest to the given offset
 */

void            Compiler::siNewScopeNear(unsigned           varNum,
                                         NATIVE_IP          offs)
{
    assert(opts.compDbgInfo && !opts.compDbgCode);

    LocalVarDsc *   local           = info.compLocalVars;
    int             closestLifeBeg  = INT_MAX;
    LocalVarDsc *   closestLocal    = NULL;

    for (unsigned i=0; i<info.compLocalVarsCount; i++, local++)
    {
        if (local->lvdVarNum == varNum)
        {
            int diff = local->lvdLifeBeg - offs;
            if (diff < 0) diff = -diff;

            if (diff < closestLifeBeg)
            {
                closestLifeBeg = diff;
                closestLocal   = local;
            }
        }
    }

    if (!closestLocal)
        return;

    siNewScope(closestLocal->lvdLVnum, varNum, true);
}

/*****************************************************************************
 *                          siCheckVarScope
 *
 * For non-debuggable code, whenever we come across a GenTree which is an
 * assignment to a local variable, this function is called to check if the
 * variable has an open scope. Also, check if it has the correct LVnum.
 */

void            Compiler::siCheckVarScope (unsigned         varNum,
                                           IL_OFFSET        offs)
{
    assert(opts.compScopeInfo && !opts.compDbgCode && info.compLocalVarsCount>0);

    siScope *       scope;
    LclVarDsc *     lclVarDsc1 = &lvaTable[varNum];

    // If there is an open scope correspongind to varNum, find it

    if (lclVarDsc1->lvTracked)
    {
        scope = siLatestTrackedScopes[lclVarDsc1->lvVarIndex];
    }
    else
    {
        for (scope = siOpenScopeList.scNext; scope; scope = scope->scNext)
        {
            if (scope->scVarNum == varNum)
                break;
        }
    }

    // UNDONE : This needs to be changed to do a better lookup

    // Look up the info.compLocalVars[] to find the local var info for (varNum->lvSlotNum, offs)

    LocalVarDsc * LocalVarDsc1 = NULL;

    for (unsigned i=0; i<info.compLocalVarsCount; i++)
    {
        if (   (info.compLocalVars[i].lvdVarNum  == varNum)
            && (info.compLocalVars[i].lvdLifeBeg <= offs)
            && (info.compLocalVars[i].lvdLifeEnd >  offs) )
        {
            LocalVarDsc1 = & info.compLocalVars[i];
            break;
        }
    }

    // UNDONE
    //assert(LocalVarDsc1 || !"This could be coz of a temp. Need to handle that case");
    if (!LocalVarDsc1)
        return;

    // If the currently open scope does not have the correct LVnum, close it
    // and create a new scope with this new LVnum

    if (scope)
    {
        if (scope->scLVnum != LocalVarDsc1->lvdLVnum)
        {
            siEndScope (scope);
            siNewScope (LocalVarDsc1->lvdLVnum, LocalVarDsc1->lvdVarNum);
        }
    }
    else
    {
        siNewScope (LocalVarDsc1->lvdLVnum, LocalVarDsc1->lvdVarNum);
    }
}



/*****************************************************************************
 *                          siStackLevelChanged
 *
 * If the code-gen changes the stack, we have to change the stack-offsets
 * of any live stack variables we may have.
 */

void            Compiler::siStackLevelChanged()
{
    assert(opts.compScopeInfo && info.compLocalVarsCount>0);

#if TGT_x86
    if (genStackLevel == siLastStackLevel)
        return;
    else
        siLastStackLevel = genStackLevel;
#endif

    // If EBP is used for both parameters and locals, do nothing

    if (genFPused)
    {
#if DOUBLE_ALIGN
        assert(!genDoubleAlign);
#endif
        return;
    }

    if (siOpenScopeList.scNext == NULL)
    {
        return;
    }

    siScope * last = siOpenScopeLast;
    siScope * prev = NULL;

    for (siScope * scope = siOpenScopeList.scNext; ; scope = scope->scNext)
    {
        siScope *   newScope;

        if (prev == last)
            break;
        else
            prev = scope;

        assert(scope);

        // ignore register variables
        if (lvaTable[scope->scVarNum].lvRegister)
            continue;

        // ignore EBP-relative vars
        if  (lvaTable[scope->scVarNum].lvFPbased)
            continue;

        siEndScope(scope);

        newScope = siNewScope(scope->scLVnum, scope->scVarNum, scope->scAvailable);
    }
}

/*****************************************************************************
 *                          siCloseAllOpenScopes
 *
 * For unreachable code, or optimized code with blocks reordered, there may be 
 * scopes left open at the end. Simply close them.
 */

void            Compiler::siCloseAllOpenScopes()
{
    assert(siOpenScopeList.scNext);

    while(siOpenScopeList.scNext)
        siEndScope(siOpenScopeList.scNext);
}

/*****************************************************************************
 *                          siDispOpenScopes
 *
 * Displays all the vars on the open-scope list
 */

#ifdef DEBUG

void            Compiler::siDispOpenScopes()
{
    assert(opts.compScopeInfo && info.compLocalVarsCount>0);

    printf ("Open scopes = ");

    for (siScope * scope = siOpenScopeList.scNext; scope; scope = scope->scNext)
    {
        LocalVarDsc * localVars = info.compLocalVars;

        for (unsigned i=0; i < info.compLocalVarsCount; i++, localVars++)
        {
            if (localVars->lvdLVnum == scope->scLVnum)
            {
                printf ("%s ", lvdNAMEstr(localVars->lvdName));
                break;
            }
        }
    }
    printf ("\n");
}

#endif



/*============================================================================
 *
 *              Implementation for PrologScopeInfo
 *
 *============================================================================
 */


/*****************************************************************************
 *                      psiNewPrologScope
 *
 * Creates a new scope and adds it to the Open scope list.
 */

Compiler::psiScope *
                Compiler::psiNewPrologScope(unsigned        LVnum,
                                            unsigned        slotNum)
{
    psiScope * newScope = (psiScope *) compGetMem(sizeof(*newScope));

    newScope->scStartBlock   = genEmitter->emitCurBlock();
    newScope->scStartBlkOffs = genEmitter->emitCurOffset();

    assert(newScope->scStartBlock);

    newScope->scEndBlock     = NULL;
    newScope->scEndBlkOffs   = 0;

    newScope->scLVnum        = LVnum;
    newScope->scSlotNum      = slotNum;

    newScope->scNext         = NULL;
    psiOpenScopeLast->scNext = newScope;
    newScope->scPrev         = psiOpenScopeLast;
    psiOpenScopeLast         = newScope;

    return newScope;
}



/*****************************************************************************
 *                          psiEndPrologScope
 *
 * Remove the scope from the Open-scope list and add it to the finished-scopes
 * list if its length is non-zero
 */

void                Compiler::psiEndPrologScope(psiScope * scope)
{
    scope->scEndBlock    = genEmitter->emitCurBlock();
    scope->scEndBlkOffs  = genEmitter->emitCurOffset();

    assert(scope->scEndBlock);

    // Remove from open-scope list
    scope->scPrev->scNext       = scope->scNext;
    if (scope->scNext)
    {
        scope->scNext->scPrev   = scope->scPrev;
    }
    else
    {
        psiOpenScopeLast        = scope->scPrev;
    }

    // add to the finished scope list, if the length is non-zero.
    if (scope->scStartBlock   != scope->scEndBlock ||
        scope->scStartBlkOffs != scope->scEndBlkOffs)
    {
        psiScopeLast->scNext = scope;
        psiScopeLast         = scope;
        psiScopeCnt++;
    }
}



/*============================================================================
 *           INTERFACE (public) Functions for PrologScopeInfo
 *============================================================================
 */

/*****************************************************************************
 *                          psiBegProlog
 *
 * Initializes the PrologScopeInfo, and creates open scopes for all the
 * parameters of the method.
 */

void                Compiler::psiBegProlog()
{
    LocalVarDsc * LocalVarDsc1;

    psiOpenScopeList.scNext     = NULL;
    psiOpenScopeLast            = &psiOpenScopeList;
    psiScopeLast                = &psiScopeList;
    psiScopeCnt                 = 0;

    compResetScopeLists();

    for(LocalVarDsc1 = compGetNextEnterScope(0); LocalVarDsc1; LocalVarDsc1 = compGetNextEnterScope(0))
    {
        LclVarDsc * lclVarDsc1 = &lvaTable[LocalVarDsc1->lvdVarNum];

        if (!lclVarDsc1->lvIsParam)
            continue;

        psiScope * newScope      = psiNewPrologScope(LocalVarDsc1->lvdLVnum,
                                                     LocalVarDsc1->lvdVarNum);

        if  (lclVarDsc1->lvIsRegArg)
        {
            assert(genRegArgIdx(lclVarDsc1->lvArgReg) != -1);

            newScope->scRegister     = true;
            newScope->scRegNum       = lclVarDsc1->lvArgReg;
        }
        else
        {
            newScope->scRegister     = false;
            newScope->scBaseReg      = REG_SPBASE;

            if (DOUBLE_ALIGN_NEED_EBPFRAME)
            {
                // sizeof(int) - for one DWORD for the pushed value of EBP
                newScope->scOffset   =   lclVarDsc1->lvStkOffs - sizeof(int);
            }
            else
            {
                /* compCalleeRegsPushed gets set in genFnProlog(). That should 
                   have been been called by now */
                assert(compCalleeRegsPushed != 0xDD);

                newScope->scOffset   =   lclVarDsc1->lvStkOffs 
                                       - compLclFrameSize
                                       - compCalleeRegsPushed * sizeof(int);
            }
        }
    }
}

/*****************************************************************************
 *                          psiAdjustStackLevel
 *
 * When ESP changes, all scopes relative to ESP have to be updated.
 */

void                Compiler::psiAdjustStackLevel(unsigned size)
{
    psiScope * scope;

    // walk the list backwards
    // Works as psiEndPrologScope does not change scPrev
    for (scope = psiOpenScopeLast; scope != &psiOpenScopeList; scope = scope->scPrev)
    {
        if  (scope->scRegister)
        {
            assert(lvaTable[scope->scSlotNum].lvIsRegArg);
            continue;
        }
        assert(scope->scBaseReg == REG_SPBASE);

        psiScope * newScope     = psiNewPrologScope(scope->scLVnum, scope->scSlotNum);
        newScope->scRegister    = false;
        newScope->scBaseReg     = REG_SPBASE;
        newScope->scOffset      = scope->scOffset + size;

        psiEndPrologScope (scope);
    }
}



/*****************************************************************************
 *                          psiMoveESPtoEBP
 *
 * For EBP-frames, the parameters are accessed via ESP on entry to the function,
 * but via EBP right after a "mov ebp,esp" instruction
 */

void                Compiler::psiMoveESPtoEBP()
{
    assert(DOUBLE_ALIGN_NEED_EBPFRAME);

    psiScope * scope;

    // walk the list backwards
    // Works as psiEndPrologScope does not change scPrev
    for (scope = psiOpenScopeLast; scope != &psiOpenScopeList; scope = scope->scPrev)
    {
        if  (scope->scRegister)
        {
            assert(lvaTable[scope->scSlotNum].lvIsRegArg);
            continue;
        }
        assert(scope->scBaseReg == REG_SPBASE);

        psiScope * newScope     = psiNewPrologScope(scope->scLVnum, scope->scSlotNum);
        newScope->scRegister    = false;
        newScope->scBaseReg     = REG_FPBASE;
        newScope->scOffset      = scope->scOffset;

        psiEndPrologScope (scope);
    }
}



/*****************************************************************************
 *                          psiMoveToReg
 *
 * Called when a parameter is loaded into its assigned register from the stack,
 *
 *
 * or when parameters are moved around due to circular dependancy.
 * If reg!=REG_NA, then the parameter is being moved into its assigned 
 * register, else it may be being moved to a temp register.
 *
 *
 */

void            Compiler::psiMoveToReg (unsigned    varNum, 
                                        regNumber   reg, 
                                        regNumber   otherReg)
{
    assert(lvaTable[varNum].lvRegister);

    /* If reg!=REG_NA, the parameter is part of a cirular dependancy, and is
     * being moved through temp register "reg".
     * If reg==REG_NA, it is being moved to its assigned register.
     */
    if  (reg == REG_NA)
    {
        // Grab the assigned registers.

        reg      = lvaTable[varNum].lvRegNum;
        otherReg = lvaTable[varNum].lvOtherReg;
    }

    psiScope * scope;

    // walk the list backwards
    // Works as psiEndPrologScope does not change scPrev
    for (scope = psiOpenScopeLast; scope != &psiOpenScopeList; scope = scope->scPrev)
    {
        if (scope->scSlotNum != lvaTable[varNum].lvSlotNum)
            continue;

        psiScope * newScope     = psiNewPrologScope(scope->scLVnum, scope->scSlotNum);
        newScope->scRegister    = true;
        newScope->scRegNum      = reg;
        newScope->scOtherReg    = otherReg;

        psiEndPrologScope (scope);
        return;
    }

    // May happen if a parameter does not have an entry in the LocalVarTab
    // But assert() just in case it is because of something else.
    assert(varNum == (unsigned)info.compRetBuffArg || 
           !"Parameter scope not found (Assert doesnt always indicate error)");
}


/*****************************************************************************
 *                      Compiler::psiMoveToStack
 *
 * A incoming register-argument is being moved to its final home on the stack
 * (ie. all adjustements to {F/S}PBASE have been made
 */

void                Compiler::psiMoveToStack(unsigned   varNum)
{
    assert( lvaTable[varNum].lvIsRegArg);
    assert(!lvaTable[varNum].lvRegister);

    psiScope * scope;

    // walk the list backwards
    // Works as psiEndPrologScope does not change scPrev
    for (scope = psiOpenScopeLast; scope != &psiOpenScopeList; scope = scope->scPrev)
    {
        if (scope->scSlotNum != lvaTable[varNum].lvSlotNum)
            continue;

        /* The param must be currently sitting in the register in which it
           was passed in */
        assert(scope->scRegister);
        assert(scope->scRegNum == lvaTable[varNum].lvArgReg);

        psiScope * newScope     = psiNewPrologScope(scope->scLVnum, scope->scSlotNum);
        newScope->scRegister    = false;        
        newScope->scBaseReg     = (lvaTable[varNum].lvFPbased) ? REG_FPBASE
                                                               : REG_SPBASE;
        newScope->scOffset      = lvaTable[varNum].lvStkOffs;

        psiEndPrologScope (scope);
        return;
    }

    // May happen if a parameter does not have an entry in the LocalVarTab
    // But assert() just in case it is because of something else.
    assert(varNum == (unsigned)info.compRetBuffArg || 
           !"Parameter scope not found (Assert doesnt always indicate error)");
}

/*****************************************************************************
 *                          psiEndProlog
 */

void                Compiler::psiEndProlog()
{
    psiScope * scope;

    for(scope = psiOpenScopeList.scNext; scope; scope = psiOpenScopeList.scNext)
    {
        psiEndPrologScope(scope);
    }
}





/*****************************************************************************/
#endif // DEBUGGING_SUPPORT
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\target.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _TARGET_H_
#define _TARGET_H_
/*****************************************************************************/

#ifndef SCHEDULER
#error 'SCHEDULER' should be defined by the time we get here (like in jit.h) !
#endif

/*****************************************************************************/
/*                  The following is for x86                                 */
/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************/

#define CPU_NAME        "x86"

/*****************************************************************************/

#define STK_FASTCALL    0           // reserve space on stack for reg args?
#define NST_FASTCALL    1           // fastcall calls allowed to nest?

#define ARG_ORDER_L2R   1
#define ARG_ORDER_R2L   0

/*****************************************************************************/

enum _regNumber_enum
{
    #define REGDEF(name, rnum, mask, byte)  REG_##name = rnum,
    #include "register.h"
    #undef  REGDEF

    REG_COUNT,
    REG_NA = REG_COUNT,
};

enum _regMask_enum
{
    RBM_NONE = 0,

    #define REGDEF(name, rnum, mask, byte)  RBM_##name = mask,
    #include "register.h"
    #undef  REGDEF
};

/* The following are used to hold 'long' (64-bit integer) operands */

#ifdef DEBUG
#define REG_PAIR_FIRST 0x70
#else
#define REG_PAIR_FIRST 0x0
#endif

enum _regPairNo_enum
{
    #define PAIRDEF(rlo,rhi)    REG_PAIR_##rlo##rhi = REG_##rlo + (REG_##rhi << 4) + REG_PAIR_FIRST,
    #include "regpair.h"
    #undef  PAIRDEF

    REG_PAIR_LAST  = REG_PAIR_STKEDI + REG_PAIR_FIRST,
    REG_PAIR_NONE  = REG_PAIR_LAST + 1
};

enum regPairMask
{
    #define PAIRDEF(rlo,rhi)    RBM_PAIR_##rlo##rhi = (RBM_##rlo|RBM_##rhi),
    #include "regpair.h"
    #undef  PAIRDEF
};

/* We're using the encoding for ESP to indicate a half-long on the frame */

#define REG_L_STK               REG_ESP

/*
    The following yield the number of bits and the mask of a register
    number in a register pair.
 */

#define REG_PAIR_NBITS          4
#define REG_PAIR_NMASK          ((1<<REG_PAIR_NBITS)-1)

/*****************************************************************************/

#define CPU_FLT_REGISTERS       0
#define CPU_DBL_REGISTERS       0

#define CPU_HAS_FP_SUPPORT      1

/*****************************************************************************/

#define MAX_REGRET_STRUCT_SZ    8
#define RET_64BIT_AS_STRUCTS    0

/*****************************************************************************/

#define LEA_AVAILABLE           1
#define SCALED_ADDR_MODES       1

/*****************************************************************************/

#ifndef BIRCH_SP2               // this comes from the WinCE build switches
#define EMIT_USE_LIT_POOLS      0
#endif
#define EMIT_DSP_INS_NAME       "      %-11s "

#define EMIT_TRACK_STACK_DEPTH  1

/*****************************************************************************/

#ifdef  DEBUG
#define DSP_SRC_OPER_LEFT       0
#define DSP_SRC_OPER_RIGHT      1
#define DSP_DST_OPER_LEFT       1
#define DSP_DST_OPER_RIGHT      0
#endif

/*****************************************************************************/

enum addrModes
{
    AM_NONE,

    AM_REG,                         // register value
    AM_LCL,                         // local variable (on stack frame)
    AM_CONS,                        // constant

    AM_IND_ADDR,                    // [addr               ]

    AM_IND_REG1,                    // [reg1               ]
    AM_IND_REG1_DISP,               // [reg1          +disp]

    AM_IND_MUL2,                    // [     mult*reg2     ]
    AM_IND_MUL2_DISP,               // [     mult*reg2+disp]

    AM_IND_REG1_REG2,               // [reg1+reg2          ]
    AM_IND_REG1_REG2_DISP,          // [reg1+reg2     +disp]

    AM_IND_REG1_MUL2,               // [reg1+mult*reg2     ]
    AM_IND_REG1_MUL2_DISP,          // [reg1+mult*reg2+disp]
};

/*****************************************************************************/

#define RBM_ALL                 (RBM_EAX|RBM_EDX|RBM_ECX|RBM_EBX|   \
                                 RBM_ESI|RBM_EDI|RBM_EBP)

#define RBM_BYTE_REGS           (RBM_EAX|RBM_EBX|RBM_ECX|RBM_EDX)
#define RBM_NON_BYTE_REGS       (RBM_ESI|RBM_EDI|RBM_EBP)

#define RBM_CALLEE_SAVED        (RBM_EBX|RBM_ESI|RBM_EDI|RBM_EBP)
#define RBM_CALLEE_TRASH        (RBM_EAX|RBM_ECX|RBM_EDX)

#define REG_VAR_LIST             REG_EAX,REG_EDX,REG_ECX,REG_ESI,REG_EDI,REG_EBX,REG_EBP

// We reuse the ESP register as a flag for byteable registers in lvPrefReg
#define RBM_BYTE_REG_FLAG       RBM_ESP

// We reuse the ESP register as a illegal value in the register predictor
#define RBM_ILLEGAL             RBM_ESP

// We reuse the ESP register as a flag for last use handling in the register predictor
#define RBM_LASTUSE             RBM_ESP

// Where is the exception object on entry to the handler block ?
#define REG_EXCEPTION_OBJECT     REG_EAX
#define RBM_EXCEPTION_OBJECT     RBM_EAX

// The follow three defines are useful for interating a regNumber
#define REG_FIRST                REG_EAX
#define REG_LAST                 REG_EDI
#define REG_NEXT(reg)           ((regNumber)((unsigned)reg + 1))

// genCodeForCall() moves the target address of the tailcall into this
// register, before pushing it on the stack
#define REG_TAILCALL_ADDR   REG_EAX

// Which register are int and long values returned in ?
#define REG_INTRET               REG_EAX
#define RBM_INTRET               RBM_EAX
#define REG_LNGRET               REG_PAIR_EAXEDX
#define RBM_LNGRET              (RBM_EDX|RBM_EAX)

#define REG_FPBASE               REG_EBP
#define RBM_FPBASE               RBM_EBP
#define REG_SPBASE               REG_ESP
#define RBM_SPBASE               RBM_ESP

#if     ALLOW_MIN_OPT
#define RBM_MIN_OPT_LCLVAR_REGS (RBM_ESI|RBM_EDI)
#endif

#define FIRST_ARG_STACK_OFFS    8

#define RETURN_ADDR_OFFS        1       // in DWORDS

#define CALLEE_SAVED_REG_MAXSZ  (4*sizeof(int)) // EBX,ESI,EDI,EBP

#define MAX_EPILOG_SIZE          15

/*****************************************************************************/

#define MAX_REG_ARG             2

#define REG_ARG_0               REG_ECX //REG_ECX
#define REG_ARG_1               REG_EDX //REG_EAX

#define RBM_ARG_0               RBM_ECX //RBM_ECX
#define RBM_ARG_1               RBM_EDX //RBM_EAX

#define RBM_ARG_REGS            (RBM_ARG_0|RBM_ARG_1)

/*****************************************************************************/

#define FP_STK_SIZE             8

/*****************************************************************************/

#define REGNUM_BITS             3               // number of bits in reg#

typedef unsigned                regMaskTP;
typedef unsigned char           regMaskSmall;
typedef unsigned                regPairMaskTP;
typedef unsigned short          regPairMaskSmall;

#ifdef DEBUG
typedef _regNumber_enum         regNumber;
typedef _regNumber_enum         regNumberSmall;
typedef _regPairNo_enum         regPairNo;
typedef _regPairNo_enum         regPairNoSmall;
#else
typedef unsigned int            regNumber;
typedef unsigned char           regNumberSmall;
typedef unsigned int            regPairNo;
typedef unsigned char           regPairNoSmall;
#endif

inline  int isByteReg(regNumber reg) { return reg <= REG_EBX; }

#define JMP_DIST_SMALL_MAX_NEG  (-128)
#define JMP_DIST_SMALL_MAX_POS  (+127)

#define JCC_DIST_SMALL_MAX_NEG  (-128)
#define JCC_DIST_SMALL_MAX_POS  (+127)

#define JMP_SIZE_SMALL          (2)
#define JMP_SIZE_LARGE          (5)

#define JCC_SIZE_SMALL          (2)
#define JCC_SIZE_LARGE          (6)

#define JMP_SIZE_SMALL_MIN      (2)     // smaller of JMP_SIZE_SMALL and JCC_SIZE_SMALL
#define JMP_SIZE_SMALL_MAX      (2)     // larger  of JMP_SIZE_SMALL and JCC_SIZE_SMALL

#define PUSH_INST_SIZE          (5)
#define CALL_INST_SIZE          (5)

#define LARGEST_JUMP_SIZE       (6)

#define JMP_INSTRUCTION         INS_jmp

#define MAX_BRANCH_DELAY_LEN    0       // the x86 has no branch-delay slots

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Define target-dependent scheduling values that need to be kept track of.
 */

#define SCHED_USE_FL            1       // scheduler needs to know about flags

struct  scExtraInfo
{
    bool        stackDep;
};

#define             scTgtDepDcl()                                   \
                                                                    \
    schedDef_tp     scFPUdef;                                       \
    schedUse_tp     scFPUuse;

#define             scTgtDepClr()                                   \
                                                                    \
    scFPUdef = 0;                                                   \
    scFPUuse = 0;

#define             scTgtDepDep(id,inf,dag)                         \
                                                                    \
    if  (inf & IS_FP_STK)                                           \
    {                                                               \
        scDepDef(dag, "FPUstk",  scFPUdef,  scFPUuse);              \
        scDepUse(dag, "FPUstk",  scFPUdef,  scFPUuse);              \
    }

#define             scTgtDepUpd(id,inf,dag)                         \
                                                                    \
    if  (inf & IS_FP_STK)                                           \
    {                                                               \
        scUpdDef(dag, &scFPUdef, &scFPUuse);                        \
        scUpdUse(dag, &scFPUdef, &scFPUuse);                        \
    }

#endif
/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/

#ifdef  TGT_SH3

        #include "targetSH3.h"

#endif  //TGT_SH3

#ifdef  TGT_MIPS32

        #include "targetMIPS.h"

#endif  // TGT_MIPS32

#ifdef  TGT_ARM

        #include "targetARM.h"

#endif  //TGT_ARM

#ifdef  TGT_PPC

        #include "targetPPC.h"

#endif  //TGT_PPC

/*****************************************************************************/

#ifdef DEBUG
const   char *      getRegName(unsigned  regNum);
extern  void        dspRegMask(regMaskTP regMask, size_t minSiz = 0);
#endif

/*****************************************************************************
 *
 *  Map a register number to a register mask.
 */

extern
const regMaskSmall  regMasks[REG_COUNT];

inline
regMaskTP           genRegMask(regNumber reg)
{
    assert(reg < sizeof(regMasks)/sizeof(regMasks[0]));

    return regMasks[reg];
}

/*****************************************************************************
 *
 *  Returns the register that holds the low  32 bits of the long value given
 *  by the register pair 'regPair'.
 */

#ifndef BIRCH_SP2

inline
regNumber           genRegPairLo(regPairNo regPair)
{
    assert(regPair >= REG_PAIR_FIRST &&
           regPair <= REG_PAIR_LAST);

    return  (regNumber)((regPair - REG_PAIR_FIRST) & REG_PAIR_NMASK);
}

#endif // not BIRCH_SP2

/*****************************************************************************
 *
 *  Returns the register that holds the high 32 bits of the long value given
 *  by the register pair 'regPair'.
 */

#ifndef BIRCH_SP2

inline
regNumber           genRegPairHi(regPairNo regPair)
{
    assert(regPair >= REG_PAIR_FIRST &&
           regPair <= REG_PAIR_LAST);

    return (regNumber)(((regPair - REG_PAIR_FIRST) >> REG_PAIR_NBITS) & REG_PAIR_NMASK);
}

#endif // not BIRCH_SP2

/*****************************************************************************
 * Return true if the registers is a valid value
 */

#ifndef BIRCH_SP2

inline
bool                genIsValidReg(regNumber reg)
{
    /* It's safest to perform an unsigned comparison in case reg is negative */
    return ((unsigned) reg < (unsigned) REG_COUNT);
}

#endif // not BIRCH_SP2

/*****************************************************************************
 *
 *  Returns whether regPair is a combination of two "real" registers
 *  or whether it contains a pseudo register.
 *
 *  In debug it also asserts that reg1 and reg2 are not the same.
 */

#ifndef BIRCH_SP2

BOOL                genIsProperRegPair(regPairNo regPair);

#endif // not BIRCH_SP2

/*****************************************************************************
 *
 *  Returns the register pair number that corresponds to the given two regs.
 */

#ifndef BIRCH_SP2

inline
regPairNo           gen2regs2pair(regNumber regLo, regNumber regHi)
{
    assert(regLo != regHi);
    assert(genIsValidReg(regLo) && genIsValidReg(regHi));
    assert(regLo != REG_L_STK && regHi != REG_L_STK);

    regPairNo regPair = (regPairNo)(regLo+(regHi<<REG_PAIR_NBITS)+REG_PAIR_FIRST);

    assert(regLo == genRegPairLo(regPair));
    assert(regHi == genRegPairHi(regPair));

    return regPair;
}

#endif // not BIRCH_SP2

/*****************************************************************************/

#ifndef BIRCH_SP2

inline
regMaskTP           genRegPairMask(regPairNo regPair)
{
    assert(regPair >= REG_PAIR_FIRST &&
           regPair <= REG_PAIR_LAST);

    return genRegMask(genRegPairLo(regPair))|genRegMask(genRegPairHi(regPair));
}

#endif // not BIRCH_SP2

/*****************************************************************************/
#ifndef BIRCH_SP2

inline
regNumber           genRegArgNum(unsigned argNum)
{
    assert (argNum < MAX_REG_ARG);

    switch (argNum)
    {
    case 0: return REG_ARG_0;
#if MAX_REG_ARG >= 2
    case 1: return REG_ARG_1;
#if MAX_REG_ARG >= 3
    case 2: return REG_ARG_2;
#if MAX_REG_ARG >= 4
    case 3: return REG_ARG_3;
#if MAX_REG_ARG >= 5
#error  Add some more code over here, will ya?!
#endif
#endif
#endif
#endif
    default: assert(!"too many reg args!"); return REG_NA;
    }
}

inline
unsigned           genRegArgIdx(regNumber regNum)
{
    assert (genRegMask(regNum) & RBM_ARG_REGS);

    switch (regNum)
    {
    case REG_ARG_0: return 0;
    case REG_ARG_1: return 1;
#if MAX_REG_ARG >= 3
    case REG_ARG_2: return 2;
#if MAX_REG_ARG >= 4
    case REG_ARG_3: return 3;
#if MAX_REG_ARG >= 5
    case REG_ARG_4: return 4;
#endif
#endif
#endif
    default: assert(!"invalid register arg register"); return (unsigned)-1;
    }
}

inline
regMaskTP           genRegArgMask(unsigned totalArgs)
{
    assert (totalArgs <= MAX_REG_ARG);

    switch (totalArgs)
    {
    case 0: return RBM_NONE;
    case 1: return RBM_ARG_0;
#if MAX_REG_ARG >= 2
    case 2: return RBM_ARG_0|RBM_ARG_1;
#if MAX_REG_ARG >= 3
    case 3: return RBM_ARG_0|RBM_ARG_1|RBM_ARG_2;
#if MAX_REG_ARG >= 4
    case 4: return RBM_ARG_0|RBM_ARG_1|RBM_ARG_2|RBM_ARG_3;
#if MAX_REG_ARG >= 5
#error  Add some more code over here, will ya?!
#endif
#endif
#endif
#endif
    default: assert(!"invalid register arg number"); return REG_NA;
    }
}

#endif // not BIRCH_SP2

/*****************************************************************************/
#if ARG_ORDER_L2R != !ARG_ORDER_R2L
#error  Please make up your mind as to what order are arguments pushed in.
#endif
#if STK_FASTCALL  != !NST_FASTCALL
#error  Please make up your mind as to whether stack space is needed for register args.
#endif
/*****************************************************************************/

/*****************************************************************************/
#endif  // _TARGET_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\targetsh3.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/************************************************************************
*
 Confidential.
*
***********************************************************************/
// -*- C++ -*-


#define CPU_NAME        "SH3"

/*****************************************************************************/

#define STK_FASTCALL    1           // reserve space on stack for reg args?
#define NST_FASTCALL    0           // fastcall calls allowed to nest?

#define ARG_ORDER_L2R   0
#define ARG_ORDER_R2L   1

/*****************************************************************************/

enum regNumber
{
    #define REGDEF(name, strn, rnum, mask) REG_##name = rnum,
    #include "regSH3.h"
    #undef  REGDEF

    REG_COUNT,
    REG_NA = REG_COUNT
};

enum regMasks
{
    #define REGDEF(name, strn, rnum, mask) RBM_##name = mask,
    #include "regSH3.h"
    #undef  REGDEF
};

#ifndef BIRCH_SP2
/* The following are used to hold 64-bit integer operands */

#ifdef DEBUG
#define REG_PAIR_FIRST 0x70
#else
#define REG_PAIR_FIRST 0x0
#endif

enum regPairNo
{
    #define PAIRDEF(rlo,rhi)    REG_PAIR_##rlo##rhi = REG_##rlo + (REG_##rhi << 4) + REG_PAIR_FIRST,
    #include "regpair.h"
    #undef  PAIRDEF

    REG_PAIR_LAST  = REG_PAIR_STKr14 + REG_PAIR_FIRST,
    REG_PAIR_NONE  = REG_PAIR_LAST + 1
};

enum regPairMask
{
    #define PAIRDEF(rlo,rhi)    RBM_PAIR_##rlo##rhi = (RBM_##rlo|RBM_##rhi),
    #include "regpair.h"
    #undef  PAIRDEF
};
#endif

/* We're using the encoding for r15 to indicate a half-long on the frame */

#define REG_L_STK               REG_r15

#ifndef BIRCH_SP2
/*
    The following yield the number of bits and the mask of a register
    number in a register pair.
 */

#define REG_PAIR_NBITS          4
#define REG_PAIR_NMASK          ((1<<REG_PAIR_NBITS)-1)
#endif

/*****************************************************************************/

#define REGNUM_BITS             4               // number of bits in reg#

#ifdef BIRCH_SP2
typedef unsigned                regMaskTP;
typedef unsigned short          regMaskSmall;
typedef regNumber               regNumberSmall;
#else
typedef unsigned                regMaskTP;
typedef unsigned short          regMaskSmall;
typedef unsigned                regPairMaskTP;
typedef unsigned short          regPairMaskSmall;

#ifndef DEBUG
typedef unsigned int            regNumber;
typedef unsigned int            regPairNo;
typedef unsigned char           regNumberSmall;
typedef unsigned short          regPairNoSmall;
#else
typedef regNumber               regNumberSmall;
typedef regPairNo               regPairNoSmall;
#endif
#endif

/*****************************************************************************/

#define CPU_FLT_REGISTERS       0
#define CPU_DBL_REGISTERS       0

#define CPU_HAS_FP_SUPPORT      0

#define USE_HELPERS_FOR_INT_DIV 1

/*****************************************************************************/

#define MAX_REGRET_STRUCT_SZ    4
#define RET_64BIT_AS_STRUCTS    1

/*****************************************************************************/

#define LEA_AVAILABLE           0
#define SCALED_ADDR_MODES       0

/*****************************************************************************/

#define EMIT_USE_LIT_POOLS      1
#define EMIT_DSP_INS_NAME       "      %-11s "

#define EMIT_TRACK_STACK_DEPTH  0

/*****************************************************************************/

#ifdef  DEBUG
#define DSP_SRC_OPER_LEFT       1
#define DSP_SRC_OPER_RIGHT      0
#define DSP_DST_OPER_LEFT       0
#define DSP_DST_OPER_RIGHT      1
#endif

/*****************************************************************************/

#define MAX_INDREG_DISP         15  // NOTE: always scaled by operand size

/*****************************************************************************/

enum addrModes
{
    AM_NONE,

    AM_REG,                         // register value
    AM_LCL,                         // local variable (on stack frame)
    AM_CONS,                        // constant
    AM_GLOBAL,                      // global variable / static data member

    AM_IND_REG1,                    // [reg1       ]
    AM_IND_REG1_REG0,               // [reg1 + reg0]
    AM_IND_REG1_DISP,               // [reg1 + disp]
};

/*****************************************************************************/

#define RBM_ALL                 (RBM_r00|RBM_r01|RBM_r02|RBM_r03|       \
                                 RBM_r04|RBM_r05|RBM_r06|RBM_r07|       \
                                 RBM_r08|RBM_r09|RBM_r10|RBM_r11|       \
                                 RBM_r12|RBM_r13|RBM_r14|RBM_r15)

#define RBM_CALLEE_SAVED        (RBM_r08|RBM_r09|RBM_r10|RBM_r11|RBM_r12|RBM_r13|RBM_r14|RBM_r15)
#define RBM_CALLEE_TRASH        (RBM_ALL & ~RBM_CALLEE_SAVED)

#define CALLEE_SAVED_REG_MAXSZ  ((8+1)*sizeof(int)) // callee-saved + retaddr

#define MAX_EPILOG_SIZE          16

#if     ALLOW_MIN_OPT
#define RBM_MIN_OPT_LCLVAR_REGS  REG_r04,REG_r05,REG_r06,REG_r07,REG_r08,\
                                 REG_r09,REG_r10,REG_r11,REG_r12,REG_r13
#endif

#define REG_VAR_LIST                             REG_r02,REG_r03,REG_r04,REG_r05,REG_r06,REG_r07,\
                                 REG_r08,REG_r09,REG_r10,REG_r11,REG_r12,REG_r13,REG_r14,REG_r00

// Where is the exception object on entry to the handler block ?
#define REG_EXCEPTION_OBJECT     REG_r00
#define RBM_EXCEPTION_OBJECT     RBM_r00

// Which register are int and long values returned in ?
#define REG_INTRET               REG_r00
#define RBM_INTRET               RBM_r00
#define REG_LNGRET               REG_PAIR_r00r01
#define RBM_LNGRET              (RBM_r00|RBM_r01)

#define REG_FPBASE               REG_r14
#define RBM_FPBASE               RBM_r14
#define REG_SPBASE               REG_r15
#define RBM_SPBASE               RBM_r15

#define MAX_SPBASE_OFFS          (MAX_INDREG_DISP*sizeof(int))
#define MAX_FPBASE_OFFS          (MAX_INDREG_DISP*sizeof(int))

/*****************************************************************************/

#define MAX_REG_ARG             4

#define REG_ARG_0               REG_r04
#define REG_ARG_1               REG_r05
#define REG_ARG_2               REG_r06
#define REG_ARG_3               REG_r07

#define RBM_ARG_0               RBM_r04
#define RBM_ARG_1               RBM_r05
#define RBM_ARG_2               RBM_r06
#define RBM_ARG_3               RBM_r07

#define RBM_ARG_REGS            (RBM_ARG_0|RBM_ARG_1|RBM_ARG_2|RBM_ARG_3)

inline
bool                isRegParamType(var_types type)
{
    // HACK: don't pass longs/doubles in regs
    
    if  (type <= TYP_INT || type == TYP_FLOAT ||
         type == TYP_REF || type == TYP_BYREF)
        return  true;
    else
        return  false;
}

/*****************************************************************************/

#define FIRST_ARG_STACK_OFFS    0
#define MIN_OUT_ARG_RESERVE     16

/*****************************************************************************/

#define INSTRUCTION_SIZE        2

/*****************************************************************************/

#define IMMED_INT_MIN           (-128)
#define IMMED_INT_MAX           (+127)

/*****************************************************************************/

#define JMP_DIST_SMALL_MAX_NEG  (-0x2000)
#define JMP_DIST_SMALL_MAX_POS  (+0x1FFF)

#define JMP_DIST_MIDDL_MAX_NEG  (0)
#define JMP_DIST_MIDDL_MAX_POS  (0)

#define JMP_SIZE_SMALL          (2)     // bra target
#define JMP_SIZE_MIDDL          (0)     // no such thing
#define JMP_SIZE_LARGE          (12)     // mov [addr], rt ; jmp @rt ; nop

#define JCC_DIST_SMALL_MAX_NEG  (-0x00FE)
#define JCC_DIST_SMALL_MAX_POS  (+0x0100)

#define JCC_DIST_MIDDL_MAX_NEG  JMP_DIST_SMALL_MAX_NEG
#define JCC_DIST_MIDDL_MAX_POS  JMP_DIST_SMALL_MAX_POS

#define JCC_SIZE_SMALL          (2)
#define JCC_SIZE_MIDDL          (6)
#define JCC_SIZE_LARGE          (14)

#define JMP_SIZE_SMALL_MIN      (2)     // smaller of JMP_SIZE_SMALL and JCC_SIZE_SMALL
#define JMP_SIZE_SMALL_MAX      (2)     // larger  of JMP_SIZE_SMALL and JCC_SIZE_SMALL

#define LARGEST_JUMP_SIZE       (8)

#define JMP_INSTRUCTION         INS_bra

#define MAX_BRANCH_DELAY_LEN    1       // the max. number of branch-delay slots

/*****************************************************************************/

#ifndef BIRCH_SP2               // this comes from the Wce build switches
#define SMALL_DIRECT_CALLS      1
#endif

#define CALL_DIST_MAX_NEG       (-0x0200)
#define CALL_DIST_MAX_POS       (+0x01FE)

inline
BYTE  * emitDirectCallBase(BYTE *orig)
{
    return  orig + 2 * INSTRUCTION_SIZE;
}

/* Indirect calls consist of LIT_POOL_LOAD_INS followed by INDIRECT_CALL_INS */

#define LIT_POOL_LOAD_INS       INS_mov_PC
#define INDIRECT_CALL_INS       INS_jsr
#define   DIRECT_CALL_INS       INS_bsr

/*****************************************************************************/

#define LIT_POOL_MAX_OFFS_WORD  (0x100*sizeof(short))
#define LIT_POOL_MAX_OFFS_LONG  (0x100*sizeof(long ))

enum    LPfixTypes
{
    LPF_CLSVAR,                         // static data member
    LPF_METHOD,                         // non-virtual method
};

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Define target-dependent scheduling values that need to be kept track of.
 */

#define SCHED_USE_FL            1       // scheduler needs to know about flags

struct  scExtraInfo
{
    unsigned        scxDeps;
};

#define             scTgtDepDcl()                                   \
                                                                    \
    schedDef_tp     scMACdef, scPRRdef;                             \
    schedUse_tp     scMACuse, scPRRuse;

#define             scTgtDepClr()                                   \
                                                                    \
    scMACdef = scPRRdef = 0;                                        \
    scMACuse = scPRRuse = 0;

#define             scTgtDepDep(id,inf,dag)
#define             scTgtDepUpd(id,inf,dag)

#endif  // SCHEDULER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\typelist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if TRACK_GC_REFS
#define GCS  EA_GCREF
#define BRS  EA_BYREF
#else
#define GCS  4
#define BRS  4
#endif

/*  tn  - TYP_name
    nm  - name string
    jitType - The jit compresses types that are 'equivalent', this is the jit type genActualType()
    verType - Used for type checking
    sz  - size in bytes (genTypeSize(t))
    sze - size in bytes for the emitter (GC types are encoded) (emitTypeSize(t))
    asze- size in bytes for the emitter (GC types are encoded) (emitActualTypeSize(t))
    st  - stack slots (slots are sizeof(void*) bytes) (genTypeStSzs())
    al  - alignment
    tf  - flags
    howUsed - If a variable is used (referenced) as the type

DEF_TP(tn      ,nm        , jitType,    verType,    sz, sze,asze,st,al, tf,            howUsed     )
*/

DEF_TP(UNDEF   ,"<UNDEF>" , TYP_UNDEF,   TI_ERROR, 0,  0,  0,  0, 0, VTF_ANY,        0           )
DEF_TP(VOID    ,"void"    , TYP_VOID,    TI_ERROR, 0,  0,  0,  0, 0, VTF_ANY,        0           )

DEF_TP(BOOL    ,"bool"    , TYP_INT,     TI_BYTE,  1,  1,  4,  1, 1, VTF_INT|VTF_UNS,TYPE_REF_INT)
DEF_TP(BYTE    ,"byte"    , TYP_INT,     TI_BYTE,  1,  1,  4,  1, 1, VTF_INT,        TYPE_REF_INT)
DEF_TP(UBYTE   ,"ubyte"   , TYP_INT,     TI_BYTE,  1,  1,  4,  1, 1, VTF_INT|VTF_UNS,TYPE_REF_INT)

DEF_TP(CHAR    ,"char"    , TYP_INT,     TI_SHORT, 2,  2,  4,  1, 2, VTF_INT|VTF_UNS,TYPE_REF_INT)
DEF_TP(SHORT   ,"short"   , TYP_INT,     TI_SHORT, 2,  2,  4,  1, 2, VTF_INT,        TYPE_REF_INT)
DEF_TP(USHORT  ,"ushort"  , TYP_INT,     TI_SHORT, 2,  2,  4,  1, 2, VTF_INT|VTF_UNS,TYPE_REF_INT)

DEF_TP(INT     ,"int"     , TYP_INT,     TI_INT,   4,  4,  4,  1, 4, VTF_INT|VTF_I,  TYPE_REF_INT)
DEF_TP(UINT    ,"uint"    , TYP_INT,     TI_INT,   4,  4,  4,  1, 4, VTF_INT|VTF_UNS|VTF_I,TYPE_REF_INT) // Only used in GT_CAST nodes

DEF_TP(LONG    ,"long"    , TYP_LONG,    TI_LONG,  8,  4,  4,  2, 8, VTF_INT,        TYPE_REF_LNG)
DEF_TP(ULONG   ,"ulong"   , TYP_LONG,    TI_LONG,  8,  4,  4,  2, 8, VTF_INT|VTF_UNS,TYPE_REF_LNG)       // Only used in GT_CAST nodes

DEF_TP(FLOAT   ,"float"   , TYP_FLOAT,   TI_FLOAT, 4,  4,  4,  1, 4, VTF_FLT,        TYPE_REF_FLT)
DEF_TP(DOUBLE  ,"double"  , TYP_DOUBLE,  TI_DOUBLE,8,  4,  4,  2, 8, VTF_FLT,        TYPE_REF_DBL)

DEF_TP(REF     ,"ref"     , TYP_REF,     TI_REF,   4,GCS,GCS,  1, 4, VTF_ANY|VTF_GCR|VTF_I,TYPE_REF_PTR)
DEF_TP(BYREF   ,"byref"   , TYP_BYREF,   TI_ERROR, 4,BRS,BRS,  1, 4, VTF_ANY|VTF_BYR|VTF_I,TYPE_REF_BYR)
DEF_TP(ARRAY   ,"array"   , TYP_REF,     TI_REF,   4,GCS,GCS,  1, 4, VTF_ANY|VTF_GCR|VTF_I,TYPE_REF_PTR)
DEF_TP(STRUCT  ,"struct"  , TYP_STRUCT,  TI_STRUCT,0,  0,  0,  1, 4, VTF_ANY,        TYPE_REF_STC)

DEF_TP(BLK     ,"blk"     , TYP_BLK,     TI_ERROR, 0,  0,  0,  1, 4, VTF_ANY,        0           ) // blob of memory
DEF_TP(LCLBLK  ,"lclBlk"  , TYP_LCLBLK,  TI_ERROR, 0,  0,  0,  1, 4, VTF_ANY,        0           ) // preallocated memory for locspace

DEF_TP(PTR     ,"pointer" , TYP_PTR,     TI_ERROR, 4,  4,  4,  1, 4, VTF_ANY|VTF_I,  TYPE_REF_PTR) // (not currently used)
DEF_TP(FNC     ,"function", TYP_FNC,     TI_ERROR, 0,  4,  4,  0, 0, VTF_ANY|VTF_I,  0           )


DEF_TP(UNKNOWN ,"unknown" ,TYP_UNKNOWN,  TI_ERROR, 0,  0,  0,  0, 0, VTF_ANY,        0           )

#undef  GCS
#undef  BRS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\typeinfo.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          typeInfo                                         XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "_typeInfo.h"

/*****************************************************************************
 * Verify child is compatible with the template parent.  Basically, that 
 * child is a "subclass" of parent -it can be substituted for parent 
 * anywhere.  Note that if parent contains fancy flags, such as "uninitialised"
 * , "is this ptr", or  "has byref local/field" info, then child must also 
 * contain those flags, otherwise FALSE will be returned !
 *
 * Rules for determining compatibility:
 *
 * If parent is a primitive type or value class, then child must be the 
 * same primitive type or value class.  The exception is that the built in 
 * value classes System/Boolean etc. are treated as synonyms for 
 * TI_BYTE etc.
 *
 * If parent is a byref of a primitive type or value class, then child
 * must be a byref of the same (rules same as above case).
 *
 * Byrefs are compatible only with byrefs.
 *
 * If parent is an object, child must be a subclass of it, implement it 
 * (if it is an interface), or be null.
 *
 * If parent is an array, child must be the same or subclassed array.
 *
 * If parent is a null objref, only null is compatible with it.
 *
 * If the "uninitialised", "by ref local/field", "this pointer" or other flags 
 * are different, the items are incompatible.
 *
 * parent CANNOT be an undefined (dead) item.
 *
 */

BOOL         Compiler::tiCompatibleWith          (const typeInfo& child,
                                                  const typeInfo& parent) const
{
    assert(child.IsDead() || NormaliseForStack(child) == child);
    assert(parent.IsDead() || NormaliseForStack(parent) == parent);

    if (child == parent)
        return(TRUE);

    if (parent.IsType(TI_REF))
    {
        // An uninitialized objRef is not compatible to initialized.
        if (child.IsUninitialisedObjRef() && !parent.IsUninitialisedObjRef())
            return FALSE;

        if (child.IsNullObjRef())                   // NULL can be any reference type
            return TRUE;
        if (!child.IsType(TI_REF))
            return FALSE;

        return info.compCompHnd->canCast(child.m_cls, parent.m_cls);
    }
    else if (parent.IsType(TI_METHOD))
    {
        if (!child.IsType(TI_METHOD))
            return FALSE;

            // Right now we don't bother merging method handles
        return FALSE;
    }
    return FALSE;
}

/*****************************************************************************
 * Merge pDest and pSrc to find some commonality (e.g. a common parent).
 * Copy the result to pDest, marking it dead if no commonality can be found.
 *
 * null ^ null                  -> null
 * Object ^ null                -> Object
 * [I4 ^ null                   -> [I4
 * InputStream ^ OutputStream   -> Stream
 * InputStream ^ NULL           -> InputStream
 * [I4 ^ Object                 -> Object
 * [I4 ^ [Object                -> Array
 * [I4 ^ [R8                    -> Array
 * [Foo ^ I4                    -> DEAD
 * [Foo ^ [I1                   -> Array
 * [InputStream ^ [OutputStream -> Array
 * DEAD ^ X                     -> DEAD
 * [Intfc ^ [OutputStream       -> Array
 * Intf ^ [OutputStream         -> Object
 * [[InStream ^ [[OutStream     -> Array
 * [[InStream ^ [OutStream      -> Array
 * [[Foo ^ [Object              -> Array
 *
 * Importantly:
 * [I1 ^ [U1                    -> either [I1 or [U1
 * etc.
 *
 * Also, System/Int32 and I4 merge -> I4, etc.
 *
 * Returns FALSE if the merge was completely incompatible (i.e. the item became 
 * dead).
 *
 */

BOOL         Compiler::tiMergeToCommonParent     (typeInfo *pDest, 
                                                  const typeInfo *pSrc) const
{
    assert(pSrc->IsDead() || NormaliseForStack(*pSrc) == *pSrc);
    assert(pDest->IsDead() || NormaliseForStack(*pDest) == *pDest);

    // Merge the axuillary information like This poitner tracking etc...

    // This bit is only set if both pDest and pSrc have it set
    pDest->m_flags &= (pSrc->m_flags | ~TI_FLAG_THIS_PTR);

    // This bit is set if either pDest or pSrc have it set
    pDest->m_flags |= (pSrc->m_flags & TI_FLAG_UNINIT_OBJREF);

    // OK the main event.  Merge the main types
    if (*pDest == *pSrc)
        return(TRUE);

    if (pDest->IsType(TI_REF))
    {
        if (pSrc->IsType(TI_NULL))                  // NULL can be any reference type
            return TRUE;
        if (!pSrc->IsType(TI_REF))
            goto FAIL;

            // Ask the EE to find the common parent,  This always succeeds since System.Object always works
        pDest->m_cls = info.compCompHnd->mergeClasses(pDest->GetClassHandle(), pSrc->GetClassHandle());
        return TRUE;
    }
    else if (pDest->IsType(TI_NULL))
    {
        if (pSrc->IsType(TI_REF))                   // NULL can be any reference type
        {
            *pDest = *pSrc;
            return TRUE;
        }
        goto FAIL;
    }

        // @TODO [REVISIT] [04/16/01] []: we presently don't deal with non-exact merging of Method poitner types

FAIL:
    *pDest = typeInfo();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "MSCORJIT.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Just-In-Time Compiler\0"
#define VER_ORIGFILENAME_STR    "mscorjit.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\utils.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                                  Utils.h                                  XX
XX                                                                           XX
XX   Has miscellaneous utility functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#ifndef _UTILS_H_
#define _UTILS_H_

#include "UtilCode.h"

#ifdef DEBUG
/**************************************************************************/
class ConfigMethodRange
{
public:
	ConfigMethodRange(LPWSTR keyName) : m_keyName(keyName), m_inited(false), m_lastRange(0) {}
	bool contains(class ICorJitInfo* info, CORINFO_METHOD_HANDLE method);

private:
    void initRanges(LPWSTR rangeStr);
private:
	LPWSTR m_keyName;
    unsigned char m_lastRange;                   // count of low-high pairs
	unsigned char m_inited;
    unsigned m_ranges[100];                      // ranges of functions to Jit (low, high pairs).  
};

#endif // DEBUG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\vartype.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _VARTYPE_H_
#define _VARTYPE_H_
/*****************************************************************************/


enum    var_types_classification
{
    VTF_ANY = 0x0000,
    VTF_INT = 0x0001,
    VTF_UNS = 0x0002,   // type is unsigned
    VTF_FLT = 0x0004,
    VTF_GCR = 0x0008,   // type is GC ref
    VTF_BYR = 0x0010,   // type is Byref
    VTF_I   = 0x0020,   // is machine sized 
};

enum    _var_types_enum
{
    #define DEF_TP(tn,nm,jitType,verType,sz,sze,asze,st,al,tf,howUsed) TYP_##tn,
    #include "typelist.h"
    #undef  DEF_TP

    TYP_COUNT,

    TYP_lastIntrins = TYP_DOUBLE
};

#ifdef DEBUG
typedef _var_types_enum var_types;
#else
typedef BYTE var_types;
#endif

/*****************************************************************************/

const extern  BYTE  varTypeClassification[TYP_COUNT];

inline  bool        varTypeIsIntegral  (var_types vt)
{
    return  ((varTypeClassification[vt] & (VTF_INT        )) != 0);
}

inline  bool        varTypeIsUnsigned  (var_types vt)
{
    return  ((varTypeClassification[vt] & (VTF_UNS        )) != 0);
}

inline  bool        varTypeIsFloating  (var_types vt)
{
    return  ((varTypeClassification[vt] & (VTF_FLT        )) != 0);
}

inline  bool        varTypeIsArithmetic(var_types vt)
{
    return  ((varTypeClassification[vt] & (VTF_INT|VTF_FLT)) != 0);
}

inline unsigned      varTypeGCtype     (var_types vt)
{
    return  (unsigned)(varTypeClassification[vt] & (VTF_GCR|VTF_BYR));
}

inline bool         varTypeIsGC        (var_types vt)
{
    return  (varTypeGCtype(vt) != 0);
}

inline bool         varTypeIsI         (var_types vt)
{
    return          ((varTypeClassification[vt] & VTF_I) != 0); 
}

inline bool         varTypeCanReg      (var_types vt)
{
    return          ((varTypeClassification[vt] & (VTF_INT|VTF_I|VTF_FLT)) != 0);
}

inline bool         varTypeIsByte      (var_types vt)
{
    return          (vt >= TYP_BOOL) && (vt <= TYP_UBYTE);
}

inline bool         varTypeIsShort     (var_types vt)
{
    return          (vt >= TYP_CHAR) && (vt <= TYP_USHORT);
}

inline bool         varTypeIsSmall     (var_types vt)
{
    return          (vt >= TYP_BOOL) && (vt <= TYP_USHORT);
}

inline bool         varTypeIsSmallInt  (var_types vt)
{
    return          (vt >= TYP_CHAR) && (vt <= TYP_USHORT);
}

inline bool         varTypeIsLong     (var_types vt)
{
    return          (vt >= TYP_LONG) && (vt <= TYP_ULONG);
}

inline  bool        varTypeIsComposite(var_types vt)
{
    return  (!varTypeIsArithmetic(vt) && vt != TYP_VOID);
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\_typeinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          _typeInfo                                         XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************
 This header file is named _typeInfo.h to be distinguished from typeinfo.h
 in the NT SDK
******************************************************************************/

/*****************************************************************************/
#ifndef _TYPEINFO_H_
#define _TYPEINFO_H_
/*****************************************************************************/

enum ti_types
{
    TI_ERROR,

    TI_REF,
    TI_STRUCT,
    TI_METHOD,

    TI_ONLY_ENUM = TI_METHOD,   //Enum values above this are completely described by the enumeration

    TI_BYTE,
    TI_SHORT,
    TI_INT,
    TI_LONG,
    TI_FLOAT,
    TI_DOUBLE,
    TI_NULL,

    TI_COUNT
};


// typeInfo does not care about distinction between signed/unsigned
// This routine converts all unsigned types to signed ones 
inline ti_types varType2tiType(var_types type)
{
    static const ti_types map[] =
    {
#define DEF_TP(tn,nm,jitType,verType,sz,sze,asze,st,al,tf,howUsed) verType,
#include "typelist.h"
#undef  DEF_TP
    };

    assert(map[TYP_BYTE] == TI_BYTE);
    assert(map[TYP_INT] == TI_INT);
    assert(map[TYP_UINT] == TI_INT);
    assert(map[TYP_FLOAT] == TI_FLOAT);
    assert(map[TYP_BYREF] == TI_ERROR);
    assert(map[type] != TI_ERROR); 
    return map[type];
}


// Convert the type returned from the VM to a ti_type.

inline ti_types JITtype2tiType(CorInfoType type)
{
    static const ti_types map[CORINFO_TYPE_COUNT] =
    { // see the definition of enum CorInfoType in file inc/corinfo.h
      TI_ERROR,        // CORINFO_TYPE_UNDEF           = 0x0,
      TI_ERROR,         // CORINFO_TYPE_VOID            = 0x1,
      TI_BYTE,         // CORINFO_TYPE_BOOL            = 0x2,
      TI_SHORT,        // CORINFO_TYPE_CHAR            = 0x3,
      TI_BYTE,         // CORINFO_TYPE_BYTE            = 0x4,
      TI_BYTE,         // CORINFO_TYPE_UBYTE           = 0x5,
      TI_SHORT,        // CORINFO_TYPE_SHORT           = 0x6,
      TI_SHORT,        // CORINFO_TYPE_USHORT          = 0x7,
      TI_INT,          // CORINFO_TYPE_INT             = 0x8,
      TI_INT,          // CORINFO_TYPE_UINT            = 0x9,
      TI_LONG,         // CORINFO_TYPE_LONG            = 0xa,
      TI_LONG,         // CORINFO_TYPE_ULONG           = 0xb,
      TI_FLOAT,        // CORINFO_TYPE_FLOAT           = 0xc,
      TI_DOUBLE,       // CORINFO_TYPE_DOUBLE          = 0xd,
      TI_REF,          // CORINFO_TYPE_STRING          = 0xe,
      TI_ERROR,        // CORINFO_TYPE_PTR             = 0xf,
      TI_ERROR,        // CORINFO_TYPE_BYREF           = 0x10,
      TI_STRUCT,       // CORINFO_TYPE_VALUECLASS      = 0x11,
      TI_REF,          // CORINFO_TYPE_CLASS           = 0x12,
      TI_STRUCT,       // CORINFO_TYPE_REFANY          = 0x13,
    };

    // spot check to make certain enumerations have not changed

    assert(map[CORINFO_TYPE_CLASS]      == TI_REF);
    assert(map[CORINFO_TYPE_BYREF]      == TI_ERROR);
    assert(map[CORINFO_TYPE_DOUBLE]     == TI_DOUBLE);
    assert(map[CORINFO_TYPE_VALUECLASS] == TI_STRUCT);
    assert(map[CORINFO_TYPE_STRING]     == TI_REF);

    type = CorInfoType(type & CORINFO_TYPE_MASK); // strip off modifiers

    assert(type < CORINFO_TYPE_COUNT);

    assert(map[type] != TI_ERROR || type == CORINFO_TYPE_VOID);
    return map[type];
};

/*****************************************************************************
 * Declares the typeInfo class, which represents the type of an entity on the
 * stack, in a local variable or an argument. 
 *
 * Flags: LLLLLLLLLLLLLLLLffffffffffTTTTTT
 *
 * L = local var # or instance field #
 * x = unused
 * f = flags
 * T = type
 *
 * The lower bits are used to store the type component, and may be one of:
 *
 * TI_* (primitive)   - see tyelist.h for enumeration (BYTE, SHORT, INT..)
 * TI_REF             - OBJREF / ARRAY use m_cls for the type
 *                       (including arrays and null objref)
 * TI_STRUCT          - VALUE type, use m_cls for the actual type
 *
 * NOTE carefully that BYREF info is not stored here.  You will never see a 
 * TI_BYREF in this component.  For example, the type component 
 * of a "byref TI_INT" is TI_FLAG_BYREF | TI_INT.
 *
 */

    // TI_COUNT is less than or equal to TI_FLAG_DATA_MASK

#define TI_FLAG_DATA_BITS              6
#define TI_FLAG_DATA_MASK              ((1 << TI_FLAG_DATA_BITS)-1)

    // Flag indicating this item is uninitialised
    // Note that if UNINIT and BYREF are both set, 
    // it means byref (uninit x) - i.e. we are pointing to an uninit <something>

#define TI_FLAG_UNINIT_OBJREF          0x00000040

    // Flag indicating this item is a byref <something>

#define TI_FLAG_BYREF                  0x00000080

    // Flag indicating this item is a byref <local#> (TI_FLAG_BYREF must 
    // also be set)
    // The local# is stored in the upper 2 bytes

#define TI_FLAG_BYREF_LOCAL            0x00000100

    // Flag indicating this item is a byref <instance field# of this class>
    // This is only important when verifying value class constructors.  In that 
    // case, we must verify that all instance fields are initialised.  However, 
    // if some fields are value class fields themselves, then they would be 
    // initialised via ldflda, call <ctor>, so we have to track that a field on 
    // the stack is a particular instance field of this class.
    // TI_FLAG_BYREF must also be set 

#define TI_FLAG_BYREF_INSTANCE_FIELD   0x00000200

    // This item contains the 'this' pointer (used for tracking)

#define TI_FLAG_THIS_PTR               0x00001000

    // This item is a byref to something which has a permanent home 
    // (e.g. a static field, or instance field of an object in GC heap, as 
    // opposed to the stack or a local variable).  TI_FLAG_BYREF must also be 
    // set. This information is useful for tail calls and return byrefs.

#define TI_FLAG_BYREF_PERMANENT_HOME   0x00002000

    // Number of bits local var # is shifted

#define TI_FLAG_LOCAL_VAR_SHIFT       16
#define TI_FLAG_LOCAL_VAR_MASK        0xFFFF0000

    // Field info uses the same space as the local info

#define TI_FLAG_FIELD_SHIFT           TI_FLAG_LOCAL_VAR_SHIFT
#define TI_FLAG_FIELD_MASK            TI_FLAG_LOCAL_VAR_MASK

#define TI_ALL_BYREF_FLAGS           (TI_FLAG_BYREF|                    \
                                      TI_FLAG_BYREF_LOCAL|              \
                                      TI_FLAG_BYREF_INSTANCE_FIELD|     \
                                      TI_FLAG_BYREF_PERMANENT_HOME)

/*****************************************************************************
 * A typeInfo can be one of several types:
 * - A primitive type (I4,I8,R4,R8,I)
 * - A type (ref, array, value type) (m_cls describes the type)
 * - An array (m_cls describes the array type)
 * - A byref (byref flag set, otherwise the same as the above),
 * - A Function Pointer (m_method)
 * - A byref local variable (byref and byref local flags set), can be 
 *   uninitialised
 *
 * The reason that there can be 2 types of byrefs (general byrefs, and byref 
 * locals) is that byref locals initially point to uninitialised items.  
 * Therefore these byrefs must be tracked specialy.
 */

class typeInfo
{
    friend  class   Compiler;

private:
    union {
            // Right now m_bits is for debugging,
         struct {
            ti_types type       : 6;
            unsigned uninitobj  : 1;    // used
            unsigned byref      : 1;    // used
            unsigned : 4;
            unsigned thisPtr    : 1;    // used
        } m_bits; 

        DWORD       m_flags;
     };

    union {
            // Valid only for TI_STRUCT or TI_REF
        CORINFO_CLASS_HANDLE  m_cls;  
            // Valid only for type TI_METHOD 
        CORINFO_METHOD_HANDLE m_method;
    };

public:
    typeInfo():m_flags(TI_ERROR) 
    {
        INDEBUG(m_cls = BAD_CLASS_HANDLE);
    }

    typeInfo(ti_types tiType) 
    { 
        assert((tiType >= TI_BYTE) && (tiType <= TI_NULL));
        assert(tiType <= TI_FLAG_DATA_MASK);

        m_flags = (DWORD) tiType;
        INDEBUG(m_cls = BAD_CLASS_HANDLE);
    }

    typeInfo(var_types varType) 
    { 
        m_flags = (DWORD) varType2tiType(varType);
        INDEBUG(m_cls = BAD_CLASS_HANDLE);
    }

    typeInfo(ti_types tiType, CORINFO_CLASS_HANDLE cls) 
    {
        assert(tiType == TI_STRUCT || tiType == TI_REF);
        assert(cls != 0 && cls != CORINFO_CLASS_HANDLE(0xcccccccc));
        m_flags = tiType;
        m_cls   = cls;
    }

    typeInfo(CORINFO_METHOD_HANDLE method)
    {
        assert(method != 0 && method != CORINFO_METHOD_HANDLE(0xcccccccc));
        m_flags = TI_METHOD;
        m_method = method;
    }

    int operator ==(const typeInfo& ti)  const
    {
        if ((m_flags & (TI_FLAG_DATA_MASK|TI_FLAG_BYREF|TI_FLAG_UNINIT_OBJREF)) != 
            (ti.m_flags & (TI_FLAG_DATA_MASK|TI_FLAG_BYREF|TI_FLAG_UNINIT_OBJREF)))
            return false;

        unsigned type = m_flags & TI_FLAG_DATA_MASK;
        assert(TI_ERROR < TI_ONLY_ENUM);        // TI_ERROR looks like it needs more than enum.  This optimises the success case a bit
        if (type > TI_ONLY_ENUM) 
            return true;
        if (type == TI_ERROR)
            return false;       // TI_ERROR != TI_ERROR
        assert(m_cls != BAD_CLASS_HANDLE && ti.m_cls != BAD_CLASS_HANDLE);
        return m_cls == ti.m_cls;
    }

    /////////////////////////////////////////////////////////////////////////
    // Operations
    /////////////////////////////////////////////////////////////////////////

    void SetIsThisPtr()
    {
        m_flags |= TI_FLAG_THIS_PTR;
        assert(m_bits.thisPtr);
    }

    /****
    void SetIsPermanentHomeByRef()
    {
        assert(IsByRef());
        m_flags |= TI_FLAG_BYREF_PERMANENT_HOME;
        assert(m_bits.byrefHome);
    }
    ****/

    // Set that this item is uninitialised.  
    void SetUninitialisedObjRef()
    {
        assert((IsObjRef() && IsThisPtr()));
        // For now, this is used only  to track uninit this ptrs in ctors

        m_flags |= TI_FLAG_UNINIT_OBJREF;
        assert(m_bits.uninitobj);
    }

    // Set that this item is initialised.
    void SetInitialisedObjRef()
    {
        assert((IsObjRef() && IsThisPtr()));
        // For now, this is used only  to track uninit this ptrs in ctors

        m_flags &= ~TI_FLAG_UNINIT_OBJREF;
    }

    typeInfo& DereferenceByRef()
    {
        if (!IsByRef()) {
            m_flags = TI_ERROR;
            INDEBUG(m_cls = BAD_CLASS_HANDLE);
        }
        m_flags &= ~(TI_FLAG_THIS_PTR | TI_FLAG_BYREF_PERMANENT_HOME | TI_ALL_BYREF_FLAGS);
        return *this;
    }

    /***
    void RemoveAllNonTypeInfo()
    {
        m_flags &= ~(TI_FLAG_THIS_PTR|
                     TI_FLAG_BYREF_PERMANENT_HOME);
    }
    ****/

    typeInfo& MakeByRef()
    {
        assert(!IsByRef());
        m_flags &= ~(TI_FLAG_THIS_PTR| TI_FLAG_BYREF_PERMANENT_HOME);
        m_flags |= TI_FLAG_BYREF;
        return *this;
    }

    /****

    // Mark that this item is a byref, and a byref of a particular local 
    // variable

    void MakeByRefLocal(DWORD dwLocVarNumber)
    {
        assert(!IsDead());
        assert(!IsByRef());
        m_flags |= ((TI_FLAG_BYREF | 
                    TI_FLAG_BYREF_LOCAL) | 
                    (dwLocVarNumber << TI_FLAG_LOCAL_VAR_SHIFT));
    }

    void MakeByRefInstanceField(DWORD dwFieldNumber)
    {
        assert(!IsDead());
        assert(!HasByRefLocalInfo());
        m_flags |= ((TI_FLAG_BYREF | 
                    TI_FLAG_BYREF_INSTANCE_FIELD) | 
                    (dwFieldNumber << TI_FLAG_FIELD_SHIFT));
    }
    ***/

    // I1,I2 --> I4
    // FLOAT --> DOUBLE
    // objref, arrays, byrefs, value classes are unchanged
    //
    typeInfo& NormaliseForStack()
    {
        switch (GetType())
        {
        case TI_BYTE:
        case TI_SHORT:
            m_flags = TI_INT;
            break;

        case TI_FLOAT:
            m_flags = TI_DOUBLE;
            break;
        default:
            break;
        }
        return (*this);
    }

    /////////////////////////////////////////////////////////////////////////
    // Getters
    /////////////////////////////////////////////////////////////////////////

    CORINFO_CLASS_HANDLE GetClassHandle()  const
    {
        if (!IsType(TI_REF) && !IsType(TI_STRUCT))
            return 0;
        return m_cls;
    }

    CORINFO_CLASS_HANDLE GetClassHandleForValueClass()  const
    {
        assert(IsType(TI_STRUCT));
        assert(m_cls && m_cls != BAD_CLASS_HANDLE);
        return m_cls;
    }

    CORINFO_CLASS_HANDLE GetClassHandleForObjRef()  const
    {
        assert(IsType(TI_REF));
        assert(m_cls && m_cls != BAD_CLASS_HANDLE);
        return m_cls;
    }

    CORINFO_METHOD_HANDLE GetMethod()  const
    {
        assert(GetType() == TI_METHOD);
        return m_method;
    }

    // Get this item's type
    // If primitive, returns the primitive type (TI_*)
    // If not primitive, returns:
    //  - TI_BYREF if a byref anything
    //  - TI_REF if a class or array or null
    //  - TI_STRUCT if a value class
    ti_types GetType() const
    {
        if (m_flags & TI_FLAG_BYREF)
            return TI_ERROR;

        // objref/array/null (objref), value class, ptr, primitive
        return (ti_types)(m_flags & TI_FLAG_DATA_MASK); 
    }

    /***
    DWORD GetByRefLocalInfo() const
    {
        assert(HasByRefLocalInfo());
        assert(m_bits.localNum == m_flags >> TI_FLAG_LOCAL_VAR_SHIFT);
        return (m_flags >> TI_FLAG_LOCAL_VAR_SHIFT);
    }

    DWORD GetByRefFieldInfo() const
    {
        assert(HasByRefFieldInfo());
        return (m_flags >> TI_FLAG_FIELD_SHIFT);
    }
    ***/

    BOOL IsType(ti_types type) const {
        assert(type != TI_ERROR);
        return (m_flags & (TI_FLAG_DATA_MASK|TI_FLAG_BYREF)) == DWORD(type);
    }

    // Returns whether this is an objref
    BOOL IsObjRef() const
    {
        return IsType(TI_REF) || IsType(TI_NULL);
    }

    // Returns whether this is a by-ref
    BOOL IsByRef() const
    {
        return (m_flags & TI_FLAG_BYREF);
    }

    // Returns whether this is the this pointer
    BOOL IsThisPtr() const
    {
        return (m_flags & TI_FLAG_THIS_PTR);
    }

    /***
    BOOL IsPermanentHomeByRef() const
    {
        return (m_flags & TI_FLAG_BYREF_PERMANENT_HOME);
    }
    ***/

    // Returns whether this is a method desc
    BOOL IsMethod() const
    {
        return (GetType() == TI_METHOD);
    }

    /***
    // Returns whether this item is a byref <Type>
    // If Type is TI_REF, returns whether we are a byref 
    // to some objref/array/value class type
    BOOL IsByRefOfType(DWORD Type) const
    {
        return (m_flags & (TI_FLAG_DATA_MASK|TI_FLAG_BYREF)) == 
                (Type | TI_FLAG_BYREF);
    }

    BOOL IsByRefValueClass() const
    {
        return (m_flags & (TI_FLAG_BYREF|TI_FLAG_DATA_MASK)) == 
                (TI_FLAG_BYREF|TI_STRUCT);
    }

    BOOL IsByRefObjRef() const
    {
        return (m_flags & (TI_FLAG_BYREF|TI_FLAG_DATA_MASK)) == 
                (TI_FLAG_BYREF|TI_REF);
    }
    ***/

    // A byref value class is NOT a value class
    BOOL IsValueClass() const
    {
        // @TODO [CONSIDER] [04/16/01] []: make a table lookup for efficiency
        return (IsType(TI_STRUCT) || IsPrimitiveType());     
    }

    // Returns whether this is an integer or real number
    // NOTE: Use NormaliseToPrimitiveType() if you think you may have a 
    // System.Int32 etc., because those types are not considered number 
    // types by this function.
    BOOL IsNumberType() const
    {
        ti_types Type = GetType();

        // I1, I2, Boolean, character etc. cannot exist nakedly - 
        // everything is at least an I4

        return (Type == TI_INT || 
                Type == TI_LONG || 
                Type == TI_DOUBLE);
    }

    // Returns whether this is an integer
    // NOTE: Use NormaliseToPrimitiveType() if you think you may have a 
    // System.Int32 etc., because those types are not considered number 
    // types by this function.
    BOOL IsIntegerType() const
    {
        ti_types Type = GetType();

        // I1, I2, Boolean, character etc. cannot exist nakedly - 
        // everything is at least an I4

        return (Type == TI_INT || 
                Type == TI_LONG);
    }

    // Returns whether this is a primitive type (not a byref, objref, 
    // array, null, value class, invalid value)
    // May Need to normalise first (m/r/I4 --> I4)
    BOOL IsPrimitiveType() const
    {
        DWORD Type = GetType();

        // boolean, char, u1,u2 never appear on the operand stack
        return (Type == TI_BYTE || 
                Type == TI_SHORT ||
                Type == TI_INT || 
                Type == TI_LONG ||
                Type == TI_FLOAT || 
                Type == TI_DOUBLE);
    }

    // May Need to normalise first (m/r/I4 --> I4)
    /***
    BOOL IsNormalisedByRefPrimitiveType() const
    {
        if (IsByRef() == FALSE)
            return FALSE;

        DWORD Type = (m_flags & TI_FLAG_DATA_MASK);

        return (Type == TI_INT || 
                Type == TI_LONG || 
                Type == TI_DOUBLE);
    }
    ***/
    
    /**
    BOOL IsByRefPrimitiveType() const
    {
        if (IsByRef() == FALSE)
            return FALSE;
        
        DWORD Type = (m_flags & TI_FLAG_DATA_MASK);

        // boolean, char, u1,u2 never appear on the operand stack
        return (Type == TI_BYTE ||
                Type == TI_SHORT ||
                Type == TI_INT ||
                Type == TI_LONG ||
                Type == TI_FLOAT || 
                Type == TI_DOUBLE);
    }
    ***/

    // Returns whether this is the null objref
    BOOL IsNullObjRef() const
    {
        return (IsType(TI_NULL));
    }

    // must be for a local which is an object type (i.e. has a slot >= 0)
    // for primitive locals, use the liveness bitmap instead
    // Note that this works if the error is 'Byref' 
    BOOL IsDead() const
    {
        return (m_flags & (TI_FLAG_DATA_MASK)) == TI_ERROR;
    }

    BOOL IsUninitialisedObjRef() const
    {
        return (m_flags & TI_FLAG_UNINIT_OBJREF);
    }

    /****
    BOOL HasByRefLocalInfo() const
    {
        return (m_flags & TI_FLAG_BYREF_LOCAL);
    }

    BOOL HasByRefFieldInfo() const
    {
        return (m_flags & TI_FLAG_BYREF_INSTANCE_FIELD);
    }
    ****/

    /***
#ifdef DEBUG

    // In the watch window of the debugger, type tiVarName.ToStaticString()
    // to view a string representation of this instance.

    char *ToStaticString()
    {
#define TI_DEBUG_STR_LEN 100

        assert(TI_COUNT <= TI_FLAG_DATA_MASK);

        static char str[TI_DEBUG_STR_LEN];
        char *      p = "";
        ti_types    tiType;

        str[0] = 0;

        if (IsMethod())
        {
            strcpy(str, "method");
            return str;
        }

        if (IsByRef())
            strcat(str, "&");

        if (IsNullObjRef())
            strcat(str, "nullref");

        if (IsUninitialisedObjRef())
            strcat(str, "<uninit>");

        if (IsPermanentHomeByRef())
            strcat(str, "<permanent home>");

        if (IsThisPtr())
            strcat(str, "<this>");

        if (HasByRefLocalInfo())
            sprintf(&str[strlen(str)], "(local %d)", GetByRefLocalInfo());

        if (HasByRefFieldInfo())
            sprintf(&str[strlen(str)], "(field %d)", GetByRefFieldInfo());

        tiType = GetType();

        switch (tiType)
        {
        default:
            p = "<<internal error>>";
            break;

        case TI_BYTE:
            p = "byte";
            break;

        case TI_SHORT:
            p = "short";
            break;

        case TI_INT:
            p = "int";
            break;

        case TI_LONG:
            p = "long";
            break;

        case TI_FLOAT:
            p = "float";
            break;

        case TI_DOUBLE:
            p = "double";
            break;

        case TI_REF:
            p = "ref";
            break;

        case TI_STRUCT:
            p = "struct";
            break;

        case TI_ERROR:
            p = "error";
            break;
        }

        strcat(str, " ");
        strcat(str, p);

        return str;
    }

#endif  // DEBUG
    ***/

private:
        // used to make functions that return typeinfo efficient.
    typeInfo(DWORD flags, CORINFO_CLASS_HANDLE cls) 
    {
        m_cls   = cls;
        m_flags = flags;
    }
     
    friend typeInfo ByRef(const typeInfo& ti);
    friend typeInfo DereferenceByRef(const typeInfo& ti);
    friend typeInfo NormaliseForStack(const typeInfo& ti);
};

inline
typeInfo NormaliseForStack(const typeInfo& ti) 
{
    return typeInfo(ti).NormaliseForStack();
}

    // given ti make a byref to that type. 
inline
typeInfo ByRef(const typeInfo& ti) 
{
    return typeInfo(ti).MakeByRef();
}

 
    // given ti which is a byref, return the type it points at
inline
typeInfo DereferenceByRef(const typeInfo& ti) 
{
    return typeInfo(ti).DereferenceByRef();
}

/*****************************************************************************/
#endif // _TYPEINFO_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\il\utils.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                                  Utils.cpp                                XX
XX                                                                           XX
XX   Has miscellaneous utility functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#include "jitpch.h"
#pragma hdrstop

#include "opcode.h"

#define DECLARE_DATA



extern
const signed char       opcodeSizes[] =
{
    #define InlineNone_size           0
    #define ShortInlineVar_size       1
    #define InlineVar_size            2
    #define ShortInlineI_size         1
    #define InlineI_size              4
    #define InlineI8_size             8
    #define ShortInlineR_size         4
    #define InlineR_size              8
    #define ShortInlineBrTarget_size  1
    #define InlineBrTarget_size       4
    #define InlineMethod_size         4
    #define InlineField_size          4
    #define InlineType_size           4
    #define InlineString_size         4
    #define InlineSig_size            4
    #define InlineRVA_size            4
    #define InlineTok_size            4
    #define InlineSwitch_size         0       // for now
    #define InlinePhi_size            0       // for now
    #define InlineVarTok_size         0       // remove

    #define OPDEF(name,string,pop,push,oprType,opcType,l,s1,s2,ctrl) oprType ## _size ,
    #include "opcode.def"
    #undef OPDEF

    #undef InlineNone_size
    #undef ShortInlineVar_size
    #undef InlineVar_size
    #undef ShortInlineI_size
    #undef InlineI_size
    #undef InlineI8_size
    #undef ShortInlineR_size
    #undef InlineR_size
    #undef ShortInlineBrTarget_size
    #undef InlineBrTarget_size
    #undef InlineMethod_size
    #undef InlineField_size
    #undef InlineType_size
    #undef InlineString_size
    #undef InlineSig_size
    #undef InlineRVA_size
    #undef InlineTok_size
    #undef InlineSwitch_size
    #undef InlinePhi_size
};



#if COUNT_OPCODES || defined(DEBUG)

extern
const char * const  opcodeNames[] =
{
    #define OPDEF(name,string,pop,push,oprType,opcType,l,s1,s2,ctrl) string,
    #include "opcode.def"
    #undef  OPDEF
};

#endif

#ifdef DUMPER

extern
const BYTE          opcodeArgKinds[] =
{
    #define OPDEF(name,string,pop,push,oprType,opcType,l,s1,s2,ctrl) (BYTE) oprType,
    #include "opcode.def"
    #undef  OPDEF
};

#endif


const BYTE          varTypeClassification[] =
{
    #define DEF_TP(tn,nm,jitType,verType,sz,sze,asze,st,al,tf,howUsed) tf,
    #include "typelist.h"
    #undef  DEF_TP
};

/*****************************************************************************/

const   char *      varTypeName(var_types vt)
{
    static
    const char * const  varTypeNames[] =
    {
        #define DEF_TP(tn,nm,jitType,verType,sz,sze,asze,st,al,tf,howUsed) nm,
        #include "typelist.h"
        #undef  DEF_TP
    };

    assert(vt < sizeof(varTypeNames)/sizeof(varTypeNames[0]));

    return  varTypeNames[vt];
}

/*****************************************************************************/
/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************
 *
 *  Return the name of the given register.
 */

const   char *      getRegName(unsigned reg)
{
    static
    const char * const  regNames[] =
    {
        #if     TGT_x86
        #define REGDEF(name, rnum, mask, byte) #name,
        #include "register.h"
        #undef  REGDEF
        #endif

        #if     TGT_SH3
        #define REGDEF(name, strn, rnum, mask)  strn,
        #include "regSH3.h"
        #undef  REGDEF
        #endif
    };

    assert(reg < sizeof(regNames)/sizeof(regNames[0]));

    return  regNames[reg];
}

/*****************************************************************************
 *
 *  Displays a register set.
 */

void                dspRegMask(unsigned regMask, size_t minSiz)
{
    const   char *  sep = "";

    printf("[");

    #define dspRegBit(reg,bit)                          \
                                                        \
        if  (regMask & bit)                             \
        {                                               \
            const   char *  nam = getRegName(reg);      \
            printf("%s%s", sep, nam);                   \
            minSiz -= (strlen(sep) + strlen(nam));      \
            sep = " ";                                  \
        }

#if TGT_x86

    #define dspOneReg(reg)  dspRegBit(REG_##reg, RBM_##reg)

    dspOneReg(EAX);
    dspOneReg(EDX);
    dspOneReg(ECX);
    dspOneReg(EBX);
    dspOneReg(EBP);
    dspOneReg(ESI);
    dspOneReg(EDI);

    if (regMask & RBM_BYTE_REG_FLAG)
    {
        const char *  nam = "BYTE";
        printf("%s%s", sep, nam);
        minSiz -= (strlen(sep) + strlen(nam));   
    }

#else

    for (unsigned reg = 0; reg < REG_STK; reg++)
        dspRegBit(reg, genRegMask((regNumber)reg));

#endif

    printf("]");

    while ((int)minSiz > 0)
    {
        printf(" ");
        minSiz--;
    }
}


unsigned
dumpSingleInstr(const BYTE * codeAddr, IL_OFFSET offs, const char * prefix)
{
    const BYTE  *        opcodePtr = codeAddr + offs;
    const BYTE  *   startOpcodePtr = opcodePtr;

    if( prefix!=NULL)
        printf("%s", prefix);

    OPCODE      opcode = (OPCODE) getU1LittleEndian(opcodePtr);
    opcodePtr += sizeof(__int8);

DECODE_OPCODE:

    /* Get the size of additional parameters */

    size_t      sz      = opcodeSizes   [opcode];
    unsigned    argKind = opcodeArgKinds[opcode];

    /* See what kind of an opcode we have, then */

    switch (opcode)
    {
        case CEE_PREFIX1:
            opcode = OPCODE(getU1LittleEndian(codeAddr) + 256);
            opcodePtr += sizeof(__int8);
            goto DECODE_OPCODE;

        default:
        {

            printf("%-12s ", opcodeNames[opcode]);

            __int64     iOp;
            double      dOp;
            DWORD       jOp;

            switch(argKind)
            {
            case InlineNone    :   break;

            case ShortInlineVar  :   iOp  = getU1LittleEndian(opcodePtr);  goto INT_OP;
            case ShortInlineI    :   iOp  = getI1LittleEndian(opcodePtr);  goto INT_OP;
            case InlineVar       :   iOp  = getU2LittleEndian(opcodePtr);  goto INT_OP;
            case InlineTok       :
            case InlineMethod    :
            case InlineField     :
            case InlineType      :
            case InlineString    :
            case InlineSig       :
            case InlineI         :   iOp  = getI4LittleEndian(opcodePtr);  goto INT_OP;
            case InlineI8        :   iOp  = getU4LittleEndian(opcodePtr);
                                     iOp |= getU4LittleEndian(opcodePtr) >> 32;
                                    goto INT_OP;

        INT_OP                  :   printf("0x%X", iOp);
                                    break;

            case ShortInlineR   :   dOp  = getR4LittleEndian(opcodePtr);  goto FLT_OP;
            case InlineR   :   dOp  = getR8LittleEndian(opcodePtr);  goto FLT_OP;

        FLT_OP                  :   printf("%f", dOp);
                                    break;

            case ShortInlineBrTarget:  jOp  = getI1LittleEndian(opcodePtr);  goto JMP_OP;
            case InlineBrTarget:  jOp  = getI4LittleEndian(opcodePtr);  goto JMP_OP;

        JMP_OP                  :   printf("0x%X (abs=0x%X)", jOp,
                                            (opcodePtr - startOpcodePtr) + jOp);
                                    break;

            case InlineSwitch:
                jOp = getU4LittleEndian(opcodePtr); opcodePtr += 4;
                opcodePtr += jOp * 4; // Jump over the table
                break;

            case InlinePhi:
                jOp = getU1LittleEndian(opcodePtr); opcodePtr += 1;
                opcodePtr += jOp * 2; // Jump over the table
                break;

            default         : assert(!"Bad argKind");
            }

            opcodePtr += sz;
            break;
        }
    }

    printf("\n");
    return opcodePtr - startOpcodePtr;
}

/*****************************************************************************/
#endif // DEBUG
/*****************************************************************************
 *
 *  Display a variable set (which may be a 32-bit or 64-bit number); only
 *  one or two of these can be used at once.
 */

#ifdef  DEBUG

const   char *      genVS2str(VARSET_TP set)
{
    static
    char            num1[17];

    static
    char            num2[17];

    static
    char    *       nump = num1;

    char    *       temp = nump;

    nump = (nump == num1) ? num2
                          : num1;

#if VARSET_SZ == 32
    sprintf(temp, "%08X", set);
#else
    sprintf(temp, "%08X%08X", (int)(set >> 32), (int)set);
#endif

    return  temp;
}

#endif

/*****************************************************************************/

#if defined(DEBUG)

histo::histo(unsigned * sizeTab, unsigned sizeCnt)
{
    if  (!sizeCnt)
    {
        do
        {
            sizeCnt++;
        }
        while(sizeTab[sizeCnt]);
    }

    histoSizCnt = sizeCnt;
    histoSizTab = sizeTab;

    histoCounts = new unsigned[sizeCnt+1];

    histoClr();
}

histo::~histo()
{
    delete [] histoCounts;
}

void                histo::histoClr()
{
    memset(histoCounts, 0, (histoSizCnt+1)*sizeof(*histoCounts));
}

void                histo::histoDsp()
{
    unsigned        i;
    unsigned        c;
    unsigned        t;

    for (i = t = 0; i <= histoSizCnt; i++)
        t += histoCounts[i];

    for (i = c = 0; i <= histoSizCnt; i++)
    {
        if  (i == histoSizCnt)
        {
            if  (!histoCounts[i])
                break;

            printf("    >     %6u", histoSizTab[i-1]);
        }
        else
        {
            if (i == 0)
            {
                printf("    <=    ");
            }
            else
                printf("%6u .. ", histoSizTab[i-1]+1);

            printf("%6u", histoSizTab[i]);
        }

        c += histoCounts[i];

        printf(" ===> %6u count (%3u%% of total)\n", histoCounts[i], (int)(100.0*c/t));
    }
}

void                histo::histoRec(unsigned siz, unsigned cnt)
{
    unsigned        i;
    unsigned    *   t;

    for (i = 0, t = histoSizTab;
         i < histoSizCnt;
         i++  , t++)
    {
        if  (*t >= siz)
            break;
    }

    histoCounts[i] += cnt;
}

#endif // defined(DEBUG) || !defined(DLL_JIT)

#ifdef DEBUG

#define MAX_RANGE 0xfffff

/**************************************************************************/
bool ConfigMethodRange::contains(ICorJitInfo* info, CORINFO_METHOD_HANDLE method) 
{
	if (!m_inited) {
        OnUnicodeSystem();
		LPWSTR str = REGUTIL::GetConfigString(m_keyName);
		initRanges(str);
        REGUTIL::FreeConfigString(str);
		m_inited = true;
	}

	if (m_lastRange == 0)   // no range mean everything
		return true;

    unsigned hash = info->getMethodHash(method);
    assert(hash < MAX_RANGE);
    int i = 0;

    for (i=0 ; i<m_lastRange ; i+=2) 
    {
        if (m_ranges[i]<=hash && hash<=m_ranges[i+1])
        {
            return true;
        }        
    }

    return false;
}

/**************************************************************************/
void ConfigMethodRange::initRanges(LPWSTR value)
{
    if (value == 0)
        return;

    WCHAR *p = value;
    m_lastRange = 0;
    while (*p) {
        while (*p == ' ')       //skip blanks
            p++;
        int i = 0;
        while ('0' <= *p && *p <= '9')
        {
            i = 10*i + ((*p++) - '0');
        }
        m_ranges[m_lastRange++] = i;

        while (*p == ' ')
            p++;

        // Have we read only the first part of a (possible) pair?
        if (m_lastRange & 1) 
        {
            // Is this entry of the form "beg-end" or simply "num"?
            if (*p == '-')
                p++; // Skip over the '-' to get to "end"
            else
                m_ranges[m_lastRange++] = i; // This is just "num".
        }
    }
    if (m_lastRange & 1) 
        m_ranges[m_lastRange++] = MAX_RANGE;
    assert(m_lastRange < 100);
}

#endif

/*****************************************************************************
 *  Identity function used to force the compiler to spill a float value to memory
 *  in order to avoid some fpu inconsistency issues, for example
 *  
 *   fild DWORD PTR 
 *   fstp QWORD PTR
 *
 *  in a (double)((float) i32Integer) casting if the i32Integer cannot be 
 *  represented with a float and it can with a double
 *
 *  This function will force a 
 *
 *  fild DWORD PTR
 *  fstp DWORD PTR
 *  fld  DWORD PTR
 *  fstp QWORD PTR
 *
 *  when used like this (double)(forceFloatSpill((float) i32Integer))
 *  
 *  We use this in order to workaround a vc bug, when the bug is fixed
 *  the function won't be needed any more
 */
float forceFloatSpill(float f)
{
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\custommarshalers.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CustomMarshalers.cpp
//
// This file contains the assembly level attributes.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"
#include <__file__.ver>

using namespace System::Reflection;
using namespace System::Resources;

//-----------------------------------------------------------------------
// Strong name the assembly (or half sign it, at least). 
//-----------------------------------------------------------------------
[assembly:AssemblyDelaySignAttribute(true)];
[assembly:AssemblyKeyFileAttribute("../../../bin/FinalPublicKey.snk")];


//-----------------------------------------------------------------------
// Version number of the assembly.
//-----------------------------------------------------------------------
[assembly:AssemblyVersionAttribute(VER_ASSEMBLYVERSION_STR)];

//-----------------------------------------------------------------------
// ResourceManager attributes
//-----------------------------------------------------------------------
[assembly:NeutralResourcesLanguageAttribute("en-US")];
[assembly:SatelliteContractVersionAttribute(VER_ASSEMBLYVERSION_STR)];


//-----------------------------------------------------------------------
// Guids used in the assembly.
//-----------------------------------------------------------------------

// {00000000-0000-0000-0000-000000000000}
EXTERN_C const GUID GUID_NULL           = {0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}};

// {00000000-0000-0000-C000-000000000046}
EXTERN_C const IID IID_IUnknown         = {0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// {00020404-0000-0000-C000-000000000046}
EXTERN_C const IID IID_IEnumVARIANT     = {0x00020404,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// {A6EF9860-C720-11d0-9337-00A0C90DCAA9}
EXTERN_C const IID IID_IDispatchEx      = {0xA6EF9860,0xC720,0x11D0,{0x93,0x37,0x00,0xA0,0xC9,0x0D,0xCA,0xA9}};


CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\custommarshalersnamespacedef.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CustomMarshalersNameSpaceDef.h
//
// This file defines the namespace for the custom marshalers.
//
//*****************************************************************************

#ifndef _CUSTOMMARSHALERSNAMESPACEDEF_H
#define _CUSTOMMARSHALERSNAMESPACEDEF_H

#define OPEN_CUSTOM_MARSHALERS_NAMESPACE()	\
namespace System {							\
	namespace Runtime {						\
    	namespace InteropServices {		    \
	    	namespace CustomMarshalers {		

#define CLOSE_CUSTOM_MARSHALERS_NAMESPACE()	\
		    }								\
        }                                   \
	}										\
}											

#endif  _CUSTOMMARSHALERSNAMESPACEDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\custommarshalersdefines.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CustomMarshalersDefines.h
//
// This file provides standard defines used in defining custom marshalers.
//
//*****************************************************************************

#ifndef _CUSTOMMARSHALERSDEFINES_H
#define _CUSTOMMARSHALERSDEFINES_H

#define __IServiceProvider_FWD_DEFINED__
#include "windows.h"

// Helper function for dealing with HRESULTS.
#define IfFailThrow(ErrorCode) \
    if (FAILED(ErrorCode)) \
        Marshal::ThrowExceptionForHR(ErrorCode);

// Undefine symbols defined in windows.h that conflict with ones defined in the classlibs.
#undef GetObject
#undef lstrcpy

using namespace System::Security::Permissions;
using namespace System::Security;

[DllImport("oleaut32")]
[SecurityPermissionAttribute(SecurityAction::LinkDemand, Flags=SecurityPermissionFlag::UnmanagedCode)]
WINOLEAUTAPI_(BSTR) SysAllocStringLen(const OLECHAR *, UINT);

[DllImport("oleaut32")]
[SecurityPermissionAttribute(SecurityAction::LinkDemand, Flags=SecurityPermissionFlag::UnmanagedCode)]
WINOLEAUTAPI_(UINT) SysStringLen(BSTR);

[DllImport("oleaut32")]
[SecurityPermissionAttribute(SecurityAction::LinkDemand, Flags=SecurityPermissionFlag::UnmanagedCode)]
WINOLEAUTAPI_(void) SysFreeString(BSTR);

[DllImport("oleaut32")]
[SecurityPermissionAttribute(SecurityAction::LinkDemand, Flags=SecurityPermissionFlag::UnmanagedCode)]
WINOLEAUTAPI_(void) VariantInit(VARIANTARG *pvarg);

[DllImport("oleaut32")]
[SecurityPermissionAttribute(SecurityAction::LinkDemand, Flags=SecurityPermissionFlag::UnmanagedCode)]
WINOLEAUTAPI VariantClear(VARIANTARG * pvarg);

#ifdef _WIN64
#define TOINTPTR(x) ((IntPtr)(INT64)(x))
#define FROMINTPTR(x) ((void*)(x).ToInt64())
#else
#define TOINTPTR(x) ((IntPtr)(INT32)(x))
#define FROMINTPTR(x) ((void*)(x).ToInt32())
#endif

#endif  _CUSTOMMARSHALERSDEFINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\dispatchexmethodinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// DispatchExMethodInfo.h
//
// This file provides the declaration and implemention of the
// DispatchExMethodInfo class. This class represents a MethodInfo that layered
// on top of IDispatchEx.
//
//*****************************************************************************

#ifndef _DISPATCHEXMETHODINFO_H
#define _DISPATCHEXMETHODINFO_H

#include "CustomMarshalersNameSpaceDef.h"
#include "CustomMarshalersDefines.h"
#include "ExpandoViewOfDispatchEx.h"
#include "Resource.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

using namespace System::Reflection;

__value private enum MethodType
{
	MethodType_NormalMethod = 0,
	MethodType_GetMethod = 1,
	MethodType_SetMethod = 2
};

[Serializable]
__gc private class DispatchExMethodInfo : public MethodInfo
{
public:
	DispatchExMethodInfo(DISPID DispID, String *pstrName, MethodType MethType, ExpandoViewOfDispatchEx *pOwner)
	: m_DispID(DispID)
	, m_pstrName(pstrName)
	, m_MethodType(MethType)
	, m_pOwner(pOwner)
	{
	}

	/**
	* Return an array of all of the custom attributes
	*/
	Object* GetCustomAttributes(bool inherit) __gc []
	{
		return new Object * __gc [0];
	}

    /**
	* 	Returns true if this attribute is defined on the given element (including inherited members)
	*/
	bool IsDefined(Type *pType, bool inherit)
	{
		if (!pType)
			throw new ArgumentNullException(L"type");
		return false;
	}

	/**
	* Return a custom attribute identified by Type
	*/
	Object* GetCustomAttributes(Type *pType, bool inherit)  __gc []
	{
		if (!pType)
			throw new ArgumentNullException(L"type");

		return NULL;
	}

	/**
	 * Property the Member Type of the specific memeber.  This
	 * is useful for switch statements.
	 */
	__property MemberTypes get_MemberType()
    {
    	return MemberTypes::Method;
	}

	/**
	 * Property representing the name of the Member.
	 */
	__property String *get_Name()
	{
		return m_pstrName;
	}

	/**
	 * Property representing the class that declared the member.  This may be different
	 * from the reflection class because a sub-class inherits methods from its base class.
	 * These inheritted methods will have a declared class of the last base class to
	 * declare the member.
	 */
	__property Type *get_DeclaringType()
	{
		return m_pOwner->UnderlyingSystemType;
	}

	/**
	 * Property representing the class that was used in reflection to obtain
	 * this Member.
	 */
	__property Type *get_ReflectedType()
	{
		// For IDispatchEx the reflected type is the same as the declaring type.
		return DeclaringType;
	}

	/**
	 * Property the Signature of the member
	 */
	__property String *get_Signature()
	{
		return NULL;
	}

	// GetParameters
	// This method returns an array of parameters for this method
	ParameterInfo* GetParameters() __gc []
	{
		return new ParameterInfo * __gc [0];
	}

	/**
	 * Return the MethodImpl flags.
	 */
	MethodImplAttributes GetMethodImplementationFlags()
	{
		return MethodImplAttributes::Unmanaged;
	}

	/**
	 * Property representing the Attributes associated with a Member.  All
	 * members have a set of attributes which are defined in relation to
	 * the specific type of member.
	 */
	__property MethodAttributes get_Attributes()
	{
		return (MethodAttributes)(MethodAttributes::Public |
								  MethodAttributes::Virtual |
								  MethodAttributes::ReuseSlot);
	}

	/**
	 * Return type Type of the methods return type
	 */
	__property Type *get_ReturnType()
	{
        return __typeof(Object);
	}

	__property ICustomAttributeProvider *get_ReturnTypeCustomAttributes()
	{
		return NULL;
	}

	/**
	 * Return Type handle
	 */
	__property RuntimeMethodHandle get_MethodHandle()
	{
		return m_EmptyMH;
	}

	/**
	 * Return the base implementation for a method.
	 */
	MethodInfo *GetBaseDefinition()
	{
		return this;
	}

	/**
	 * Invokes the method on the specified object.
	 */
	Object* Invoke(Object *pObj, BindingFlags invokeAttr, Binder *pBinder, Object* aParameters __gc [], CultureInfo *pCulture)
	{
		// Validate the arguments.
		if (!pObj)
			throw new ArgumentNullException(L"obj");
		if (!m_pOwner->IsOwnedBy(pObj))
            throw new ArgumentException(Resource::FormatString(L"Arg_ObjectNotValidForMethodInfo"), L"obj");

        // If no binding flags are specified, then use the default for the type
        // of DispatchEx member we are dealing with.
        if (invokeAttr == BindingFlags::Default)
        {
            if (m_MethodType == MethodType_NormalMethod)
            {
                invokeAttr = BindingFlags::InvokeMethod;
            }
            else if (m_MethodType == MethodType_GetMethod)
            {
                invokeAttr = BindingFlags::GetProperty;
            }
            else if (m_MethodType == MethodType_SetMethod)
            {
                invokeAttr = BindingFlags::SetProperty;
            }
        }

		// Determine the flags to pass to DispExInvoke.
		int Flags = m_pOwner->InvokeAttrsToDispatchFlags(invokeAttr);

		// Invoke the method and return the result.
		return m_pOwner->DispExInvoke(m_pstrName, m_DispID, Flags, pBinder, aParameters, NULL, pCulture, NULL);
	}

	/**
	 * Returns the DISPID associated with the method.
	 */
	__property int get_DispID()
	{
		return (int)m_DispID;
    }

	/**
	 * Returns the ExpandoViewOfDispatchEx that owns the DispatchExMethodInfo.
	 */
	__property ExpandoViewOfDispatchEx *get_Owner()
	{
		return m_pOwner;
	}

private:
	DISPID m_DispID;
	String *m_pstrName;
	MethodType m_MethodType;
	ExpandoViewOfDispatchEx *m_pOwner;
	RuntimeMethodHandle m_EmptyMH;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _DISPATCHEXMETHODINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumerabletodispatchmarshaler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorToEnumVariantMarshaler.cpp
//
// This file provides the implemention of the EnumeratorToEnumVariantMarshaler
// class. This class is used to marshal between IEnumVariant and IEnumerator.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "EnumerableToDispatchMarshaler.h"
#include "EnumerableViewOfDispatch.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()


#define CACHE_MANAGED_VIEWS


EnumerableToDispatchMarshaler::EnumerableToDispatchMarshaler()
{
}


Object *EnumerableToDispatchMarshaler::MarshalNativeToManaged(IntPtr pNativeData)
{
    EnumerableViewOfDispatch *pMngView = NULL;

	// Validate the arguments.
    if (pNativeData == TOINTPTR(0))
		throw new ArgumentNullException(L"pNativeData");

    // Retrieve the __ComObject that wraps the IUnknown *.
    Object *pComObj = Marshal::GetObjectForIUnknown(pNativeData);

    // Retrieve the type of the managed view.
    Object *pKey = __typeof(EnumerableViewOfDispatch);

    // Check to see if the __ComObject already has the managed view cached.
    pMngView = dynamic_cast<EnumerableViewOfDispatch *>(Marshal::GetComObjectData(pComObj, pKey));

    // If it doesn't have a cached managed view, then allocate one.
    if (!pMngView)
    {
        pMngView = new EnumerableViewOfDispatch(pComObj);
        if (!Marshal::SetComObjectData(pComObj, pKey, pMngView))
	    {
            // Someone beat us to adding the managed view so fetch it again.
            pMngView = dynamic_cast<EnumerableViewOfDispatch *>(Marshal::GetComObjectData(pComObj, pKey));
        }
    }

	return pMngView;
}


IntPtr EnumerableToDispatchMarshaler::MarshalManagedToNative(Object *pManagedObj)
{
	// Validate the arguments.
	if (!pManagedObj)
		throw new ArgumentNullException(L"pManagedObj");

	// Retrieve a pointer to the IEnumerable interface.
	return Marshal::GetComInterfaceForObject(pManagedObj, __typeof(IEnumerable));
}


void EnumerableToDispatchMarshaler::CleanUpNativeData(IntPtr pNativeData)
{
    ((IUnknown*)FROMINTPTR(pNativeData))->Release();
}


void EnumerableToDispatchMarshaler::CleanUpManagedData(Object *pManagedObj)
{
}


int EnumerableToDispatchMarshaler::GetNativeDataSize()
{
	// Return -1 to indicate the managed type this marshaler handles is not a value type.
	return -1;
}


ICustomMarshaler *EnumerableToDispatchMarshaler::GetInstance(String *pstrCookie)
{
	if (!m_pMarshaler)
		m_pMarshaler = new EnumerableToDispatchMarshaler;
	return m_pMarshaler;
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumerabletodispatchmarshaler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumerableToDispatchMarshaler.h
//
// This file provides the definition of the EnumerableToDispatchMarshaler
// class. This class is used to marshal between IEnumerable and IDispatch
//
//*****************************************************************************
#ifndef _ENUMERABLETODISPATCHMARSHALER_H
#define _ENUMERABLETODISPATCHMARSHALER_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System::Runtime::InteropServices;
using namespace System::Collections;

__gc public class EnumerableToDispatchMarshaler : public ICustomMarshaler
{
public:
    /*=========================================================================
    ** This method marshals a pointer to native data into a managed object.
    =========================================================================*/
	Object *MarshalNativeToManaged(IntPtr pNativeData);

    /*=========================================================================
    ** This method marshals a managed object into a pointer to native data.
    =========================================================================*/
	IntPtr MarshalManagedToNative(Object *pManagedObj);

	/*=========================================================================
	** This method is called to allow the marshaler to clean up the native
	** data.
	=========================================================================*/
	void CleanUpNativeData(IntPtr pNativeData);

	/*=========================================================================
	** This method is called to allow the marshaler to clean up the managed
	** data.
	=========================================================================*/
	void CleanUpManagedData(Object *pManagedObj);

    /*=========================================================================
    ** This method is called to retrieve the size of the native data.
    =========================================================================*/
	int GetNativeDataSize();

    /*=========================================================================
    ** This method is called to retrieve an instance of the custom marshaler.
	** The ExpandoToDispatchExMarshaler only has one instance of the
	** marshaler which is reused.
    =========================================================================*/
	static ICustomMarshaler *GetInstance(String *pstrCookie);

private:
    /*=========================================================================
    ** This class is not made to be created by anyone other then GetInstance().
    =========================================================================*/
	EnumerableToDispatchMarshaler();

    /*=========================================================================
    ** The one and only instance of the marshaler.
    =========================================================================*/
	static EnumerableToDispatchMarshaler *m_pMarshaler = NULL;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _ENUMERABLETODISPATCHMARSHALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\dispatchexpropertyinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// DispatchExPropertyInfo.h
//
// This file provides the declaration and implemention of the
// DispatchExPropertyInfo class. This class represents a PropertyInfo that is
// layered on top of IDispatchEx.
//
//*****************************************************************************

#ifndef _DISPATCHEXPROPERTYINFO_H
#define _DISPATCHEXPROPERTYINFO_H

#include "CustomMarshalersNameSpaceDef.h"
#include "CustomMarshalersDefines.h"
#include "ExpandoViewOfDispatchEx.h"
#include "DispatchExMethodInfo.h"
#include "Resource.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

using namespace System::Reflection;

[Serializable]
__gc private class DispatchExPropertyInfo : public PropertyInfo
{
public:
	DispatchExPropertyInfo(DISPID DispID, String *pstrName, ExpandoViewOfDispatchEx *pOwner)
	: m_DispID(DispID)
	, m_pstrName(pstrName)
	, m_pGetMethod(NULL)
	, m_pSetMethod(NULL)
	, m_pOwner(pOwner)
	{
	}

	/**
	* Return an array of all of the custom attributes
	*/
	Object* GetCustomAttributes(bool inherit) __gc []
	{
		return new Object * __gc [0];
	}

	/**
	* Returns true if this attribute is defined on the given element (including inherited members)
	*/
	bool IsDefined(Type *pType, bool inherit)
	{
		return false;
	}

	/**
	* Return a custom attribute identified by Type
	*/
	Object* GetCustomAttributes(Type *pType, bool inherit) __gc []
	{
		if (!pType)
			throw new ArgumentNullException(L"type");

		return NULL;
	}

	/**
	 * Property the Member Type of the specific memeber.  This
	 * is useful for switch statements.
	 */
	__property MemberTypes get_MemberType()
	{
		return System::Reflection::MemberTypes::Property;
	}

	/**
	 * Property representing the name of the Member.
	 */
	__property String *get_Name()
	{
		return m_pstrName;
	}

	/**
	 * Property representing the class that declared the member.  This may be different
	 * from the reflection class because a sub-class inherits methods from its base class.
	 * These inheritted methods will have a declared class of the last base class to
	 * declare the member.
	 */
	__property Type *get_DeclaringType()
	{
		return m_pOwner->UnderlyingSystemType;
    }

	/**
	 * Property representing the class that was used in reflection to obtain
	 * this Member.
	 */
	__property Type *get_ReflectedType()
	{
		// For IDispatchEx the reflected type is the same as the declaring type.
		return DeclaringType;
	}

	/**
	 * Return the Type that represents the type of the field
	 */
	__property Type *get_PropertyType()
	{
        // This is not really true, but it is what JScript wants.
        return __typeof(Object);
	}

	/**
	 * Get the value of the property.
	 * @param obj Return the property value for this object
	 * @param index Optional index values for indexed properties.
	 */
	Object* GetValue(Object *pObj, BindingFlags invokeAttr, Binder* binder, Object* aIndex __gc [], CultureInfo* culture)
	{
		// Validate the arguments.
		if (!pObj)
			throw new ArgumentNullException(L"obj");
		if (!m_pGetMethod)
			throw new ArgumentException(Resource::FormatString(L"Arg_GetMethNotFnd"), L"obj");

        // Set the get property flag if it is not set.
        if (!(invokeAttr & BindingFlags::GetProperty))
            invokeAttr = (BindingFlags)(invokeAttr | BindingFlags::GetProperty);

		// Invoke the get method.
		return m_pGetMethod->Invoke(pObj, invokeAttr, binder, aIndex, culture);
	}

	/**
	 * Set the value of the property.
	 * @param obj Set the property value for this object.
	 * @param value An Object containing the new value.
	 * @param index Optional index values for indexed properties.
	 */
	void SetValue(Object *pObj, Object* Value,BindingFlags invokeAttr,Binder* binder, Object* aIndex __gc [], CultureInfo* culture)
	{
		Object* aArgs __gc [] = NULL;

		// Validate the arguments.
		if (!pObj)
			throw new ArgumentNullException(L"obj");
		if (!m_pSetMethod)
			throw new ArgumentException(Resource::FormatString(L"Arg_SetMethNotFnd"), L"obj");

		// Prepare the arguments that will be passed to the set method.
		if (!aIndex)
		{
			aArgs = new Object* __gc [1];
			aArgs[0] = Value;
		}
		else
		{
			aArgs = new Object* __gc[aIndex->Count + 1];
			for (int i=0;i<aIndex->Count;i++)
				aArgs[i] = aIndex[i];
			aArgs[aIndex->Count] = Value;
		}

        // Set the set property flag if none of the setter flags are set.
        if (!(invokeAttr & (BindingFlags::SetProperty | BindingFlags::PutDispProperty | BindingFlags::PutRefDispProperty)))
            invokeAttr = (BindingFlags)(invokeAttr | BindingFlags::SetProperty);

		// Invoke the set method.
		m_pSetMethod->Invoke(pObj, invokeAttr, binder, aArgs, culture);
	}

	// GetAccessors
	// This method will return an array of accessors. The array will be empty if no accessors are found.
	MethodInfo* GetAccessors(bool nonPublic) __gc []
	{
		MethodInfo *aAccessors __gc [];

		if (m_pGetMethod && m_pSetMethod)
		{
			 aAccessors = new MethodInfo *__gc [2];
			 aAccessors[0] = m_pGetMethod;
			 aAccessors[1] = m_pSetMethod;
		}
		else if (m_pGetMethod)
		{
			 aAccessors = new MethodInfo * __gc [1];
			 aAccessors[0] = m_pGetMethod;
		}
		else if (m_pSetMethod)
		{
			 aAccessors = new MethodInfo * __gc [1];
			 aAccessors[0] = m_pSetMethod;
		}
		else
		{
			 aAccessors = new MethodInfo * __gc [0];
		}

		return aAccessors;
	}

	// GetMethod
	// This propertery is the MethodInfo representing the Get Accessor
	MethodInfo *GetGetMethod(bool nonPublic)
	{
		return m_pGetMethod;
	}

	// SetMethod
	// This property is the MethodInfo representing the Set Accessor
	MethodInfo *GetSetMethod(bool nonPublic)
	{
		return m_pSetMethod;
	}

	// ResetMethod
	// This property is the PropertyInfo representing the Reset Accessor
	MethodInfo *GetResetMethod(bool nonPublic)
	{
		// IDispatchEx has no notion of a reset method.
		return NULL;
	}

	/**
	 * Return the parameters for the indexes
	 */
	ParameterInfo* GetIndexParameters() __gc []
	{
		return new ParameterInfo* __gc [0];
	}

	// GetChangedEvent
	// This method returns the Changed event if one has
	//	been defined for this property. null otherwise.
	EventInfo *GetChangedEvent()
	{
		// IDispatchEx has no notion of an event called when the value changes.
		return NULL;
	}

	// GetChangingEvent
	// This method returns the Changing event if one has
	//	been defined for the property.  null otherwise.
	EventInfo *GetChangingEvent()
	{
		// IDispatchEx has no notion of an event called when the value is changing.
		return NULL;
	}

	/**
	 * Property representing the Attributes associated with a Member.  All
	 * members have a set of attributes which are defined in relation to
	 * the specific type of member.
	 */
	__property PropertyAttributes get_Attributes()
	{
		return (PropertyAttributes)(0);
	}

	/**
	 * Boolean property indicating if the property can be read.
	 */
	__property bool get_CanRead()
	{
		return m_pGetMethod ? true : false;
	}

	/**
	 * Boolean property indicating if the property can be written.
	 */
	__property bool get_CanWrite()
	{
		return m_pSetMethod ? true : false;
	}

	/**
	 * Returns the DISPID associated with the method.
	 */
	__property int get_DispID()
	{
		return (int)m_DispID;
	}

	/**
	 * This is used to specify the Get method for the property.
	 */
	void SetGetMethod(MethodInfo *pGetMethod)
	{
		// Validate that value is valid.
		if (!pGetMethod)
			throw new ArgumentNullException(L"pGetMethod");

		// This property can only be set once.
		if (m_pGetMethod)
			throw new ExecutionEngineException();

		m_pGetMethod = dynamic_cast<DispatchExMethodInfo*>(pGetMethod);
	}

	/**
	 * This is used to specify the Set method for the property.
	 */
	void SetSetMethod(MethodInfo *pSetMethod)
	{
		// Validate that value is valid.
		if (!pSetMethod)
			throw new ArgumentNullException(L"pSetMethod");

		// This property can only be set once.
		if (m_pSetMethod)
			throw new ExecutionEngineException();

		m_pSetMethod = dynamic_cast<DispatchExMethodInfo*>(pSetMethod);
	}

	/**
	 * Returns the ExpandoViewOfDispatchEx that owns the DispatchExPropertyInfo.
	 */
	__property ExpandoViewOfDispatchEx *get_Owner()
	{
		return m_pOwner;
    }

private:
	DISPID m_DispID;
	String *m_pstrName;
	DispatchExMethodInfo *m_pGetMethod;
	DispatchExMethodInfo *m_pSetMethod;
	ExpandoViewOfDispatchEx *m_pOwner;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _DISPATCHEXPROPERTYINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumvariantviewofenumerator.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumVariantViewOfEnumerator.h
//
// This file provides the definition of the  EnumVariantViewOfEnumerator.cpp class.
// This class is used to expose an IEnumerator as an IEnumVariant.
//
//*****************************************************************************

#ifndef _ENUMVARIANTVIEWOFENUMERATOR_H
#define _ENUMVARIANTVIEWOFENUMERATOR_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System::Runtime::InteropServices;
using namespace System::Collections;

[Serializable]
__gc private class EnumVariantViewOfEnumerator : public ICustomAdapter, public UCOMIEnumVARIANT
{
public:
	// Constructor.
	EnumVariantViewOfEnumerator(Object *pManagedObj);
        
    // The ICustomAdapter method.
    Object *GetUnderlyingObject()
    {
        return m_pMngEnumerator;
    }

	int Next(int celt, int rgvar, int pceltFetched);
    int Skip(int celt);
    int Reset();
    void Clone(int ppenum);

private:
	IEnumerator *m_pMngEnumerator;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _ENUMVARIANTVIEWOFENUMERATOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumeratorviewofenumvariant.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorToEnumVariantMarshaler.cpp
//
// This file provides the implemention of the EnumeratorToEnumVariantMarshaler
// class. This class is used to convert an IEnumerator to an IEnumVariant.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "EnumeratorViewOfEnumVariant.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include <malloc.h>


// The count of VARIANTS to that are requested every time we call Next.
// ! changed from 64 to 1 (see B#93197)
static const int NUM_VARS_REQUESTED = 1;


EnumeratorViewOfEnumVariant::EnumeratorViewOfEnumVariant(Object *pEnumVariantObj)
: m_pEnumVariantObj(pEnumVariantObj)
, m_CurrIndex(0)
, m_apObjs(new Object*[0])
, m_bFetchedLastBatch(false)
{
}


bool EnumeratorViewOfEnumVariant::MoveNext()
{
    // Increment the current index.
    m_CurrIndex++;


    // If we have reached the end of the cached array of objects, then 
    // we need to retrieve more elements from the IEnumVARIANT.
    if (m_CurrIndex >= m_apObjs.Length)
        return GetNextElems();

    // We have not yet reached the end of the cached array of objects.
    m_pCurrObj = m_apObjs[m_CurrIndex];
    return true;
}


Object *EnumeratorViewOfEnumVariant::get_Current()
{
    return m_pCurrObj;
}


void EnumeratorViewOfEnumVariant::Reset()
{
    IEnumVARIANT *pEnumVariant = NULL;

    try
    {
        pEnumVariant = GetEnumVariant();
        IfFailThrow(pEnumVariant->Reset());
        m_apObjs = new Object*[0];
        m_pCurrObj = NULL;
        m_CurrIndex = 0;
        m_bFetchedLastBatch = false;
    }
    __finally
    {
        if (pEnumVariant)
            pEnumVariant->Release();
    }
}


IEnumVARIANT *EnumeratorViewOfEnumVariant::GetEnumVariant()
{
    IUnknown *pUnk = NULL;
    IEnumVARIANT *pEnumVariant = NULL;

    try
    {
        pUnk = (IUnknown *)FROMINTPTR(Marshal::GetIUnknownForObject(m_pEnumVariantObj));
        IfFailThrow(pUnk->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumVariant));
    }
    __finally
    {
        if (pUnk)
            pUnk->Release();
    }

    return pEnumVariant;
}


bool EnumeratorViewOfEnumVariant::GetNextElems()
{
    VARIANT *aVars;
    ULONG cFetched = 0;
    HRESULT hr;
    IEnumVARIANT *pEnumVariant = NULL;
    
    // If we have already retrieved the last batch, then do not try to retrieve 
    // more. This is required because some IEnumVARIANT implementations reset
    // themselves and restart from the beginning if they are called after having
    // returned S_FALSE;
    if (m_bFetchedLastBatch)
    {
        m_apObjs = new Object*[0];
        m_pCurrObj = NULL;
        return false;
    }

    // Initialize the variant array before we call Next().
    aVars = reinterpret_cast<VARIANT*>(_alloca(NUM_VARS_REQUESTED * sizeof(VARIANT)));
    memset(aVars, 0, NUM_VARS_REQUESTED * sizeof(VARIANT)); 
    
    try
    {
        // Retrieve the IEnumVARIANT pointer.
        pEnumVariant = GetEnumVariant();

        // Go to the native IEnumVariant to get the next element.
        IfFailThrow(hr = pEnumVariant->Next(NUM_VARS_REQUESTED, aVars, &cFetched));
    
        // Check for end of enumeration condition.
        if (hr == S_FALSE)
        {
            // Remember this is the last batch.
            m_bFetchedLastBatch = true;

            // If the last batch is empty, then return false right away.
            if (cFetched == 0)
            {
                // There are no more elements.
                m_apObjs = new Object*[0];
                m_pCurrObj = NULL;
                return false;
            }
        }

        // Convert the variants to objects.
        m_apObjs = Marshal::GetObjectsForNativeVariants((IntPtr)aVars, cFetched);

        // Set the current index back to 0.
        m_CurrIndex = 0;

        // Retrieve the current object.
        m_pCurrObj = m_apObjs[m_CurrIndex];
    }
    __finally
    {
        // If we managed to retrieve an IDispatch pointer then release it.
        if (pEnumVariant)
            pEnumVariant->Release();

        // Clear the variants we got back from Next.
        for (int i = 0; i < cFetched; i++)
            VariantClear(&aVars[i]);
    }
    
    // We have not yet reached the end of the enumeration.
    return true;
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumeratortoenumvariantmarshaler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorToEnumVariantMarshaler.cpp
//
// This file provides the implemention of the EnumeratorToEnumVariantMarshaler
// class. This class is used to marshal between IEnumVariant and IEnumerator.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "EnumeratorToEnumVariantMarshaler.h"
#include "EnumeratorViewOfEnumVariant.h"
#include "EnumVariantViewOfEnumerator.h"
#include "Resource.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()


#define CACHE_MANAGED_VIEWS


EnumeratorToEnumVariantMarshaler::EnumeratorToEnumVariantMarshaler()
{
}


Object *EnumeratorToEnumVariantMarshaler::MarshalNativeToManaged(IntPtr pNativeData)
{
    HRESULT hr = S_OK;
    IEnumVARIANT *pEnumVARIANT = NULL;
    EnumeratorViewOfEnumVariant *pMngView = NULL;

	// Validate the arguments.
    if (pNativeData == TOINTPTR(0))
		throw new ArgumentNullException(L"pNativeData");

    // Retrieve the __ComObject that wraps the IUnknown *.
    Object *pComObj = Marshal::GetObjectForIUnknown(pNativeData);

    // If we are dealing with a managed object, then cast it directly.
    if (!pComObj->GetType()->get_IsCOMObject())
        return dynamic_cast<IEnumerator *>(pComObj);

    // Validate that the COM component implements IEnumVARIANT.
    hr = ((IUnknown*)FROMINTPTR(pNativeData))->QueryInterface(IID_IEnumVARIANT, (void**)&pEnumVARIANT);
    if (FAILED(hr) || !pEnumVARIANT)
        throw new InvalidCastException(Resource::FormatString(L"InvalidCast_QIForEnumVarFailed"));
    pEnumVARIANT->Release();

    // Retrieve the type of the managed view.
    Object *pKey = __typeof(EnumeratorViewOfEnumVariant);

    // Check to see if the __ComObject already has the managed view cached.
    pMngView = dynamic_cast<EnumeratorViewOfEnumVariant *>(Marshal::GetComObjectData(pComObj, pKey));

    // If it doesn't have a cached managed view, then allocate one.
    if (!pMngView)
    {
        pMngView = new EnumeratorViewOfEnumVariant(pComObj);
        if (!Marshal::SetComObjectData(pComObj, pKey, pMngView))
        {
            // Someone beat us to adding the managed view so fetch it again.
            pMngView = dynamic_cast<EnumeratorViewOfEnumVariant *>(Marshal::GetComObjectData(pComObj, pKey));
        }
    }

	return pMngView;
}


IntPtr EnumeratorToEnumVariantMarshaler::MarshalManagedToNative(Object *pManagedObj)
{
    // Validate the arguments.
    if (!pManagedObj)
        throw new ArgumentNullException(L"pManagedObj");
    
    // Create a native view of the managed data.
    EnumVariantViewOfEnumerator *pNativeView = new EnumVariantViewOfEnumerator(pManagedObj);
    
    // Retrieve the a pointer to the IEnumVARIANT interface.
    return Marshal::GetComInterfaceForObject(pNativeView, __typeof(UCOMIEnumVARIANT));
}


void EnumeratorToEnumVariantMarshaler::CleanUpNativeData(IntPtr pNativeData)
{
    ((IUnknown*)FROMINTPTR(pNativeData))->Release();
}


void EnumeratorToEnumVariantMarshaler::CleanUpManagedData(Object *pManagedObj)
{
}


int EnumeratorToEnumVariantMarshaler::GetNativeDataSize()
{
    // Return -1 to indicate the managed type this marshaler handles is not a value type.
    return -1;
}


ICustomMarshaler *EnumeratorToEnumVariantMarshaler::GetInstance(String *pstrCookie)
{
    if (!m_pMarshaler)
        m_pMarshaler = new EnumeratorToEnumVariantMarshaler;
    return m_pMarshaler;
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumeratorviewofenumvariant.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorViewOfEnumVariant.h
//
// This file provides the definition of the  EnumeratorViewOfEnumVariant class.
// This class is used to expose an IEnumVariant as an IEnumerator.
//
//*****************************************************************************

#ifndef _ENUMERATORVIEWOFENUMVARIANT_H
#define _ENUMERATORVIEWOFENUMVARIANT_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System::Runtime::InteropServices;
using namespace System::Collections;

[Serializable]
__gc private class EnumeratorViewOfEnumVariant : public ICustomAdapter, public IEnumerator
{
public:
    // Constructor.
    EnumeratorViewOfEnumVariant(Object *pEnumVariantObj);
    
    // The ICustomAdapter method.
    Object *GetUnderlyingObject()
    {
        return m_pEnumVariantObj;
    }

    // The IEnumerator methods.
    bool MoveNext();
    __property Object *get_Current();
    void Reset();
    
private:
    IEnumVARIANT *GetEnumVariant();
    bool GetNextElems();

    Object *m_pEnumVariantObj;
    Object *m_apObjs[];
    int m_CurrIndex;
    Object *m_pCurrObj;
    bool m_bFetchedLastBatch;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _ENUMERATORVIEWOFENUMVARIANT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumerableviewofdispatch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorViewOfEnumVariant.h
//
// This file provides the definition of the  EnumerableViewOfDispatch class.
// This class is used to expose an IDispatch as an IEnumerable.
//
//*****************************************************************************

#ifndef _ENUMERABLEVIEWOFDISPATCH_H
#define _ENUMERABLEVIEWOFDISPATCH_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System::Collections;

[Serializable]
__gc private class EnumerableViewOfDispatch : public ICustomAdapter, public IEnumerable
{
public:
	// Constructor.
	EnumerableViewOfDispatch(Object *pDispObj);

    // The ICustomAdapter method.
    Object *GetUnderlyingObject()
    {
        return m_pDispObj;
    }

	// The IEnumerator methods.
    IEnumerator *GetEnumerator();

private:
    IDispatch *GetDispatch();

    Object *m_pDispObj;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _ENUMERABLEVIEWOFDISPATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumeratortoenumvariantmarshaler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorToEnumVariantMarshaler.cpp
//
// This file provides the definition of the EnumeratorToEnumVariantMarshaler
// class. This class is used to marshal between IEnumVariant and IEnumerator.
//
//*****************************************************************************
#ifndef _ENUMERATORTOENUMVARIANTMARSHALER_H
#define _ENUMERATORTOENUMVARIANTMARSHALER_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System::Runtime::InteropServices;
using namespace System::Collections;

__gc public class EnumeratorToEnumVariantMarshaler : public ICustomMarshaler
{
public:
    /*=========================================================================
    ** This method marshals a pointer to native data into a managed object.
    =========================================================================*/
	Object *MarshalNativeToManaged(IntPtr pNativeData);

    /*=========================================================================
    ** This method marshals a managed object into a pointer to native data.
    =========================================================================*/
	IntPtr MarshalManagedToNative(Object *pManagedObj);

	/*=========================================================================
	** This method is called to allow the marshaler to clean up the native
	** data.
	=========================================================================*/
	void CleanUpNativeData(IntPtr pNativeData);

	/*=========================================================================
	** This method is called to allow the marshaler to clean up the managed
	** data.
	=========================================================================*/
	void CleanUpManagedData(Object *pManagedObj);

    /*=========================================================================
    ** This method is called to retrieve the size of the native data.
    =========================================================================*/
	int GetNativeDataSize();

    /*=========================================================================
    ** This method is called to retrieve an instance of the custom marshaler.
	** The ExpandoToDispatchExMarshaler only has one instance of the
	** marshaler which is reused.
    =========================================================================*/
	static ICustomMarshaler *GetInstance(String *pstrCookie);

private:
    /*=========================================================================
    ** This class is not made to be created by anyone other then GetInstance().
    =========================================================================*/
	EnumeratorToEnumVariantMarshaler();

    /*=========================================================================
    ** The one and only instance of the marshaler.
    =========================================================================*/
	static EnumeratorToEnumVariantMarshaler *m_pMarshaler = NULL;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _ENUMERATORTOENUMVARIANTMARSHALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumerableviewofdispatch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorToEnumVariantMarshaler.cpp
//
// This file provides the definition of the EnumerableViewOfDispatch class.
// This class is used to expose an IDispatch as an IEnumerable.
//
//*****************************************************************************

#using <mscorlib.dll>
#include "EnumerableViewOfDispatch.h"
#include "EnumeratorToEnumVariantMarshaler.h"
#include "Resource.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()


EnumerableViewOfDispatch::EnumerableViewOfDispatch(Object *pDispObj)
: m_pDispObj(pDispObj)
{
}

IEnumerator *EnumerableViewOfDispatch::GetEnumerator()
{
    HRESULT hr;
    DISPPARAMS DispParams = {0, 0, NULL, NULL};
    VARIANT VarResult;
    IEnumVARIANT *pEnumVar = NULL;
    IEnumerator *pEnum = NULL;
    IDispatch *pDispatch = NULL;

    // Initialize the return variant.
    VariantInit(&VarResult);

    try
    {
        // Retrieve the IDispatch pointer.
        pDispatch = GetDispatch();

        // Call the DISPID_NEWENUM to retrive an IEnumVARIANT.
        IfFailThrow(pDispatch->Invoke(
                            DISPID_NEWENUM,
                            IID_NULL,
                            LOCALE_USER_DEFAULT,
                            DISPATCH_METHOD | DISPATCH_PROPERTYGET,
                            &DispParams,
                            &VarResult,
                            NULL,
                            NULL
                          ));

        // Validate that the returned variant is valid.
        if (VarResult.vt != VT_UNKNOWN && VarResult.vt != VT_DISPATCH)
            throw new InvalidOperationException(Resource::FormatString(L"InvalidOp_InvalidNewEnumVariant"));
        
        // QI the interface we got back for IEnumVARIANT.
        IfFailThrow(VarResult.punkVal->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pEnumVar)));
        
        // Marshaler the IEnumVARIANT to IEnumerator.
        ICustomMarshaler *pEnumMarshaler = EnumeratorToEnumVariantMarshaler::GetInstance(NULL);
        pEnum = dynamic_cast<IEnumerator*>(pEnumMarshaler->MarshalNativeToManaged((int)pEnumVar));
    }
    __finally
    {
        // If we managed to retrieve an IDispatch pointer then release it.
        if (pDispatch)
            pDispatch->Release();

        // If we managed to QI for IEnumVARIANT, release it.
        if (pEnumVar)
            pEnumVar->Release();

        // Clear the result variant.
        VariantClear(&VarResult);
    }
    
    return pEnum;
}

IDispatch *EnumerableViewOfDispatch::GetDispatch()
{
    return (IDispatch *)FROMINTPTR(Marshal::GetIDispatchForObject(m_pDispObj));
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\enumvariantviewofenumerator.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// EnumeratorToEnumVariantMarshaler.cpp
//
// This file provides the implemention of the EnumeratorToEnumVariantMarshaler
// class. This class is used to convert an IEnumerator to an IEnumVariant.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "EnumVariantViewOfEnumerator.h"
#include "EnumeratorToEnumVariantMarshaler.h"
#include "Resource.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()


// Define this to enable debugging output.
//#define DISPLAY_DEBUG_INFO

EnumVariantViewOfEnumerator::EnumVariantViewOfEnumerator(Object *pManagedObj)
: m_pMngEnumerator(dynamic_cast<IEnumerator*>(pManagedObj))
{
}


int EnumVariantViewOfEnumerator::Next(int celt, int rgvar, int pceltFetched)
{
    try
    {
	    VARIANT *aVar = (VARIANT*)rgvar;
	    int cElements;

	    // Validate the arguments.
	    if (celt && !rgvar)
		    return E_INVALIDARG;

	    // Initialize the variants in the array.
	    for (cElements = 0; cElements < celt; cElements++)
		    VariantInit(&aVar[cElements]);

		cElements = 0;
		while ((cElements < celt) && m_pMngEnumerator->MoveNext())
		{
			Marshal::GetNativeVariantForObject(m_pMngEnumerator->Current, (int)&aVar[cElements]);
			cElements++;
		}

	    // Set the number of elements that were fetched.
	    if (pceltFetched)
		    *((int *)pceltFetched) = cElements;

	    return (cElements == celt) ? S_OK : S_FALSE;
	}
	catch (Exception *e)
	{
        return Marshal::GetHRForException(e);
	}
	return S_FALSE;		// should be unreachable, but keeps compiler happy
}


int EnumVariantViewOfEnumerator::Skip(int celt)
{
    try
    {
	    int cElements = 0;
	    while ((cElements < celt) && m_pMngEnumerator->MoveNext())
	    {
		    cElements++;
	    }

	    return (cElements == celt) ? S_OK : S_FALSE;
    }
	catch (Exception *e)
	{
        return Marshal::GetHRForException(e);
	}
	return S_FALSE;		// should be unreachable, but keeps compiler happy
}

int EnumVariantViewOfEnumerator::Reset()
{
	// We don't currently support resetting the enumeration.
	return S_FALSE;
}


void EnumVariantViewOfEnumerator::Clone(int ppEnum)
{
	// Validate the argument.
	if (!ppEnum)
        throw new ArgumentNullException("ppEnum");

	// Check to see if the enumerator is cloneable.
	if (!__typeof(ICloneable)->IsInstanceOfType(m_pMngEnumerator))
        throw new COMException(Resource::FormatString(L"Arg_EnumNotCloneable"), E_FAIL);

	// Clone the enumerator.
	IEnumerator *pNewMngEnum = dynamic_cast<IEnumerator *>((dynamic_cast<ICloneable*>(m_pMngEnumerator))->Clone());

	// Use the custom marshaler to convert the managed enumerator to an IEnumVARIANT.
	*(reinterpret_cast<int *>(ppEnum)) = (int)(EnumeratorToEnumVariantMarshaler::GetInstance(NULL)->MarshalManagedToNative(pNewMngEnum));
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\expandoviewofdispatchex.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ExpandoViewOfDispatchEx.cpp
//
// This file provides the implemention of the  ExpandoViewOfDispatchEx class.
// This class is used to expose an IDispatchEx as an IExpando.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "ExpandoViewOfDispatchEx.h"
#include "DispatchExMethodInfo.h"
#include "DispatchExPropertyInfo.h"
#include "Resource.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include <malloc.h>

using namespace System::Threading;
using namespace System::Collections;

// Define this to enable debugging output.
//#define DISPLAY_DEBUG_INFO


ExpandoViewOfDispatchEx::ExpandoViewOfDispatchEx(Object *pDispExObj)
: m_pDispExObj(pDispExObj)
, m_pNameToMethodMap(new Hashtable)
, m_pNameToPropertyMap(new Hashtable)
{
}


MethodInfo *ExpandoViewOfDispatchEx::GetMethod(String *pstrName, BindingFlags BindingAttr)
{
    return GetMethod(pstrName, BindingAttr, NULL, NULL, NULL);
}


MethodInfo *ExpandoViewOfDispatchEx::GetMethod(String *pstrName, BindingFlags BindingAttr, Binder *pBinder, Type* apTypes __gc [], ParameterModifier aModifiers __gc [])
{
    bool bNewMemberAdded = false;
    IDispatchEx *pDispEx = NULL;

    // Validate the arguments.
    if (!pstrName)
        throw new ArgumentNullException(L"name");   

    try
    {
        // Retrieve the IEnumVARIANT pointer.
        pDispEx = GetDispatchEx();

        do
        {
            // Check to see if the specified name matches a method in our current view of the IDispatchEx.
            MethodInfo *pMethod = dynamic_cast<MethodInfo*>(m_pNameToMethodMap->Item[pstrName]);
            if (pMethod)
                return pMethod;
        
            // We haven't found the member through GetNextDispId so ask for it directly 
            // using GetDispID().
            DISPID DispID = DISPID_UNKNOWN;

            // Retrieve a BSTR from the member name.
            BSTR bstrMemberName = reinterpret_cast<BSTR>(FROMINTPTR(Marshal::StringToBSTR(pstrName)));
     
            // Call GetDispID to try and locate the method. If this fails then the method is not present.
            if (SUCCEEDED(pDispEx->GetDispID(bstrMemberName, BindingAttr & BindingFlags::IgnoreCase ? fdexNameCaseInsensitive : fdexNameCaseSensitive, &DispID)))
            {
                AddNativeMember(DispID, pstrName);
                bNewMemberAdded = true;
            }

            // Free the BSTR.
            SysFreeString(bstrMemberName);

            // The member has not been found so synch with the native IDispatchEx view and
            // try again if the members of the native IDispatchEx have changed.
        }
        while (bNewMemberAdded || SynchWithNativeView());   
    }
    __finally
    {
        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }

    // The member has not been found.
    return NULL;
}


MethodInfo* ExpandoViewOfDispatchEx::GetMethods(BindingFlags BindingAttr) __gc []
{
    // We must synch with the native view before we give an array back to make sure it is up to date.
    SynchWithNativeView();
    
    // Retrieve the size of the method map.
    int MethodMapSize = m_pNameToMethodMap->Count;
    
    // Create an array that will contain the members.
    MethodInfo *apMethods __gc [] = new MethodInfo * __gc [MethodMapSize];
    
    // Copy the contents of the method map into the array.
    if (MethodMapSize > 0)
        m_pNameToMethodMap->get_Values()->CopyTo(apMethods, 0);
    
    return apMethods;
}


FieldInfo *ExpandoViewOfDispatchEx::GetField(String *pstrName, BindingFlags BindingAttr)
{
    // Validate the arguments.
    if (!pstrName)
        throw new ArgumentNullException(L"name");
    
    // IDispatchEx does not have a notion of fields.
    return NULL;
}


FieldInfo* ExpandoViewOfDispatchEx::GetFields(BindingFlags BindingAttr) __gc []
{
    // IDispatchEx does not have a notion of fields.
    return new FieldInfo * __gc [0];
}


PropertyInfo *ExpandoViewOfDispatchEx::GetProperty(String *pstrName, BindingFlags BindingAttr)
{
    return GetProperty(pstrName, BindingAttr, NULL, NULL, NULL, NULL);
}


PropertyInfo *ExpandoViewOfDispatchEx::GetProperty(String *pstrName, BindingFlags BindingAttr, Binder *pBinder, Type *pReturnType, Type* apTypes __gc [], ParameterModifier aModifiers __gc [])
{
    bool bNewMemberAdded = false;
    IDispatchEx *pDispEx = NULL;

    // Validate the arguments.
    if (!pstrName)
        throw new ArgumentNullException(L"name");   

    try
    {
        // Retrieve the IEnumVARIANT pointer.
        pDispEx = GetDispatchEx();

        do
        {
            // Check to see if the specified name matches a property in our current view of the IDispatchEx.
            PropertyInfo *pProperty = dynamic_cast<PropertyInfo*>(m_pNameToPropertyMap->Item[pstrName]);
            if (pProperty)
                return pProperty;
        
            // We haven't found the member through GetNextDispId so ask for it directly 
            // using GetDispID().
            DISPID DispID = DISPID_UNKNOWN;

            // Retrieve a BSTR from the member name.
            BSTR bstrMemberName = reinterpret_cast<BSTR>(FROMINTPTR(Marshal::StringToBSTR(pstrName)));
     
            // Call GetDispID to try and locate the method. If this fails then the method is not present.
            if (SUCCEEDED(pDispEx->GetDispID(bstrMemberName, BindingAttr & BindingFlags::IgnoreCase ? fdexNameCaseInsensitive : fdexNameCaseSensitive, &DispID)))
            {
                AddNativeMember(DispID, pstrName);
                bNewMemberAdded = true;
            }

            // Free the BSTR.
            SysFreeString(bstrMemberName);

            // The member has not been found so synch with the native IDispatchEx view and
            // try again if the members of the native IDispatchEx have changed.
        }
        while (bNewMemberAdded || SynchWithNativeView());
    }
    __finally
    {
        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }

    // The member has not been found.
    return NULL;
}


PropertyInfo* ExpandoViewOfDispatchEx::GetProperties(BindingFlags BindingAttr)  __gc []
{
    // We must synch with the native view before we give an array back to make sure it is up to date.
    SynchWithNativeView();
    
    // Retrieve the size of the property map.
    int PropertyMapSize = m_pNameToMethodMap->Count;
    
    // Create an array that will contain the members.
    PropertyInfo *apProperties __gc [] = new  PropertyInfo * __gc [PropertyMapSize];
    
    // Copy the contents of the property map into the array.
    if (PropertyMapSize > 0)
        m_pNameToPropertyMap->get_Values()->CopyTo(apProperties, 0);
    
    return apProperties;
}


MemberInfo* ExpandoViewOfDispatchEx::GetMember(String *pstrName, BindingFlags BindingAttr) __gc []
{
    bool bNewMemberAdded = false;
    IDispatchEx *pDispEx = NULL;

    // Validate the arguments.
    if (!pstrName)
        throw new ArgumentNullException(L"name");   

    try
    {
        // Retrieve the IEnumVARIANT pointer.
        pDispEx = GetDispatchEx();

        do
        {
            // First check if the specified name is for a property.
            MemberInfo *pMember = dynamic_cast<MemberInfo*>(m_pNameToPropertyMap->Item[pstrName]);
            if (!pMember)
            {
                // Next check to see if it is a method.
                pMember = dynamic_cast<MemberInfo*>(m_pNameToMethodMap->Item[pstrName]);
            }
        
            // @TODO(DM): Should we add the Get and Set methods if the member is a property ???

            // If we have found the member then return an array with it as the only element.
            if (pMember)
            {
                MemberInfo *apMembers __gc [] = new MemberInfo * __gc [1];
                apMembers[0] = pMember;
                return apMembers;
            }

            // We haven't found the member through GetNextDispId so ask for it directly 
            // using GetDispID().
            DISPID DispID = DISPID_UNKNOWN;

            // Retrieve a BSTR from the member name.
            BSTR bstrMemberName = reinterpret_cast<BSTR>(FROMINTPTR(Marshal::StringToBSTR(pstrName)));
     
            // Call GetDispID to try and locate the method. If this fails then the method is not present.
            if (SUCCEEDED(pDispEx->GetDispID(bstrMemberName, BindingAttr & BindingFlags::IgnoreCase ? fdexNameCaseInsensitive : fdexNameCaseSensitive, &DispID)))
            {
                AddNativeMember(DispID, pstrName);
                bNewMemberAdded = true;
            }

            // Free the BSTR.
            SysFreeString(bstrMemberName);

            // The member has not been found so synch with the native IDispatchEx view and
            // try again if the members of the native IDispatchEx have changed.
        }
        while (bNewMemberAdded || SynchWithNativeView());
    }
    __finally
    {
        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }

    // The member has not been found.
    return NULL;
}

MemberInfo* ExpandoViewOfDispatchEx::GetMembers(BindingFlags BindingAttr) __gc []
{
    // We must synch with the native view before we give an array back to make sure it is up to date.
    SynchWithNativeView();
    
    // Retrieve the size of the property and method maps.
    int PropertyMapSize = m_pNameToPropertyMap->Count;
    int MethodMapSize = m_pNameToMethodMap->Count;
    
    // Create an array that will contain the members.
    MemberInfo *apMembers __gc [] = new  MemberInfo * __gc [PropertyMapSize + MethodMapSize];
    
    // Copy the properties into the array of members.
    if (PropertyMapSize > 0)
        m_pNameToPropertyMap->get_Values()->CopyTo(apMembers, 0);
    
    // Copy the methods into the array of members.
    if (MethodMapSize > 0)
        m_pNameToMethodMap->get_Values()->CopyTo(apMembers, m_pNameToPropertyMap->Count);
    
    // Return the filled in array of members.
    return apMembers;
}


Object* ExpandoViewOfDispatchEx::InvokeMember(String *pstrName, BindingFlags InvokeAttr, Binder *pBinder, Object *pTarget, Object* aArgs __gc [], ParameterModifier aModifiers __gc [], CultureInfo *pCultureInfo,  String* astrNamedParameters __gc [])
{
    DISPID MemberDispID = DISPID_UNKNOWN;
    
    //
    // Validate the arguments.
    //
    
    if (!pstrName)
        throw new ArgumentNullException(L"name");
    if (!pTarget)
        throw new ArgumentNullException(L"target");
    if (!IsOwnedBy(pTarget))
        throw new ArgumentException(Resource::FormatString(L"Arg_TargetNotValidForIReflect"), L"target");
    
    
    //
    // Attempt to locate the member by looking at the managed view. This will cover all
    // the members except the ones the IDispatchEx server didn't not provide properties for.
    //
    
    if (InvokeAttr & (BindingFlags::GetProperty | BindingFlags::SetProperty))
    {
        // Retrieve property with the given name and if we find it retrieve the DISPID.
        DispatchExPropertyInfo *pProperty = dynamic_cast<DispatchExPropertyInfo *>(GetProperty(pstrName, InvokeAttr));
        if (pProperty)
            MemberDispID = pProperty->DispID;
    }
    else if (InvokeAttr & BindingFlags::InvokeMethod)
    {
        DispatchExMethodInfo *pMethod = dynamic_cast<DispatchExMethodInfo *>(GetMethod(pstrName, InvokeAttr));
        if (pMethod)
            MemberDispID = pMethod->DispID;
    }
    else
    {
        // The binding flags are invalid.
        throw new ArgumentException(Resource::FormatString("Arg_NoAccessSpec"),"invokeAttr");
    }
    
    
    //
    // Phase 2: If we have not located the member in the managed view then we need to go and
    //          search for it on the IDispatchEx server.
    //
    
    // If we have found the method then simply invoke on it and return the result.
    if (MemberDispID == DISPID_UNKNOWN)
    {
       IDispatchEx *pDispEx = NULL;

        try
        {
            // Retrieve the IEnumVARIANT pointer.
            pDispEx = GetDispatchEx();

            // Retrieve a BSTR from the member name.
            BSTR bstrMemberName = reinterpret_cast<BSTR>(FROMINTPTR(Marshal::StringToBSTR(pstrName)));
        
            // Call GetDispID to try and locate the method. If this fails then the method is not present.
            if (FAILED(pDispEx->GetDispID(bstrMemberName, InvokeAttr & BindingFlags::IgnoreCase ? fdexNameCaseInsensitive : fdexNameCaseSensitive, &MemberDispID)))
            {
                MemberDispID = DISPID_UNKNOWN;
            }
        
            // Free the BSTR.
            SysFreeString(bstrMemberName);
        }
        __finally
        {
            // Release the IDispatchEx IUnknown.
            if (pDispEx)
                pDispEx->Release();
        }
    }
    
    
    //
    // Phase 3: Invoke the method if we have found it or throw an exception if we have not.
    //
    
    // We have found the method so invoke it and return the result.
    if (MemberDispID != DISPID_UNKNOWN)
    {
        int Flags = InvokeAttrsToDispatchFlags(InvokeAttr);
        return DispExInvoke(pstrName, MemberDispID, Flags, pBinder, aArgs, aModifiers, pCultureInfo, astrNamedParameters);
    }
    else
    {
        throw new MissingMethodException(Resource::FormatString("MissingMember"));
    }
}


FieldInfo *ExpandoViewOfDispatchEx::AddField(String *pstrName)
{
    if (!pstrName)
        throw new ArgumentNullException(L"name");
    
    throw new NotSupportedException(Resource::FormatString("NotSupported_AddingFieldsNotSupported"));
    return NULL;
}


PropertyInfo *ExpandoViewOfDispatchEx::AddProperty(String *pstrName)
{
    HRESULT hr = S_OK;
    DispatchExPropertyInfo *pProperty = NULL;
    DISPID MemberDispID = DISPID_UNKNOWN;
    IDispatchEx *pDispEx = NULL;
    
    if (!pstrName)
        throw new ArgumentNullException(L"name");

    try
    {
        // Retrieve the IEnumVARIANT pointer.
        pDispEx = GetDispatchEx();
   
        // Take a lock before we manipulate the hashtables.
        Monitor::Enter(this);
    
        // Check to see if the property is already present.
        pProperty = dynamic_cast<DispatchExPropertyInfo*>(m_pNameToPropertyMap->Item[pstrName]);
        if (!pProperty)
        {
            // Retrieve a BSTR from the member name.
            BSTR bstrMemberName = reinterpret_cast<BSTR>(FROMINTPTR(Marshal::StringToBSTR(pstrName)));
        
            // Add the property to the IDispatchEx server.
            hr = pDispEx->GetDispID(bstrMemberName, fdexNameCaseSensitive | fdexNameEnsure, &MemberDispID);
        
            // Free the BSTR.
            SysFreeString(bstrMemberName);
        
            // If the member was added successfully to the IDispatchEx server then add it to the managed view.
            if (SUCCEEDED(hr) && (MemberDispID != DISPID_UNKNOWN))
            {
                // Create a new property info for the member we are adding.
                pProperty = new DispatchExPropertyInfo(MemberDispID, pstrName, this);
            
                // Create the set method and add it to the property.
                pProperty->SetSetMethod(new DispatchExMethodInfo(
                    MemberDispID,
                    pstrName,
                    MethodType_SetMethod,
                    this));
            
                // Create the get method and add it to the property.
                pProperty->SetGetMethod(new DispatchExMethodInfo(
                    MemberDispID,
                    pstrName,
                    MethodType_GetMethod,
                    this));
            
                // Add the member to the name to property map.
                m_pNameToPropertyMap->Item[pstrName] = pProperty;
            }
        }
    
        // Leave the critical section now that we have finished adding the member.
        Monitor::Exit(this);
    }
    __finally
    {
        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }
    
    return pProperty;
}


MethodInfo *ExpandoViewOfDispatchEx::AddMethod(String *pstrName, Delegate *pMethod)
{
    if (!pstrName)
        throw new ArgumentNullException(L"name");

    throw new NotSupportedException(Resource::FormatString("NotSupported_AddingMethsNotSupported"));
    return NULL;
}


void ExpandoViewOfDispatchEx::RemoveMember(MemberInfo *pMember)
{
    DISPID DispID = DISPID_UNKNOWN;
    ExpandoViewOfDispatchEx *pMemberOwner = NULL;
    Hashtable *pMemberMap = NULL;
    IDispatchEx *pDispEx = NULL;
    HRESULT hr = S_OK;
    bool bMonitorEntered = false;
    
    if (!pMember)
        throw new ArgumentNullException(L"member");
    
    switch (pMember->MemberType)
    {
        case MemberTypes::Method:
        {
            try
            {
                // Try and cast the member to a DispatchExMethodInfo.
                DispatchExMethodInfo *pDispExMethod = dynamic_cast<DispatchExMethodInfo *>(pMember);
                
                // Retrieve the information we need from the DispatchExMethodInfo.
                DispID = pDispExMethod->DispID;
                pMemberOwner = pDispExMethod->Owner;
                pMemberMap = m_pNameToMethodMap;
            }
            catch (InvalidCastException *e)
            {
                // The member is not a DispatchExMemberInfo.
                throw new ArgumentException(Resource::FormatString("Arg_InvalidMemberInfo"), "member");
            }
            break;
        }
        
        case MemberTypes::Property:
        {
            try
            {
                // Try and cast the member to a DispatchExPropertyInfo.
                DispatchExPropertyInfo *pDispExProp = dynamic_cast<DispatchExPropertyInfo *>(pMember);
                
                // Retrieve the information we need from the DispatchExPropertyInfo.
                DispID = pDispExProp->DispID;
                pMemberOwner = pDispExProp->Owner;
                pMemberMap = m_pNameToPropertyMap;
            }
            catch (InvalidCastException *e)
            {
                // The member is not a DispatchExMemberInfo.
                throw new ArgumentException(Resource::FormatString("Arg_InvalidMemberInfo"), "member");
            }
            break;
        }
        
        default:
        {
            // The member not of a supported type.
            throw new ArgumentException(Resource::FormatString("Arg_InvalidMemberInfo"), "member");
        }
    }
    
    // Make sure the MemberInfo is associated with the current ExpandoViewOfDispatchEx either
    // directly if the ExpandoViewOfDispatchEx that owns the MemberInfo is the current one or
    // by sharing the same COM IDispatchEx server.
    if (this != pMemberOwner)
        throw new ArgumentException(Resource::FormatString("Arg_InvalidMemberInfo"), "member");

    try
    {     
        // Retrieve the IEnumVARIANT pointer.
        pDispEx = GetDispatchEx();

        // This needs to be synchronized to ensure that only one thread plays around
        // with the hashtables.
        Monitor::Enter(this);
        bMonitorEntered = true;

        // Remove the member from the native IDispatchEx server.
        IfFailThrow(pDispEx->DeleteMemberByDispID(DispID));
    
        // Remove the member from the managed view's list of members.
        pMemberMap->Remove(pMember->Name);   
    }
    __finally
    {
        // We have entered the monitor we need to exit it now that are finished playing
        // around with the hashtables.
        if (bMonitorEntered)
            Monitor::Exit(this);

        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }
}


int ExpandoViewOfDispatchEx::InvokeAttrsToDispatchFlags(BindingFlags InvokeAttr)
{
    int Flags = 0;

    if (InvokeAttr & BindingFlags::InvokeMethod)
        Flags |= DISPATCH_METHOD;
    if (InvokeAttr & BindingFlags::GetProperty)
        Flags |= DISPATCH_PROPERTYGET;
    if (InvokeAttr & BindingFlags::SetProperty)
        Flags = DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF;
    if (InvokeAttr & BindingFlags::PutDispProperty)
        Flags = DISPATCH_PROPERTYPUT;
    if (InvokeAttr & BindingFlags::PutRefDispProperty)
        Flags = DISPATCH_PROPERTYPUTREF;
    if (InvokeAttr & BindingFlags::CreateInstance)
        Flags |= DISPATCH_CONSTRUCT;

    return Flags;
}

Object *ExpandoViewOfDispatchEx::DispExInvoke(String *pstrMemberName, DISPID MemberDispID, int Flags, Binder *pBinder, Object* aArgs __gc [], ParameterModifier aModifiers __gc [], CultureInfo *pCultureInfo, String* astrNamedParameters __gc [])
{
    HRESULT hr;
    UINT i;
    UINT cArgs = !aArgs ? 0 : aArgs->Count;
    UINT cNamedArgs = !astrNamedParameters ? 0 : astrNamedParameters->Count;
    DISPID *aDispID;
    DISPPARAMS DispParams;
    VARIANT VarResult;
    Object *ObjResult = NULL;
    IDispatchEx *pDispEx = NULL;
    
    // @TODO(DM): Convert the CultureInfo to a LCID.
    LCID lcid = NULL;
    

    try
    {
        //
        // Retrieve the IEnumVARIANT pointer.
        //

        pDispEx = GetDispatchEx();

        
        //
        // Retrieve the DISPID's of the named arguments if any named arguments are specified.
        //
    
        if (cNamedArgs > 0)
        {
            // @TODO(DM): Handle invoking on the standard DISPID's.
        
            //
            // Create an array of strings that will be passed to GetIDsOfNames().
            //
        
            UINT cNamesToConvert = cNamedArgs + 1;
        
            // Allocate the array of strings to convert, the array of pinned handles and the
            // array of converted DISPID's.
            LPWSTR *aNamesToConvert = reinterpret_cast<LPWSTR *>(_alloca(cNamesToConvert * sizeof(LPWSTR)));
            GCHandle ahndPinnedObjs __gc [] = new GCHandle __gc [cNamesToConvert];
            aDispID = reinterpret_cast<DISPID *>(_alloca(cNamesToConvert * sizeof(DISPID)));
        
            // Pin the managed name string and use it directly as a LPWSTR.
            ahndPinnedObjs[0] = GCHandle::Alloc(pstrMemberName, GCHandleType::Pinned);
            aNamesToConvert[0] = reinterpret_cast<LPWSTR>(FROMINTPTR(ahndPinnedObjs[0].AddrOfPinnedObject()));
        
            // Copy the named arguments into the array of names to convert.
            for (i = 0; i < cNamedArgs; i++)
            {
                // Pin the string object and retrieve a pointer to its data.
                ahndPinnedObjs[i + 1] = GCHandle::Alloc(astrNamedParameters[i], GCHandleType::Pinned);
                aNamesToConvert[i + 1] = reinterpret_cast<LPWSTR>(FROMINTPTR(ahndPinnedObjs[i + 1].AddrOfPinnedObject()));
            }
        
        
            //
            // Call GetIDsOfNames to convert the names to DISPID's
            //
        
            // Call GetIdsOfNames() to retrieve the DISPID's of the method and of the arguments.
            hr = pDispEx->GetIDsOfNames(
                IID_NULL,
                aNamesToConvert,
                cNamesToConvert,
                lcid,
                aDispID
                );
        
            // Now that we no longer need the method and argument names we can un-pin them.
            for (i = 0; i < cNamesToConvert; i++)
                ahndPinnedObjs[i].Free();
        
            // Validate that the GetIDsOfNames() call succeded.
            IfFailThrow(hr);
        
            if (aDispID[0] != MemberDispID)
                throw new InvalidOperationException(Resource::FormatString("InvalidOp_GetIdDiffFromMemId"));
        }
    
    
        //
        // Fill in the DISPPARAMS structure.
        //
    
        if (cArgs > 0)
        {
            UINT cPositionalArgs = cArgs - cNamedArgs;
            DispParams.cArgs = cArgs;
        
            if (!(Flags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)))
            {
                // For anything other than a put or a putref we just use the specified
                // named arguments.
                DispParams.cNamedArgs = cNamedArgs;
                DispParams.rgdispidNamedArgs = (cNamedArgs == 0) ? NULL : &aDispID[1];
                DispParams.rgvarg = reinterpret_cast<VARIANTARG *>(_alloca(cArgs * sizeof(VARIANTARG)));
            
                // Convert the named arguments from COM+ to OLE. These arguments are in the same order
                // on both sides.
                for (i = 0; i < cNamedArgs; i++)
                    Marshal::GetNativeVariantForObject(aArgs[i], (int)&DispParams.rgvarg[i]);
            
                // Convert the unnamed arguments. These need to be presented in reverse order to IDispatch::Invoke().
                for (i = 0; i < cPositionalArgs; i++)
                    Marshal::GetNativeVariantForObject(aArgs[cNamedArgs + i], (int)&DispParams.rgvarg[cArgs - i - 1]);
            }
            else
            {
                // If we are doing a property put then we need to set the DISPID of the
                // argument to DISP_PROPERTYPUT if there is at least one argument.
                DispParams.cNamedArgs = cNamedArgs + 1;
                DispParams.rgdispidNamedArgs = reinterpret_cast<DISPID*>(_alloca((cNamedArgs + 1) * sizeof(DISPID)));
                DispParams.rgvarg = reinterpret_cast<VARIANTARG *>(_alloca(cArgs * sizeof(VARIANTARG)));
            
                // Fill in the array of named arguments.
                DispParams.rgdispidNamedArgs[0] = DISPID_PROPERTYPUT;
                for (i = 1; i < cNamedArgs; i++)
                    DispParams.rgdispidNamedArgs[i] = aDispID[i];
            
                // The last argument from reflection becomes the first argument that must be passed to IDispatch.
                Marshal::GetNativeVariantForObject(aArgs[cArgs - 1], reinterpret_cast<int>(&DispParams.rgvarg[0]));
            
                // Convert the named arguments from COM+ to OLE. These arguments are in the same order
                // on both sides.
                for (i = 0; i < cNamedArgs; i++)
                    Marshal::GetNativeVariantForObject(aArgs[i], reinterpret_cast<int>(&DispParams.rgvarg[i + 1]));
            
                // Convert the unnamed arguments. These need to be presented in reverse order to IDispatch::Invoke().
                for (i = 0; i < cPositionalArgs - 1; i++)
                    Marshal::GetNativeVariantForObject(aArgs[cNamedArgs + i], reinterpret_cast<int>(&DispParams.rgvarg[cArgs - i - 1]));
            }
        }
        else
        {
            // There are no arguments.
            DispParams.cArgs = cArgs;
            DispParams.cNamedArgs = 0;
            DispParams.rgdispidNamedArgs = NULL;
            DispParams.rgvarg = NULL;
        }
    
    
        //
        // Call invoke on the target's IDispatch.
        //
    
        VariantInit(&VarResult);
    
        IfFailThrow(pDispEx->InvokeEx(
            MemberDispID,
            lcid,
            Flags,
            &DispParams,
            &VarResult,
            NULL,
            NULL    // @TODO(DM): Expose the service provider.
            ));
    
    
        //
        // Convert the native variant back to a managed variant and return it.
        //
    
        // @TODO(DM): Handle converting DISPID_NEWENUM from an IEnumVARIANT to an IEnumerator.
    
        try
        {
            ObjResult = Marshal::GetObjectForNativeVariant(reinterpret_cast<int>(&VarResult));
        }
        __finally
        {
            VariantClear(&VarResult);
        }
    }
    __finally
    {
        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }
    
    return ObjResult;
}


bool ExpandoViewOfDispatchEx::IsOwnedBy(Object *pObj)
{   
    // Check to see if the specified object is this.
    if (pObj == this)
        return true;
    
    // Check to see if the current owner is the same object as the one specified.
    if (m_pDispExObj == pObj)
        return true;
    
    // The specified object is not the RCW that owns the current ExpandoViewOfDispatchEx.
    return false;
}


IDispatchEx *ExpandoViewOfDispatchEx::GetDispatchEx()
{
    IUnknown *pUnk = NULL;
    IDispatchEx *pDispEx = NULL;

    try
    {
        pUnk = (IUnknown *)FROMINTPTR(Marshal::GetIUnknownForObject(m_pDispExObj));
        IfFailThrow(pUnk->QueryInterface(IID_IDispatchEx, (void**)&pDispEx));
    }
    __finally
    {
        if (pUnk)
            pUnk->Release();
    }

    return pDispEx;
}


IUnknown *ExpandoViewOfDispatchEx::GetUnknown()
{
    return (IUnknown *)FROMINTPTR(Marshal::GetIUnknownForObject(m_pDispExObj));
}


bool ExpandoViewOfDispatchEx::SynchWithNativeView()
{
    // Start by requesting the first DISPID.
    DISPID DispID = DISPID_STARTENUM;
    
    // Fill in a hashtable of all the current members.
    Hashtable *pCurrentMemberMap = new Hashtable();
    
    // The three counts required to determine if the managed view has changed.
    int NumMembersAtStart = m_pNameToMethodMap->Count + m_pNameToPropertyMap->Count;
    int NumMembersAfterAddPhase;
    int NumMembersAfterRemovePhase;

    // The native IDispatchEx interface pointer.
    IDispatchEx *pDispEx = NULL;
    
    // This needs to be synchronized to ensure that only one thread plays around
    // with the hashtables at any given time.
    Monitor::Enter(this);
    

    try
    {
        //
        // Retrieve the IEnumVARIANT pointer.
        //

        pDispEx = GetDispatchEx();

        
        //
        // Phase 1: Go through the members on the IDispatchEx and add any new ones to the ExpandoView.
        //
    
#ifdef DISPLAY_DEBUG_INFO
        Console::WriteLine(L"Starting phase one of SynchWithNativeView");
        Console::Write(L"Num methods = ");
        Console::Write(m_pNameToMethodMap->Count);
        Console::Write(L" Num properties = ");
        Console::WriteLine(m_pNameToPropertyMap->Count);
#endif
    
        // Go through all the members in the IDispatchEx and add any new ones.
        while (pDispEx->GetNextDispID(fdexEnumDefault | fdexEnumAll, DispID, &DispID) == S_OK)
        {
            BSTR bstrName;
        
#ifdef DISPLAY_DEBUG_INFO
            Console::Write(L"Found member with dispid #");
            Console::WriteLine(DispID);
#endif
        
            // Retrieve the name of the member.
            if (SUCCEEDED(pDispEx->GetMemberName(DispID, &bstrName)))
            {
                // Convert the BSTR to a COM+ string.
                String *pstrMemberName = Marshal::PtrToStringBSTR(reinterpret_cast<int>(bstrName));
            
                // Free the now useless BSTR.
                SysFreeString(bstrName);
            
#ifdef DISPLAY_DEBUG_INFO
                Console::Write(L"Member's name is");
                Console::WriteLine(pstrMemberName);
#endif
            
                // Add the native member to our hash tables.
                MemberInfo *pMember = AddNativeMember(DispID, pstrMemberName);

                // Add the member to the current members map.
                pCurrentMemberMap->Item[__box(DispID)] = pMember;
            }
        }
    
        // Remember the number of members after the add phase has finished.
        NumMembersAfterAddPhase = m_pNameToMethodMap->Count + m_pNameToPropertyMap->Count;
    
    
        //
        // Phase 2: Handle removed members by going through the members in the ExpandoView and removing the
        //          ones that were removed from the IDispatchEx.
        //
    
#ifdef DISPLAY_DEBUG_INFO
        Console::WriteLine(L"Starting phase two of SynchWithNativeView");
        Console::Write(L"Num methods = ");
        Console::Write(m_pNameToMethodMap->Count);
        Console::Write(L" Num properties = ");
        Console::WriteLine(m_pNameToPropertyMap->Count);
#endif
    
        // Start by removing the properties that have been removed from the IDispatchEx.
        IDictionaryEnumerator *pMemberEnumerator = m_pNameToPropertyMap->GetEnumerator();
        ArrayList *pMembersToRemoveList = new ArrayList();
        while (pMemberEnumerator->MoveNext())
        {
            if (!pCurrentMemberMap->Item[__box((dynamic_cast<DispatchExPropertyInfo*>(pMemberEnumerator->Value))->DispID)])
                pMembersToRemoveList->Add(pMemberEnumerator->Key);
        }

        int cMembersToRemove = pMembersToRemoveList->Count;
        if (cMembersToRemove > 0)
        {
            for (int i = 0; i < cMembersToRemove; i++)
                m_pNameToPropertyMap->Remove(pMembersToRemoveList->Item[i]);
        }

        // Start by removing the methods that have been removed from the IDispatchEx.
        pMemberEnumerator = m_pNameToMethodMap->GetEnumerator();
        pMembersToRemoveList->Clear();
        while (pMemberEnumerator->MoveNext())
        {
            if (!pCurrentMemberMap->Item[__box((dynamic_cast<DispatchExMethodInfo*>(pMemberEnumerator->Value))->DispID)])
                pMembersToRemoveList->Add(pMemberEnumerator->Key);
        }
    
        cMembersToRemove = pMembersToRemoveList->Count;
        if (cMembersToRemove > 0)
        {
            for (int i = 0; i < cMembersToRemove; i++)
                m_pNameToMethodMap->Remove(pMembersToRemoveList->Item[i]);
        }

        // Remember the number of members after the remove phase has finished.
        NumMembersAfterRemovePhase = m_pNameToMethodMap->Count + m_pNameToPropertyMap->Count;
    
        // We have finished playing around with the hashtables so we can leave the critical section.
        Monitor::Exit(this);
    
    
        //
        // Phase 3: Determine if the managed view has changed and return the result.
        //
    
#ifdef DISPLAY_DEBUG_INFO
        Console::WriteLine(L"Starting phase three of SynchWithNativeView");
        Console::Write(L"Num methods = ");
        Console::Write(m_pNameToMethodMap->Count);
        Console::Write(L" Num properties = ");
        Console::WriteLine(m_pNameToPropertyMap->Count);
#endif
    }
    __finally
    {
        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }
    
    // If the numbers are not all equal then the managed view has changed.
    return !((NumMembersAtStart == NumMembersAfterAddPhase) && (NumMembersAtStart == NumMembersAfterRemovePhase));
}

MemberInfo *ExpandoViewOfDispatchEx::AddNativeMember(int DispID, String *pstrMemberName)
{
    DWORD MemberProps = 0;
    MemberInfo *pMember = NULL;           
    IDispatchEx *pDispEx = NULL;

#ifdef DISPLAY_DEBUG_INFO
    Console::WriteLine(L"Adding native member with DispID = {0} and name = {1}", DispID, pstrMemberName->ToString());
#endif

    try
    {
        // Retrieve the IEnumVARIANT pointer.
        pDispEx = GetDispatchEx();

        // Try and get the properties of the member. This is often not implemented so
        // we need to cope with that case.
        if (FAILED(pDispEx->GetMemberProperties(DispID, grfdexPropCanAll, &MemberProps)) ||
            (MemberProps & (fdexPropCanPut | fdexPropCanGet | fdexPropCanCall)) == 0)
        {
            // The server does not support retrieving the properties of members. Since we cannot
            // determine what the member is we assume it is both a property and a normal method.
            MemberProps = fdexPropCanPut | fdexPropCanGet | fdexPropCanCall;
        }
    
    
        // Handle members that are properties.
        if (MemberProps & (fdexPropCanPut | fdexPropCanGet))
        {
#ifdef DISPLAY_DEBUG_INFO
            Console::WriteLine(L"Member is a property");
#endif
        
            // The member is a property so look it up in the property name to property hashtable.
            pMember = dynamic_cast<MemberInfo*>(m_pNameToPropertyMap->Item[pstrMemberName]);
            if (!pMember)
            {
#ifdef DISPLAY_DEBUG_INFO
                Console::WriteLine(L"This is a new member which is being added");
#endif
            
                // The property is not in the map so we need to create a new property info
                // to represent it.
                pMember = new DispatchExPropertyInfo(DispID, pstrMemberName, this);
            
                // Add the set method to the property if its value can be set.
                if (MemberProps & fdexPropCanPut)
                {
#ifdef DISPLAY_DEBUG_INFO
                    Console::WriteLine(L"Member has a property put");
#endif
                
                    // Create the set method that will be added to the property.
                    DispatchExMethodInfo *pMethod = new DispatchExMethodInfo(
                        DispID,
                        pstrMemberName,
                        MethodType_SetMethod,
                        this);
                
                    (dynamic_cast<DispatchExPropertyInfo*>(pMember))->SetSetMethod(pMethod);
                }
            
                // Add a get method to the property if its value can be retrieved.
                if (MemberProps & fdexPropCanGet)
                {
#ifdef DISPLAY_DEBUG_INFO
                    Console::WriteLine(L"Member has a property get");
#endif
                
                    // Create the get method that will be added to the property.
                    DispatchExMethodInfo *pMethod = new DispatchExMethodInfo(
                        DispID,
                        pstrMemberName,
                        MethodType_GetMethod,
                        this);
                
                    (dynamic_cast<DispatchExPropertyInfo*>(pMember))->SetGetMethod(pMethod);
                }
            
                // Add the property to the name to property map.
                m_pNameToPropertyMap->Item[pstrMemberName] = pMember;
            }
        }
    
    
        // Handle members that are methods.
        if (MemberProps & fdexPropCanCall)
        {
#ifdef DISPLAY_DEBUG_INFO
            Console::WriteLine(L"Member is a method");
#endif
        
            // The member is a method so look it up in the method name to method hashtable.
            pMember = dynamic_cast<MemberInfo*>(m_pNameToMethodMap->Item[pstrMemberName]);
        
            // If the method is not in the hashtable we need to add it.
            if (!pMember)
            {
#ifdef DISPLAY_DEBUG_INFO
                Console::WriteLine(L"This is a new member which is being added");
#endif
            
                // Create a new method info and add it to the name to method map.
                pMember = new DispatchExMethodInfo(DispID, pstrMemberName, MethodType_NormalMethod, this);
                m_pNameToMethodMap->Item[pstrMemberName] = pMember;
            }
        }   
    }
    __finally
    {
        // Release the IDispatchEx IUnknown.
        if (pDispEx)
            pDispEx->Release();
    }

    // Return the newly added member.
    return pMember;
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\expandoviewofdispatchex.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ExpandoViewOfDispatchEx.cpp
//
// This file provides the definition of the  ExpandoViewOfDispatchEx class.
// This class is used to expose an IDispatchEx as an IExpando.
//
//*****************************************************************************

#ifndef _EXPANDOVIEWOFDISPATCHEX_H
#define _EXPANDOVIEWOFDISPATCHEX_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"
#include <dispex.h>

using namespace System::Reflection;
using namespace System::Collections;
using namespace System::Globalization;
using namespace System::Runtime::InteropServices::Expando;
using namespace System::Runtime::InteropServices;

[Serializable]
__gc private class ExpandoViewOfDispatchEx : public ICustomAdapter, public IExpando
{
public:
    // Constructor.
    ExpandoViewOfDispatchEx(Object *pDispExObj);
        
    // The ICustomAdapter method.
    Object *GetUnderlyingObject()
    {
        return m_pDispExObj;
    }

    // The IReflect methods.
    MethodInfo *GetMethod(String *pstrName, BindingFlags BindingAttr, Binder *pBinder,  Type* apTypes __gc [], ParameterModifier aModifiers __gc []);
    MethodInfo *GetMethod(String *pstrName, BindingFlags BindingAttr);
    MethodInfo* GetMethods(BindingFlags BindingAttr) __gc [];
    FieldInfo *GetField(String *name, BindingFlags BindingAttr);
    FieldInfo* GetFields(BindingFlags BindingAttr) __gc [];
    PropertyInfo *GetProperty(String *pstrName, BindingFlags BindingAttr);
    PropertyInfo *GetProperty(String *pstrName, BindingFlags BindingAttr, Binder *pBinder, Type* pReturnType, Type* apTypes __gc [], ParameterModifier aModifiers __gc []);
    PropertyInfo* GetProperties(BindingFlags BindingAttr) __gc [];
    MemberInfo* GetMember(String *pstrName, BindingFlags BindingAttr) __gc [];
    MemberInfo* GetMembers(BindingFlags BindingAttr) __gc [];
    Object* InvokeMember(String *pstrName, BindingFlags InvokeAttr, Binder *pBinder, Object *pTarget, Object* aArgs __gc [], ParameterModifier aModifiers __gc [], CultureInfo *pCultureInfo, String* astrNamedParameters __gc []);
    
    __property Type * get_UnderlyingSystemType()
    {
        return __typeof(Object);
    }
    
    // The IExpando methods.
    FieldInfo *AddField(String *pstrName);
    PropertyInfo *AddProperty(String *pstrName);
    MethodInfo *AddMethod(String *pstrName, Delegate *pMethod);
    void RemoveMember(MemberInfo *pMember);
    
    // Helper method to convert invoke binding flags to IDispatch::Invoke flags.
    int InvokeAttrsToDispatchFlags(BindingFlags InvokeAttr);

    // This method does the actual invoke call on IDispatchEx.
    Object *DispExInvoke(String *pstrMemberName, DISPID MemberDispID, int Flags, Binder *pBinder, Object* aArgs __gc [], ParameterModifier aModifiers __gc [], CultureInfo *pCultureInfo, String* astrNamedParameters __gc []);
    
    // The RCW that owns the ExpandoViewOfDispatchEx.
    bool IsOwnedBy(Object *pObj);
    
private:
    // Helper method to retrieve an AddRef'ed IDispatchEx pointer.
    IDispatchEx *GetDispatchEx();
    IUnknown *GetUnknown();

    // This methods synchronizes the members of the ExpandoViewOfDispatchEx with the native view.
    // It will return true if the managed view has changed and false otherwise.
    bool SynchWithNativeView();
    
    // This method adds a native member to the hashtable of members.
    MemberInfo *AddNativeMember(int DispID, String *pstrMemberName);

    Object *m_pDispExObj;
    Hashtable *m_pNameToMethodMap;
    Hashtable *m_pNameToPropertyMap;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _EXPANDOVIEWOFDISPATCHEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\expandotodispatchexmarshaler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ExpandoToDispatchExMarshaler.cpp
//
// This file provides the definition of the ExpandoToDispatchExMarshaler
// class. This class is used to marshal between IDispatchEx and IExpando.
//
//*****************************************************************************

#ifndef _EXPANDOTODISPATCHEXMARSHALER_H
#define _EXPANDOTODISPATCHEXMARSHALER_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System;
using namespace System::Runtime::InteropServices;
using namespace System::Collections;

__value private enum ExpandoToDispatchExMarshalerType
{
    FullExpandoMarshaler,
    ReflectOnlyMarshaler
};

__gc public class ExpandoToDispatchExMarshaler : public ICustomMarshaler
{
public:
    /*=========================================================================
    ** This method marshals a pointer to native data into a managed object.
    =========================================================================*/
    Object *MarshalNativeToManaged(IntPtr pNativeData);

    /*=========================================================================
    ** This method marshals a managed object into a pointer to native data.
    =========================================================================*/
    IntPtr MarshalManagedToNative(Object *pManagedObj);

    /*=========================================================================
    ** This method is called to allow the marshaler to clean up the native
    ** data.
    =========================================================================*/
    void CleanUpNativeData(IntPtr pNativeData);

    /*=========================================================================
    ** This method is called to allow the marshaler to clean up the managed
    ** data.
    =========================================================================*/
    void CleanUpManagedData(Object *pManagedObj);

    /*=========================================================================
    ** This method is called to retrieve the size of the native data.
    =========================================================================*/
    int GetNativeDataSize();

    /*=========================================================================
    ** This method is called to retrieve an instance of the custom marshaler.
    ** The ExpandoToDispatchExMarshaler only has one instance of the
    ** marshaler which is reused.
    =========================================================================*/
    static ICustomMarshaler *GetInstance(String *pstrCookie);

private:
    /*=========================================================================
    ** This class is not made to be created by anyone other then GetInstance().
    =========================================================================*/
    ExpandoToDispatchExMarshaler(ExpandoToDispatchExMarshalerType MarshalerType);

    /*=========================================================================
    ** The type of the marshaler.
    =========================================================================*/
    ExpandoToDispatchExMarshalerType m_MarshalerType;

    /*=========================================================================
    ** One instance of each type of marshaler.
    =========================================================================*/
    static ExpandoToDispatchExMarshaler *m_pExpandoMarshaler = NULL;
    static ExpandoToDispatchExMarshaler *m_pReflectMarshaler = NULL;

    /*=========================================================================
    ** One instance of each type of marshaler.
    =========================================================================*/
    static ExpandoToDispatchExMarshaler *m_pMarshaler = NULL;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _EXPANDOTODISPATCHEXMARSHALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ExpandoToDispatchExMarshaler.cpp
//
// This file provides the definition of the ExpandoToDispatchExMarshaler
// class. This class is used to marshal between IDispatchEx and IExpando.
//
//*****************************************************************************

#ifndef _RESOURCE_H
#define _RESOURCE_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System;
using namespace System::Resources;
using namespace System::Reflection;

__gc private class Resource
{
public:   
    /*=========================================================================
    ** This formats a resource string with no substitution.
    =========================================================================*/
    static String *FormatString(String *key)
    {
        return(GetString(key));
    }
    
    /*=========================================================================
    ** This formats a resource string with one arg substitution.
    =========================================================================*/
    static String *FormatString(String *key, Object *a1)
    {
        return(String::Format(GetString(key), a1));
    }
    
    /*=========================================================================
    ** This formats a resource string with two arg substitutions.
    =========================================================================*/
    static String *FormatString(String *key, Object *a1, Object *a2)
    {
        return(String::Format(GetString(key), a1, a2));
    }
    
    /*=========================================================================
    ** This formats a resource string with three arg substitutions.
    =========================================================================*/
    static String *FormatString(String *key, Object *a1, Object *a2, Object *a3)
    {
        return(String::Format(GetString(key), a1, a2, a3));
    }
    
    /*=========================================================================
    ** This formats a resource string with n arg substitutions.
    =========================================================================*/
    static String *FormatString(String *key, Object* a[])
    {
        return(String::Format(GetString(key), a));
    }

private:
    /*=========================================================================
    ** Private method to retrieve the string.
    =========================================================================*/
    static String *GetString(String *key)
    {
        String *s = m_pResourceMgr->GetString(key, NULL);
        if(s == NULL) 
        {
            String *strMsg = String::Format(S"FATAL: Resource string for '{0}' is null", key);
            throw new ApplicationException(strMsg);
        }
        return s;
    }

    /*=========================================================================
    ** The resource manager.
    =========================================================================*/
    static ResourceManager *m_pResourceMgr = new ResourceManager("CustomMarshalers", Assembly::GetAssembly(__typeof(Resource)));
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\makefile.inc ===
#
# Makefile include stuff for ISymWrapper

BASE_OPT=-base:@$(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\coffbase.txt,$(MINORCOMP)

# If one of these commands fails, notice it.
!CMDSWITCHES -I

OBJ_FILES = $(O)\CustomMarshalers.obj $(O)\ExpandoToDispatchExMarshaler.obj $(O)\ExpandoViewOfDispatchEx.obj $(O)\EnumeratorToEnumVariantMarshaler.obj $(O)\EnumeratorViewOfEnumVariant.obj $(O)\EnumVariantViewOfEnumerator.obj $(O)\TypeToTypeInfoMarshaler.obj $(O)\EnumerableToDispatchMarshaler.obj $(O)\EnumerableViewOfDispatch.obj

!if "$(OS)" == "Windows_NT"
SYSTEMDIR=$(WINDIR)\system32
!else
SYSTEMDIR=$(WINDIR)\system
!endif

MSCOREE_TARGET=$(SYSTEMDIR)\mscoree.dll
MSCOREE_TARGET_LIB = $(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscoree.lib

!IF "$(DDKBUILDENV)" == "checked" || "$(DDKBUILDENV)" == "fastchecked"
C_COMP_FLAGS = /nologo /d1PrivateNativeTypes /GX /Bx$(MANAGED_VCDIR)\c1xx.dll /B2$(MANAGED_VCDIR)\c2.dll /c /Zi  /I $(SDK_INC_PATH) /I $(CRT_INC_PATH) /I $(CORBASE)\src\inc\version
C_LINK_FLAGS = /SAFESEH /nologo /nodefaultlib /DLL /NOENTRY /DEBUG $(BASE_OPT)
!ELSE
C_COMP_FLAGS = /nologo /d1PrivateNativeTypes /GX /Bx$(MANAGED_VCDIR)\c1xx.dll /B2$(MANAGED_VCDIR)\c2.dll /c /I $(SDK_INC_PATH) /I $(CRT_INC_PATH) /I $(CORBASE)\src\inc\version
C_LINK_FLAGS = /SAFESEH /nologo /nodefaultlib /DLL /NOENTRY /DEBUG $(BASE_OPT)
!ENDIF

CustomMarshalers.res: CustomMarshalers.rc ..\..\inc\Version\__official__.ver
    set _oldinclude=$(include)
    set include=$(INCPATHRC)
    $(RC_COMPILER) -r -fo $(@R).tmp $(CDEFINERC) CustomMarshalers.rc
    set include=$(_oldinclude)
    set _oldinclude=
    $(MANAGED_VCDIR)\cvtres -nologo -machine:IX86 -readonly -out:$@ $(@R).tmp
    erase $(@R).tmp

$(TARGETPATH)\CustomMarshalers.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt $(TARGETPATH)\CustomMarshalers.resources

$(O)\CustomMarshalers.obj: $(MSCOREE_TARGET) CustomMarshalers.cpp
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\CustomMarshalers.obj CustomMarshalers.cpp

$(O)\ExpandoToDispatchExMarshaler.obj: $(MSCOREE_TARGET) ExpandoToDispatchExMarshaler.cpp ExpandoToDispatchExMarshaler.h ExpandoViewOfDispatchEx.h Resource.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\ExpandoToDispatchExMarshaler.obj ExpandoToDispatchExMarshaler.cpp

$(O)\ExpandoViewOfDispatchEx.obj: $(MSCOREE_TARGET) ExpandoViewOfDispatchEx.cpp ExpandoViewOfDispatchEx.h DispatchExMethodInfo.h DispatchExPropertyInfo.h Resource.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\ExpandoViewOfDispatchEx.obj ExpandoViewOfDispatchEx.cpp

$(O)\EnumeratorToEnumVariantMarshaler.obj: $(MSCOREE_TARGET) EnumeratorToEnumVariantMarshaler.cpp EnumeratorToEnumVariantMarshaler.h EnumeratorViewOfEnumVariant.h EnumVariantViewOfEnumerator.h Resource.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\EnumeratorToEnumVariantMarshaler.obj EnumeratorToEnumVariantMarshaler.cpp

$(O)\EnumeratorViewOfEnumVariant.obj: $(MSCOREE_TARGET) EnumeratorViewOfEnumVariant.cpp EnumeratorViewOfEnumVariant.h Resource.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\EnumeratorViewOfEnumVariant.obj EnumeratorViewOfEnumVariant.cpp

$(O)\EnumVariantViewOfEnumerator.obj: $(MSCOREE_TARGET) EnumVariantViewOfEnumerator.cpp EnumVariantViewOfEnumerator.h Resource.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\EnumVariantViewOfEnumerator.obj EnumVariantViewOfEnumerator.cpp

$(O)\TypeToTypeInfoMarshaler.obj: $(MSCOREE_TARGET) TypeToTypeInfoMarshaler.cpp TypeToTypeInfoMarshaler.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\TypeToTypeInfoMarshaler.obj TypeToTypeInfoMarshaler.cpp

$(O)\EnumerableToDispatchMarshaler.obj: $(MSCOREE_TARGET) EnumerableToDispatchMarshaler.cpp EnumerableToDispatchMarshaler.h EnumerableViewOfDispatch.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\EnumerableToDispatchMarshaler.obj EnumerableToDispatchMarshaler.cpp

$(O)\EnumerableViewOfDispatch.obj: $(MSCOREE_TARGET) EnumerableViewOfDispatch.cpp EnumerableViewOfDispatch.h CustomMarshalersDefines.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Fo$(O)\EnumerableViewOfDispatch.obj EnumerableViewOfDispatch.cpp

$(TARGETNAME): $(MSCOREE_TARGET) $(OBJ_FILES) $(TARGETPATH)\CustomMarshalers.resources CustomMarshalers.res
        $(MANAGED_VCDIR)\link $(C_LINK_FLAGS) $(OBJ_FILES) .\CustomMarshalers.res /ASSEMBLYRESOURCE:$(TARGETPATH)\CustomMarshalers.resources /OUT:$(TARGETPATH)\CustomMarshalers.dll $(SDK_LIB_PATH)\msvcrt$(DCRT).lib $(SDK_LIB_PATH)\oleaut32.lib $(MSCOREE_TARGET_LIB)

        set COPYCMD=/Y

        gacutil -i $(TARGETNAME)

        sn -T $(TARGETPATH)\CustomMarshalers.dll > $(O)\pubkey.tmp
        sn -e $(TARGETPATH)\CustomMarshalers.dll $(O)\pubkey.snk
        -perl $(CORENV)\bin\genpubpol.pl pubkey.snk CustomMarshalers $(O)\pubkey.tmp $(O)\al.rsp $(O)\placepol.bat
        $(CORENV)\Bin\devlkg\al.exe /delaysign+ /keyf:$(O)\pubkey.snk @$(O)\al.rsp
        $(O)\placepol.bat

# Copy it to the COM+ target directory.
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\CustomMarshalers.dll $(TARGETCOMPLUS)

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\CustomMarshalers.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\typetotypeinfomarshaler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// TypeToTypeInfoMarshaler.cpp
//
// This file provides the implemention of the TypeToTypeInfoMarshaler
// class. This class is used to marshal between Type and ITypeInfo.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "TypeToTypeInfoMarshaler.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()


TypeToTypeInfoMarshaler::TypeToTypeInfoMarshaler()
{
}


Object *TypeToTypeInfoMarshaler::MarshalNativeToManaged(IntPtr pNativeData)
{
    // Validate the arguments.
    if (pNativeData == TOINTPTR(0))
        throw new ArgumentNullException(L"pNativeData");
    
    // Use the Marshal helper to convert the ITypeInfo into a type.
    return Marshal::GetTypeForITypeInfo(pNativeData);
}

#pragma warning( disable: 4669 ) // 'reinterpret_cast' : unsafe conversion: 'System::Type' is a managed type object

IntPtr TypeToTypeInfoMarshaler::MarshalManagedToNative(Object *pManagedObj)
{
    // Validate the arguments.
    if (!pManagedObj)
        throw new ArgumentNullException(L"pManagedObj");
    
    // Use the Marshal helper to convert the Type into an ITypeInfo.
    return Marshal::GetITypeInfoForType(reinterpret_cast<Type*>(pManagedObj));
}


void TypeToTypeInfoMarshaler::CleanUpNativeData(IntPtr pNativeData)
{
    ((IUnknown*)FROMINTPTR(pNativeData))->Release();
}


void TypeToTypeInfoMarshaler::CleanUpManagedData(Object *pManagedObj)
{
}


int TypeToTypeInfoMarshaler::GetNativeDataSize()
{
    // Return -1 to indicate the managed type this marshaler handles is not a value type.
    return -1;
}


ICustomMarshaler *TypeToTypeInfoMarshaler::GetInstance(String *pstrCookie)
{
    if (!m_pMarshaler)
        m_pMarshaler = new TypeToTypeInfoMarshaler();
    return m_pMarshaler;
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\expandotodispatchexmarshaler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ExpandoToDispatchExMarshaler.cpp
//
// This file provides the implemention of the ExpandoToDispatchExMarshaler
// class. This class is used to marshal between IDispatchEx and IExpando.
//
//*****************************************************************************

#using  <mscorlib.dll>
#include "ExpandoToDispatchExMarshaler.h"
#include "ExpandoViewOfDispatchEx.h"
#include "Resource.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()


#define CACHE_MANAGED_VIEWS


ExpandoToDispatchExMarshaler::ExpandoToDispatchExMarshaler(ExpandoToDispatchExMarshalerType MarshalerType)
: m_MarshalerType(MarshalerType)
{
}


Object *ExpandoToDispatchExMarshaler::MarshalNativeToManaged(IntPtr pNativeData)
{
    ExpandoViewOfDispatchEx *pMngView = NULL;

    // Validate the arguments.
    if (pNativeData == TOINTPTR(0))
        throw new ArgumentNullException(L"pNativeData");

    // Retrieve the __ComObject that wraps the IUnknown *.
    Object *pComObj = Marshal::GetObjectForIUnknown(pNativeData);

    // If we are dealing with a managed object, then cast it directly.
    if (!pComObj->GetType()->get_IsCOMObject())
    {
        if (m_MarshalerType == FullExpandoMarshaler)
            return dynamic_cast<IExpando *>(pComObj);
        else
            return dynamic_cast<IReflect *>(pComObj);
    }

    // Retrieve the type of the managed view.
    Object *pKey = __typeof(ExpandoViewOfDispatchEx);

    // Check to see if the __ComObject already has the managed view cached.
    pMngView = dynamic_cast<ExpandoViewOfDispatchEx *>(Marshal::GetComObjectData(pComObj, pKey));

    // If it doesn't have a cached managed view, then allocate one.
    if (!pMngView)
    {
        pMngView = new ExpandoViewOfDispatchEx(pComObj);
        if (!Marshal::SetComObjectData(pComObj, pKey, pMngView))
        {
            // Someone beat us to adding the managed view so fetch it again.
            pMngView = dynamic_cast<ExpandoViewOfDispatchEx *>(Marshal::GetComObjectData(pComObj, pKey));
        }
    }

    return pMngView;
}


IntPtr ExpandoToDispatchExMarshaler::MarshalManagedToNative(Object *pManagedObj)
{
    IDispatchEx *pDispEx = NULL;
    HRESULT hr = S_OK;

    // Validate the arguments.
    if (!pManagedObj)
        throw new ArgumentNullException(L"pManagedObj");

    // Retrieve the IUnknown associated with this object.
    IUnknown *pUnk = (IUnknown *) FROMINTPTR(Marshal::GetIUnknownForObject(pManagedObj));

    // QI for IDispatchEx.
    hr = pUnk->QueryInterface(IID_IDispatchEx, (void**)&pDispEx);

    // Release the now useless IUnknown.
    pUnk->Release();

    // Check to see if the QI for IDispatchEx succeeded.
    if (FAILED(hr))
        Marshal::ThrowExceptionForHR(hr);

    return TOINTPTR(pDispEx);
}


void ExpandoToDispatchExMarshaler::CleanUpNativeData(IntPtr pNativeData)
{
    ((IUnknown*)FROMINTPTR(pNativeData))->Release();
}


void ExpandoToDispatchExMarshaler::CleanUpManagedData(Object *pManagedObj)
{
}


int ExpandoToDispatchExMarshaler::GetNativeDataSize()
{
    // Return -1 to indicate the managed type this marshaler handles is not a value type.
    return -1;
}


ICustomMarshaler *ExpandoToDispatchExMarshaler::GetInstance(String *pstrCookie)
{
    if (pstrCookie->Equals(L"IReflect"))
    {
        if (!m_pReflectMarshaler)
            m_pReflectMarshaler = new ExpandoToDispatchExMarshaler(ReflectOnlyMarshaler);
        return m_pReflectMarshaler;
    }
    else if (pstrCookie->Equals(L"IExpando"))
    {
        if (!m_pExpandoMarshaler)
            m_pExpandoMarshaler = new ExpandoToDispatchExMarshaler(FullExpandoMarshaler);
        return m_pExpandoMarshaler;
    }
    else
    {
        throw new ArgumentException(Resource::FormatString(L"Arg_InvalidCookieString"), L"pstrCookie");
    }
}

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "CustomMarshalers.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Custom Marshalers\0"
#define VER_ORIGFILENAME_STR    "CustomMarshalers.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\custommarshalers\typetotypeinfomarshaler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// TypeToTypeInfoMarshaler.cpp
//
// This file provides the definition of the TypeToTypeInfoMarshaler
// class. This class is used to marshal between Type and ITypeInfo.
//
//*****************************************************************************

#ifndef _TYPETOTYPEINFOMARSHALER_H
#define _TYPETOTYPEINFOMARSHALER_H

#include "CustomMarshalersNameSpaceDef.h"

OPEN_CUSTOM_MARSHALERS_NAMESPACE()

#include "CustomMarshalersDefines.h"

using namespace System::Runtime::InteropServices;

__gc public class TypeToTypeInfoMarshaler : public ICustomMarshaler
{
public:
    /*=========================================================================
    ** This method marshals a pointer to native data into a managed object.
    =========================================================================*/
	Object *MarshalNativeToManaged(IntPtr pNativeData);

    /*=========================================================================
    ** This method marshals a managed object into a pointer to native data.
    =========================================================================*/
	IntPtr MarshalManagedToNative(Object *pManagedObj);

	/*=========================================================================
	** This method is called to allow the marshaler to clean up the native
	** data.
	=========================================================================*/
	void CleanUpNativeData(IntPtr pNativeData);

	/*=========================================================================
	** This method is called to allow the marshaler to clean up the managed
	** data.
	=========================================================================*/
	void CleanUpManagedData(Object *pManagedObj);

    /*=========================================================================
    ** This method is called to retrieve the size of the native data.
    =========================================================================*/
	int GetNativeDataSize();

    /*=========================================================================
    ** This method is called to retrieve an instance of the custom marshaler.
	** The ExpandoToDispatchExMarshaler only has one instance of the
	** marshaler which is reused.
    =========================================================================*/
	static ICustomMarshaler *GetInstance(String *pstrCookie);

private:
    /*=========================================================================
    ** This class is not made to be created by anyone other then GetInstance().
    =========================================================================*/
	TypeToTypeInfoMarshaler();

    /*=========================================================================
    ** One and only instance of the marshaler.
    =========================================================================*/
	static TypeToTypeInfoMarshaler *m_pMarshaler = NULL;
};

CLOSE_CUSTOM_MARSHALERS_NAMESPACE()

#endif  _TYPETOTYPEINFOMARSHALER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\admin.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//


namespace System.EnterpriseServices.Admin
{

    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    using System.Security;

    // Enums:
	[Serializable]
    internal enum ApplicationInstallOptions
    {
        NoUsers               = 0,
        Users                 = 1,
        ForceOverwriteOfFiles = 2
    }

	[Serializable]
    internal enum ApplicationExportOptions
    {
        NoUsers               = 0,
        Users                 = 1,
        ApplicationProxy      = 2,
        ForceOverwriteOfFiles = 4
    }

	[Serializable]
    internal enum AuthenticationCapabilitiesOptions
    {
        None            = 0,
        StaticCloaking  = 32,
        DynamicCloaking = 64,
        SecureReference = 2
    }

	[Serializable]
    internal enum ServiceStatusOptions    
    {
        Stopped         = 0,
        StartPending    = 1,
        StopPending     = 2,
        Running         = 3,
        ContinuePending = 4,
        PausePending    = 5,
        Paused          = 6,
        UnknownState    = 7
    }

	[Serializable]
    internal enum FileFlags
    {
        Loadable = 1,
        COM = 2,
        ContainsPS = 4,
        ContainsComp = 8,
        ContainsTLB = 16,
        SelfReg = 32,
        SelfUnReg = 64,
        UnloadableDLL = 128,
        DoesNotExists = 256,
        AlreadyInstalled = 512,
        BadTLB = 1024,
        GetClassObjFailed = 2048,
        ClassNotAvailable = 4096,
        Registrar = 8192,
        NoRegistrar = 16384,
        DLLRegsvrFailed = 32768,
        RegTLBFailed = 65536,
        RegistrarFailed = 131072,
        Error = 262144
    }

	[Serializable]
    internal enum ComponentFlags
    {
        TypeInfoFound = 1,
        COMPlusPropertiesFound = 2,
        ProxyFound = 4,
        InterfacesFound = 8,
        AlreadyInstalled = 16,
        NotInApplication = 32
    }

    [SuppressUnmanagedCodeSecurity]
    [ComImport]
    [Guid("6EB22870-8A19-11D0-81B6-00A0C9231C29")]
    internal interface IMtsCatalog
    {
        [DispId(0x00000001)]
        [return : MarshalAs(UnmanagedType.Interface)        ]
        Object GetCollection([In, MarshalAs(UnmanagedType.BStr)] 
                             String bstrCollName);

        [DispId(0x00000002)]
        [return : MarshalAs(UnmanagedType.Interface)        ]
        Object Connect([In, MarshalAs(UnmanagedType.BStr)] String connectStr);

        [DispId(0x00000003)]
        int MajorVersion();

        [DispId(0x00000004)]
        int MinorVersion();
    }

    [ComImport]
    [Guid("6EB22873-8A19-11D0-81B6-00A0C9231C29")]
    internal interface IComponentUtil
    {
        [DispId(0x00000001)]
        void InstallComponent([In, MarshalAs(UnmanagedType.BStr)] String bstrDLLFile, 
                              [In, MarshalAs(UnmanagedType.BStr)] String bstrTypelibFile, 
                              [In, MarshalAs(UnmanagedType.BStr)] String bstrProxyStubDLLFile);
        [DispId(0x00000002)]
        void  ImportComponent([In, MarshalAs(UnmanagedType.BStr)] String bstrCLSID);

        [DispId(0x00000003)]
        void ImportComponentByName([In, MarshalAs(UnmanagedType.BStr)] String bstrProgID);
        [DispId(0x00000004)]
        void GetCLSIDs([In, MarshalAs(UnmanagedType.BStr)] String bstrDLLFile, 
                       [In, MarshalAs(UnmanagedType.BStr)] String bstrTypelibFile, 
                       [Out, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] out Object[] CLSIDS);
    }
    
    [ComImport]
    [Guid("6EB22876-8A19-11D0-81B6-00A0C9231C29")]
    internal interface IRoleAssociationUtil
    {
        [DispId(0x00000001)]
        void AssociateRole([In, MarshalAs(UnmanagedType.BStr)] String bstrRoleID);
        [DispId(0x00000002)]
        void AssociateRoleByName([In, MarshalAs(UnmanagedType.BStr)] String bstrRoleName);
    }

    [SuppressUnmanagedCodeSecurity]
    [ComImport]
    [Guid("DD662187-DFC2-11D1-A2CF-00805FC79235")]
    internal interface ICatalog
    {
        [DispId(0x00000001)]
        [return:MarshalAs(UnmanagedType.Interface)]
        Object GetCollection([In, MarshalAs(UnmanagedType.BStr)] 
                             String bstrCollName);

        [DispId(0x00000002)]
        [return:MarshalAs(UnmanagedType.Interface)]
        Object Connect([In, MarshalAs(UnmanagedType.BStr)] String connectStr);

        [DispId(0x00000003)]
        int MajorVersion();

        [DispId(0x00000004)]
        int MinorVersion();

        [DispId(0x00000005)]
        [return:MarshalAs(UnmanagedType.Interface)]
        Object GetCollectionByQuery([In, MarshalAs(UnmanagedType.BStr)] 
                                    String collName,
                                    [In, MarshalAs(UnmanagedType.SafeArray)] 
                                    ref Object[] aQuery);

        [DispId(0x00000006)]
        void ImportComponent([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
                             [In, MarshalAs(UnmanagedType.BStr)] String bstrCLSIDOrProgId);

        [DispId(0x00000007)]
        void InstallComponent([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
                              [In, MarshalAs(UnmanagedType.BStr)] String bstrDLL, 
                              [In, MarshalAs(UnmanagedType.BStr)] String bstrTLB, 
                              [In, MarshalAs(UnmanagedType.BStr)] String bstrPSDLL);

        [DispId(0x00000008)]
        void ShutdownApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName);

        [DispId(0x00000009)]
        void ExportApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
                                  [In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationFile, 
                                  [In] int lOptions);

        [DispId(0x0000000a)]
        void InstallApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationFile, 
                                [In, MarshalAs(UnmanagedType.BStr)] String bstrDestinationDirectory, 
                                [In] int lOptions, 
                                [In, MarshalAs(UnmanagedType.BStr)] String bstrUserId, 
                                [In, MarshalAs(UnmanagedType.BStr)] String bstrPassword, 
                                [In, MarshalAs(UnmanagedType.BStr)] String bstrRSN);
        
        [DispId(0x0000000b)]
        void StopRouter();

        [DispId(0x0000000c)]
        void RefreshRouter();

        [DispId(0x0000000d)]
        void StartRouter();

        [DispId(0x0000000e)]
        void Reserved1();

        [DispId(0x0000000f)]
        void Reserved2();

        [DispId(0x00000010)]
        void InstallMultipleComponents([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
                                       [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] fileNames,
                                       [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] CLSIDS);
        
        [DispId(0x00000011)]
        void GetMultipleComponentsInfo([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
                                       [In] Object varFileNames, 
                                       [Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varCLSIDS, 
                                       [Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varClassNames, 
                                       [Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varFileFlags, 
                                       [Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varComponentFlags);

        [DispId(0x00000012)]
        void RefreshComponents();

        [DispId(0x00000013)]
        void BackupREGDB([In, MarshalAs(UnmanagedType.BStr)] String bstrBackupFilePath);

        [DispId(0x00000014)]
        void RestoreREGDB([In, MarshalAs(UnmanagedType.BStr)] String bstrBackupFilePath);

        [DispId(0x00000015)]
        void QueryApplicationFile([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationFile, 
                                  [Out, MarshalAs(UnmanagedType.BStr)] out String bstrApplicationName,
                                  [Out, MarshalAs(UnmanagedType.BStr)] out String bstrApplicationDescription, 
                                  [Out, MarshalAs(UnmanagedType.VariantBool)] out bool bHasUsers, 
                                  [Out, MarshalAs(UnmanagedType.VariantBool)] out bool bIsProxy, 
                                  [Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varFileNames);
        
        [DispId(0x00000016)]
        void StartApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName);

        [DispId(0x00000017)]
        int ServiceCheck([In] int lService);

        [DispId(0x00000018)]
        void InstallMultipleEventClasses([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
                                         [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] fileNames,
                                         [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] CLSIDS);

        [DispId(0x00000019)]
        void InstallEventClass([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
                                  [In, MarshalAs(UnmanagedType.BStr)] String bstrDLL, 
                                  [In, MarshalAs(UnmanagedType.BStr)] String bstrTLB, 
                                  [In, MarshalAs(UnmanagedType.BStr)] String bstrPSDLL);
        [DispId(0x0000001a)]
        void GetEventClassesForIID([In] String bstrIID, 
                                   [In, Out, MarshalAs(UnmanagedType.SafeArray)] ref Object[] varCLSIDS, 
                                   [In, Out, MarshalAs(UnmanagedType.SafeArray)] ref Object[] varProgIDs, 
                                   [In, Out, MarshalAs(UnmanagedType.SafeArray)] ref Object[] varDescriptions);

    }

	[SuppressUnmanagedCodeSecurity]
	[ComImport]
	[Guid("790C6E0B-9194-4cc9-9426-A48A63185696")]
	[InterfaceType(ComInterfaceType.InterfaceIsDual)] 
	internal interface ICatalog2
	{
		[DispId(0x00000001)]
		[return:MarshalAs(UnmanagedType.Interface)]
		Object GetCollection([In, MarshalAs(UnmanagedType.BStr)] 
			String bstrCollName);

		[DispId(0x00000002)]
		[return:MarshalAs(UnmanagedType.Interface)]
		Object Connect([In, MarshalAs(UnmanagedType.BStr)] String connectStr);

		[DispId(0x00000003)]
		int MajorVersion();

		[DispId(0x00000004)]
		int MinorVersion();

		[DispId(0x00000005)]
		[return:MarshalAs(UnmanagedType.Interface)]
		Object GetCollectionByQuery([In, MarshalAs(UnmanagedType.BStr)] 
			String collName,
			[In, MarshalAs(UnmanagedType.SafeArray)] 
			ref Object[] aQuery);

		[DispId(0x00000006)]
		void ImportComponent([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrCLSIDOrProgId);

		[DispId(0x00000007)]
		void InstallComponent([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrDLL, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrTLB, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrPSDLL);

		[DispId(0x00000008)]
		void ShutdownApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName);

		[DispId(0x00000009)]
		void ExportApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationFile, 
			[In] int lOptions);

		[DispId(0x0000000a)]
		void InstallApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationFile, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrDestinationDirectory, 
			[In] int lOptions, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrUserId, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrPassword, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrRSN);
        
		[DispId(0x0000000b)]
		void StopRouter();

		[DispId(0x0000000c)]
		void RefreshRouter();

		[DispId(0x0000000d)]
		void StartRouter();

		[DispId(0x0000000e)]
		void Reserved1();

		[DispId(0x0000000f)]
		void Reserved2();

		[DispId(0x00000010)]
		void InstallMultipleComponents([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
			[In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] fileNames,
			[In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] CLSIDS);
        
		[DispId(0x00000011)]
		void GetMultipleComponentsInfo([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
			[In] Object varFileNames, 
			[Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varCLSIDS, 
			[Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varClassNames, 
			[Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varFileFlags, 
			[Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varComponentFlags);

		[DispId(0x00000012)]
		void RefreshComponents();

		[DispId(0x00000013)]
		void BackupREGDB([In, MarshalAs(UnmanagedType.BStr)] String bstrBackupFilePath);

		[DispId(0x00000014)]
		void RestoreREGDB([In, MarshalAs(UnmanagedType.BStr)] String bstrBackupFilePath);

		[DispId(0x00000015)]
		void QueryApplicationFile([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationFile, 
			[Out, MarshalAs(UnmanagedType.BStr)] out String bstrApplicationName,
			[Out, MarshalAs(UnmanagedType.BStr)] out String bstrApplicationDescription, 
			[Out, MarshalAs(UnmanagedType.VariantBool)] out bool bHasUsers, 
			[Out, MarshalAs(UnmanagedType.VariantBool)] out bool bIsProxy, 
			[Out, MarshalAs(UnmanagedType.SafeArray)] out Object[] varFileNames);
        
		[DispId(0x00000016)]
		void StartApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName);

		[DispId(0x00000017)]
		int ServiceCheck([In] int lService);

		[DispId(0x00000018)]
		void InstallMultipleEventClasses([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
			[In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] fileNames,
			[In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)] ref Object[] CLSIDS);

		[DispId(0x00000019)]
		void InstallEventClass([In, MarshalAs(UnmanagedType.BStr)] String bstrApplIdOrName, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrDLL, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrTLB, 
			[In, MarshalAs(UnmanagedType.BStr)] String bstrPSDLL);

		[DispId(0x0000001a)]
		void GetEventClassesForIID([In] String bstrIID, 
			[In, Out, MarshalAs(UnmanagedType.SafeArray)] ref Object[] varCLSIDS, 
			[In, Out, MarshalAs(UnmanagedType.SafeArray)] ref Object[] varProgIDs, 
			[In, Out, MarshalAs(UnmanagedType.SafeArray)] ref Object[] varDescriptions);

		[DispId(0x0000001b)]
		[return:MarshalAs(UnmanagedType.Interface)] 
		Object GetCollectionByQuery2(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrCollectionName, 
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarQueryStrings);

		[DispId(0x0000001c)]
		[return:MarshalAs(UnmanagedType.BStr)]
		String GetApplicationInstanceIDFromProcessID([In, MarshalAs(UnmanagedType.I4)] int lProcessID);

		[DispId(0x0000001d)]
		void ShutdownApplicationInstances([In, MarshalAs(UnmanagedType.LPStruct)] Object pVarApplicationInstanceID);
        
		[DispId(0x0000001e)]
		void PauseApplicationInstances([In, MarshalAs(UnmanagedType.LPStruct)] Object pVarApplicationInstanceID);
        
		[DispId(0x0000001f)]
		void ResumeApplicationInstances([In, MarshalAs(UnmanagedType.LPStruct)] Object pVarApplicationInstanceID);

		[DispId(0x00000020)]
		void RecycleApplicationInstances(
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarApplicationInstanceID,
								[In, MarshalAs(UnmanagedType.I4)] int lReasonCode);
        
		[DispId(0x00000021)]
		[return:MarshalAs(UnmanagedType.VariantBool)]
		bool AreApplicationInstancesPaused([In, MarshalAs(UnmanagedType.LPStruct)] Object pVarApplicationInstanceID);

		[DispId(0x00000022)]
		[return:MarshalAs(UnmanagedType.BStr)]
		String DumpApplicationInstance(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationInstanceID,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrDirectory,
								[In, MarshalAs(UnmanagedType.I4)] int lMaxImages);
          
		[DispId(0x00000023)]
		[return:MarshalAs(UnmanagedType.VariantBool)]
		bool IsApplicationInstanceDumpSupported();

		[DispId(0x00000024)]
		void CreateServiceForApplication(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrServiceName,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrStartType,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrErrorControl,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrDependencies,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrRunAs,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrPassword,
								[In, MarshalAs(UnmanagedType.VariantBool)] bool bDesktopOk);

		[DispId(0x00000025)]
		void DeleteServiceForApplication([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationIDOrName);

		[DispId(0x00000026)]
		[return:MarshalAs(UnmanagedType.BStr)]
		String GetPartitionID([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationIDOrName);

		[DispId(0x00000027)]
		[return:MarshalAs(UnmanagedType.BStr)]
		String GetPartitionName([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationIDOrName);

		[DispId(0x00000028)]
		void CurrentPartition([In, MarshalAs(UnmanagedType.BStr)]String bstrPartitionIDOrName);

		[DispId(0x00000029)]
		[return:MarshalAs(UnmanagedType.BStr)]
		String CurrentPartitionID();

		[DispId(0x0000002A)]
		[return:MarshalAs(UnmanagedType.BStr)] 
		String CurrentPartitionName();

		[DispId(0x0000002B)]
		[return:MarshalAs(UnmanagedType.BStr)] 
		String GlobalPartitionID();

		[DispId(0x0000002C)]
		void FlushPartitionCache(); 

		[DispId(0x0000002D)]
		void CopyApplications(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrSourcePartitionIDOrName,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarApplicationID,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrDestinationPartitionIDOrName); 

		[DispId(0x0000002E)]
		void CopyComponents(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrSourceApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarCLSIDOrProgID,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrDestinationApplicationIDOrName);

		[DispId(0x0000002F)]
		void MoveComponents(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrSourceApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarCLSIDOrProgID,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrDestinationApplicationIDOrName);

		[DispId(0x00000030)]
		void AliasComponent(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrSrcApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrCLSIDOrProgID,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrDestApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrNewProgId,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrNewClsid);

		[DispId(0x00000031)]
		[return:MarshalAs(UnmanagedType.Interface)] 
		Object IsSafeToDelete([In, MarshalAs(UnmanagedType.BStr)] String bstrDllName);

		[DispId(0x00000032)]
		void ImportUnconfiguredComponents(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarCLSIDOrProgID,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarComponentType);

		[DispId(0x00000033)]
		void PromoteUnconfiguredComponents(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarCLSIDOrProgID,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarComponentType);
		
		[DispId(0x00000034)]
		void ImportComponents(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationIDOrName,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarCLSIDOrProgID,
								[In, MarshalAs(UnmanagedType.LPStruct)] Object pVarComponentType);

		[DispId(0x00000035)]
		[return:MarshalAs(UnmanagedType.VariantBool)] 
		bool Is64BitCatalogServer();

		[DispId(0x00000036)]
		void ExportPartition(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrPartitionIDOrName,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrPartitionFileName,
								[In, MarshalAs(UnmanagedType.I4)] int lOptions);

		[DispId(0x00000037)]
		void InstallPartition(
								[In, MarshalAs(UnmanagedType.BStr)] String bstrFileName, 
								[In, MarshalAs(UnmanagedType.BStr)] String bstrDestDirectory,
								[In, MarshalAs(UnmanagedType.I4)] int lOptions,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrUserID,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrPassword,
								[In, MarshalAs(UnmanagedType.BStr)] String bstrRSN);

		[DispId(0x00000038)]
		[return:MarshalAs(UnmanagedType.IDispatch)] 
		Object QueryApplicationFile2([In, MarshalAs(UnmanagedType.BStr)] String bstrApplicationFile);

		[DispId(0x00000039)]
		[return:MarshalAs(UnmanagedType.I4)] 
		int GetComponentVersionCount([In, MarshalAs(UnmanagedType.BStr)] String bstrCLSIDOrProgID);
	}


    [SuppressUnmanagedCodeSecurity]
    [ComImport]
    [Guid("6EB22871-8A19-11D0-81B6-00A0C9231C29")]
    internal interface ICatalogObject
    {
        [DispId(0x00000001)]
        Object GetValue([In, MarshalAs(UnmanagedType.BStr)] String propName);

        [DispId(0x00000001)]
        void SetValue([In, MarshalAs(UnmanagedType.BStr)] String propName,
                      [In] Object value);

        [DispId(0x00000002)]
        Object Key();

        [DispId(0x00000003)]
        Object Name();
        
        [DispId(0x00000004)]
        [return : MarshalAs(UnmanagedType.VariantBool)]
        bool IsPropertyReadOnly([In, MarshalAs(UnmanagedType.BStr)] String bstrPropName);

        bool Valid { 
            [DispId(0x00000005)]
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
        }

        [DispId(0x00000006)]
        [return : MarshalAs(UnmanagedType.VariantBool)]
        bool IsPropertyWriteOnly([In, MarshalAs(UnmanagedType.BStr)] String bstrPropName);
    }

    [SuppressUnmanagedCodeSecurity]
    [ComImport]
    [Guid("6EB22872-8A19-11D0-81B6-00A0C9231C29")]
    [InterfaceType(ComInterfaceType.InterfaceIsDual)]
    internal interface ICatalogCollection
    {
        [DispId(unchecked((int)0xfffffffc))]
        void GetEnumerator(out IEnumerator pEnum);

        [DispId(0x00000001)]
        [return : MarshalAs(UnmanagedType.Interface)]
        Object Item([In] int lIndex);
        
        [DispId(0x60020002)]
        int Count();

        [DispId(0x60020003)]
        void Remove([In] int lIndex);

        [DispId(0x60020004)]
        [return : MarshalAs(UnmanagedType.Interface)]
        Object Add();
        
        [DispId(0x00000002)]
        void Populate();
        
        [DispId(0x00000003)]
        int SaveChanges();

        [DispId(0x00000004)]
        [return : MarshalAs(UnmanagedType.Interface)]
        Object GetCollection([In, MarshalAs(UnmanagedType.BStr)] String bstrCollName, 
                             [In] Object varObjectKey);

        [DispId(0x00000006)]
        Object Name();

        bool IsAddEnabled {
            [DispId(0x00000007)]
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
        }

        bool IsRemoveEnabled {
            [DispId(0x00000008)]
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
        }
        
        [DispId(0x00000009)]
        [return : MarshalAs(UnmanagedType.Interface)]
        Object GetUtilInterface();

        int DataStoreMajorVersion {
            [DispId(0x0000000a)]
            get;
        }

        int DataStoreMinorVersion {
            [DispId(0x0000000b)]
            get;
        }

        void PopulateByKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_VARIANT)]
                           Object[] aKeys);

        [DispId(0x0000000d)]
        void PopulateByQuery([In, MarshalAs(UnmanagedType.BStr)] String bstrQueryString, 
                             [In] int lQueryType);
    }
    
    [ComImport]
    [Guid("F618C514-DFB8-11D1-A2CF-00805FC79235")]
    internal class xCatalog {}

    [ComImport]
    [Guid("6EB22881-8A19-11D0-81B6-00A0C9231C29")]
    internal class xMtsCatalog {}

    internal class CollectionName
    {
        private static volatile bool _initialized;
        private static String _apps;
        private static String _comps;
        private static String _interfaces;
        private static String _meths;
        private static String _roles;
        private static String _user;

        private static void Initialize()
        {
            if(!_initialized)
            {
                lock(typeof(CollectionName))
                {
                    if(!_initialized)
                    {
                        if(Platform.IsLessThan(Platform.W2K))
                        {
                            _apps       = "Packages";
                            _comps      = "ComponentsInPackage";
                            _interfaces = "InterfacesForComponent";
                            _meths      = "MethodsForInterface";
                            _roles      = "RolesInPackage";
                            _user       = "UsersInRole";
                        }
                        else
                        {
                            _apps       = "Applications";
                            _comps      = "Components";
                            _interfaces = "InterfacesForComponent";
                            _meths      = "MethodsForInterface";
                            _roles      = "Roles";
                            _user       = "UsersInRole";
                        }
                        _initialized = true;
                    }
                }
            }
        }

        internal static String Applications
        {
            get { Initialize(); return(_apps); }
        }

        internal static String Components
        {
            get { Initialize(); return(_comps); }
        }

        internal static String Interfaces
        {
            get { Initialize(); return(_interfaces); }
        }

        internal static String Methods
        {
            get { Initialize(); return(_meths); }
        }

        internal static String Roles
        {
            get { Initialize(); return(_roles); }
        }

        internal static String UsersInRole
        {
            get { Initialize(); return(_user); }
        }

        internal static String RolesFor(String target)
        {
            if(Platform.IsLessThan(Platform.W2K))
            {
                if(target == "Component") 
                    return("RolesForPackageComponent");
                else if(target == "Interface")
                    return("RolesForPackageComponentInterface");
                else
                {
                    DBG.Assert(false, "Unknown MTS role collection target.");
                    return(null);
                }
            }
            else
            {
                return("RolesFor" + target);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\contextutil.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//


/// <include file='doc\ContextUtil.uex' path='docs/doc[@for="EnterpriseServices"]/*' />
namespace System.EnterpriseServices
{
    using System;
	using System.Runtime.InteropServices;
	
    
    //   The ContextUtil object provides some useful functions for 
    //   accessing a COM+ context.
    /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil"]/*' />
    public sealed class ContextUtil
    {
        // Disallow instantiation of this class.
        private ContextUtil() {}
        
        internal static readonly Guid GUID_TransactionProperty = new Guid("ecabaeb1-7f19-11d2-978e-0000f8757e2a");
        internal static readonly Guid GUID_JitActivationPolicy = new Guid("ecabaeb2-7f19-11d2-978e-0000f8757e2a");

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.ObjectContext"]/*' />
        internal static Object ObjectContext
        { 
            get 
            { 
                Platform.Assert(Platform.MTS, "ContextUtil.ObjectContext");
                IObjectContext obj = null;
                int hr = Util.GetObjectContext(out obj);
                
                if(hr == 0) return(obj);

                // Error conditions:
                if(hr == Util.E_NOINTERFACE || hr == Util.CONTEXT_E_NOCONTEXT) // No context
                {
                    throw new COMException(Resource.FormatString("Err_NoContext"), Util.CONTEXT_E_NOCONTEXT);
                }
                else
                {
                    Marshal.ThrowExceptionForHR(hr);
                }
                DBG.Assert(false, "ThrowExceptionForHR failed to throw!");
                return(null);
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.EnableCommit"]/*' />
        public static void EnableCommit() 
        {
            Platform.Assert(Platform.MTS, "ContextUtil.EnableCommit");
            Thunk.ContextThunk.EnableCommit();
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.DisableCommit"]/*' />
        public static void DisableCommit() 
        {
            Platform.Assert(Platform.MTS, "ContextUtil.DisableCommit");
            Thunk.ContextThunk.DisableCommit();
        }

        // The standard SetComplete/SetAbort:
        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.SetComplete"]/*' />
        public static void SetComplete() 
        {
            Platform.Assert(Platform.MTS, "ContextUtil.SetComplete");
            Thunk.ContextThunk.SetComplete();
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.SetAbort"]/*' />
        public static void SetAbort() 
        {
            Platform.Assert(Platform.MTS, "ContextUtil.SetAbort");
            Thunk.ContextThunk.SetAbort();

        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.IsCallerInRole"]/*' />
        public static bool IsCallerInRole(String role) 
        {
            Platform.Assert(Platform.MTS, "ContextUtil.IsCallerInRole");
            return ((IObjectContext)ObjectContext).IsCallerInRole(role);
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.IsInTransaction"]/*' />
        public static bool IsInTransaction 
        { 
            get 
			{ 
		        return ( Thunk.ContextThunk.IsInTransaction() );
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.IsSecurityEnabled"]/*' />
        public static bool IsSecurityEnabled 
        {
            get 
            { 
                Platform.Assert(Platform.MTS, "ContextUtil.IsSecurityEnabled");
                try
                {
                    return ((IObjectContext)ObjectContext).IsSecurityEnabled(); 
                }
                catch(Exception)
                {
                    return(false);
                }
            }
        }

        // Context information:
        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.Transaction"]/*' />
        public static Object Transaction 
        { 
            get 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.Transaction");
                return ((IObjectContextInfo)ObjectContext).GetTransaction(); 
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.TransactionId"]/*' />
        public static Guid TransactionId
        { 
            get 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.TransactionId");
                return Thunk.ContextThunk.GetTransactionId();
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.ContextId"]/*' />
        public static Guid ContextId
        { 
            get 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.ContextId");
                return ((IObjectContextInfo)ObjectContext).GetContextId(); 
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.ActivityId"]/*' />
        public static Guid ActivityId
        { 
            get 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.ActivityId");
                return ((IObjectContextInfo)ObjectContext).GetActivityId(); 
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.MyTransactionVote"]/*' />
        public static TransactionVote MyTransactionVote
        { 
            get 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.MyTransactionVote");
                return ((IContextState)ObjectContext).GetMyTransactionVote();                 
            }
            set 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.MyTransactionVote");  
                ((IContextState)ObjectContext).SetMyTransactionVote(value);              
            }
        }
    
        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.DeactivateOnReturn"]/*' />
        public static bool DeactivateOnReturn 
        { 
            get 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.DeactivateOnReturn");
                return ((IContextState)ObjectContext).GetDeactivateOnReturn();                 
            }
            set 
            { 
                Platform.Assert(Platform.W2K, "ContextUtil.DeactivateOnReturn");
                ((IContextState)ObjectContext).SetDeactivateOnReturn(value);                
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.GetNamedProperty"]/*' />
        public static Object GetNamedProperty(String name)
        {
            Platform.Assert(Platform.W2K, "ContextUtil.GetNamedProperty");
            return ((IGetContextProperties)ObjectContext).GetProperty(name);
        }
        
        // IObjectContextInfo2 properties
        
        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.PartitionId"]/*' />
        public static Guid PartitionId
        { 
            get 
            { 
                Platform.Assert(Platform.Whistler, "ContextUtil.PartitionId");
                return ((IObjectContextInfo2)ObjectContext).GetPartitionId(); 
            }
        }

        /// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.ApplicationId"]/*' />
        public static Guid ApplicationId
        { 
            get 
            { 
                Platform.Assert(Platform.Whistler, "ContextUtil.ApplicationId");
                return ((IObjectContextInfo2)ObjectContext).GetApplicationId(); 
            }
        }

		/// <include file='doc\ContextUtil.uex' path='docs/doc[@for="ContextUtil.ApplicationInstanceId"]/*' />
        public static Guid ApplicationInstanceId
        { 
            get 
            { 
                Platform.Assert(Platform.Whistler, "ContextUtil.ApplicationInstanceId");
                return ((IObjectContextInfo2)ObjectContext).GetApplicationInstanceId(); 
            }
        }
                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\configcallbacks.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: April 2000
//

/*
  New configuration theory:

  Start at the application level, w/ a Component collection.  
  We pass the collection and a new ComponentConfigCallback, which knows
  how to do the steps to configure a component.


 */

namespace System.EnterpriseServices
{
    using System;
    using System.EnterpriseServices.Admin;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;

    // Interface supported by objects which do configuration:
    internal interface IConfigCallback
    {
        Object FindObject(ICatalogCollection coll, Object key);
        void   ConfigureDefaults(Object a, Object key);
        // These two guys are expected to return true if they dirtied the collection.
        bool   Configure(Object a, Object key);        
        bool   AfterSaveChanges(Object a, Object key);
        void   ConfigureSubCollections(ICatalogCollection coll);

        IEnumerator GetEnumerator();
    }

    internal class ComponentConfigCallback : IConfigCallback
    {
        ApplicationSpec    _spec;
        ICatalogCollection _coll;
        Hashtable         _cache;
        RegistrationDriver _driver;
        InstallationFlags  _installFlags;

        public ComponentConfigCallback(ICatalogCollection coll,
                                       ApplicationSpec spec, 
                                       Hashtable cache, 
                                       RegistrationDriver driver,
                                       InstallationFlags installFlags)
        {
            _spec  = spec;
            _coll  = coll;
            _cache = cache;
            _driver = driver;
            _installFlags = installFlags;

            // TODO:  Populate w/ QueryByKey
            // TODO:  Cache for FindObject
            RegistrationDriver.Populate(coll);
        }

        // Map a runtime type (key) to a component catalog object (obj)
        public Object FindObject(ICatalogCollection coll, Object key)
        {
            Guid id = Marshal.GenerateGuidForType((Type)key);

            for(int i = 0; i < coll.Count(); i++)
            {
                ICatalogObject obj = (ICatalogObject)(coll.Item(i));
                Guid possible = new Guid((String)(obj.Key()));
                if(possible == id) return(obj);
            }
            throw new RegistrationException(Resource.FormatString("Reg_ComponentMissing", ((Type)key).FullName));
        }

        public void ConfigureDefaults(Object a, Object key)
        {
            ICatalogObject obj = (ICatalogObject)a;
            
            if(Platform.IsLessThan(Platform.W2K))
            {
                obj.SetValue("Transaction", "Not Supported");
                obj.SetValue("SecurityEnabled", "N");
            }
            else
            {
                obj.SetValue("AllowInprocSubscribers", true);
                obj.SetValue("ComponentAccessChecksEnabled", false);
                obj.SetValue("COMTIIntrinsics", false);
                obj.SetValue("ConstructionEnabled", false);
                obj.SetValue("EventTrackingEnabled", false);
                obj.SetValue("FireInParallel", false);
                obj.SetValue("IISIntrinsics", false);
                obj.SetValue("JustInTimeActivation", false);
                obj.SetValue("LoadBalancingSupported", false);
                obj.SetValue("MustRunInClientContext", false);
                obj.SetValue("ObjectPoolingEnabled", false);
                obj.SetValue("Synchronization", SynchronizationOption.Disabled);
                obj.SetValue("Transaction", TransactionOption.Disabled);
				obj.SetValue("ComponentTransactionTimeoutEnabled", false);
            }
            if(!Platform.IsLessThan(Platform.Whistler))
            {
                obj.SetValue("TxIsolationLevel", TransactionIsolationLevel.Serializable);
            }
        }

        public bool Configure(Object a, Object key)
        {
            return(_driver.ConfigureObject((Type)key, (ICatalogObject)a, _coll, "Component", _cache));
        }

        public bool AfterSaveChanges(Object a, Object key)
        {
            return(_driver.AfterSaveChanges((Type)key, (ICatalogObject)a, _coll, "Component", _cache));
        }

        public IEnumerator GetEnumerator()
        {
            return(_spec.ConfigurableTypes.GetEnumerator());
        }

        public void ConfigureSubCollections(ICatalogCollection coll)
        {
            if((_installFlags & InstallationFlags.ConfigureComponentsOnly) == 0)
            {
                foreach(Type t in _spec.ConfigurableTypes)
                {
                    ICatalogObject obj = (ICatalogObject)FindObject(coll, t);
                    ICatalogCollection ifcColl = (ICatalogCollection)(coll.GetCollection(CollectionName.Interfaces, obj.Key()));

                    // Poke the cache so it's up to date...
                    _cache["Component"] = obj;
                    _cache["ComponentType"] = t;

                    InterfaceConfigCallback cb = new InterfaceConfigCallback(ifcColl, t, _cache, _driver);
                    _driver.ConfigureCollection(ifcColl, cb);

                    if(_cache["SecurityOnMethods"] != null || ServicedComponentInfo.AreMethodsSecure(t))
                    {
                        DBG.Info(DBG.Registration, "Found security on methods for: " + t);
                        FixupMethodSecurity(ifcColl);
                        _cache["SecurityOnMethods"] = null;
                    }
                }

            }
        }

        private void FixupMethodSecurity(ICatalogCollection coll)
        {
            // HACK:  We've gone through and configured all the methods
            // and interfaces.  If we noticed that we've got method
            // based security, we need to add a Marshaler role to 
            // IManagedObject (in order to let remote activators marshal
            // this guy into their space), to IDisposable (to let the caller dispose
			// the object) and to IServiceComponentInfo (to query remote object).

			FixupMethodSecurityForInterface(coll, typeof(IManagedObject));
			FixupMethodSecurityForInterface(coll, typeof(IServicedComponentInfo));
			FixupMethodSecurityForInterface(coll, typeof(IDisposable));

		}

        private void FixupMethodSecurityForInterface(ICatalogCollection coll, Type InterfaceType)
        {
            ICatalogObject obj = null;

            // Look through the interfaces in ifcColl, and find specific interface.
            Guid iid = Marshal.GenerateGuidForType(InterfaceType);
            int count = coll.Count();
            for(int i = 0; i < count; i++)
            {
                ICatalogObject test = (ICatalogObject)(coll.Item(i));
                if(new Guid((String)(test.Key())) == iid)
                {
                    obj = test;
                    break;
                }
            }
            
            DBG.Assert(obj != null, "Could not find interface " + InterfaceType + " in catalog!");
            if(obj != null)
            {
                SecurityRoleAttribute attr = new SecurityRoleAttribute("Marshaler", false);
                attr.Description = Resource.FormatString("Reg_MarshalerDesc");
                IConfigurationAttribute confattr = attr as IConfigurationAttribute;
            
                DBG.Assert(confattr != null, "SecurityRoleAttribute does not support IConfigurationAttribute!");
                
                // Now, set up the cache to configure this interface:
                _cache["CurrentTarget"] = "Interface";
                _cache["InterfaceCollection"] = coll;
                _cache["Interface"] = obj;
                _cache["InterfaceType"] = InterfaceType;

                // First step, Ensure that the role is here:
                if(confattr.Apply(_cache))
                {
                    coll.SaveChanges();
                }

                //  Now, fix up the real roles:
                if(confattr.AfterSaveChanges(_cache))
                {
                    coll.SaveChanges();
                }
            }
        }
    }

    // Interfaces are keyed by catalog object, rather than
    // the other way round (components are keyed by type).
    internal class InterfaceConfigCallback : IConfigCallback
    {
        private static readonly Guid IID_IProcessInitializer = new Guid("1113f52d-dc7f-4943-aed6-88d04027e32a");

        private Type               _type;
        private ICatalogCollection _coll;
        private Type[]             _ifcs;
        private Hashtable         _cache;
        private RegistrationDriver _driver;

        private Type[] GetInteropInterfaces(Type t)
        {
            Type root = t;
            ArrayList arr = new ArrayList(t.GetInterfaces());
            while(root != null)
            {
                arr.Add(root);
                root = root.BaseType;
            }
            
            arr.Add(typeof(IManagedObject));

            Type[] tarr = new Type[arr.Count];
            arr.CopyTo(tarr);
            return(tarr);
        }

        // Given a type T, find the interface it supports, given the
        // catalog object.
        private Type FindInterfaceByID(ICatalogObject ifcObj, Type t, Type[] interfaces)
        {
            Guid id = new Guid((String)(ifcObj.GetValue("IID")));
            DBG.Info(DBG.Registration, "Searching by ID: " + id);
            
            foreach(Type ifc in interfaces)
            {
                Guid ifcID = Marshal.GenerateGuidForType(ifc);
                DBG.Info(DBG.Registration, "ID = " + ifcID + " for " + ifc);
                if(ifcID == id) return(ifc);
            }

            return(null);
        }

        private Type FindInterfaceByName(ICatalogObject ifcObj, Type t, Type[] interfaces)
        {
            String name = (String)(ifcObj.GetValue("Name"));
            
            foreach(Type ifc in interfaces)
            {
                if(ifc.IsInterface) {
                    DBG.Info(DBG.Registration, "Matching " + ifc.Name + " against " + name + " on " + ifc);
                    if(ifc.Name == name) return(ifc);
                }
                else {
                    DBG.Info(DBG.Registration, "Matching _" + ifc.Name + " against " + name + " on " + ifc);
                    if("_" + ifc.Name == name) return(ifc);
                }
            }

            return(null);
        }

        public InterfaceConfigCallback(ICatalogCollection coll, Type t, Hashtable cache, RegistrationDriver driver)
        {
            _type = t;
            _coll = coll;
            _cache = cache;
            _driver = driver;

            // TODO:  Populate w/ QueryByKey
            // TODO:  Build cache for FindObject()
            _ifcs = GetInteropInterfaces(_type);

            // Check to see if one of the interfaces is IProcessInitializer
            foreach(Type ifc in _ifcs)
            {
                if(Marshal.GenerateGuidForType(ifc) == IID_IProcessInitializer)
                {
                    DBG.Info(DBG.Registration, "Setting component " + cache["ComponentType"] + " up as process initializer");
                    try
                    {
                        ICatalogObject comp = cache["Component"] as ICatalogObject;
                        ICatalogCollection compColl = cache["ComponentCollection"] as ICatalogCollection;

                        comp.SetValue("InitializesServerApplication", 1);
                        compColl.SaveChanges();
                    }
                    catch(Exception e)
                    {
                        throw new RegistrationException(Resource.FormatString("Reg_FailPIT", _type), e);
                    }
                }
            }

            RegistrationDriver.Populate(_coll);
        }

        // Map an interface catalog object (key) to a runtime type (ifc)
        public Object FindObject(ICatalogCollection coll, Object key)
        {
            ICatalogObject ifcObj = (ICatalogObject)key;
            Type ifc = null;

            ifc = FindInterfaceByID(ifcObj, _type, _ifcs);

            if(ifc == null) 
            {
                ifc = FindInterfaceByName(ifcObj, _type, _ifcs);
            }
            

            DBG.Assert(ifc != null, 
                       "Unable to find requested interface: \n"
                       + "\t" + (String)(ifcObj.Name()) + "\n"
                       + "\t" + (String)(ifcObj.Key()));

            return(ifc);
        }
 
        public void ConfigureDefaults(Object a, Object key)
        {
            DBG.Assert(!(Platform.IsLessThan(Platform.W2K)), "Configuring interfaces on non-w2k platform!");

            if(!Platform.IsLessThan(Platform.W2K))
            {
                bool setQdefault = true;

                ICatalogObject obj = (ICatalogObject)key;
                // If this type (a) has been touched by the parent component,
                // we don't want to set this value...
                if(_cache[_type] != null)
                {
                    Object co = _cache[_type];
                    if(co is Hashtable && ((Hashtable)co)[a] != null)
                    {
                        DBG.Info(DBG.Registration, "*** not setting queue defaults!");
                        setQdefault = false;
                    }
                }
                if(setQdefault)
                {
                    obj.SetValue("QueuingEnabled", false);
                }
            }
        }

        public bool Configure(Object a, Object key)
        {
            if(a == null) return(false);
            return(_driver.ConfigureObject((Type)a, (ICatalogObject)key, _coll, "Interface", _cache));
        }

        public bool AfterSaveChanges(Object a, Object key)
        {
            if(a == null) return(false);
            return(_driver.AfterSaveChanges((Type)a, (ICatalogObject)key, _coll, "Interface", _cache));
        }

        public IEnumerator GetEnumerator()
        {
            IEnumerator E = null;
            _coll.GetEnumerator(out E);
            return(E);
        }

        public void ConfigureSubCollections(ICatalogCollection coll)
        {
            foreach(ICatalogObject ifcObj in this)
            {
                Type ifc = (Type)FindObject(coll, ifcObj);
                if(ifc == null) continue;

                ICatalogCollection methColl = (ICatalogCollection)(coll.GetCollection(CollectionName.Methods, ifcObj.Key()));
                _driver.ConfigureCollection(methColl, 
                                            new MethodConfigCallback(methColl, ifc, _type, _cache, _driver));
            }            
        }
    }

    // Methods are also keyed by catalog object, rather than
    // the other way round (components are keyed by type).
    internal class MethodConfigCallback : IConfigCallback
    {
        private Type               _type;
        private Type               _impl;
        private ICatalogCollection _coll;
        private Hashtable          _cache;
        private RegistrationDriver _driver;
        private InterfaceMapping   _map;

        public MethodConfigCallback(ICatalogCollection coll, Type t, Type impl, Hashtable cache, RegistrationDriver driver)
        {
            _type   = t;      // The "interface" we have methods for
            _impl   = impl;   // The implementation of the interface:
            _coll   = coll;
            _cache  = cache;
            _driver = driver;

            try
            {
                _map = _impl.GetInterfaceMap(_type);
            }
            catch(System.ArgumentException)
            {
                _map.InterfaceMethods = null;
                _map.InterfaceType = null;
                _map.TargetMethods = null;
                _map.TargetType = null;
            }

            RegistrationDriver.Populate(coll);
        }

        public Object FindObject(ICatalogCollection coll, Object key)
        {
            ICatalogObject methObj = (ICatalogObject)key;
            int slot = (int)(methObj.GetValue("Index"));
            ComMemberType mtype = ComMemberType.Method;

            MemberInfo info = Marshal.GetMethodInfoForComSlot(_type, slot, ref mtype);
            DBG.Assert(info != null, "Failed to find method info for COM slot!");

            // Now we have the member info, look through the interface
            // mapping for this guy:
            if(info is PropertyInfo)
            {
                if(mtype == ComMemberType.PropSet)
                    info = ((PropertyInfo)info).GetSetMethod();
                else if(mtype == ComMemberType.PropGet)
                    info = ((PropertyInfo)info).GetGetMethod();
                else
                {
                    DBG.Assert(false, "Illegal ComMemberType returned");
                }
            }

            if(_map.InterfaceMethods != null)
            {
                for(int i = 0; i < _map.InterfaceMethods.Length; i++)
                {
                    if(_map.InterfaceMethods[i] == info)
                        return(_map.TargetMethods[i]);
                }
                DBG.Assert(false, "Had interface mapping, but found no method.");
            }
            return(info);
        }

        public void ConfigureDefaults(Object a, Object key)
        {
            DBG.Assert(!(Platform.IsLessThan(Platform.W2K)), "Configuring methods on non-w2k platform!");

            if(!Platform.IsLessThan(Platform.W2K))
            {
                ICatalogObject obj = (ICatalogObject)key;
                obj.SetValue("AutoComplete", false);
            }
        }

        public bool Configure(Object a, Object key)
        {
            if(a == null) return(false);
            return(_driver.ConfigureObject((MethodInfo)a, (ICatalogObject)key, _coll, "Method", _cache));
        }

        public bool AfterSaveChanges(Object a, Object key)
        {
            if(a == null) return(false);
            return(_driver.AfterSaveChanges((MethodInfo)a, (ICatalogObject)key, _coll, "Method", _cache));
        }

        public IEnumerator GetEnumerator()
        {
            IEnumerator E = null;
            _coll.GetEnumerator(out E);
            return(E);
        }

        public void ConfigureSubCollections(ICatalogCollection coll)
        {
            // No sub-collections below Method require any work.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\byot.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: dddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System.Runtime.InteropServices;

    [ComImport]
    [Guid("455ACF59-5345-11D2-99CF-00C04F797BC9")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICreateWithTipTransactionEx
    {
        [return: MarshalAs(UnmanagedType.Interface)]
        Object CreateInstance(String bstrTipUrl, 
                              [In, MarshalAs(UnmanagedType.LPStruct)] Guid rclsid, 
                              [In, MarshalAs(UnmanagedType.LPStruct)] Guid riid);
    }

    [ComImport]
    [Guid("455ACF57-5345-11D2-99CF-00C04F797BC9")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICreateWithTransactionEx
    {
        [return: MarshalAs(UnmanagedType.Interface)]
        Object CreateInstance(ITransaction pTransaction, 
                            [In, MarshalAs(UnmanagedType.LPStruct)] Guid rclsid, 
                            [In, MarshalAs(UnmanagedType.LPStruct)] Guid riid);
        
    }

    [ComImport]
    [Guid("ECABB0AA-7F19-11D2-978E-0000F8757E2A")]
    internal class xByotServer {}

    /// <include file='doc\BYOT.uex' path='docs/doc[@for="BYOT"]/*' />
    public sealed class BYOT
    {
        // Disallow instantiation.
        private BYOT() {}

        private static Object GetByotServer()
        {
            return(new xByotServer());
        }

        // Type t must be a ServicedComponent, and should be configured
        // w/ tx requires or tx supports, so that it can inherit the root
        // transaction.
        // The transaction object should be a DTC transaction.
        /// <include file='doc\BYOT.uex' path='docs/doc[@for="BYOT.CreateWithTransaction"]/*' />
        public static Object CreateWithTransaction(Object transaction, Type t)
        {
            Guid clsid = Marshal.GenerateGuidForType(t);

            return(((ICreateWithTransactionEx)GetByotServer()).CreateInstance((ITransaction)transaction, 
                                                                         clsid, 
                                                                         Util.IID_IUnknown));
        }
        
        /// <include file='doc\BYOT.uex' path='docs/doc[@for="BYOT.CreateWithTipTransaction"]/*' />
        public static Object CreateWithTipTransaction(String url, Type t)
        {
            Guid clsid = Marshal.GenerateGuidForType(t);

            return(((ICreateWithTipTransactionEx)GetByotServer()).CreateInstance(url,
                                                                            clsid, 
                                                                            Util.IID_IUnknown));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\attributes.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: dddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Services;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.EnterpriseServices.Admin;
    using System.Collections;
    using System.Threading;
    
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionOption"]/*' />
	[Serializable]
    public enum TransactionOption
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionOption.Disabled"]/*' />
        Disabled    = 0,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionOption.NotSupported"]/*' />
        NotSupported = 1,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionOption.Supported"]/*' />
        Supported   = 2,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionOption.Required"]/*' />
        Required    = 3,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionOption.RequiresNew"]/*' />
        RequiresNew = 4
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionIsolationLevel"]/*' />
	[Serializable]
    public enum TransactionIsolationLevel
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionIsolationLevel.Any"]/*' />
        Any = 0,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionIsolationLevel.ReadUncommitted"]/*' />
        ReadUncommitted = 1,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionIsolationLevel.ReadCommitted"]/*' />
        ReadCommitted = 2,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionIsolationLevel.RepeatableRead"]/*' />
        RepeatableRead = 3,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionIsolationLevel.Serializable"]/*' />
        Serializable = 4
    } 


    /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationOption"]/*' />
	[Serializable]
    public enum SynchronizationOption
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationOption.Disabled"]/*' />
        Disabled     = 0,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationOption.NotSupported"]/*' />
        NotSupported = 1,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationOption.Supported"]/*' />
        Supported    = 2,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationOption.Required"]/*' />
        Required     = 3,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationOption.RequiresNew"]/*' />
        RequiresNew  = 4
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ActivationOption"]/*' />
	[Serializable]
    public enum ActivationOption
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ActivationOption.Library"]/*' />
        Library = 0,
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ActivationOption.Server"]/*' />
        Server  = 1,
    }

    // Currently, a call to Apply must supply a Hashtable containing the
    // at least the following entries:
    // ManagedType          (System.Type)
    // XXXCollection  (System.EnterpriseServices.Admin.ICatalogCollection)
    // XXX            (System.EnterpriseServices.Admin.ICatalogObject)
    // where XXX is the current target type (Component, Application, Method, Interface)
    internal interface IConfigurationAttribute
    {
        bool IsValidTarget(String s);
        // The following return true if they dirtied the object/collection.
        bool Apply(Hashtable info);
        bool AfterSaveChanges(Hashtable info);
    }

    // 
    // Component attributes.
    //
    //

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="IProcessInitializer"]/*' />
    [ComImport]
    [Guid("1113f52d-dc7f-4943-aed6-88d04027e32a")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IProcessInitializer
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="IProcessInitializer.Startup"]/*' />
        void Startup([In,MarshalAs(UnmanagedType.IUnknown)] Object punkProcessControl);
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="IProcessInitializer.Shutdown"]/*' />
        void Shutdown();
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="IProcessInitControl"]/*' />
    [ComImport]
    [Guid("72380d55-8d2b-43a3-8513-2b6ef31434e9")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IProcessInitControl
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="IProcessInitControl.ResetInitializerTimeout"]/*' />
        void ResetInitializerTimeout(int dwSecondsRemaining);
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class TransactionAttribute : Attribute, IConfigurationAttribute
    {
        private TransactionOption _value;
        private TransactionIsolationLevel _isolation;
        private int _timeout;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionAttribute.TransactionAttribute"]/*' />
        public TransactionAttribute()
          : this(TransactionOption.Required) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionAttribute.TransactionAttribute1"]/*' />
        public TransactionAttribute(TransactionOption val) 
        {
            _value = val;
            _isolation = TransactionIsolationLevel.Serializable;
            _timeout = -1;		// use global timeout
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionAttribute.Value"]/*' />
        public TransactionOption Value { get { return(_value); } }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionAttribute.Isolation"]/*' />
        public TransactionIsolationLevel Isolation 
        {
            get { return(_isolation); }
            set { _isolation = value; }
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="TransactionAttribute.Timeout"]/*' />
        public int Timeout 
        {
            get { return(_timeout); }
            set { _timeout = value; }
        }

        // Internal implementation:
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Object value = _value;

            Platform.Assert(Platform.MTS, "TransactionAttribute");

            if(Platform.IsLessThan(Platform.W2K))
            {
                switch(_value)
                {
                case TransactionOption.Required:     value = "Required"; break;
                case TransactionOption.RequiresNew:  value = "Requires New"; break;
                case TransactionOption.Supported:    value = "Supported"; break;
                case TransactionOption.NotSupported: value = "NotSupported"; break;
                case TransactionOption.Disabled:     value = "NotSupported"; break;
                default:
                    DBG.Assert(false, "Unknown transaction type requested!");
                    break;
                }
            }

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("Transaction", value);

            if(_isolation != TransactionIsolationLevel.Serializable)
            {
                Platform.Assert(Platform.Whistler, "TransactionAttribute.Isolation");
                obj.SetValue("TxIsolationLevel", _isolation);
            }

            if(_timeout != -1)
            {
                Platform.Assert(Platform.W2K, "TransactionAttribute.Timeout");
                obj.SetValue("ComponentTransactionTimeout", _timeout);
                obj.SetValue("ComponentTransactionTimeoutEnabled", true);
            }

            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="JustInTimeActivationAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class JustInTimeActivationAttribute : Attribute, IConfigurationAttribute
    {
        private bool _enabled;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="JustInTimeActivationAttribute.JustInTimeActivationAttribute"]/*' />
        public JustInTimeActivationAttribute() 
          : this(true) {}
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="JustInTimeActivationAttribute.JustInTimeActivationAttribute1"]/*' />
        public JustInTimeActivationAttribute(bool val) 
        {
            _enabled = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="JustInTimeActivationAttribute.Value"]/*' />
        public bool Value { get { return(_enabled); } }

        // Internal implementation:
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "JustInTimeActivationAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("JustInTimeActivation", _enabled);

            // Make sure we turn on sync if the user didn't request
            // anything special:
            if(_enabled)
            {
                if((int)(obj.GetValue("Synchronization")) == (int)(SynchronizationOption.Disabled))
                {
                    DBG.Info(DBG.Registration, "JIT: Forcibly enabling sync:");
                    obj.SetValue("Synchronization", SynchronizationOption.Required);
                }
                else
                {
                    DBG.Info(DBG.Registration, "JIT: User-set sync, ignoring");
                }
            }
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class SynchronizationAttribute : Attribute, IConfigurationAttribute
    {
        private SynchronizationOption _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationAttribute.SynchronizationAttribute"]/*' />
        public SynchronizationAttribute() 
          : this(SynchronizationOption.Required) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationAttribute.SynchronizationAttribute1"]/*' />
        public SynchronizationAttribute(SynchronizationOption val) 
        {
            _value = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="SynchronizationAttribute.Value"]/*' />
        public SynchronizationOption Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "SynchronizationAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("Synchronization", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="MustRunInClientContextAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class MustRunInClientContextAttribute : Attribute, IConfigurationAttribute
    {
        private bool _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="MustRunInClientContextAttribute.MustRunInClientContextAttribute"]/*' />
        public MustRunInClientContextAttribute() : this(true) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="MustRunInClientContextAttribute.MustRunInClientContextAttribute1"]/*' />
        public MustRunInClientContextAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="MustRunInClientContextAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "MustRunInClientContextAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("MustRunInClientContext", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ConstructionEnabledAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class ConstructionEnabledAttribute : Attribute, IConfigurationAttribute
    {
        private bool   _enabled;
        private String _default;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ConstructionEnabledAttribute.ConstructionEnabledAttribute"]/*' />
        public ConstructionEnabledAttribute()          
        {
            // Make sure that the target type supports IObjectConstruct
            _enabled = true;
            _default = "";
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ConstructionEnabledAttribute.ConstructionEnabledAttribute1"]/*' />
        public ConstructionEnabledAttribute(bool val) 
        {
            // Make sure the target type supports IObjectConstruct
            _enabled = val;
            _default = "";
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ConstructionEnabledAttribute.Default"]/*' />
        public String Default 
        {
            get { return(_default); }
            set { _default = value; }
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ConstructionEnabledAttribute.Enabled"]/*' />
        public bool Enabled
        {
            get { return(_enabled); }
            set { _enabled = value; }
        }

        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "ConstructionEnabledAttribute");

            ICatalogObject comp = (ICatalogObject)(info["Component"]);
            comp.SetValue("ConstructionEnabled", _enabled);
            if(_default != null && _default != "")
            {
                comp.SetValue("ConstructorString", _default);
            }
            return(true);
        }

        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }
    
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class ObjectPoolingAttribute : Attribute, IConfigurationAttribute
    {
        private bool _enable;
        private int  _maxSize;
        private int  _minSize;
        private int  _timeout;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.ObjectPoolingAttribute"]/*' />
        public ObjectPoolingAttribute()
        {
            _enable  = true;
            _maxSize = -1; // Take defaults
            _minSize = -1; 
            _timeout = -1;
        }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.ObjectPoolingAttribute1"]/*' />
        public ObjectPoolingAttribute(int minPoolSize, int maxPoolSize)
        {
            _enable  = true;
            _maxSize = maxPoolSize;
            _minSize = minPoolSize;
            _timeout = -1;
        }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.ObjectPoolingAttribute2"]/*' />
        public ObjectPoolingAttribute(bool enable)
        {
            _enable  = enable;
            _maxSize = -1; // Take defaults
            _minSize = -1; 
            _timeout = -1;
        }
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.ObjectPoolingAttribute3"]/*' />
        public ObjectPoolingAttribute(bool enable, int minPoolSize, int maxPoolSize)
        {
            _enable  = enable;
            _maxSize = maxPoolSize;
            _minSize = minPoolSize;
            _timeout = -1;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.Enabled"]/*' />
        public bool Enabled 
        {
            get { return(_enable); }
            set { _enable = value; }
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.MaxPoolSize"]/*' />
        public int MaxPoolSize
        {
            get { return(_maxSize); }
            set { _maxSize = value; }
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.MinPoolSize"]/*' />
        public int MinPoolSize
        {
            get { return(_minSize); }
            set { _minSize = value; }
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.CreationTimeout"]/*' />
        public int CreationTimeout
        {
            get { return(_timeout); }
            set { _timeout = value; }
        }

         /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.IsValidTarget"]/*' />
         /// <internalonly/>
         public bool IsValidTarget(String s) { return(s == "Component"); }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.Apply"]/*' />
        /// <internalonly/>
        public bool Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "ObjectPoolingAttribute");

            ICatalogObject comp = (ICatalogObject)(info["Component"]);
            comp.SetValue("ObjectPoolingEnabled", _enable);
            if(_minSize >= 0) 
            {
                comp.SetValue("MinPoolSize", _minSize);
            }
            if(_maxSize >= 0) 
            {
                comp.SetValue("MaxPoolSize", _maxSize);
            }
            if(_timeout >= 0)
            {
                comp.SetValue("CreationTimeout", _timeout);
            }
            return(true);
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ObjectPoolingAttribute.AfterSaveChanges"]/*' />
        /// <internalonly/>
        public bool AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="COMTIIntrinsicsAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class COMTIIntrinsicsAttribute : Attribute, IConfigurationAttribute
    {
        private bool _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="COMTIIntrinsicsAttribute.COMTIIntrinsicsAttribute"]/*' />
        public COMTIIntrinsicsAttribute() : this(true) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="COMTIIntrinsicsAttribute.COMTIIntrinsicsAttribute1"]/*' />
        public COMTIIntrinsicsAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="COMTIIntrinsicsAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "COMTIIntrinsicsAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("COMTIIntrinsics", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="IISIntrinsicsAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class IISIntrinsicsAttribute : Attribute, IConfigurationAttribute
    {
        private bool _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="IISIntrinsicsAttribute.IISIntrinsicsAttribute"]/*' />
        public IISIntrinsicsAttribute() : this(true) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="IISIntrinsicsAttribute.IISIntrinsicsAttribute1"]/*' />
        public IISIntrinsicsAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="IISIntrinsicsAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "IISIntrinsicsAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("IISIntrinsics", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventTrackingEnabledAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    [ComVisible(false)]
    public sealed class EventTrackingEnabledAttribute : Attribute, IConfigurationAttribute
    {
        private bool _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventTrackingEnabledAttribute.EventTrackingEnabledAttribute"]/*' />
        public EventTrackingEnabledAttribute() : this(true) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventTrackingEnabledAttribute.EventTrackingEnabledAttribute1"]/*' />
        public EventTrackingEnabledAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventTrackingEnabledAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "EventTrackingEnabledAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("EventTrackingEnabled", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ExceptionClassAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    [ComVisible(false)]
    public sealed class ExceptionClassAttribute : Attribute, IConfigurationAttribute
    {
        private String _value;
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ExceptionClassAttribute.ExceptionClassAttribute"]/*' />
        public ExceptionClassAttribute(String name)
        {
            _value = name;
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ExceptionClassAttribute.Value"]/*' />
        public String Value { get { return(_value); } }
        
        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "ExceptionClassAttribute");
            
            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("ExceptionClass", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }
    
    // Load balancing supported?
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="LoadBalancingSupportedAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    [ComVisible(false)]
    public sealed class LoadBalancingSupportedAttribute : Attribute, IConfigurationAttribute    
    {
        private bool _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LoadBalancingSupportedAttribute.LoadBalancingSupportedAttribute"]/*' />
        public LoadBalancingSupportedAttribute() : this(true) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LoadBalancingSupportedAttribute.LoadBalancingSupportedAttribute1"]/*' />
        public LoadBalancingSupportedAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="LoadBalancingSupportedAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }
        
        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "LoadBalancingSupportedAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("LoadBalancingSupported", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }


    /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventClassAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    [ComVisible(false)]
    public sealed class EventClassAttribute : Attribute, IConfigurationAttribute
    {
        private bool _fireInParallel;
        private bool _allowInprocSubscribers;
        private String _filter;
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventClassAttribute.EventClassAttribute"]/*' />
        public EventClassAttribute() 
        { 
            _fireInParallel         = false;
            _allowInprocSubscribers = true;
            _filter = null;
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventClassAttribute.FireInParallel"]/*' />
        public bool FireInParallel
        {
            get { return(_fireInParallel); }
            set { _fireInParallel = value; }
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventClassAttribute.AllowInprocSubscribers"]/*' />
        public bool AllowInprocSubscribers
        {
            get { return(_allowInprocSubscribers); }
            set { _allowInprocSubscribers = value; }
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="EventClassAttribute.PublisherFilter"]/*' />
        public String PublisherFilter
        {
            get { return(_filter); }
            set { _filter = value; }
        }
        
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "EventClassAttribute");
            
            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            
            // assert that this guy is an event class?
            DBG.Info(DBG.Registration, "Setting FireIn...");
            obj.SetValue("FireInParallel", _fireInParallel);
            DBG.Info(DBG.Registration, "Setting Allow...");
            obj.SetValue("AllowInprocSubscribers", _allowInprocSubscribers);
            if(_filter != null)
            {
                obj.SetValue("MultiInterfacePublisherFilterCLSID", _filter);
            }
            return(true);
        }
        
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }   

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="PrivateComponentAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited = true)]
    [ComVisible(false)]
    public sealed class PrivateComponentAttribute : Attribute, IConfigurationAttribute
    {
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="PrivateComponentAttribute.PrivateComponentAttribute"]/*' />
        public PrivateComponentAttribute() {} 

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.Whistler, "PrivateComponentAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            obj.SetValue("IsPrivateComponent", true);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    //
    // Method-level attributes.
    //
    //
        
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="AutoCompleteAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method, Inherited = true)]
    [ComVisible(false)]
    public sealed class AutoCompleteAttribute : Attribute, IConfigurationAttribute
    {
        private bool _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="AutoCompleteAttribute.AutoCompleteAttribute"]/*' />
        public AutoCompleteAttribute() : this(true) {}

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="AutoCompleteAttribute.AutoCompleteAttribute1"]/*' />
        public AutoCompleteAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="AutoCompleteAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Method"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "AutoCompleteAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Method"]);
            obj.SetValue("AutoComplete", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    // 
    // Application level attributes.
    //
    //

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationActivationAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited = true)]
    [ComVisible(false)]
    public sealed class ApplicationActivationAttribute : Attribute, IConfigurationAttribute
    {
        private ActivationOption _value;
        private string _SoapVRoot;
        private string _SoapMailbox;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationActivationAttribute.ApplicationActivationAttribute"]/*' />
        public ApplicationActivationAttribute(ActivationOption opt)
        {
            _value = opt;            
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationActivationAttribute.Value"]/*' />
        public ActivationOption Value { get { return(_value); } }


		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationActivationAttribute.SoapVRoot"]/*' />
        public string SoapVRoot
        {
            get { return(_SoapVRoot); }
            set { _SoapVRoot = value; }
        }

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationActivationAttribute.SoapMailbox"]/*' />
        public string SoapMailbox
        {
            get { return(_SoapMailbox); }
            set { _SoapMailbox = value; }
        }
        
        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Application"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.MTS, "ApplicationActivationAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Application"]);

            // Translate into MTS speak:
            if(Platform.IsLessThan(Platform.W2K))
            {
                switch(_value)
                {
                case ActivationOption.Server: obj.SetValue("Activation", "Local"); break;
                case ActivationOption.Library: obj.SetValue("Activation", "Inproc"); break;
                default:
                    DBG.Assert(false, "Unknown activation type requested!");
                    break;
                }
            }
            else
            {
                obj.SetValue("Activation", _value);
            }

            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) 
        { 
            bool bRetVal = false;
            if(_SoapVRoot != null)
            {
                ICatalogObject obj = (ICatalogObject)(info["Application"]);
                Platform.Assert(Platform.Whistler, "ApplicationActivationAttribute.SoapVRoot");
                obj.SetValue("SoapActivated", true);
                obj.SetValue("SoapVRoot", _SoapVRoot);  
                bRetVal = true;
            }

            if(_SoapMailbox != null)
            {
                ICatalogObject obj = (ICatalogObject)(info["Application"]);
                Platform.Assert(Platform.Whistler, "ApplicationActivationAttribute.SoapMailbox");
                obj.SetValue("SoapActivated", true);
                obj.SetValue("SoapMailTo", _SoapMailbox);  
                bRetVal = true;
            }

            return bRetVal; 
        }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationNameAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited = true)]
    [ComVisible(false)]
    public sealed class ApplicationNameAttribute : Attribute, IConfigurationAttribute
    {
        private String _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationNameAttribute.ApplicationNameAttribute"]/*' />
        public ApplicationNameAttribute(String name)
        {
            _value = name;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationNameAttribute.Value"]/*' />
        public String Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Application"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.MTS, "ApplicationNameAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Application"]);
            obj.SetValue("Name", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationIDAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited = true)]
    [ComVisible(false)]
    public sealed class ApplicationIDAttribute : Attribute, IConfigurationAttribute
    {
        private Guid _value;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationIDAttribute.ApplicationIDAttribute"]/*' />
        public ApplicationIDAttribute(String guid)
        {
            // Should we validate that the guid is actually a guid?
            _value = new Guid(guid);
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationIDAttribute.Value"]/*' />
        public Guid Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Application"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            return(false);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationQueuingAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited=true)]
    [ComVisible(false)]
    public sealed class ApplicationQueuingAttribute : Attribute, IConfigurationAttribute
    {
        private bool _enabled;
        private bool _listen;
        private int _maxthreads;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationQueuingAttribute.ApplicationQueuingAttribute"]/*' />
        public ApplicationQueuingAttribute()
        {
            _enabled = true;
            _listen  = false;
            _maxthreads = 0;
        }
        
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationQueuingAttribute.Enabled"]/*' />
        public bool Enabled
        {
            get { return(_enabled); } 
            set { _enabled = value; }
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationQueuingAttribute.QueueListenerEnabled"]/*' />
        public bool QueueListenerEnabled
        {
            get { return(_listen); }
            set { _listen = value; }
        }


		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ApplicationQueuingAttribute.MaxListenerThreads"]/*' />
        public int MaxListenerThreads
        {
            get { return(_maxthreads); }
            set { _maxthreads = value; }
        }

        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Application"); }
        
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "ApplicationQueueingAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Application"]);
            obj.SetValue("QueuingEnabled", _enabled);
            obj.SetValue("QueueListenerEnabled", _listen);
            
            if(_maxthreads != 0)
            {
                Platform.Assert(Platform.Whistler, "ApplicationQueuingAttribute.MaxListenerThreads");
                obj.SetValue("QCListenerMaxThreads", _maxthreads);
            }
            
            return(true);
        }

        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }
    
    //
    // Interface level attributes.
    //
    //
    
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceQueuingAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Interface|AttributeTargets.Class, Inherited=true, AllowMultiple=true)]
    [ComVisible(false)]
    public sealed class InterfaceQueuingAttribute : Attribute, IConfigurationAttribute
    {
        private bool   _enabled;
        private String _interface;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceQueuingAttribute.InterfaceQueuingAttribute"]/*' />
        public InterfaceQueuingAttribute()
        {
            _enabled = true;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceQueuingAttribute.InterfaceQueuingAttribute1"]/*' />
        public InterfaceQueuingAttribute(bool enabled)
        {
            _enabled = enabled;
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceQueuingAttribute.Enabled"]/*' />
        public bool Enabled
        {
            get { return(_enabled); } 
            set { _enabled = value; }
        }

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="InterfaceQueuingAttribute.Interface"]/*' />
        public String Interface
        {
            get { return(_interface); }
            set { _interface = value; }
        }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) 
        { 
            if(_interface == null)
            {
                return(s == "Interface"); 
            }
            else
            {
                DBG.Info(DBG.Registration, "**** Interface queueing for component: ");
                return(s == "Component");
            }
        }

        private bool ConfigureInterface(ICatalogObject obj)
        {
            DBG.Info(DBG.Registration, "Checking to see if queueing supported:");
            bool supported = (bool)(obj.GetValue("QueuingSupported"));
            
            if(_enabled && supported)
            {
                DBG.Info(DBG.Registration, "Setting Queuing enabled:");
                obj.SetValue("QueuingEnabled", _enabled);
            }
            else if(_enabled)
            {
                DBG.Info(DBG.Registration, "Error on queueing enabled");
                throw new RegistrationException(Resource.FormatString("Reg_QueueingNotSupported", (String)(obj.Name())));
            }
            else // _enabled == false
            {
                DBG.Info(DBG.Registration, "Not enabling queuing:");
                obj.SetValue("QueuingEnabled", _enabled);
            }

            return(true);
        }

        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "InterfaceQueuingAttribute");
            
            if(_interface == null)
            {
                DBG.Info(DBG.Registration, "Getting interface object out of dict");
                ICatalogObject obj = (ICatalogObject)(info["Interface"]);
                ConfigureInterface(obj);
            }

            return(true);
        }

        internal static Type ResolveTypeRelativeTo(String typeName, Type serverType)
        {
            Type iface  = null;
            Type result = null;
            bool exact = false;
            bool multiple = false;
            // compare against the interface list
            // GetInterfaces() returns a complete list of interfaces this type supports
            Type[] interfaces = serverType.GetInterfaces();
            for(int i = 0; i < interfaces.Length; i++)
            {
                iface = interfaces[i];
                String ifcname = iface.FullName;
                int startB = ifcname.Length - typeName.Length;
                if (startB >= 0 
                    && String.CompareOrdinal(typeName, 0, ifcname, startB, typeName.Length) == 0)
                {
                    // One last sanity check:  If the user has specified IFoo, we might have matched to
                    // something of the form BIFoo.  Make sure that the starting match point is a .
                    if(startB == 0 || (startB > 0 && ifcname[startB-1] == '.'))
                    {
                        if(result == null)
                        {
                            result = iface;
                            exact = (startB == 0);
                        }
                        else
                        {
                            // We had a previous match.  4 cases:
                            // a) if previous match exact, this match not, ignore.
                            // b) if this match exact, previous not, this one is right.
                            // c) neither exact, go with the first match.
                            // d) both exact: ambiguous match error.
                            if(result != null) multiple = true;  // Always denote multiple 
                            
                            if(result != null && exact)
                            {
                                // d)
                                if(startB == 0) throw new AmbiguousMatchException(Resource.FormatString("Reg_IfcAmbiguousMatch", typeName, iface, result));
                                // a) - ignore
                            }
                            else if(result != null && !exact && startB == 0) // b)
                            {
                                result = iface;
                                exact = true;
                            }
                        }
                    }
                }                
            }

            // If we matched multiple results, and neither was exact, throw an exception:
            if(multiple && !exact)
            {
                throw new AmbiguousMatchException(Resource.FormatString("Reg_IfcAmbiguousMatch", typeName, iface, result));
            }

            return(result);
        }

        internal static Type FindInterfaceByName(String name, Type component)
        {
            Type t = ResolveTypeRelativeTo(name, component);
            if(t == null)
            {
                // Try to look up with an Assembly.Load...
                t = Type.GetType(name, false);
            }
            if(t != null)
            {
                DBG.Info(DBG.Registration, "Matched string \"" + name + "\" to interface " + t.AssemblyQualifiedName);
            }
            return(t);
        }

        private void FindInterfaceByKey(String key, 
                                        ICatalogCollection coll, 
                                        Type comp,
                                        out ICatalogObject ifcObj,
                                        out Type ifcType)
        {
            // Try by type:
            // Get the list of interfaces this guy supports:
            DBG.Info(DBG.Registration, "**** Searching for interface: " + key);
            ifcType = FindInterfaceByName(key, comp);
            if(ifcType == null)
            {
                throw new RegistrationException(Resource.FormatString("Reg_TypeFindError", key, comp.ToString()));
            }
            
            // Search through the collection for this type:
            Guid id = Marshal.GenerateGuidForType(ifcType);

            Object[] keys = { "{" + id + "}" };
            coll.PopulateByKey(keys);

            if(coll.Count() != 1)
            {
                throw new RegistrationException(Resource.FormatString("Reg_TypeFindError", key, comp.ToString()));
            }

            ifcObj = (ICatalogObject)(coll.Item(0));

            DBG.Info(DBG.Registration, "Found " + ifcObj.Name() + " for " + key);
        }

        private void StashModification(Hashtable cache, Type comp, Type ifc)
        {
            if(cache[comp] == null)
            {
                cache[comp] = new Hashtable();
            }
            ((Hashtable)(cache[comp]))[ifc] = (Object)true;
        }

        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) 
        { 
            // If this is an interface on a component, then we need to
            // get the interface out of the ifc collection, and configure it:
            if(_interface != null)
            {
                DBG.Assert((String)(info["CurrentTarget"]) == "Component",
                           "Applying interface attribute on non-component target!");
                
                DBG.Info(DBG.Registration, "Adding queueing to interface " + _interface);
                
                ICatalogCollection compColl = (ICatalogCollection)(info["ComponentCollection"]);
                ICatalogObject     compObj = (ICatalogObject)(info["Component"]);
                Type               compType = (Type)(info["ComponentType"]);
                
                ICatalogCollection ifcColl = (ICatalogCollection)(compColl.GetCollection("InterfacesForComponent", compObj.Key()));
                
                // Find the interface key:  Try loading it?
                ICatalogObject ifcObj;
                Type ifcType;
                FindInterfaceByKey(_interface, ifcColl, compType, out ifcObj, out ifcType);
                ConfigureInterface(ifcObj);

                // Save changes to interface collection (blech!)
                ifcColl.SaveChanges();
                DBG.Info(DBG.Registration, "Saved changes to interface...");
                // We need to stuff this pair into the cache so that
                // we know not to blow this change away later!
                StashModification(info, compType, ifcType);
            }
            return(false); 
        }
    }

	
    //
    // Miscellaneous attributes
    //
    //
    /// <include file='doc\Attributes.uex' path='docs/doc[@for="DescriptionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Method|AttributeTargets.Interface|AttributeTargets.Class, Inherited=true)]
    [ComVisible(false)]
    public sealed class DescriptionAttribute : Attribute, IConfigurationAttribute
    {
        String _desc;

        /// <include file='doc\Attributes.uex' path='docs/doc[@for="DescriptionAttribute.DescriptionAttribute"]/*' />
        public DescriptionAttribute(String desc) 
        { 
            _desc = desc;
        }

        bool IConfigurationAttribute.IsValidTarget(String s) 
        { 
            return(s == "Application" || 
                   s == "Component" || 
                   s == "Interface" || 
                   s == "Method"); 
        }

        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.MTS, "DescriptionAttribute");

            String target = (String)(info["CurrentTarget"]);
            ICatalogObject obj = (ICatalogObject)(info[target]);
            obj.SetValue("Description", _desc);
            return(true);
        }        

        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

	
	// helper class to introspect the config attributes
	/// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo"]/*' />
	internal sealed class ServicedComponentInfo
    {
        private static RWHashTable _SCICache;
        private static RWHashTable _MICache;
        private static Hashtable _ExecuteMessageCache;
      
        /// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo.ServicedComponentInfo"]/*' />
        static ServicedComponentInfo()
        {
        	_SCICache = new RWHashTable();        	
        	_MICache = new RWHashTable();
        	_ExecuteMessageCache = new Hashtable();

        	AddExecuteMethodValidTypes();
        }
		
		private static bool IsTypeServicedComponent2(Type t)
		{
            return(t.IsSubclassOf(typeof(ServicedComponent)));
		}
		
		private static bool IsTypeJITActivated2(Type t)
		{
                Object[] attr = t.GetCustomAttributes(true);
                foreach(Object a in attr)
                {
                    if(a is JustInTimeActivationAttribute) 
					{
						return ((JustInTimeActivationAttribute)a).Value;
					}
                    if(a is TransactionAttribute)
                    {
                        int val = (int)((TransactionAttribute)a).Value;
                        if (val >= 2)
                        {
                            return true;
                        }
                    }
                }
			return false;
		}

		private static bool IsTypeEventSource2(Type t)
		{
                Object[] attr = t.GetCustomAttributes(true);
                foreach(Object a in attr)
                {
                    if(a is EventClassAttribute) 
					{
						return true;
					}
                }
			return false;
		}

		internal const int SCI_PRESENT = 0x1;	// not needed any more
		internal const int SCI_SERVICEDCOMPONENT = 0x2;
		internal const int SCI_EVENTSOURCE = 0x4;
		internal const int SCI_JIT = 0x8;
		internal const int SCI_OBJECTPOOLED = 0x10;
		internal const int SCI_METHODSSECURE = 0x20;
		internal const int SCI_CLASSINTERFACE = 0x40;
		

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo.IsTypeEventSource"]/*' />
		public static bool IsTypeEventSource(Type t)
		{
			return (SCICachedLookup(t) & SCI_EVENTSOURCE)!=0;
		}
		
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo.IsTypeJITActivated"]/*' />
		public static bool IsTypeJITActivated(Type t)
		{
			return (SCICachedLookup(t) & SCI_JIT)!=0;
		}
		
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo.IsTypeServicedComponent"]/*' />
		public static bool IsTypeServicedComponent(Type t)
		{
			return (SCICachedLookup(t) & SCI_SERVICEDCOMPONENT)!=0;
		}
		

		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo.IsTypeObjectPooled"]/*' />
		public static bool IsTypeObjectPooled(Type t)
		{
			return (SCICachedLookup(t) & SCI_OBJECTPOOLED)!=0;
		}
		
		internal static bool AreMethodsSecure(Type t)
		{
			return (SCICachedLookup(t) & SCI_METHODSSECURE)!=0;
		}
		
		internal static bool HasClassInterface(Type t)
		{
			return (SCICachedLookup(t) & SCI_CLASSINTERFACE)!=0;
		}
		
		internal static int SCICachedLookup(Type t)
		{
			Object o = _SCICache.Get(t);
			
			if (o!=null)			// a hit
			{
				return (int)o;
			}
			else					// a miss
			{
				int sci = 0;
				
				if(IsTypeServicedComponent2(t))
				{
					sci |= SCI_SERVICEDCOMPONENT;
					
					if (IsTypeEventSource2(t))
						sci |= SCI_EVENTSOURCE;
				
					if (IsTypeJITActivated2(t))
						sci |= SCI_JIT;
					
					if (IsTypeObjectPooled2(t))
						sci |= SCI_OBJECTPOOLED;
				}
				if (AreMethodsSecure2(t))
					sci |= SCI_METHODSSECURE;
					
				if (HasClassInterface2(t))
					sci |= SCI_CLASSINTERFACE;				
					
				_SCICache.Put(t, sci);
				
				return sci;
			}
		}
				

		private static bool IsTypeObjectPooled2(Type t)
		{
                Object[] attr = t.GetCustomAttributes(typeof(ObjectPoolingAttribute), true);
                if(attr != null && attr.Length > 0) 
                {
                    return (bool)((ObjectPoolingAttribute)attr[0]).Enabled;
                }
			return false;		
		}


		internal const int MI_PRESENT = 0x1;	// not needed any more
		internal const int MI_AUTODONE = 0x2;
		internal const int MI_HASSPECIALATTRIBUTES = 0x4;
		internal const int MI_EXECUTEMESSAGEVALID = 0x08;
		
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo.IsMethodAutoDone"]/*' />
		public static bool IsMethodAutoDone(MemberInfo m)
		{
			return (MICachedLookup(m) & MI_AUTODONE)!=0;
		}
		
		/// <include file='doc\Attributes.uex' path='docs/doc[@for="ServicedComponentInfo.HasSpecialMethodAttributes"]/*' />
		public static bool HasSpecialMethodAttributes(MemberInfo m)
		{
			return (MICachedLookup(m) & MI_HASSPECIALATTRIBUTES)!=0;
		}

		public static bool IsExecuteMessageValid(MemberInfo m)
		{
			return (MICachedLookup(m) & MI_EXECUTEMESSAGEVALID)!=0;
		}

		internal static int MICachedLookup(MemberInfo m)
		{
			Object o = _MICache.Get(m);
			
			if (o!=null)			// a hit
			{
				return (int)o;
			}
			else					// a miss
			{
				int mi = 0;
				
				if (IsMethodAutoDone2(m))
					mi |= MI_AUTODONE;
				
				if (HasSpecialMethodAttributes2(m))
					mi |= MI_HASSPECIALATTRIBUTES;

				if (IsExecuteMessageValid2(m))
					mi |= MI_EXECUTEMESSAGEVALID;

				_MICache.Put(m, mi);
				
				return mi;
			}
		}
				
		private static bool IsExecuteMessageValid2(MemberInfo m)
		{
			// verify method is on an interface
			MemberInfo intfMemInfo = ReflectionCache.ConvertToInterfaceMI(m);
			if (intfMemInfo == null)
				return false;
			
			MethodInfo mti = m as MethodInfo;
			if (mti == null)
				return false;

			// go through paramters, veryifying they're valid
			foreach (ParameterInfo p in mti.GetParameters())
				if (!IsTypeExecuteMethodValid(p.ParameterType))
					return false;
			
			// check return type
			if (!IsTypeExecuteMethodValid(mti.ReturnType))
				return false;

			return true;
		}

		private static bool IsTypeExecuteMethodValid(Type t)
		{
			if (t.IsEnum)
				return true;
			
			Type eltType = t.GetElementType();

			if ((eltType != null) && (t.IsByRef || t.IsArray))
			{
				if (_ExecuteMessageCache[eltType] == null)
					return false;
			}
			else
			{
				if (_ExecuteMessageCache[t] == null)
					return false;
			}
			
			return true;
		}

		private static void AddExecuteMethodValidTypes()
		{
			_ExecuteMessageCache.Add(typeof(System.Boolean), true);
			_ExecuteMessageCache.Add(typeof(System.Byte), true);
			_ExecuteMessageCache.Add(typeof(System.Char), true);
			_ExecuteMessageCache.Add(typeof(System.DateTime), true);
			_ExecuteMessageCache.Add(typeof(System.Decimal), true);
			_ExecuteMessageCache.Add(typeof(System.Double), true);
			_ExecuteMessageCache.Add(typeof(System.Guid), true);
			_ExecuteMessageCache.Add(typeof(System.Int16), true);
			_ExecuteMessageCache.Add(typeof(System.Int32), true);
			_ExecuteMessageCache.Add(typeof(System.Int64), true);
			_ExecuteMessageCache.Add(typeof(System.IntPtr), true);
			_ExecuteMessageCache.Add(typeof(System.SByte), true);
			_ExecuteMessageCache.Add(typeof(System.Single), true);
			_ExecuteMessageCache.Add(typeof(System.String), true);
			_ExecuteMessageCache.Add(typeof(System.TimeSpan), true);
			_ExecuteMessageCache.Add(typeof(System.UInt16), true);
			_ExecuteMessageCache.Add(typeof(System.UInt32), true);
			_ExecuteMessageCache.Add(typeof(System.UInt64), true);
			_ExecuteMessageCache.Add(typeof(System.UIntPtr), true);
			_ExecuteMessageCache.Add(typeof(void), true); // can't use System.Void
		}
		
		private static bool IsMethodAutoDone2(MemberInfo m)
		{			
			Object[] attr = m.GetCustomAttributes(typeof(AutoCompleteAttribute), true);
            foreach(Object a in attr)
            {
                DBG.Assert(a is AutoCompleteAttribute, "GetCustomAttributes returned a non-autocomplete attribute");
                return ((AutoCompleteAttribute)a).Value;
            }
			return false;
		}

		private static bool HasSpecialMethodAttributes2(MemberInfo m)
		{
			Object[] attr = m.GetCustomAttributes(true);
            foreach(Object a in attr)
            {
            	// any configuration attribute other than auto complete is
            	// special 
                if((a is IConfigurationAttribute) && !(a is AutoCompleteAttribute)) 
				{
					return true;
				}
            }
			return false;
		}

        private static bool AreMethodsSecure2(Type t)
        {
            Object[] attr = t.GetCustomAttributes(typeof(SecureMethodAttribute), true);
            if(attr != null && attr.Length > 0)
            {
                return(true);
            }
            return(false);
        }
        
        private static bool HasClassInterface2(Type t)
        {
            Object[] attr = t.GetCustomAttributes(typeof(ClassInterfaceAttribute), false);
            if(attr != null && attr.Length > 0)
            {
                ClassInterfaceAttribute cia = (ClassInterfaceAttribute)attr[0];
                if(cia.Value == ClassInterfaceType.AutoDual || 
                   cia.Value == ClassInterfaceType.AutoDispatch)
                    return(true);
            }
            
            // Gotta check the assembly if we found nothing on the type,
            // because we might have specified a global default.
            attr = t.Assembly.GetCustomAttributes(typeof(ClassInterfaceAttribute), true);
            if(attr != null && attr.Length > 0)
            {
                ClassInterfaceAttribute cia = (ClassInterfaceAttribute)attr[0];
                if(cia.Value == ClassInterfaceType.AutoDual || 
                   cia.Value == ClassInterfaceType.AutoDispatch)
                    return(true);
            }

            return(false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\icontextstate.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// IObjectControl interface allows the user to implement an interface to
// get Activate/Deactivate notifications from JIT and object pooling.
//
// Author: ddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System.Runtime.InteropServices;
    
    // The TransactionVote constants are used to set the
    // Context true/false operations.
    /// <include file='doc\IContextState.uex' path='docs/doc[@for="TransactionVote"]/*' />
    [ComVisible(false), Serializable]
    public enum TransactionVote
    {
        /// <include file='doc\IContextState.uex' path='docs/doc[@for="TransactionVote.Commit"]/*' />
        Commit = 0,
        /// <include file='doc\IContextState.uex' path='docs/doc[@for="TransactionVote.Abort"]/*' />
        Abort  = Commit+1,
    }

    [
     ComImport,
     Guid("3C05E54B-A42A-11D2-AFC4-00C04F8EE1C4"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IContextState
    {
        void SetDeactivateOnReturn([In, MarshalAs(UnmanagedType.Bool)] bool bDeactivate);
        
        [return : MarshalAs(UnmanagedType.Bool)]
        bool GetDeactivateOnReturn();
        
        void SetMyTransactionVote([In, MarshalAs(UnmanagedType.I4)] TransactionVote txVote);

        [return : MarshalAs(UnmanagedType.I4)]
        TransactionVote GetMyTransactionVote();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\igetcontextproperties.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: dddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    using System.Collections;

    [Guid("51372AF4-CAE7-11CF-BE81-00AA00A2FA25")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [ComImport]
    internal interface IGetContextProperties
    {
        int Count {
            get;
        }
        
        Object GetProperty([In, MarshalAs(UnmanagedType.BStr)] String name);
        
        // BUGBUG:  IEnumerator should be return parameter.
        void GetEnumerator(out IEnumerator pEnum);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\exportutil.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: December 2000
//

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;

    /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="IAssemblyLocator"]/*' />
    [ComImport]
    [Guid("391ffbb9-a8ee-432a-abc8-baa238dab90f")]
    internal interface IAssemblyLocator
    {
        /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="IAssemblyLocator.GetModules"]/*' />
        String[] GetModules(String applicationDir, 
                            String applicationName,
                            String assemblyName);
    }
    
    
    /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="AssemblyLocator"]/*' />
    [Guid("458aa3b5-265a-4b75-bc05-9bea4630cf18")]
    public class AssemblyLocator : MarshalByRefObject, IAssemblyLocator
    {
        /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="AssemblyLocator.IAssemblyLocator.GetModules"]/*' />
        String[] IAssemblyLocator.GetModules(String appdir, String appName, String name)
        {
            DBG.Info(DBG.Registration, "Finding modules for \"" + name + "\" at \"" + appdir + "\" in \"" + appName + "\"");

            if(appdir != null && appdir.Length > 0)
            {
                AssemblyLocator loc = null;
                try
                {
                // Spawn off an app-domain with the given directory as
                // the root search path:
                AppDomainSetup domainOptions = new AppDomainSetup();
                
         	  	domainOptions.ApplicationBase = appdir;
        	    AppDomain domain = AppDomain.CreateDomain(appName,
                                                          null,
                                                          domainOptions);
	            if(domain != null)
                    {
                        AssemblyName n = typeof(AssemblyLocator).Assembly.GetName();
                        
                        ObjectHandle h = domain.CreateInstance(n.FullName, typeof(AssemblyLocator).FullName);
                        if(h != null)
                        {
                            loc = (AssemblyLocator) h.Unwrap();
                        }
                    }
                }
                catch(Exception e)
                {
                    DBG.Info(DBG.Registration, "Exception: " + e);
                    return(null);
                }

                return(((IAssemblyLocator)loc).GetModules(null, null, name));
            }

            // Otherwise, Just load the assembly and be done with it:
            try
            {
                Assembly asm = Assembly.Load(name);
                if(asm == null)
                {
                    // TODO: error?
                    DBG.Info(DBG.Registration, "Couldn't load assembly!");
                }
                Module[] modules = asm.GetModules();
                String[] names = new String[modules.Length];
                
                for(int i = 0; i < modules.Length; i++)
                {
                    names[i] = modules[i].FullyQualifiedName;
                }

                return(names);
            }
            catch(Exception e)
            {
                DBG.Info(DBG.Registration, "Exception loading assembly: " + e);
                throw e;
            }
        }
    }

    /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="IAppDomainHelper"]/*' />
    [ComImport]
    [Guid("c7b67079-8255-42c6-9ec0-6994a3548780")]
    internal interface IAppDomainHelper
    {
        /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="IAppDomainHelper.Initialize"]/*' />
        void Initialize(IntPtr pUnkAD, IntPtr pfnShutdownCB, IntPtr data);

       /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="IAppDomainHelper.DoCallback"]/*' />
        void DoCallback(IntPtr pUnkAD, IntPtr pfnCallbackCB, IntPtr data);
    }

    /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="AppDomainHelper"]/*' />
    [Guid("ef24f689-14f8-4d92-b4af-d7b1f0e70fd4")]
    public class AppDomainHelper : IAppDomainHelper
    {
        private class CallbackWrapper
        {
            private IntPtr _pfnCB;
            private IntPtr _pv;

            public CallbackWrapper(IntPtr pfnCB, IntPtr pv)
            {
                _pfnCB = pfnCB;
                _pv    = pv;
            }
            
            public void ReceiveCallback()
            {
                DBG.Info(DBG.Pool, "AppDomainHelper.CallbackWrapper: delivering CB.");
                int hr = Thunk.Proxy.CallFunction(_pfnCB, _pv);
                if(hr < 0) Marshal.ThrowExceptionForHR(hr);
                DBG.Info(DBG.Pool, "AppDomainHelper.CallbackWrapper: done.");
            }
        }

        private AppDomain _ad;
        private IntPtr    _pfnShutdownCB;
        private IntPtr    _punkPool;

        /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="AppDomainHelper.AppDomainHelper"]/*' />
        public AppDomainHelper() {}
        
        /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="AppDomainHelper.IAppDomainHelper.Initialize"]/*' />
        void IAppDomainHelper.Initialize(IntPtr pUnkAD, IntPtr pfnShutdownCB, IntPtr punkPool)
        {
            _ad = (AppDomain)Marshal.GetObjectForIUnknown(pUnkAD);
            DBG.Assert(_ad == AppDomain.CurrentDomain, "Call to AppDomainHelper.Initialize in wrong AD");

            _pfnShutdownCB  = pfnShutdownCB;
            _punkPool       = punkPool;
            Marshal.AddRef(_punkPool);

            _ad.DomainUnload += new EventHandler(this.OnDomainUnload);
        }

        /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="AppDomainHelper.IAppDomainHelper.DoCallback"]/*' />
        void IAppDomainHelper.DoCallback(IntPtr pUnkAD, IntPtr pfnCallbackCB, IntPtr data)
        {
#if _DEBUG
            AppDomain ad = (AppDomain)Marshal.GetObjectForIUnknown(pUnkAD);
            DBG.Assert(ad == _ad, "Call to AppDomainHelper.DoCallback for wrong AD");
#endif
            // DoCallback:
            CallbackWrapper wrap = new CallbackWrapper(pfnCallbackCB, data);

            if(_ad != AppDomain.CurrentDomain)
            {
                DBG.Info(DBG.Pool, "AppDomainHelper.DoCallback: the current domain differs from the passed domain.");
                _ad.DoCallBack(new CrossAppDomainDelegate(wrap.ReceiveCallback));
                DBG.Info(DBG.Pool, "AppDomainHelper.DoCallback: done with callback.");
            }
            else
            {
                DBG.Info(DBG.Pool, "AppDomainHelper.DoCallback: the current domain matches.");
                wrap.ReceiveCallback();
            }
        }

        // callback for shutdown delegate:
        private void OnDomainUnload(Object sender, EventArgs e)
        {
            DBG.Assert(AppDomain.CurrentDomain == _ad, "Call to AppDomainHelper.OnDomainUnload for wrong AD");
            // Our domain is being unloaded, it's time to call the
            // unmanaged world back...
            if(_pfnShutdownCB != IntPtr.Zero)
            {
                DBG.Info(DBG.Pool, "AppDomainHelper.OnDomainUnload: delivering callback.");
                Thunk.Proxy.CallFunction(_pfnShutdownCB, _punkPool);
                _pfnShutdownCB = IntPtr.Zero;
                Marshal.Release(_punkPool);
                _punkPool = IntPtr.Zero;
                DBG.Info(DBG.Pool, "OnDomainUnload: done.");
            }
        }

        /// <include file='doc\ExportUtil.uex' path='docs/doc[@for="AppDomainHelper.Finalize"]/*' />
        ~AppDomainHelper()
        {
            if(_punkPool != IntPtr.Zero)
            {
                Marshal.Release(_punkPool);
                _punkPool = IntPtr.Zero;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\crm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//

/// <include file='doc\CRM.uex' path='docs/doc[@for="CRM"]/*' />
namespace System.EnterpriseServices.CompensatingResourceManager
{
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.IO;
    using System.EnterpriseServices.Admin;
    using System.Security.Permissions;

    /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags"]/*' />
    [Flags, Serializable]
    public enum LogRecordFlags
    {
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags.ForgetTarget"]/*' />
        ForgetTarget           = 0x00000001,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags.WrittenDuringPrepare"]/*' />
        WrittenDuringPrepare   = 0x00000002,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags.WrittenDuringCommit"]/*' />
        WrittenDuringCommit    = 0x00000004,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags.WrittenDuringAbort"]/*' />
        WrittenDuringAbort     = 0x00000008,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags.WrittenDurringRecovery"]/*' />
        WrittenDurringRecovery = 0x00000010,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags.WrittenDuringReplay"]/*' />
        WrittenDuringReplay    = 0x00000020,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecordFlags.ReplayInProgress"]/*' />
        ReplayInProgress       = 0x00000040,
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="CompensatorOptions"]/*' />
    [Flags, Serializable]
    public enum CompensatorOptions
    {
        /// <include file='doc\CRM.uex' path='docs/doc[@for="CompensatorOptions.PreparePhase"]/*' />
        PreparePhase         = 0x00000001,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="CompensatorOptions.CommitPhase"]/*' />
        CommitPhase          = 0x00000002,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="CompensatorOptions.AbortPhase"]/*' />
        AbortPhase           = 0x00000004,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="CompensatorOptions.AllPhases"]/*' />
        AllPhases            = 0x00000007,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="CompensatorOptions.FailIfInDoubtsRemain"]/*' />
        FailIfInDoubtsRemain = 0x00000010,
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="TransactionState"]/*' />
	[Serializable]
    public enum TransactionState
    {
        /// <include file='doc\CRM.uex' path='docs/doc[@for="TransactionState.Active"]/*' />
        Active    = 0x0,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="TransactionState.Committed"]/*' />
        Committed = 0x1,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="TransactionState.Aborted"]/*' />
        Aborted   = 0x2,
        /// <include file='doc\CRM.uex' path='docs/doc[@for="TransactionState.Indoubt"]/*' />
        Indoubt   = 0x3
    }

    [ComImport]
    [Guid("BBC01830-8D3B-11D1-82EC-00A0C91EEDE9")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface _ICompensator
    {
        void _SetLogControl(IntPtr logControl);
        void _BeginPrepare();

        [return: MarshalAs(UnmanagedType.Bool)]
        bool _PrepareRecord(_LogRecord record);

        [return: MarshalAs(UnmanagedType.Bool)]
        bool _EndPrepare();

        void _BeginCommit(bool fRecovery);

        [return: MarshalAs(UnmanagedType.Bool)]
        bool _CommitRecord(_LogRecord record);

        void _EndCommit();

        void _BeginAbort(bool fRecovery);

        [return: MarshalAs(UnmanagedType.Bool)]
        bool _AbortRecord(_LogRecord record);

        void _EndAbort();
    }

    [ComImport]
    [Guid("70C8E441-C7ED-11D1-82FB-00A0C91EEDE9")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface _IMonitorLogRecords
    {
        int Count {
            get;
        }


        TransactionState TransactionState { 
            get; 
        }

        
        bool StructuredRecords
        {
            [return: MarshalAs(UnmanagedType.VariantBool)] get;
        }

        void GetLogRecord([In] int dwIndex, 
                          [In,Out,MarshalAs(UnmanagedType.LPStruct)] ref _LogRecord pRecord);

        Object GetLogRecordVariants([In] Object IndexNumber);
    }
    
    [ComImport]
    [Guid("9C51D821-C98B-11D1-82FB-00A0C91EEDE9")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface _IFormatLogRecords
    {
        int GetColumnCount();
        // Must return a safe-array of strings
        Object GetColumnHeaders();
        Object GetColumn([In] _LogRecord crmLogRec);
        Object GetColumnVariants([In] Object logRecord);
    }

    internal interface IFormatLogRecords
    {
        int      ColumnCount { get; }
        String[] ColumnHeaders { get; }
        String[] Format(LogRecord r);
    }

    [
     ComImport,
     Guid("ECABB0BE-7F19-11D2-978E-0000F8757E2A")
    ]
    internal class xRecoveryClerk {}

    internal class BlobPackage
    {
        private GCHandle _handle;
        private byte[]   _bits;

        internal _BLOB  Blob;
        internal int    Size { get { return(Blob.cbSize); } }

        internal BlobPackage(_BLOB b) 
        { 
            Blob    = b; 
            _bits   = null;
        }
        internal BlobPackage(byte[] arr, int len) 
        {
            _bits          = arr;
            _handle        = GCHandle.Alloc(arr, GCHandleType.Pinned);
            Blob.cbSize    = len;
            Blob.pBlobData = _handle.AddrOfPinnedObject();
        }

        internal byte[] GetBits()
        {
            if(_bits != null) return(_bits);

            // Rip some bits out of the blob we hold:
            byte[] r = new byte[Blob.cbSize];
            Marshal.Copy(Blob.pBlobData, r, 0, Blob.cbSize);
            return(r);
        }

        internal void Free()
        {
            if(_bits != null) _handle.Free();
        }
    }

    internal class Packager
    {
        private static BinaryFormatter _ser;
        private static volatile bool   _initialized = false;

        private static void Init()
        {
            if(!_initialized)
            {
                lock(typeof(Packager))
                {
                    if(!_initialized)
                    {
                        StreamingContext ctx;
                        ctx = new StreamingContext(StreamingContextStates.Persistence
                                                   | StreamingContextStates.File);

                        _ser = new BinaryFormatter(null, ctx);
                                                   
                        _initialized = true;
                    }
                }
            }
        }

        internal static Object Deserialize(BlobPackage b)
        {
            Init();
            byte[] r = b.GetBits();
            // We should have marshalled this puppy into an array.
            return(_ser.Deserialize(new MemoryStream(r, false)));
        }
        
        internal static byte[] Serialize(Object o)
        {
            Init();

            MemoryStream s = new MemoryStream();
            _ser.Serialize(s, o);
            
            return(s.GetBuffer());
        }
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecord"]/*' />
    public sealed class LogRecord
    {
        internal LogRecordFlags _flags;
        internal int            _seq;
        internal Object         _data;

        internal LogRecord() { _flags = 0; _seq = 0; _data = null; }

        internal LogRecord(_LogRecord r)
        {
            _flags = (LogRecordFlags)r.dwCrmFlags;
            _seq   = r.dwSequenceNumber;
            _data  = Packager.Deserialize(new BlobPackage(r.blobUserData));
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecord.Flags"]/*' />
        public LogRecordFlags Flags    { get { return(_flags); } }
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecord.Sequence"]/*' />
        public int            Sequence { get { return(_seq); } }
        /// <include file='doc\CRM.uex' path='docs/doc[@for="LogRecord.Record"]/*' />
        public Object         Record   { get { return(_data); } }
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator"]/*' />
    public class Compensator : ServicedComponent, _ICompensator, _IFormatLogRecords
    {
        private Clerk _clerk;

        void _ICompensator._SetLogControl(IntPtr logControl)
        {
            DBG.Info(DBG.CRM, "Compensator: Setting new clerk:");
            _clerk = new Clerk(new CrmLogControl(logControl)); 
        }

        // Deserialize the bugger first.
        bool _ICompensator._PrepareRecord(_LogRecord record)
        {
            DBG.Assert(_clerk != null, "Method call made on Compensator with no clerk!");

            DBG.Info(DBG.CRM, "Compensator: prepare-record");
            LogRecord R = new LogRecord(record);

            return(PrepareRecord(R));
        }
        
        bool _ICompensator._CommitRecord(_LogRecord record) 
        { 
            DBG.Assert(_clerk != null, "Method call made on Compensator with no clerk!");

            DBG.Info(DBG.CRM, "Compensator: commit-record");
            LogRecord R = new LogRecord(record);

            return(CommitRecord(R));
        }
        
        bool _ICompensator._AbortRecord(_LogRecord record) 
        {
            DBG.Assert(_clerk != null, "Method call made on Compensator with no clerk!");

            DBG.Info(DBG.CRM, "Compensator: abort-record");
            LogRecord R = new LogRecord(record);
            return(AbortRecord(R));
        }

        // Delegate immediately.
        void _ICompensator._BeginPrepare() { BeginPrepare(); }
        bool _ICompensator._EndPrepare() { return(EndPrepare()); }
        void _ICompensator._BeginCommit(bool fRecovery) { BeginCommit(fRecovery); }
        void _ICompensator._EndCommit() { EndCommit(); }
        void _ICompensator._BeginAbort(bool fRecovery) { BeginAbort(fRecovery); }
        void _ICompensator._EndAbort() { EndAbort(); }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.Compensator"]/*' />
        public Compensator() 
        {
            DBG.Info(DBG.CRM, "Compensator: created");
            _clerk = null;
        }

        // These methods should be over-ridden by the user in order to participate
        // in the transaction.
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.BeginPrepare"]/*' />
        public virtual void BeginPrepare()  {}
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.PrepareRecord"]/*' />
        public virtual bool PrepareRecord(LogRecord rec) { return(false); }
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.EndPrepare"]/*' />
        public virtual bool EndPrepare()    { return(true); }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.BeginCommit"]/*' />
        public virtual void BeginCommit(bool fRecovery) {}
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.CommitRecord"]/*' />
        public virtual bool CommitRecord(LogRecord rec) { return(false); }
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.EndCommit"]/*' />
        public virtual void EndCommit()    {}

        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.BeginAbort"]/*' />
        public virtual void BeginAbort(bool fRecovery) {}
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.AbortRecord"]/*' />
        public virtual bool AbortRecord(LogRecord rec)  { return(false); }
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.EndAbort"]/*' />
        public virtual void EndAbort()     {}

        /// <include file='doc\CRM.uex' path='docs/doc[@for="Compensator.Clerk"]/*' />
        public Clerk Clerk 
        { 
            get 
            { 
                // TODO:  Throw exception if this is called before the clerk is set!
                DBG.Assert(_clerk != null, "Method call made on Compensator with no clerk!");
                return(_clerk); 
            } 
        }
        

        // IFormatLogRecords implementation!
        int _IFormatLogRecords.GetColumnCount()
        {
            if(this is IFormatLogRecords)
            {
                return(((IFormatLogRecords)this).ColumnCount);
            }
            
            // Use our default implementation!
            return(3); // Flags, Record#, String rep
        }

        Object _IFormatLogRecords.GetColumnHeaders()
        {
            if(this is IFormatLogRecords)
            {
                return(((IFormatLogRecords)this).ColumnHeaders);
            }
            
            return(new String[] { Resource.FormatString("CRM_HeaderFlags"),
                                  Resource.FormatString("CRM_HeaderRecord"),
                                  Resource.FormatString("CRM_HeaderString") });
        }

        Object _IFormatLogRecords.GetColumn(_LogRecord r)
        {
            LogRecord real = new LogRecord(r);
                
            if(this is IFormatLogRecords)
            {
                return(((IFormatLogRecords)this).Format(real));
            }

            String[] format = new String[3];
            format[0] = real.Flags.ToString();
            format[1] = real.Sequence.ToString();
            format[2] = real.Record.ToString();
            return(format);
        }

        Object _IFormatLogRecords.GetColumnVariants(Object logRecord)
        {
            // We just throw here, because this compensator should never
            // be used for VARIANT compensation!
            throw new NotSupportedException();
        }
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk"]/*' />
    public sealed class Clerk
    {
        private CrmLogControl        _control;     // real log-control
        private CrmMonitorLogRecords _monitor;

        internal Clerk(CrmLogControl logControl)
        {
            DBG.Assert(logControl != null, "logControl object is null!");
            _control = logControl;
            _monitor = _control.GetMonitor();
        }
        
        private void ValidateCompensator(Type compensator)
        {
            DBG.Status(DBG.CRM, "Validating compensator: " + compensator);
            
            if(!compensator.IsSubclassOf(typeof(Compensator)))
            {
                // Throw an exception!
                throw new ArgumentException(Resource.FormatString("CRM_CompensatorDerive"));                
            }

            // We've gotta make sure that this puppy's available for
            // COM clients:
            if(!(new RegistrationServices()).TypeRequiresRegistration(compensator))
            {
                throw new ArgumentException(Resource.FormatString("CRM_CompensatorConstructor"));
            }

            DBG.Info(DBG.CRM, "Testing compensator instantiation:");

            // Create an instance of it just in case:
            ServicedComponent inst = (ServicedComponent)Activator.CreateInstance(compensator);
            if(inst == null)
            {
                throw new ArgumentException(Resource.FormatString("CRM_CompensatorActivate"));
            }
            DBG.Info(DBG.CRM, "'" + compensator + "' instantiation succeeded");
            
            // Make sure we forcibly get rid of the thing we just created immediately:
            // This has to happen in case it is pooled, otherwise we'll have to wait
            // for the GC to kick in.
            ServicedComponent.DisposeObject(inst);
            DBG.Info(DBG.CRM, "'" + compensator + "' is valid");
        }

        private void Init(String compensator, String description, CompensatorOptions flags)
        {
            // Create the logcontrol object:
            DBG.Info(DBG.CRM, "Creating the log-control object");
            _control = new CrmLogControl();

            DBG.Info(DBG.CRM, "Registering the compensator '" + compensator + "' w/ the control.");
            _control.RegisterCompensator(compensator, description, (int)flags);

            DBG.Info(DBG.CRM, "Getting monitor from log-control object");
            _monitor = _control.GetMonitor();
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.Clerk"]/*' />
        public Clerk(Type compensator, String description, CompensatorOptions flags)
        {
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
            sp.Demand();
            sp.Assert();
        
            Platform.Assert(Platform.W2K, "CRM");
            ValidateCompensator(compensator);

            String progid = "{" + Marshal.GenerateGuidForType(compensator) + "}";
            Init(progid, description, flags);
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.Clerk1"]/*' />
        public Clerk(String compensator, String description, CompensatorOptions flags)
        {
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
            sp.Demand();
            sp.Assert();
            
            Init(compensator, description, flags);
        }

        // ICrmLogControl methods
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.TransactionUOW"]/*' />
        public String TransactionUOW 
        { 
            get { return(_control.GetTransactionUOW()); }
        }

        // Force log records to be durable on disk.
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.ForceLog"]/*' />
        public void ForceLog() 
        {
            _control.ForceLog();
        }
        
        // Forget the last written log record.
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.ForgetLogRecord"]/*' />
        public void ForgetLogRecord() 
        {
            _control.ForgetLogRecord();
        }
        
        // Force an abort on the current transaction:
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.ForceTransactionToAbort"]/*' />
        public void ForceTransactionToAbort()
        {
            _control.ForceTransactionToAbort();
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.WriteLogRecord"]/*' />
        public void WriteLogRecord(Object record)
        {
            // Serialize the current log record, the write it to the
            // actual object.
            DBG.Info(DBG.CRM, "Clerk.WriteLogRecord: Serializing log record");
            byte[] buf = Packager.Serialize(record);

            DBG.Info(DBG.CRM, "Clerk.WriteLogRecord: Writing log record: size = " + buf.Length);
            _control.WriteLogRecord(buf);
            DBG.Info(DBG.CRM, "Clerk.WriteLogRecord: Done");
        }

        // ICrmMonitorLogRecords interface ...
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.LogRecordCount"]/*' />
        public int LogRecordCount { 
            get
            {
                return(_monitor.GetCount());
            }
        }
        
        LogRecord ReadLogRecord(int index)
        {
            _LogRecord record = _monitor.GetLogRecord(index);
            return(new LogRecord(record));
        }

        TransactionState TransactionState 
        {
            get 
            { 
                return((TransactionState)_monitor.GetTransactionState());
            }
        }

        // TODO:  Provide an enumerator over the log records?

        // BUGBUG:  We're calling release on this guy from the finalizer
        // thread, which isn't strictly correct.  If interop less smart,
        // we could use them to handle our pointers, but since they
        // try to do callbacks into random contexts and cause deadlocks,
        // we can't do that.
        /// <include file='doc\CRM.uex' path='docs/doc[@for="Clerk.Finalize"]/*' />
        ~Clerk()
        {
            if(_monitor != null) _monitor.Dispose();
            if(_control != null) _control.Dispose();
        }
    }

    
    //---------------------------------------------------------------------
    // Clerk Monitoring 

    [
     Guid("70C8E442-C7ED-11D1-82FB-00A0C91EEDE9"),
    ]
    internal interface _IMonitorClerks 
    {
        Object Item(Object index);

        [return: MarshalAs(UnmanagedType.Interface)]
        Object _NewEnum();
        int Count();
        Object ProgIdCompensator(Object index);
        Object Description(Object index);
        Object TransactionUOW(Object index);
        Object ActivityId(Object index);
    };

    internal class ClerkMonitorEnumerator : IEnumerator
    {
        private ClerkMonitor    _monitor;
        private int				_version;
        private int             _curIndex = -1;
        private int             _endIndex;
		private Object			_curElement;

        internal ClerkMonitorEnumerator(ClerkMonitor c) 
        { 
            _monitor	= c;
			_version	= c._version;
			_endIndex	= c.Count;
			_curElement	= null;
        }

        public virtual bool MoveNext() 
		{
			if (_version != _monitor._version) 
				throw new InvalidOperationException(Resource.FormatString("InvalidOperation_EnumFailedVersion"));

            if (_curIndex < _endIndex)
			    _curIndex++;

            if (_curIndex < _endIndex)
			{
	            _curElement = _monitor[_curIndex];
				return true;
	        }
			else
				_curElement = null;

			return false;
        }
    
        public virtual Object Current 
		{
			get 
			{
				if (_curIndex < 0) 
					throw new InvalidOperationException(Resource.FormatString("InvalidOperation_EnumNotStarted"));

				if (_curIndex >= _endIndex) 
					throw new InvalidOperationException(Resource.FormatString("InvalidOperation_EnumEnded"));

                return _curElement;
			}
		}
    
        public virtual void Reset()
		{
			if (_version != _monitor._version) 
				throw new InvalidOperationException(Resource.FormatString("InvalidOperation_EnumFailedVersion"));

            _curIndex	= -1;
			_curElement	= null;
        }
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor"]/*' />
    public sealed class ClerkMonitor : IEnumerable
    {
        internal CrmMonitor      _monitor;
        internal _IMonitorClerks _clerks;
		internal int			 _version;

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor.ClerkMonitor"]/*' />
        public ClerkMonitor()
        {
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
            sp.Demand();
            sp.Assert();
       
            _monitor = new CrmMonitor();
			_version = 0;
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor.Populate"]/*' />
        public void Populate()
        {
            _clerks = (_IMonitorClerks)_monitor.GetClerks();
			_version++;
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor.Count"]/*' />
        public int Count 
        { 
            get 
            { 
                DBG.Assert(_clerks != null, "CRM monitor collection has no clerks!");
                return(_clerks.Count());
            } 
        }
        
        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor.this"]/*' />
        public ClerkInfo this[int index] 
        {
            get 
            { 
                return(new ClerkInfo(index, _monitor, _clerks)); 
            }
        }
        
        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor.this1"]/*' />
        public ClerkInfo this[String index]
        {
            get { return(new ClerkInfo(index, _monitor, _clerks)); }
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator()
        {
            return(new ClerkMonitorEnumerator(this));
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkMonitor.Finalize"]/*' />
        ~ClerkMonitor()
        {
            _monitor.Release();
        }
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo"]/*' />
    public sealed class ClerkInfo
    {
        private Object          _index;
        private CrmMonitor      _monitor;
        private _IMonitorClerks _clerks;

        internal ClerkInfo(Object index, CrmMonitor monitor, _IMonitorClerks clerks)
        {
            _index   = index;
            _clerks  = clerks;
            _monitor = monitor;
            _monitor.AddRef();
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo.Clerk"]/*' />
        public Clerk Clerk
        { 
            get
            {
                return(new Clerk(_monitor.HoldClerk(InstanceId)));
            }
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo.InstanceId"]/*' />
        public String InstanceId
        { 
            get { return((String)(_clerks.Item(_index))); }
        }

        // TODO:  Should we translate this into an assembly/typename if 
        // the clsid turns out to be a URT component?
        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo.Compensator"]/*' />
        public String Compensator
        { 
            get { return((String)(_clerks.ProgIdCompensator(_index))); }
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo.Description"]/*' />
        public String Description
        { 
            get { return((String)(_clerks.Description(_index))); }
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo.TransactionUOW"]/*' />
        public String TransactionUOW
        { 
            get { return((String)(_clerks.TransactionUOW(_index))); }
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo.ActivityId"]/*' />
        public String ActivityId
        { 
            get { return((String)(_clerks.ActivityId(_index))); }
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ClerkInfo.Finalize"]/*' />
        ~ClerkInfo()
        {
            _monitor.Release();
        }
    }

    /// <include file='doc\CRM.uex' path='docs/doc[@for="ApplicationCrmEnabledAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited=true)]
    [ProgId("System.EnterpriseServices.Crm.ApplicationCrmEnabledAttribute")]
    [ComVisible(false)]
    public sealed class ApplicationCrmEnabledAttribute : Attribute, IConfigurationAttribute
    {
        private bool _value;

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ApplicationCrmEnabledAttribute.ApplicationCrmEnabledAttribute"]/*' />
        public ApplicationCrmEnabledAttribute() : this(true) {}
          
        /// <include file='doc\CRM.uex' path='docs/doc[@for="ApplicationCrmEnabledAttribute.ApplicationCrmEnabledAttribute1"]/*' />
        public ApplicationCrmEnabledAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\CRM.uex' path='docs/doc[@for="ApplicationCrmEnabledAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Application"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.W2K, "CrmEnabledAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Application"]);
            obj.SetValue("CRMEnabled", _value);
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\componentservices.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ComponentServices.cs
**
** Author:  RajaK
**
** Purpose: Defines the general purpose ComponentServices
**
** Date:    June 15 2000
**
===========================================================*/
namespace System.EnterpriseServices {   
    using System;
    using System.Threading;
	using System.Reflection;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Services;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
	using System.Runtime.InteropServices;
	using System.Text;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
	using System.Runtime.Serialization.Formatters;
	using System.Runtime.Serialization.Formatters.Binary;
	using System.IO;
	using System.Runtime.Remoting.Channels;
	using System.Runtime.Remoting.Channels.Http;
	
    internal class InterlockedStack 
    {
        private class Node
        {
            public Object   Object;
            public Node     Next;
            
            public Node(Object o)
            {
                Object = o;
                Next   = null;
            }
        }
        
        private Object _head;
        private int _count;
        
        public InterlockedStack()
        {
            _head = null;
        }
        
        public void Push(Object o)
        {
            Node n = new Node(o);
            
            while(true)
            {
                Object head = _head;
                ((Node)n).Next = (Node)head;
                if(Interlocked.CompareExchange(ref _head, n, head) == head)
                {
                    Interlocked.Increment(ref _count);
                    break;
                }
            }
        }
        
        public int Count { get { return(_count); } }
        
        public Object Pop()
        {
            while(true)
            {
                Object head = _head;
                if(head == null) return(null);
                Object next = ((Node)head).Next;
                
                if(Interlocked.CompareExchange(ref _head, next, head) == head)
                {
                    Interlocked.Decrement(ref _count);
                    return(((Node)head).Object);
                }
            }
        }
    }

    internal sealed class ComSurrogateSelector : ISurrogateSelector, ISerializationSurrogate
    {
        ISurrogateSelector _deleg;

        public ComSurrogateSelector()
        {
            _deleg = new RemotingSurrogateSelector();
        }

        public void ChainSelector(ISurrogateSelector next)
        {
            _deleg.ChainSelector(next);
        }

        public ISurrogateSelector GetNextSelector()
        {
            return(_deleg.GetNextSelector());
        }

        public ISerializationSurrogate GetSurrogate(Type type, StreamingContext ctx, out ISurrogateSelector selector)
        {
            selector = null;

            DBG.Info(DBG.SC, "CSS: GetSurrogate(" + type + ")");
            if(type.IsCOMObject)
            {
                selector = this;
                return(this);
            }

            return(_deleg.GetSurrogate(type, ctx, out selector));
        }

        public void GetObjectData(Object obj, SerializationInfo info, StreamingContext ctx)
        {
            if(!obj.GetType().IsCOMObject)
                throw new NotSupportedException();

            info.SetType(typeof(ComObjRef));
            info.AddValue("buffer", ComponentServices.GetDCOMBuffer(obj));
        }

        public Object SetObjectData(Object obj, SerializationInfo info, StreamingContext ctx, ISurrogateSelector sel)
        {
            throw new NotSupportedException();
        }
    }

    internal sealed class ComObjRef : IObjectReference, ISerializable
    {
        private Object _realobj;

        public ComObjRef(SerializationInfo info, StreamingContext ctx)
        {
            byte[] buffer = null;
            IntPtr pUnk = IntPtr.Zero;

            SerializationInfoEnumerator e = info.GetEnumerator();
            while(e.MoveNext())
            {
                if(e.Name.Equals("buffer"))
                {
                    buffer = (byte[])e.Value;
                }
            }
            
            DBG.Assert(buffer != null, "Buffer in ComObjRef is null!");

            try
            {
                pUnk = Thunk.Proxy.UnmarshalObject(buffer);
                _realobj = Marshal.GetObjectForIUnknown(pUnk);
            }
            finally
            {
                if(pUnk != IntPtr.Zero) Marshal.Release(pUnk);
            }

            if(_realobj == null) throw new NotSupportedException();
        }

        public Object GetRealObject(StreamingContext ctx)
        {
            return(_realobj);
        }
        
        public void GetObjectData(SerializationInfo info, StreamingContext ctx)
        {
            throw new NotSupportedException();
        }
    }

    internal sealed class ComponentSerializer
    {
        // At max, this cache will only take 10 MB of memory.
        static readonly int MaxBuffersCached = 40;
        static readonly int MaxCachedBufferLength = 256*1024;

        static InterlockedStack _stack = new InterlockedStack();

        MemoryStream _stream;
        ISurrogateSelector _selector;
        BinaryFormatter _formatter;
        StreamingContext _streamingCtx;
        HeaderHandler _headerhandler;
        Object _tp;

        public ComponentSerializer()
        {
            _stream = new MemoryStream(0);
            _selector = new ComSurrogateSelector();
            _formatter = new BinaryFormatter();
            _streamingCtx = new StreamingContext(StreamingContextStates.Other);
            _formatter.Context = _streamingCtx;
            _headerhandler = new HeaderHandler(TPHeaderHandler);
        }

        internal void SetStream(byte [] b)
        {
            _stream.SetLength(0);
            if (b != null)
            {
                _stream.Write(b,0,b.Length);
                _stream.Position = 0;
            }
        }

        internal byte[] MarshalToBuffer(Object o, out long numBytes)
        {
            DBG.Info(DBG.SC, "MarshalToBuffer(): " + o.GetType());
            SetStream(null);
            _formatter.SurrogateSelector = _selector;
            _formatter.AssemblyFormat = FormatterAssemblyStyle.Full;
            _formatter.Serialize(_stream, o, null);
            numBytes = _stream.Position;
            if ((numBytes %2) != 0)			// we want to make sure we're encoding even-sized buffers
            {
                _stream.WriteByte(0);
                numBytes++;
            }
            return _stream.GetBuffer();
        }

        public object TPHeaderHandler(Header[] Headers)
        {
            return _tp;
        }

        internal Object UnmarshalFromBuffer(byte [] b, Object tp)
        {
            Object o = null;
            SetStream(b);
            _tp = tp;
            try
            {
                _formatter.SurrogateSelector = null;
                _formatter.AssemblyFormat = FormatterAssemblyStyle.Simple;
                o = _formatter.Deserialize(_stream, _headerhandler);
            }
            finally
            {
                _tp = null;
            }
            return o;
        }

		internal Object UnmarshalReturnMessageFromBuffer(byte [] b, IMethodCallMessage msg)
        {
            SetStream(b);
            _formatter.SurrogateSelector = null;
            _formatter.AssemblyFormat = FormatterAssemblyStyle.Simple;
            return _formatter.DeserializeMethodResponse(_stream, null, (IMethodCallMessage)msg);
        }

        internal static ComponentSerializer Get()
        {
            ComponentSerializer serializer = (ComponentSerializer)_stack.Pop();

            if (serializer == null)
                serializer = new ComponentSerializer();

            return serializer;
        }

        internal void Release()
        {
            // Only put this back in the cache if it is of a reasonably
            // small size, and if we haven't cached to many things already:
            if((_stack.Count < MaxBuffersCached)
               && (_stream.Capacity < MaxCachedBufferLength))
            {
                _stack.Push(this);
            }
        }
    }

	internal sealed class ComponentServices
    {
        static UnicodeEncoding _encoder = new UnicodeEncoding();

        // TODO: @cleanup: Inline in the various places that need it.
		public static byte[] GetDCOMBuffer(Object o)
        {
            int cb = Thunk.Proxy.GetMarshalSize(o);

            DBG.Info(DBG.SC, "GetDCOMBuffer(): size = " + cb);
            if (cb == -1)
                throw new RemotingException(Resource.FormatString("Remoting_InteropError"));

            byte[] b = new byte[cb];

            if (!Thunk.Proxy.MarshalObject(o, b, cb))
            {
                throw new RemotingException(Resource.FormatString("Remoting_InteropError"));
            }

            return b;
        }

		internal static void InitializeRemotingChannels()
		{
			/*
			//@TODO figure out a clean way to ensure atleast one 
			// cross process channel is registered in this app domain
			
			// make sure there is atleast one channel in every App Domain
			IChannel[] channels = ChannelServices.RegisteredChannels;
			if (channels.Length == 0)
			{
				// No http channel that was listening found.
	            // Create a new channel.
    	        HttpChannel newHttpChannel = new HttpChannel(0);
        	    ChannelServices.RegisterChannel(newHttpChannel);
        	}
        	*/
		}
		
        // TODO:  Move to ServicedComponent static method
		public static void DeactivateObject(Object otp, bool disposing)
		{			
			RealProxy rp = RemotingServices.GetRealProxy(otp);
            ServicedComponentProxy scp = rp as ServicedComponentProxy;
            
            DBG.Assert(scp != null, "CS.DeactivateObject called on a non-ServicedComponentProxy");

       		if (!scp.IsProxyDeactivated)
            {
    			DBG.Assert(scp.HomeToken == Thunk.Proxy.GetCurrentContextToken(), "Deactivate called from wrong context");
    			
				if (scp.IsObjectPooled)
				{
					DBG.Info(DBG.SC, "CS.DeactivateObject calling ReconnectForPooling");
					ReconnectForPooling(scp);
				}
				
                // this would wack the real server also so do this last
                
				DBG.Info(DBG.SC, "CS.DeactivateObject calling scp.DeactivateProxy");
    			scp.DeactivateProxy(disposing);
    		}
    		
            DBG.Assert(scp.IsProxyDeactivated, "scp not deactive");
		}

        // TODO: @cleanup: Move to ServicedComponentProxy
		private static void ReconnectForPooling(ServicedComponentProxy scp)
		{
			Type serverType = scp.GetProxiedType();
			bool fIsJitActivated = scp.IsJitActivated;
			bool fIsTypePooled = scp.IsObjectPooled;
			bool fAreMethodsSecure = scp.AreMethodsSecure;
            ProxyTearoff tearoff = null;
            
            DBG.Assert(fIsTypePooled == true, "CS.ReconnectForPooling called on a non-pooled proxy!");
						
			DBG.Info(DBG.SC, "CS.ReconnectForPooling (type is pooled) "+serverType );
			ServicedComponent server = scp.DisconnectForPooling(ref tearoff);
						
	        // now setup a new SCP that we can add to the pool
	        // with the current server object and the CCW					
	        ServicedComponentProxy newscp = new ServicedComponentProxy(serverType, fIsJitActivated, fIsTypePooled, fAreMethodsSecure, false);
	            
	        DBG.Info(DBG.SC, "CS.ReconnectForPooling (calling newscp.ConnectForPooling)");
	        newscp.ConnectForPooling(scp, server, tearoff, false);
	        // switch the CCW from oldtp to new tp

			DBG.Info(DBG.SC, "CS.ReconnectForPooling (SwitchingWrappers)");
	        EnterpriseServicesHelper.SwitchWrappers(scp, newscp);

            // Strengthen the CCW:  The only reference now held is
            // the reference from the pool.
            if (tearoff != null)            
            	Marshal.ChangeWrapperHandleStrength(tearoff, false);
            Marshal.ChangeWrapperHandleStrength(newscp.GetTransparentProxy(), false);

		}
		
		private ComponentServices()
        {
        	// nobody should instantiate this class
        }    
        
        public static Object WrapIUnknownWithComObject(IntPtr i)
        {
        	return EnterpriseServicesHelper.WrapIUnknownWithComObject(i);
        }

        internal static String ConvertToString(IMessage reqMsg)
		{
            ComponentSerializer serializer = ComponentSerializer.Get();
            long numBytes;
            byte[] byteArray = serializer.MarshalToBuffer(reqMsg, out numBytes);
            String s = _encoder.GetString(byteArray, 0, (int)numBytes);		// downcast should be ok, looks like MemoryStream internally uses an int anyway
            serializer.Release();
			return s;
		}

		internal static IMessage ConvertToMessage(String s, Object tp)
		{
            ComponentSerializer serializer = ComponentSerializer.Get();
			byte[] byteArray = _encoder.GetBytes(s);
			IMessage retMsg = (IMessage)serializer.UnmarshalFromBuffer(byteArray, tp);
            serializer.Release();
			return retMsg;
		}

		internal static IMessage ConvertToReturnMessage(String s, IMessage mcMsg)
		{
            ComponentSerializer serializer = ComponentSerializer.Get();
			byte[] byteArray = _encoder.GetBytes(s);
			IMessage retMsg = (IMessage)serializer.UnmarshalReturnMessageFromBuffer(byteArray, (IMethodCallMessage)mcMsg);
            serializer.Release();
			return retMsg;
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\importutil.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.EnterpriseServices.Internal
{
    using System;
    using System.IO;
    using System.EnterpriseServices;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\ImportUtil.uex' path='docs/doc[@for="IComManagedImportUtil"]/*' />
    [Guid("c3f8f66b-91be-4c99-a94f-ce3b0a951039")]
    public interface IComManagedImportUtil
    {
        /// <include file='doc\ImportUtil.uex' path='docs/doc[@for="IComManagedImportUtil.GetComponentInfo"]/*' />
        [DispId(0x00000004)]void GetComponentInfo(
			[MarshalAs(UnmanagedType.BStr)] string assemblyPath,
 			[MarshalAs(UnmanagedType.BStr)] out string numComponents,
 			[MarshalAs(UnmanagedType.BStr)] out string componentInfo
            );

		/// <include file='doc\ImportUtil.uex' path='docs/doc[@for="IComManagedImportUtil.InstallAssembly"]/*' />
		[DispId(0x00000005)]
		void InstallAssembly([MarshalAs(UnmanagedType.BStr)] String filename, 
                             [MarshalAs(UnmanagedType.BStr)] String parname, 
                             [MarshalAs(UnmanagedType.BStr)] String appname);
	}

    /// <include file='doc\ImportUtil.uex' path='docs/doc[@for="ComManagedImportUtil"]/*' />
    [Guid("3b0398c9-7812-4007-85cb-18c771f2206f")]
    public class ComManagedImportUtil : IComManagedImportUtil
    {
        /// <include file='doc\ImportUtil.uex' path='docs/doc[@for="ComManagedImportUtil.GetComponentInfo"]/*' />
        public void GetComponentInfo(string assemblyPath, out string numComponents, out string componentInfo)
        {
            RegistrationServices rs = new RegistrationServices();
            Assembly asm = LoadAssembly(assemblyPath);
            
            Type[] asmTypes = rs.GetRegistrableTypesInAssembly(asm);
            
            int nComponents = 0;
            string s = "";
            
            foreach(Type t in asmTypes)
            {
                if (t.IsClass && t.IsSubclassOf(typeof(ServicedComponent)))
                {				
                    nComponents++;
                    string clsid = Marshal.GenerateGuidForType(t).ToString();;
                    string progId = Marshal.GenerateProgIdForType(t);
                    s+= progId + ",{" + clsid + "},";
                }
            }
            
            numComponents = nComponents.ToString();
            componentInfo = s;		
        }

        // returns the loaded Assembly, or null if could not load it
        private Assembly LoadAssembly(String assemblyFile)
        {
            string assemblyFullPath = Path.GetFullPath(assemblyFile).ToLower(CultureInfo.InvariantCulture);

            bool dirChanged = false;

            string assemblyDir = Path.GetDirectoryName(assemblyFullPath);
            string initialDir = Environment.CurrentDirectory;

            if(initialDir != assemblyDir) {
                Environment.CurrentDirectory = assemblyDir;
                dirChanged = true;
            }
            
            Assembly asm = null;
            try {
                asm = Assembly.LoadFrom(assemblyFullPath);
            }
            catch(Exception)
            {
            }

            if(dirChanged) Environment.CurrentDirectory = initialDir;
            return(asm);
        }	

        /// <include file='doc\ImportUtil.uex' path='docs/doc[@for="ComManagedImportUtil.InstallAssembly"]/*' />
        public void InstallAssembly(string asmpath, string parname, string appname)
        {
            try
            {
                DBG.Info(DBG.Registration, "Attempting install of " + asmpath + " to app " + appname + " in partition " + parname);
                String tlb = null;
                InstallationFlags flags = InstallationFlags.Default;

                RegistrationHelper h = new RegistrationHelper();
                h.InstallAssembly(asmpath, ref appname, parname, ref tlb, flags);
            }
            catch(Exception e)
            {
                EventLog.WriteEntry(Resource.FormatString("Reg_InstallTitle"),
                                    Resource.FormatString("Reg_FailInstall", asmpath, appname) + "\n\n" + e.ToString(), 
                                    EventLogEntryType.Error);

                throw;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\iobjectconstruct.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\IObjectConstruct.uex' path='docs/doc[@for="IObjectConstruct"]/*' />
    [
     ComImport,
     Guid("41C4F8B3-7439-11D2-98CB-00C04F8EE1C4"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IObjectConstruct
    {
        /// <include file='doc\IObjectConstruct.uex' path='docs/doc[@for="IObjectConstruct.Construct"]/*' />
        void Construct([In, MarshalAs(UnmanagedType.Interface)] Object obj);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\interlockedqueue.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Threading;

namespace System.EnterpriseServices
{
    // The interlocked queue works as follows:
    // Nodes are removed from _head, and are placed on _tail.
    // 
    // Invariants:
    // A node can only be added to a tail if the tail's next is null. If
    // next isn't null, then tail needs to be updated.
    //
    // If head == tail && head.Next == null, then list is empty.
    // If head == tail && head.Next != null, tail needs updating.
    //
    // head = null;
    // tail = null;
    //
    

    internal class InterlockedQueue
    {
        private class Node
        {
            public Object _object;
            public Object _next;

            public Node(Object o)
            {
                _object = o;
                _next   = null;
            }

            public Object Object 
            { 
                get { return(_object); } 
                set { _object = value; }
            }
            public Node   Next   
            { 
                get { return((Node)_next); } 
                set { _next = value; }
            }
        }

        private Object _head;
        private Object _tail;
        
        public int Count;

        private Node Head 
        {
            get { return((Node)_head); }
            set { _head = value; }
        }
        
        private Node Tail 
        {
            get { return((Node)_tail); }
            set { _tail = value; }
        }

        public InterlockedQueue()
        {
            // Create a dummy node to hang out?
            Head = Tail = new Node(null);
            Count = 0;
        }
        
        public void Push(Object o)
        {
            Node node = new Node(o);
            Node tail;
            Node next;

            while(true)
            {
                // Take a sample of the current state.
                tail = Tail;
                next = tail.Next;

                // Check to see if we're really at the end of the list.
                // if next != null, we need to move down the list a bit first.
                if(next == null)
                {
                    // Test the hard case?
                    // Thread.Sleep(0);
                    if(Interlocked.CompareExchange(ref tail._next, node, null) == null)
                    {
                        // We shoved this guy on the tail.  Run off.
                        break;
                    }
                }
                else
                {
                    // Move the tail down the list, and try again.
                    Interlocked.CompareExchange(ref _tail, next, tail);
                }
            }
            // We updated tail, move it down to our new node if that hasn't
            // been done already.
            Interlocked.CompareExchange(ref _tail, node, tail);
            Interlocked.Increment(ref Count);
        }

        public Object Pop()
        {
            Node head, tail, next;
            Object data;
            
            while(true)
            {
                // Take a sample of the current state.
                head = Head;
                tail = Tail;
                next = head.Next;

                // Check first to see if head == tail, list might be empty,
                // or tail might not be updated.
                if(head == tail)
                {
                    if(next == null) return(null);
                    
                    // tail is falling behind:
                    Interlocked.CompareExchange(ref _tail, next, tail);
                }
                else
                {
                    // Try to get some data out?
                    // ASSERT(next != null).  Shouldn't be possible if
                    // head != tail
                    data = next.Object;
                    if(Interlocked.CompareExchange(ref _head, next, head) == head)
                    {
                        break;
                    }
                }
            }
            // We let the old head float away, and we need to make sure
            // that next (the new head) has dropped it's data pointer,
            // so that the queue doesn't hold any objects alive indefinitely.
            next.Object = null;
			Interlocked.Decrement(ref Count);
            return(data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\iobjectcontext.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// IObjectContext interface is a wrapper to expose the COM+ 1.0 context
// to managed objects.  All functionality from this interface is exposed
// through the ContextUtil object, so this is kept private.
//
// Author: dddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\IObjectContext.uex' path='docs/doc[@for="IObjectContext"]/*' />
    [
     ComImport,
     Guid("51372AE0-CAE7-11CF-BE81-00AA00A2FA25"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IObjectContext
    {
        [return : MarshalAs(UnmanagedType.Interface)]
        Object CreateInstance([MarshalAs(UnmanagedType.LPStruct)] Guid rclsid, 
                              [MarshalAs(UnmanagedType.LPStruct)] Guid riid);
        
        void SetComplete();
        
        void SetAbort();
        
        void EnableCommit();
        
        void DisableCommit();
        
        [PreserveSig]
        [return : MarshalAs(UnmanagedType.Bool)]
        bool IsInTransaction();
        
        [PreserveSig]
        [return : MarshalAs(UnmanagedType.Bool)]
        bool IsSecurityEnabled();
        
        [return : MarshalAs(UnmanagedType.Bool)]
        bool IsCallerInRole([In, MarshalAs(UnmanagedType.BStr)] String role);
    }

    [ComImport]
    [Guid("74C08646-CEDB-11CF-8B49-00AA00B8A790")]
    internal interface IDispatchContext 
    {
        void CreateInstance([In, MarshalAs(UnmanagedType.BStr)] String bstrProgID, 
                            [Out] out Object pObject);
        void SetComplete();
        void SetAbort();
        void EnableCommit();
        void DisableCommit();
        bool IsInTransaction();
        bool IsSecurityEnabled();
        bool IsCallerInRole([In, MarshalAs(UnmanagedType.BStr)] String bstrRole);
        void Count([Out] out int plCount);
        void Item([In, MarshalAs(UnmanagedType.BStr)] String name, 
                  [Out] out Object pItem);
        void _NewEnum([Out, MarshalAs(UnmanagedType.Interface)] out Object ppEnum);
        [return : MarshalAs(UnmanagedType.Interface)]
        Object Security();
        [return : MarshalAs(UnmanagedType.Interface)]
        Object ContextInfo();
    }
    
    [ComImport]
    [Guid("E74A7215-014D-11D1-A63C-00A0C911B4E0")]
    internal interface SecurityProperty 
    {
        [return : MarshalAs(UnmanagedType.BStr)]
        String GetDirectCallerName();
        [return : MarshalAs(UnmanagedType.BStr)]
        String GetDirectCreatorName();
        [return : MarshalAs(UnmanagedType.BStr)]
        String GetOriginalCallerName();
        [return : MarshalAs(UnmanagedType.BStr)]
        String GetOriginalCreatorName();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\iobjectcontextinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\IObjectContextInfo.uex' path='docs/doc[@for="IObjectContextInfo"]/*' />
    [
     ComImport,
     Guid("75B52DDB-E8ED-11D1-93AD-00AA00BA3258"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IObjectContextInfo
    {
        [return : MarshalAs(UnmanagedType.Bool)]
        bool IsInTransaction();

        [return : MarshalAs(UnmanagedType.Interface)]
        Object GetTransaction();

        Guid GetTransactionId();

        Guid GetActivityId();
        
        Guid GetContextId();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\iobjectconstructstring.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: dddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\IObjectConstructString.uex' path='docs/doc[@for="IObjectConstructString"]/*' />
    [
     ComImport,
     Guid("41C4F8B2-7439-11D2-98CB-00C04F8EE1C4"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
    ]
    internal interface IObjectConstructString
    {
        /// <include file='doc\IObjectConstructString.uex' path='docs/doc[@for="IObjectConstructString.ConstructString"]/*' />
        String ConstructString { 
            [return : MarshalAs(UnmanagedType.BStr)]
            get; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\iobjectcontextinfo2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: HanyR
// Date: April 2001
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\IObjectContextInfo2.uex' path='docs/doc[@for="IObjectContextInfo2"]/*' />
    [
     ComImport,
     Guid("594BE71A-4BC4-438b-9197-CFD176248B09"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    internal interface IObjectContextInfo2 // : IObjectContextInfo
    {
		[return : MarshalAs(UnmanagedType.Bool)]
		bool IsInTransaction();
		
		[return : MarshalAs(UnmanagedType.Interface)]
		Object GetTransaction();
		
		Guid GetTransactionId();
		
		Guid GetActivityId();
		        
		Guid GetContextId();

		Guid GetPartitionId();
		Guid GetApplicationId();
		Guid GetApplicationInstanceId();		
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\factory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.MetadataServices;
    using System.Threading;
    using System.Net;
    using System.Text;
    using System.Security.Permissions;

    /// <include file='doc\factory.uex' path='docs/doc[@for="IClrObjectFactory"]/*' />
   

    [Guid("ecabafd2-7f19-11d2-978e-0000f8757e2a")]
    public interface IClrObjectFactory
    {
        
        /// <include file='doc\factory.uex' path='docs/doc[@for="IClrObjectFactory.CreateFromAssembly"]/*' />
        [DispId(0x00000001)]
        [return : MarshalAs(UnmanagedType.IDispatch)        ]
        object CreateFromAssembly(string assembly, string type, string mode);

        //
        // moniker passes in all configuration information
        //
        /// <include file='doc\factory.uex' path='docs/doc[@for="IClrObjectFactory.CreateFromVroot"]/*' />
        [DispId(0x00000002)]
        [return : MarshalAs(UnmanagedType.IDispatch)        ]
        object CreateFromVroot(string VrootUrl, string Mode);

        /// <include file='doc\factory.uex' path='docs/doc[@for="IClrObjectFactory.CreateFromWsdl"]/*' />
        [DispId(0x00000003)]
        [return : MarshalAs(UnmanagedType.IDispatch)        ]
        object CreateFromWsdl(string WsdlUrl, string Mode);

        /// <include file='doc\factory.uex' path='docs/doc[@for="IClrObjectFactory.CreateFromMailbox"]/*' />
        [DispId(0x00000004)]
        [return : MarshalAs(UnmanagedType.IDispatch)        ]
        object CreateFromMailbox(string Mailbox, string Mode);
    }

    /// <include file='doc\factory.uex' path='docs/doc[@for="ClrObjectFactory"]/*' />
    [Guid("ecabafd1-7f19-11d2-978e-0000f8757e2a")]
    public class ClrObjectFactory : IClrObjectFactory
    {

       private  static Hashtable _htTypes = new Hashtable();
    
        /// <include file='doc\factory.uex' path='docs/doc[@for="ClrObjectFactory.CreateFromAssembly"]/*' />
        public object CreateFromAssembly(string AssemblyName, string TypeName, string Mode)
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                // check to ensure this call is not being used to activate private classes in our assembly
                if (AssemblyName.StartsWith("System.EnterpriseServices"))
                {
                    return null;
                }
                string PhysicalPath = Publish.GetClientPhysicalPath(false);
                string cfgName = PhysicalPath + TypeName + ".config";
                // we only remote activate if there is a configuration file in this case
                {
                    if (File.Exists(cfgName))
                    {
                        lock(_htTypes)
                        if (!_htTypes.ContainsKey(cfgName))
                        {
                             RemotingConfiguration.Configure(cfgName);
                             _htTypes.Add(cfgName, cfgName);
                        }
                    }
                    else //COM+ 26264 - no configuration file is an error condition
                    {
                        throw new COMException(Resource.FormatString("Err_ClassNotReg"), Util.REGDB_E_CLASSNOTREG);
                    }
                }
                Assembly objAssem = Assembly.LoadWithPartialName(AssemblyName);
                if (null == objAssem)
                {
                    throw new COMException(Resource.FormatString("Err_ClassNotReg"), Util.REGDB_E_CLASSNOTREG);
                }
                Object o = objAssem.CreateInstance(TypeName);
                if (null == o)
                {
                    throw new COMException(Resource.FormatString("Err_ClassNotReg"), Util.REGDB_E_CLASSNOTREG);
                }
                return(o);
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                throw;
            }
        }

        private string Url2File(string InUrl)
        {
              string Url = InUrl;
              Url = Url.Replace("/", "0");
              Url = Url.Replace(":", "1");
              Url = Url.Replace("?", "2");
              Url = Url.Replace("\\","3");
              Url = Url.Replace(".", "4");
              Url = Url.Replace("\"","5");
              Url = Url.Replace("'", "6");
              Url = Url.Replace(" ", "7");
              Url = Url.Replace(";", "8");
              Url = Url.Replace("=", "9");
              Url = Url.Replace("|", "A");
              Url = Url.Replace("<", "[");
              Url = Url.Replace(">", "]");
              return Url;
        }

        /// <include file='doc\factory.uex' path='docs/doc[@for="ClrObjectFactory.CreateFromVroot"]/*' />
        public object CreateFromVroot(string VrootUrl, string Mode)
        {
              string WsdlUrl = VrootUrl + "?wsdl";
              return CreateFromWsdl(WsdlUrl, Mode);
        }

        /// <include file='doc\factory.uex' path='docs/doc[@for="ClrObjectFactory.CreateFromWsdl"]/*' />
        public object CreateFromWsdl(string WsdlUrl, string Mode)
        {
            try
            {
              SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
              sp.Demand();
              string PhysicalPath = Publish.GetClientPhysicalPath(true);
              string TypeName     = "";
              string EscUrl = Url2File(WsdlUrl);
              if ((EscUrl.Length + PhysicalPath.Length) > 250)
              {
                  EscUrl = EscUrl.Remove(0, (EscUrl.Length + PhysicalPath.Length)-250);
              }
              string dllName = EscUrl + ".dll";
              if (!File.Exists(PhysicalPath + dllName))
              {
                  GenAssemblyFromWsdl gen = new GenAssemblyFromWsdl();
                  gen.Run(WsdlUrl, dllName, PhysicalPath);
              }
              Assembly objAssem = Assembly.LoadFrom(PhysicalPath + dllName);
              Type[] AssemTypes = objAssem.GetTypes();
              for (long i=0; i < AssemTypes.GetLength(0); i++)
              {
                  if (AssemTypes[i].IsClass) TypeName = AssemTypes[i].ToString();
              }
              Object o = objAssem.CreateInstance(TypeName);
              return(o);
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                throw;
            }
        }

        /// <include file='doc\factory.uex' path='docs/doc[@for="ClrObjectFactory.CreateFromMailbox"]/*' />
        public object CreateFromMailbox(string Mailbox, string Mode)
        {
            // TODO: Implement SMTP support
            string error = Resource.FormatString("Soap_SmtpNotImplemented");
            ComSoapPublishError.Report(error);
            throw new COMException(error);
        }
    }

    internal sealed class NativeMethods
    {
        private NativeMethods()
        {
            // protect against instance creation
        }

        [ DllImport( "ADVAPI32", SetLastError=true, CharSet=CharSet.Auto )]
        internal static extern bool OpenThreadToken(
          IntPtr ThreadHandle,  
          System.UInt32 DesiredAccess,  
          bool OpenAsSelf,      
          ref IntPtr TokenHandle   
        );

        [ DllImport( "ADVAPI32", SetLastError=true, CharSet=CharSet.Auto )]
        internal static extern bool SetThreadToken(
          IntPtr Thread,
          IntPtr Token   
        );
        
        [ DllImport( "Kernel32", CharSet=CharSet.Auto )]
        internal static extern IntPtr GetCurrentThread();
    }

    internal class GenAssemblyFromWsdl 
    {
        private const System.UInt32 TOKEN_IMPERSONATE  =  0x0004;

        private string wsdlurl      = ""; 
        private string filename     = ""; 
        private string pathname     = ""; 
        private Thread thisthread   = null;
        private IntPtr threadtoken  = IntPtr.Zero;
        private Exception SavedException;
        private bool ExceptionThrown = false;

        public GenAssemblyFromWsdl()
        {
            thisthread = new Thread(new ThreadStart(this.Generate));
            thisthread.ApartmentState = ApartmentState.MTA;
        }

        public void Run(string WsdlUrl, string FileName, string PathName)
        {
            try
            {
                if (WsdlUrl.Length <= 0 || FileName.Length <= 0) return;
                wsdlurl  = WsdlUrl;
                filename = PathName + FileName;
                pathname = PathName;

                NativeMethods.OpenThreadToken(NativeMethods.GetCurrentThread(), TOKEN_IMPERSONATE, true, ref threadtoken);

                int err = Marshal.GetLastWin32Error();
                if(err != Util.ERROR_SUCCESS && err != Util.ERROR_NO_TOKEN)
                {
                   throw new COMException(Resource.FormatString("Err_OpenThreadToken"), Marshal.GetHRForLastWin32Error());
                }

                thisthread.Start();
                thisthread.Join();

                if(ExceptionThrown == true)
                {
                    throw SavedException;
                }
                
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                throw;
            }
        }

        public void Generate()
        {
            try
            {

                if(threadtoken != IntPtr.Zero)
                {
                    if(!NativeMethods.SetThreadToken(IntPtr.Zero, threadtoken))
                    {
                       throw new COMException(Resource.FormatString("Err_SetThreadToken"), Marshal.GetHRForLastWin32Error());
                    }
                }
                    
                if (wsdlurl.Length <= 0)
                {
                    return;
                }
                Stream  oSchemaStream    = new MemoryStream();
                ArrayList aCodeStreamList = new ArrayList();
                MetaData.RetrieveSchemaFromUrlToStream(wsdlurl, oSchemaStream);
                oSchemaStream.Position = 0;
                MetaData.ConvertSchemaStreamToCodeSourceStream(true, pathname, oSchemaStream, aCodeStreamList);
                MetaData.ConvertCodeSourceStreamToAssemblyFile(aCodeStreamList, filename, null);
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                SavedException = e;
				ExceptionThrown = true;
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\iplaybackcontrol.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// The IPlaybackControl interface is used in Queued Components to participate
// in the abnormal handling of server-side playback errors and client-side
// failures of the Message Queuing delivery mechanism.
// 
// Author: mikedice
// Date: May 2002
//

namespace System.EnterpriseServices
{
    using System.Runtime.InteropServices;
    
    /// <include file='doc\IPlaybackControl.uex' path='docs/doc[@for="IPlaybackControl"]/*' />
    [
     ComImport,
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
     Guid("51372AFD-CAE7-11CF-BE81-00AA00A2FA25")
    ]
    public interface IPlaybackControl
    {
        /// <include file='doc\IPlaybackControl.uex' path='docs/doc[@for="IPlaybackControl.FinalClientRetry"]/*' />
        void FinalClientRetry();

        /// <include file='doc\IPlaybackControl.uex' path='docs/doc[@for="IPlaybackControl.FinalServerRetry"]/*' />
        void FinalServerRetry();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\itransaction.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    
    // BUGBUG:  This is also defined in System.Messaging.Interop.  Where
    // should it really go?  (It really belongs as part of an OLEDB thing).

    /// <include file='doc\ITransaction.uex' path='docs/doc[@for="BOID"]/*' />
    [StructLayout(LayoutKind.Sequential,Pack=1)]
    [ComVisible(false)]
    public struct BOID
    {
        // BUGBUG:  Does this allocate the rgb arrray?
        // if it doesn't, there will have to be some wacky code.
        // or if stack instances of value types call default
        // constructors, we can allocate it.
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="BOID.rgb"]/*' />
        [MarshalAs(UnmanagedType.ByValArray, SizeConst=16)]
        public byte[] rgb;
    }

    /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO"]/*' />
    [StructLayout(LayoutKind.Sequential,Pack=4)]
    [ComVisible(false)]
    public struct XACTTRANSINFO
    {
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO.uow"]/*' />
        public BOID uow;
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO.isoLevel"]/*' />
        public int  isoLevel;
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO.isoFlags"]/*' />
        public int  isoFlags;
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO.grfTCSupported"]/*' />
        public int  grfTCSupported;
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO.grfRMSupported"]/*' />
        public int  grfRMSupported;
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO.grfTCSupportedRetaining"]/*' />
        public int  grfTCSupportedRetaining;
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="XACTTRANSINFO.grfRMSupportedRetaining"]/*' />
        public int  grfRMSupportedRetaining;
    }

    /// <include file='doc\ITransaction.uex' path='docs/doc[@for="ITransaction"]/*' />
    [
     ComImport,
     Guid("0FB15084-AF41-11CE-BD2B-204C4F4F5020"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
    ]
    public interface ITransaction
    {
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="ITransaction.Commit"]/*' />
        void Commit(int fRetaining, int grfTC, int grfRM);
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="ITransaction.Abort"]/*' />
        // BUGBUG:  We should be able to automatically convert a passed
        // BOID to a BOID*, cause that's what the function takes.  I don't
        // know why that don't work right now.  I'll send a repro
        // to the interop guys:
        void Abort(ref BOID pboidReason, int fRetaining, int fAsync);
        /// <include file='doc\ITransaction.uex' path='docs/doc[@for="ITransaction.GetTransactionInfo"]/*' />
        void GetTransactionInfo(out XACTTRANSINFO pinfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

# Make sure this puppy will get rebuilt if System.EnterpriseServices.Thunk is
# rebuilt, cause the hash's have got to match.
$(COOL_TARGET): $(TARGETCOMPLUS)\System.EnterpriseServices.Thunk.dll

SETUP:
    $(TARGETPATH)\InternalResGen.exe resources.txt System.EnterpriseServices.resources

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\System.EnterpriseServices.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\iobjectcontrol.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// IObjectControl interface allows the user to implement an interface to
// get Activate/Deactivate notifications from JIT and object pooling.
//
// Author: ddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System.Runtime.InteropServices;
    
    /// <include file='doc\IObjectControl.uex' path='docs/doc[@for="IObjectControl"]/*' />
    [
     ComImport,
     Guid("51372AEC-CAE7-11CF-BE81-00AA00A2FA25"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
    ]
    internal interface IObjectControl
    {
        /// <include file='doc\IObjectControl.uex' path='docs/doc[@for="IObjectControl.Activate"]/*' />
        void Activate();

        /// <include file='doc\IObjectControl.uex' path='docs/doc[@for="IObjectControl.Deactivate"]/*' />
        void Deactivate();

        // REVIEW:  Should this be a property?
        /// <include file='doc\IObjectControl.uex' path='docs/doc[@for="IObjectControl.CanBePooled"]/*' />
        [PreserveSig]
        [return :MarshalAs(UnmanagedType.Bool)]
        bool CanBePooled();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\lookuptable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ComponentServices.cs
**
** Author:  RajaK
**
** Purpose: Defines the general purpose ComponentServices
**
** Date:    June 15 2000
**
===========================================================*/

using System;
using System.Collections;
using System.Threading;

namespace System.EnterpriseServices
{
	//---------------------------------------------------------
	//	internal sealed class LookupTable
	//---------------------------------------------------------
	internal sealed class LookupTable
	{
		private IntPtr[] keys;
        private Object[] values;
        private int _size;
    	
        private const int _defaultCapacity = 16;

		internal LookupTable()
		{
			keys = new IntPtr[_defaultCapacity];
			values = new Object[_defaultCapacity];
		}

		internal Object this[int index]
		{
            get 
            {
                return values[index];
            }
		}

		internal void Add(IntPtr ikey, Object value) 
		{            
			DBG.Assert((int)ikey != 0,"Adding entry with key 0");
            DBG.Assert((int)ikey != -1,"Adding entry with key -1");
            int i = BinarySearch(ikey);
            DBG.Assert(!(i>=0)," Duplicated entry being added to Deactivated list");
            Insert(~i, ikey, value);
        }
		
        // Ensures that the capacity of this sorted list is at least the given
        // minimum value. If the currect capacity of the list is less than
        // min, the capacity is increased to twice the current capacity or
        // to min, whichever is larger.
        private void EnsureCapacity() 
		{
            int newCapacity = keys.Length < 128 ? keys.Length * 2 : keys.Length + 64;
			IntPtr[] newKeys = new IntPtr[newCapacity];
    		Object[] newValues = new Object[newCapacity];
    	    Array.Copy(keys, 0, newKeys, 0, _size);
    		Array.Copy(values, 0, newValues, 0, _size);
    		keys = newKeys;
    	    values = newValues;
        }

		internal int IndexOfKey(IntPtr ikey) 
		{
            int ret = BinarySearch(ikey);
    		return ret >=0 ? ret : -1;
        }

		private int BinarySearch(IntPtr ikey)
		{
			int lo = 0;
            int hi = _size - 1;
            while (lo <= hi) 
			{
                int i = (lo + hi) >> 1;
                if (ikey == keys[i]) return i;
                if ((long)ikey < (long)keys[i]) 
				{
                    lo = i + 1;
                }
                else 
				{
                    hi = i - 1;
                }
            }
            return ~lo;
		}

        // Inserts an entry with a given key and value at a given index.
        private void Insert(int index, IntPtr key, Object value) 
		{
            if (_size == keys.Length) EnsureCapacity();
            if (index < _size)
			{
                Array.Copy(keys, index, keys, index + 1, _size - index);
                Array.Copy(values, index, values, index + 1, _size - index);
            }
            keys[index] = key;
            values[index] = value;
            _size++;
        }
    
        // Removes the entry at the given index. The size of the sorted list is
        // decreased by one.
        // 
        
        internal void RemoveAt(int index)
		{
            if (index < 0 || index >= _size) throw new ArgumentOutOfRangeException("index", Resource.FormatString("ArgumentOutOfRange_Index"));
            _size--;
            if (index < _size) 
			{
                Array.Copy(keys, index + 1, keys, index, _size - index);
                Array.Copy(values, index + 1, values, index, _size - index);
            }
            keys[_size] = IntPtr.Zero;
            values[_size] = null;
        }
    }

    
    internal sealed class IdentityTable
    {
        private static Hashtable        _table;
        private static ReaderWriterLock _rwlock;

        static IdentityTable()
        {
            _rwlock = new ReaderWriterLock();
            _table = new Hashtable();
        }

        // We want to remove the object from the table if:
        // wf.Target == val
        // wf.Target == null
        // If wf.Target is other than null, then we assume that
        // the new jitted object for this context has hit the table.
        public static void RemoveObject(IntPtr key, Object val)
		{
            _rwlock.AcquireWriterLock(Timeout.Infinite);
            try
            {
                WeakReference wf = _table[key] as WeakReference;

                // This assert isn't valid, because of the following sequence:
                // we could have the following sequence:
                //     object created by remote client
                //     object deactivated (jitted out)
                //     object collected (wf nulled), added to finalizer stack
                //     new object created by jit in context
                //     new object added to table (making entry non null)
                //     new object deactivated (jitted out)
                //     new object collected, added to finalizer stack
                //     new object finalized (removing context entry)
                //     old object finalized (can't remove entry, already gone)
                // DBG.Assert(index != -1, " Lookup table didn't contain the object being removed");
                
                // We only remove the object if nobody has re-used this
                // context before we got to this point.
                if(wf != null && (wf.Target == val || wf.Target == null))
                {
                    _table.Remove(key);
                    wf.Target = null;
                }
            }
            finally
            {
                _rwlock.ReleaseWriterLock();
            }
		}

		public static Object FindObject(IntPtr key)
		{
			Object o = null;
            _rwlock.AcquireReaderLock(Timeout.Infinite);
            try
            {
                WeakReference wf = _table[key] as WeakReference;
    			if (wf != null)
    			{    
                    // Note that the weak-reference target could be null,
                    // if the object has been collected but the 
                    // finalizer for this context hasn't kicked in yet.
    				o = wf.Target;
                }
            }			
            finally
            {
                _rwlock.ReleaseReaderLock();
            }
			return o;
		}

		public static void AddObject(IntPtr key, Object val)
        {
            _rwlock.AcquireWriterLock(Timeout.Infinite);
            try
            {
                WeakReference wf = _table[key] as WeakReference;
                if(wf == null)
                {
                    DBG.Info(DBG.SC, "LookupTable.AddObject(): Adding new entry for " + key);
                    // We didn't find an entry, we need to add a new one:
                    wf = new WeakReference(val,false);
                    _table.Add(key, wf);
                }
                else
                {
                    DBG.Info(DBG.SC, "LookupTable.AddObject(): Reusing entry for " + key);
                    // We found an entry, it better be the same or null:
                    DBG.Assert(wf.Target == null || wf.Target == val, "different live TP found in table");
                    if(wf.Target == null)
                    {
                        wf.Target = val;
                    }
                }
            }
            finally
            {
                _rwlock.ReleaseWriterLock();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\reflectioncache.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Collections;
    using System.Threading;
    using System.Reflection;

    // Our simple cache-table has a Get method, that will get the current
    // value of the cache, and several Set methods:
    // Set():  Set the value if it has not currently been set.
    // Reset(): Set the value to a new value regardless of whether it was
    //          previously set or not.  This is faster, but is often not 
    //          optimal if the cache entry is a sub-table.

    // TODO:  Read/Write lock on the cache.
    // TODO:  Design an aging algorithm so that participating cache tables
    // can register with the thread pool for cleanup.
    internal class Cachetable
    {
        private Hashtable _cache;
        private ReaderWriterLock _rwlock;

        public Cachetable()
        {
            _cache = new Hashtable();
            _rwlock = new ReaderWriterLock();
        }
        
        public Object Get(Object key)
        { 
            _rwlock.AcquireReaderLock(Timeout.Infinite);
            try
            {
                return(_cache[key]);
            }
            finally
            {
                _rwlock.ReleaseReaderLock();
            }
        }
        
        // Returns the value that ends up the slot, it might have already
        // been set.
        public Object Set(Object key, Object nv)
        {
            _rwlock.AcquireWriterLock(Timeout.Infinite);
            try
            {
                Object v = _cache[key];
                if(v == null)
                {
                    _cache[key] = nv;
                    return(nv);
                }

                return(v);            
            }
            finally
            {
				_rwlock.ReleaseWriterLock();
            }
        }

        public void Reset(Object key, Object nv)
        {
            _rwlock.AcquireWriterLock(Timeout.Infinite);
            try
            {
                _cache[key] = nv;
            }
            finally
            {
                _rwlock.ReleaseWriterLock();
            }
        }
    }

    // The reflection assistant data based on the type of an
    // object about the object's implementation.
    internal sealed class ReflectionCache
    {
        private static Cachetable Cache = new Cachetable();

        // We cache this by mapping MemberInfo to MemberInfo in our
        // cache.  Note that because assemblies can never be unloaded,
        // there's no reason to flush this cache (we won't be holding
        // anything alive longer than it would have been alive anyway.
        public static MemberInfo ConvertToInterfaceMI(MemberInfo mi)
        {
            // First, try to hit the cache:
            MemberInfo cmi = (MemberInfo)Cache.Get(mi);
            if(cmi != null) return(cmi);

            // Failed to hit the cache, do the lookup.
            // TODO: clean this up a bit.
            // TODO: Deal with non-methodInfo objects (work off MethodBase)
            MethodInfo minfo = mi as MethodInfo;
            if(minfo == null) return(null);

            MethodInfo intfMethodInfo = null;
            
            // check for AutoDone
            Type reflectType = minfo.ReflectedType;
            if (reflectType.IsInterface)
            {
                intfMethodInfo = minfo;
            }
            else
            {
                // get all the interfaces implemented by the class
                Type[] rgInterfaces = reflectType.GetInterfaces();
                if (rgInterfaces == null)
                    return null;
                
                // iterate through all the interfaces
                for (int ii =0; ii < rgInterfaces.Length; ii++)
				{				
					// get interface mapping for each interface
					InterfaceMapping imap  = reflectType.GetInterfaceMap(rgInterfaces[ii]);
                    
					if (imap.TargetMethods == null)
						continue;						
                    
					// check if a class method in this inteface map matches
					for (int j=0; j < imap.TargetMethods.Length; j++)
					{
						// see if the class method matches
						if (imap.TargetMethods[j] == minfo)
						{
							// grab the interface method
							intfMethodInfo = imap.InterfaceMethods[j];
							break;
						}
					}
                    
					if (intfMethodInfo != null)
						break;
				}
			}
            
			DBG.Assert(intfMethodInfo == null ||
                       intfMethodInfo.ReflectedType.IsInterface, 
                       "Failed to map class method to interface method");

            Cache.Reset(mi, intfMethodInfo);

			return (MemberInfo)intfMethodInfo;
        }

        public static MemberInfo ConvertToClassMI(Type t, MemberInfo mi)
        {
            // get reflected type
            Type reflectType = mi.ReflectedType;
            if (!reflectType.IsInterface)
            {
                return mi;
            }

            // First, try to hit the cache.  We look for the cache entry
            // for this type, and it should be a little cache-table
            // of it's own.  In that cache-table, we 
            Cachetable subcache = (Cachetable)Cache.Get(t);
            if(subcache != null)
            {
                MemberInfo cmi = (MemberInfo)subcache.Get(mi);
                if(cmi != null) return(cmi);
            }

			DBG.Assert(t != null, "class type is null");
			DBG.Assert(!t.IsInterface, " class type is actually an interface");						

			MethodInfo minfo = (MethodInfo)mi;
			MethodInfo clsMethodInfo = null;
			// minfo is an interface member info, map it to class memeber info

			// get the interface map
            DBG.Info(DBG.SC, "ReflectionCache: Looking up " + reflectType + " on " + t);
			InterfaceMapping imap  = t.GetInterfaceMap(reflectType);

			if (imap.TargetMethods == null)
			{
				throw new InvalidCastException();
			}
			for (int i=0; i < imap.TargetMethods.Length; i++)
			{
				if (imap.InterfaceMethods[i] == minfo)
				{
					clsMethodInfo = imap.TargetMethods[i];
					break;
				}
			}

			DBG.Assert(clsMethodInfo != null, "Failed to map interface method to class method");
			DBG.Assert(!clsMethodInfo.ReflectedType.IsInterface, 
								"Failed to map interface method to class method");

            // Store the result in the cache:
            if(subcache == null)
            {
                subcache = (Cachetable)Cache.Set(t, new Cachetable());
            }

            subcache.Reset(mi, clsMethodInfo);

			return (MemberInfo)clsMethodInfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\registrationwrappers.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: April 2000
//

// This file implements the "public" views of the RegistrationHelperImpl
// object.  The internal object implements Install and Uninstall Assembly,
// these outer objects provide access to the internal version w/ various
// different services.  
// TODO:  Unify these into a single client view:

namespace System.EnterpriseServices
{
    using System;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.EnterpriseServices.Admin;
    using System.Security;
    using System.Security.Permissions;
    using System.Diagnostics;
    using System.Threading; 

    /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="IRegistrationHelper"]/*' />
    [Guid("55e3ea25-55cb-4650-8887-18e8d30bb4bc")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IRegistrationHelper
    {
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="IRegistrationHelper.InstallAssembly"]/*' />
        void InstallAssembly([In, MarshalAs(UnmanagedType.BStr)]    String assembly, 
                             [In,Out,MarshalAs(UnmanagedType.BStr)] ref String application, 
                             [In,Out,MarshalAs(UnmanagedType.BStr)] ref String tlb,
                             [In] InstallationFlags installFlags);
        
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="IRegistrationHelper.UninstallAssembly"]/*' />
        void UninstallAssembly([In, MarshalAs(UnmanagedType.BStr)] String assembly,
                               [In, MarshalAs(UnmanagedType.BStr)] String application);
    }
       
    /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationConfig"]/*' />
    [Serializable]
    [Guid("36dcda30-dc3b-4d93-be42-90b2d74c64e7")]
    public class RegistrationConfig
    {
        private string _assmfile;
        private InstallationFlags _flags;
        private string _application;
        private string _typelib;
        private string _partition;
        private string _approotdir;

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationConfig.AssemblyFile"]/*' />
        public string AssemblyFile
        {
            set { _assmfile = value;    }
            get { return _assmfile;     }
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationConfig.InstallationFlags"]/*' />
        public InstallationFlags InstallationFlags
        {
            set { _flags = value; }
            get { return _flags;  }
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationConfig.Application"]/*' />
        public string Application
        {
            set { _application = value;   }
            get { return _application;    }
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationConfig.TypeLibrary"]/*' />
        public string TypeLibrary
        {
            set { _typelib = value; }
            get { return _typelib;  }
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationConfig.Partition"]/*' />
        public string Partition
        {
            set { _partition = value;   }
            get { return _partition;    }
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationConfig.ApplicationRootDirectory"]/*' />
        public string ApplicationRootDirectory
        {
            set { _approotdir = value;  }
            get { return _approotdir;   }
        }
    }

    internal class RegistrationThreadWrapper
    {
        private RegistrationHelper _helper;
        RegistrationConfig _regConfig;        

        private Exception _exception;
                
        internal RegistrationThreadWrapper(RegistrationHelper helper,
                                           RegistrationConfig regConfig)
        {
            DBG.Info(DBG.Registration, "STA Thread!  jumping onto MTA for registration");
            _regConfig      = regConfig;           
            _helper      = helper;
            _exception   = null;
        }

        internal void InstallThread()
        {
            try
            {
                Thread.CurrentThread.ApartmentState = ApartmentState.MTA;
                DBG.Info(DBG.Registration, "InstallThread(): recursing install assembly...");
                _helper.InstallAssemblyFromConfig(ref _regConfig);
                DBG.Info(DBG.Registration, "InstallThread(): Finished with install assembly.");
            }
            catch(Exception e)
            {
                DBG.Info(DBG.Registration, "InstallThread(): Caught failure in InstallAssembly.");
                _exception = e;
            }
        }

        internal void UninstallThread()
        {
            try
            {
                Thread.CurrentThread.ApartmentState = ApartmentState.MTA;
                DBG.Info(DBG.Registration, "UninstallThread(): recursing install assembly...");
                _helper.UninstallAssemblyFromConfig(ref _regConfig);
                DBG.Info(DBG.Registration, "UninstallThread(): Finished with install assembly.");
            }
            catch(Exception e)
            {
                DBG.Info(DBG.Registration, "UninstallThread(): Caught failure in InstallAssembly.");
                _exception = e;
            }
        }

        internal void PropInstallResult()
        {
            if(_exception != null)
            {
                throw _exception;
            }
        }

        internal void PropUninstallResult()
        {
            if(_exception != null)
            {
                throw _exception;
            }
        }
    }


    /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelper"]/*' />
    [Guid("89a86e7b-c229-4008-9baa-2f5c8411d7e0")]    
    public sealed class RegistrationHelper : MarshalByRefObject, 
                                      IRegistrationHelper,
                                      Thunk.IThunkInstallation
    {
        void Thunk.IThunkInstallation.DefaultInstall(String asm)
        {
            String app = null;
            String tlb = null;

            InstallAssembly(asm, ref app, ref tlb, 
                            InstallationFlags.FindOrCreateTargetApplication |
                            InstallationFlags.ReconfigureExistingApplication);
        }
        
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelper.InstallAssembly"]/*' />
        public void InstallAssembly(String assembly, ref String application, ref String tlb, InstallationFlags installFlags)
        {
		    InstallAssembly(assembly, ref application, null, ref tlb, installFlags);
        }
        
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelper.InstallAssembly1"]/*' />
        public void InstallAssembly(String assembly, ref String application, String partition, ref String tlb, InstallationFlags installFlags)
        {
            RegistrationConfig regConfig = new RegistrationConfig();

            regConfig.AssemblyFile = assembly;
            regConfig.Application = application;
            regConfig.Partition = partition;
            regConfig.TypeLibrary = tlb;
            regConfig.InstallationFlags = installFlags;

            InstallAssemblyFromConfig(ref regConfig);

            application = regConfig.Application;
            tlb = regConfig.TypeLibrary;
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelper.InstallAssemblyFromConfig"]/*' />
        public void InstallAssemblyFromConfig([MarshalAs(UnmanagedType.IUnknown)] ref RegistrationConfig regConfig)
        {
            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();
		
            Platform.Assert(Platform.W2K, "RegistrationHelper.InstallAssemblyFromConfig");

            if(Thread.CurrentThread.ApartmentState == ApartmentState.STA)
            {
                // HACK:  In order to reduce deadlock likelihood, we need to get off 
                // the current STA (into an MTA) in order to do this work.
                // Whip off a new thread...
                RegistrationThreadWrapper wrap = new RegistrationThreadWrapper(this, regConfig);
                Thread t = new Thread(new ThreadStart(wrap.InstallThread));
                t.Start();
                t.Join();
                wrap.PropInstallResult();
            }
            else
            {
                // First, try to do this in a "transacted" manner.  This will
                // return false if we couldn't start up the transaction, 
                // true if it succeeded.
                // We only do the transacted install if we're on win2k or higher,
                // cause MTS is all in the registry.
                if(Platform.IsLessThan(Platform.W2K) || !TryTransactedInstall(regConfig))
                {
                    // We need to try a non-transacted install:
                    DBG.Info(DBG.Registration, "Failed to do a transacted install.  Using non-tx install.");
                    RegistrationDriver helper = new RegistrationDriver();
                    helper.InstallAssembly(regConfig, null);
                }
            }
        }               
        
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelper.UninstallAssembly"]/*' />
        public void UninstallAssembly(String assembly, String application)
		{
			UninstallAssembly(assembly, application, null);
		}

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelper.UninstallAssembly1"]/*' />
        public void UninstallAssembly(String assembly, String application, String partition)
        {
            RegistrationConfig regConfig = new RegistrationConfig();

            regConfig.AssemblyFile = assembly;
            regConfig.Application = application;
            regConfig.Partition = partition;    

            UninstallAssemblyFromConfig(ref regConfig);
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelper.UninstallAssemblyFromConfig"]/*' />
        public void UninstallAssemblyFromConfig([MarshalAs(UnmanagedType.IUnknown)] ref RegistrationConfig regConfig)
        {
            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();

            Platform.Assert(Platform.W2K, "RegistrationHelper.UninstallAssemblyFromConfig");

            if(Thread.CurrentThread.ApartmentState == ApartmentState.STA)
            {
                // HACK:  In order to reduce deadlock likelihood, we need to get off 
                // the current STA (into an MTA) in order to do this work.
                // Whip off a new thread...
                RegistrationThreadWrapper wrap = new RegistrationThreadWrapper(this, regConfig);
                Thread t = new Thread(new ThreadStart(wrap.UninstallThread));
                t.Start();
                t.Join();
                wrap.PropUninstallResult();
            }
            else
            {
                // First, try to do this in a "transacted" manner.  This will
                // return false if we couldn't start up the transaction, 
                // true if it succeeded.
                if(Platform.IsLessThan(Platform.W2K) || !TryTransactedUninstall(regConfig))
                {
                    // We need to try a non-transacted install:
                    DBG.Info(DBG.Registration, "Failed to do a transacted uninstall.  Using non-tx uninstall.");
                    RegistrationDriver helper = new RegistrationDriver();
                    helper.UninstallAssembly(regConfig, null);
                }
            }
        }               
        
        private bool TryTransactedInstall(RegistrationConfig regConfig)
        {
            Perf.Tick("RegistrationHelper - Object creation");
            
            RegistrationHelperTx reg = null;
            
            try
            {
                reg = new RegistrationHelperTx();
                if(!reg.IsInTransaction())
                {
                    DBG.Info(DBG.Registration, "Not in a transaction!  Failing tx install.");
                    reg = null;
                }
            }
            catch(Exception e) 
            {
                DBG.Info(DBG.Registration, "Transacted install failed w/ " + e);
				try
				{
					EventLog appLog = new EventLog();
					appLog.Source    = "System.EnterpriseServices";
					String errMsg   = String.Format(Resource.FormatString("Reg_ErrTxInst"), e);
					appLog.WriteEntry(errMsg, EventLogEntryType.Error);
				}
				catch
				{}	// We don't want to fail... fall back as we were before.

            }
            
            // Couldn't set up to do a transactional install
            if(reg == null) return(false);

            // HACK:  We have to pass in this CatalogSync object, which we use
            // so that we can watch until the CLB is updated on disc, because
            // there is a CRM bug in Win2K which keeps us from 
            DBG.Info(DBG.Registration, "Doing a tx install.");
            CatalogSync sync = new CatalogSync();
            reg.InstallAssemblyFromConfig(ref regConfig, sync);
            sync.Wait();
            
            Perf.Tick("RegistrationHelper - Done");
            return(true);
        }

        private bool TryTransactedUninstall(RegistrationConfig regConfig)
        {
            Perf.Tick("RegistrationHelper - Object creation (uninstall)");
                
            RegistrationHelperTx reg = null;
            try
            {
                reg = new RegistrationHelperTx();
                if(!reg.IsInTransaction())
                    reg = null;
                // reg is now bound into a transactional context?  do transactional work:
            }
            catch(Exception e) 
            {
                DBG.Info(DBG.Registration, "Transacted uninstall failed w/ " + e);
				try
				{
					EventLog appLog = new EventLog();
					appLog.Source    = "System.EnterpriseServices";
					String errMsg   = String.Format(Resource.FormatString("Reg_ErrTxUninst"), e);
					appLog.WriteEntry(errMsg, EventLogEntryType.Error);
				}
				catch
				{}	// We don't want to fail... fall back as we were before.

            }
            
            // Couldn't set up to do a transactional install
            if(reg == null) return(false);
            
            // HACK:  We have to pass in this CatalogSync object, which we use
            // so that we can watch until the CLB is updated on disc, because
            // there is a CRM bug in Win2K which keeps us from 
            CatalogSync sync = new CatalogSync();
            reg.UninstallAssemblyFromConfig(ref regConfig, sync);
            sync.Wait();

            Perf.Tick("RegistrationHelper - Done");
                
            return(true);
        }
    }

    internal class CatalogSync
    {
        private bool        _set;
        private int         _version;

        internal CatalogSync() { _set = false; _version = 0; }

        // We assume that Set() is called inside the transaction, as soon
        // as any write work has been done on the catalog.
        internal void Set()
        {
            try 
            {
                if(!_set && ContextUtil.IsInTransaction)
                {
                    _set = true;
                    RegistryKey key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Classes\\CLSID");
                    _version = (int)(key.GetValue("CLBVersion", 0));
                    DBG.Info(DBG.Registration, "Old version: " + _version);
                }
            }
            catch(Exception)
            {
                // We don't need to watch if the key isn't there, or if
                // other things failed.
                _set = false;
                _version = 0;
                DBG.Warning(DBG.Registration, "Failed to retreive original catalog version.");
            }
        }

        internal void Set(int version)
        {
            _set = true;
            _version = version;
        }

        internal void Wait()
        {
            if(_set)
            {
                RegistryKey key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Classes\\CLSID");
                // Loop till the transaction commits:
                for(;;)
                {
                    int newVersion = (int)(key.GetValue("CLBVersion", 0));
                    DBG.Info(DBG.Registration, "New version: " + newVersion);
                    if(newVersion != _version) break;
                    System.Threading.Thread.Sleep(0);
                }
                _set = false;
            }
        }
    }

    /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx"]/*' />
    /// <internalonly/>
    [Transaction(TransactionOption.RequiresNew)]
    [Guid("9e31421c-2f15-4f35-ad20-66fb9d4cd428")]
    public sealed class RegistrationHelperTx : ServicedComponent
    {
        private static Guid _appid = new Guid("1e246775-2281-484f-8ad4-044c15b86eb7");
        private static string _appname = ".NET Utilities";

        private static ICatalogObject FindApplication(ICatalogCollection coll, 
                                                      Guid appid,
                                                      ref int idx)
        {
            int count = coll.Count();
            for(int i = 0; i < count; i++)
            {
                ICatalogObject obj = (ICatalogObject)(coll.Item(i));
                Guid objid = new Guid((String)(obj.GetValue("ID")));
                if(objid == appid) 
                {
                    idx = i;
                    return(obj);
                }
            }
            return(null);
        }

        private static ICatalogObject FindComponent(ICatalogCollection coll, Guid clsid, ref int idx)
        {
            RegistrationDriver.Populate(coll);
            int count = coll.Count();
            for(int i = 0; i < count; i++)
            {
                ICatalogObject obj = (ICatalogObject)(coll.Item(i));
                Guid objid = new Guid((String)(obj.GetValue("CLSID")));
                if(objid == clsid) 
                {
                    idx = i;
                    return(obj);
                }
            }
            return(null);
        }

        private static void ConfigureComponent(ICatalogCollection coll,
                                               ICatalogObject obj)
        {
            // Configure this puppy:
            obj.SetValue("Transaction", TransactionOption.RequiresNew);
            obj.SetValue("ComponentTransactionTimeoutEnabled", true);
            // infinite timeout.
            obj.SetValue("ComponentTransactionTimeout", 0);
            coll.SaveChanges();
        }

        [ComRegisterFunction]
        internal static void InstallUtilityApplication(Type t)
        {
            DBG.Info(DBG.Registration, "Starting utility installation:");
            
            try
            {
                if(Platform.IsLessThan(Platform.W2K)) return;

                ICatalog cat            = null;
                ICatalogCollection apps = null;
                ICatalogObject app      = null;         
                int junk                = 0;
                
                cat = (ICatalog)(new xCatalog());

                if (!Platform.IsLessThan(Platform.Whistler))
                {
                    // AS/URT 97116:  Keep this from failing the install if
                    // we're on a Beta2 Whistler machine, which has a different
                    // GUID for ICatalog2.
                    ICatalog2 cat2 = cat as ICatalog2;
					
                    if(cat2 != null)
                    {
                        cat2.CurrentPartition(cat2.GlobalPartitionID());
                    }
                }
                
                apps = (ICatalogCollection)(cat.GetCollection("Applications"));
                RegistrationDriver.Populate(apps);
                
                app = FindApplication(apps, _appid, ref junk);
                if(app == null)
                {
                    DBG.Info(DBG.Registration, "Didn't find existing application...");
                    app = (ICatalogObject)(apps.Add());
                    app.SetValue("Name", _appname);
                    app.SetValue("Activation", ActivationOption.Library);
                    app.SetValue("ID", "{" + _appid.ToString() + "}");
					if(!Platform.IsLessThan(Platform.Whistler))
                    {
                        // AS/URT 97116:  Keep this from failing the install if
                        // we're on a Beta2 Whistler machine, which has no Replicable property.
                        try
                        {
                            app.SetValue("Replicable", 0); 
                        }
                        catch(Exception) {}
                    }
                    apps.SaveChanges();
                }
                else
                {
                    // Make sure that we can change this puppy:
                    app.SetValue("Changeable", true);
                    app.SetValue("Deleteable", true);
                    apps.SaveChanges();
                    app.SetValue("Name", _appname);
                    if(!Platform.IsLessThan(Platform.Whistler))
                    {
                        // AS/URT 97116:  Keep this from failing the install if
                        // we're on a Beta2 Whistler machine, which has no Replicable property.
                        try
                        {
                            app.SetValue("Replicable", 0); 
                        }
                        catch(Exception) {}
                    }
                    apps.SaveChanges();
                }
                
                // Import ourselves into the application:
                Guid clsid = Marshal.GenerateGuidForType(typeof(RegistrationHelperTx));
                ICatalogCollection comps = (ICatalogCollection)(apps.GetCollection("Components", app.Key()));
                ICatalogObject comp = FindComponent(comps, clsid, ref junk);
                if(comp == null)
                {
                    cat.ImportComponent("{" + _appid + "}", "{" + clsid + "}");
                    comps = (ICatalogCollection)(apps.GetCollection("Components", app.Key()));
                    comp = FindComponent(comps, clsid, ref junk);
                }
                DBG.Assert(comp != null, "Couldn't find imported component!");
                
                ConfigureComponent(comps, comp);
                
                // And finally, lock this guy down:
                app.SetValue("Changeable", false);
                app.SetValue("Deleteable", false);
                apps.SaveChanges();
                
                DBG.Info(DBG.Registration, "Registering Proxy/Stub dlls:");
                Thunk.Proxy.RegisterProxyStub();


				// HACK
                // This is a HACK to get Windows XP Client COM+ export/import functionallity to work.
                // Export code will try to export System.EnterpriseServices.Thunk.dll because its not in it's
                // list of non-redist dlls.
                // We should get rid of this once this name is in the harcoded list in the export code.
                RegistryPermission rp = new RegistryPermission(PermissionState.Unrestricted);
                rp.Demand();
                rp.Assert();

                RegistryKey rk = Registry.LocalMachine.CreateSubKey("SOFTWARE\\MICROSOFT\\OLE\\NONREDIST");
                rk.SetValue("System.EnterpriseServices.Thunk.dll", "");
                rk.Close();
                // END HACK
            }
            catch(Exception e)
            {
                // Log a failure in some acceptable manner.
				try
				{
					EventLog appLog = new EventLog();
					appLog.Source    = "System.EnterpriseServices";
					String errMsg   = String.Format(Resource.FormatString("Reg_ErrInstSysEnt"), e);
					appLog.WriteEntry(errMsg, EventLogEntryType.Error);
				}
				catch
				{}

                // We threw an exception?  What do we do here?
                //DBG.Assert(false, 
                //           "Installation of System.EnterpriseServices threw an exception!",
                //           "Exception: " + e);
            }
        }

        [ComUnregisterFunction]
        internal static void UninstallUtilityApplication(Type t)
        {
            DBG.Info(DBG.Registration, "Starting utility uninstallation:");
            
            try
            {
                if(Platform.IsLessThan(Platform.W2K)) return;

                ICatalog cat            = null;
                ICatalogCollection apps = null;
                ICatalogObject app      = null;
                int appidx              = 0;
                
                cat = (ICatalog)(new xCatalog());

                if (!Platform.IsLessThan(Platform.Whistler))
                {
                    // AS/URT 97116:  Keep this from failing the install if
                    // we're on a Beta2 Whistler machine, which has a different
                    // GUID for ICatalog2.
                    ICatalog2 cat2 = cat as ICatalog2;
                    if(cat2 != null)
                    {
                        cat2.CurrentPartition(cat2.GlobalPartitionID());
                    }
                }
                
                apps = (ICatalogCollection)(cat.GetCollection("Applications"));
                RegistrationDriver.Populate(apps);
                
                app = FindApplication(apps, _appid, ref appidx);
                if(app != null)
                {
                    // Make sure that we can change this puppy:
                    app.SetValue("Changeable", true);
                    app.SetValue("Deleteable", true);
                    apps.SaveChanges();

                    DBG.Info(DBG.Registration, "Found application!");
                    int idx = 0, compcount = 0;
                    Guid clsid = Marshal.GenerateGuidForType(typeof(RegistrationHelperTx));
                    ICatalogCollection comps = (ICatalogCollection)(apps.GetCollection("Components", app.Key()));
                    ICatalogObject comp = FindComponent(comps, clsid, ref idx);
                    // Store count here, if it is 1, we can delete the app later.
                    compcount = comps.Count();
                    if(comp != null)
                    {
                        DBG.Info(DBG.Registration, "Found component at " + idx);
                        comps.Remove(idx);
                        comps.SaveChanges();
                    }

                    if(comp != null && compcount == 1)
                    {
                        DBG.Info(DBG.Registration, "Removing .NET Utilities application.");
                        // we removed the last component, kill the app
                        apps.Remove(appidx);
                        apps.SaveChanges();
                    }
                    else
                    {
                        // Make sure that we can't change the app:
                        app.SetValue("Changeable", false);
                        app.SetValue("Deleteable", false);
                        apps.SaveChanges();
                    }
                }
            }
            catch(Exception e)
            {
                // Log a failure in some acceptable manner.
				try
				{
					EventLog appLog = new EventLog();
					appLog.Source    = "System.EnterpriseServices";
					String errMsg   = String.Format(Resource.FormatString("Reg_ErrUninstSysEnt"), e);
					appLog.WriteEntry(errMsg, EventLogEntryType.Error);
				}
				catch
				{}

                // We threw an exception?  What do we do here?
                //DBG.Assert(false, 
                //           "Installation of System.EnterpriseServices threw an exception!",
                //           "Exception: " + e);
                DBG.Info(DBG.Registration, "Caught exception: " + e);
            }
        }

        // Implementation:
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.InstallAssembly"]/*' />
        public void InstallAssembly(String assembly, ref String application, ref String tlb, InstallationFlags installFlags, Object sync)
        {
            InstallAssembly(assembly, ref application, null, ref tlb, installFlags, sync);
		}

        // Implementation:
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.InstallAssembly1"]/*' />
        public void InstallAssembly(String assembly, ref String application, String partition, ref String tlb, InstallationFlags installFlags, Object sync)
        {
            RegistrationConfig regConfig = new RegistrationConfig();

            regConfig.AssemblyFile = assembly;
            regConfig.Application = application;
            regConfig.Partition = partition;
            regConfig.TypeLibrary = tlb;
            regConfig.InstallationFlags = installFlags;            

            InstallAssemblyFromConfig(ref regConfig, sync);

            application = regConfig.AssemblyFile;
            tlb = regConfig.TypeLibrary;
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.InstallAssemblyFromConfig"]/*' />
        public void InstallAssemblyFromConfig([MarshalAs(UnmanagedType.IUnknown)] ref RegistrationConfig regConfig, Object sync)
        {
            bool succeed = false;
            try
            {
                DBG.Assert(ContextUtil.IsInTransaction,
                           "Running in transactional helper w/o transaction will deadlock!");
                RegistrationDriver driver = new RegistrationDriver();

                driver.InstallAssembly(regConfig, sync);

                ContextUtil.SetComplete();
                succeed = true;
            }
            finally
            {
                if(!succeed)
                {
                    DBG.Info(DBG.Registration, "Install failed.");
                    ContextUtil.SetAbort();
                }
            }
        }              
       
        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.UninstallAssembly"]/*' />
        public void UninstallAssembly(String assembly, String application, Object sync)
		{
			UninstallAssembly(assembly, application, null, sync);
		}

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.UninstallAssembly1"]/*' />
        public void UninstallAssembly(String assembly, String application, String partition, Object sync)
        {
           RegistrationConfig regConfig = new RegistrationConfig();

           regConfig.AssemblyFile = assembly;
           regConfig.Application = application;
           regConfig.Partition = partition;
                
           UninstallAssemblyFromConfig(ref regConfig, sync);            
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.UninstallAssemblyFromConfig"]/*' />
        public void UninstallAssemblyFromConfig([MarshalAs(UnmanagedType.IUnknown)] ref RegistrationConfig regConfig, Object sync)
        {
            bool succeed = false;
            try
            {                                              
                DBG.Assert(ContextUtil.IsInTransaction,
                           "Running in transactional helper w/o transaction will deadlock!");
                RegistrationDriver helper = new RegistrationDriver();
                helper.UninstallAssembly(regConfig, sync);
                ContextUtil.SetComplete();
                succeed = true;
            }
            finally
            {
                if(!succeed)
                {
                    DBG.Info(DBG.Registration, "Uninstall failed.");
                    ContextUtil.SetAbort();
                }
            }
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.IsInTransaction"]/*' />
        public bool IsInTransaction()
        {
            return(ContextUtil.IsInTransaction);
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.Activate"]/*' />
        protected internal override void Activate()
        {
            DBG.Info(DBG.Registration, "TxHelper: Activate()");
        }

        /// <include file='doc\RegistrationWrappers.uex' path='docs/doc[@for="RegistrationHelperTx.Deactivate"]/*' />
        protected internal override void Deactivate()
        {
            DBG.Info(DBG.Registration, "TxHelper: Deactivate()");
        }        
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\resourcepool.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Threading;
    using System.Runtime.InteropServices;

    [ComImport]
	[Guid("7D8805A0-2EA7-11D1-B1CC-00AA00BA3258")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IObjPool
    {
        void Init([MarshalAs(UnmanagedType.Interface)] Object pClassInfo);
        [return : MarshalAs(UnmanagedType.Interface)]
        Object Get();
        void SetOption(int eOption, int dwOption);
        void PutNew([In, MarshalAs(UnmanagedType.Interface)] Object pObj);
        void PutEndTx([In, MarshalAs(UnmanagedType.Interface)] Object pObj);
        void PutDeactivated([In, MarshalAs(UnmanagedType.Interface)] Object pObj);
        void Shutdown();		
    };

    [ComImport]
    [Guid("C5FEB7C1-346A-11D1-B1CC-00AA00BA3258")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ITransactionResourcePool
    {
        [PreserveSig]
        int PutResource(IntPtr pPool, [MarshalAs(UnmanagedType.Interface)] Object pUnk);
        [PreserveSig]
        int GetResource(IntPtr pPool, [Out, MarshalAs(UnmanagedType.Interface)] out Object obj);
    }
    
    /// <include file='doc\ResourcePool.uex' path='docs/doc[@for="ResourcePool"]/*' />
    public sealed class ResourcePool : IObjPool
    {
        /// <include file='doc\ResourcePool.uex' path='docs/doc[@for="TransactionEndDelegate"]/*' />
        public delegate void TransactionEndDelegate(Object resource);

        /// <include file='doc\ResourcePool.uex' path='docs/doc[@for="ResourcePool.ResourcePool"]/*' />
        public ResourcePool(TransactionEndDelegate cb)
        {
            Platform.Assert(Platform.W2K, "ResourcePool");
            _cb    = cb;
            // _token = Marshal.GetComInterfaceForObject(this, typeof(IObjPool));
        }

        /// <include file='doc\ResourcePool.uex' path='docs/doc[@for="ResourcePool.GetToken"]/*' />
        private IntPtr GetToken()
        {
            return(Marshal.GetComInterfaceForObject(this, typeof(IObjPool)));
        }

        /// <include file='doc\ResourcePool.uex' path='docs/doc[@for="ResourcePool.ReleaseToken"]/*' />
        private void ReleaseToken()
        {
            IntPtr token = Marshal.GetComInterfaceForObject(this, typeof(IObjPool));
            Marshal.Release(token);
            Marshal.Release(token);
        }

        /// <include file='doc\ResourcePool.uex' path='docs/doc[@for="ResourcePool.PutResource"]/*' />
        public bool PutResource(Object resource)
        {
            ITransactionResourcePool p = null;
            IntPtr token = (IntPtr)0;
            bool result  = false;

            try
            {
                // 1. Get the tx pool.
                p = GetResourcePool();
                if(p != null)
                {
	                // 2. Reference our pool token.
        	        token = GetToken();
                	// 3. Stuff object into pool.
	                DBG.Info(DBG.Pool, "Placing resource in context");
	                int hr = p.PutResource(token, resource);
	                if(hr < 0) result = false;
	                else       result = true;
                }
            }
            finally
            {
                // If we failed to stick it in, unref it:
                if(!result && token != (IntPtr)0) Marshal.Release(token);
                if(p != null) Marshal.ReleaseComObject(p);
            }
            return(result);
        }

        /// <include file='doc\ResourcePool.uex' path='docs/doc[@for="ResourcePool.GetResource"]/*' />
        public Object GetResource()
        {
            Object resource = null;
            ITransactionResourcePool p = null;
            IntPtr token = (IntPtr)0;
            
            try
            {
                // 0. Get our token:
                token = GetToken();
                // 1. Get the tx pool.
                p = GetResourcePool();
                if(p != null)
                {
	                // 2. Try to get object out of pool.
                    DBG.Info(DBG.Pool, "Retrieving resource in context");
                    int hr = p.GetResource(token, out resource);
                    // 3. If succeeded, unreference the token.
                    if(hr >= 0)
                    {
                        Marshal.Release(token);
                    }
                }
            }
            finally
            {
                if(token != ((IntPtr)0)) Marshal.Release(token);
                if(p != null) Marshal.ReleaseComObject(p);
            }
            return(resource);
        }
        
        private static readonly Guid GUID_TransactionProperty = new Guid("ecabaeb1-7f19-11d2-978e-0000f8757e2a");
        private TransactionEndDelegate _cb;
        
        private static ITransactionResourcePool GetResourcePool()
        {
            ITransactionResourcePool p = null;
            Object prop = null;
            int    junk = 0;
            int    hr   = 0;
            
            ((IContext)ContextUtil.ObjectContext).GetProperty(GUID_TransactionProperty, out junk, out prop);
            hr = ((ITransactionProperty)prop).GetTransactionResourcePool(out p);
            if(hr >= 0)
                return(p);
            else
                return(null);
        }
        
        void IObjPool.Init(Object p) { 
            DBG.Assert(false, "ComExposedPool: This shouldn't be called");
            throw new NotSupportedException(); 
        }
        
        Object IObjPool.Get() { 
            DBG.Assert(false, "ComExposedPool: This shouldn't be called");
            throw new NotSupportedException(); 
        }
        
        void IObjPool.SetOption(int o, int dw) { 
            DBG.Assert(false, "ComExposedPool: This shouldn't be called");
            throw new NotSupportedException(); 
        }
        
        void IObjPool.PutNew(Object o) { 
            DBG.Assert(false, "ComExposedPool: This shouldn't be called");
            throw new NotSupportedException(); 
        }
        
        void IObjPool.PutDeactivated(Object p) { 
            DBG.Assert(false, "ComExposedPool: This shouldn't be called");
            throw new NotSupportedException(); 
        }

        void IObjPool.Shutdown() { 
            DBG.Assert(false, "ComExposedPool: This shouldn't be called");
            throw new NotSupportedException();
        }
        
        void IObjPool.PutEndTx(Object p) 
        { 
            DBG.Assert(p != null, "ComExposedPool: EndTx delivered a null object!");
            // Release, cause this guy's not in the pool any longer.
            DBG.Info(DBG.Pool, "Returing object on tx end!");
            _cb(p);
            ReleaseToken();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\rwhashtable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: hanyr
// Date: June 2001
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Services;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.EnterpriseServices.Admin;
    using System.Collections;
    using System.Threading;

	// a reader-writer lock protected hashtable 
	internal sealed class RWHashTable
	{
		Hashtable _hashtable;
		ReaderWriterLock _rwlock;
		
		public RWHashTable()
		{
			_hashtable = new Hashtable();
			_rwlock = new ReaderWriterLock();			
		}
		
		public Object Get(Object o)
		{
			try {
				_rwlock.AcquireReaderLock(Timeout.Infinite);
				return _hashtable[o];
			}
			finally {
				_rwlock.ReleaseReaderLock();
			}
		}
		
		public void Put(Object key, Object val)
		{
			try {
				_rwlock.AcquireWriterLock(Timeout.Infinite);
				_hashtable[key] = val;
			}
			finally {
				_rwlock.ReleaseWriterLock();
			}
		}

	}

	// a reader-writer lock protected hashtable that can with null value detection abilities
	internal sealed class RWHashTableEx
	{
		Hashtable _hashtable;
		ReaderWriterLock _rwlock;
		
		public RWHashTableEx()
		{
			_hashtable = new Hashtable();
			_rwlock = new ReaderWriterLock();			
		}
		
		public Object Get(Object o, out bool bFound)
		{
			bFound = false;
			try {
				_rwlock.AcquireReaderLock(Timeout.Infinite);
				Object rwte= _hashtable[o];
				if (rwte!=null)
				{
					bFound = true;
					return ((RWTableEntry)rwte)._realObject;
				}
				else
					return null;
			}
			finally {
				_rwlock.ReleaseReaderLock();
			}
		}
		
		public void Put(Object key, Object val)
		{
			RWTableEntry rwte = new RWTableEntry(val);

			try {
				_rwlock.AcquireWriterLock(Timeout.Infinite);
				_hashtable[key] = rwte;
			}
			finally {
				_rwlock.ReleaseWriterLock();
			}
		}

		internal class RWTableEntry
		{			
			internal Object _realObject;

			public RWTableEntry(Object o)
			{
				_realObject = o;
			}
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\registrationhelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: April 2000
//

// #define _TRACE_STACKS
// #define _DEBUG_PERF

using System.EnterpriseServices;
using System.Runtime.InteropServices;

namespace System.EnterpriseServices
{
    using System;
    using System.Diagnostics;
    using System.Reflection;
    using System.IO;
    using System.Collections;
    using Microsoft.Win32;
    using System.EnterpriseServices.Admin;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;
    
    // Default registration expects the application to already exist.
    /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags"]/*' />
    [Flags, Serializable]
    public enum InstallationFlags
    {
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Default"]/*' />
        Default                        = 0x000,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ExpectExistingTypeLib"]/*' />
        ExpectExistingTypeLib          = 0x001,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.CreateTargetApplication"]/*' />
        CreateTargetApplication        = 0x002,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.FindOrCreateTargetApplication"]/*' />
        FindOrCreateTargetApplication  = 0x004,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ReconfigureExistingApplication"]/*' />
        ReconfigureExistingApplication = 0x008,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ConfigureComponentsOnly"]/*' />
        ConfigureComponentsOnly        = 0x010,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ReportWarningsToConsole"]/*' />
        ReportWarningsToConsole        = 0x020,

        // If none of Register, Install, or Configure are specified,
        // then all are performed.  If any one is specified, only the ones
        // specified are performed.
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Register"]/*' />
        Register                      = 0x100,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Install"]/*' />
        Install                       = 0x200,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Configure"]/*' />
        Configure                     = 0x400,
    }

    [Flags, Serializable]
    internal enum ClassTypes
    {
        Event  = 0x1,
        Normal = 0x2,
        All    = Event|Normal,
    }

    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [Guid("04C6BE1E-1DB1-4058-AB7A-700CCCFBF254")]
    [ComImport]
    internal interface ICatalogServices
    {
        [AutoComplete(true)]
        void Autodone();
        [AutoComplete(false)]
        void NotAutodone();
    }

    /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo"]/*' />

    //
    // The registration helper allows the user to grab an assembly, and do
    // all the steps necessary to get it configured based on its metadata.
    // In theory, all these steps should be transactional:
    //
    // Exception Rules:
    //     We throw RegistrationExceptions.  For the most part, these
    //     exceptions are simply specializations of corresponding COM
    //     exceptions.  When the COMException is generated by the catalog,
    //     we gather up the ErrorInfo collection, and package it into
    //     the RegistrationException.

    [Serializable]
    public sealed class RegistrationErrorInfo
    {
        private String _majorRef;
        private String _minorRef;
        private String _name;
        private int    _errorCode;
        private String _errorString;

        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.MajorRef"]/*' />
        public String MajorRef    { get { return(_majorRef); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.MinorRef"]/*' />
        public String MinorRef    { get { return(_minorRef); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.Name"]/*' />
        public String Name        { get { return(_name); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.ErrorCode"]/*' />
        public int    ErrorCode   { get { return(_errorCode); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.ErrorString"]/*' />
        public String ErrorString { get { return(_errorString); } }

        internal RegistrationErrorInfo(String majorRef, String minorRef, 
                                     String name, int errorCode)
        {
            _majorRef  = majorRef;
            _minorRef  = minorRef;
            _name      = name;
            _errorCode = errorCode;
              
            if(_majorRef == null) _majorRef = "";
            if(_minorRef == null) _minorRef = "<invalid>";
            // Calculate an error string off of the errorcode:
            _errorString = Util.GetErrorString(_errorCode);
            if(_errorString == null)
            {
                _errorString = Resource.FormatString("Err_UnknownHR", _errorCode);
            }
        }
    }

    /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException"]/*' />
    [Serializable]
    public sealed class RegistrationException : SystemException
    {
        private RegistrationErrorInfo[] _errorInfo;

        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException.RegistrationException"]/*' />
        public RegistrationException(String msg)
          : base(msg)
        {
            _errorInfo = null;
        }

        internal RegistrationException(String msg, Exception inner)
          : base(msg, inner)
        {
            _errorInfo = null;
        }

        internal RegistrationException(String msg,
                                       RegistrationErrorInfo[] errorInfo)
          : base(msg)
        {
            _errorInfo = errorInfo;
        }

        internal RegistrationException(String msg,
                                       RegistrationErrorInfo[] errorInfo,
                                       Exception inner)
          : base(msg, inner)
        {
            _errorInfo = errorInfo;
        }

        internal RegistrationException(SerializationInfo info, StreamingContext context) 
          : base(info, context) 
        {
            try {           // work around URT bug #61954
                _errorInfo = (RegistrationErrorInfo[])(info.GetValue("RegistrationException._errorInfo", typeof(RegistrationErrorInfo[])));
            }
            catch (SerializationException)
            {
                _errorInfo = null;
            }
        }

        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext ctx)
        {
            if(info == null) throw new ArgumentException("info");
            
            // Call the parent serializer:
            base.GetObjectData(info, ctx);

            // Shove the error-info array in:
            if (_errorInfo != null)     // work around URT bug #61954
                info.AddValue("RegistrationException._errorInfo", _errorInfo, typeof(RegistrationErrorInfo[]));
        }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException.ErrorInfo"]/*' />
        public RegistrationErrorInfo[] ErrorInfo { get { return(_errorInfo); } }
    }

    internal delegate void Report(String msg);    

    internal class RegistrationExporterNotifySink : ITypeLibExporterNotifySink
    {
        private String                     _tlb;
        // Should this really be a RegistrationHelperTx object, in case
        // we go out of context in the TypeLibExporter?  probably.
        // I'm going to ignore that for now, because the TypeLibExport
        // code isn't covered by our transaction right now.
        private Report _report;

        internal RegistrationExporterNotifySink(String tlb, Report report)
        {
            _tlb    = tlb;
            _report = report;
        }

        public void ReportEvent(ExporterEventKind EventKind, int EventCode, String EventMsg)
        {
            // What do we do here?  We should be able to specify a verbosity flag.
            // Or, we try to 
            DBG.Info(DBG.Registration, EventMsg);
            if(EventKind != ExporterEventKind.NOTIF_TYPECONVERTED && _report != null)
            {
                _report(EventMsg);
            }
        }

        public Object ResolveRef(Assembly asm)
        {
            UCOMITypeLib rslt = null;
            String asmPath = Path.GetDirectoryName(asm.Location);
            
            String typeLibName = Path.Combine(asmPath, asm.GetName().Name) + ".tlb";

            DBG.Info(DBG.Registration, "Auto exporting type library for asm: " + asm);
            
            if (_report != null)
                _report(Resource.FormatString("Reg_AutoExportMsg", asm.GetName(), typeLibName));
            
            rslt = (UCOMITypeLib)(RegistrationDriver.GenerateTypeLibrary(asm, typeLibName, _report));

            // TODO:  Add this to a list of changes which should be backed
            // out if this fails.

            return(rslt);
        }
    }

    [ComImport]
    [Guid("00020406-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICreateTypeLib
    {
        [return : MarshalAs(UnmanagedType.Interface)]
        Object CreateTypeInfo([In, MarshalAs(UnmanagedType.LPStr)] String szName,
                              int tkind);
        
        
        void SetName(String szName);
        
        void SetVersion(short wMajorVerNum, short wMinorVerNum);
        
        void SetGuid([In, MarshalAs(UnmanagedType.LPStruct)] Guid guid);
        
        void SetDocString([In, MarshalAs(UnmanagedType.LPStr)] String szDoc);
        
        void SetHelpFileName([In, MarshalAs(UnmanagedType.LPStr)] String szHelpFileName);
        
        void SetHelpContext(int dwHelpContext);
        
        void SetLcid(int lcid);
        
        void SetLibFlags(int uLibFlags);
        
        void SaveAllChanges();
    }

    internal class ApplicationSpec
    {
        RegistrationConfig _regConfig;        		
        private Assembly   _asm;
        private Type[]     _events;
        private Type[]     _normal;
        private Type[]     _cfgtypes;
        private String     _appid;
        
        internal ApplicationSpec(Assembly asm, RegistrationConfig regConfig)
        {
            _asm = asm;
            _regConfig = regConfig;            

            // Generate an application name from the assembly.
            // Get an ID from the assembly.
            GenerateNames();
            ReadTypes();
        }
        
        internal String Partition 
		{	
			get { return _regConfig.Partition; } 
			set { _regConfig.Partition = value; }
		}
        internal String Name 
        { 
            get { return _regConfig.Application;  } 
            set { _regConfig.Application = value;	  } 
        }
        internal String ID			{ get { return _appid; } }
        internal String TypeLib		{ get { return _regConfig.TypeLibrary; } }
        internal String File		{ get { return _regConfig.AssemblyFile; } }
        internal String AppRootDir  { get { return _regConfig.ApplicationRootDirectory; } }
        internal Assembly Assembly	{ get { return(_asm); } }
        
        internal Type[] EventTypes	{ get { return(_events); } }
        internal Type[] NormalTypes	{ get { return(_normal); } }
        internal Type[] ConfigurableTypes { get { return(_cfgtypes); } }
        
        internal String DefinitiveName 
        {
            get
            {
                if(ID != null) 
					return ID;
                else 
					return Name;
            }
        }
        
        private String FormatApplicationName(Assembly asm)
        {
            String realName = null;
            Object[] attr = asm.GetCustomAttributes(typeof(ApplicationNameAttribute), true);
            if(attr.Length > 0)
            {
                // Get the application name from the Name attribute:
                realName = (String)(((ApplicationNameAttribute)(attr[0])).Value);
                DBG.Info(DBG.Registration, "Attribute name = " + realName);
            }
            else
            {           
                realName = asm.GetName().Name;

                DBG.Info(DBG.Registration, "Generated name \"" + realName + "\" for \"" + asm.FullName + "\"");
            }
            return(realName);
        }
        
        private void GenerateNames()
        {                        
            if(_regConfig.TypeLibrary == null || _regConfig.TypeLibrary.Length == 0)
            {
                String strDir = System.IO.Path.GetDirectoryName(File);
                _regConfig.TypeLibrary = Path.Combine(strDir, _asm.GetName().Name + ".tlb");
            }
            else
            {
                _regConfig.TypeLibrary = Path.GetFullPath(_regConfig.TypeLibrary);
            }

			// Check if name is really an ID.            
            if(Name != null && Name.Length != 0 && '{' == Name[0])
			{
                _appid = "{" + (new Guid(Name)) + "}";
				Name = null;
			}

            if(Name == null || Name.Length == 0)
            {
                // We should strip out the version number, because
                // versions aren't going to work "correctly" anyway.
                // Right?                
                Name		= FormatApplicationName(_asm);
            }
            
            // If there's an ID embedded in the assembly, use that
            // to generate our ID, if not, then we use the NAME
            // as the definitive search item.
            Object[] attr = _asm.GetCustomAttributes(typeof(ApplicationIDAttribute), true);
            if(attr.Length > 0)
            {
                ApplicationIDAttribute a = (ApplicationIDAttribute)(attr[0]);
                _appid = "{" + (new Guid(a.Value.ToString())).ToString() + "}";
            }
            
            // TODO:  Should we use the assembly GUID?  Not a Guid attribute,
            // but a Marshal.GenerateGuidForType type of guid?
        }
        
        public bool Matches(ICatalogObject obj)
        {
            if(ID != null) // Match by ID
            {
                Guid id = new Guid(ID);
                Guid objid = new Guid((String)(obj.GetValue("ID")));
                DBG.Info(DBG.Registration, "Comparing ID with: " + objid);
                if(id == objid)
				{
					/*
					// Make sure the name is in sync with the one from the real app.
					String name = (String)(obj.GetValue("Name"));
					if (0 != String.Compare(this.Name, name, true))
						this.Name = name;
					*/

					return(true);
				}
            }
            else // Match by name
            {
                String name = ((String)(obj.GetValue("Name"))).ToLower(CultureInfo.InvariantCulture);
                DBG.Info(DBG.Registration, "Comparing name with: " + name);
                if(this.Name.ToLower(CultureInfo.InvariantCulture) == name) return(true);
            }
            return(false);
        }
        
        public override String ToString()
        {
            // If we've got an ID, display the ID:
            if(ID != null)
            {
                return("id=" + ID);
            }
            else
            {
                return("name=" + Name);
            }
        }
        
        private void ReadTypes()
        {
            ArrayList eventList = new ArrayList();
            ArrayList normalList = new ArrayList();
            Type[] regTypes = new RegistrationServices().GetRegistrableTypesInAssembly(_asm);
            
            foreach(Type t in regTypes)
            {
                // A type is configurable if it is a ServicedComponent
                if (ServicedComponentInfo.IsTypeServicedComponent(t))
                {
                    Object[] attr = t.GetCustomAttributes(typeof(EventClassAttribute), true);
                    if(attr != null && attr.Length > 0)
                    {
                        eventList.Add(t);
                    }
                    else // Normal type
                    {
                        normalList.Add(t);
                    }
                }
            }
            
            if(eventList.Count > 0)
            {
                _events = new Type[eventList.Count];
                eventList.CopyTo(_events);
            }
            else _events = null;
            
            if(normalList.Count > 0)
            {
                _normal = new Type[normalList.Count];
                normalList.CopyTo(_normal);
            }
            else _normal = null;
            
            int total = (((_normal != null)?_normal.Length:0) 
                         + ((_events != null)?_events.Length:0));
            if(total > 0)
            {
                _cfgtypes = new Type[total];
                if(_events != null) _events.CopyTo(_cfgtypes, 0);
                if(_normal != null) _normal.CopyTo(_cfgtypes, total-_normal.Length);
            }            
        }
    }
    
    internal class RegistrationDriver
    {                                                  
        private ICatalog           _cat;
        private IMtsCatalog        _mts;
        private ICatalogCollection _appColl;
        private Hashtable          _cache;
        private InstallationFlags  _installFlags;
        
        // private RollbackEngine     _rollback;

#if _DEBUG_PERF
        private static int       _saveCount;
        private static int       _popCount;
        private static Hashtable _counts;
#endif        
        internal static void SaveChanges(ICatalogCollection coll)
        {
#if _DEBUG_PERF
            if(_counts == null) _counts = new Hashtable();

            DBG.Info(DBG.Perf, "PERF:  SaveChanges(): " + (++_saveCount)
#if _TRACE_STACKS
                     + new System.Diagnostics.StackTrace().ToString()
#endif
                       );
            if(_counts[coll] == null)
            {
                _counts[coll] = 1;
            }
            else
            {
                int i = ((int)(_counts[coll])) + 1;
                _counts[coll] = i;
                DBG.Assert(i <= 3, "No collection should be saved more than 3 times!");
            }
#endif
            coll.SaveChanges();
        }
        
        internal static void Populate(ICatalogCollection coll)
        {
#if _DEBUG_PERF
            DBG.Info(DBG.Perf, "PERF:  Populate(): " + (++_popCount)
#if _TRACE_STACKS
                     + new System.Diagnostics.StackTrace().ToString()
#endif
                       );
#endif
            try { coll.Populate(); }
            catch(COMException e)
            {
                DBG.Info(DBG.Registration, "Populate caught exception: " + e);
                if(e.ErrorCode != Util.COMADMIN_E_OBJECTERRORS) throw;
            }
            // we just fall through if it was OBJECTERRORS, because the contract
            // says to ignore that problem.
            // TODO:  Feed this back as warnings to regsvcs?
        }
        
        private static RegistrationErrorInfo[] BuildErrorInfoChain(ICatalogCollection coll)
        {
            try {
                Populate(coll);
                int count = coll.Count();
                RegistrationErrorInfo[] errors = null;
                
                if(count > 0) {
                    errors = new RegistrationErrorInfo[count];
                    
                    for(int i = 0; i < count; i++)
                    {
                        String majorRef = null;
                        String minorRef = null;
                        String name;
                        int errorCode = 0;
                        ICatalogObject obj = (ICatalogObject)(coll.Item(i));
                        name      = (String)(obj.GetValue("Name"));
                        errorCode = (int)(obj.GetValue("ErrorCode"));
                        // More info if we're on W2K or above:
                        if(!Platform.IsLessThan(Platform.W2K))
                        {
                            majorRef  = (String)(obj.GetValue("MajorRef"));
                            minorRef  = (String)(obj.GetValue("MinorRef"));
                        }
                        errors[i] = new RegistrationErrorInfo(majorRef, minorRef, name, errorCode);
                    }
                }
                return(errors);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_ErrCollectionErr"), e);
            }
        }

        private static void RegisterTypeLibrary(String tlb)
        {
            // REGKIND_REGISTER = 1
            IntPtr pptlib = (IntPtr)0;
            tlb = Path.GetFullPath(tlb);
            int hr = Util.LoadTypeLibEx(tlb, 1, out pptlib);
            if(hr < 0 || pptlib == (IntPtr)0) {
                Exception e = Util.GetExceptionForHR(hr);
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibRegErr", tlb), e);
            }
            hr = Util.RegisterTypeLib(pptlib, tlb, Path.GetDirectoryName(tlb));
            if(hr < 0 || pptlib == (IntPtr)0) {
                Exception e = Util.GetExceptionForHR(hr);
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibRegErr", tlb), e);
            }
            Marshal.Release(pptlib);
        }
        
        private RegistrationException WrapCOMException(ICatalogCollection coll,
                                                       COMException e, 
                                                       String msg)
        {
            DBG.Assert(_cat != null || _mts != null, "Wrapping COM exception w/ no catalog!");
            RegistrationErrorInfo[] errorInfo = null;
            if(e.ErrorCode == Util.COMADMIN_E_OBJECTERRORS) 
            {
                ICatalogCollection errors = null;
                if(coll == null)
                {
                    errors = (ICatalogCollection)_cat.GetCollection("ErrorInfo");
                }
                else
                {
                    errors = (ICatalogCollection)coll.GetCollection("ErrorInfo", "");
                }
                if(errors != null)
                {
                    errorInfo = BuildErrorInfoChain(errors);
                }
            }
            return new RegistrationException(msg, errorInfo);
        }

        internal void ReportWarning(String msg)
        {
            if((_installFlags & InstallationFlags.ReportWarningsToConsole) != 0)
            {
                Console.WriteLine(msg);
            }
        }

        /*

        public static bool IsV1Assembly(Assembly asm)
        {
            AssemblyName[] anames = asm.GetReferencedAssemblies();
            foreach (AssemblyName an in anames)
            {
                if (an.Name.Equals("mscorlib"))
                {		
                    Version v = an.Version;
                    if ((v.Major == 1) && (v.Minor ==0) && (v.Build==3300))
                        return true;
                    else
                        return false;
                 }
            }
            return false;         // more secure default, assume it is a newer assembly
        }
		
        // We now mandate that every assembly has to make a statement about security one way or another (on or off)
        // see COM+ 30749
        public void CheckAssemblySecurity(Assembly asm)
        {
            if (IsV1Assembly(asm))       // for backcompat, we let V1 assemblies through without any security checks
                return;

            // Only server apps need to have their security checked
			
            // absence of this attribute means it is a library app
            Object[] appattr = asm.GetCustomAttributes(typeof(ApplicationActivationAttribute), true);
            if(appattr.Length == 0)
                return;
            
            ApplicationActivationAttribute aaa = (ApplicationActivationAttribute) appattr[0];
            if (aaa.Value == ActivationOption.Library)   // if explicitly a library app, just return
                return;
            
            // new (post V1) assemblies, must make a statement about security, i.e. the attribute must be in the assembly
            Object[] attr = asm.GetCustomAttributes(typeof(ApplicationAccessControlAttribute), true);
            if(attr.Length > 0)
                return;

            // otherwise, through a security exception			
            throw new RegistrationException(Resource.FormatString("Reg_NoApplicationSecurity"));
        }
        */
        
        // checks if the assembly has a app-security attribute.  If not, report a warning.
        // v1.1 has different defaults (on) than v1.0, so a warning should help users figure out whats going on
        public void CheckForAppSecurityAttribute(Assembly asm)
        {            
            Object[] attr = asm.GetCustomAttributes(typeof(ApplicationAccessControlAttribute), true);
            if(attr.Length > 0)
                return;

            ReportWarning(Resource.FormatString("Reg_NoApplicationSecurity"));								
        }

        // Checks that all ServicedComponent-derived classes in an assembly are valid (i.e. would get Registered).
        // returns false if any classes are invalid
        public void CheckAssemblySCValidity(Assembly asm)
        {
            Type[] asmTypes = asm.GetTypes();
            bool bValid = true;
            ArrayList errorInfoList = null;
            RegistrationServices rs = new RegistrationServices();
            
            
            foreach(Type t in asmTypes)
            {
                if (t.IsClass && t.IsSubclassOf(typeof(ServicedComponent)))
                {
                    if (rs.TypeRequiresRegistration(t)==false && !t.IsAbstract)
                    {
                        bValid = false;
                        
                        if (errorInfoList==null)
                            errorInfoList = new ArrayList();
                        
                        RegistrationErrorInfo ei = new RegistrationErrorInfo(null, null, t.ToString(), unchecked((int)0x80004005));	// E_FAIL
                        errorInfoList.Add(ei);				
                    }

                    MethodInfo[] methods = t.GetMethods();
                    foreach(MethodInfo m in methods)
                    {
                        if(ServicedComponentInfo.IsMethodAutoDone(m)
                           && !ServicedComponentInfo.HasClassInterface(t))
                        {
                            ReportWarning(Resource.FormatString("Reg_NoClassInterface", t.FullName));
                            break;
                        }
                    }
                }
            }
            
            if (!bValid)
            {
                RegistrationErrorInfo[] errorInfo = (RegistrationErrorInfo[]) errorInfoList.ToArray(typeof(RegistrationErrorInfo));
                throw new RegistrationException(Resource.FormatString("Reg_InvalidServicedComponents"), errorInfo);
            }
        }

        // checks to see if the assembly has a strong name
        // by checking for a public key token
        // 
        internal bool AssemblyHasStrongName(Assembly asm)
        {
        AssemblyName an = asm.GetName();

        return (an.GetPublicKeyToken() != null);
        }

    internal Assembly NewLoadAssembly(String assembly)
    {
        Assembly asm;
        
        DBG.Info(DBG.Registration, "NewLoadAssembly: AssemblyName = " + assembly);
        
        try {
            // this will throw a FileNotFoundException if the assembly is not in the GAC
            asm = Assembly.Load(assembly);
            DBG.Info(DBG.Registration, "NewLoadAssembly: Assembly was loaded from the GAC");
            
            // this will throw a RegistrationException if any SC's are invalid
            CheckAssemblySCValidity(asm);                   
            
            // this will throw a RegistrationException if the assembly doesn't have appropriate security attributes
            // CheckAssemblySecurity(asm);
            
            return asm;
        }
        
	// We can tolerate some set of failures from Assembly.Load.
        catch (FileLoadException) {}
	catch (FileNotFoundException) {}
        
        asm = LoadAssembly( assembly );
        DBG.Info(DBG.Registration, "NewLoadAssembly: Assembly was loaded from file");
            
        // this will throw a RegistrationException if any SC's are invalid
        CheckAssemblySCValidity(asm);

        // this will throw a RegistrationException if the assembly doesn't have appropriate security attributes
        // CheckAssemblySecurity(asm);
            
            // bug 23665
            // check that assembly has a strong name
            if (!AssemblyHasStrongName(asm))
            {
                throw new RegistrationException(Resource.FormatString("Reg_NoStrongName",assembly));
            }
					
		return asm;
		}		
	
    
    internal Assembly LoadAssembly(String assembly)
        {
            assembly = Path.GetFullPath(assembly).ToLower(CultureInfo.InvariantCulture);

            // 1. Load the given assembly.
            bool dirChanged = false;
            String initialDir = null;

            String assemblyDir = Path.GetDirectoryName(assembly);
            initialDir = Environment.CurrentDirectory;

            if(initialDir != assemblyDir) {
                Environment.CurrentDirectory = assemblyDir;
                dirChanged = true;
            }
            
            Assembly asm = null;
            try {
                asm = Assembly.LoadFrom(assembly);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_AssemblyLoadErr", assembly), e);
            }

            if(dirChanged) Environment.CurrentDirectory = initialDir;
            if(asm == null) throw new RegistrationException(Resource.FormatString("Reg_AssemblyLoadErr", assembly));

            // special case our own assembly
        if (asm.GetName().Name == "System.EnterpriseServices")
                    throw new RegistrationException(Resource.FormatString("RegSvcs_NoBootstrap"));

            return(asm);
        }

        internal static Object GenerateTypeLibrary(Assembly asm, String tlb, Report report)
        {
           try {
                TypeLibConverter converter = new TypeLibConverter();
                RegistrationExporterNotifySink sink = new RegistrationExporterNotifySink(tlb, report);
                Object o = converter.ConvertAssemblyToTypeLib(asm, 
                                                              tlb, 
                                                              TypeLibExporterFlags.OnlyReferenceRegistered, 
                                                              sink);
                ICreateTypeLib creat = (ICreateTypeLib)o;
                creat.SaveAllChanges();
                RegisterTypeLibrary(tlb);
                return(o);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibGenErr", tlb, asm), e);
            }
        }

        private void PostProcessApplication(ICatalogObject app, ApplicationSpec spec)
        {
            try {
	            DBG.Info(DBG.Registration, "PostProcessing app: " + spec);
	            
	            if (AfterSaveChanges(spec.Assembly, app, _appColl, "Application", _cache))
	            {
	                SaveChanges(_appColl);
	            }
             }
            catch (Exception e)
            {
            	throw new RegistrationException(Resource.FormatString("Reg_ConfigUnkErr"), e);
            }
        }
		
        private ICatalogObject CreateApplication(ApplicationSpec spec, bool checkExistence)
        {
            DBG.Info(DBG.Registration, "FindOrCreating app: " + spec);
            if(checkExistence)
            {
                ICatalogObject temp = FindApplication(_appColl, spec);
                if(temp != null) 
                {
                    throw new RegistrationException(Resource.FormatString("Reg_AppExistsErr", spec));
                }
            }

            ICatalogObject app = (ICatalogObject)(_appColl.Add());

            CheckForAppSecurityAttribute(spec.Assembly);	// will just give a warning if no app-security attribute in the assembly

            ApplicationDefaults(app, _appColl);
            app.SetValue("Name", spec.Name);
            if(spec.ID != null)
                app.SetValue("ID", spec.ID);
            if(spec.AppRootDir != null)
            {
                Platform.Assert(Platform.Whistler, "ApplicationRootDirectory");
                app.SetValue("ApplicationDirectory", spec.AppRootDir);
            }
            SaveChanges(_appColl);
            ConfigureObject(spec.Assembly, app, _appColl, "Application", _cache);
            // Make sure we have an up-to-date name:
            spec.Name = (String)(app.GetValue("Name"));
            SaveChanges(_appColl);
            return(app);
        }

        private ICatalogObject FindOrCreateApplication(ApplicationSpec spec, bool configure)
        {
            DBG.Info(DBG.Registration, "FindOrCreating app: " + spec + ": configure = " + configure);
            ICatalogObject app = FindApplication(_appColl, spec);
            
            if(app == null)
            {
                app = CreateApplication(spec, false);
            }
            else if(configure) // Configure the application:
            {
                CheckForAppSecurityAttribute(spec.Assembly);	// will give a warning if no app-security attribute in the assembly
            	
                ApplicationDefaults(app, _appColl);
                app.SetValue("Name", spec.Name);
                if(!Platform.IsLessThan(Platform.Whistler))
                {
                    app.SetValue("ApplicationDirectory", (spec.AppRootDir == null) ? "" : spec.AppRootDir);
                }
                ConfigureObject(spec.Assembly, app, _appColl, "Application", _cache);
                // Make sure we have an up-to-date name:
                spec.Name = (String)(app.GetValue("Name"));
                SaveChanges(_appColl);                
            }
            return(app);
        }

        private void InstallTypeLibrary(ApplicationSpec spec)
        {
            if(Platform.IsLessThan(Platform.W2K))
            {
                InstallTypeLibrary_MTS(spec);
            }
            else
            {
                InstallTypeLibrary_W2K(spec);
            }
        }

        private void InstallTypeLibrary_W2K(ApplicationSpec spec)
        {
            try 
            {
                Object[] saFileNames = new Object[1];
                saFileNames[0] = spec.TypeLib;
                
                // Normal classes:
                Type[] regTypes = spec.NormalTypes;
                if(regTypes != null)
                {
                    DBG.Info(DBG.Registration, "Trying to get ID's for " + regTypes.Length + " components.");
                    if(regTypes == null || regTypes.Length == 0)
                    {
                        throw new RegistrationException(Resource.FormatString("Reg_NoConfigTypesErr"));
                    }
                    
                    // Run through these types, and get GUID's for them.
                    Object[] saCLSID = new Object[regTypes.Length];
                    for(int i = 0; i < regTypes.Length; i++)
                    {
                        DBG.Info(DBG.Registration, "ID: " + Marshal.GenerateGuidForType(regTypes[i]));
                        saCLSID[i] = "{" + Marshal.GenerateGuidForType(regTypes[i]).ToString() + "}";
                    }
                    
                    // Now, we've got components to install.
                    DBG.Info(DBG.Registration, "Installing multiple components.");
                    _cat.InstallMultipleComponents(spec.DefinitiveName, ref saFileNames, ref saCLSID);
                }

                // Event classes:
                regTypes = spec.EventTypes;
                if(regTypes != null)
                {
                    DBG.Info(DBG.Registration, "Trying to get ID's for " + regTypes.Length + " components.");
                    if(regTypes == null || regTypes.Length == 0)
                    {
                        throw new RegistrationException(Resource.FormatString("Reg_NoConfigTypesErr"));
                    }
                    
                    // Run through these types, and get GUID's for them.
                    Object[] saCLSID = new Object[regTypes.Length];
                    for(int i = 0; i < regTypes.Length; i++)
                    {
                        DBG.Info(DBG.Registration, "ID: " + Marshal.GenerateGuidForType(regTypes[i]));
                        saCLSID[i] = "{" + Marshal.GenerateGuidForType(regTypes[i]).ToString() + "}";
                    }
                    
                    // Now, we've got components to install.
                    DBG.Info(DBG.Registration, "Installing multiple components.");

                    _cat.InstallMultipleEventClasses(spec.DefinitiveName, ref saFileNames, ref saCLSID);
                }
            }
            catch(COMException e)
            {
                // It's safe to pass in NULL as the collection here, because
                // we're on W2K or above.
                throw WrapCOMException(null, e, 
                                       Resource.FormatString("Reg_TypeLibInstallErr", spec.TypeLib, spec.Name));
            }
        }

        private void InstallTypeLibrary_MTS(ApplicationSpec spec)
        {
            ICatalogCollection comps = null;
            try 
            {
                // TODO:  Figure out how to hack interfaces in here:
                DBG.Assert(_mts != null, "MTS object is null on MTS machine?");
                ICatalogObject app = FindApplication(_appColl, spec);
                comps = (ICatalogCollection)_appColl.GetCollection(CollectionName.Components, app.Key());
                Populate(comps);
                IComponentUtil util = (IComponentUtil)(comps.GetUtilInterface());
                foreach(Type t in spec.NormalTypes)
                {
                    Guid id = Marshal.GenerateGuidForType(t);
                    // We have to make sure this guy doesn't already
                    // exist in this application:
                    bool found = false;
                    for(int i = 0; i < comps.Count(); i++)
                    {
                        ICatalogObject o = (ICatalogObject)(comps.Item(i));
                        Guid possible = new Guid((String)(o.Key()));
                        if(possible == id) 
                        {
                            found = true;
                            break;
                        }
                    }

                    if(!found) util.ImportComponent("{" + id + "}");
                }
            }
            catch(COMException e)
            {
                throw WrapCOMException(comps, e, 
                                       Resource.FormatString("Reg_TypeLibInstallErr", spec.TypeLib, spec.Name));
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibInstallErr", spec.TypeLib, spec.Name),
                                                e);
            }
        }

        private ICatalogObject FindApplication(ICatalogCollection apps, ApplicationSpec spec)
        {
            DBG.Info(DBG.Registration, "Finding app: " + spec);
            for(int i = 0; i < apps.Count(); i++)
            {
                ICatalogObject obj = (ICatalogObject)(apps.Item(i));
                if(spec.Matches(obj)) return(obj);
            }
            return(null);
        }

        private void ApplicationDefaults(ICatalogObject obj, ICatalogCollection coll)
        {
            DBG.Info(DBG.Registration, "Setting application defaults");
            if(Platform.IsLessThan(Platform.W2K))
            {
                obj.SetValue("Activation", "Inproc");
                obj.SetValue("SecurityEnabled", "N");
                obj.SetValue("Authentication", AuthenticationOption.Packet);
            }
            else
            {
                obj.SetValue("Activation", ActivationOption.Library);
                obj.SetValue("AccessChecksLevel", AccessChecksLevelOption.Application);
                obj.SetValue("ApplicationAccessChecksEnabled", true);
                obj.SetValue("Authentication", AuthenticationOption.Packet);
                obj.SetValue("CRMEnabled", false);
                obj.SetValue("EventsEnabled", true);
                obj.SetValue("ImpersonationLevel", ImpersonationLevelOption.Impersonate);
                obj.SetValue("QueuingEnabled", false);
                obj.SetValue("QueueListenerEnabled", false);
            }
            if(!Platform.IsLessThan(Platform.Whistler))
            {
                obj.SetValue("SoapActivated", false);
                obj.SetValue("QCListenerMaxThreads", 0);    // 0 means use default number of player threads
            }

        }

        internal bool ConfigureObject(ICustomAttributeProvider t, 
                                      ICatalogObject obj,
                                      ICatalogCollection coll,
                                      String prefix, 
                                      Hashtable cache)
        {
            bool dirty = false;

            DBG.Info(DBG.Registration, "Configuring object: " + prefix + " " + t);
            Object[] attributes = t.GetCustomAttributes(true);
            cache[prefix]              = obj;
            cache[prefix+"Type"]       = t;
            cache[prefix+"Collection"] = coll;
            cache["CurrentTarget"]     = prefix;
            
            foreach(Object attr in attributes)
            {
                if(attr is IConfigurationAttribute)
                {
                	try {
                        IConfigurationAttribute config = (IConfigurationAttribute)attr;
                        if(config.IsValidTarget(prefix)) 
                        {
                            DBG.Info(DBG.Registration, "Applying: " + attr.GetType().FullName);
                            if(config.Apply(cache)) dirty = true;
                        }
                    }
                    catch (Exception e)
                    {
                    	 throw new RegistrationException(Resource.FormatString("Reg_ComponentAttrErr", obj.Name(), attr), e);
                    }
                }
            }
            return(dirty);
        }

        internal bool AfterSaveChanges(ICustomAttributeProvider t, 
                                        ICatalogObject obj, 
                                        ICatalogCollection coll,
                                        String prefix, 
                                        Hashtable cache)
        {
            bool dirty = false;

            DBG.Info(DBG.Registration, "After save changes on: " + prefix + " " + t);
            Object[] attributes = t.GetCustomAttributes(true);
            cache[prefix]              = obj;
            cache[prefix+"Type"]       = t;
            cache[prefix+"Collection"] = coll;
            cache["CurrentTarget"]     = prefix;
            
            foreach(Object attr in attributes)
            {
                if(attr is IConfigurationAttribute)
                {
                    IConfigurationAttribute config = (IConfigurationAttribute)attr;
                    if(config.IsValidTarget(prefix))
                    {
                        if(config.AfterSaveChanges(cache)) dirty = true;
                    }
                }
            }
            return(dirty);
        }
        
        internal void ConfigureCollection(ICatalogCollection coll, IConfigCallback cb)
        {
            bool postChanged = false;

            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();

            // Make sure that we're all set to defaults.
            foreach(Object o in cb)
            {
                // Set defaults:  Find the item in the collection, configure
                // appropriately
                Object catObj = cb.FindObject(coll, o);
                cb.ConfigureDefaults(catObj, o);
            }
            SaveChanges(coll);

            postChanged = false;
            foreach(Object o in cb)
            {
                Object catObj = cb.FindObject(coll, o);
                if(cb.Configure(catObj, o)) postChanged = true;
            }
            SaveChanges(coll);

            postChanged = false;
            foreach(Object o in cb)
            {
                Object catObj = cb.FindObject(coll, o);
                if(cb.AfterSaveChanges(catObj, o)) postChanged = true;
            }
            if(postChanged) SaveChanges(coll);

            cb.ConfigureSubCollections(coll);
        }

        private void ConfigureComponents(ApplicationSpec spec)
        {
            ICatalogCollection catComps = null;

            try 
            {
                ICatalogObject app = FindApplication(_appColl, spec);
                if(app == null) throw new RegistrationException(Resource.FormatString("Reg_AppNotFoundErr", spec));
                
                // Make sure we've got the Application stored up in the cache:
                _cache["Application"] = app;
                _cache["ApplicationType"] = spec.Assembly;
                _cache["ApplicationCollection"] = _appColl;

                catComps = (ICatalogCollection)(_appColl.GetCollection(CollectionName.Components, app.Key()));
                ConfigureCollection(catComps, new ComponentConfigCallback(catComps, spec, _cache, this, _installFlags));
            }
            catch(RegistrationException)
            {
                throw;
            }
            catch(COMException e)
            {
                throw WrapCOMException(catComps, e, Resource.FormatString("Reg_ConfigErr"));
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_ConfigUnkErr"), e);
            }
        }

		internal bool IsAssemblyRegistered(ApplicationSpec spec)
		{
			bool fPresent = false;

            // Bail out if there are no configurable types in the assembly..			
			if (null == spec || null == spec.ConfigurableTypes) 
				return false;

            RegistryKey BaseClsIdKey = Registry.ClassesRoot.OpenSubKey("CLSID");
            if (null == BaseClsIdKey)
				throw new RegistrationException(Resource.FormatString("Reg_RegistryErr"));

			// Check if any of the types in the assembly are registered.
            foreach(Type t in spec.ConfigurableTypes)
            {
                String strClsId = "{" + Marshal.GenerateGuidForType(t).ToString() + "}";

				RegistryKey ClsIdKey		= null;
				RegistryKey InProcServerKey = null;

				try
				{	// Open the InProcServer32 key.
					ClsIdKey = BaseClsIdKey.OpenSubKey(strClsId);
					if (ClsIdKey != null)
					{
						InProcServerKey = ClsIdKey.OpenSubKey("InprocServer32");
						if (InProcServerKey != null)
						{
							// Try reading the Assembly and Class values.
							if (null != InProcServerKey.GetValue("Assembly") &&
							    null != InProcServerKey.GetValue("Class"))
							{
								fPresent = true;
								break;
							}
						}
					}
				}
				catch
				{} // Continue if any error.
				finally
				{
					if (null != InProcServerKey)
						InProcServerKey.Close();

					if (null != ClsIdKey)
						ClsIdKey.Close();
				}

			}

			BaseClsIdKey.Close();
			return fPresent;
		}

		internal void UnregisterAssembly(Assembly asm, ApplicationSpec spec)
		{
			bool unregAssembly = true;

            // Bail out if no assembly.
			if (null == asm)
				return;

            // Bail out if there are no configurable types in the assembly..			
			if (null == spec || null == spec.ConfigurableTypes) 
				return;

			// Check always on Whistler and above.
			if (!Platform.IsLessThan(Platform.Whistler) && null != _cat) 
            {	
				// Check if any of the types in the assembly are still in use in other partitions.
                foreach(Type t in spec.ConfigurableTypes)
                {
                    String id = "{" + Marshal.GenerateGuidForType(t).ToString() + "}";
					
					try
					{
						int		nVersions	= 0;
						/* 
						// Early binding.
						Object		o1, o2, o3, o4;
						ICatalog2	cat2	= (ICatalog2)_cat;
						nVersions = cat2.GetComponentVersions(id, out o1, out o2, out o3, out o4)
						*/
						
						// Late binding.
						Type ot	  = _cat.GetType();
						try
						{
							nVersions = (int)InvokeMemberHelper(ot,
                                                            "GetComponentVersions",
															BindingFlags.InvokeMethod,
															null,
															_cat,
															new object[] {id, null, null, null, null});
						}
						catch(COMException e)
						{
							if (Util.DISP_E_UNKNOWNNAME == e.ErrorCode)
							{
								// Try the new method name.
								nVersions = (int)InvokeMemberHelper(ot, 
                                                                "GetComponentVersionCount",
																BindingFlags.InvokeMethod,
																null,
																_cat,
                                                                new object[] {id} );
							}
							else
							{
								throw;	// re-throw.
							}
						}

						if (nVersions > 0)
						{
							unregAssembly = false;
							break;
						}
					}
					catch(COMException e)
					{
						if (Util.REGDB_E_CLASSNOTREG != e.ErrorCode)
							throw;
					}	// else continue if class not registered.
                }
			}

			if (unregAssembly)
            {
				ClassicUnregistration(asm);
                try { UnregisterTypeLib(asm); }
                catch(Exception) {}
            }
		}

        internal void ClassicRegistration(Assembly asm)
        {
            // UNDONE - this is too restrictive
            //
            RegistryPermission rp = new RegistryPermission(PermissionState.Unrestricted);
            rp.Demand();
            rp.Assert();

            try {
                RegistrationServices rs = new RegistrationServices();
                
                rs.RegisterAssembly(asm, AssemblyRegistrationFlags.SetCodeBase);
                // _rollback.Add(new ClassicRegistrationRollback(this, asm));
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_AssemblyRegErr", asm), e);
            }
        }

        internal void ClassicUnregistration(Assembly asm)
        {
            try {
                new RegistrationServices().UnregisterAssembly(asm);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_AssemblyUnregErr", asm), e);
            }
        }

        internal void UnregisterTypeLib(Assembly asm)
        {
            IntPtr pAttr = IntPtr.Zero;
            Object tlbobj = null;
            UCOMITypeLib tlb = null;

            try
            {
                Guid id = Marshal.GetTypeLibGuidForAssembly(asm);
                Version ver = asm.GetName().Version;
                if(ver.Major == 0 && ver.Minor == 0)
                {
                    ver = new Version(1, 0);
                }
                
                if (0 != Util.LoadRegTypeLib(id, (short)ver.Major, (short)ver.Minor, 0, out tlbobj))
                	return;
                	
                tlb = (UCOMITypeLib)tlbobj;
                // Retrieve the version information from the typelib.
                tlb.GetLibAttr(out pAttr);
                
                // Copy the int we got back from GetLibAttr to a TypeLibAttr struct.
                TYPELIBATTR attr = (TYPELIBATTR)Marshal.PtrToStructure((IntPtr)pAttr, typeof(TYPELIBATTR));

                // Unregister the typelib.
                Util.UnRegisterTypeLib(attr.guid, attr.wMajorVerNum, attr.wMinorVerNum, attr.lcid, attr.syskind);
            }
            finally
            {
                if(tlb != null && pAttr != IntPtr.Zero) 
                    tlb.ReleaseTLibAttr(pAttr);
                if(tlb != null)
                    Marshal.ReleaseComObject(tlb);
            }
        }

        private Object InvokeMemberHelper(Type type, String name, BindingFlags invokeAttr, Binder binder, Object target, Object[] args)
        {
            try
            {
                return type.InvokeMember(name, invokeAttr, binder, target, args);
            }
            catch(TargetInvocationException e)
            {
                throw e.InnerException;
            }
        }

        private void PrepDriver(ref ApplicationSpec spec)
        {
            if(Platform.IsLessThan(Platform.W2K)) // NT and below.
            {	
                try 
                {
                    _cat = null;
                    _mts = (IMtsCatalog)(new xMtsCatalog());
                    _appColl = (ICatalogCollection)(_mts.GetCollection(CollectionName.Applications));
                    Populate(_appColl);
                }
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }
            }
            else if (Platform.IsLessThan(Platform.Whistler)) // W2k.
            {	
                try 
                {
                    _mts = null;
                    _cat = (ICatalog)(new xCatalog());
                    _appColl = (ICatalogCollection)(_cat.GetCollection(CollectionName.Applications));
                    Populate(_appColl);
                }
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }
            }
			else // Whistler and above.
			{	
				/*
				// Early Binding.
				ICatalog2 cat2 = null;
				*/

				// Get the new com+ admin interface.
                try 
                {	
					/*
					// Early Binding.
					//cat2 = (ICatalog2)(new xCatalog());
					*/

					// Late Binding.
					_cat = (ICatalog)(new xCatalog());
				}
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }

				// Try to find a partition for this app.
				if ((null == spec.Partition || 0 == spec.Partition.Length) && null != spec.ID)
				{
					try
					{
						/*
						// Early Binding.
						spec.Partition = cat2.GetAppPartitionId(spec.ID);
						*/

						// Late Binding.
						Type ot			= _cat.GetType();
						try
						{
							spec.Partition	= (String)InvokeMemberHelper(ot, 
                                                                        "GetAppPartitionId",
																		BindingFlags.InvokeMethod,
																		null,
																		_cat,
																		new object[] {spec.ID});
						}
						catch(COMException e)
						{
							if (Util.DISP_E_UNKNOWNNAME == e.ErrorCode)
							{
								// Try the new method name.
								spec.Partition	= (String)InvokeMemberHelper(ot,
                                                                            "GetPartitionID",
																			BindingFlags.InvokeMethod,
																			null,
																			_cat,
																			new object[] {spec.ID});
							}
						}
					}
					catch	// default to app not present if any error.
					{}
				}
				
				// If specified, set target partition.
				if (null != spec.Partition && 0 != spec.Partition.Length)
				{
					try
					{
						/*
						// Early Binding.
						cat2.SetApplicationPartition(spec.Partition);
						*/

						// Late Binding.
						Type ot = _cat.GetType();
						try
						{
							InvokeMemberHelper(ot, 
                                            "SetApplicationPartition",
											BindingFlags.InvokeMethod,
											null,
											_cat,
											new object[] {spec.Partition} );
						}
						catch(COMException e)
						{
							if (Util.DISP_E_UNKNOWNNAME == e.ErrorCode)
							{
								// Try setting the new partition property.
								InvokeMemberHelper(ot,
                                                "CurrentPartition",
												BindingFlags.SetProperty,
												null,
												_cat,
												new object[] {spec.Partition} );
							}
							else
							{
								throw;	// re-throw original exception.
							}
						}

					}
					catch(Exception e)
					{
						throw new RegistrationException(Resource.FormatString("Reg_PartitionErr", spec.Partition), e);
					}
				}

				// Init "this" obj data members.
				try
				{
                    _mts = null;

					/* 
					// Early Binding.
                    _cat = (ICatalog)cat2;
					*/

                    _appColl = (ICatalogCollection)(_cat.GetCollection(CollectionName.Applications));
                    Populate(_appColl);
                }
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }
			}
            _cache    = new Hashtable();
            // _rollback = new RollbackEngine();
        }

        private void CleanupDriver()
        {
            _cat     = null;
            _cache   = null;
            _appColl = null;
        }

        private void PrepArguments(RegistrationConfig regConfig)
        {
            // We must have an assembly name                        
            if(regConfig.AssemblyFile == null || regConfig.AssemblyFile.Length == 0)
            {
                throw new RegistrationException(Resource.FormatString("Reg_ArgumentAssembly"));
            }

            // If we're expecting an existing typelib, TLB must be non-null:           
            if((regConfig.InstallationFlags & InstallationFlags.ExpectExistingTypeLib) != 0)
            {
                if(regConfig.TypeLibrary == null || regConfig.TypeLibrary.Length == 0) 
                {
                    throw new RegistrationException(Resource.FormatString("Reg_ExpectExisting"));
                }
            }

            // ForceCreate and FindOrCreate are mutually exclusive:
            if(((regConfig.InstallationFlags & InstallationFlags.CreateTargetApplication) != 0) 
               && ((regConfig.InstallationFlags & InstallationFlags.FindOrCreateTargetApplication) != 0))
            {
                throw new RegistrationException(Resource.FormatString("Reg_CreateFlagErr"));
            }

            if(!(((regConfig.InstallationFlags & InstallationFlags.Register) != 0)
                 || ((regConfig.InstallationFlags & InstallationFlags.Install) != 0)
                 || ((regConfig.InstallationFlags & InstallationFlags.Configure) != 0)))
            {
                regConfig.InstallationFlags |= (InstallationFlags.Register | InstallationFlags.Install | InstallationFlags.Configure);
            }

            _installFlags = regConfig.InstallationFlags;
            if(Platform.IsLessThan(Platform.W2K)) _installFlags |= InstallationFlags.ConfigureComponentsOnly;

			// Validate partition info.			
			if(null != regConfig.Partition && 0 != regConfig.Partition.Length)
			{
				// Check for default partitions.
				String strDefPartitionName	= "Base Application Partition";
				String strDefPartitionId	= "{41E90F3E-56C1-4633-81C3-6E8BAC8BDD70}";
				
				if (0 == String.Compare(regConfig.Partition, strDefPartitionId, true, CultureInfo.InvariantCulture)   ||
					0 == String.Compare(regConfig.Partition, strDefPartitionName, true, CultureInfo.InvariantCulture))
				{                    					
					regConfig.Partition = null;
				}

				// Partitions are only supported in Whistler or above.
				if (null != regConfig.Partition && Platform.IsLessThan(Platform.Whistler))
				{
					throw new RegistrationException(Resource.FormatString("Reg_PartitionsNotSupported"));
				}
			}
            
			if (regConfig.ApplicationRootDirectory != null)
			{
			    // approotdir should be have a valid path form.
			    if (!Directory.Exists(regConfig.ApplicationRootDirectory))
			    {
			        throw new RegistrationException(Resource.FormatString("Reg_BadAppRootDir"));
			    }
			}
        }		                  

        public void InstallAssembly(RegistrationConfig regConfig,                                    
                                    Object obSync)
        {
            Assembly        asm      = null;
            ApplicationSpec spec     = null;
            CatalogSync     sync     = null;
            bool            fUnreg   = false;
            bool            fUnregTlb = false;
            
            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();
		
            Perf.Tick("RegistrationHelper - Begin");

            try {
            
            	ICatalogObject icoApp = null;
            
                PrepArguments(regConfig);
                
                // 1. Load the given assembly.
                
                asm = NewLoadAssembly(regConfig.AssemblyFile);
                
                // Generate any names we're going to need to generate.
                
                spec = new ApplicationSpec(asm, regConfig);

                // bail out if there are no configurable types in the assembly..
                // the call to NewLoadAssembly won't have added the assembly to the GAC in this condition
                if (spec.ConfigurableTypes == null) 
                {
                    regConfig.Application = null;
                    regConfig.TypeLibrary = null;
                    return; 
                }

                if(obSync != null)
                {
                    if(!(obSync is CatalogSync)) throw new ArgumentException("obSync");
                    sync = (CatalogSync)obSync;
                }
                
                // 0. Prep the driver object:
                PrepDriver(ref spec);
                
                Perf.Tick("RegistrationDriver - Load done");
                
                if((regConfig.InstallationFlags & InstallationFlags.Register) != 0)
                {
                    // 3. Register its members.
                    fUnreg = !IsAssemblyRegistered(spec);
                    ClassicRegistration(spec.Assembly);
                    
                    // 4. Generate a type-library. (or register if we've just got
                    // an existing one.
                    if((regConfig.InstallationFlags & InstallationFlags.ExpectExistingTypeLib) != 0)
                    {
                        RegisterTypeLibrary(spec.TypeLib);
                    }
                    else { // Generate target type library.
                        fUnregTlb = true;
                        GenerateTypeLibrary(spec.Assembly,                                           
                                            spec.TypeLib,
                                            new Report(this.ReportWarning));
                    }
                    Perf.Tick("RegistrationDriver - Classic registration done");
                }
                
                if(((regConfig.InstallationFlags & InstallationFlags.Install) != 0) 
                   && (spec.ConfigurableTypes != null))
                {
                    // 5. Create the application if it does not exist.
                    if((regConfig.InstallationFlags & InstallationFlags.CreateTargetApplication) != 0) 
                    {
                        icoApp = CreateApplication(spec, true);
                    }
                    else if ((regConfig.InstallationFlags & InstallationFlags.FindOrCreateTargetApplication) != 0) 
                    {
                        icoApp = FindOrCreateApplication(spec, ((regConfig.InstallationFlags & InstallationFlags.ReconfigureExistingApplication) != 0));
                    }
                    // else, we expect an existing application.
                    
                    // 6. Install the type-library under the given application.
                    InstallTypeLibrary(spec);
                    
                    if(sync != null) sync.Set();
                    
                    Perf.Tick("RegistrationDriver - Installation done");
                }
                
                if(((regConfig.InstallationFlags & InstallationFlags.Configure) != 0) 
                   && (spec.ConfigurableTypes != null))
                {
                    // 7. Configure the registrable components from the assembly.
                    ConfigureComponents(spec);
                    
                    if(sync != null) sync.Set();
                    Perf.Tick("RegistrationDriver - Configuration done");
                }
                
                if (icoApp!=null)
                {
                    PostProcessApplication(icoApp, spec); // AfterSaveChanges for Applications happens here, after we've configured the components.
                }
                 
                // 8.  Done, cleanup driver
                CleanupDriver();                               
                
                Perf.Tick("RegistrationDriver - Transaction complete");
            }
            catch(Exception)
            {
                // TODO:  On failure, clean up things which succeeded,
                // such as registration, typelib creation.
                // We swallow any exceptions that this throws, because
                // we prefer to have the previously thrown error.
				if (fUnreg && null != asm)
                {
                    try { ClassicUnregistration(asm); }
                    catch(Exception) {}
                }
                if(fUnregTlb && null != asm)
                {
                    try { UnregisterTypeLib(asm); }
                    catch(Exception) {}
                }

                throw;
            }
        }

        // Helper function for UninstallAssembly.
        private int FindIndexOf(String[] arr, String key)
        {
            for(int i = 0; i < arr.Length; i++)
            {
                if(arr[i] == key) return(i);
            }
            return(-1);
        }   

        public void UninstallAssembly(RegistrationConfig regConfig, Object obSync)
        {
            CatalogSync     sync = null;            
            
            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();
		
            if(obSync != null)
            {
                if(!(obSync is CatalogSync)) throw new ArgumentException("obSync");
                sync = (CatalogSync)obSync;
            }

            DBG.Info(DBG.Registration, "Uninstalling assembly: " + regConfig.AssemblyFile);
            
            // 0. Load the given assembly.
            Assembly asm = NewLoadAssembly(regConfig.AssemblyFile);
            
            // Generate any names we're going to need to generate.
            ApplicationSpec spec = new ApplicationSpec(asm, regConfig);
            DBG.Info(DBG.Registration, "Application name = " + spec.Name);
            
            // bail out if there are no configurable types in the assembly..			
			if (spec.ConfigurableTypes == null) 
				return; 
			
            // 1. Prep the helper object:
            PrepDriver(ref spec);

            // If we didn't configure any components, no app exists.
            if(spec.ConfigurableTypes != null) 
            {
                // To do the uninstall, we need to do open up the components
                // list in the target application, and remove all components
                // in it that are listed in the ConfigureableComponents list.
                ICatalogObject app = FindApplication(_appColl, spec);
                
                if(app == null) throw new RegistrationException(Resource.FormatString("Reg_AppNotFoundErr", spec));
                
                // Get the components in this puppy:
                ICatalogCollection compColl = (ICatalogCollection)(_appColl.GetCollection(CollectionName.Components, app.Key()));
                
                String[] keys  = new String[spec.ConfigurableTypes.Length];
                
                int k = 0;
                foreach(Type t in spec.ConfigurableTypes)
                {
                    keys[k] = Marshal.GenerateGuidForType(t).ToString();
                    k++;
                }
                
                Populate(compColl);
                bool empty = true;
                for(int i = 0; i < compColl.Count();)
                {
                    ICatalogObject obj = (ICatalogObject)(compColl.Item(i));
                    String key = (String)(obj.Key());
                    
                    // Make sure we've got the same formatting as we have above:
                    key = (new Guid(key)).ToString();
                    
                    if(FindIndexOf(keys, key) != -1)
                    {
                        // Found it, let's delete it:
                        DBG.Info(DBG.Registration, "Removing item: " + (String)(obj.Name()));
                        
                        compColl.Remove(i);
                        if(sync != null) sync.Set();
                    }
                    else 
                    {
                        // Only kick up the index if we didn't do a deletion.
                        i++;
                        empty = false;
                    }
                }
                SaveChanges(compColl);
                
                if(empty)
                {
                    DBG.Info(DBG.Registration, "Deleting the enclosing application.");
                    // Delete the parent application as well.
                    for(int i = 0; i < _appColl.Count(); i++)
                    {
                        ICatalogObject obj = (ICatalogObject)(_appColl.Item(i));
                        if(obj.Key().Equals(app.Key()))
                        {
                            _appColl.Remove(i);
                            if(sync != null) sync.Set();
                            break;
                        }
                    }
                    SaveChanges(_appColl);
                }
            }
            
            // Unregister the assembly:  Should we also delete the type lib?
			UnregisterAssembly(asm, spec);
            
            // TODO:  Unregister the type library.   
            CleanupDriver();
        }
        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\remotingintermediary.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    RemotingIntermediary.cs
**
** Author:  ddriver
**
** Purpose: This is a forwarding proxy used to fake out remoting:  we use
** this so that remoting thinks there is an object living in this process.
**
** Date:    June 15 2002
**
===========================================================*/
namespace System.EnterpriseServices {   
    using System;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Services;
    using System.Runtime.Remoting.Activation;   
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Serialization;    
    using System.Security.Permissions;
    using System.Runtime.Remoting.Lifetime;
    
    internal class BlindMBRO : MarshalByRefObject
    {
        private MarshalByRefObject _holder;
        
        public BlindMBRO(MarshalByRefObject holder)
        {
            _holder = holder;
        }
    }
    
    internal class RemotingIntermediary : RealProxy
    {               
        private static MethodInfo _initializeLifetimeServiceMethod = typeof(MarshalByRefObject).GetMethod("InitializeLifetimeService", new Type[0]);
        private static MethodInfo _getLifetimeServiceMethod = typeof(MarshalByRefObject).GetMethod("GetLifetimeService", new Type[0]);
        private static MethodInfo _getCOMIUnknownMethod = typeof(MarshalByRefObject).GetMethod("GetComIUnknown", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, new Type[] {typeof(bool)}, null);
        private static MethodInfo _setCOMIUnknownMethod = typeof(ServicedComponent).GetMethod("DoSetCOMIUnknown", BindingFlags.NonPublic | BindingFlags.Instance);
        
        private RealProxy      _pxy; 
        private BlindMBRO      _blind;
        
        internal RemotingIntermediary(RealProxy pxy) 
          : base(pxy.GetProxiedType()) 
        {
            _pxy = pxy;
            _blind = new BlindMBRO((MarshalByRefObject)GetTransparentProxy());
        }
        
        // interop methods
        public override IntPtr GetCOMIUnknown(bool fIsMarshalled)
        {
            return _pxy.GetCOMIUnknown(fIsMarshalled);
        }
        
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public override void SetCOMIUnknown(IntPtr pUnk)
        {
            _pxy.SetCOMIUnknown(pUnk);
        }
        
        public override ObjRef CreateObjRef(Type requestedType)
        {   
            return new IntermediaryObjRef((MarshalByRefObject)GetTransparentProxy(), requestedType, _pxy);
        }
        
        // We need to handle lifetime for the intermediary as though it were
        // a real object.  We do this by delegating the InitializeLS and GetLS
        // to an hidden surrogate, who can produce the default lifetime settings
        // for the object.
        private IMessage HandleSpecialMessages(IMessage reqmsg)
        {
            IMethodCallMessage mcm = reqmsg as IMethodCallMessage;
            MethodBase mb = mcm.MethodBase;
            if(mb == _initializeLifetimeServiceMethod)
            {
                return new ReturnMessage(_blind.InitializeLifetimeService(), null, 0, mcm.LogicalCallContext, mcm);
            }
            else if(mb == _getLifetimeServiceMethod)
            {
                return new ReturnMessage(_blind.GetLifetimeService(), null, 0, mcm.LogicalCallContext, mcm);
            }
            return null;
        }
        
        // Implement Invoke
        public override IMessage Invoke(IMessage reqmsg) 
        {    
            DBG.Info(DBG.SC, "Intermediary: Invoke: forwarding call...");

            IMessage retmsg = HandleSpecialMessages(reqmsg);
            if(retmsg != null)
                return retmsg;

            return _pxy.Invoke(reqmsg);
        }
    }

    // The IntermediaryObjRef understands that when we're remoting over 
    // a managed channel, we should use a standard CLR objref.  Otherwise,
    // we should be using the data from ServicedComponentMarshaler (ie, a DCOM 
    // aware objref).
    internal class IntermediaryObjRef : ObjRef
    {
        private ObjRef _custom;

        public IntermediaryObjRef(MarshalByRefObject mbro, Type reqtype, RealProxy pxy)
          : base(mbro, reqtype)
        {
            _custom = pxy.CreateObjRef(reqtype);
        }

        // We should never need to have a deserialization constructor, since
        // we never deserialize one of these guys.

        public override void GetObjectData(SerializationInfo info, StreamingContext ctx)
        {
            object oClientIsClr = CallContext.GetData("__ClientIsClr");
            DBG.Info(DBG.SC, "SCM: GetObjectData: oClientIsClr = " + oClientIsClr);
            bool bUseStandardObjRef = (oClientIsClr==null)?false:(bool)oClientIsClr;
            if(bUseStandardObjRef)
            {
                base.GetObjectData(info, ctx);
            }
            else
            {
                _custom.GetObjectData(info, ctx);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\securityutil.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//

/*
   Security sample:

   SecurityCallContext call = SecurityCallContext.CurrentCall;

   foreach(SecurityIdentity id in call.Callers) {
       Console.WriteLine("Caller: " + id.AccountName);
   }
*/


namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    
    // Interfaces used w/ Security:
    [ComImport]
    [Guid("CAFC823D-B441-11D1-B82B-0000F8757E2A")]
    internal interface ISecurityCallersColl
    {
        int Count {
            [DispId(unchecked((int)1610743808))]
            get;
        }
        
        [DispId(0)]
        ISecurityIdentityColl GetItem(int lIndex);

        // BUGBUG:  Marshal this enumerator correctly:
        [DispId(unchecked((int)4294967292))]
        void GetEnumerator(out IEnumerator pEnum);
    }

    [ComImport]
    [Guid("CAFC823C-B441-11D1-B82B-0000F8757E2A")]
    internal interface ISecurityIdentityColl
    {
        int Count {
            [DispId(unchecked((int)1610743808))]
            get;
        }
        
        [DispId(0)]
        Object GetItem([In, MarshalAs(UnmanagedType.BStr)] String lIndex);

        // BUGBUG:  Marshal this enumerator correctly:
        [DispId(unchecked((int)4294967292))]
        void GetEnumerator(out IEnumerator pEnum);
    }


    [Guid("CAFC823E-B441-11D1-B82B-0000F8757E2A")]
    [ComImport]
    internal interface ISecurityCallContext
    {
        int Count {
            [DispId(1610743813)]
            get;
        }
        
        [DispId(0)]
        Object GetItem([In, MarshalAs(UnmanagedType.BStr)] String name);
        
        // BUGBUG: IEnumerator needs custom marshal
        [DispId(unchecked((int)4294967292))]
        void GetEnumerator(out IEnumerator pEnum);
        
        [DispId(unchecked((int)1610743814))]
        bool IsCallerInRole([In, MarshalAs(UnmanagedType.BStr)] String role);
        
        [DispId(unchecked((int)1610743815))]
        bool IsSecurityEnabled();
        
        [DispId(unchecked((int)1610743816))]
        bool IsUserInRole([In, MarshalAs(UnmanagedType.Struct)]ref Object pUser, 
                          [In, MarshalAs(UnmanagedType.BStr)] String role);
    }

    /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityIdentity"]/*' />
    public sealed class SecurityIdentity
    {
        private ISecurityIdentityColl _ex;

        // Disallow default construction.
        private SecurityIdentity() {}

        internal SecurityIdentity(ISecurityIdentityColl ifc) {
            _ex = ifc;
        }

        // Typed properties on SecurityIdentity
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityIdentity.AccountName"]/*' />
        public String AccountName 
        {
            get { return((String)(_ex.GetItem("AccountName"))); } 
        }

        // BUGBUG:  Try to return an enum value:
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityIdentity.AuthenticationService"]/*' />
        public int AuthenticationService 
        { 
            get { return((int)(_ex.GetItem("AuthenticationService"))); }
        }

        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityIdentity.ImpersonationLevel"]/*' />
        public ImpersonationLevelOption ImpersonationLevel 
        { 
            get { return((ImpersonationLevelOption)(_ex.GetItem("ImpersonationLevel"))); }
        }

        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityIdentity.AuthenticationLevel"]/*' />
        public AuthenticationOption AuthenticationLevel 
        { 
            get { return((AuthenticationOption)(_ex.GetItem("AuthenticationLevel"))); }
        }
    }
    
    internal class SecurityIdentityEnumerator : IEnumerator
    {
        private IEnumerator     _E;
        private SecurityCallers _callers;

        internal SecurityIdentityEnumerator(IEnumerator E, SecurityCallers c) 
        { 
            _E = E; 
            _callers = c;
        }

        public bool MoveNext() { return(_E.MoveNext()); }
        public void Reset() { _E.Reset(); }

        public Object Current {
            get {
                Object o = _E.Current;
                DBG.Assert(o is Int32, "SecurityIdentityEnumerator produced unknown object: ");
                return(_callers[(Int32)o]);
            }
        }
    }


    // The SecurityCallers is a collection of ISecurityInfo objects:
    /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallers"]/*' />
    public sealed class SecurityCallers : IEnumerable
    {
        private ISecurityCallersColl _ex;

        // Disallow default construction.
        private SecurityCallers() {}

        internal SecurityCallers(ISecurityCallersColl ifc) { _ex = ifc; }

        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallers.Count"]/*' />
        public int Count { get { return(_ex.Count); } }

        // Helpers:  For nicer types (VB-like syntax).
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallers.this"]/*' />
        public SecurityIdentity this[int idx]
        {
            get {
                return(new SecurityIdentity(_ex.GetItem(idx)));
            }
        }

        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallers.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator() 
        { 
            IEnumerator E = null;
            _ex.GetEnumerator(out E); 
            // Wrap this up in our custom enumerator:
            return(new SecurityIdentityEnumerator(E, this));
        }
    }

    /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext"]/*' />
    public sealed class SecurityCallContext
    {
        private ISecurityCallContext _ex;

        // Disallow default construction.
        private SecurityCallContext() {}

        private SecurityCallContext(ISecurityCallContext ctx)
        {
            _ex = ctx;
        }

        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.CurrentCall"]/*' />
        public static SecurityCallContext CurrentCall
        {
            get {
                Platform.Assert(Platform.W2K, "SecurityCallContext");
                try
                {
                    ISecurityCallContext ctx;
                    Util.CoGetCallContext(Util.IID_ISecurityCallContext, out ctx);
                    return(new SecurityCallContext(ctx));
                }
                catch(InvalidCastException)
                {
                    throw new COMException(Resource.FormatString("Err_NoSecurityContext"), Util.E_NOINTERFACE);
                }
            }
        }
   
        // Helpers:  For nicer types (VB-like syntax).

        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.IsCallerInRole"]/*' />
        public bool IsCallerInRole(String role) 
        {
            return(_ex.IsCallerInRole(role));
        }
        
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.IsUserInRole"]/*' />
        public bool IsUserInRole(String user, String role)
        {        
        	Object o = user;
            return(_ex.IsUserInRole(ref o, role));
        }
        
        // Properties
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.IsSecurityEnabled"]/*' />
        public bool IsSecurityEnabled 
        { 
            // BUGBUG:  Should this go to the ObjectContext?  This will
            // throw an exception always (if supposed to be false).
            get { return(_ex.IsSecurityEnabled()); }
        }

        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.DirectCaller"]/*' />
        public SecurityIdentity DirectCaller 
        {
            get { 
                ISecurityIdentityColl coll = (ISecurityIdentityColl)_ex.GetItem("DirectCaller");
                return(new SecurityIdentity(coll));
            }
        }
        
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.OriginalCaller"]/*' />
        public SecurityIdentity OriginalCaller
        {
            get { 
                ISecurityIdentityColl coll = (ISecurityIdentityColl)_ex.GetItem("OriginalCaller");
                return(new SecurityIdentity(coll));
            }
        }
        
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.NumCallers"]/*' />
        public int NumCallers
        {
            get { 
                return((int)(_ex.GetItem("NumCallers")));
            }
        }
        
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.MinAuthenticationLevel"]/*' />
        public int MinAuthenticationLevel
        {
            get { 
                return((int)(_ex.GetItem("MinAuthenticationLevel")));
            }
        }
        
        /// <include file='doc\SecurityUtil.uex' path='docs/doc[@for="SecurityCallContext.Callers"]/*' />
        public SecurityCallers Callers { 
            get { 
                ISecurityCallersColl coll = (ISecurityCallersColl)_ex.GetItem("Callers");
                return(new SecurityCallers(coll));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\securityattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: dddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    using System.EnterpriseServices.Admin;
    using System.Collections;

    /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ComponentAccessControlAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    [ComVisible(false)]
    public sealed class ComponentAccessControlAttribute : Attribute, IConfigurationAttribute
    {
        private bool _value;

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ComponentAccessControlAttribute.ComponentAccessControlAttribute"]/*' />
        public ComponentAccessControlAttribute() : this(true) {}

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ComponentAccessControlAttribute.ComponentAccessControlAttribute1"]/*' />
        public ComponentAccessControlAttribute(bool val)
        {
            _value = val;
        }

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ComponentAccessControlAttribute.Value"]/*' />
        public bool Value { get { return(_value); } }

        // Internal implementation
        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable info)
        {
            Platform.Assert(Platform.MTS, "ComponentAccessControlAttribute");

            ICatalogObject obj = (ICatalogObject)(info["Component"]);
            if(Platform.IsLessThan(Platform.W2K))
            {
                obj.SetValue("SecurityEnabled", _value?"Y":"N");
            }
            else
            {
                obj.SetValue("ComponentAccessChecksEnabled", _value);
            }
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AccessChecksLevelOption"]/*' />
	[Serializable]
    public enum AccessChecksLevelOption
    {
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AccessChecksLevelOption.Application"]/*' />
        Application = 0,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AccessChecksLevelOption.ApplicationComponent"]/*' />
        ApplicationComponent   = 1
    }

    /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption"]/*' />
	[Serializable]
    public enum AuthenticationOption
    {
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption.Default"]/*' />
        Default   = 0,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption.None"]/*' />
        None      = 1,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption.Connect"]/*' />
        Connect   = 2,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption.Call"]/*' />
        Call      = 3,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption.Packet"]/*' />
        Packet    = 4,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption.Integrity"]/*' />
        Integrity = 5,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="AuthenticationOption.Privacy"]/*' />
        Privacy   = 6
    }

    /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ImpersonationLevelOption"]/*' />
	[Serializable]
    public enum ImpersonationLevelOption
    { 
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ImpersonationLevelOption.Default"]/*' />
        Default     = 0,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ImpersonationLevelOption.Anonymous"]/*' />
        Anonymous   = 1,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ImpersonationLevelOption.Identify"]/*' />
        Identify    = 2,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ImpersonationLevelOption.Impersonate"]/*' />
        Impersonate = 3,
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ImpersonationLevelOption.Delegate"]/*' />
        Delegate    = 4
    }

    /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ApplicationAccessControlAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Assembly, Inherited=true)]
    [ComVisible(false)]
    public sealed class ApplicationAccessControlAttribute : Attribute, IConfigurationAttribute
    {
        bool                      _val;
        AccessChecksLevelOption   _checkLevel;
        AuthenticationOption      _authLevel;
        ImpersonationLevelOption  _impLevel;

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ApplicationAccessControlAttribute.ApplicationAccessControlAttribute"]/*' />
        public ApplicationAccessControlAttribute() 
          : this(true)
        {
        }

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ApplicationAccessControlAttribute.ApplicationAccessControlAttribute1"]/*' />
        public ApplicationAccessControlAttribute(bool val)
        {
            _val = val;
            _authLevel  = (AuthenticationOption)(-1);
            _impLevel   = (ImpersonationLevelOption)(-1);

            if(_val)
                _checkLevel = AccessChecksLevelOption.ApplicationComponent;
            else
                _checkLevel = AccessChecksLevelOption.Application;
        }

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ApplicationAccessControlAttribute.Value"]/*' />
        public bool Value { 
            get { return(_val); }
            set { _val = value; }
        }
        
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ApplicationAccessControlAttribute.AccessChecksLevel"]/*' />
        public AccessChecksLevelOption AccessChecksLevel
        {
            get { return(_checkLevel); }
            set 
            { 
                Platform.Assert(Platform.W2K, "ApplicationAccessControlAttribute.AccessChecksLevel");
                _checkLevel = value; 
            }
        }

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ApplicationAccessControlAttribute.Authentication"]/*' />
        public AuthenticationOption Authentication
        {
            get { return(_authLevel); }
            set 
            { 
                _authLevel = value; 
            }
        }

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="ApplicationAccessControlAttribute.ImpersonationLevel"]/*' />
        public ImpersonationLevelOption ImpersonationLevel
        {
            get { return(_impLevel); }
            set 
            { 
                Platform.Assert(Platform.W2K, "ApplicationAccessControlAttribute.ImpersonationLevel");
                _impLevel = value; 
            }
        }

        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Application"); }
        bool IConfigurationAttribute.Apply(Hashtable cache)
        {
            Platform.Assert(Platform.MTS, "ApplicationAccessControlAttribute");
            ICatalogObject obj = (ICatalogObject)(cache["Application"]);
            
            // MTS-speak
            if(Platform.IsLessThan(Platform.W2K))
            {
                bool en = (bool)_val;
                obj.SetValue("SecurityEnabled", en?"Y":"N");
            }
            else
            {
                obj.SetValue("ApplicationAccessChecksEnabled", _val);
                obj.SetValue("AccessChecksLevel", _checkLevel);
            }
            if(_authLevel != (AuthenticationOption)(-1))
            {
                obj.SetValue("Authentication", _authLevel);
            }
            if(_impLevel != (ImpersonationLevelOption)(-1))
            {
                obj.SetValue("ImpersonationLevel", _impLevel);
            }
            return(true);
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }

    /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecurityRoleAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method|AttributeTargets.Assembly|AttributeTargets.Interface, 
                    Inherited=true, AllowMultiple=true)]
    [ComVisible(false)]
    public sealed class SecurityRoleAttribute : Attribute, IConfigurationAttribute
    {
        private String _role;
        private bool   _setEveryoneAccess;
        private String _description;
        
        private static readonly String RoleCacheString = "RoleAttribute::ApplicationRoleCache";

        private static String _everyone;
        private static String EveryoneAccount
        {
            get 
            {
                if(_everyone == null)
                {
                    _everyone = Thunk.Security.GetEveryoneAccountName();
                    DBG.Assert(_everyone != null, "Failed to get Everyone account.");
                    DBG.Info(DBG.Registration, "Everyone Account = " + _everyone);
                }
                return(_everyone);
            }
        }

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecurityRoleAttribute.SecurityRoleAttribute"]/*' />
        public SecurityRoleAttribute(String role) : this(role, false) {}

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecurityRoleAttribute.SecurityRoleAttribute1"]/*' />
        public SecurityRoleAttribute(String role, bool everyone)
        {
            _role = role;
            _setEveryoneAccess = everyone;
            _description = null;
        }
        
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecurityRoleAttribute.Role"]/*' />
        public String Role 
        {
            get { return(_role); } 
            set { _role = value; }
        }

        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecurityRoleAttribute.SetEveryoneAccess"]/*' />
        public bool SetEveryoneAccess
        {
            get { return(_setEveryoneAccess); } 
            set { _setEveryoneAccess = value; }
        }
        
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecurityRoleAttribute.Description"]/*' />
        public String Description
        {
            get { return(_description); }
            set { _description = value; }
        }

        bool IConfigurationAttribute.IsValidTarget(String s)
        {
            if(s == "Component" || 
               s == "Method" || 
               s == "Application" ||
               s == "Interface")
            {
                DBG.Info(DBG.Registration, "Setting security for target: " + s);
                return(true);
            }
            DBG.Info(DBG.Registration, "Not setting security for target: " + s);
            return(false);
        }

        private ICatalogObject Search(ICatalogCollection coll, String key, String value)
        {
            DBG.Info(DBG.Registration, "Searching for " + value + " in " + key);
            DBG.Info(DBG.Registration, "collection has " + coll.Count() + " elements");
            for(int i = 0; i < coll.Count(); i++)
            {
                ICatalogObject obj = (ICatalogObject)(coll.Item(i));
                String possible = (String)(obj.GetValue(key));
                DBG.Info(DBG.Registration, "Checking against: " + possible);
                if(possible == value) 
                {
                    DBG.Info(DBG.Registration, "Found it!");
                    return(obj);
                }
            }
            DBG.Info(DBG.Registration, "Didn't find it.");
            return(null);
        }

        private void EnsureRole(Hashtable cache)
        {
            ICatalogCollection appColl  = null;
            ICatalogObject     app      = null;
            ICatalogCollection roleColl = null;
            
            // Check to see if we've cached the existence of the role:
            Hashtable appRoleCache = (Hashtable)(cache[RoleCacheString]);
            
            if(appRoleCache == null)
            {
                appRoleCache = new Hashtable();
                cache[RoleCacheString] = appRoleCache;
            }
            
            if(appRoleCache[_role] != null) return;

            appColl = (ICatalogCollection)(cache["ApplicationCollection"]);
            app     = (ICatalogObject)(cache["Application"]);
            DBG.Info(DBG.Registration, "Getting roles for app: " + app.Key());
            roleColl = (ICatalogCollection)(appColl.GetCollection(CollectionName.Roles, app.Key()));
            roleColl.Populate();

            ICatalogObject newRole = Search(roleColl, "Name", _role);
            if(newRole == null)
            {
                // We didn't find it, we need to try to add a new role:
                newRole = (ICatalogObject)(roleColl.Add());
                newRole.SetValue("Name", _role);

                if(_description != null)
                {
                    newRole.SetValue("Description", _description);
                }

                roleColl.SaveChanges();
                
                if(_setEveryoneAccess)
                {
                    DBG.Info(DBG.Registration, "\tAdding everyone to the role!");
                    ICatalogCollection userColl = (ICatalogCollection)(roleColl.GetCollection(CollectionName.UsersInRole, newRole.Key()));
                    userColl.Populate();
                    
                    // Add the Everyone user to this guy, so that activation will
                    // subsequently succeed:
                    ICatalogObject newUser = (ICatalogObject)(userColl.Add());
                    
                    newUser.SetValue("User", EveryoneAccount);
                    
                    userColl.SaveChanges();
                }
            }
            
            // Mark this guy in the cache.
            appRoleCache[_role] = (Object)true;
        }

        private void AddRoleFor(String target, Hashtable cache)
        {
            DBG.Info(DBG.Registration, "Adding role " + _role + " for " + target);
            ICatalogCollection coll = (ICatalogCollection)(cache[target+"Collection"]);
            ICatalogObject     obj  = (ICatalogObject)(cache[target]);

            // Navigate to the RolesForTarget collection:
            ICatalogCollection roles = (ICatalogCollection)(coll.GetCollection(CollectionName.RolesFor(target), obj.Key()));
            roles.Populate();
                
            if(Platform.IsLessThan(Platform.W2K))
            {
                // MTS uses RoleUtil method
                // TODO:  Can we use this on w2k?  It would make stuff easier.
                IRoleAssociationUtil util = (IRoleAssociationUtil)(roles.GetUtilInterface());
                util.AssociateRoleByName(_role);
            }
            else
            {
                // See if the desired role is already part of the collection:
                ICatalogObject queryObj = Search(roles, "Name", _role);
                if(queryObj != null) return;
                
                // We didn't find it, go ahead and add it.
                DBG.Info(DBG.Registration, "\tNew role: " + _role);
                ICatalogObject newRole = (ICatalogObject)(roles.Add());
                newRole.SetValue("Name", _role);
                DBG.Info(DBG.Registration, "Done!");
                roles.SaveChanges();
                
                roles.Populate();
                DBG.Info(DBG.Registration, "\tRole collection: " + roles.Name());
                DBG.Info(DBG.Registration, "\tOn " + target + ": " + obj.Name());
                for(int i = 0; i < roles.Count(); i++)
                {
                    ICatalogObject tobj = (ICatalogObject)(roles.Item(i));
                    DBG.Info(DBG.Registration, "\tRole: " + tobj.Name());
                }
            }
        }

        bool IConfigurationAttribute.Apply(Hashtable cache)
        {
            // Make sure the role exists in the application.
            EnsureRole(cache);

            // If this is a method, we need to make sure that we've enabled
            // the marshaler role:
            String target = (String)(cache["CurrentTarget"]);

            if(target == "Method")
            {
                cache["SecurityOnMethods"] = (Object)true;
                DBG.Info(DBG.Registration, "Add SecurityOnMethods for " + cache["ComponentType"]);
            }
            
            return(true);
        }

        bool IConfigurationAttribute.AfterSaveChanges(Hashtable cache)
        {
            String target = (String)(cache["CurrentTarget"]);
            
            // Now that the component itself is configured, we go and add
            // roles to the sub-collection.  (This ensures that all the
            // component logic that hits sub-collections gets run first.
            if(target == "Component")
            {
                Platform.Assert(Platform.MTS, "SecurityRoleAttribute");
                // Pull out the RolesForComponent collection, add the name of
                // the desired role to that collection.
                AddRoleFor("Component", cache);
            }
            else if(target == "Method")
            {
                Platform.Assert(Platform.W2K, "SecurityRoleAttribute");
                // Pull out the RolesForMethod collection, add the name of
                // the desired role to that collection.
                AddRoleFor("Method", cache);
            }
            else if(target == "Interface")
            {
                AddRoleFor("Interface", cache);
            }
            else if(target == "Application")
            {
                // We don't actually need to do anything for application,
                // as we have already verified that the role exists.
            }
            else
            {
                // We got called on a target we don't know about, which
                // shouldn't ever happen.
                DBG.Assert(false, "Invalid target for RoleAttribute");
            }
            return(true);
        }
    }
    
    /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecureMethodAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, 
                    Inherited=true, AllowMultiple=false)]
    [ComVisible(false)]
    public sealed class SecureMethodAttribute : Attribute, IConfigurationAttribute
    {
        /// <include file='doc\SecurityAttribute.uex' path='docs/doc[@for="SecureMethodAttribute.SecureMethodAttribute"]/*' />
        public SecureMethodAttribute() {}

        bool IConfigurationAttribute.IsValidTarget(String s) { return(s == "Method" || s == "Component"); }
        bool IConfigurationAttribute.Apply(Hashtable cache) 
        { 
            // If this is a method, we need to make sure that we've enabled
            // the marshaler role:
            String target = (String)(cache["CurrentTarget"]);

            if(target == "Method")
            {
                cache["SecurityOnMethods"] = (Object)true;
                DBG.Info(DBG.Registration, "Add SecurityOnMethods for " + cache["ComponentType"]);
            }
            return(false); 
        }
        bool IConfigurationAttribute.AfterSaveChanges(Hashtable info) { return(false); }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\remoteservicedcomponentproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    RemoteServicedComponentProxy.cs
**
** Author:  RajaK
**
** Purpose: Defines the general purpose RemoteServicedComponentProxy proxy
**
** Date:    June 15 2000
**
===========================================================*/
namespace System.EnterpriseServices {   
    using System;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Services;
    using System.Runtime.Remoting.Activation;	
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Serialization;    
    using System.Security.Permissions;



   	internal class MethodCallMessageWrapperEx : MethodCallMessageWrapper
   	{
   		private MethodBase _mb;
   		public MethodCallMessageWrapperEx(IMethodCallMessage imcmsg, MethodBase mb)
   			:base(imcmsg)
   		{
   			_mb = mb;
   		}

   		/// <include file='doc\Message.uex' path='docs/doc[@for="MethodCallMessageWrapper.MethodBase"]/*' />
        public override MethodBase MethodBase { get {return _mb;}}     	
   	}
	
	//---------------------------------------------------------
	//	internal class RemoteServicedComponentProxy
	//---------------------------------------------------------
    // RemoteServicedComponentProxy
    internal class RemoteServicedComponentProxy : RealProxy
    {            	
    	private IntPtr 	   _pUnk; // An IUnknown for the remote object.
		private Object 	   _server; // outproc server object
		private bool	   _fUseIntfDispatch;
		private bool	   _fAttachedServer;
        private volatile RemotingIntermediary _intermediary;

		// Static Fields
        private static MethodInfo _getTypeMethod = typeof(System.Object).GetMethod("GetType");
        private static MethodInfo _getHashCodeMethod = typeof(System.Object).GetMethod("GetHashCode");
        
		private static MethodBase _getIDisposableDispose = typeof(IDisposable).GetMethod("Dispose", new Type[0]);
		private static MethodBase _getServicedComponentDispose = typeof(ServicedComponent).GetMethod("Dispose", new Type[0]);
        
        private Type _pt;
        private Type ProxiedType
        {
            get
            {
                if (_pt == null)
                    _pt = GetProxiedType();
                return (_pt);
            }
        }
																		
        // default constructor
		private RemoteServicedComponentProxy()
        {
            // Prevent anyone from creating a blank instance of a proxy
            // without the underlying server type
        }

        private void AssertValid()
		{
			// disallow calls on invalid objects (or) objects that have not
			// been activated
			if (_server == null)
			{
				throw new ObjectDisposedException("ServicedComponent");
			}
		}
																		
        private bool IsDisposeRequest(IMessage msg)
        {
			IMethodCallMessage methcall = msg as IMethodCallMessage;
            if(methcall != null)
            {
				MethodBase mb = methcall.MethodBase;

                if(mb == _getServicedComponentDispose || mb == _getIDisposableDispose)
	                return true;
            }
            return false;
        }

		internal RemoteServicedComponentProxy(Type serverType, IntPtr pUnk, bool fAttachServer) 
          : base(serverType) 
        {
            DBG.Info(DBG.SC, "RSCP: type = " + serverType);
			DBG.Assert(serverType != null,"server type is null");
            
			_fUseIntfDispatch = (ServicedComponentInfo.IsTypeEventSource(serverType)
                                 || ServicedComponentInfo.AreMethodsSecure(serverType));
            DBG.Info(DBG.SC, "RSCP: using interface dispatch = " + _fUseIntfDispatch);
	  		if (pUnk != IntPtr.Zero)
	  		{
	  			_pUnk = pUnk;
				_server = EnterpriseServicesHelper.WrapIUnknownWithComObject(pUnk);				
				if (fAttachServer)
				{
					AttachServer((MarshalByRefObject)_server);
					_fAttachedServer = true;
				}			
			}
        }	

		internal void Dispose(bool disposing)
		{
            DBG.Info(DBG.SC, "RSCP: dispose");
			Object s = _server;
			_server = null;
			if (s != null)
			{
                _pUnk = IntPtr.Zero;
                if(disposing)
                {
                    Marshal.ReleaseComObject(s);
                }
				if (_fAttachedServer)
				{
					DetachServer();
					_fAttachedServer = false;
				}
			}
		}
        
        internal RemotingIntermediary RemotingIntermediary
        {
            get
            {
                if(_intermediary == null)
                {
                    lock(this)
                    {
                        if(_intermediary == null)
                        {
                            _intermediary = new RemotingIntermediary(this);
                        }
                    }
                }
                return _intermediary;
            }
        }

		
		// itnerop methods
		public override IntPtr GetCOMIUnknown(bool fIsMarshalled)
		{
            DBG.Info(DBG.SC, "RSCP: GetCOMIUnknown");
			// sub -class should override
			if(_server != null)
			{
				return Marshal.GetIUnknownForObject(_server);
			}
			else
				return IntPtr.Zero;
		}
		
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public override void SetCOMIUnknown(IntPtr pUnk)
		{
			if (_server == null)
			{
                DBG.Info(DBG.SC, "RSCP: SetCOMIUnknown: storing pUnk.");
				_pUnk = pUnk;
				_server = EnterpriseServicesHelper.WrapIUnknownWithComObject(pUnk);
				// add this to our table of weak references
			   //IdentityTable.AddObject(_pUnk, GetTransparentProxy());
			}
		}

		public override ObjRef CreateObjRef(Type requestedType)
        {   
        	DBG.Info(DBG.SC, "RSCP: CreateObjRef, creating SCM of type "+ requestedType);
            return new ServicedComponentMarshaler((MarshalByRefObject)GetTransparentProxy(), requestedType);
        }        
        
		// Implement Invoke
        public override IMessage Invoke(IMessage reqMsg) 
        {     
        	AssertValid();
        	IMessage retMsg = null;
        	
			// CHECK FOR CTOR
            if (reqMsg is IConstructionCallMessage)
            {            	
                DBG.Info(DBG.SC, "RSCP: Short circuiting constructor call.");

                if (((IConstructionCallMessage)reqMsg).ArgCount > 0)
                    throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_ConstructorArguments"));
            
            	// WE don't need dispatch the constructor message, the default .ctor is called
				// by CoCI
	            // Create the return message
                MarshalByRefObject retObj = (MarshalByRefObject)GetTransparentProxy();              
        		return EnterpriseServicesHelper.CreateConstructionReturnMessage((IConstructionCallMessage)reqMsg, retObj);
        	}

			// NON CTOR MESSAGE
			MethodBase mb = ((IMethodMessage)reqMsg).MethodBase;
			MemberInfo m = (MemberInfo)mb;
			DBG.Assert(m != null, "member info should not be null");

			if (mb == _getTypeMethod)
			{
				DBG.Info(DBG.SC, "RSCP: Hijacking call to GetType");
				IMethodCallMessage mcm = (IMethodCallMessage)reqMsg;
                return new ReturnMessage(ProxiedType, null, 0, mcm.LogicalCallContext, mcm);
			}

            if (mb == _getHashCodeMethod)
            {            
                int hashCode = this.GetHashCode();
                DBG.Info(DBG.SC, "RSCP: Hijacking call to GetHashCode, returning " + hashCode);
                IMethodCallMessage mcm = (IMethodCallMessage)reqMsg;
                return new ReturnMessage(hashCode, null, 0, mcm.LogicalCallContext, mcm);
            }

            DBG.Info(DBG.SC, "RSCP: Delivering call to " + mb.Name);

			// convert to class member info
			MemberInfo clsMemInfo = ReflectionCache.ConvertToClassMI(ProxiedType, m);			
			DBG.Assert(!clsMemInfo.ReflectedType.IsInterface, 
							"Failed to convert interface member info to class member info");
			
			// dispatch the call
#if _DEBUG
            if(clsMemInfo != m)
            {
                DBG.Info(DBG.SC, "RSCP: converted interface to class call: " + clsMemInfo.Name);
            }
#endif
            
            try
            {
                int iMethodInfo;
                // check for rolebased security
                if ( _fUseIntfDispatch || 
                    (((iMethodInfo = ServicedComponentInfo.MICachedLookup(clsMemInfo)) & ServicedComponentInfo.MI_HASSPECIALATTRIBUTES) !=0)
                    || ((iMethodInfo & ServicedComponentInfo.MI_EXECUTEMESSAGEVALID) != 0)
                   )
                {
                    // role based security implies we dispatch through an interface
               	    MemberInfo intfMemInfo = ReflectionCache.ConvertToInterfaceMI(m);
                    if (intfMemInfo == null)
                    {
                        throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_SecurityMapping"));
                    }
                    //retMsg = EnterpriseServicesHelper.DispatchRemoteCall(reqMsg, intfMemInfo, _server);	
                    MethodCallMessageWrapperEx msgex = new MethodCallMessageWrapperEx((IMethodCallMessage)reqMsg, (MethodBase)intfMemInfo);
                    retMsg = RemotingServices.ExecuteMessage((MarshalByRefObject)_server, (IMethodCallMessage)msgex);
                }
                else
                {
                    // check for AutoDone
                    bool fAutoDone = (iMethodInfo & ServicedComponentInfo.MI_AUTODONE) != 0;

                    String s = ComponentServices.ConvertToString(reqMsg);

                    IRemoteDispatch iremDisp = (IRemoteDispatch)_server;

                    String sret;
                    if (fAutoDone)
                    {
                        sret = iremDisp.RemoteDispatchAutoDone(s);
                    }
                    else
                    {
                        sret = iremDisp.RemoteDispatchNotAutoDone(s);										
                    }
                    retMsg = ComponentServices.ConvertToReturnMessage(sret, reqMsg);	
                }
            }
            catch(COMException e)
            {
                if(!(e.ErrorCode == Util.CONTEXT_E_ABORTED || e.ErrorCode == Util.CONTEXT_E_ABORTING))
                    throw;
                if(IsDisposeRequest(reqMsg))
                {
                    IMethodCallMessage mcm = reqMsg as IMethodCallMessage;
                    retMsg = new ReturnMessage(null, null, 0, mcm.LogicalCallContext, mcm);
                }
                else
                    throw;
            }

            // if disposing, we need to release this side of the world.
            if(IsDisposeRequest(reqMsg))
            {
                Dispose(true);
            }
            
            return retMsg;
		}

        ~RemoteServicedComponentProxy()
    	{  
            DBG.Info(DBG.SC, "RSCP: Finalize");
       		Dispose(false);
    	}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\servicedcomponentexception.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*=============================================================================
**
** Class: ServicedComponentException
**
** Author: RajaK
**
** Purpose: Exception class for ServicedComponent 
**
** Date: July 15, 2000
**
=============================================================================*/

namespace System.EnterpriseServices
{
	using System.Runtime.Remoting;
	using System.Runtime.Serialization;
        using System.Runtime.InteropServices;

	// The Exception thrown when something has gone
	// wrong
	// 
	/// <include file='doc\ServicedComponentException.uex' path='docs/doc[@for="ServicedComponentException"]/*' />
	[Serializable()]
        [ComVisible(false)]
	public sealed class ServicedComponentException : SystemException {

	private static String _default = null;

	// this is also define in System.__HResults
        private const int COR_E_SERVICEDCOMPONENT = unchecked((int)0x8013150F);


        private static String DefaultMessage {
            get {
                if (_default==null)
                    _default = Resource.FormatString("ServicedComponentException_Default");
                return _default;
            }
        }

		// Creates a new ServicedComponentException with its message 
		// string set to a default message.
		/// <include file='doc\ServicedComponentException.uex' path='docs/doc[@for="ServicedComponentException.ServicedComponentException"]/*' />
		public ServicedComponentException() 
				: base(DefaultMessage) {
			HResult = COR_E_SERVICEDCOMPONENT;
		}

		/// <include file='doc\ServicedComponentException.uex' path='docs/doc[@for="ServicedComponentException.ServicedComponentException1"]/*' />
		public ServicedComponentException(String message) 
				: base(message) {
			HResult = COR_E_SERVICEDCOMPONENT;
		}

		/// <include file='doc\ServicedComponentException.uex' path='docs/doc[@for="ServicedComponentException.ServicedComponentException2"]/*' />

		public ServicedComponentException(String message, Exception innerException) 
				: base(message, innerException) {
			HResult = COR_E_SERVICEDCOMPONENT;
		}	

		/// <include file='doc\ServicedComponentException.uex' path='docs/doc[@for="ServicedComponentException.ServicedComponentException3"]/*' />
		private ServicedComponentException(SerializationInfo info, StreamingContext context) : base(info, context) {}
	}    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\sharedproperties.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: dddriver
// Date: April 2000
//

namespace System.EnterpriseServices
{
    using System;
    using System.Runtime.InteropServices;
    using System.Collections;
    
    /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="PropertyLockMode"]/*' />
    [ComVisible(false), Serializable]
    public enum PropertyLockMode
    {
        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="PropertyLockMode.SetGet"]/*' />
        SetGet = 0,
        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="PropertyLockMode.Method"]/*' />
        Method = 1,
    }

    /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="PropertyReleaseMode"]/*' />
    [ComVisible(false), Serializable]
    public enum PropertyReleaseMode
    {
        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="PropertyReleaseMode.Standard"]/*' />
        Standard = 0,
        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="PropertyReleaseMode.Process"]/*' />
        Process  = 1,
    }

    [
     ComImport,
     Guid("2A005C01-A5DE-11CF-9E66-00AA00A3F464")
    ]
    internal interface ISharedProperty
    {
        Object Value
        {
            get;
            set;
        }
    }


    [
     ComImport,
     Guid("2A005C07-A5DE-11CF-9E66-00AA00A3F464")
    ]
    internal interface ISharedPropertyGroup
    {
        ISharedProperty 
        CreatePropertyByPosition([In,  MarshalAs(UnmanagedType.I4)] int position,
                                 [Out] out bool fExists);

        ISharedProperty PropertyByPosition(int position);
        
        ISharedProperty 
        CreateProperty([In,  MarshalAs(UnmanagedType.BStr)] String name,
                       [Out] out bool fExists);

        ISharedProperty Property([In, MarshalAs(UnmanagedType.BStr)] String name);
    }

    [
     ComImport,
     Guid("2A005C0D-A5DE-11CF-9E66-00AA00A3F464")
    ]
    internal interface ISharedPropertyGroupManager
    {
        ISharedPropertyGroup 
        CreatePropertyGroup([In, MarshalAs(UnmanagedType.BStr)] String name, 
                            [In,Out, MarshalAs(UnmanagedType.I4)] ref PropertyLockMode dwIsoMode,
                            [In,Out, MarshalAs(UnmanagedType.I4)] ref PropertyReleaseMode dwRelMode,
                            [Out] out bool fExist);

        ISharedPropertyGroup Group(String name);
        
        void GetEnumerator([Out] out IEnumerator pEnum);
    }

    [ComImport]
    [Guid("2A005C11-A5DE-11CF-9E66-00AA00A3F464")]
    internal class xSharedPropertyGroupManager {}

    /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedProperty"]/*' />
    [ComVisible(false)]
    public sealed class SharedProperty
    {
        private ISharedProperty _x;
        
        internal SharedProperty(ISharedProperty prop)
        {
            _x = prop;
        }

        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedProperty.Value"]/*' />
        public Object Value
        {
            get { return(_x.Value); }
            set { _x.Value = value; }
        }
    }

    /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroup"]/*' />
    [ComVisible(false)]
    public sealed class SharedPropertyGroup
    {
        private ISharedPropertyGroup _x;

        internal SharedPropertyGroup(ISharedPropertyGroup grp)
        {
            _x = grp;
        }

        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroup.CreatePropertyByPosition"]/*' />
        public SharedProperty CreatePropertyByPosition(int position,
                                                out bool fExists)
        {
            return(new SharedProperty(_x.CreatePropertyByPosition(position, out fExists)));
        }

        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroup.PropertyByPosition"]/*' />
        public SharedProperty PropertyByPosition(int position)
        {
            return(new SharedProperty(_x.PropertyByPosition(position)));
        }
        
        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroup.CreateProperty"]/*' />
        public SharedProperty CreateProperty(String name,
                                      out bool fExists)
        {
            return(new SharedProperty(_x.CreateProperty(name, out fExists)));
        }

        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroup.Property"]/*' />
        public SharedProperty Property(String name)
        {
            return(new SharedProperty(_x.Property(name)));
        }
    }

    /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroupManager"]/*' />
    [ComVisible(false)]
    public sealed class SharedPropertyGroupManager : IEnumerable
    {
        private ISharedPropertyGroupManager _ex;
        
        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroupManager.SharedPropertyGroupManager"]/*' />
        public SharedPropertyGroupManager() 
        {
            Platform.Assert(Platform.MTS, "SharedPropertyGroupManager");
            _ex = (ISharedPropertyGroupManager)(new xSharedPropertyGroupManager());
        }
        
        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroupManager.CreatePropertyGroup"]/*' />
        public SharedPropertyGroup CreatePropertyGroup(String name, 
                                                        ref PropertyLockMode dwIsoMode,
                                                        ref PropertyReleaseMode dwRelMode,
                                                        out bool fExist)
        {
            return new SharedPropertyGroup(_ex.CreatePropertyGroup(name, 
                                                                   ref dwIsoMode,
                                                                   ref dwRelMode,
                                                                   out fExist));
        }

        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroupManager.Group"]/*' />
        public SharedPropertyGroup Group(String name)
        {
            return new SharedPropertyGroup(_ex.Group(name));
        }

        /// <include file='doc\SharedProperties.uex' path='docs/doc[@for="SharedPropertyGroupManager.GetEnumerator"]/*' />
        public IEnumerator GetEnumerator()
        {
            IEnumerator E = null;
            _ex.GetEnumerator(out E);
            return(E);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\servicedcomponent.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ServicedComponent
**
** Author(s):   RajaK
**              
**
** Purpose: Defines the root type for all ServicedComponent types
**          
**          
**
** Date:    June 15 2000
**
===========================================================*/
namespace System.EnterpriseServices {   
    
	using System;    
	using System.Runtime.Serialization;
    using System.Runtime.Remoting;
    using System.Reflection;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.InteropServices;

    // TODO:  Eliminate this interface.
    // DO NOT CHANGE THIS INTERFACE WITHOUT CHANGING THE PROXY/STUB CODE IN ENTSVCPS.IDL
    /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="IRemoteDispatch"]/*' />
    /// <internalonly/>
    [Guid("6619a740-8154-43be-a186-0319578e02db")]
    public interface IRemoteDispatch
    {
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="IRemoteDispatch.RemoteAutoDone"]/*' />
    	[AutoComplete(true)]
		// helper to dispatch an autodone method on a remote object				
        String RemoteDispatchAutoDone(String s);

        // helper to dispatch a not autodone method on a remote object
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="IRemoteDispatch.RemoteNotAutoDone"]/*' />
        [AutoComplete(false)]
        String RemoteDispatchNotAutoDone(String s);		
    };


	// DO NOT CHANGE THIS INTERFACE WITHOUT CHANGING THE PROXY/STUB CODE IN ENTSVCPS.IDL
    /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="IServicedComponentInfo"]/*' />
    /// <internalonly/>
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [Guid("8165B19E-8D3A-4d0b-80C8-97DE310DB583")]
    public interface IServicedComponentInfo
    {		
		/// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="IServicedComponentInfo.GetComponentInfo"]/*' />
		void GetComponentInfo(ref int infoMask, out String[] infoArray);
    };


	//*****************************************************************************
    // Interface for controlling a managed object
    //*****************************************************************************
	// DO NOT CHANGE THIS INTERFACE WITHOUT CHANGING THE PROXY/STUB CODE IN ENTSVCPS.IDL
	// NEED TO KEEP THIS IN SYNC WITH THE ORIGINAL DEFINITION IN THE EE
	[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("C3FCC19E-A970-11d2-8B5A-00A0C9B7C9C4")]
    [ComImport]
    internal interface IManagedObject
    {
		// the rest of the methods we don't care
        // helper to serialize the object and marshal it to the client 
        void GetSerializedBuffer(ref String s);
                
        // helper to identify the process id and whether the object
        // is a configured object
        void GetObjectIdentity(ref String s, ref int AppDomainID, ref int ccw);
    };

    /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent"]/*' />
    [Serializable]    
    [ServicedComponentProxyAttribute]
    public abstract class ServicedComponent : ContextBoundObject, 
                                              IRemoteDispatch,
                                              IDisposable,
                                              IManagedObject,
                                              IServicedComponentInfo
    {
        private bool _denyRemoteDispatch;
        private MethodInfo _finalize;
        private bool _calledDispose;

        private static RWHashTableEx _finalizeCache;
        private static Type _typeofSC;

        static MethodBase s_mbFieldGetter;
        static MethodBase s_mbFieldSetter;
        static MethodBase s_mbIsInstanceOfType;
            
        const String c_strFieldGetterName = "FieldGetter";
        const String c_strFieldSetterName = "FieldSetter";
        const String c_strIsInstanceOfTypeName = "IsInstanceOfType";
                            
        const BindingFlags bfLookupAll = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static;
        
        static ServicedComponent()
        {
            _finalizeCache = new RWHashTableEx();
            _typeofSC = typeof(ServicedComponent);
        }        
        
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.ServicedComponent"]/*' />
        public ServicedComponent()
        {
            ServicedComponentProxy pxy = RemotingServices.GetRealProxy(this) as ServicedComponentProxy;
            DBG.Assert(pxy != null, "RealProxy() is null during constructor!");
            pxy.SuppressFinalizeServer();

            Type thisType = this.GetType();
            _denyRemoteDispatch = ServicedComponentInfo.AreMethodsSecure(thisType);
            
            // Get the methodinfo for finalize...
            // REVIEW:  Do we have to do anything special to make sure we
            // get the one furthest down the chain?
            
            bool bFoundInCache = false;

            _finalize = _finalizeCache.Get(thisType, out bFoundInCache) as MethodInfo;
            
            if (bFoundInCache == false)
            {
                _finalize = GetDeclaredFinalizer(thisType);
                _finalizeCache.Put(thisType, _finalize);	
            }

            _calledDispose = false;
        }

		/// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.IServicedComponentInfo.GetComponentInfo"]/*' />
		/// <internalonly/>
		void IServicedComponentInfo.GetComponentInfo(ref int infoMask, out String[] infoArray)
		{
			int newInfoMask = 0;
			System.Collections.ArrayList alist = new System.Collections.ArrayList();
			
			if ((infoMask & Thunk.Proxy.INFO_PROCESSID)!=0)
			{
				alist.Add(RemotingConfiguration.ProcessId);
				newInfoMask |= Thunk.Proxy.INFO_PROCESSID;

			}

			if ((infoMask & Thunk.Proxy.INFO_APPDOMAINID)!=0)
			{
				alist.Add(RemotingConfiguration.ApplicationId);
				newInfoMask |= Thunk.Proxy.INFO_APPDOMAINID;
			}

			if ((infoMask & Thunk.Proxy.INFO_URI)!=0)
			{
				string uri = RemotingServices.GetObjectUri(this);		
				if (uri==null)	
				{
					RemotingServices.Marshal(this);
					uri = RemotingServices.GetObjectUri(this);
				}
				alist.Add(uri);
				newInfoMask |= Thunk.Proxy.INFO_URI;
			}
			
			infoArray = (string[]) alist.ToArray(typeof(String));
			infoMask = newInfoMask;
		}
		
        
        private static MethodInfo GetDeclaredFinalizer(Type t)
        {
            DBG.Info(DBG.SC, "Searching for declared finalizer on " + t);
            MethodInfo fmi = null;
            while (t != _typeofSC)
            {
                fmi = t.GetMethod("Finalize", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                if (fmi!=null)
                    break;
                t = t.BaseType;
            }
            if(fmi != null) DBG.Info(DBG.SC, "Found finalizer = " + fmi);
            return fmi;
        }
        
		/// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.DisposeObject"]/*' />
		public static void DisposeObject(ServicedComponent sc)
        {
			RealProxy rp = RemotingServices.GetRealProxy(sc);
			
			if (rp is ServicedComponentProxy)
			{
                DBG.Info(DBG.SC, "DisposeObject(): Disposing ServicedComponentProxy");

				ServicedComponentProxy scp = (ServicedComponentProxy)rp;
				
                RemotingServices.Disconnect(sc);
                
                // dispose the actual proxy
                scp.Dispose(true);
	    	}
	    	else if (rp is RemoteServicedComponentProxy)
	    	{
                DBG.Info(DBG.SC, "DisposeObject(): Disposing RemoteServicedComponentProxy");
                
                RemoteServicedComponentProxy rscp = (RemoteServicedComponentProxy)rp;
                
        		// dispose the remote instance first
        		
        		sc.Dispose();
        		
        		// then dispose the local proxy
	    		
	    		rscp.Dispose(true);
	    	}
        	else // We're off in magic land, with no proxy of our own.
            {
                sc.Dispose();
            }
        }
		
		// IObject Control helpers
		/// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.Activate"]/*' />
		protected internal virtual void Activate()
		{
		}

		/// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.Deactivate"]/*' />
		protected internal virtual void Deactivate()
		{            
		}

        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.CanBePooled"]/*' />
        protected internal virtual bool CanBePooled()
        {
            return false;
        }

        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.Construct"]/*' />
        protected internal virtual void Construct(String s)
        {
        }

		// IRemoteDispatch methods
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.IRemoteDispatch.RemoteDispatchAutoDone"]/*' />
        /// <internalonly/>
		[AutoComplete(true)]
         // helper to dispatch an autodone method on a remote object				
        String IRemoteDispatch.RemoteDispatchAutoDone(String s)
        {
            bool failed = false;
            DBG.Info(DBG.SC, "SC: RemoteDispatch - AutoDone");
            String r = RemoteDispatchHelper(s, out failed);
            if(failed)
            {
                ContextUtil.SetAbort();
            }
        	return r;
        }

        // helper to dispatch a not autodone method on a remote object
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.IRemoteDispatch.RemoteDispatchNotAutoDone"]/*' />
        /// <internalonly/>
        [AutoComplete(false)]
        String IRemoteDispatch.RemoteDispatchNotAutoDone(String s)
        {
            bool failed = false;
            DBG.Info(DBG.SC, "SC: RemoteDispatch - NotAutoDone");
        	return RemoteDispatchHelper(s, out failed);
        }

        private void CheckMethodAccess(IMessage request)
        {
            MethodBase reqmethod = null;  // Method from the request
            MethodBase implmethod = null; // The implementation we will dispatch on.

            IMethodMessage call = request as IMethodMessage;
            if(call == null) throw new UnauthorizedAccessException();

            reqmethod = call.MethodBase;

            // Make sure we investigate the implementation, not the interface
            // for attributes (such as SecureMethod)
            implmethod = ReflectionCache.ConvertToClassMI(GetType(), reqmethod) as MethodBase;
            if(implmethod == null) throw new UnauthorizedAccessException();

            // Check implementation for dispatch attributes
            if(ServicedComponentInfo.HasSpecialMethodAttributes(implmethod))
                throw new UnauthorizedAccessException(Resource.FormatString("ServicedComponentException_SecurityMapping"));

            // Verify the method is not private, internal, or static.  Use
            // the method that's being requested here, in case it's an
            // explicit interface implementation (they're all private).
            if(!reqmethod.IsPublic || reqmethod.IsStatic)
            {
                // If this is a special method (such as the FieldGetter or Setter, thne
                // go ahead and let it through.
                if(!IsMethodAllowedRemotely(reqmethod))
                {
                    throw new UnauthorizedAccessException(Resource.FormatString("ServicedComponentException_SecurityNoPrivateAccess"));            
                }
            }

            // Make sure that the type we're invoking on is public!  This
            // covers invokes on public methods of internal interfaces.
            Type reqtype = reqmethod.DeclaringType;
            if(!reqtype.IsPublic && !reqtype.IsNestedPublic)
                throw new UnauthorizedAccessException(Resource.FormatString("ServicedComponentException_SecurityNoPrivateAccess"));            

            // Deal with nested types!  Get the declaring type of the method,
            // and then get the outer type that declared that.  It'll be
            // non-null if this is a nested type.
            reqtype = reqmethod.DeclaringType.DeclaringType;
            while(reqtype != null)
            {
                if(!reqtype.IsPublic && !reqtype.IsNestedPublic)
                    throw new UnauthorizedAccessException(Resource.FormatString("ServicedComponentException_SecurityNoPrivateAccess"));

                reqtype = reqtype.DeclaringType;
            }
        }

        internal static bool IsMethodAllowedRemotely(MethodBase method)
        {
            if (s_mbFieldGetter == null)
                s_mbFieldGetter = typeof(Object).GetMethod(c_strFieldGetterName, bfLookupAll);

            if (s_mbFieldSetter == null)
                s_mbFieldSetter = typeof(Object).GetMethod(c_strFieldSetterName,  bfLookupAll);

            if (s_mbIsInstanceOfType == null)
                s_mbIsInstanceOfType = typeof(MarshalByRefObject).GetMethod(c_strIsInstanceOfTypeName, bfLookupAll);
                
            return 
                method == s_mbFieldGetter ||
                method == s_mbFieldSetter ||
                method == s_mbIsInstanceOfType;
        }        

		// helper to implement RemoteDispatch methods
		private String RemoteDispatchHelper(String s, out bool failed)
		{			
            if(_denyRemoteDispatch)
            {
                throw new UnauthorizedAccessException(Resource.FormatString("ServicedComponentException_SecurityMapping"));
            }
			IMessage reqMsg = ComponentServices.ConvertToMessage(s, this);
			

            // Check to see if the method is marked as secure on the
            // server side:  If so, we need to kick it back to the caller,
            // cause they called us incorrectly.  Also verify the method
            // is not private, internal, or static. 
          
            CheckMethodAccess(reqMsg);

			RealProxy rp = RemotingServices.GetRealProxy(this);
			DBG.Assert(rp != null,"Null RP in Invoke helper");
			
			IMessage retMsg =  rp.Invoke(reqMsg);

            // Check for failures:
            IMethodReturnMessage mrm = retMsg as IMethodReturnMessage;
            if(mrm != null && mrm.Exception != null)
                failed = true;
            else
                failed = false;

			String sret = ComponentServices.ConvertToString(retMsg);

			return sret;
		}		

        // implementation of IDisposable
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.Dispose"]/*' />
        public void Dispose()
        {
            DBG.Info(DBG.SC, "Dispose(): calling DisposeObject.");
            DisposeObject(this);
        }

        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.Dispose1"]/*' />
        protected virtual void Dispose(bool disposing) 
        {
            DBG.Info(DBG.SC, "ServicedComponent.Dispose(" + disposing + ")");
        }

        // TODO:  Use callback mechanisms instead of helper functions.
    	internal void _callFinalize(bool disposing)
    	{
            DBG.Info(DBG.SC, "Calling finalize...");
            // ServicedComponent finalizer...
            if(!_calledDispose)
            {
                _calledDispose = true;
                Dispose(disposing);
            }

            // We have to call finalize through reflection, because the
            // compiler disallows all other calls...
            if(_finalize != null)
            {
                _finalize.Invoke(this, new Object[0]);
            }
        }

        internal void _internalDeactivate(bool disposing)
        {
            System.EnterpriseServices.ComponentServices.DeactivateObject(this, disposing);
        }
        
		internal void DoSetCOMIUnknown(IntPtr pUnk)
		{
			// this call needs to be intercepted by the proxy, before we come into the context
			// Unless the client and component live in the same context (but in different AppDomains)
			// then the proxy will not be able to intercept, so we need to do this here.			
			DBG.Info(DBG.SC, "ServicedComponent.DoSetCOMIUnknown, setting it in the proxy myself.  Punk=" + pUnk);
			RealProxy rp = RemotingServices.GetRealProxy(this);
			rp.SetCOMIUnknown(pUnk);
		}
        

        // Some dummy empty methods for IManagedObject.
        // These should never be called, this is just here to ensure that
        // IManagedObject gets stuck in the type library.
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.IManagedObject.GetSerializedBuffer"]/*' />
        /// <internalonly/>
        void IManagedObject.GetSerializedBuffer(ref String s) 
        {
            DBG.Assert(false, "IManagedObject.GetSerializedBuffer should never be called.");
            throw new NotSupportedException("IManagedObject.GetSerializedBuffer");
        }
        /// <include file='doc\ServicedComponent.uex' path='docs/doc[@for="ServicedComponent.IManagedObject.GetObjectIdentity"]/*' />
        /// <internalonly/>
        void IManagedObject.GetObjectIdentity(ref String s, ref int AppDomainID, ref int ccw)
        {
            DBG.Assert(false, "IManagedObject.GetObjectIdentity should never be called.");
            throw new NotSupportedException("IManagedObject.GetObjectIdentity");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\soapclientconfig.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Xml;
    using System.Xml.XPath;
    using System.Security.Permissions;
   
    internal class SoapClientConfig 
    {
        static internal bool Write(
            string destinationDirectory, 
            string fullUrl,
            string assemblyName, 
            string typeName, 
            string progId, 
            string authentication
            )
        {
            bool bRetVal = false;
            const string indent = "  ";
            string remotingcfg = "<configuration>\r\n";
            remotingcfg += indent + "<system.runtime.remoting>\r\n";
            remotingcfg += indent + indent + "<application>\r\n";
            remotingcfg += indent + indent + indent + "<client url=\"" + fullUrl + "\">\r\n";
            remotingcfg += indent + indent + indent + indent;
            remotingcfg += "<activated type=\"" + typeName + ", " + assemblyName + "\"/>\r\n";
            remotingcfg += indent + indent + indent + "</client>\r\n";
            if (authentication.ToLower(CultureInfo.InvariantCulture) == "windows")
            {
                remotingcfg += indent + indent + indent + "<channels>\r\n";
                remotingcfg += indent + indent + indent + indent + "<channel ref=\"http\" useDefaultCredentials=\"true\" />\r\n";
                remotingcfg += indent + indent + indent + "</channels>\r\n";
            }
            remotingcfg += indent + indent + "</application>\r\n";
            remotingcfg += indent + "</system.runtime.remoting>\r\n";
            remotingcfg += "</configuration>\r\n";
            string cfgPath = destinationDirectory;
            if (cfgPath.Length > 0 && !cfgPath.EndsWith("\\")) cfgPath += "\\";
            cfgPath += typeName + ".config";
            if (File.Exists(cfgPath)) File.Delete(cfgPath);
            FileStream cfgFile = new FileStream(cfgPath, FileMode.Create);
            StreamWriter cfgStream = new StreamWriter(cfgFile);
            cfgStream.Write(remotingcfg);
            cfgStream.Close();
            cfgFile.Close();
            bRetVal = true;
            return bRetVal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\servicedcomponentproxyattribute.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ServicedComponentProxyAttribute.cs
**
** Author:  Raja Krishnaswamy (rajak)
**
** Purpose: Defines the attribute that is used on ServicedComponent

** Date:    Sep 30, 2000
**
===========================================================*/
namespace System.EnterpriseServices {

    using System;
    using System.Reflection;    
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Services;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Contexts;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;

    [AttributeUsage(AttributeTargets.Class)]
    internal class ServicedComponentProxyAttribute : ProxyAttribute, ICustomFactory
    {
        public ServicedComponentProxyAttribute() {}
		
        // Create an instance of ServicedComponentProxy
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public override MarshalByRefObject CreateInstance(Type serverType)
        {
            // Platform.Assert(Platform.W2K, "ServicedComponent");

            RealProxy rp = null;
            MarshalByRefObject mo = null;
            DBG.Info(DBG.SC, "SCPA.CreateInstance(" + serverType + ") for managed request");
            

			ServicedComponentProxy.CleanupQueues(true);
			
            // First check if the type is configured to be activated remotely or is a well
            // known remote type.
            if((null != RemotingConfiguration.IsWellKnownClientType(serverType)) ||
               (null != RemotingConfiguration.IsRemotelyActivatedClientType(serverType)))
            {
                // It is configured for remote activation. Ask remoting services to do the
                // job of creating a remoting proxy and returning it.
                mo = base.CreateInstance(serverType);
                rp = RemotingServices.GetRealProxy(mo);
            }
            else
            {
				bool bIsAnotherProcess = false;
				string uri = "";
				bool bEventClass = ServicedComponentInfo.IsTypeEventSource(serverType);
                IntPtr pUnk = Thunk.Proxy.CoCreateObject(serverType, !bEventClass, ref bIsAnotherProcess, ref uri);
                if (pUnk != IntPtr.Zero)
                {
                	try {
                        // TODO:  Get rid of this useless foreknowledge requirement
                        // Is there a way we can tell by QI'ing this guy if he's
                        // an event class (or something else we need to artificially
                        // wrap?                
                        if (bEventClass)
                        {
                            // events and queued components use RemoteServicedComponentProxy
                            // set up a TP & Remote ServicedComponentProxy pair	            	
                            rp = new RemoteServicedComponentProxy(serverType, pUnk, true);
                            mo = (MarshalByRefObject)rp.GetTransparentProxy();	
                        }
                        else
                        {    					    					
                            if (bIsAnotherProcess)		// a-ha, we know it should be a RSCP now !!!!
                            {							
                                FastRSCPObjRef oref = new FastRSCPObjRef(pUnk, serverType, uri);
                                mo = (MarshalByRefObject) RemotingServices.Unmarshal(oref);
                                
                                DBG.Assert(mo!=null, "RemotingServices.Unmarshal returned null!");
                                DBG.Assert(RemotingServices.GetRealProxy(mo) is RemoteServicedComponentProxy, "RemotingServices.Unmarshal did not return an RSCP!");
                            }
                            else	// bummer, this will give us back a SCP
                            {
                                mo = (MarshalByRefObject)Marshal.GetObjectForIUnknown(pUnk);
                                
                                DBG.Info(DBG.SC, "ret = " + mo.GetType());
                                DBG.Info(DBG.SC, "st = " + serverType);
                                DBG.Info(DBG.SC, "rt == sc = " + (mo.GetType() == serverType));
                                DBG.Info(DBG.SC, "instanceof = " + serverType.IsInstanceOfType(mo));
                                
                                if(!(serverType.IsInstanceOfType(mo)))
                                {
                                    throw new InvalidCastException(Resource.FormatString("ServicedComponentException_UnexpectedType", serverType, mo.GetType()));
                                }
                                
                                rp = RemotingServices.GetRealProxy(mo);
                                if (!(rp is ServicedComponentProxy) && !(rp is RemoteServicedComponentProxy))
                                {
                        			// in cross-appdomain scenario, we get back a RemotingProxy, SetCOMIUnknown has not been made on our server!
                        			ServicedComponent sc = (ServicedComponent)mo;
                        			sc.DoSetCOMIUnknown(pUnk);
                                }
                            }
                        }
    				}
    				finally 
                    {
                        Marshal.Release(pUnk);
    				}
                }
            }
            
            if(rp is ServicedComponentProxy)
            {
                // Here, we tell the server proxy that it needs to filter out
                // constructor calls:  We only need to do this if
                // the proxy lives in the same context as the caller,
                // otherwise we'll get an Invoke call and can do the
                // filtering automagically:
                ServicedComponentProxy scp = (ServicedComponentProxy)rp;
                if(scp.HomeToken == Thunk.Proxy.GetCurrentContextToken())
                {
                    scp.FilterConstructors();
                }
            }

			DBG.Assert(mo is ServicedComponent, " CoCI returned an invalid object type");
			DBG.Info(DBG.SC, "SCPA.CreateInstance done.");
            return mo;
        }        

        // The COM custom factory finds a transparent proxy for use by 
        // the activation.  Note that the real object hasn't been created
        // yet, we delay that activation until a) the first method call
        // or b) the first Activate() (aka the first method call!)
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        MarshalByRefObject ICustomFactory.CreateInstance(Type serverType)
        {
            // Platform.Assert(Platform.W2K, "ServicedComponent");

            DBG.Info(DBG.SC, "SCPA.CreateInstance(" + serverType + ") for unmanaged request");

			DBG.Assert(ServicedComponentInfo.IsTypeServicedComponent(serverType),
                       "unconfigured type passed to ICustomFactory.CreateInstance");

			RealProxy rp = null;
			
			// The reason we don't want to cleanup GIT cookies from inside here (passing false) is 
			// because we will already be in a new context, and RevokeInterfaceFromGlobal will be very expensive
			// (like 5x), as it needs to switch context.  A more appropriate place to do this is in the managed CreateInstance
			// before we even call CoCreateInstance
			
			ServicedComponentProxy.CleanupQueues(false);		
			
																
			
			int iSCInfo = ServicedComponentInfo.SCICachedLookup(serverType);
			
			bool fIsTypeJITActivated = (iSCInfo & ServicedComponentInfo.SCI_JIT) != 0;
			bool fIsTypePooled = (iSCInfo & ServicedComponentInfo.SCI_OBJECTPOOLED) != 0;
			bool fAreMethodsSecure = (iSCInfo & ServicedComponentInfo.SCI_METHODSSECURE) != 0;

			if (fIsTypeJITActivated)
			{
				// NOTE: If the component is JIT activated, we may be trying
                // to connect a new backing object to an existing TP held
                // by a managed client.  So we look in our handy table
                // to see if there is a component registered for this context.
                // Because it is JIT activated, COM+ ensures that it will
                // have been the distinguished object in this context.
				
				IntPtr token = Thunk.Proxy.GetCurrentContextToken();
				
				DBG.Info(DBG.SC, "SCPA.CreateInstance looking for JIT object in IdentityTable. token="+token);
				
				Object otp   = IdentityTable.FindObject(token);
				
				if (otp != null)
				{
					DBG.Info(DBG.SC, "SCPA.CreateInstance found JIT object in IdentityTable.");
                    rp = RemotingServices.GetRealProxy(otp); 
                    
                    DBG.Assert(rp is ServicedComponentProxy, "Cached something that wasn't a serviced component proxy in the ID table!");
                    DBG.Assert(rp != null, " GetTransparentProxy.. real proxy is null");
                    DBG.Assert(serverType == rp.GetProxiedType(), "Invalid type found in Deactivated list");
				}				
			}

			if (rp == null)
			{				
                DBG.Info(DBG.SC, "SCPA.CreateInstance creating new SCP fJIT="+fIsTypeJITActivated+" fPooled="+fIsTypePooled+" fMethodsSecure="+fAreMethodsSecure);
                rp = new ServicedComponentProxy(serverType, fIsTypeJITActivated, fIsTypePooled, fAreMethodsSecure, true);
			}
            else if(rp is ServicedComponentProxy)
            {
                ServicedComponentProxy scp = (ServicedComponentProxy)rp;
                scp.ConstructServer();
            }

			MarshalByRefObject mo = (MarshalByRefObject)rp.GetTransparentProxy();
			DBG.Assert(mo != null, " GetTransparentProxy returned NULL");

			DBG.Info(DBG.SC, "SCPA.ICustomFactory.CreateInstance done.");
			
			return mo;
        }


        // remoting proxy
        /// <include file='doc\ProxyAttribute.uex' path='docs/doc[@for="ProxyAttribute.CreateProxy"]/*' />
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        public override RealProxy CreateProxy(ObjRef objRef, 
                                             Type serverType,  
                                             Object serverObject, 
                                             Context serverContext)
                	
        {        	
        	
			DBG.Assert(serverType != null, "server type is null in CreateProxy");

            //
            // If this guy isn't one of our objrefs, then we should use remoting.  Otherwise,
            // go ahead and call GetRealObject on it.
            //
            if(objRef == null)
				return base.CreateProxy(objRef, serverType, serverObject, serverContext);

			if ((objRef is FastRSCPObjRef) || 
                ((objRef is ServicedComponentMarshaler) && 
                 (!objRef.IsFromThisProcess() || ServicedComponentInfo.IsTypeEventSource(serverType))))
            {
                DBG.Info(DBG.SC, "SCPA: CreateProxy: delegating custom CreateProxy");
                Object otp = objRef.GetRealObject(new StreamingContext(StreamingContextStates.Remoting));			
                return RemotingServices.GetRealProxy(otp);
            }
            else
            {
                DBG.Info(DBG.SC, "SCPA: CreateProxy: delegating standard CreateProxy");
                return base.CreateProxy(objRef, serverType, serverObject, serverContext);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\servicedcomponentmarshaler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ServicedComponentMarshaler.cs
**
** Author:  RajaK
**
** Purpose: Defines the general purpose ServicedComponentMarshaler
**
** Date:    June 15 2000
**
===========================================================*/
namespace System.EnterpriseServices 
{
    using System;
	using System.Reflection;
	using System.Runtime.Remoting;
	using System.Runtime.Remoting.Proxies;
	using System.Runtime.Remoting.Messaging;
	using System.Runtime.InteropServices;
	using System.Runtime.Remoting.Services;	
	using System.Runtime.Serialization;	
	using Microsoft.Win32;

	internal class SCUnMarshaler
	{
		private byte[] buffer;
        private Type   servertype;
        private RealProxy _rp;
        private bool	_fUnMarshaled;

		internal SCUnMarshaler(Type _servertype, byte[] _buffer)
        {
        	buffer = _buffer;
        	servertype = _servertype;        	
        	_rp = null;
        	_fUnMarshaled = false;
        }

		private RealProxy UnmarshalRemoteReference()
		{
            DBG.Info(DBG.SC, "SCM: UnmarshalRemoteReference()");
			IntPtr pUnk = IntPtr.Zero;
			RealProxy rp = null;				            	
            	
			try
			{
				_fUnMarshaled = true;
                if (buffer != null)
                {
                    pUnk = Thunk.Proxy.UnmarshalObject(buffer);                    		       
                }
                
                // set up a remote serviced component proxy
                rp = new RemoteServicedComponentProxy(servertype, pUnk, false);
                
		    }
			finally
			{
				// now get rid of the pUnk
				if (pUnk  != IntPtr.Zero)
			        Marshal.Release(pUnk);
			    // if we have the dcom buffer get rid of it    
			     buffer = null;
		    }
		    		   		    
            return rp;
		}

		internal RealProxy GetRealProxy()
		{
			if (_rp == null && !_fUnMarshaled)
			{	
				_rp = UnmarshalRemoteReference();
        	}        	
        	return _rp;
        }

        internal void Dispose()
        {
        	if (!_fUnMarshaled && buffer != null)
        	{
        		// cleanup
        		Thunk.Proxy.ReleaseMarshaledObject(buffer);
        	}
        }
    };
    
	//---------------------------------------------------------
	//	internal class ServicedComponentMarshaler
	//---------------------------------------------------------
    // 
    [Serializable]
    internal class ServicedComponentMarshaler : ObjRef
    {     
    	private RealProxy     _rp;
    	private SCUnMarshaler _um;
		private Type          _rt;
        private bool          _marshalled;

		// Only instantiated through deserializaton.    	
    	private ServicedComponentMarshaler()
        {
        }
		
        protected ServicedComponentMarshaler(SerializationInfo info, StreamingContext context) 
        	: base(info, context) 
        {
            byte[] buffer = null;
            Type   servertype = null;
            bool bFoundFIsMarshalled = false;

            DBG.Info(DBG.SC, "SCM: construct");
        	ComponentServices.InitializeRemotingChannels();
        	SerializationInfoEnumerator e = info.GetEnumerator();
            while (e.MoveNext())
            {
                DBG.Info(DBG.SC, "SCM: ctor: name = " + e.Name + " value = " + e.Value);
                if (e.Name.Equals("servertype"))
                {
                    servertype = (Type) e.Value;
                }
                else if (e.Name.Equals("dcomInfo"))
                {
                    buffer = (byte[]) e.Value;
                }
                else if (e.Name.Equals("fIsMarshalled"))
                {
                    int value = 0;
                    Object o = e.Value;
                    if(o.GetType() == typeof(String))
                		value = ((IConvertible)o).ToInt32(null);
                	else
                    	value = (int)o;

                    if (value == 0)
                        bFoundFIsMarshalled = true;
                }
            }

            if(!bFoundFIsMarshalled)
            {
                DBG.Info(DBG.SC, "SCM: ctor: didn't find fIsMarshalled.");
                _marshalled = true;
            }

			_um = new SCUnMarshaler(servertype, buffer);

			_rt = servertype;
			

			if(IsFromThisProcess() && !ServicedComponentInfo.IsTypeEventSource(servertype))
            {
                _rp = RemotingServices.GetRealProxy(base.GetRealObject(context));
            }
            else
            {
                DBG.Assert(servertype != null, "SCM: server type is null during marshal.");
				if (ServicedComponentInfo.IsTypeEventSource(servertype))
				{
					TypeInfo = (IRemotingTypeInfo) new SCMTypeName(servertype);
				}
                Object otp = base.GetRealObject(context);
               	_rp = RemotingServices.GetRealProxy(otp);			
            }
            // cleanup the buffer, in case we found an existing rp
            _um.Dispose();
        }

		
		internal ServicedComponentMarshaler(MarshalByRefObject o, Type requestedType)
			:base(o, requestedType)
		{								
			DBG.Assert(RemotingServices.IsTransparentProxy(o), "IsTransparentProxy failed");
			_rp = RemotingServices.GetRealProxy(o);		
			_rt = requestedType;
		}

        private bool IsMarshaledObject { get { return(_marshalled); } }

		public override Object GetRealObject(StreamingContext context)
		{
            DBG.Info(DBG.SC, "SCM: GetRealObject()");

            if(!IsMarshaledObject)
            {
                DBG.Info(DBG.SC, "SCM: GetRealObject() returning objref!");
                return(this);
            }
			else
            {
                if (IsFromThisProcess() && !ServicedComponentInfo.IsTypeEventSource(_rt))
                {
                    Object otp = base.GetRealObject(context);
                    // We need to notify the object that there is a managed reference.
                    ((ServicedComponent)otp).DoSetCOMIUnknown(IntPtr.Zero);
                    
                    return(otp);
                }				
                else
                {
                    if (_rp == null)
                    {
                        _rp = _um.GetRealProxy();
                    }
                    DBG.Assert(_rp != null, "GetRealObject on a marshaller with no proxy!");
                    return(_rp.GetTransparentProxy());
                }
            }
		}
		
		// IF YOU MAK ANY CHANGES TO THIS, KEEP THE COPY IN FastRSCPObjRef in SYNC
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
            DBG.Info(DBG.SC, "SCM: GetObjectData");
			ComponentServices.InitializeRemotingChannels();
			if (info==null) 
            {
                throw new ArgumentNullException("info");
            }

            // Check to see if this is a remoting channel, if so, then we
            // should use the standard objref marshal (cause we're going over SOAP
            // or another remoting channel).
            object oClientIsClr = CallContext.GetData("__ClientIsClr");
            DBG.Info(DBG.SC, "SCM: GetObjectData: oClientIsClr = " + oClientIsClr);
            bool bUseStandardObjRef = (oClientIsClr==null)?false:(bool)oClientIsClr;
            if(bUseStandardObjRef)
            {
                RemoteServicedComponentProxy rscp = _rp as RemoteServicedComponentProxy;
                if(rscp != null)
                {
                    DBG.Info(DBG.SC, "SCM: GetObjectData: intermediary objref");
                    ObjRef std = RemotingServices.Marshal((MarshalByRefObject)(rscp.RemotingIntermediary.GetTransparentProxy()), null, null);
                    std.GetObjectData(info, context);
                }
                else 
                {
                    DBG.Info(DBG.SC, "SCM: GetObjectData: Using standard objref");
                    base.GetObjectData(info, context);
                } 
            }
            else
            {
                DBG.Info(DBG.SC, "SCM: GetObjectData: Using custom objref");
                base.GetObjectData(info, context);

                //*** base.GetObjectData sets the type to be itself
                // now wack the type to be us
                info.SetType(typeof(ServicedComponentMarshaler));
			
                DBG.Assert(_rp != null, "_rp is null");
                
                info.AddValue("servertype", _rp.GetProxiedType());	
                
                byte[] dcomBuffer = ComponentServices.GetDCOMBuffer((MarshalByRefObject)_rp.GetTransparentProxy());
                
                DBG.Assert(dcomBuffer != null, "dcomBuffer is null");
                
                if (dcomBuffer != null)
                {
                    info.AddValue("dcomInfo", dcomBuffer);
                }
            }
		}
    }

	//---------------------------------------------------------
	//	internal class FastRSCPObjRef
	//---------------------------------------------------------
    // 
    [Serializable]
    internal class FastRSCPObjRef : ObjRef
    {     
        private IntPtr _pUnk;
        private Type _serverType;
        private RealProxy _rp;
    	
    	internal FastRSCPObjRef(IntPtr pUnk, Type serverType, string uri)
        {
	        _pUnk = pUnk;        
	        _serverType = serverType;	        	        
	        
	        URI = uri;
			TypeInfo = (IRemotingTypeInfo) new SCMTypeName(serverType);
			ChannelInfo = (IChannelInfo) new SCMChannelInfo();
        }


		public override Object GetRealObject(StreamingContext context)
		{
            DBG.Info(DBG.SC, "FSCM: GetRealObject");
			DBG.Assert(_pUnk != IntPtr.Zero, "pUnk is zero!");
			DBG.Assert(_serverType != null, "_serverType is null!");
			
			RealProxy rp = new RemoteServicedComponentProxy(_serverType, _pUnk, false);
			_rp = rp;
			
			return (MarshalByRefObject)rp.GetTransparentProxy();
		}

		// copied from ServicedComponentMarshaler above directly
		// IF YOU MAK ANY CHANGES TO THIS, KEEP THE OTHER COPY IN SYNC
		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
            DBG.Info(DBG.SC, "FSCM: GetObjectData");
			ComponentServices.InitializeRemotingChannels();
			if (info==null) 
            {
                throw new ArgumentNullException("info");
            }

            // Check to see if this is a remoting channel, if so, then we
            // should use the standard objref marshal (cause we're going over SOAP
            // or another remoting channel).
            object oClientIsClr = CallContext.GetData("__ClientIsClr");
            DBG.Info(DBG.SC, "FSCM: GetObjectData: oClientIsClr = " + oClientIsClr);
            bool bUseStandardObjRef = (oClientIsClr==null)?false:(bool)oClientIsClr;
            if(bUseStandardObjRef)
            {
                RemoteServicedComponentProxy rscp = _rp as RemoteServicedComponentProxy;
                if(rscp != null)
                {
                    DBG.Info(DBG.SC, "FSCM: GetObjectData: intermediary objref");
                    ObjRef std = RemotingServices.Marshal((MarshalByRefObject)(rscp.RemotingIntermediary.GetTransparentProxy()), null, null);
                    std.GetObjectData(info, context);
                }
                else 
                {
                    DBG.Info(DBG.SC, "FSCM: GetObjectData: Using standard objref");
                    base.GetObjectData(info, context);
                } 
            }
            else
            {
                DBG.Info(DBG.SC, "FSCM: GetObjectData: Using custom objref");
                base.GetObjectData(info, context);

                //*** base.GetObjectData sets the type to be itself
                // now wack the type to be us
                info.SetType(typeof(ServicedComponentMarshaler));
			
                DBG.Assert(_rp != null, "_rp is null");
                
                info.AddValue("servertype", _rp.GetProxiedType());	
                
                byte[] dcomBuffer = ComponentServices.GetDCOMBuffer((MarshalByRefObject)_rp.GetTransparentProxy());
                
                DBG.Assert(dcomBuffer != null, "dcomBuffer is null");
                
                if (dcomBuffer != null)
                {
                    info.AddValue("dcomInfo", dcomBuffer);
                }
            }
		}
    }
    
    [Serializable]
    internal class SCMChannelInfo : IChannelInfo
    {
		public virtual Object[] ChannelData
		{
			get { return new Object[0]; }
			set { }
		}             
    }
    
	//---------------------------------------------------------
	//	internal class SCMTypeName
	//---------------------------------------------------------
    // 
 	[Serializable]
	internal class SCMTypeName : IRemotingTypeInfo
	{
		private Type _serverType;
		private string _serverTypeName;

		internal SCMTypeName(Type serverType)
		{
			_serverType = serverType;
			_serverTypeName = serverType.AssemblyQualifiedName;
		}
		// Return the fully qualified type name
		public virtual String TypeName
		{
			get { return _serverTypeName;}
			set { _serverTypeName = value; DBG.Assert(false, "SCMTypeName: set_TypeName was called!"); }
		}

		public virtual bool CanCastTo(Type castType, Object o)
		{
			return castType.IsAssignableFrom(_serverType);
		}
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\servicedcomponentproxy.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ServicedComponentProxy.cs
**
** Author:  RajaK
**
** Purpose: Defines the general purpose ServicedComponentProxy proxy
**
** Date:    June 15 2000
**
===========================================================*/
namespace System.EnterpriseServices {   
    using System;
    using System.Collections;
    using System.Reflection;
    using System.Runtime;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Proxies;    
    using System.Runtime.Remoting.Services;
    using System.Security.Permissions;
    using System.Threading;
    using System.Diagnostics;

    [ComImport]
    [Guid("da91b74e-5388-4783-949d-c1cd5fb00506")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IManagedPoolAction
    {
        void LastRelease();
    }

    internal abstract class ProxyTearoff 
    {
        internal ProxyTearoff() {}

        internal abstract void Init(ServicedComponentProxy scp);
		internal abstract void SetCanBePooled(bool fCanBePooled);
    }

	internal class ClassicProxyTearoff : ProxyTearoff, IObjectControl, IObjectConstruct
	{
		ServicedComponentProxy _scp;
		bool 	_fCanBePooled;
		
		internal override void Init(ServicedComponentProxy scp)
		{
			_scp = scp;
		}

		internal override void SetCanBePooled(bool fCanBePooled)
		{
		     DBG.Info(DBG.SC, GetHashCode() + ": ProxyTearoff: SetCanBePooled to: " + fCanBePooled);
			_fCanBePooled = fCanBePooled;			
		}

		// IObjectControl methods
        void IObjectControl.Activate()
        {
        	DBG.Info(DBG.SC, GetHashCode() +": ProxyTearoff: Delivering Activate.");
        	_scp.ActivateObject();
        }

        void IObjectControl.Deactivate()
        {
            DBG.Info(DBG.SC, GetHashCode() +": ProxyTearoff: Delivering Deactivate.");
        	System.EnterpriseServices.ComponentServices.DeactivateObject(_scp.GetTransparentProxy(), true);
        }

        bool IObjectControl.CanBePooled()
        {
            DBG.Info(DBG.SC, GetHashCode() +": Querying CanBePooled. we will be returning... " + _fCanBePooled);
        	return _fCanBePooled;
        }		

        void IObjectConstruct.Construct(Object obj)
        {
            DBG.Assert(obj is IObjectConstructString, "construct called with non-string object!");
            DBG.Info(DBG.SC, GetHashCode() +": ProxyTearoff: Delivering construct!");
        	_scp.DispatchConstruct(((IObjectConstructString)obj).ConstructString);
        }
	};

	internal class WeakProxyTearoff : ProxyTearoff, 
                                      IObjectControl, 
                                      IObjectConstruct
	{
		WeakReference _scp;
		bool 	_fCanBePooled;
		
		internal override void Init(ServicedComponentProxy scp)
		{
			_scp = new WeakReference(scp, true);
		}

		internal override void SetCanBePooled(bool fCanBePooled)
		{
		     DBG.Info(DBG.SC, GetHashCode() + ": ProxyTearoff: SetCanBePooled to: " + fCanBePooled);
			_fCanBePooled = fCanBePooled;			
		}

        internal void Refresh(ServicedComponentProxy scp)
        {
            DBG.Assert(_scp.Target == null || _scp.Target == scp, "mismatch tearoff & proxy...");
            _scp.Target = scp;
        }

		// IObjectControl methods
        void IObjectControl.Activate()
        {
            ServicedComponentProxy scp = (ServicedComponentProxy) _scp.Target;

            DBG.Assert(scp != null, "No backing proxy for Activate!");
        	DBG.Info(DBG.SC, GetHashCode() +": ProxyTearoff: Delivering Activate.");
        	scp.ActivateObject();
        }

        void IObjectControl.Deactivate()
        {
            ServicedComponentProxy scp = (ServicedComponentProxy) _scp.Target;
            // SCP may be validly null in this case (deactivate happening).
            if(scp != null)
            {
                DBG.Info(DBG.SC, GetHashCode() +": ProxyTearoff: Delivering Deactivate.");
                ComponentServices.DeactivateObject(scp.GetTransparentProxy(), true);
            }
        }

        bool IObjectControl.CanBePooled()
        {
            DBG.Info(DBG.SC, GetHashCode() +": Querying CanBePooled.");
        	return _fCanBePooled;
        }		

        void IObjectConstruct.Construct(Object obj)
        {
            ServicedComponentProxy scp = (ServicedComponentProxy) _scp.Target;

            DBG.Assert(scp != null, "construct called with no backing proxy.");
            DBG.Assert(obj is IObjectConstructString, "construct called with non-string object!");
            DBG.Info(DBG.SC, GetHashCode() +": ProxyTearoff: Delivering construct!");
        	scp.DispatchConstruct(((IObjectConstructString)obj).ConstructString);
        }
	};

    /// <include file='doc\ServicedComponentProxy.uex' path='docs/doc[@for="ServicedComponentStub"]/*' />
    internal class ServicedComponentStub : IManagedObjectInfo
    {
		private WeakReference _scp;
		
		internal ServicedComponentStub(ServicedComponentProxy scp)
		{
			Refresh(scp);
		}

        internal void Refresh(ServicedComponentProxy scp)
        {
            _scp = new WeakReference(scp, true);
        }

        /// <include file='doc\ServicedComponentProxy.uex' path='docs/doc[@for="ServicedComponentStub.IManagedObjectInfo.GetIObjectControl"]/*' />
        void IManagedObjectInfo.GetIObjectControl(out IObjectControl pCtrl)
        {
            ServicedComponentProxy scp = (ServicedComponentProxy) _scp.Target;
            pCtrl = scp.GetProxyTearoff() as IObjectControl;
        }

        /// <include file='doc\ServicedComponentProxy.uex' path='docs/doc[@for="ServicedComponentStub.IManagedObjectInfo.GetIUnknown"]/*' />
        void IManagedObjectInfo.GetIUnknown(out IntPtr pUnk)
        {
            IntPtr pTemp = IntPtr.Zero;
            ServicedComponentProxy scp = (ServicedComponentProxy) _scp.Target;

            DBG.Assert(scp != null, "GetIUnknown called with no backing proxy.");
            pUnk = scp.GetOuterIUnknown();
        }

        /// <include file='doc\ServicedComponentProxy.uex' path='docs/doc[@for="ServicedComponentStub.IManagedObjectInfo.SetInPool"]/*' />
        void IManagedObjectInfo.SetInPool(bool fInPool, IntPtr pPooledObject)
        {
            ServicedComponentProxy scp = (ServicedComponentProxy) _scp.Target;

            // If this is false, then we're coming out of the pool.
            //     Mark the pooled reference as held from managed code.
            // If this is true, then we're going back into the pool.
            //     Make sure we're not held.
            DBG.Info(DBG.SC, GetHashCode() + ": Set in pool called...: " + fInPool);
            scp.SetInPool(fInPool, pPooledObject);
        }

        /// <include file='doc\ServicedComponentProxy.uex' path='docs/doc[@for="ServicedComponentStub.IManagedObjectInfo.SetWrapperStrength"]/*' />
        void IManagedObjectInfo.SetWrapperStrength(bool bStrong)
        {
            ServicedComponentProxy scp = (ServicedComponentProxy) _scp.Target;
            DBG.Assert(scp != null, "No backing RP for SetWrapperStrength");
            Marshal.ChangeWrapperHandleStrength(scp.GetTransparentProxy(), !bStrong);
        }
    }


    // ServicedComponentProxy
    internal class ServicedComponentProxy : RealProxy, Thunk.IProxyInvoke, IManagedPoolAction
    {        
        private static readonly IntPtr NegativeOne = new IntPtr(-1);
        private static IntPtr   _stub            = Thunk.Proxy.GetContextCheck(); // stub that does context comparison

		// Static Fields
        private static MethodInfo _getTypeMethod = typeof(System.Object).GetMethod("GetType");
        private static MethodInfo _getHashCodeMethod = typeof(System.Object).GetMethod("GetHashCode");

        private static MethodBase _getIDisposableDispose = typeof(IDisposable).GetMethod("Dispose", new Type[0]);
		private static MethodBase _getServicedComponentDispose = typeof(ServicedComponent).GetMethod("Dispose", new Type[0]);
        private static MethodInfo _internalDeactivateMethod = typeof(ServicedComponent).GetMethod("_internalDeactivate", BindingFlags.NonPublic | BindingFlags.Instance);
        private static MethodInfo _initializeLifetimeServiceMethod = typeof(MarshalByRefObject).GetMethod("InitializeLifetimeService", new Type[0]);
        private static MethodInfo _getLifetimeServiceMethod = typeof(MarshalByRefObject).GetMethod("GetLifetimeService", new Type[0]);
        private static MethodInfo _getComIUnknownMethod = typeof(MarshalByRefObject).GetMethod("GetComIUnknown", BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance, null, new Type[] {typeof(bool)}, null);

		private static MethodInfo _setCOMIUnknownMethod = typeof(ServicedComponent).GetMethod("DoSetCOMIUnknown", BindingFlags.NonPublic | BindingFlags.Instance);

        private int             _gitCookie;
        private IntPtr          _token;
        private IntPtr          _context;
        private IntPtr          _pPoolUnk;

        private Thunk.Tracker   _tracker;

        private bool            _fIsObjectPooled;
        private bool            _fIsJitActivated;
        private bool            _fDeliverADC;

        private bool            _fUseIntfDispatch;

        // TODO: consolidate these 3 bits of info into one central
        // (less confusing) place.
        private bool            _fIsServerActivated; // has the server been activated
        private bool            _fIsActive;
        private bool            _tabled;

        // Cannot let a pooled object back into the pool if they weren't disposed.
        private bool            _fFinalized;
        private bool            _fReturnedByFinalizer;

        // We keep a little notice that we use to try and see if we need
        // to filter constructors for inproc local calls.
        private bool            _filterConstructors;

        private ProxyTearoff 	      _proxyTearoff;
        private ServicedComponentStub _scstub;

        private Thunk.Callback  _callback;

		private static bool _asyncFinalizeEnabled;
		private static InterlockedQueue _ctxQueue = new InterlockedQueue();
		private static InterlockedQueue _gitQueue = new InterlockedQueue();
        private static Thread           _cleanupThread;
		
		static ServicedComponentProxy()
		{
			_asyncFinalizeEnabled = true;		// we want async finalization by default
			
			try 
			{
				BooleanSwitch bs = new BooleanSwitch("DisableAsyncFinalization");
				_asyncFinalizeEnabled = !bs.Enabled;				
			}
			catch
			{
				_asyncFinalizeEnabled = true;		// if any problems, we stick to our default
			}
			
			if (_asyncFinalizeEnabled)
			{
                DBG.Info(DBG.SC, "****** SCP: static SC init..");
				_ctxQueue = new InterlockedQueue();
				_gitQueue = new InterlockedQueue();
			    _cleanupThread = new Thread(new ThreadStart(QueueCleaner));
                _cleanupThread.IsBackground = true;
	    		_cleanupThread.Start();
    
                AppDomain.CurrentDomain.DomainUnload += new EventHandler(ShutdownDomain);
			}

		}

        private static void ShutdownDomain(Object sender, EventArgs e)
        {
            DBG.Info(DBG.SC, "****** SCP: shutting down domain..");
            // Kill the cleanup thread...
            _cleanupThread.Abort();
            _cleanupThread.Join();
            
            // Cleanup everything left behind...
            while((_gitQueue.Count > 0) || (_ctxQueue.Count > 0))
                CleanupQueues(true);				

            DBG.Info(DBG.SC, "****** SCP: shutting down domain.. done");
        }

		private static void QueueCleaner()
		{
            DBG.Info(DBG.SC, "****** SCP: starting cleanup thread..");
            while (true)
            {
                CleanupQueues(true);				
                if ((_gitQueue.Count==0) && (_ctxQueue.Count==0))
                {
                    System.Threading.Thread.Sleep(2500);		
                }
            }
        }
		
		
		// default constructor
        private ServicedComponentProxy()
        {
        }


        // Normal Constructor:  This constructor is used when we need
        // to instantiate a backing object.
        internal ServicedComponentProxy(Type serverType, 
                                        bool fIsJitActivated,
                                        bool fIsPooled,
                                        bool fAreMethodsSecure,
                                        bool fCreateRealServer)
        : base(serverType, _stub, (int)-1) 
        {
            DBG.Assert(serverType != null,"server type is null");
            DBG.Assert(ServicedComponentInfo.IsTypeServicedComponent(serverType),"server type is not configurable");
            DBG.Assert(ServicedComponentInfo.IsTypeObjectPooled(serverType) == fIsPooled,"bad config properties passed to constructor");
            DBG.Assert(ServicedComponentInfo.IsTypeJITActivated(serverType) == fIsJitActivated,"bad config properties passed to constructor");

            _gitCookie = 0;

            _fIsObjectPooled = fIsPooled;
            _fIsJitActivated = fIsJitActivated;
            _fDeliverADC     = (_fIsObjectPooled || _fIsJitActivated);
            _fIsActive       = !_fDeliverADC;
            _tabled          = false;

            _fUseIntfDispatch = fAreMethodsSecure;

			_context = NegativeOne;	
            _token   = NegativeOne;
            _tracker = null;

            // Make certain that we allocate a callback where the proxy
            // lives, so that we call back correctly
            _callback = new Thunk.Callback();
            _pPoolUnk = IntPtr.Zero;

            if(Util.ExtendedLifetime)
            {
                _scstub = new ServicedComponentStub(this);
            }

            if(fCreateRealServer) 
            {
                DBG.Info(DBG.SC, GetHashCode() + ": SCP: Eagerly constructing server.");

                try
                {
                    ConstructServer();
                }
                catch (Exception e)
                {
                    ReleaseContext();
                    if(!Util.ExtendedLifetime)
                        ReleaseGitCookie();
                    _fIsServerActivated = false;
                    GC.SuppressFinalize(this);	

                    throw e;
                }
                
                // Notify the context that a managed object is alive...
                SendCreationEvents();
            }
            
            
        }

		internal static void CleanupQueues(bool bGit)	
		{
			Object o;
			
			if (!_asyncFinalizeEnabled)			// if user disabled async finalization, nothing to do (We have no queues!)
				return;
			
			if (bGit)					// do we want to participate in cleaning up GIT cookies
			{
			if (_gitQueue.Count>0)
			{
				o = _gitQueue.Pop();
				if (o!=null)
					{	
						int gitcookie = (int) o;
						Thunk.Proxy.RevokeObject(gitcookie);			// revoke a git cookie				
					}
			}
			}
			
			if (_ctxQueue.Count>0)
			{
				o = _ctxQueue.Pop();
				if (o!=null)
				{
					if (!Util.ExtendedLifetime)
						Marshal.Release((IntPtr)o);			// release a context
					else
					{
						ServicedComponentProxy scp = (ServicedComponentProxy)o;
						scp.SendDestructionEvents(false);
						scp.ReleaseContext();
					}
				}
			}			
		}
		
        private void AssertValid()
        {
            if(_context == NegativeOne || _context == IntPtr.Zero)
            {
				throw new ObjectDisposedException("ServicedComponent");
            }
        }

        // Proxy Properties
        // Home context/token info
        internal IntPtr HomeContext { get { return(_context); } }
        internal IntPtr HomeToken   { get { return(_token); } }

        // Proxy helpers
        internal bool IsProxyDeactivated { get { return !_fIsActive; } }
        internal bool IsJitActivated { get { return _fIsJitActivated; } }
        internal bool IsObjectPooled { get { return _fIsObjectPooled; } }
        internal bool AreMethodsSecure { get { return _fUseIntfDispatch; } }

        // Helpers to propagate the IObjectControl methods        
        private void DispatchActivate()
        {
            if(_fDeliverADC)
            {
                DBG.Info(DBG.SC, GetHashCode() +": DispatchActivate()");
                DBG.Assert(_fIsServerActivated == false, "Server is already Activated");
                DBG.Assert(GetUnwrappedServer() != null, "Object is null");
                // give the object a chance to activate itself
                _fIsServerActivated = true;
                
                ServicedComponent sc = (ServicedComponent)GetTransparentProxy();
                // dispatch the activate message
                try 
                {
                	sc.Activate();
                }
                catch (Exception e)
                {
                    ReleaseContext();
                    ReleaseGitCookie();
					_fIsServerActivated = false;
					
					try
					{
						EventLog log = new EventLog();

						log.Source = "System.EnterpriseServices";
						String errmsg = Resource.FormatString("Err_ActivationFailed", e.ToString());
						log.WriteEntry(errmsg, EventLogEntryType.Error);
					}
					catch (Exception)
					{
					}

					throw new COMException(Resource.FormatString("ServicedComponentException_ActivationFailed"), unchecked((int)0x8004E025) /*CO_E_INITIALIZATIONFAILED*/);
                }
            }
        }

        private void DispatchDeactivate()
        {            
            if(_fDeliverADC)
            {
                DBG.Info(DBG.SC, GetHashCode() + ": SCP: DispatchDeactivate()");
                DBG.Assert(_fIsServerActivated == true, "Server is already Deactivated");
                // give the object a chance to deactivate
                ServicedComponent sc = (ServicedComponent)GetTransparentProxy();

                _fIsServerActivated = false;
            
                try {
                	if (!_fFinalized)
                    	sc.Deactivate();
                } catch(Exception) {}
                // call the can be pooled method
                // and cache result
                if(IsObjectPooled)
                {
                	bool fCanBePooled = false;
                    DBG.Assert(GetUnwrappedServer() != null, "_server is null during can be pooled");
                    try
                    {
                    	if (!_fFinalized)
                        	fCanBePooled = sc.CanBePooled();	// otherwise we leave it at false
                        DBG.Assert(_proxyTearoff != null, "proxyhelper is null");
                        _proxyTearoff.SetCanBePooled(fCanBePooled);
                    }
                    catch(Exception)
                    {
                        _proxyTearoff.SetCanBePooled(false);
                    }
                }
            }
        }

        internal void DispatchConstruct(String str)
        {
            DBG.Info(DBG.SC, GetHashCode() + ": SCP: passing off constructor string = " + str);
            DBG.Assert(GetUnwrappedServer() != null, "Constructing a null object!");
            // dispatch the construct message                
            ServicedComponent sc = (ServicedComponent)GetTransparentProxy();
            sc.Construct(str);
        }        

        internal void ConnectForPooling(ServicedComponentProxy oldscp,
                                        ServicedComponent server, 
                                        ProxyTearoff proxyTearoff,
                                        bool fForJit)
        {
        	DBG.Assert(IsObjectPooled, " type not poolable");           
            DBG.Assert(proxyTearoff != null, " proxyTearoff is null");
            DBG.Assert(_proxyTearoff == null, " _proxyTearoff is not null");
            DBG.Assert(GetUnwrappedServer() == null, " connecting an already connected object");

            // If we had a pointer to our outer, take it away so that our
            // other proxy doesn't muck about with it.
            if(oldscp != null)
            {
                _fReturnedByFinalizer = oldscp._fFinalized;
                DBG.Info(DBG.SC, GetHashCode() + ": copy finalized = " + _fReturnedByFinalizer);

                if(fForJit)
                {
                    _pPoolUnk = oldscp._pPoolUnk;
                    oldscp._pPoolUnk = IntPtr.Zero;
                    DBG.Info(DBG.SC, GetHashCode() + ": copy pool unk = " + _pPoolUnk);
                }
            }

			// call reconnect
            if(server != null)
            {
                AttachServer(server);
            }
            
            _proxyTearoff = proxyTearoff;
            _proxyTearoff.Init(this);
            
            // the server is still deactivated
            DBG.Assert(_fIsServerActivated == false," Objects in Pool should be deactivated");
        }

        internal ServicedComponent DisconnectForPooling(ref ProxyTearoff proxyTearoff)
        {           
        	DBG.Assert(IsObjectPooled, " type not poolable");           
        	DBG.Assert(GetUnwrappedServer() != null, " disconnecting an already disconnected object");

            // if the server was activated
            if (_fIsServerActivated)
            {
            	DBG.Assert(GetUnwrappedServer() != null, " Attempting to dispatch deactivate on a null server");
                // give the component a chance to deactivate

                DispatchDeactivate();
            }
            
            proxyTearoff = _proxyTearoff;
            _proxyTearoff = null;

            // disconnect the server
            // DisconnectServer should return null if there is no existing server, but you never know...
			return (GetUnwrappedServer()==null)?null:(ServicedComponent)DetachServer();
        }

        // mark object as not active
        internal void DeactivateProxy(bool disposing)
        {
            DBG.Info(DBG.SC, GetHashCode() + ": SCP: DeactivateProxy()");
            if (_fIsActive)
            {
                Object tp = GetTransparentProxy();

                if (GetUnwrappedServer() != null)
                {
                    DBG.Assert(!IsObjectPooled, "Pooled objects shouldn't be finalized");                    
                    // allow the server to deactivate
                    DispatchDeactivate();
                    DBG.Assert(_token == Thunk.Proxy.GetCurrentContextToken(), " Bad context during deactivate");
                    ServicedComponent sc = (ServicedComponent)tp;
                    sc._callFinalize(disposing);
                    // remove the server
                    DetachServer();
                }
                else
                {
                    DBG.Assert(_fIsServerActivated == false," Server was not deactivated");
                }

                // set ole context on TP as -1
                SetStubData(this, NegativeOne);

                // set this flag here, because we call the finalize method above
                // and we don't want the call to come to deactivated proxy
                _fIsActive = false;

			   // if object is not JITActivated
                // then the object is dead w.r.t to this context		
                if (!IsJitActivated)
                {
                	// release the dcom proxy that we cache
                    // do this after _fIsActive is set to false, because
                    // for object pooling, this call could come back
                    // here, because object pooling will call Deactivate also
                   ReleaseGitCookie();
                   ReleaseContext();
                }

                ReleasePoolUnk();
            }
        }

		internal void ActivateObject()
		{
            DBG.Info(DBG.SC, GetHashCode() +": ActivateObject");
			IntPtr token = Thunk.Proxy.GetCurrentContextToken();
			DBG.Assert((int)token != -1, "Current context == -1");

			// pooling and JIT together needs some extra work
			// we might have had an entry in the pool which is
			// not the distinguished object for the context
			DBG.Info(DBG.SC, GetHashCode() + ": ActivateObject() token is " + token + " HomeToken is " + HomeToken);
			if(IsObjectPooled && IsJitActivated && HomeToken != token)
			{
				// if JIT Activated, check to see if we already have a TP
				// in this context
				Object otp = IdentityTable.FindObject(token);
				if (otp != null)
				{
					ServicedComponentProxy jitcp = 
                      (ServicedComponentProxy)RemotingServices.GetRealProxy(otp);

					DBG.Assert(jitcp.IsProxyDeactivated," jitcp not deactive");

					ProxyTearoff proxyTearoff  = null;
					// disconnect the server from the proxy
					ServicedComponent server = DisconnectForPooling(ref proxyTearoff);
					// reset the pooling flag
					proxyTearoff.SetCanBePooled(false);

					// this cp should already be deactivated,
					// no harm in calling this again
					DBG.Assert(IsProxyDeactivated, "Object in pool should not be active");
					// 2nd argument CanBePooled make sense only during DeactivateObject above
					jitcp.ConnectForPooling(this, server, proxyTearoff, true);
					EnterpriseServicesHelper.SwitchWrappers(this, jitcp);
					// set jitcp to be the right object 
					jitcp.ActivateProxy();					

					return;
                }
			}
			
			ActivateProxy();
		}
        
        private Object GetContextProperty(IntPtr ctx, Guid id)
        {
            Object prop = null;
            int    junk = 0;
            IContext ictx = Marshal.GetObjectForIUnknown(ctx) as IContext;
            if(ictx != null)
            {
                ictx.GetProperty(id, out junk, out prop);
            }
            return(prop);
        }

        internal void SendCreationEvents()
        {
            // Try to tell the COM+ context that a managed object has been
            // activated.  We can only do this if we're talking to the new
            // context....
            if(Util.ExtendedLifetime && _context != IntPtr.Zero && _context != NegativeOne)
            {
                IntPtr pInfo = this.SupportsInterface(ref _s_IID_IManagedObjectInfo);
                if(pInfo != IntPtr.Zero)
                {
                    try
                    {
                        Thunk.Proxy.SendCreationEvents(_context, pInfo, IsJitActivated);
                    }
                    finally
                    {
                        Marshal.Release(pInfo);
                    }
                }
            }
        }

        private void ReleasePoolUnk()
        {
            if(_pPoolUnk != IntPtr.Zero)
            {
                DBG.Info(DBG.SC, GetHashCode() + ": Unmarking our reference in the pool...");
                IntPtr temp = _pPoolUnk;
                _pPoolUnk = IntPtr.Zero;
                Thunk.Proxy.PoolUnmark(temp);
            }
        }

        internal void SendDestructionEvents(bool disposing)
        {
            if(Util.ExtendedLifetime && _context != IntPtr.Zero && _context != NegativeOne)
            {
                IntPtr pInfo = this.SupportsInterface(ref _s_IID_IManagedObjectInfo);
                if(pInfo != IntPtr.Zero)
                {
                    try
                    {
                        DBG.Info(DBG.SC, GetHashCode() + ": Sending to ctx=" + _context + ", stub=" + pInfo);
                        DBG.Info(DBG.SC, GetHashCode() + ": current = " + Thunk.Proxy.GetCurrentContextToken());
                        Thunk.Proxy.SendDestructionEvents(_context, pInfo, disposing);
                    }
                    finally
                    {
                        Marshal.Release(pInfo);
                    }
                }
            }
        }
        
        private void SendDestructionEventsAsync()
        {
                if(AppDomain.CurrentDomain.IsFinalizingForUnload())
                {
                    SendDestructionEvents(false);		
                }
                else
                {
                    _ctxQueue.Push(this);
                }
            DBG.Info(DBG.SC, GetHashCode() +": SendDestructionEventsAsync(): Finished.");
        }
        
        
        internal void ConstructServer()
        {
            DBG.Info(DBG.SC, GetHashCode() +": \tinitializing server");

            IConstructionReturnMessage retMsg;

            // TODO: Should we always capture the current context?
            // We can reset this appropriately if an activate comes in, but
            // we don't take a ref on the object until we know
            // it's got managed references, so this gives us
            // some useful information.
            // We might get Activate/Deactivate notifications from a 
            // different context than we expect, but that's okay
            // cause we can intercept those using the ProxyTearoff, so
            // we know they don't do a context transition.
            SetupContext(true);
            
            // Create a blank instance and call the default ctor
            retMsg = InitializeServerObject(null);
            if (retMsg != null && retMsg.Exception != null)
            {
            	ServicedComponent sc = (ServicedComponent)GetTransparentProxy();

                sc._callFinalize(true);			
                DetachServer();	
                	
                throw retMsg.Exception;
            }
        }

        internal void SuppressFinalizeServer()
        {
            GC.SuppressFinalize(GetUnwrappedServer());
        }
		
        // mark object as active
        internal void ActivateProxy()
        {           
            if (_fIsActive == false)
            {
                DBG.Info(DBG.SC, GetHashCode() +": ActivateProxy()");
                _fIsActive = true;
                
                // Force the current context to be the real one.
				SetupContext(false);
				
                DBG.Assert(_token == Thunk.Proxy.GetCurrentContextToken(), 
                           "context should be same during Activate: " + _token + ", " + Thunk.Proxy.GetCurrentContextToken());
                DBG.Assert(GetUnwrappedServer() != null, "Activating proxy with null server!");

            	// activate the server                    
                DispatchActivate();
            }
            DBG.Info(DBG.SC, GetHashCode() +": ActivateProxy(): done");
        }

        internal void FilterConstructors()
        {
            DBG.Info(DBG.SC, GetHashCode() + ": Setting up to filter constructors for in-context object.");
            
            // COM+ 24757, misconfiguration can cause a stack overflow
            if (_fIsJitActivated)
            	throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_BadConfiguration"));
            
            _filterConstructors = true;
            SetStubData(this, NegativeOne);
        }

		internal bool HasGITCookie()
		{
			return (_gitCookie != 0);
		}

        public IntPtr GetOuterIUnknown()
        {
            IntPtr pTemp = IntPtr.Zero;
            IntPtr pUnk = IntPtr.Zero;
            try
            {
                pTemp = base.GetCOMIUnknown(false);
                
                Guid iid = Util.IID_IUnknown;
                
                // this gives us the IUnkown for the object, 
                // but we want the outer!
                int hr = Marshal.QueryInterface(pTemp, ref iid, out pUnk);
                if(hr != 0) Marshal.ThrowExceptionForHR(hr);
            }
            finally
            {
                if(pTemp != IntPtr.Zero) Marshal.Release(pTemp);
            }
            return pUnk;
        }

        // IComMarshaler methods
		public override IntPtr GetCOMIUnknown(bool fIsBeingMarshalled)
		{
            // TODO:  re-enable this assert.
            DBG.Info(DBG.SC, GetHashCode() +": GetCOMIUnknown fIsBeingMarshalled="+fIsBeingMarshalled+" _gitCookie="+_gitCookie);
            DBG.Assert(Util.ExtendedLifetime && _gitCookie == 0 || !Util.ExtendedLifetime, " have GIT cookie with cycle prevention fix");

            // If we're not yet bound to a context, or we're in the correct context,
            // we can just hand out a raw IUnknown.
            if(_token == IntPtr.Zero 
               || _token == NegativeOne
               || _token == Thunk.Proxy.GetCurrentContextToken())
            {
                if(fIsBeingMarshalled)
                {
                    DBG.Assert(_token != IntPtr.Zero && _token != NegativeOne, "marshaling unbound proxy!");
                    IntPtr pRealUnk = IntPtr.Zero;
                    IntPtr pMarUnk = IntPtr.Zero;
                    try
                    {
                        pRealUnk = base.GetCOMIUnknown(false);
                        pMarUnk = Thunk.Proxy.GetStandardMarshal(pRealUnk);
                    }
                    finally
                    {
                        if(pRealUnk != IntPtr.Zero) Marshal.Release(pRealUnk);
                    }
                    return(pMarUnk);
                }
                else
                {
                    // return our IUnknown...
                    return(base.GetCOMIUnknown(false));
                }
            }
            // Otherwise, we need to get one that's valid for the current context.
            else
            {
                if(Util.ExtendedLifetime)
                {
                    // Get a marshalled reference into this context.
                    IntPtr pRealUnk = base.GetCOMIUnknown(false);
                    IntPtr pMarUnk = IntPtr.Zero;
                    try
                    {
                        // return the IMarshal for the standard marshaler.
                        byte[] buffer = _callback.SwitchMarshal(_context, pRealUnk);
                        pMarUnk = Thunk.Proxy.UnmarshalObject(buffer);
                    }
                    finally
                    {
                        if(pRealUnk != IntPtr.Zero) Marshal.Release(pRealUnk);
                    }
                    return(pMarUnk);
                }
                else
                {
                    if(_gitCookie == 0) 
                    {
                        return base.GetCOMIUnknown(false);
                    }
                
                    // If we are JIT activated, our proxy is stored in the GIT
                    // table.  Otherwise, we hold a direct reference.
                    // TODO:  Assert that _gitCookie fits in an int.
                    return(Thunk.Proxy.GetObject(_gitCookie));
                }
            }
		}
		
        // When SetCOMIUnknown is called, we have a reference coming in from
        // unmanaged code to our managed object.  We store that puppy in the
        // GIT for safe-keeping (ie, we keep it alive until we're finalized
        // or disposed).
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
		public override void SetCOMIUnknown(IntPtr i)
		{
            bool freeunk = false;
			DBG.Info(DBG.SC, GetHashCode() +": SetCOMIUnknown i="+i+" existing _gitCookie="+_gitCookie);
            // DBG.Assert(_gitCookie == IntPtr.Zero, "multiple calls to SetCOMIUnknown!");
            DBG.Assert(Util.ExtendedLifetime && _gitCookie == 0 || !Util.ExtendedLifetime, " have GIT cookie with cycle prevention fix");
            if(_gitCookie != 0) return;
            if(Util.ExtendedLifetime) return;

            try
            {
                if(i == IntPtr.Zero)
                {
                    DBG.Info(DBG.SC, GetHashCode() + ": Got SetCOMIUnknown w/ null ptr, finding our own!");
                    freeunk = true;
                    DBG.Assert(HomeToken == Thunk.Proxy.GetCurrentContextToken(), "mismatched context when we're getting our own IUnknown");
                    i = Marshal.GetIUnknownForObject(GetTransparentProxy());
                }
                
                // If we are JIT activated, shove our proxy into the GIT table,
                // otherwise, just hold a direct reference.
                _gitCookie = Thunk.Proxy.StoreObject(i);
                DBG.Info(DBG.SC, GetHashCode() +": SetCOMIUnknown new _gitCookie="+_gitCookie);			
                // mark the wrapper strength as weak to allow for GC
                if (_proxyTearoff != null)            
                    Marshal.ChangeWrapperHandleStrength(_proxyTearoff, true);
                Marshal.ChangeWrapperHandleStrength(GetTransparentProxy(), true);
            }
            finally
            {
                if(freeunk && i != IntPtr.Zero)
                    Marshal.Release(i);
            }
		}

		private static Guid _s_IID_IObjectControl = Marshal.GenerateGuidForType(typeof(IObjectControl));
		private static Guid _s_IID_IObjectConstruct = Marshal.GenerateGuidForType(typeof(IObjectConstruct));
		private static Guid _s_IID_IManagedObjectInfo = Marshal.GenerateGuidForType(typeof(IManagedObjectInfo));
		private static Guid _s_IID_IManagedPoolAction = Marshal.GenerateGuidForType(typeof(IManagedPoolAction));
		
        internal ProxyTearoff GetProxyTearoff()
        {
            if(_proxyTearoff == null)
            {
                if(Util.ExtendedLifetime)
                {
                    _proxyTearoff = new WeakProxyTearoff();
                }
                else
                {
                    _proxyTearoff = new ClassicProxyTearoff();
                }
                _proxyTearoff.Init(this);
            }
            DBG.Assert(_proxyTearoff != null, "_proxyTearoff is null!");
            return(_proxyTearoff);
        }

		public override IntPtr SupportsInterface(ref Guid iid)
		{
            // TODO: @race: Make sure that the proxyTearoff creation is thread safe.
			if (_s_IID_IObjectControl.Equals(iid))			
			{
				return Marshal.GetComInterfaceForObject(GetProxyTearoff(), typeof(IObjectControl));
			}
            else if(_s_IID_IObjectConstruct.Equals(iid))
            {
				return Marshal.GetComInterfaceForObject(GetProxyTearoff(), typeof(IObjectConstruct));
            }
            else if(_s_IID_IManagedPoolAction.Equals(iid))
            {
                return Marshal.GetComInterfaceForObject(this, typeof(IManagedPoolAction));
            }
            else if(Util.ExtendedLifetime && _s_IID_IManagedObjectInfo.Equals(iid))
            {
                return Marshal.GetComInterfaceForObject(_scstub, typeof(IManagedObjectInfo));
            }
			return IntPtr.Zero;
		}

        public override ObjRef CreateObjRef(Type requestedType)
        {        		
            return new ServicedComponentMarshaler((MarshalByRefObject)GetTransparentProxy(), requestedType);
        }        

        // Implement RealProxy.Invoke
        public override IMessage Invoke(IMessage request) 
        {
            IMessage ret = null;
            if (_token == Thunk.Proxy.GetCurrentContextToken())
            {
                ret = LocalInvoke(request);
            }
            else	// Cross-context call
            {
                ret = CrossCtxInvoke(request);
            }

            return(ret);
        }

        // Must be public to implement IProxyInvoke
        public IMessage LocalInvoke(IMessage reqMsg)
        {
            IMessage retMsg = null;

            if (reqMsg is IConstructionCallMessage)
            {
                // TODO:  Validate ConstructionCallMessage as default constructor.
                DBG.Info(DBG.SC, GetHashCode() +": Invoke: constructing object.");
                
                ActivateProxy();							

                if(_filterConstructors)
                {
                    DBG.Info(DBG.SC, GetHashCode() + ": Caught filtered constructor...");
                    _filterConstructors = false;
                    SetStubData(this, _token);
                }

                if (((IConstructionCallMessage)reqMsg).ArgCount > 0)
                    throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_ConstructorArguments"));

				MarshalByRefObject retObj = (MarshalByRefObject)GetTransparentProxy();              
        		retMsg = EnterpriseServicesHelper.CreateConstructionReturnMessage((IConstructionCallMessage)reqMsg, retObj);
            }
            else if(reqMsg is IMethodCallMessage)
            {
            
           		// check for GetType & GetHashCode
				retMsg = HandleSpecialMethods(reqMsg);
           		if (retMsg!=null)
           			return retMsg;

                DBG.Info(DBG.SC, GetHashCode() +": Invoke: Delivering " + ((IMethodCallMessage)reqMsg).MethodBase.Name);

                // Make sure that we've got a server here.
                // DBG.Assert(GetUnwrappedServer() != null, "no backing object for method call!");
                DBG.Assert(!_filterConstructors, "delivering call on object with stub data not set!");

                if(GetUnwrappedServer() == null || (IntPtr)GetStubData(this) == NegativeOne)
                    throw new ObjectDisposedException("ServicedComponent");

                bool tracked = SendMethodCall(reqMsg);
                try
                {
                    retMsg = RemotingServices.ExecuteMessage((MarshalByRefObject)GetTransparentProxy(), (IMethodCallMessage)reqMsg);
                    if(tracked)
                    {
                        SendMethodReturn(reqMsg, ((IMethodReturnMessage)retMsg).Exception);
                    }
                }
                catch(Exception e)
                {
                    if(tracked)
                    {
                        SendMethodReturn(reqMsg, e);
                    }
                    throw;
                }
            }
            DBG.Assert(retMsg != null, "Could not interpret message type");

            return(retMsg);
        }

        // Called when we want to actually switch contexts.
        [SecurityPermissionAttribute(SecurityAction.Demand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        private IMessage CrossCtxInvoke(IMessage reqMsg)
        {   
            IMessage retMsg = null;
         
            AssertValid();

            DBG.Info(DBG.SC, GetHashCode() +": SCP: Making cross context call.");

            retMsg = HandleDispose(reqMsg);
            if (retMsg != null)
                return(retMsg);

            retMsg = HandleSetCOMIUnknown(reqMsg);
            if (retMsg!=null)
                return retMsg;

            // check for GetType & GetHashCode
            retMsg = HandleSpecialMethods(reqMsg);
            if (retMsg!=null)
                return retMsg;

            Object otp = GetTransparentProxy();

            MethodBase mb = ((IMethodMessage)reqMsg).MethodBase;
            // DoCallBack to switch COM contexts
            MemberInfo m = (MemberInfo)mb;
            MemberInfo dispMemInfo = m;
            MemberInfo tempdisp = null;

            DBG.Info(DBG.SC, GetHashCode() + ": SCP: call on method " + mb.Name);
            
            // convert interface member info to class memberinfo
            MemberInfo clsMemberInfo = ReflectionCache.ConvertToClassMI(GetProxiedType(), m);
            
            DBG.Assert(!clsMemberInfo.ReflectedType.IsInterface, 
                       " Fail to map interface method to class method");
            
            bool fAutoDone = false;
            int flags = ServicedComponentInfo.MICachedLookup(clsMemberInfo);

            
            // COM+ 24551: On a class with SecureMethods, we need
            // a way to get into the context for the constructor
            // So we pretend it's on IManagedObject (all valid clients/roles should have access to this)
            if (reqMsg is IConstructionCallMessage)
            {										        
                ComMemberType cmt = ComMemberType.Method;
                dispMemInfo = Marshal.GetMethodInfoForComSlot(typeof(IManagedObject), 3, ref cmt);
            }
            else if ((tempdisp = AliasCall(mb as MethodInfo)) != null)
            {
                dispMemInfo = tempdisp;
            }
            // check for special method attributes such as Role based security
            else if (_fUseIntfDispatch || (flags & ServicedComponentInfo.MI_HASSPECIALATTRIBUTES) != 0)
            {
                // role based security implies we dispatch through an interface
                // so that we get the right IID and slot for DoCallBack
                dispMemInfo = ReflectionCache.ConvertToInterfaceMI(m);
                if (dispMemInfo == null)
                    throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_SecurityMapping"));
            }
            else
            {
                fAutoDone = (flags & ServicedComponentInfo.MI_AUTODONE) != 0;
            }
                       
            // DoCallBack to switch COM contexts
            DBG.Assert(_context != NegativeOne, "context is unset (deliver x-ctx invoke): " + GetHashCode());
            DBG.Assert(_context != IntPtr.Zero, "context is unset (deliver x-ctx invoke): " + GetHashCode());
            retMsg = _callback.DoCallback(otp, reqMsg, _context, fAutoDone, dispMemInfo, (_gitCookie != 0));

            return retMsg;
		}

		private MemberInfo AliasCall(MethodInfo mi)
        {
            if(mi == null) return(null);
            MethodInfo mb = mi.GetBaseDefinition();

            if(mb == _internalDeactivateMethod) 
            {
                DBG.Info(DBG.SC, GetHashCode() + ": SCP: Letting call to _internalDeactivate slip past security check");
                return(_getIDisposableDispose);
            }
            else if(mb == _initializeLifetimeServiceMethod
                    || mb == _getLifetimeServiceMethod
                    || mb == _getComIUnknownMethod
                    || mb == _setCOMIUnknownMethod)
            {
                DBG.Info(DBG.SC, GetHashCode() + ": SCP: Letting call to " + mb + " slip past security check");
                ComMemberType cmt = ComMemberType.Method;	// So we pretend it's on IManagedObject (all valid clients/roles should have access to this)
                return(Marshal.GetMethodInfoForComSlot(typeof(IManagedObject), 3, ref cmt));
            }
            return(null);
        }

        private IMessage HandleDispose(IMessage msg)
        {
			IMethodCallMessage methcall = msg as IMethodCallMessage;
            if(methcall != null)
            {
				MethodBase mb = methcall.MethodBase;
                
                if(mb == _getServicedComponentDispose || mb == _getIDisposableDispose)
                {
                    DBG.Info(DBG.SC, "Blocking dispose call on client side.");
                    ServicedComponent.DisposeObject((ServicedComponent)GetTransparentProxy());
                    IMethodCallMessage mcm = (IMethodCallMessage)msg;
                    return new ReturnMessage(null, null, 0, mcm.LogicalCallContext, mcm);
                }
            }
            return(null);
        }

		private IMessage HandleSetCOMIUnknown(IMessage reqMsg)
		{
		    MethodBase mb = ((IMethodMessage)reqMsg).MethodBase;
			if (mb == _setCOMIUnknownMethod)
			{
				DBG.Info(DBG.SC, GetHashCode() + ": SCP: Hijacking call to SetCOMIUnknown");
				IMethodCallMessage mcm = (IMethodCallMessage)reqMsg;
				IntPtr ip = (IntPtr) mcm.InArgs[0];
                if(ip != IntPtr.Zero)
                {
                    SetCOMIUnknown(ip);
                    return new ReturnMessage(null, null, 0, mcm.LogicalCallContext, mcm);
                }
			}

            return null;
		}

		private IMessage HandleSpecialMethods(IMessage reqMsg)
		{
		    MethodBase mb = ((IMethodMessage)reqMsg).MethodBase;
		    
			if (mb == _getTypeMethod)
			{
				DBG.Info(DBG.SC, GetHashCode() + ": SCP: Hijacking call to GetType");
				IMethodCallMessage mcm = (IMethodCallMessage)reqMsg;
                return new ReturnMessage(GetProxiedType(), null, 0, mcm.LogicalCallContext, mcm);
			}
            if (mb == _getHashCodeMethod)
            {            
                int hashCode = this.GetHashCode();
                DBG.Info(DBG.SC, GetHashCode() + ": SCP: Hijacking call to GetHashCode, returning " + hashCode);
                IMethodCallMessage mcm = (IMethodCallMessage)reqMsg;
                return new ReturnMessage(hashCode, null, 0, mcm.LogicalCallContext, mcm);
            }
            
            return null;
		}

        private bool IsRealCall(MethodBase mb)
        {
            if(mb == _internalDeactivateMethod ||
               mb == _initializeLifetimeServiceMethod ||
               mb == _getLifetimeServiceMethod ||
               mb == _getComIUnknownMethod ||
               mb == _setCOMIUnknownMethod ||
               mb == _getTypeMethod ||
               mb == _getHashCodeMethod)
            {
                return false;
            }
            return true;
        }

        private bool SendMethodCall(IMessage req)
        {
            bool tracked = false;
            if(_tracker != null)
            {
                IntPtr pUnk = IntPtr.Zero;
                try
                {
                    IMethodCallMessage mcm = req as IMethodCallMessage;
                    if(!IsRealCall(mcm.MethodBase))
                        return false;

                    if(Util.ExtendedLifetime)
                    {
                        pUnk = this.SupportsInterface(ref _s_IID_IManagedObjectInfo);
                    }
                    else
                    {
                        pUnk = GetOuterIUnknown();
                    }
                    
                    DBG.Info(DBG.SC, "SendMethodCall: method = '" + mcm.MethodBase.Name + " " + mcm.MethodBase.ReflectedType.Name + "'");
                    MethodBase mb = ReflectionCache.ConvertToInterfaceMI(mcm.MethodBase) as MethodBase;
                    if(mb != null)
                    {
                        DBG.Info(DBG.SC, "SendMethodCall: converted to = '" + mb.Name + " " + mb.ReflectedType.Name + "'");
                        _tracker.SendMethodCall(pUnk, mb);
                        tracked = true;
                    }
                }
                catch(Exception) {}
                finally
                {
                    if(pUnk != IntPtr.Zero) Marshal.Release(pUnk);
                }
            }
            return tracked;
        }

        private void SendMethodReturn(IMessage req, Exception except)
        {
            if(_tracker != null)
            {
                IntPtr pUnk = IntPtr.Zero;
                try
                {
                    IMethodCallMessage mcm = req as IMethodCallMessage;
                    if(!IsRealCall(mcm.MethodBase))
                        return;

                    if(Util.ExtendedLifetime)
                    {
                        pUnk = this.SupportsInterface(ref _s_IID_IManagedObjectInfo);
                    }
                    else
                    {
                        pUnk = GetOuterIUnknown();
                    }
                    

                    DBG.Info(DBG.SC, "SendMethodReturn: method = '" + mcm.MethodBase.Name + " " + mcm.MethodBase.ReflectedType.Name + "'");
                    MethodBase mb = ReflectionCache.ConvertToInterfaceMI(mcm.MethodBase) as MethodBase;
                    if(mb != null)
                    {
                        DBG.Info(DBG.SC, "SendMethodReturn: converted to = '" + mb.Name +  " " + mb.ReflectedType.Name + "'");
                        _tracker.SendMethodReturn(pUnk, mb, except);
                    }
                }
                catch(Exception) {}
                finally
                {
                    if(pUnk != IntPtr.Zero) Marshal.Release(pUnk);
                }
            }
        }

        private void ReleaseGitCookie()
        {
            DBG.Info(DBG.SC, GetHashCode() +": ReleaseGitCookie(): Performing final release... _gitCookie is " + _gitCookie);
            if (_gitCookie != 0)
            {
                // TODO: @race  This might not be thread safe.
                int cookie = _gitCookie;

				// set the Cookie to 0 now because RevokeObject might end up calling back into us to RevokeObject, and attempting to Revoke twice throws		
				// (i.e. this happens with pooling, Revoke will trigger a IOC.Deactivate, which ends up causes us to do a proxy cleanup in DisconnectForPooling)
				_gitCookie = 0;

                Thunk.Proxy.RevokeObject(cookie);
                
            }
            DBG.Info(DBG.SC, GetHashCode() +": ReleaseGitCookie(): Finished... _gitCookie is " + _gitCookie);
        }

        //--------------------------------------------------------------------
        // Context referencing functions.
        // SetupContext should be called f
		private void SetupContext(bool construction)
		{
			IntPtr          curtoken = Thunk.Proxy.GetCurrentContextToken();

            // First check to see if we need to set up at all.
            if(_token != curtoken) 
            {
                // We must need to.  Make sure that we blow away the 
                // old ref, if we took one.  (Might have for pooling).
                if (_token != NegativeOne)
                {
                    // We need to be sure that we release the old context,
                    // and resurrect ourselves here.
                    ReleaseContext();
                }
                
                // reinitialize the current context
                DBG.Info(DBG.SC, GetHashCode() +": \tsetting up first context reference");
                _token      = curtoken;
                // Take and hold a reference on the home context
                _context    = Thunk.Proxy.GetCurrentContext();
                DBG.Assert(_context != (IntPtr)0, "CurrentContext is zero!");
                _tracker    = Thunk.Proxy.FindTracker(_context);
            }
            
            // let us initialize tp with the ComContext
            if(!_filterConstructors) SetStubData(this, _token);
            
            // NOTE:  we won't have any races on the _tabled variable,
            // because we're protected by the fact that we're jitted.
            // NOTE:  We don't add this in immediately on construction,
            // we wait until we're actually live in a context.
            // Otherwise, we might begin to think that we're live in
            // the default context, because all pooled transactional objects
            // will be created in the default context first, but
            // activated in the context where they become live.
            if (IsJitActivated && !_tabled && !construction)
            {
                // check if JIT Activated
                // add this to our table of weak references
                IdentityTable.AddObject(_token, GetTransparentProxy());
                _tabled = true;
            }
            DBG.Info(DBG.SC, GetHashCode() +": stored home context: token = " + _token + ", ctx = " + _context);
		}

        private void ReleaseContext()
        {
            if(_token != NegativeOne)
            {
                // remove the entry from the deactivated list	               
                Object otp = GetTransparentProxy();
                
                DBG.Assert(otp != null, "otp is null when releasing context");
                
                if (IsJitActivated && _tabled)
                {
                    IdentityTable.RemoveObject(_token, otp);
                    _tabled = false;
                }

                if(_tracker != null)
                {
                    _tracker.Release();
                }

                // release the com context
                Marshal.Release(_context);
                _context = NegativeOne;
                _token   = NegativeOne;
                DBG.Info(DBG.SC, GetHashCode() +": \tunmarked current context: " + GetHashCode());
            }
        }

        internal void SetInPool(bool fInPool, IntPtr pPooledObject)
        {
            DBG.Info(DBG.SC, GetHashCode() + ": SetInPool(): " + fInPool);
            if(!fInPool)
            {
                // Hold this guy alive till we're done...
                Thunk.Proxy.PoolMark(pPooledObject);
                _pPoolUnk =  pPooledObject;
            }
            else
            {
                // TODO:  what?
                DBG.Assert(_pPoolUnk ==  IntPtr.Zero, "placing back into pool while still held!");
            }
        }
        
        // IManagedPoolAction:
        void IManagedPoolAction.LastRelease()
        {
            DBG.Info(DBG.SC, GetHashCode() + ": LastRelease: Finalizing pooled object.");
            if(IsObjectPooled && GetUnwrappedServer() != null)
            {
                // Wherever we were, we aren't there now.
                ReleaseContext();

                IntPtr token = Thunk.Proxy.GetCurrentContextToken();
                IntPtr ctx   = Thunk.Proxy.GetCurrentContext();

                try
                {
                    SetStubData(this, token);
                    ((ServicedComponent)GetTransparentProxy())._callFinalize(!_fFinalized && !_fReturnedByFinalizer);

                    // We don't have a context reference, we don't need
                    // to send destruction events to the main context,
                    // we don't need to do anything else...
                    GC.SuppressFinalize(this);
                }
                finally
                {
                    Marshal.Release(ctx);
                    SetStubData(this, _token);
                }
            }
        }

        private void FinalizeHere()
        {
            DBG.Info(DBG.SC, GetHashCode() + ": FinalizeHere: Finalizing pooled object.");
            IntPtr token = Thunk.Proxy.GetCurrentContextToken();
            IntPtr ctx   = Thunk.Proxy.GetCurrentContext();
            try
            {
                SetStubData(this, token);
                ((ServicedComponent)GetTransparentProxy())._callFinalize(false);
            }
            finally
            {
                Marshal.Release(ctx);
                SetStubData(this, NegativeOne);
            }
        }

        private void ReleaseContextAsync()
        {
            if(_token != NegativeOne)
            {
                if(AppDomain.CurrentDomain.IsFinalizingForUnload())
                {
                    ReleaseContext();
                }
                else
                {
                    // remove the entry from the deactivated list	               
                    Object otp = GetTransparentProxy();
                    
                    DBG.Assert(otp != null, "otp is null when releasing context");
                    
                    if (IsJitActivated && _tabled)
                    {
                        IdentityTable.RemoveObject(_token, otp);
                        _tabled = false;
                    }
                    
                    // release the com context
                    
                    _ctxQueue.Push((IntPtr)_context);
                    
                    _context = NegativeOne;
                    _token   = NegativeOne;
                    
                    DBG.Info(DBG.SC, GetHashCode() +": \tunmarked current context (ReleaseContextAsync): " + GetHashCode());
                }
            }
        }

        private void ReleaseGitCookieAsync()
        {
            DBG.Info(DBG.SC, GetHashCode() +": ReleaseGitCookieAsync(): Performing final release... _gitCookie is " + _gitCookie);
            if (_gitCookie != 0)
            {
                if(AppDomain.CurrentDomain.IsFinalizingForUnload())
                {
                    ReleaseGitCookie();
                }
                else
                {
                    // TODO: @race  This might not be thread safe.
                    int cookie = _gitCookie;
                    
                    // set the Cookie to 0 now because RevokeObject might end up calling back into us to RevokeObject, and attempting to Revoke twice throws		
                    // (i.e. this happens with pooling, Revoke will trigger a IOC.Deactivate, which ends up causes us to do a proxy cleanup in DisconnectForPooling)
                    _gitCookie = 0;
                    
                    _gitQueue.Push(cookie);
                }
            }
            DBG.Info(DBG.SC, GetHashCode() +": ReleaseGitCookieAsync(): Finished... _gitCookie is " + _gitCookie);
        }


        internal void Dispose(bool disposing)
        {
        	DBG.Info(DBG.SC, GetHashCode() +": SCP.Dispose(), _fIsActive is " + _fIsActive + ", disposing = " + disposing);

            // Notify the context of object destruction...
            if (Util.ExtendedLifetime)
            {
            	if (disposing || (!_asyncFinalizeEnabled))
		            SendDestructionEvents(disposing);
            }
            

        	if (_fIsActive)
        	{        	
        		ServicedComponent sc = (ServicedComponent)GetTransparentProxy();
                DBG.Assert(sc != null, " otp is null during dispose");

                // COM+ 27486:  _internalDeactivate will block waiting to enter
                // the right sync domain, and if the transaction commits while
                // we're waiting, the object will be cleaned up.  In that case
                // the Disposed exception is expected.
                try
                {
                    sc._internalDeactivate(disposing);
                }
                catch(ObjectDisposedException) {}
        	}

            if(!disposing && IsObjectPooled && GetUnwrappedServer() != null)
            {
                // We need to call finalize.  This object is permanently out
                // of the pool.
                FinalizeHere();
            }
            
            ReleasePoolUnk();

            // position the queuing of DestructionEvents after internalDeactivate, so that we do not race (async DestructionEvents frees the context as well!)
            if (Util.ExtendedLifetime)
            {
            	if (!(disposing || (!_asyncFinalizeEnabled)))
		        	SendDestructionEventsAsync();
            }

        	DBG.Assert(_fIsActive == false, "ServicedComponent is active during dispose");
        	// release the dcom proxy that we cache                       
            ReleaseGitCookie();	
            if ((disposing || (!_asyncFinalizeEnabled)) || AppDomain.CurrentDomain.IsFinalizingForUnload())
            	ReleaseContext();
            else if (!Util.ExtendedLifetime)	
				ReleaseContextAsync();	// if we are using ExtendedLifetime, then the DestructionEventsAsync will take care of freeing the context
										// except if we're finalizing for unload, we have to do that ourselves here (added the above check for IsFina..)
	        	
    	    // mark the entry as disposed
        	_fIsActive = false;
        	
        	if (disposing)				// if we're coming in due to the Finalizer, there is no point in doing this
				GC.SuppressFinalize(this);
        }

        private void RefreshStub()
        {
            // Update the weak references stored.  They may have been
            // eligible for finalization, which makes them stale.
            if(_proxyTearoff != null) _proxyTearoff.Init(this);
            if(_scstub != null) _scstub.Refresh(this);
        }

        ~ServicedComponentProxy()
        {   
        	DBG.Info(DBG.SC, GetHashCode() +": SCP.Finalize(), _fIsActive is " + _fIsActive);

			_fFinalized = true;
					
            try
            {
                // DBG.Assert(!_fIsActive, "Finalizing active object!");
                if (_gitCookie != 0)
                {
                	// resurrect this object and re-register this object for finalization
                    GC.ReRegisterForFinalize(this);
                    
                    
                    if (_asyncFinalizeEnabled)
                    	ReleaseGitCookieAsync();
                    else
                    	ReleaseGitCookie();

                    // mark the wrapper strength as ref-counted to allow GC to pick
                    // this up when the ref-count on the CCW falls to zero
                    if (_proxyTearoff != null)	
	                    Marshal.ChangeWrapperHandleStrength(_proxyTearoff, false);
                    Marshal.ChangeWrapperHandleStrength(GetTransparentProxy(), false);
                }
                else
                {
                    if(Util.ExtendedLifetime)
                    {
                        RefreshStub();
                    }
                    
                    // DBG.Assert(_pPoolUnk == IntPtr.Zero, "WARNING:  User code has leaked a pooled object!");
                    Dispose(_pPoolUnk==IntPtr.Zero?false:true);
                }
            }
            catch(Exception) {}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\soapclientimport.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Text;
    using System.IO;
    using System.Security.Permissions;
   
    /// <include file='doc\SoapClientImport.uex' path='docs/doc[@for="ISoapClientImport"]/*' />
    [Guid("E7F0F021-9201-47e4-94DA-1D1416DEC27A")]
    public interface ISoapClientImport
    {
        /// <include file='doc\SoapClientImport.uex' path='docs/doc[@for="ISoapClientImport.ProcessClientTlbEx"]/*' />
        [DispId(0x00000001)]void ProcessClientTlbEx(
            [MarshalAs(UnmanagedType.BStr)] string progId,
            [MarshalAs(UnmanagedType.BStr)] string virtualRoot,
            [MarshalAs(UnmanagedType.BStr)] string baseUrl,
            [MarshalAs(UnmanagedType.BStr)] string authentication,
            [MarshalAs(UnmanagedType.BStr)] string assemblyName,
            [MarshalAs(UnmanagedType.BStr)] string typeName
            );
    }
    
    /// <include file='doc\SoapClientImport.uex' path='docs/doc[@for="SoapClientImport"]/*' />
    [Guid("346D5B9F-45E1-45c0-AADF-1B7D221E9063")]
    public sealed class SoapClientImport: ISoapClientImport
    {
        /// <include file='doc\SoapClientImport.uex' path='docs/doc[@for="SoapClientImport.ProcessClientTlbEx"]/*' />
        public void ProcessClientTlbEx(
            string progId, 
            string virtualRoot,
            string baseUrl,
            string authentication,
            string assemblyName, 
            string typeName
            )
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
            }
            catch(Exception e)
            {
                if (e.GetType() == typeof(System.Security.SecurityException))
                {
                    string Error = Resource.FormatString("Soap_SecurityFailure");
                    ComSoapPublishError.Report(Error);
                }
                throw;
            }

            try
            {
                Platform.Assert(Platform.Whistler, "SoapClientImport.ProcessClientTlbEx");
                //if ProgId is an empty string, it means it does not go in the configuration file
                string ClientDir = GetClientPhysicalPath(true);
                if (progId.Length > 0)
                {
                    // write to the client configuration file
                    Uri baseUri = new Uri(baseUrl);
                    Uri fullUri = new Uri(baseUri, virtualRoot);
                    string auth = authentication;
                    if (auth.Length <= 0 && fullUri.Scheme.ToLower(CultureInfo.InvariantCulture) == "https")
                    {
                        auth = "Windows";    
                    }

                    SoapClientConfig.Write(
                        ClientDir,
                        fullUri.AbsoluteUri,
                        assemblyName, 
                        typeName, 
                        progId, 
                        auth
                        );
                }
            }
            catch
            {
                string Error = Resource.FormatString("Soap_ClientConfigAddFailure");
                ComSoapPublishError.Report(Error);
                throw;
            }
        }

        internal static string GetClientPhysicalPath(bool createDir)
        {
            uint size = 1024;
            StringBuilder sysDir = new StringBuilder( (int)size, (int)size); //two ints are initial and maximum size
            if (0 == GetSystemDirectory(sysDir, size))
            {
                throw new ServicedComponentException(Resource.FormatString("Soap_GetSystemDirectoryFailure"));
            }
            string PhysicalPath = sysDir.ToString() + "\\com\\SOAPAssembly\\";
            if (createDir)
            {
                if (!Directory.Exists(PhysicalPath))
                {
                    Directory.CreateDirectory(PhysicalPath);
                }
            }
            return PhysicalPath;
        }

        [DllImport("kernel32.dll", CharSet=CharSet.Unicode)]
        internal static extern uint GetSystemDirectory(StringBuilder lpBuf, uint uSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\soapserverconfig.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Globalization;
    using System.Xml;
    using System.Xml.XPath;
    using System.Text;
    using System.Security.Permissions;
   
    internal class SoapServerConfig 
    {
        internal static bool Create(
            string inFilePath,
            bool impersonate,
            bool windowsAuth)
        {
            string FilePath = inFilePath;
            if (FilePath.Length <= 0) return false;
            if (!FilePath.EndsWith("/") && !FilePath.EndsWith("\\")) FilePath += "\\";
            string FileName = FilePath + "web.config";
            if (!File.Exists(FileName))
            {
                XmlTextWriter writer = new XmlTextWriter(FileName, new UTF8Encoding());
                writer.Formatting = Formatting.Indented;
                writer.WriteStartDocument();
                writer.WriteStartElement("configuration");
                writer.Flush();
                writer.Close();
            }
            return ChangeSecuritySettings(FileName, impersonate, windowsAuth);
        }

        internal static XmlElement FindOrCreateElement(
            XmlDocument configXml, 
            XmlNode node, 
            string elemName)
        {
            XmlElement retVal = null;
            XmlNodeList nl = node.SelectNodes(elemName);
            if (nl.Count == 0)
            {
                XmlElement elem = configXml.CreateElement(elemName);
                node.AppendChild(elem);
                retVal = elem;
            }
            else
            {
                retVal = (XmlElement)nl[0];
            }
            return retVal;
        }

        internal static bool UpdateChannels(XmlDocument configXml)
        {
            XmlNode node= configXml.DocumentElement; 
            XmlElement e = FindOrCreateElement(configXml, node, "system.runtime.remoting");
            e = FindOrCreateElement(configXml, e, "application");
            e = FindOrCreateElement(configXml, e, "channels");
            e = FindOrCreateElement(configXml, e, "channel");
            e.SetAttribute("ref", "http server");
            return true;
        }

        internal static bool UpdateSystemWeb(XmlDocument configXml, bool impersonate, bool authentication)
        {
            XmlNode node= configXml.DocumentElement; 
            XmlElement e = FindOrCreateElement(configXml, node, "system.web");
            if (impersonate)
            {
                XmlElement x = FindOrCreateElement(configXml, e, "identity");
                x.SetAttribute("impersonate", "true");
            }
            if (authentication)
            {
                XmlElement x = FindOrCreateElement(configXml, e, "authentication");
                x.SetAttribute("mode", "Windows");
            }
            return true;
        }

        internal static bool ChangeSecuritySettings(
            string fileName,
            bool impersonate,
            bool authentication)
        {
            if (!File.Exists(fileName))
            {
                return false;
            }
            XmlDocument configXml = new XmlDocument();
            configXml.Load(fileName);
            bool bRetVal = UpdateChannels(configXml);
            if (bRetVal)
            {
                bRetVal = UpdateSystemWeb(configXml, impersonate, authentication);
                try
                {
                    if (bRetVal) configXml.Save(fileName);
                }
                catch
                {
                    string Error = Resource.FormatString("Soap_WebConfigFailed");
                    ComSoapPublishError.Report(Error);
                    throw;
                }
            }
            if (!bRetVal) 
            {
                string Error = Resource.FormatString("Soap_WebConfigFailed");
                ComSoapPublishError.Report(Error);
            }
            return bRetVal;
        }

        internal static void AddComponent(
            string filePath, 
            string assemblyName, 
            string typeName, 
            string progId, 
            string assemblyFile,
            string wkoMode, // singleton or singlecall
            bool   wellKnown,
            bool   clientActivated
            )
        {
            try
            {
                AssemblyManager manager = new AssemblyManager();
                string WKOstrType = typeName + ", " + manager.GetFullName(assemblyFile, assemblyName);
                string CAOstrType = typeName + ", " + assemblyName;
                XmlDocument configXml = new XmlDocument();
                configXml.Load(filePath);
                XmlNode node= configXml.DocumentElement; 
                node = FindOrCreateElement(configXml, node, "system.runtime.remoting");
                node = FindOrCreateElement(configXml, node, "application");
                node = FindOrCreateElement(configXml, node, "service");
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    if (n.ParentNode != null)
                    {
                        n.ParentNode.RemoveChild(n);
                        nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                    }
                }
                nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    if (n.ParentNode != null)
                    {
                        n.ParentNode.RemoveChild(n);
                        nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                    }
                }
                if (wellKnown)
                {
                    XmlElement WKOElement = configXml.CreateElement("wellknown");
                    WKOElement.SetAttribute("mode", wkoMode);
                    WKOElement.SetAttribute("type", WKOstrType);
                    WKOElement.SetAttribute("objectUri", progId+".soap");
                    node.AppendChild(WKOElement);
                }
                if (clientActivated)
                {
                    XmlElement CAElement = configXml.CreateElement("activated"); 
                    CAElement.SetAttribute("type", CAOstrType);
                    node.AppendChild(CAElement);
                }
                configXml.Save(filePath);
            }
            catch(Exception e)
            {
                string Error = Resource.FormatString("Soap_ConfigAdditionFailure");
                ComSoapPublishError.Report(Error + " " + e.Message);
                throw;
            }
        }

        internal static void DeleteComponent(
            string filePath, 
            string assemblyName, 
            string typeName, 
            string progId, 
            string assemblyFile
            )
        {
            try
            {
                AssemblyManager manager = new AssemblyManager();
                string WKOstrType = typeName + ", " + manager.GetFullName(assemblyFile, assemblyName);
                string CAOstrType = typeName + ", " + assemblyName;
                XmlDocument configXml = new XmlDocument();
                configXml.Load(filePath);
                XmlNode node= configXml.DocumentElement; 
                node = FindOrCreateElement(configXml, node, "system.runtime.remoting");
                node = FindOrCreateElement(configXml, node, "application");
                node = FindOrCreateElement(configXml, node, "service");
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    {
                        if (n.ParentNode != null)
                        {
                            n.ParentNode.RemoveChild(n);
                            nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                        }
                    }
                }
                nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    {
                        if (n.ParentNode != null)
                        {
                            n.ParentNode.RemoveChild(n);
                            nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                        }
                    }
                }

                configXml.Save(filePath);
            }
                // these exceptions are not reported because on a proxy uninstall these files will not be present, but the
                // the proxy bit is not set on deletions
            catch(System.IO.DirectoryNotFoundException) {}
            catch(System.IO.FileNotFoundException) {}
            //COM+ 32052 - on a client proxy delete this code path is hit because it is impossible to 
            //to tell from the catalog that we are a client proxy. If the assembly has been removed from
            //the GAC the deletion will fail if we re-throw this exception.
            catch(System.EnterpriseServices.RegistrationException) {}
            catch(Exception e)
            {
                string Error = Resource.FormatString("Soap_ConfigDeletionFailure");
                ComSoapPublishError.Report(Error + " " + e.Message);
                throw;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\txprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: April 2000
//


namespace System.EnterpriseServices
{
    
    using System;
    using System.Runtime.InteropServices;

    [ComImport]
    [Guid("000001c0-0000-0000-C000-000000000046")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface IContext
    {
        void SetProperty([In, MarshalAs(UnmanagedType.LPStruct)] Guid policyId,
                         [In] int flags, 
                         [In, MarshalAs(UnmanagedType.Interface)] Object punk);

        void RemoveProperty([In, MarshalAs(UnmanagedType.LPStruct)] Guid policyId);
        
        void GetProperty([In, MarshalAs(UnmanagedType.LPStruct)] Guid policyId,
                         [Out] out int flags,
                         [Out, MarshalAs(UnmanagedType.Interface)] out Object pUnk);
    }

    /// <include file='doc\TxProp.uex' path='docs/doc[@for="IManagedObjectInfo"]/*' />
    [ComImport]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [Guid("1427c51a-4584-49d8-90a0-c50d8086cbe9")]
    internal interface IManagedObjectInfo
    {
        /// <include file='doc\TxProp.uex' path='docs/doc[@for="IManagedObjectInfo.GetIUnknown"]/*' />
        void GetIUnknown(out IntPtr pUnk);

        /// <include file='doc\TxProp.uex' path='docs/doc[@for="IManagedObjectInfo.GetIObjectControl"]/*' />
        void GetIObjectControl(out IObjectControl pCtrl);

        /// <include file='doc\TxProp.uex' path='docs/doc[@for="IManagedObjectInfo.SetInPool"]/*' />
        void SetInPool([MarshalAs(UnmanagedType.Bool)] bool fInPool, IntPtr pPooledObject);

        /// <include file='doc\TxProp.uex' path='docs/doc[@for="IManagedObjectInfo.SetWrapperStrength"]/*' />
        void SetWrapperStrength([MarshalAs(UnmanagedType.Bool)] bool bStrong);
    }    
    
    [ComImport]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    [Guid("a5f325af-572f-46da-b8ab-827c3d95d99e")]
    internal interface IManagedActivationEvents
    {
        void CreateManagedStub(IManagedObjectInfo pInfo, [MarshalAs(UnmanagedType.Bool)] bool fDist);
        void DestroyManagedStub(IManagedObjectInfo pInfo);
    }

    [ComImport]
    [Guid("4E31107F-8E81-11d1-9DCE-00C04FC2FBA2")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ITxStreamInternal
    {
        void GetTransaction(out ITransaction ptx);
        [PreserveSig]
        Guid GetGuid();
        [PreserveSig]
        [return : MarshalAs(UnmanagedType.Bool)]
        bool TxIsDoomed();
        
        // NOTE:  there are more methods here, which I am not describing.
    }

    [ComImport]
    [Guid("788ea814-87b1-11d1-bba6-00c04fc2fa5f")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ITransactionProperty
    {
        [PreserveSig]
        void SetConsistent(bool fConsistent);
        void GetTransaction(out ITransaction ptx);
        [PreserveSig]
        void GetTxStream([Out] out ITxStreamInternal ptsi);
        [PreserveSig]
        Guid GetTxStreamGuid();
        [PreserveSig]
        int GetTxStreamMarshalSize();
        [PreserveSig]
        int GetTxStreamMarshalBuffer();
        [PreserveSig]
        short GetUnmarshalVariant();	// 0 if representative, 1 if root, 2 if nonroot
        [PreserveSig]
        [return:MarshalAs(UnmanagedType.Bool)]
        bool NeedEnvoy();
        [PreserveSig]
        short GetRootDtcCapabilities();

	[PreserveSig]
        int GetTransactionResourcePool(out ITransactionResourcePool pool);

        void GetTransactionId(ref Guid guid);
        Object GetClassInfo();
        [PreserveSig]
        [return : MarshalAs(UnmanagedType.Bool)]
        bool IsRoot();
        /*  We don't have a defn for IPhase0Notify yet.
        [PreserveSig]
        void RegisterPhase0 ([in] IPhase0Notify *pPhase0Notify);
        [PreserveSig]
        void UnregisterPhase0([in] IPhase0Notify *pPhase0Notify);
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\soapserverinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Net;
    using System.Text;
    using System.IO;
    using System.Security.Permissions;
   
    /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="ISoapUtility"]/*' />
    [Guid("5AC4CB7E-F89F-429b-926B-C7F940936BF4")]
    public interface ISoapUtility
    {
        /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="ISoapUtility.GetServerPhysicalPath"]/*' />
        [DispId(0x00000001)]
        void GetServerPhysicalPath(
            [MarshalAs(UnmanagedType.BStr)] string rootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string inBaseUrl,
            [MarshalAs(UnmanagedType.BStr)] string inVirtualRoot,
            [MarshalAs(UnmanagedType.BStr)] out string physicalPath
            );

        /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="ISoapUtility.GetServerBinPath"]/*' />
        [DispId(0x00000002)]
        void GetServerBinPath(
            [MarshalAs(UnmanagedType.BStr)] string rootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string inBaseUrl,
            [MarshalAs(UnmanagedType.BStr)] string inVirtualRoot,
            [MarshalAs(UnmanagedType.BStr)] out string binPath
            );

        /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="ISoapUtility.Present"]/*' />
        [DispId(0x00000003)]
        void Present();
    }

    /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="SoapUtility"]/*' />
    [Guid("5F9A955F-AA55-4127-A32B-33496AA8A44E")]
    public sealed class SoapUtility : ISoapUtility
    {
        /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="SoapUtility.GetServerPhysicalPath"]/*' />
        public void GetServerPhysicalPath(
            string rootWebServer,
            string inBaseUrl,
            string inVirtualRoot, 
            out string physicalPath
           )
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                Platform.Assert(Platform.Whistler, "SoapUtility.GetServerPhysicalPath");
                physicalPath = SoapServerInfo.ServerPhysicalPath(rootWebServer, inBaseUrl, inVirtualRoot, false);
            }
            catch(Exception e)
            {
                if (e.GetType() == typeof(System.Security.SecurityException))
                {
                    string Error = Resource.FormatString("Soap_SecurityFailure");
                    ComSoapPublishError.Report(Error);
                }
                throw;
            }
        }

        /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="SoapUtility.GetServerBinPath"]/*' />
        public void GetServerBinPath(
            string rootWebServer,
            string inBaseUrl,
            string inVirtualRoot, 
            out string binPath
            )
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                Platform.Assert(Platform.Whistler, "SoapUtility.GetServerBinPath");
                binPath = SoapServerInfo.ServerPhysicalPath(rootWebServer, inBaseUrl, inVirtualRoot, false) + "\\bin\\";
            }
            catch(Exception e)
            {
                if (e.GetType() == typeof(System.Security.SecurityException))
                {
                    string Error = Resource.FormatString("Soap_SecurityFailure");
                    ComSoapPublishError.Report(Error);
                }
                throw;
            }
        }

        /// <include file='doc\SoapServerInfo.uex' path='docs/doc[@for="SoapUtility.Present"]/*' />
        public void Present() 
        {

            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                Platform.Assert(Platform.Whistler, "SoapUtility.Present");
            }
            catch(Exception e)
            {
                if (e.GetType() == typeof(System.Security.SecurityException))
                {
                    string Error = Resource.FormatString("Soap_SecurityFailure");
                    ComSoapPublishError.Report(Error);
                }
                throw;
            }
        }
    }

    internal class SoapServerInfo
    {

        internal static bool BoolFromString(string inVal, bool inDefault)
        {
            if (null == inVal) return inDefault;
            string val = inVal.ToLower(CultureInfo.InvariantCulture);
            bool bRetVal = inDefault;
            // if there is an exact match we set the value
            // Bool.Parse not used because strings in unmanaged code
            // are not localized
            if (val == "true") bRetVal  = true;
            if (val == "false") bRetVal = false;
            return bRetVal;
        }


        internal static string ServerPhysicalPath(
            string rootWebServer,
            string inBaseUrl,
            string inVirtualRoot,
            bool createDir)
        {
            string PhysicalPath = "";
            string BaseUrl = "";
            string VirtualRoot = "";                     
            ParseUrl(inBaseUrl, inVirtualRoot, "", out BaseUrl, out VirtualRoot);
            if (VirtualRoot.Length <= 0) return PhysicalPath;
            StringBuilder sysDir = new StringBuilder(1024,1024);
            uint size = 1024;
            if (0 == GetSystemDirectory(sysDir, size))
            {
                throw new ServicedComponentException(Resource.FormatString("Soap_GetSystemDirectoryFailure"));
            }
            if (sysDir.ToString().Length <= 0) return PhysicalPath;
            PhysicalPath = sysDir.ToString() + "\\com\\SoapVRoots\\" + VirtualRoot;
            if (createDir)
            {
                string bindir = PhysicalPath + "\\bin";
                if (!Directory.Exists(bindir))
                {
                    Directory.CreateDirectory(bindir);
                }
            }
            return PhysicalPath;
        }

        internal static void ParseUrl(
            string inBaseUrl, 
            string inVirtualRoot, 
            string inProtocol, 
            out string baseUrl, 
            out string virtualRoot)
        {
            // if only a relative path, the constructor will
            // throw an exception
            string protocol = "https";
            if (inProtocol.ToLower(CultureInfo.InvariantCulture) == "http")
            {
                protocol = inProtocol;
            }
            baseUrl = inBaseUrl;
            if (baseUrl.Length <= 0)
            {
                baseUrl = protocol + "://";
                baseUrl += Dns.GetHostName();
                baseUrl += "/";
            }
            Uri currUri = new Uri(baseUrl);
            //fix for COM+ 29871 - this will correctly pick up any changes from the
            //virtual root and merge them into the new Uri
            Uri fullVRoot = new Uri(currUri, inVirtualRoot);
            if (fullVRoot.Scheme != protocol)
            {
                UriBuilder fixUri = new UriBuilder(fullVRoot.AbsoluteUri);
                fixUri.Scheme = protocol;
                //COM+ 31902 - when changing schemes UriBuilder
                //will append the port number if it is set
                //to the default for http (80) or https (443)
                //The change below fixes this behavior.
                //Since the port is the default, the Uri
                //does not have the port appended.  If the
                //user has tacked on a custom port it is 
                //retained.
                if (protocol == "https"  && fixUri.Port == 80)
                {
                    fixUri.Port = 443;
                }
                if (protocol == "http" && fixUri.Port == 443)
                {
                    fixUri.Port = 80;
                }
                fullVRoot = fixUri.Uri;
            }
            string[] uriSegs = fullVRoot.Segments;
            // last segment in Uri is the VRoot
            virtualRoot = uriSegs[uriSegs.GetUpperBound(0)];
            //remove possible slash from end
            baseUrl = fullVRoot.AbsoluteUri.Substring(0, fullVRoot.AbsoluteUri.Length - virtualRoot.Length);
            char[] slash = { '/' };
            virtualRoot = virtualRoot.TrimEnd(slash); 
        }

        [DllImport("kernel32.dll", CharSet=CharSet.Unicode)]
        internal static extern uint GetSystemDirectory(StringBuilder lpBuf, uint uSize);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\swc.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

using System;
using System.Runtime.InteropServices;

namespace System.EnterpriseServices
{   
    /// <include file='doc\SWC.uex' path='docs/doc[@for="ThreadPoolOption"]/*' />
    [Serializable]
    [ComVisible(false)]
    public enum ThreadPoolOption
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="ThreadPoolOption.None"]/*' />
        None    = 0,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ThreadPoolOption.Inherit"]/*' />
        Inherit = 1,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ThreadPoolOption.STA"]/*' />
        STA     = 2,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ThreadPoolOption.MTA"]/*' />
        MTA     = 3
    }
    
    /// <include file='doc\SWC.uex' path='docs/doc[@for="TransactionStatus"]/*' />
    [Serializable]
    [ComVisible(false)]
    public enum TransactionStatus
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="TransactionStatus.Commited"]/*' />
        Commited        = 0,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="TransactionStatus.LocallyOk"]/*' />
        LocallyOk       = 1,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="TransactionStatus.NoTransaction"]/*' />
        NoTransaction   = 2,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="TransactionStatus.Aborting"]/*' />
        Aborting        = 3,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="TransactionStatus.Aborted"]/*' />
        Aborted         = 4
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="InheritanceOption"]/*' />
    [Serializable]
    [ComVisible(false)]
    public enum InheritanceOption
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="InheritanceOption.Inherit"]/*' />
        Inherit  = 0,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="InheritanceOption.Ignore"]/*' />
        Ignore   = 1,
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="BindingOption"]/*' />
    [Serializable]
    [ComVisible(false)]
    public enum BindingOption
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="BindingOption.NoBinding"]/*' />
        NoBinding            = 0,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="BindingOption.BindingToPoolThread"]/*' />
        BindingToPoolThread  = 1
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="SxsOption"]/*' />
    [Serializable]
    [ComVisible(false)]
    public enum SxsOption
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="SxsOption.Ignore"]/*' />
        Ignore  = 0,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="SxsOption.Inherit"]/*' />
        Inherit = 1,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="SxsOption.New"]/*' />
        New     = 2
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="PartitionOption"]/*' />
    [Serializable]
    [ComVisible(false)]
    public enum PartitionOption
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="PartitionOption.Ignore"]/*' />
        Ignore  = 0,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="PartitionOption.Inherit"]/*' />
        Inherit = 1,

        /// <include file='doc\SWC.uex' path='docs/doc[@for="PartitionOption.New"]/*' />
        New     = 2
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig"]/*' />
    [ComVisible(false)]
    public sealed class ServiceConfig
    {
        private Thunk.ServiceConfigThunk m_sct;

        private ThreadPoolOption m_thrpool;
        private InheritanceOption m_inheritance;
        private BindingOption m_binding;
        
        private TransactionOption m_txn;
        private TransactionIsolationLevel m_txniso;
        private int m_timeout;        
        private string m_strTipUrl;
        private string m_strTxDesc;
        private ITransaction m_txnByot;

        private SynchronizationOption m_sync;

        private bool m_bIISIntrinsics;
        private bool m_bComTIIntrinsics;

        private bool m_bTracker;
        private string m_strTrackerAppName;
        private string m_strTrackerCompName;

        private SxsOption m_sxs;
        private string m_strSxsDirectory;
        private string m_strSxsName;

        private PartitionOption m_part;
        private Guid m_guidPart;

        private void Init()
        {            
            m_sct = new Thunk.ServiceConfigThunk();
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.ServiceConfig"]/*' />
        public ServiceConfig()
        {
            Platform.Assert(Platform.Supports(PlatformFeature.SWC), "ServiceConfig");
            Init(); 
        }        

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.ThreadPool"]/*' />
        public ThreadPoolOption ThreadPool
        {
            get { return m_thrpool; }
            set { m_sct.ThreadPool = (int)value; m_thrpool = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.Inheritance"]/*' />
        public InheritanceOption Inheritance
        {
            get 
            { 
                return m_inheritance; 
            }

            set
            { 
                m_sct.Inheritance = (int)value;
                m_inheritance = value; 

                switch (value)              
                {
                case InheritanceOption.Inherit:
                    m_thrpool = ThreadPoolOption.Inherit;
                    m_txn = TransactionOption.Supported;
                    m_sync = SynchronizationOption.Supported;
                    m_bIISIntrinsics = true;
                    m_bComTIIntrinsics = true;
                    m_sxs = SxsOption.Inherit;
                    m_part = PartitionOption.Inherit;
                    break;

                case InheritanceOption.Ignore:
                    m_thrpool = ThreadPoolOption.None;
                    m_txn = TransactionOption.Disabled;
                    m_sync = SynchronizationOption.Disabled;
                    m_bIISIntrinsics = false;
                    m_bComTIIntrinsics = false;
                    m_sxs = SxsOption.Ignore;
                    m_part = PartitionOption.Ignore;
                    break;

                default:                    
                    throw new ArgumentException();
                }              
            }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.Binding"]/*' />
        public BindingOption Binding
        {
            get { return m_binding; }
            set { m_sct.Binding = (int)value; m_binding = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.Transaction"]/*' />
        public TransactionOption Transaction
        {
            get { return m_txn; }
            set { m_sct.Transaction = (int)value; m_txn = value; }                
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.IsolationLevel"]/*' />
        public TransactionIsolationLevel IsolationLevel
        {
            get { return m_txniso; }
            set { m_sct.TxIsolationLevel = (int)value; m_txniso = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.TransactionTimeout"]/*' />
        public int TransactionTimeout
        {
            get { return m_timeout; }
            set { m_sct.TxTimeout = value; m_timeout = value; }
        }
        
        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.TipUrl"]/*' />
        public string TipUrl
        {
            get { return m_strTipUrl; }
            set { m_sct.TipUrl = value; m_strTipUrl = value; }
        }
        
        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.TransactionDescription"]/*' />
        public string TransactionDescription
        {
            get { return m_strTxDesc; }
            set { m_sct.TxDesc = value; m_strTxDesc = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.BringYourOwnTransaction"]/*' />
        public ITransaction BringYourOwnTransaction
        {
            get { return m_txnByot; }
            set { m_sct.Byot = value; m_txnByot = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.Synchronization"]/*' />
        public SynchronizationOption Synchronization
        {
            get { return m_sync; }
            set { m_sct.Synchronization = (int)value; m_sync = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.IISIntrinsics"]/*' />
        public bool IISIntrinsicsEnabled
        {
            get { return m_bIISIntrinsics; }
            set { m_sct.IISIntrinsics = value; m_bIISIntrinsics = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.COMTIIntriniscs"]/*' />
        public bool COMTIIntrinsicsEnabled
        {
            get { return m_bComTIIntrinsics; }
            set { m_sct.COMTIIntrinsics = value; m_bComTIIntrinsics = value; }            
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.TrackingEnabled"]/*' />
        public bool TrackingEnabled
        {
            get { return m_bTracker; }
            set { m_sct.Tracker = value; m_bTracker = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.TrackingAppName"]/*' />
        public string TrackingAppName
        {
            get { return m_strTrackerAppName; }
            set { m_sct.TrackerAppName = value; m_strTrackerAppName = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.TrackingComponentName"]/*' />
        public string TrackingComponentName
        {
            get { return m_strTrackerCompName; }
            set { m_sct.TrackerCtxName = value; m_strTrackerCompName = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.SxsOption"]/*' />
        public SxsOption SxsOption
        {
            get { return m_sxs; }
            set { m_sct.Sxs = (int)value; m_sxs = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.SxsDirectory"]/*' />
        public string SxsDirectory
        {
            get { return m_strSxsDirectory; }
            set { m_sct.SxsDirectory = value; m_strSxsDirectory = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.SxsName"]/*' />
        public string SxsName
        {
            get { return m_strSxsName; }
            set { m_sct.SxsName = value; m_strSxsName = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.PartitionOption"]/*' />
        public PartitionOption PartitionOption
        {
            get { return m_part; }
            set { m_sct.Partition = (int)value; m_part = value; }
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceConfig.PartitionId"]/*' />
        public Guid PartitionId
        {
            get { return m_guidPart; }
            set { m_sct.PartitionId = value; m_guidPart = value; }
        }

        internal Thunk.ServiceConfigThunk SCT
        {
            get { return m_sct;  }
        }               
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceDomain"]/*' />
    [ComVisible(false)]
    public sealed class ServiceDomain    
    {             
        private const int S_OK                  = unchecked((int)0x00000000);
        private const int XACT_S_LOCALLY_OK     = unchecked((int)0x0004D00A);
        private const int XACT_E_NOTRANSACTION  = unchecked((int)0x8004D00E);
        private const int XACT_E_ABORTING       = unchecked((int)0x8004D029);
        private const int XACT_E_ABORTED        = unchecked((int)0x8004D019);

        private ServiceDomain() {}
        
        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceDomain.Enter"]/*' />
        public static void Enter(ServiceConfig cfg)
        {
            Platform.Assert(Platform.Supports(PlatformFeature.SWC), "ServiceDomain");
            Thunk.ServiceDomainThunk.EnterServiceDomain(cfg.SCT);
        }        

        /// <include file='doc\SWC.uex' path='docs/doc[@for="ServiceDomain.Leave"]/*' />
        public static TransactionStatus Leave()
        {
            Platform.Assert(Platform.Supports(PlatformFeature.SWC), "ServiceDomain");
            
            int res;

            res = Thunk.ServiceDomainThunk.LeaveServiceDomain();
            switch (res)
            {
            case S_OK:
                return TransactionStatus.Commited;
                
            case XACT_S_LOCALLY_OK:
                return TransactionStatus.LocallyOk;

            case XACT_E_NOTRANSACTION:
                return TransactionStatus.NoTransaction;

            case XACT_E_ABORTING:
                return TransactionStatus.Aborting;

            case XACT_E_ABORTED:
                return TransactionStatus.Aborted;
            }

            Marshal.ThrowExceptionForHR(res);

            return TransactionStatus.Commited;
        }
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="IServiceCall"]/*' />
    [ComImport]
    [Guid("BD3E2E12-42DD-40f4-A09A-95A50C58304B")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IServiceCall
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="IServiceCall.OnCall"]/*' />
        void OnCall();
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="IAsyncErrorNotify"]/*' />
    [ComImport]
    [Guid("FE6777FB-A674-4177-8F32-6D707E113484")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IAsyncErrorNotify
    {
        /// <include file='doc\SWC.uex' path='docs/doc[@for="IAsyncErrorNotify.OnError"]/*' />
        void OnError(int hresult);
    }

    /// <include file='doc\SWC.uex' path='docs/doc[@for="Activity"]/*' />
    [ComVisible(false)]
    public sealed class Activity
    {        
        private Thunk.ServiceActivityThunk m_sat;

        /// <include file='doc\SWC.uex' path='docs/doc[@for="Activity.Activity"]/*' />
        public Activity(ServiceConfig cfg)
        {
            Platform.Assert(Platform.Supports(PlatformFeature.SWC), "Activity");
            m_sat = new Thunk.ServiceActivityThunk(cfg.SCT);
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="Activity.SynchronousCall"]/*' />
        public void SynchronousCall(IServiceCall serviceCall)
        {
            m_sat.SynchronousCall(serviceCall);
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="Activity.AsynchronousCall"]/*' />
        public void AsynchronousCall(IServiceCall serviceCall)
        {
            m_sat.AsynchronousCall(serviceCall);
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="Activity.BindToCurrentThread"]/*' />
        public void BindToCurrentThread()
        {
            m_sat.BindToCurrentThread();
        }

        /// <include file='doc\SWC.uex' path='docs/doc[@for="Activity.UnbindFromThread"]/*' />
        public void UnbindFromThread()
        {
            m_sat.UnbindFromThread();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\soapservervroot.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.Reflection.Emit;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Text;
    using System.IO;
    using System.Collections;
    using System.DirectoryServices;
    using System.Runtime.Remoting;
    using System.EnterpriseServices.Admin;
    using System.Security.Permissions;
   
    /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="ISoapServerVRoot"]/*' />
    [Guid("A31B6577-71D2-4344-AEDF-ADC1B0DC5347")]
    public interface ISoapServerVRoot
    {
        /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="ISoapServerVRoot.CreateVirtualRootEx"]/*' />
        [DispId(0x00000001)]
        void CreateVirtualRootEx(
            [MarshalAs(UnmanagedType.BStr)] string rootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string inBaseUrl,
            [MarshalAs(UnmanagedType.BStr)] string inVirtualRoot,
            [MarshalAs(UnmanagedType.BStr)] string homePage, 
            [MarshalAs(UnmanagedType.BStr)] string discoFile, 
            [MarshalAs(UnmanagedType.BStr)] string secureSockets, 
            [MarshalAs(UnmanagedType.BStr)] string authentication, 
            [MarshalAs(UnmanagedType.BStr)] string operation,
            [MarshalAs(UnmanagedType.BStr)] out string baseUrl,
            [MarshalAs(UnmanagedType.BStr)] out string virtualRoot,
            [MarshalAs(UnmanagedType.BStr)] out string physicalPath
            );

        /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="ISoapServerVRoot.DeleteVirtualRootEx"]/*' />
        [DispId(0x00000002)]
        void DeleteVirtualRootEx(
            [MarshalAs(UnmanagedType.BStr)] string rootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string baseUrl,
            [MarshalAs(UnmanagedType.BStr)] string virtualRoot
            );

        /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="ISoapServerVRoot.GetVirtualRootStatus"]/*' />
        [DispId(0x00000003)]
        void GetVirtualRootStatus(
            [MarshalAs(UnmanagedType.BStr)] string rootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string inBaseUrl,
            [MarshalAs(UnmanagedType.BStr)] string inVirtualRoot,
            [MarshalAs(UnmanagedType.BStr)] out string exists, 
            [MarshalAs(UnmanagedType.BStr)] out string secureSockets, 
            [MarshalAs(UnmanagedType.BStr)] out string windowsAuth, 
            [MarshalAs(UnmanagedType.BStr)] out string anonymous, 
            [MarshalAs(UnmanagedType.BStr)] out string homePage, 
            [MarshalAs(UnmanagedType.BStr)] out string discoFile, 
            [MarshalAs(UnmanagedType.BStr)] out string physicalPath, 
            [MarshalAs(UnmanagedType.BStr)] out string baseUrl, 
            [MarshalAs(UnmanagedType.BStr)] out string virtualRoot 
            );

     }

    /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="SoapServerVRoot"]/*' />
    [Guid("CAA817CC-0C04-4d22-A05C-2B7E162F4E8F")]
    public sealed class SoapServerVRoot: ISoapServerVRoot
    {
        /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="SoapServerVRoot.CreateVirtualRootEx"]/*' />
        public void CreateVirtualRootEx(
            string rootWebServer,
            string inBaseUrl,
            string inVirtualRoot,
            string homePage, 
            string discoFile, 
            string secureSockets, 
            string authentication, 
            string operation,
            out string baseUrl,
            out string virtualRoot,
            out string physicalPath
            )
        {
            // if Operation if an empty string, the VRoot will be published
            baseUrl = "";
            virtualRoot = "";
            physicalPath = "";
            bool bSSL         = true;
            bool bWindowsAuth = true;
            bool bAnonymous   = false;
            bool bDiscoFile   = false;
            bool bHomePage    = false;
            bool bImpersonate = true;
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                Platform.Assert(Platform.Whistler, "SoapServerVRoot.CreateVirtualRootEx");
                if (inBaseUrl.Length <= 0 && inVirtualRoot.Length <= 0 ) return;
                string rootWeb = "IIS://localhost/W3SVC/1/ROOT";
                if (rootWebServer.Length > 0) rootWeb = rootWebServer;
                if (authentication.ToLower(CultureInfo.InvariantCulture) == "anonymous")
                {
                    bAnonymous   = true;
                    bWindowsAuth = false;
                    bImpersonate = false;
                }
                bDiscoFile = SoapServerInfo.BoolFromString(discoFile, bDiscoFile);
                bHomePage  = SoapServerInfo.BoolFromString(homePage,  bHomePage );
                bSSL       = SoapServerInfo.BoolFromString(secureSockets,       bSSL      );
                string protocol = "https";
                if (!bSSL) protocol = "http";
                SoapServerInfo.ParseUrl(inBaseUrl, inVirtualRoot, protocol, out baseUrl, out virtualRoot);
                physicalPath = SoapServerInfo.ServerPhysicalPath(rootWeb, inBaseUrl, inVirtualRoot, true);
                SoapServerConfig.Create(physicalPath, bImpersonate, bWindowsAuth);
                if (bDiscoFile)
                {
                    DiscoFile webDisco = new DiscoFile();
                    webDisco.Create(physicalPath, "Default.disco");
                }
                else
                {
                    if (File.Exists(physicalPath + "\\Default.disco"))
                    {
                        File.Delete(physicalPath + "\\Default.disco");
                    }
                }
                if (bHomePage)
                {
                    HomePage webPage = new HomePage();
                    string discoFileName = "";
                    if (bDiscoFile) discoFileName = "Default.disco";
                    webPage.Create(physicalPath, virtualRoot, "Default.aspx", discoFileName);
                }
                else
                {
                    if (File.Exists(physicalPath + "\\Default.aspx"))
                    {
                        File.Delete(physicalPath + "\\Default.aspx");
                    }
                }
                IISVirtualRootEx.CreateOrModify(rootWeb, physicalPath, virtualRoot, bSSL, bWindowsAuth, bAnonymous, bHomePage);
            }
            catch
            {
                string etxt = Resource.FormatString("Soap_VRootCreationFailed");
                ComSoapPublishError.Report(etxt + " " + virtualRoot);
                throw;
            }
        }

        /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="SoapServerVRoot.DeleteVirtualRootEx"]/*' />
        public void DeleteVirtualRootEx(
            string rootWebServer,
            string inBaseUrl,
            string inVirtualRoot
            )
        {
            try
            {
                // set default root web server if the caller has not
                try
                {
                    SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                    sp.Demand();
                }
                catch(Exception e)
                {
                    if (e.GetType() == typeof(System.Security.SecurityException))
                    {
                        string Error = Resource.FormatString("Soap_SecurityFailure");
                        ComSoapPublishError.Report(Error);
                    }
                    throw;
                }

                Platform.Assert(Platform.Whistler, "SoapServerVRoot.DeleteVirtualRootEx");
                if (inBaseUrl.Length <= 0 && inVirtualRoot.Length <= 0) return;
                string rootWeb = "IIS://localhost/W3SVC/1/ROOT";
                if (rootWebServer.Length > 0) rootWeb = rootWebServer;
                string Protocol = ""; //doesn't matter in delete case
                string BaseUrl = "";
                string VirtualRoot = "";
                SoapServerInfo.ParseUrl(inBaseUrl, inVirtualRoot, Protocol, out BaseUrl, out VirtualRoot);
                // to preserve RTM behavior, the following line is commented out
                // to actually remove a vroot, uncomment the following line
                //IISVirtualRootEx.Delete(rootWeb, VirtualRoot);
            }
            catch
            {
                string Error = Resource.FormatString("Soap_VRootDirectoryDeletionFailed");
                ComSoapPublishError.Report(Error);
                throw;
            }
        }

        /// <include file='doc\SoapServerVroot.uex' path='docs/doc[@for="SoapServerVRoot.GetVirtualRootStatus"]/*' />
        public void GetVirtualRootStatus(
            string RootWebServer,
            string inBaseUrl,
            string inVirtualRoot,
            out string Exists,
            out string SSL, 
            out string WindowsAuth,
            out string Anonymous,
            out string HomePage, 
            out string DiscoFile, 
            out string PhysicalPath,
            out string BaseUrl,
            out string VirtualRoot
            )
        {
            string rootWeb = "IIS://localhost/W3SVC/1/ROOT";
            if (RootWebServer.Length > 0) rootWeb = RootWebServer;
            Exists      = "false";
            SSL         = "false";
            WindowsAuth = "false";
            Anonymous   = "false";
            HomePage    = "false";
            DiscoFile   = "false";
            SoapServerInfo.ParseUrl(inBaseUrl, inVirtualRoot, "http", out BaseUrl, out VirtualRoot);
            PhysicalPath = SoapServerInfo.ServerPhysicalPath(rootWeb, BaseUrl, VirtualRoot, false);
            bool bExists      = false;
            bool bSSL         = false;
            bool bWindowsAuth = false;
            bool bAnonymous   = false;
            bool bHomePage    = false;
            bool bDiscoFile   = false;
            IISVirtualRootEx.GetStatus(
                rootWeb, 
                PhysicalPath, 
                VirtualRoot,
                out bExists, 
                out bSSL, 
                out bWindowsAuth, 
                out bAnonymous, 
                out bHomePage,
                out bDiscoFile
                );
            if (bExists)      Exists      = "true";
            if (bSSL) 
            {
                SSL         = "true"; 
                SoapServerInfo.ParseUrl(inBaseUrl, inVirtualRoot, "https", out BaseUrl, out VirtualRoot);
            }
            if (bWindowsAuth) WindowsAuth = "true";
            if (bAnonymous)   Anonymous   = "true";
            if (bHomePage)    HomePage    = "true";
            if (bDiscoFile)   DiscoFile   = "true";
         }
    }

    internal class IISVirtualRootEx 
    {

        const uint MD_ACCESS_SSL          = 0x00000008; //SSL permissions required.
        const uint MD_AUTH_ANONYMOUS      = 0x00000001; //Anonymous authentication available.
        const uint MD_AUTH_NT             = 0x00000004; //Windows authentication schemes available.
        const uint MD_DIRBROW_NONE        = 0x00000000; //DirBrowse disabled
        const uint MD_DIRBROW_LOADDEFAULT = 0x4000001E; //default settings for DirBrowse
        const uint MD_ACCESS_READ         = 0x00000001; //Allow read access.
        const uint MD_ACCESS_SCRIPT       = 0x00000200; //Allow script execution.
        const int  POOLED                 = 2; //IIS application isolation level

        // this helper routine checks for the existence of the specified virtual directory
        internal static bool CheckIfExists(string rootWeb, string virtualDirectory)
        {
            DirectoryEntry parent = new DirectoryEntry(rootWeb + "/" + virtualDirectory);
            try
            {
                string s = parent.Name;
            }

            catch
            {
                // assume a failure here means the VD does not exist
                return false;
            }

            return true;
        }

        internal static void GetStatus(
            string RootWeb, 
            string PhysicalPath, 
            string VirtualDirectory,
            out bool bExists,
            out bool bSSL,
            out bool bWindowsAuth,
            out bool bAnonymous, 
            out bool bHomePage,
            out bool bDiscoFile
            )
        {
            bSSL         = false;
            bWindowsAuth = false;
            bAnonymous   = false;
            bHomePage    = false;
            bDiscoFile   = false;
            //check for existence of vroot
            bExists = CheckIfExists(RootWeb, VirtualDirectory);
            if (!bExists) return;
            DirectoryEntry parent = new DirectoryEntry(RootWeb);
            if (null == parent) return;
            DirectoryEntry child = parent.Children.Find(VirtualDirectory,  "IIsWebVirtualDir");
            if (null == child) return;
            //check for SSL enabled
            UInt32 uiSSL = UInt32.Parse(child.Properties["AccessSSLFlags"][0].ToString());
            if ((uiSSL & MD_ACCESS_SSL) > 0) bSSL = true;
            //check auth flags
            UInt32 authflags = UInt32.Parse(child.Properties["AuthFlags"][0].ToString());
            if ((authflags & MD_AUTH_ANONYMOUS) > 0) bAnonymous = true;
            if ((authflags & MD_AUTH_NT) > 0)        bWindowsAuth = true;
            //check whether home page is enabled
            bHomePage = (bool)child.Properties["EnableDefaultDoc"][0];
            //check if a disco file exists
            if (File.Exists(PhysicalPath + "\\default.disco")) bDiscoFile = true;
        }

        /// <summary>
        /// Creates an IIS 6.0 Virtual Root
        /// </summary>
        internal static void CreateOrModify(
            string rootWeb, 
            string inPhysicalDirectory, 
            string virtualDirectory,
            bool secureSockets,
            bool windowsAuth,
            bool anonymous, 
            bool homePage
            )
        {
            string PhysicalDirectory = inPhysicalDirectory; 
            while (PhysicalDirectory.EndsWith("/") || PhysicalDirectory.EndsWith("\\"))
            {
                PhysicalDirectory = PhysicalDirectory.Remove(PhysicalDirectory.Length-1, 1);
            }
            bool bExists = CheckIfExists(rootWeb, virtualDirectory);

            DirectoryEntry parent = new DirectoryEntry(rootWeb);
            DirectoryEntry child = null;
            if (bExists)
            {
                child = parent.Children.Find(virtualDirectory,  "IIsWebVirtualDir");
            }
            else
            {
                child = parent.Children.Add(virtualDirectory, "IIsWebVirtualDir");
            }
            if (child == null)
            {
                throw new ServicedComponentException(Resource.FormatString("Soap_VRootCreationFailed"));
            }
            child.CommitChanges();

            child.Properties["Path"][0]= PhysicalDirectory;
            if (secureSockets) // do not downgrade security - do not change this except to increase
            {
                UInt32 uiSSL = UInt32.Parse(child.Properties["AccessSSLFlags"][0].ToString());
                uiSSL |= MD_ACCESS_SSL;
                child.Properties["AccessSSLFlags"][0] = uiSSL;
            }
            //definitions from IIS Metadata definitions
            UInt32 authflags = UInt32.Parse(child.Properties["AuthFlags"][0].ToString());
            if (!bExists && anonymous) authflags |= MD_AUTH_ANONYMOUS;
            if (windowsAuth) authflags = MD_AUTH_NT;
            child.Properties["AuthFlags"][0]= authflags;
            child.Properties["EnableDefaultDoc"][0]= homePage;
            if (secureSockets && windowsAuth && !anonymous) // if locked down, no info about vroot
            {
                child.Properties["DirBrowseFlags"][0]= MD_DIRBROW_NONE;
            }
            else //IIS default information about vroot - only on new vroot
            {
                if (!bExists) child.Properties["DirBrowseFlags"][0]= MD_DIRBROW_LOADDEFAULT;
            }
            child.Properties["AccessFlags"][0]= MD_ACCESS_READ | MD_ACCESS_SCRIPT;
            child.Properties["AppFriendlyName"][0] = virtualDirectory;
            child.CommitChanges();

            // Now configure it to be "pooled" application isolation level

            object[] args = new object[1];
            args[0] = POOLED;
            child.Invoke("AppCreate2", args);
        }

        /// <summary>
        /// Deletes an IIS 6.0 Virtual Root
        /// </summary>
        internal static void Delete(
            string rootWeb, 
            string virtualDirectory
            )
        {
            // if it doesn't exist, this routine just returns with no error


            if (CheckIfExists(rootWeb, virtualDirectory) != true)	// check if there's anything to delete in the first place
            {
                return;
            }

            DirectoryEntry parent = new DirectoryEntry(rootWeb);
            DirectoryEntry child = new DirectoryEntry(rootWeb + "/" + virtualDirectory);

            // delete the associated application (COM+ apps, etc.)
            child.Invoke("AppDelete", null);

            // delete the actual v-dir
            object[] pargs = new object[2];
            pargs[0] = "IIsWebVirtualDir";
            pargs[1] = virtualDirectory;
            parent.Invoke("Delete", pargs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\soapservertlb.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

namespace System.EnterpriseServices.Internal
{
    using System;
    using System.Reflection;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Net;
    using System.Text;
    using System.IO;
    using System.Collections;
    using System.Runtime.Remoting;
    using System.EnterpriseServices.Admin;
    using System.Security.Permissions;
    using System.Security.Policy;
   
    /// <include file='doc\SoapServerTlb.uex' path='docs/doc[@for="ISoapServerTlb"]/*' />
    [Guid("1E7BA9F7-21DB-4482-929E-21BDE2DFE51C")]
    public interface ISoapServerTlb
    {
        /// <include file='doc\SoapServerTlb.uex' path='docs/doc[@for="ISoapServerTlb.AddServerTlb"]/*' />
        [DispId(0x00000001)]void AddServerTlb(
            [MarshalAs(UnmanagedType.BStr)] string progId,
            [MarshalAs(UnmanagedType.BStr)] string classId,
            [MarshalAs(UnmanagedType.BStr)] string interfaceId,
            [MarshalAs(UnmanagedType.BStr)] string srcTlbPath,
            [MarshalAs(UnmanagedType.BStr)] string rootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string baseUrl,
            [MarshalAs(UnmanagedType.BStr)] string virtualRoot,
            [MarshalAs(UnmanagedType.BStr)] string clientActivated, 
            [MarshalAs(UnmanagedType.BStr)] string wellKnown, 
            [MarshalAs(UnmanagedType.BStr)] string discoFile, 
            [MarshalAs(UnmanagedType.BStr)] string operation,
            [MarshalAs(UnmanagedType.BStr)] out string assemblyName,
            [MarshalAs(UnmanagedType.BStr)] out string typeName
            );

        /// <include file='doc\SoapServerTlb.uex' path='docs/doc[@for="ISoapServerTlb.DeleteServerTlb"]/*' />
        [DispId(0x00000002)]void DeleteServerTlb(
            [MarshalAs(UnmanagedType.BStr)] string progId,
            [MarshalAs(UnmanagedType.BStr)] string classId,
            [MarshalAs(UnmanagedType.BStr)] string interfaceId,
            [MarshalAs(UnmanagedType.BStr)] string srcTlbPath,
            [MarshalAs(UnmanagedType.BStr)] string rootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string baseUrl,
            [MarshalAs(UnmanagedType.BStr)] string virtualRoot,
            [MarshalAs(UnmanagedType.BStr)] string operation,
            [MarshalAs(UnmanagedType.BStr)] string assemblyName,
            [MarshalAs(UnmanagedType.BStr)] string typeName
            );
    }
    
    /// <include file='doc\SoapServerTlb.uex' path='docs/doc[@for="SoapServerTlb"]/*' />
    [Guid("F6B6768F-F99E-4152-8ED2-0412F78517FB")]
    public sealed class SoapServerTlb: ISoapServerTlb
    {
        /// <include file='doc\SoapServerTlb.uex' path='docs/doc[@for="SoapServerTlb.AddServerTlb"]/*' />
        public void AddServerTlb(
            string progId, 
            string classId,
            string interfaceId,
            string srcTlbPath, 
            string rootWebServer,
            string inBaseUrl, 
            string inVirtualRoot,
            string clientActivated, 
            string wellKnown, 
            string discoFile, 
            string operation, 
            out string strAssemblyName, 
            out string typeName
            )
        {
            strAssemblyName = "";
            typeName = "";
            bool bDelete          = false;
            //these are the defaults for these flags
            bool bDiscoFile       = false;
            bool bWellKnown       = false;
            bool bClientActivated = true;
            try
            {
                try
                {
                    SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                    sp.Demand();
                }
                catch(Exception e)
                {
                    if (e.GetType() == typeof(System.Security.SecurityException))
                    {
                        string Error = Resource.FormatString("Soap_SecurityFailure");
                        ComSoapPublishError.Report(Error);
                    }
                    throw;
                }
                Platform.Assert(Platform.Whistler, "SoapServerTlb.AddServerTlb");

                if (null != operation && operation.ToLower(CultureInfo.InvariantCulture) == "delete") bDelete = true;
                //if ProgId is an empty string, it means it does not go in the configuration file
                if (srcTlbPath.Length <= 0) return;
                bDiscoFile       = SoapServerInfo.BoolFromString(discoFile, bDiscoFile);
                bWellKnown       = SoapServerInfo.BoolFromString(wellKnown, bWellKnown);
                bClientActivated = SoapServerInfo.BoolFromString(clientActivated, bClientActivated);
                string PhysicalPath = SoapServerInfo.ServerPhysicalPath(rootWebServer, inBaseUrl, inVirtualRoot, !bDelete);
                string srcdll = srcTlbPath.ToLower(CultureInfo.InvariantCulture);
                if ( srcdll.EndsWith("mscoree.dll") )
                {
                    Type typ = Type.GetTypeFromProgID(progId);
                    typeName = typ.FullName;
                    Assembly assem = typ.Assembly;
                    AssemblyName assemname = assem.GetName();
                    strAssemblyName = assemname.Name;
                }
                else if  ( srcdll.EndsWith("scrobj.dll") )
                {
                    if (!bDelete)
                    {
                        throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_WSCNotSupported"));
                    }
                }
                else
                {
                    string Error = "";
                    GenerateMetadata metaGen = new GenerateMetadata();
                    if (bDelete) strAssemblyName = metaGen.GetAssemblyName(srcTlbPath, PhysicalPath + "\\bin\\");
                    else strAssemblyName = metaGen.GenerateSigned(srcTlbPath, PhysicalPath + "\\bin\\", false, out Error);
                    if (strAssemblyName.Length > 0)
                    {
                        try
                        {
                            //TODO - review GetTypeNameFromProgId to determine if we can use the IID
                            // to simplify the logic
                            typeName = GetTypeName(PhysicalPath + "\\bin\\" + strAssemblyName + ".dll", progId, classId);
                        }
                        catch(Exception e)
                        {
                            if (bDelete && e.GetType() != typeof(System.IO.DirectoryNotFoundException) &&
                                e.GetType() != typeof(System.IO.FileNotFoundException))
                            {
                                throw;
                            }
                        }
                    }
                }
                // pull the generated Assembly.Type from the assembly for configuration files
                if (progId.Length > 0 && strAssemblyName.Length > 0 && typeName.Length > 0)
                {
                    // write to the server configuration files
                    DiscoFile objDiscoFile = new DiscoFile();
                    string strFileName = PhysicalPath + "\\bin\\" + strAssemblyName + ".dll";
                    if (bDelete)
                    {
                        SoapServerConfig.DeleteComponent(PhysicalPath + "\\Web.Config", strAssemblyName, typeName, progId, strFileName);
                        objDiscoFile.DeleteElement(PhysicalPath + "\\Default.disco", progId + ".soap?WSDL");
                        // we have no way of telling from a single component what other components are in this type library
                        // metadata assembly.  If we remove from GAC or delete we kill all the other components simultaneously
                        //GacRemove(strFileName);
                        //File.Delete(strFileName);
                    }
                    else
                    {
                        SoapServerConfig.AddComponent(PhysicalPath + "\\Web.Config", strAssemblyName, typeName, progId, strFileName, "SingleCall", bWellKnown, bClientActivated);
                        if (bDiscoFile)
                        {
                            objDiscoFile.AddElement(PhysicalPath + "\\Default.disco", progId + ".soap?WSDL");
                        }
                    }
                }
            }
            catch(Exception e)
            {
                string Error = Resource.FormatString("Soap_PublishServerTlbFailure");
                ComSoapPublishError.Report(Error);
                if ( typeof(ServicedComponentException) == e.GetType() || typeof(RegistrationException) == e.GetType() )
                {
                    throw;
                }
            }
        }
        
        /// <include file='doc\SoapServerTlb.uex' path='docs/doc[@for="SoapServerTlb.DeleteServerTlb"]/*' />
        public void DeleteServerTlb(
            string progId,
            string classId,
            string interfaceId,
            string srcTlbPath, 
            string rootWebServer,
            string baseUrl,
            string virtualRoot,
            string operation,
            string assemblyName,
            string typeName
            )
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
            }
            catch(Exception e)
            {
                if (e.GetType() == typeof(System.Security.SecurityException))
                {
                    string Error = Resource.FormatString("Soap_SecurityFailure");
                    ComSoapPublishError.Report(Error);
                }
                throw;
            }
            Platform.Assert(Platform.Whistler, "SoapServerTlb.DeleteServerTlb");

            string strAssemblyName = assemblyName;
            if (progId.Length <= 0 && classId.Length <= 0 && assemblyName.Length <= 0 && typeName.Length <= 0) return;
            if (baseUrl.Length <= 0 && virtualRoot.Length <= 0) return;
            string PhysicalPath = SoapServerInfo.ServerPhysicalPath(rootWebServer, baseUrl, virtualRoot, false);
            string srcdll = srcTlbPath.ToLower(CultureInfo.InvariantCulture);
            if ( srcdll.EndsWith("scrobj.dll") ) return; //not supported, nothing to do
            if ( srcdll.EndsWith("mscoree.dll") )
            {
                Type typ = Type.GetTypeFromProgID(progId);
                typeName = typ.FullName;
                Assembly assem = typ.Assembly;
                AssemblyName assemname = assem.GetName();
                strAssemblyName = assemname.Name;
            }
            else
            {
                GenerateMetadata metaGen = new GenerateMetadata();
                strAssemblyName = metaGen.GetAssemblyName(srcTlbPath, PhysicalPath + "\\bin\\");
                if (strAssemblyName.Length > 0)
                {
                    try
                    {
                        //TODO - review GetTypeNameFromProgId to determine if we can use the IID
                        // to simplify the logic
                        typeName = GetTypeName(PhysicalPath + "\\bin\\" + strAssemblyName + ".dll", progId, classId);
                    }
                    catch(Exception e)
                    {
                        if (e.GetType() != typeof(System.IO.DirectoryNotFoundException) &&
                            e.GetType() != typeof(System.IO.FileNotFoundException))
                        {
                            throw;
                        }
                    }
                }
            }
            // pull the generated Assembly.Type from the assembly for configuration files
            if (progId.Length > 0 && strAssemblyName.Length > 0 && typeName.Length > 0)
            {
                // write to the server configuration files
                DiscoFile discoFile = new DiscoFile();
                string strFileName = PhysicalPath + "\\bin\\" + strAssemblyName + ".dll";
                SoapServerConfig.DeleteComponent(PhysicalPath + "\\Web.Config", strAssemblyName, typeName, progId, strFileName);
                discoFile.DeleteElement(PhysicalPath + "\\Default.disco", progId + ".soap?WSDL");
                // we have no way of telling from a single component what other components are in this type library
                // metadata assembly.  If we remove from GAC or delete we kill all the other components simultaneously
                //GacRemove(strFileName);
                //File.Delete(strFileName);
            }
        }

        internal string GetTypeName(string assemblyPath, string progId, string classId)
        {
            string retVal = "";
            AssemblyManager manager = null;
            AppDomain domain = AppDomain.CreateDomain("SoapDomain");
            if (null != domain)
            {
                AssemblyName n = typeof(AssemblyManager).Assembly.GetName();    
                Evidence baseEvidence = AppDomain.CurrentDomain.Evidence;
                Evidence evidence = new Evidence(baseEvidence);
                evidence.AddAssembly(n);
                ObjectHandle h = domain.CreateInstance(n.FullName, 
                                                       typeof(AssemblyManager).FullName,
                                                       false, 
                                                       0, 
                                                       null, 
                                                       null, 
                                                       null, 
                                                       null, 
                                                       evidence);
                if (null != h)
                {
                    manager = (AssemblyManager)h.Unwrap();
                    if (classId.Length > 0)
                    {
                        retVal = manager.InternalGetTypeNameFromClassId(assemblyPath, classId);
                    }
                    else
                    {
                        retVal = manager.InternalGetTypeNameFromProgId(assemblyPath, progId);
                    }
                }
                AppDomain.Unload(domain);
            }
            return retVal;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "System.EnterpriseServices.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Services Support Infrastructure\0"
#define VER_ORIGFILENAME_STR    "System.EnterpriseServices.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\serverpublish.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System.EnterpriseServices.Internal
{
    using System;
    using System.Reflection;
    using System.Reflection.Emit;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Net;
    using System.Text;
    using System.IO;
    using System.Collections;
    using System.DirectoryServices;
    using System.Diagnostics;
    using System.Runtime.Remoting;
    using System.EnterpriseServices.Admin;
    using System.Xml;
    using System.Xml.XPath;
    using System.Security.Permissions;
    using System.Globalization;
    
    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher"]/*' />
    [Guid("d8013eee-730b-45e2-ba24-874b7242c425")]
    public interface IComSoapPublisher
    {
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.CreateVirtualRoot"]/*' />
        [DispId(0x00000004)]void CreateVirtualRoot(
            [MarshalAs(UnmanagedType.BStr)] string Operation,
            [MarshalAs(UnmanagedType.BStr)] string FullUrl,
            [MarshalAs(UnmanagedType.BStr)] out string BaseUrl,
            [MarshalAs(UnmanagedType.BStr)] out string VirtualRoot,
            [MarshalAs(UnmanagedType.BStr)] out string PhysicalPath,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.DeleteVirtualRoot"]/*' />
        [DispId(0x00000005)]void DeleteVirtualRoot(
            [MarshalAs(UnmanagedType.BStr)] string RootWebServer,
            [MarshalAs(UnmanagedType.BStr)] string FullUrl,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.CreateMailBox"]/*' />
        [DispId(0x00000006)]void CreateMailBox(
            [MarshalAs(UnmanagedType.BStr)] string RootMailServer,
            [MarshalAs(UnmanagedType.BStr)] string MailBox,
            [MarshalAs(UnmanagedType.BStr)] out string SmtpName,
            [MarshalAs(UnmanagedType.BStr)] out string Domain,
            [MarshalAs(UnmanagedType.BStr)] out string PhysicalPath,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );
 
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.DeleteMailBox"]/*' />
        [DispId(0x00000007)]void DeleteMailBox(
            [MarshalAs(UnmanagedType.BStr)] string RootMailServer,
            [MarshalAs(UnmanagedType.BStr)] string MailBox,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.ProcessServerTlb"]/*' />
        [DispId(0x00000008)]void ProcessServerTlb(
            [MarshalAs(UnmanagedType.BStr)] string ProgId,
            [MarshalAs(UnmanagedType.BStr)] string SrcTlbPath,
            [MarshalAs(UnmanagedType.BStr)] string PhysicalPath,
            [MarshalAs(UnmanagedType.BStr)] string Operation,
            [MarshalAs(UnmanagedType.BStr)] out string AssemblyName,
            [MarshalAs(UnmanagedType.BStr)] out string TypeName,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );

       /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.ProcessClientTlb"]/*' />
       [DispId(0x00000009)]void ProcessClientTlb(
            [MarshalAs(UnmanagedType.BStr)] string ProgId,
            [MarshalAs(UnmanagedType.BStr)] string SrcTlbPath,
            [MarshalAs(UnmanagedType.BStr)] string PhysicalPath,
            [MarshalAs(UnmanagedType.BStr)] string VRoot,
            [MarshalAs(UnmanagedType.BStr)] string BaseUrl,
            [MarshalAs(UnmanagedType.BStr)] string Mode,
            [MarshalAs(UnmanagedType.BStr)] string Transport,
            [MarshalAs(UnmanagedType.BStr)] out string AssemblyName,
            [MarshalAs(UnmanagedType.BStr)] out string TypeName,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );

            //TODO: pull this interface definition
            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.GetTypeNameFromProgId"]/*' />
            [DispId(0x0000000A)]
            [return : MarshalAs(UnmanagedType.BStr)]
            string GetTypeNameFromProgId(
                [MarshalAs(UnmanagedType.BStr)] string AssemblyPath, 
                [MarshalAs(UnmanagedType.BStr)] string ProgId
                );

            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.RegisterAssembly"]/*' />
            [DispId(0x0000000B)]
            void RegisterAssembly(
                [MarshalAs(UnmanagedType.BStr)] string AssemblyPath
                );

            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.UnRegisterAssembly"]/*' />
            [DispId(0x0000000C)]
            void UnRegisterAssembly(
                [MarshalAs(UnmanagedType.BStr)] string AssemblyPath
                );

            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.GacInstall"]/*' />
            [DispId(0x0000000D)]
            void GacInstall(
                [MarshalAs(UnmanagedType.BStr)] string AssemblyPath
                );
            
            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.GacRemove"]/*' />
            [DispId(0x0000000E)]
            void GacRemove(
                [MarshalAs(UnmanagedType.BStr)] string AssemblyPath
                );

            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapPublisher.GetAssemblyNameForCache"]/*' />
            [DispId(0x0000000F)]void GetAssemblyNameForCache(
                [MarshalAs(UnmanagedType.BStr)] String TypeLibPath,
                [MarshalAs(UnmanagedType.BStr)] out String CachePath
                ); 
            
            
      }

    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapIISVRoot"]/*' />
    /// <internalonly/>
    [Guid("d8013ef0-730b-45e2-ba24-874b7242c425")]
    public interface IComSoapIISVRoot
    {
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapIISVRoot.Create"]/*' />
        /// <internalonly/>
        [DispId(0x00000001)] void Create(
            [MarshalAs(UnmanagedType.BStr)] string RootWeb,
            [MarshalAs(UnmanagedType.BStr)] string PhysicalDirectory,
            [MarshalAs(UnmanagedType.BStr)] string VirtualDirectory,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapIISVRoot.Delete"]/*' />
        /// <internalonly/>
        [DispId(0x00000002)]void Delete(
            [MarshalAs(UnmanagedType.BStr)] string RootWeb,
            [MarshalAs(UnmanagedType.BStr)] string PhysicalDirectory,
            [MarshalAs(UnmanagedType.BStr)] string VirtualDirectory,
            [MarshalAs(UnmanagedType.BStr)] out string Error
            );
    }

    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapMetadata"]/*' />
    /// <internalonly/>
    [Guid("d8013ff0-730b-45e2-ba24-874b7242c425")]
    public interface IComSoapMetadata
    {
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapMetadata.Generate"]/*' />
        /// <internalonly/>
        [DispId(0x00000001)]
        [return : MarshalAs(UnmanagedType.BStr)]
        string Generate(
            [MarshalAs(UnmanagedType.BStr)] string SrcTypeLibFileName,
            [MarshalAs(UnmanagedType.BStr)] string OutPath
            );

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IComSoapMetadata.GenerateSigned"]/*' />
        /// <internalonly/>
        [DispId(0x00000002)]
        [return : MarshalAs(UnmanagedType.BStr)]
        string GenerateSigned(
           [MarshalAs(UnmanagedType.BStr)] string SrcTypeLibFileName,
           [MarshalAs(UnmanagedType.BStr)] string OutPath,
           [MarshalAs(UnmanagedType.Bool)] bool   InstallGac,
           [MarshalAs(UnmanagedType.BStr)] out string Error
           );
    }

    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IServerWebConfig"]/*' />
    /// <internalonly/>
    [Guid("6261e4b5-572a-4142-a2f9-1fe1a0c97097")]
    public interface IServerWebConfig
    {
         /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IServerWebConfig.AddElement"]/*' />
         /// <internalonly/>
         [DispId(0x00000001)]
         void AddElement(
            [MarshalAs(UnmanagedType.BStr)]string FilePath, 
            [MarshalAs(UnmanagedType.BStr)]string AssemblyName, 
            [MarshalAs(UnmanagedType.BStr)]string TypeName, 
            [MarshalAs(UnmanagedType.BStr)]string ProgId, 
            [MarshalAs(UnmanagedType.BStr)]string Mode, 
            [MarshalAs(UnmanagedType.BStr)]out string Error
            );   
    
         /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IServerWebConfig.Create"]/*' />
         /// <internalonly/>
         [DispId(0x00000002)]
         void Create(
            [MarshalAs(UnmanagedType.BStr)]string FilePath, 
            [MarshalAs(UnmanagedType.BStr)]string FileRootName, 
            [MarshalAs(UnmanagedType.BStr)]out string Error
            );   
    }

    [ComImport,InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("7c23ff90-33af-11d3-95da-00a024a85b51")]
    internal interface IApplicationContext
    {
        void SetContextNameObject(IAssemblyName pName);
        void GetContextNameObject(out IAssemblyName ppName);
        void Set([MarshalAs(UnmanagedType.LPWStr)] String szName, int pvValue, uint cbValue, uint dwFlags);
        void Get([MarshalAs(UnmanagedType.LPWStr)] String szName, out int pvValue, ref uint pcbValue, uint dwFlags);
        void GetDynamicDirectory(out int wzDynamicDir, ref uint pdwSize);
    }// IApplicationContext
    
    [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
    internal interface IAssemblyName
    {
        [PreserveSig()]
        int SetProperty(uint PropertyId, IntPtr pvProperty, uint cbProperty);
        [PreserveSig()]
        int GetProperty(uint PropertyId, IntPtr pvProperty, ref uint pcbProperty);
        [PreserveSig()]
        int Finalize();
        [PreserveSig()]
        int GetDisplayName(IntPtr szDisplayName, ref uint pccDisplayName, uint dwDisplayFlags);
        [PreserveSig()]
        int BindToObject(Object /*REFIID*/ refIID, 
                          Object /*IAssemblyBindSink*/ pAsmBindSink, 
                          IApplicationContext pApplicationContext,
                          [MarshalAs(UnmanagedType.LPWStr)] String szCodeBase,
                          Int64 llFlags,
                          int pvReserved,
                          uint cbReserved,
                          out int ppv);
        [PreserveSig()]
        int GetName(out uint lpcwBuffer, out int pwzName);
        [PreserveSig()]
        int GetVersion(out uint pdwVersionHi, out uint pdwVersionLow);
        [PreserveSig()]
        int IsEqual(IAssemblyName pName, uint dwCmpFlags);
        [PreserveSig()]
        int Clone(out IAssemblyName pName);
    }// IAssemblyName

    [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")]
    internal interface IAssemblyCacheItem
    {
        void CreateStream([MarshalAs(UnmanagedType.LPWStr)] String pszName,uint dwFormat, uint dwFlags, uint dwMaxSize, out UCOMIStream ppStream);
        void IsNameEqual(IAssemblyName pName);
        void Commit(uint dwFlags);
        void MarkAssemblyVisible(uint dwFlags);
    }// IAssemblyCacheItem

    [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("e707dcde-d1cd-11d2-bab9-00c04f8eceae")]
    internal interface IAssemblyCache
    {
        [PreserveSig()]
        int UninstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] String pszAssemblyName, IntPtr pvReserved, out uint pulDisposition);
        [PreserveSig()]
        int QueryAssemblyInfo(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] String pszAssemblyName, IntPtr pAsmInfo);
        [PreserveSig()]
        int CreateAssemblyCacheItem(uint dwFlags, IntPtr pvReserved, out IAssemblyCacheItem ppAsmItem, [MarshalAs(UnmanagedType.LPWStr)] String pszAssemblyName);
        [PreserveSig()]
        int CreateAssemblyScavenger(out Object ppAsmScavenger);
        [PreserveSig()]
        int InstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] String pszManifestFilePath, IntPtr pvReserved);
     }// IAssemblyCache

     [ComImport, InterfaceType(ComInterfaceType.InterfaceIsIUnknown), Guid("00020411-0000-0000-C000-000000000046")]
     internal interface ITypeLib2
     {            
        // ITypeLib methods
        int GetTypeInfoCount();    
        int GetTypeInfo(int index, out UCOMITypeInfo ti);
        int GetTypeInfoType(int index, out TYPEKIND tkind);
        int GetTypeInfoOfGuid(ref Guid guid, UCOMITypeInfo ti);
        int GetLibAttr(out TYPELIBATTR tlibattr);
        int GetTypeComp(out UCOMITypeComp tcomp);
        int GetDocumentation(int index, 
                             [MarshalAs(UnmanagedType.BStr)] out string name,
                             [MarshalAs(UnmanagedType.BStr)] out string docString,
                             out int helpContext,
                             [MarshalAs(UnmanagedType.BStr)] out string helpFile);
        int IsName([MarshalAs(UnmanagedType.LPWStr)] ref string nameBuf,
                   int hashVal,
                   out int isName);
        int FindName([MarshalAs(UnmanagedType.LPWStr)] ref string szNameBuf,
                     int hashVal,
                     [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.Interface, SizeParamIndex = 5)] out UCOMITypeInfo[] tis,
                     [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I4, SizeParamIndex = 5)] out int[] memIds,
                     ref short foundCount);

        void ReleaseTLibAttr(TYPELIBATTR libattr);
     
        // ITypeLib2 methods
        int GetCustData(ref Guid guid, out object value);

        int GetLibStatistics(out int uniqueNames, out int chUniqueNames);
    
        int GetDocumentation2(int index,
                              int lcid,
                              [MarshalAs(UnmanagedType.BStr)] out string helpString,
                              out int helpStringContext,
                              [MarshalAs(UnmanagedType.BStr)] string helpStringDll);

        int GetAllCustData(out IntPtr custdata);
    }

    [Serializable]
    internal enum REGKIND
    {
        REGKIND_DEFAULT         = 0,
        REGKIND_REGISTER        = 1,
        REGKIND_NONE            = 2
    }

    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="ComSoapPublishError"]/*' />
    /// <internalonly/>
    public class ComSoapPublishError
    {
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="ComSoapPublishError.Report"]/*' />
        /// <internalonly/>
        static public void Report(string s)
        {
              string title = Resource.FormatString("Soap_ComPlusSoapServices");
              EventLog.WriteEntry(title, s, EventLogEntryType.Warning);           
        }
    }
    
     /// <include file='doc\serverpublish.uex' path='docs/doc[@for="ClientRemotingConfig"]/*' />
     /// <internalonly/>
    public class ClientRemotingConfig 
    {
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="ClientRemotingConfig.Write"]/*' />
        /// <internalonly/>
        static public bool Write(string DestinationDirectory, string VRoot, string BaseUrl,
            string AssemblyName, string TypeName, string ProgId, string Mode, string Transport )
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                sp.Demand();
                string remotingcfg = "<configuration>\r\n";
                remotingcfg += indent + "<system.runtime.remoting>\r\n";
                remotingcfg += indent + indent + "<application>\r\n";
                string fullurl = BaseUrl;
                if (fullurl.Length > 0 && !fullurl.EndsWith("/")) fullurl += "/";
                fullurl += VRoot;
                remotingcfg += indent + indent + indent + "<client url=\"" + fullurl + "\">\r\n";
                if (Mode.Length <= 0 || "WELLKNOWNOBJECT" == Mode.ToUpper(CultureInfo.InvariantCulture))
                {
                    remotingcfg += indent + indent + indent + indent;
                    remotingcfg += "<wellknown type=\"" + TypeName + ", " + AssemblyName + "\" url=\"" + fullurl;
                    if (!fullurl.EndsWith("/")) remotingcfg += "/";
                    remotingcfg += ProgId + ".soap\" />\r\n";
                }
                else // default is client activated
                {
                    remotingcfg += indent + indent + indent + indent;
                    remotingcfg += "<activated type=\"" + TypeName + ", " + AssemblyName + "\"/>\r\n";
                }
                remotingcfg += indent + indent + indent + "</client>\r\n";
                remotingcfg += indent + indent + "</application>\r\n";
                remotingcfg += indent + "</system.runtime.remoting>\r\n";
                remotingcfg += "</configuration>\r\n";
                string cfgPath = DestinationDirectory;
                if (cfgPath.Length > 0 && !cfgPath.EndsWith("\\")) cfgPath += "\\";
                cfgPath += TypeName + ".config";
                if (File.Exists(cfgPath)) File.Delete(cfgPath);
                FileStream cfgFile = new FileStream(cfgPath, FileMode.Create);
                StreamWriter cfgStream = new StreamWriter(cfgFile);
                cfgStream.Write(remotingcfg);
                cfgStream.Close();
                cfgFile.Close();
                return true;
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                return false;         
            }

        }
        const string indent = "  ";
    }

    //create a default.aspx home page if necessary for disco file
    internal class HomePage
    {
             public void Create(string FilePath, string VirtualRoot, string PageName, string DiscoRef)
             {
                   try
                   {
                         if (!FilePath.EndsWith("/") && !FilePath.EndsWith("\\")) FilePath += "\\";
                         if (File.Exists(FilePath + PageName)) return;
                         SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                         sp.Demand();
                         string configFilePath = FilePath + "web.config";
                         string strPage = "<%@ Import Namespace=\"System.Collections\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.IO\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.Xml.Serialization\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.Xml\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.Xml.Schema\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.Web.Services.Description\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.Globalization\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.Resources\" %>\r\n";
                         strPage += "<%@ Import Namespace=\"System.Diagnostics\" %>\r\n";
                         strPage += "<html>\r\n";
                         strPage += "<script language=\"C#\" runat=\"server\">\r\n";
                         strPage += "    string soapNs = \"http://schemas.xmlsoap.org/soap/envelope/\";\r\n";
                         strPage += "    string soapEncNs = \"http://schemas.xmlsoap.org/soap/encoding/\";\r\n";
                         strPage += "    string urtNs = \"urn:schemas-microsoft-com:urt-types\";\r\n";
                         strPage += "    string wsdlNs = \"http://schemas.xmlsoap.org/wsdl/\";\r\n";
                         strPage += "    string VRoot = \"" + VirtualRoot + "\";\r\n";
                         strPage += "    string ServiceName() { return VRoot; }\r\n";
                         strPage += "\r\n";
                         strPage += "   XmlNode GetNextNamedSiblingNode(XmlNode inNode, string name)\r\n";
                         strPage += "    {\r\n";
                         strPage += "       if (inNode == null ) return inNode;\r\n";
                          strPage += "      if (inNode.Name == name) return inNode;\r\n";
                         strPage += "       XmlNode newNode = inNode.NextSibling;\r\n";
                         strPage += "       if (newNode == null) return newNode;\r\n";
                         strPage += "       if (newNode.Name == name ) return newNode;\r\n";
                         strPage += "       bool found = false;\r\n";
                         strPage += "       while (!found)\r\n";
                         strPage += "       {\r\n";
                         strPage += "           XmlNode oldNode = newNode;\r\n";
                         strPage += "           newNode = oldNode.NextSibling;\r\n";
                         strPage += "           if (null == newNode || newNode == oldNode)\r\n";
                         strPage += "           {\r\n";
                         strPage += "               newNode = null;\r\n";
                         strPage += "               break;\r\n";
                         strPage += "           }\r\n";
                         strPage += "           if (newNode.Name == name) found = true;\r\n";
                         strPage += "       }\r\n";
                         strPage += "       return newNode;\r\n";
                         strPage += "   }\r\n";
                         strPage +="\r\n";
                         strPage += "   string GetNodes()\r\n";
                         strPage += "   {\r\n";
                         strPage += "       string retval = \"\";\r\n";
                         strPage += "       XmlDocument configXml = new XmlDocument();\r\n";
                         strPage += "      configXml.Load(@\"" + configFilePath + "\");\r\n";
                         strPage += "       XmlNode node= configXml.DocumentElement;\r\n"; 
                         strPage += "        node = GetNextNamedSiblingNode(node,\"configuration\");\r\n";
                         strPage += "        node = GetNextNamedSiblingNode(node.FirstChild, \"system.runtime.remoting\");\r\n";
                         strPage += "        node = GetNextNamedSiblingNode(node.FirstChild, \"application\");\r\n";
                         strPage += "        node = GetNextNamedSiblingNode(node.FirstChild, \"service\");\r\n";
                         strPage += "        node = GetNextNamedSiblingNode(node.FirstChild, \"wellknown\");\r\n";
                         strPage += "       while (node != null)\r\n";
                         strPage += "       {\r\n";
                         strPage += "           XmlNode attribType = node.Attributes.GetNamedItem(\"objectUri\");\r\n";
                         strPage += "           retval += \"<a href=\" + attribType.Value + \"?WSDL>\" + attribType.Value +\"?WSDL</a><br><br>\";\r\n";
                         strPage += "           node = GetNextNamedSiblingNode(node.NextSibling, \"wellknown\");\r\n";
                         strPage += "       }\r\n";
                         strPage += "        return retval;\r\n";
                         strPage += "    }\r\n";
                         strPage += "\r\n";
                         strPage += "</script>\r\n";
                         strPage += "<title><% = ServiceName() %></title>\r\n";
                         strPage += "<head>\r\n";
                         strPage += "<link type='text/xml' rel='alternate' href='" + DiscoRef +"' />\r\n";  
                         strPage += "\r\n";
                         strPage += "   <style type=\"text/css\">\r\n";
                         strPage += " \r\n"; 
                         strPage += "       BODY { color: #000000; background-color: white; font-family: \"Verdana\"; margin-left: 0px; margin-top: 0px; }\r\n";
                         strPage += "       #content { margin-left: 30px; font-size: .70em; padding-bottom: 2em; }\r\n";
                         strPage += "       A:link { color: #336699; font-weight: bold; text-decoration: underline; }\r\n";
                         strPage += "       A:visited { color: #6699cc; font-weight: bold; text-decoration: underline; }\r\n";
                         strPage += "       A:active { color: #336699; font-weight: bold; text-decoration: underline; }\r\n";
                         strPage += "       A:hover { color: cc3300; font-weight: bold; text-decoration: underline; }\r\n";
                         strPage += "       P { color: #000000; margin-top: 0px; margin-bottom: 12px; font-family: \"Verdana\"; }\r\n";
                         strPage += "       pre { background-color: #e5e5cc; padding: 5px; font-family: \"Courier New\"; font-size: x-small; margin-top: -5px; border: 1px #f0f0e0 solid; }\r\n";
                         strPage += "       td { color: #000000; font-family: verdana; font-size: .7em; }\r\n";
                         strPage += "       h2 { font-size: 1.5em; font-weight: bold; margin-top: 25px; margin-bottom: 10px; border-top: 1px solid #003366; margin-left: -15px; color: #003366; }\r\n";
                         strPage += "       h3 { font-size: 1.1em; color: #000000; margin-left: -15px; margin-top: 10px; margin-bottom: 10px; }\r\n";
                         strPage += "       ul, ol { margin-top: 10px; margin-left: 20px; }\r\n";
                         strPage += "       li { margin-top: 10px; color: #000000; }\r\n";
                         strPage += "       font.value { color: darkblue; font: bold; }\r\n";
                         strPage += "       font.key { color: darkgreen; font: bold; }\r\n";
                         strPage += "       .heading1 { color: #ffffff; font-family: \"Tahoma\"; font-size: 26px; font-weight: normal; background-color: #003366; margin-top: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 10px; padding-bottom: 3px; padding-left: 15px; width: 105%; }\r\n";
                         strPage += "       .button { background-color: #dcdcdc; font-family: \"Verdana\"; font-size: 1em; border-top: #cccccc 1px solid; border-bottom: #666666 1px solid; border-left: #cccccc 1px solid; border-right: #666666 1px solid; }\r\n";
                         strPage += "       .frmheader { color: #000000; background: #dcdcdc; font-family: \"Verdana\"; font-size: .7em; font-weight: normal; border-bottom: 1px solid #dcdcdc; padding-top: 2px; padding-bottom: 2px; }\r\n";
                         strPage += "       .frmtext { font-family: \"Verdana\"; font-size: .7em; margin-top: 8px; margin-bottom: 0px; margin-left: 32px; }\r\n";
                         strPage += "       .frmInput { font-family: \"Verdana\"; font-size: 1em; }\r\n";
                         strPage += "       .intro { margin-left: -15px; }\r\n";
                         strPage += " \r\n";         
                         strPage += "    </style>\r\n";
                         strPage += "\r\n";
                         strPage += "</head>\r\n";
                         strPage += "<body>\r\n";
                         strPage += "<p class=\"heading1\"><% = ServiceName() %></p><br>\r\n";
                         strPage += "<% = GetNodes() %>\r\n";
                         strPage += "</body>\r\n";
                         strPage += "</html>\r\n";
                         FileStream PageFile = new FileStream(FilePath + PageName, FileMode.Create);
                         StreamWriter PageStream = new StreamWriter(PageFile);
                         PageStream.Write(strPage);
                         PageStream.Close();
                         PageFile.Close();
                   }
                   catch(Exception e)
                   {
                         ComSoapPublishError.Report(e.ToString());
                   }
            }
    }

    internal class DiscoFile
    {
       public void Create(string FilePath, string DiscoRef)
       {
         try
         {
            if (!FilePath.EndsWith("/") && !FilePath.EndsWith("\\")) FilePath += "\\";
            if ( File.Exists(FilePath + DiscoRef) ) return;
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
            sp.Demand();
            string strDisco = "<?xml version=\"1.0\" ?>\n";
            strDisco += "<discovery xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"http://schemas.xmlsoap.org/disco/\">\n";
            strDisco += "</discovery>\n";
            FileStream DiscoFile = new FileStream(FilePath + DiscoRef, FileMode.Create);
            StreamWriter DiscoStream = new StreamWriter(DiscoFile);
            DiscoStream.Write(strDisco);
            DiscoStream.Close();
            DiscoFile.Close();
         }
         catch(Exception e)
         {
            ComSoapPublishError.Report(e.ToString());
         }
       }

       internal void DeleteElement(string FilePath, string SoapPageRef)
       {
         try
         {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                sp.Demand();
                XmlDocument discoXml = new XmlDocument();
                discoXml.Load(FilePath);
                XmlNode node= discoXml.DocumentElement; //<discovery>
                while (node.Name != "discovery") node= node.NextSibling; 
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::ref='" + SoapPageRef + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                     XmlNode n = nodelist.Item(0);
                    {
                           if (n.ParentNode != null)
                           {
                                  n.ParentNode.RemoveChild(n);
                                  nodelist = node.SelectNodes("descendant::*[attribute::ref='" + SoapPageRef + "']");
                           }
                     }
                }
                nodelist = node.SelectNodes("descendant::*[attribute::address='" + SoapPageRef + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                     XmlNode n = nodelist.Item(0);
                     {
                           if (n.ParentNode != null)
                           {
                                  n.ParentNode.RemoveChild(n);
                                  nodelist = node.SelectNodes("descendant::*[attribute::address='" + SoapPageRef + "']");
                           }
                     }
                }
                discoXml.Save(FilePath);
         }
         // these exceptions are not reported because on a proxy uninstall these files will not be present, but the
         // the proxy bit is not set on deletions
         catch(System.IO.DirectoryNotFoundException) {}
         catch(System.IO.FileNotFoundException) {}
         catch(Exception e)
         {
                ComSoapPublishError.Report(e.ToString());
         }
       }

       public void AddElement(string FilePath, string SoapPageRef)
       {
         try
         {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                sp.Demand();
                XmlDocument discoXml = new XmlDocument();   
                discoXml.Load(FilePath);
                XmlNode node= discoXml.DocumentElement; //<discovery>
                while (node.Name != "discovery") node= node.NextSibling; 
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::ref='" + SoapPageRef + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                     XmlNode n = nodelist.Item(0);
                    {
                           if (n.ParentNode != null)
                           {
                                  n.ParentNode.RemoveChild(n);
                                  nodelist = node.SelectNodes("descendant::*[attribute::ref='" + SoapPageRef + "']");
                           }
                     }
                }
                nodelist = node.SelectNodes("descendant::*[attribute::address='" + SoapPageRef + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                     XmlNode n = nodelist.Item(0);
                     {
                           if (n.ParentNode != null)
                           {
                                  n.ParentNode.RemoveChild(n);
                                  nodelist = node.SelectNodes("descendant::*[attribute::address='" + SoapPageRef + "']");
                           }
                     }
                }
                XmlElement cRefElement = discoXml.CreateElement("","contractRef", "");
                cRefElement.SetAttribute("ref", SoapPageRef);
                cRefElement.SetAttribute("docRef", SoapPageRef);
                cRefElement.SetAttribute("xmlns", "http://schemas.xmlsoap.org/disco/scl/");
                node.AppendChild(cRefElement);
                XmlElement soapElement = discoXml.CreateElement("", "soap", ""); 
                soapElement.SetAttribute("address", SoapPageRef);
                soapElement.SetAttribute("xmlns", "http://schemas.xmlsoap.org/disco/soap/");
                node.AppendChild(soapElement);
                discoXml.Save(FilePath);
         }
         catch(Exception e)
         {
                ComSoapPublishError.Report(e.ToString());           
         }
       }
    }

    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="ServerWebConfig"]/*' />
    /// <internalonly/>
    public class ServerWebConfig : IServerWebConfig
    {
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="ServerWebConfig.Create"]/*' />
        /// <internalonly/>
        public void Create(
            string FilePath,
            string FilePrefix,
            out string Error)
        {
            Error = "";
            try
            {
                 SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                 sp.Demand();
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                throw;
            }

            if (!FilePath.EndsWith("/") && !FilePath.EndsWith("\\")) FilePath += "\\";
            if (File.Exists(FilePath + FilePrefix + ".config")) return;
            webconfig = "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n";
            webconfig += "<configuration>\r\n";
            webconfig += indent + "<system.runtime.remoting>\r\n";
            webconfig += indent + indent + "<application>\r\n";
            webconfig += indent + indent + indent + "<service>\r\n";
            webconfig += indent + indent + indent + "</service>\r\n";
            webconfig += indent + indent + "</application>\r\n";
            webconfig += indent + "</system.runtime.remoting>\r\n";
            webconfig += "</configuration>\r\n";
            if (!WriteFile(FilePath, FilePrefix, ".config")) 
            {
                Error = Resource.FormatString("Soap_WebConfigFailed");
                ComSoapPublishError.Report(Error);
            }
      }

       // fast check to see if a node exists
       internal bool CheckElement(
            string FilePath, 
            string AssemblyName, 
            string TypeName, 
            string ProgId, 
            string WkoMode, 
            out string Error
            )
        {
            Error = "";
            try
            {
                string strType = TypeName + ", " + AssemblyName;
                XmlDocument configXml = new XmlDocument();
                configXml.Load(FilePath);
                XmlNode node= configXml.DocumentElement; 
                node= node.FirstChild; // <system.runtime.remoting>
                node= node.FirstChild; // <application>
                node= node.FirstChild; // <service>
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::type='" + strType + "']");
                return (nodelist.Count > 0);
            }
            catch(Exception e)
            {
                Error = e.ToString();
                ComSoapPublishError.Report(e.ToString());
            }
            return false;
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="ServerWebConfig.AddElement"]/*' />
        /// <internalonly/>
        public void AddElement(
            string FilePath, 
            string AssemblyName, 
            string TypeName, 
            string ProgId, 
            string WkoMode, 
            out string Error
            )
        {
            Error = "";
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                sp.Demand();
                string strType = TypeName + ", " + AssemblyName;
                XmlDocument configXml = new XmlDocument();
                configXml.Load(FilePath);
                XmlNode node= configXml.DocumentElement; 
                while (node.Name != "configuration") node= node.NextSibling; // <configuration>
                node= node.FirstChild; // <system.runtime.remoting>
                while (node.Name != "system.runtime.remoting") node= node.NextSibling;
                node= node.FirstChild; // <application>
                while (node.Name != "application") node= node.NextSibling;
                node= node.FirstChild; // <service>
                while (node.Name != "service") node= node.NextSibling;
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::type='" + strType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    {
                        if (n.ParentNode != null)
                        {
                           n.ParentNode.RemoveChild(n);
                           nodelist = node.SelectNodes("descendant::*[attribute::type='" + strType + "']");
                        }
                    }
                }
                XmlElement WKOElement = configXml.CreateElement("","wellknown", "");
                WKOElement.SetAttribute("mode", WkoMode);
                WKOElement.SetAttribute("type", strType);
                WKOElement.SetAttribute("objectUri", ProgId+".soap");
                node.AppendChild(WKOElement);
                XmlElement CAElement = configXml.CreateElement("", "activated", ""); 
                CAElement.SetAttribute("type", strType);
                node.AppendChild(CAElement);
                configXml.Save(FilePath);
            }
            catch(Exception e)
            {
                Error = e.ToString();
                ComSoapPublishError.Report(e.ToString());
            }
        }

        internal void AddGacElement(
            string FilePath, 
            string AssemblyName, 
            string TypeName, 
            string ProgId, 
            string WkoMode, 
            string AssemblyFile
            )
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                sp.Demand();
                AssemblyManager manager = new AssemblyManager();
                string WKOstrType = TypeName + ", " + manager.GetFullName(AssemblyFile, AssemblyName);
                string CAOstrType = TypeName + ", " + AssemblyName;
                XmlDocument configXml = new XmlDocument();
                configXml.Load(FilePath);
                XmlNode node= configXml.DocumentElement; 
                while (node.Name != "configuration") node= node.NextSibling; // <configuration>
                node= node.FirstChild; // <system.runtime.remoting>
                while (node.Name != "system.runtime.remoting") node= node.NextSibling;
                node= node.FirstChild; // <application>
                while (node.Name != "application") node= node.NextSibling;
                node= node.FirstChild; // <service>
                while (node.Name != "service") node= node.NextSibling;
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    {
                        if (n.ParentNode != null)
                        {
                           n.ParentNode.RemoveChild(n);
                           nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                        }
                    }
                }
                nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    {
                        if (n.ParentNode != null)
                        {
                           n.ParentNode.RemoveChild(n);
                           nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                        }
                    }
                }
                XmlElement WKOElement = configXml.CreateElement("","wellknown", "");
                WKOElement.SetAttribute("mode", WkoMode);
                WKOElement.SetAttribute("type", WKOstrType);
                WKOElement.SetAttribute("objectUri", ProgId+".soap");
                node.AppendChild(WKOElement);
                XmlElement CAElement = configXml.CreateElement("", "activated", ""); 
                CAElement.SetAttribute("type", CAOstrType);
                node.AppendChild(CAElement);
                configXml.Save(FilePath);
            }
            catch(Exception e)
            {
                     if (typeof(RegistrationException) == e.GetType()) throw;
                     else ComSoapPublishError.Report(e.ToString());
            }
        }

        internal void DeleteElement(
            string FilePath, 
            string AssemblyName, 
            string TypeName, 
            string ProgId, 
            string WkoMode, 
            string AssemblyFile
            )
        {
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration);
                sp.Demand();
                AssemblyManager manager = new AssemblyManager();
                string WKOstrType = TypeName + ", " + manager.GetFullName(AssemblyFile, AssemblyName);
                string CAOstrType = TypeName + ", " + AssemblyName;
                XmlDocument configXml = new XmlDocument();
                configXml.Load(FilePath);
                XmlNode node= configXml.DocumentElement; 
                while (node.Name != "configuration") node= node.NextSibling; // <configuration>
                node= node.FirstChild; // <system.runtime.remoting>
                while (node.Name != "system.runtime.remoting") node= node.NextSibling;
                node= node.FirstChild; // <application>
                while (node.Name != "application") node= node.NextSibling;
                node= node.FirstChild; // <service>
                while (node.Name != "service") node= node.NextSibling;
                XmlNodeList nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    {
                        if (n.ParentNode != null)
                        {
                           n.ParentNode.RemoveChild(n);
                           nodelist = node.SelectNodes("descendant::*[attribute::type='" + CAOstrType + "']");
                        }
                    }
                }
                nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                while (nodelist != null && nodelist.Count > 0)
                {
                    //foreach (XmlNode n in nodelist) // this code throws an "index out of range exception"
                    XmlNode n = nodelist.Item(0);
                    {
                        if (n.ParentNode != null)
                        {
                           n.ParentNode.RemoveChild(n);
                           nodelist = node.SelectNodes("descendant::*[attribute::type='" + WKOstrType + "']");
                        }
                    }
                }

                configXml.Save(FilePath);
            }
             // these exceptions are not reported because on a proxy uninstall these files will not be present, but the
             // the proxy bit is not set on deletions
            catch(System.IO.DirectoryNotFoundException) {}
            catch(System.IO.FileNotFoundException) {}
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
             }
        }
        
        private bool WriteFile(string PhysicalDirectory, string FilePrefix, string FileSuffix)
        {
            try
            {
                string webConfigPath = PhysicalDirectory + FilePrefix + FileSuffix;
                if (File.Exists(webConfigPath))
                {
                    File.Delete(webConfigPath);
                }
                FileStream webConfigFile = new FileStream(webConfigPath, FileMode.Create);
                StreamWriter webConfigStream = new StreamWriter(webConfigFile);
                webConfigStream.Write(webconfig);
                webConfigStream.Close();
                webConfigFile.Close();
                return true;
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                return false;
            }
         
        }
        
        string webconfig = "";
        const string indent = "  ";
    }

    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IISVirtualRoot"]/*' />
    /// <internalonly/>
    [Guid("d8013ef1-730b-45e2-ba24-874b7242c425")]
      public class IISVirtualRoot : IComSoapIISVRoot
      {

      // this helper routine checks for the existence of the specified virtual directory
      internal bool CheckIfExists(string RootWeb, string VirtualDirectory)
      {
                  DirectoryEntry parent = new DirectoryEntry(RootWeb + "/" + VirtualDirectory);
                  try
                  {
                     string s = parent.Name;
                  }

                  catch
                  {
                      // assume a failure here means the VD does not exist
                      return false;
                  }

                  return true;
      }

      // Creates an IIS 6.0 Virtual Root
      /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IISVirtualRoot.Create"]/*' />
      /// <internalonly/>
      public void Create(string RootWeb, string inPhysicalDirectory, string VirtualDirectory, out string Error)
      {
             // if the given VD name already exists, we delete it & create a new one (should we throw instead?)
            Error = "";
            try
            {
                   SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                   sp.Demand();
                   string PhysicalDirectory = inPhysicalDirectory; 
                   while (PhysicalDirectory.EndsWith("/") || PhysicalDirectory.EndsWith("\\"))
                   {
                        PhysicalDirectory = PhysicalDirectory.Remove(PhysicalDirectory.Length-1, 1);
                   }
                   bool b = CheckIfExists(RootWeb, VirtualDirectory);
                   if (b)  // if it exists we should clean up first
                   {
                          //TODO: Revisit this issue in beta 3 to see if better behavior
                          return; // we are done if it already exists; with beta 2 of IIS 6.0 
                          // deleting and immediately re-creating a vroot can be problematic
                          //Delete(RootWeb, null, VirtualDirectory, out Error);
                          //if (Error.Length >0)
                          // return;
                   }

                   DirectoryEntry parent = new DirectoryEntry(RootWeb);

                   DirectoryEntry child = parent.Children.Add(VirtualDirectory, "IIsWebVirtualDir");
                   child.CommitChanges();
                   child.Properties["Path"][0]= PhysicalDirectory;
                   child.Properties["AuthFlags"][0]= 5;
                   child.Properties["EnableDefaultDoc"][0]= true;
                   child.Properties["DirBrowseFlags"][0]= 0x4000003e;
                   child.Properties["AccessFlags"][0]= 513;
                   child.CommitChanges();

                   // Now configure it to be "pooled" application isolation level

                   object[] args = new object[1];
                   args[0] = 2;
                   child.Invoke("AppCreate2", args);

                   Error = "";
            }

            catch (Exception e)
            {
                   Error = e.ToString();
                   ComSoapPublishError.Report(e.ToString());
            }
      }

      // Deletes an IIS 6.0 Virtual Root
      /// <include file='doc\serverpublish.uex' path='docs/doc[@for="IISVirtualRoot.Delete"]/*' />
      /// <internalonly/>
      public void Delete(string RootWeb, string PhysicalDirectory, string VirtualDirectory, out string Error)
      {
            // if it doesn't exist, this routine just returns with no error

            // TODO: why do we need the PhysicalDirectory parameter ?  
            // a better idea is a switch that tells us if we want the underlying directory deleted or not.

            Error = "";
            try
            {
                   SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                   sp.Demand();

                   if (CheckIfExists(RootWeb, VirtualDirectory) != true)    // check if there's anything to delete in the first place
                   {
                         return;
                   }

                   DirectoryEntry parent = new DirectoryEntry(RootWeb);
                   DirectoryEntry child = new DirectoryEntry(RootWeb + "/" + VirtualDirectory);

                   // delete the associated application (COM+ apps, etc.)
                   child.Invoke("AppDelete", null);

                   // delete the actual v-dir
                   object[] pargs = new object[2];
                   pargs[0] = "IIsWebVirtualDir";
                   pargs[1] = VirtualDirectory;
                   parent.Invoke("Delete", pargs);
                   Directory.Delete(PhysicalDirectory, true);
            }
            catch (Exception e)
            {
                   Error = e.ToString();
                   ComSoapPublishError.Report(e.ToString());
            }
      }

}

internal class CacheInfo
{
      internal static string GetCacheName(string AssemblyPath, string srcTypeLib)
     {
        string retVal = "";
        try
        {
                   FileInfo typlibInfo = new FileInfo(srcTypeLib);
                   string destDirectory = GetCachePath(true);
                   string typlibSize = typlibInfo.Length.ToString();
                   string typlibName = typlibInfo.Name.ToString();
                   string typlibWriteTime = typlibInfo.LastWriteTime.Year.ToString();
                   typlibWriteTime += "_" + typlibInfo.LastWriteTime.Month.ToString();
                   typlibWriteTime += "_" +typlibInfo.LastWriteTime.Day.ToString();
                   typlibWriteTime += "_" +typlibInfo.LastWriteTime.Hour.ToString();
                   typlibWriteTime += "_" +typlibInfo.LastWriteTime.Minute.ToString();
                   typlibWriteTime += "_" + typlibInfo.LastWriteTime.Second.ToString();
                   string newName = typlibName + "_" + typlibSize + "_" + typlibWriteTime;
                   newName = destDirectory + newName + "\\";
                   if (!Directory.Exists(newName)) Directory.CreateDirectory(newName);
                   char[] delim = new char[2]  { '/', '\\' };
                   int lastdelim = AssemblyPath.LastIndexOfAny(delim) + 1;
                   if (lastdelim <= 0) lastdelim =0;
                   string assemSName = AssemblyPath.Substring(lastdelim, AssemblyPath.Length - lastdelim);
                   newName += assemSName;
                   retVal = newName;
        }
        catch(Exception e)
        {
            retVal = "";
            ComSoapPublishError.Report(e.ToString()); 
         }
         return retVal;
    }

    internal static string GetCachePath(bool CreateDir)
    {
        StringBuilder sysDir = new StringBuilder(1024,1024);
        uint size = 1024;
        Publish.GetSystemDirectory(sysDir, size);
        string CacheDir = sysDir.ToString();
        CacheDir += "\\com\\SOAPCache\\";
        if (CreateDir)
        {
            try
            {
                if (!Directory.Exists(CacheDir))
                {
                    Directory.CreateDirectory(CacheDir);
                }
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
            }
        }
        return CacheDir;
    }

      internal static string GetMetadataName(string strSrcTypeLib, UCOMITypeLib TypeLib, out string strMetaFileRoot)
      {
        string assemblyName = "";
        strMetaFileRoot = "";

        if (TypeLib == null)
        {
            TypeLib = GetTypeLib(strSrcTypeLib);
            if (TypeLib == null)
                return assemblyName;
        }

        assemblyName = Marshal.GetTypeLibName(TypeLib);
        strMetaFileRoot = assemblyName + ".dll";
        char[] delim = new char[2]  { '/', '\\' };
        int lastdelim = strSrcTypeLib.LastIndexOfAny(delim) + 1;
        if (lastdelim <= 0) lastdelim =0;
        string strSourceFileName = strSrcTypeLib.Substring(lastdelim, strSrcTypeLib.Length - lastdelim);
        if (strSourceFileName.ToLower(CultureInfo.InvariantCulture) == strMetaFileRoot.ToLower(CultureInfo.InvariantCulture))
        {
            assemblyName += "SoapLib";
            strMetaFileRoot = assemblyName + ".dll";
        }

        return assemblyName;
    }

    internal static UCOMITypeLib GetTypeLib(string strTypeLibPath)
    {
        UCOMITypeLib TypeLib = null;

        try
        {
            LoadTypeLibEx(strTypeLibPath, REGKIND.REGKIND_NONE, out TypeLib);
        }
        catch (COMException e)
        {
            if (e.ErrorCode == unchecked((int)0x80029C4A))
            {
                string etxt = Resource.FormatString("Soap_InputFileNotValidTypeLib");
                ComSoapPublishError.Report(etxt + " " + strTypeLibPath);
            }
            else
            {
                ComSoapPublishError.Report(e.ToString());
            }

            return null;
        }

        return TypeLib;
    }

    [DllImport("oleaut32.dll", CharSet=CharSet.Unicode)] 
    private static extern void LoadTypeLibEx(string strTypeLibName, REGKIND regKind, out UCOMITypeLib TypeLib);
}

internal class AssemblyManager: MarshalByRefObject
{
     internal string InternalGetGacName(string fName)
     {
        string retVal = "";
        try
        {
              AssemblyName aInfo = AssemblyName.GetAssemblyName(fName);
              retVal = aInfo.Name + ",Version=" + aInfo.Version.ToString();
         }
        catch(Exception e)
        {
            ComSoapPublishError.Report(e.ToString());
        }
        return retVal;
     }
      
     public string GetGacName(string fName)
     {
        string retVal = "";
        AssemblyManager manager = null;
        AppDomainSetup domainOptions = new AppDomainSetup();
        AppDomain domain = AppDomain.CreateDomain("SoapDomain", null, domainOptions);
        if (null != domain)
        {
            AssemblyName n = typeof(AssemblyManager).Assembly.GetName();    
            ObjectHandle h = domain.CreateInstance(n.FullName, typeof(AssemblyManager).FullName);
            if (null != h)
            {
                 manager = (AssemblyManager)h.Unwrap();
                 retVal = manager.InternalGetGacName(fName);
            }
            AppDomain.Unload(domain);
          }
          return retVal;
        }

      internal string InternalGetFullName(string fName, string strAssemblyName)
      {
        string retVal = "";
        try
        {
             if (File.Exists(fName))
             {
                  AssemblyName aInfo = AssemblyName.GetAssemblyName(fName);
                  retVal = aInfo.FullName;
             }
             else
             {
                  try
                  {
                       Assembly assem = Assembly.LoadWithPartialName(strAssemblyName);
                       AssemblyName aInfo = assem.GetName();
                       retVal = aInfo.FullName;
                  }
                  catch
                  {
                        throw new RegistrationException(Resource.FormatString("ServicedComponentException_AssemblyNotInGAC"));
                  }
             }
        }
        catch(Exception e)
        {
            if (typeof(RegistrationException) == e.GetType()) throw;
            else ComSoapPublishError.Report(e.ToString());
        }
        return retVal;
     }
      
     public string GetFullName(string fName, string strAssemblyName)
     {
        string retVal = "";
        AssemblyManager manager = null;
        AppDomainSetup domainOptions = new AppDomainSetup();
        AppDomain domain = AppDomain.CreateDomain("SoapDomain", null, domainOptions);
        if (null != domain)
        {
            AssemblyName n = typeof(AssemblyManager).Assembly.GetName();    
            ObjectHandle h = domain.CreateInstance(n.FullName, typeof(AssemblyManager).FullName);
            if (null != h)
            {
                 manager = (AssemblyManager)h.Unwrap();
                 retVal = manager.InternalGetFullName(fName, strAssemblyName);
            }
            AppDomain.Unload(domain);
          }
          return retVal;
        }

        internal string InternalGetTypeNameFromClassId(string assemblyPath, string classId)
        {
            string TypeName = "";
            Assembly AssemObj = Assembly.LoadFrom(assemblyPath);
            Guid guidCLSID = new Guid(classId);
            Type[] AssemTypes = AssemObj.GetTypes();
            foreach (Type t in AssemTypes)
            {
               if (guidCLSID.Equals(t.GUID))
               {
                    TypeName = t.FullName;
                    break;
               }
           }
           return TypeName;
        }

        internal string InternalGetTypeNameFromProgId(string AssemblyPath, string ProgId)
        {
            string TypeName = "";
            Assembly AssemObj = Assembly.LoadFrom(AssemblyPath);
            // 1) the following does not work
            //RegistrationServices RegObj = new RegistrationServices();
            //RegObj.RegisterAssembly(AssemObj);
            //Type TypeObj = Type.GetTypeFromProgID(ProgId);
            //TypeName = TypeObj.FullName;
            // 2) the following does not work -
            // an exception is generated since this is not valid
            // method to call on a type generated by tlbimp
            //Type[] AssemTypes = AssemObj.GetTypes();
            //foreach (Type t in AssemTypes)
            //{
            //   if (ProgId == Marshal.GenerateProgIdForType(t))
            //   {
            //        TypeName = t.FullName;
            //        break;
            //   }
            //} 
            // 3) try number three - CLSIDs
            try
            {
                RegistryKey ProgIdKey = Registry.ClassesRoot.OpenSubKey(ProgId+"\\CLSID");
                string strValue = (string)ProgIdKey.GetValue("");
                Guid ProgIdGuid = new Guid(strValue);
                Type[] AssemTypes = AssemObj.GetTypes();
                foreach (Type t in AssemTypes)
                {
                     if (ProgIdGuid.Equals(t.GUID))
                     {
                         TypeName = t.FullName;
                         break;
                     }
                }
            }
            catch 
            {
                TypeName = "";
                throw;
            }
            return TypeName;
        }

        [DllImport("kernel32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
         internal static extern bool CopyFile(string source, string dest, bool failifexists);

       internal bool GetFromCache( string AssemblyPath, string srcTypeLib )
       {
            try
            {
                 string newFName = CacheInfo.GetCacheName(AssemblyPath, srcTypeLib);
                 if (File.Exists(newFName))
                 {
                      return CopyFile(newFName, AssemblyPath, true);
                 }
                 return false;
            }
            catch(Exception e) 
            {
                    ComSoapPublishError.Report(e.ToString());
            }
            return false;
       }

       internal bool CopyToCache( string AssemblyPath, string srcTypeLib )
       {
            bool retVal = false;
            try
            {
                 string newFName = CacheInfo.GetCacheName(AssemblyPath, srcTypeLib);
                 if (File.Exists(newFName)) return true; //do not overwrite
                 return CopyFile(AssemblyPath, newFName, false);
            }
            catch(Exception e) 
            {
                    ComSoapPublishError.Report(e.ToString());
            }
            return retVal;
       }

       internal bool CompareToCache(string AssemblyPath, string srcTypeLib )
       {
            bool retVal = true;
            try
            {
                 string cacheName = CacheInfo.GetCacheName(AssemblyPath, srcTypeLib);
                 if (!File.Exists(AssemblyPath)) return false;
                 if (!File.Exists(cacheName)) return false;
            }
            catch(Exception e) 
            {
                    retVal = false;
                    ComSoapPublishError.Report(e.ToString());
            }
            return retVal;
       }
    }

    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish"]/*' />
    [Guid("d8013eef-730b-45e2-ba24-874b7242c425")]
    public class Publish : IComSoapPublisher
    {
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.RegisterAssembly"]/*' />
        public void RegisterAssembly( string AssemblyPath  )
        {
            try
            {
                RegistryPermission rp = new RegistryPermission(PermissionState.Unrestricted);
                rp.Demand();
                rp.Assert();

                Assembly asm = Assembly.LoadFrom(AssemblyPath);
                RegistrationServices rs = new RegistrationServices();
                rs.RegisterAssembly(asm, AssemblyRegistrationFlags.SetCodeBase);

                foreach (AssemblyName asmName in asm.GetReferencedAssemblies())
                {
                    if (asmName.Name == "System.EnterpriseServices")
                    {
                        Assembly asmThis = Assembly.GetExecutingAssembly();

                        if (asmThis.GetName().Version < asmName.Version)
                        {
                            Uri uri = new Uri(asm.Location);

                            if (uri.IsFile && uri.LocalPath != "")
                            {                                
                                string dir = uri.LocalPath.Remove(uri.LocalPath.Length - Path.GetFileName(uri.LocalPath).Length, Path.GetFileName(uri.LocalPath).Length);                                
                                string[] files = Directory.GetFiles(dir, "*.tlb");

                                foreach (string file in files)
                                {
                                    UCOMITypeLib tlib;
                                    object data;
                                    Guid attrid = new Guid("90883F05-3D28-11D2-8F17-00A0C9A6186D");

                                    Marshal.ThrowExceptionForHR(LoadTypeLib(file, out tlib));
                                    if (((ITypeLib2)tlib).GetCustData(ref attrid, out data) == 0 &&
                                        (string)data == asm.FullName)
                                    {
                                        Marshal.ReleaseComObject(tlib);
                                        RegistrationDriver.GenerateTypeLibrary(asm, file, null);   
                                    }                                    
                                }                                                                   
                            }
                        }
                    }
                }
            }
            catch(Exception e)
            {
                ComSoapPublishError.Report(e.ToString());
                throw;
            }
        }

       /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.UnRegisterAssembly"]/*' />
       public void UnRegisterAssembly(string AssemblyPath )
       {
             try
             {
                 RegistryPermission rp = new RegistryPermission(PermissionState.Unrestricted);
                 rp.Demand();
                 rp.Assert();
                 Assembly asm = Assembly.LoadFrom(AssemblyPath);
                 new RegistrationServices().UnregisterAssembly(asm);
             }
             catch(Exception e)
             {
                ComSoapPublishError.Report(e.ToString());
                throw;
             }
        }

       /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.GacInstall"]/*' />
       public void GacInstall( string AssemblyPath )
       {
             try
             {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                IAssemblyCache ac = null;
                int hr = CreateAssemblyCache(out ac, 0);
                if (0 == hr) hr = ac.InstallAssembly(0, AssemblyPath, (IntPtr)0);
                if (0 != hr)
                {
                    string etxt = Resource.FormatString("Soap_GacInstallFailed");
                    ComSoapPublishError.Report( etxt + " " + AssemblyPath);
                }
             }
             catch(Exception e)
             {
                ComSoapPublishError.Report(e.ToString());
                throw;
             }
       }
             
       /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.GacRemove"]/*' />
       public void GacRemove(string AssemblyPath)
       {
             try
             {
                 SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                 sp.Demand();
                 AssemblyManager manager = new AssemblyManager();
                 string assemblyfullname = manager.GetGacName(AssemblyPath);
                 IAssemblyCache ac = null;
                 int hr = CreateAssemblyCache(out ac, 0);
                 uint n = 0;
                 if (0 == hr) hr = ac.UninstallAssembly(0, assemblyfullname, (IntPtr)0, out n);
                 if (0 != hr)
                 {
                    string etxt = Resource.FormatString("Soap_GacRemoveFailed");
                    ComSoapPublishError.Report(etxt + " " + AssemblyPath + " " + assemblyfullname);
                 }
             }
             catch(Exception e)
             {
                ComSoapPublishError.Report(e.ToString());
                throw;
             }
       }

       /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.GetAssemblyNameForCache"]/*' />
       public void GetAssemblyNameForCache(String TypeLibPath, out String CachePath)
       {
          CacheInfo.GetMetadataName(TypeLibPath, null, out CachePath);
          CachePath = CacheInfo.GetCacheName(CachePath, TypeLibPath);
       }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.GetClientPhysicalPath"]/*' />
        public static string GetClientPhysicalPath(bool CreateDir)
        {
            StringBuilder sysDir = new StringBuilder(1024,1024);
            uint size = 1024;
            GetSystemDirectory(sysDir, size);
            string PhysicalPath = sysDir.ToString() + "\\com\\SOAPAssembly\\";
            if (CreateDir)
            {
                try
                {
                    if (!Directory.Exists(PhysicalPath))
                    {
                         Directory.CreateDirectory(PhysicalPath);
                    }
                }
                catch(Exception e)
                {
                    PhysicalPath = "";
                    ComSoapPublishError.Report(e.ToString());
                }
            }
            return PhysicalPath;
        }
        
        private bool GetVRootPhysicalPath(string VirtualRoot, out string PhysicalPath, out string BinDirectory, bool CreateDir)
        {
            bool AlreadyExists = true;
            StringBuilder sysDir = new StringBuilder(1024,1024);
            uint size = 1024;
            GetSystemDirectory(sysDir, size);
            string VRootRootDirectory = sysDir.ToString();
            VRootRootDirectory += "\\com\\SOAPVRoots\\";
            PhysicalPath = VRootRootDirectory + VirtualRoot + "\\";
            BinDirectory = PhysicalPath + "bin\\";
            if (CreateDir)
            {
                try
                {
                      try
                      {
                          if (!Directory.Exists(VRootRootDirectory))
                          {
                               Directory.CreateDirectory(VRootRootDirectory);
                          }
                      }
                      catch {}
                      try
                      {
                          if (!Directory.Exists(PhysicalPath))
                          {
                               Directory.CreateDirectory(PhysicalPath);
                          }
                      }
                      catch {}
                      try
                      {
                          if (!Directory.Exists(BinDirectory))
                          {
                               Directory.CreateDirectory(BinDirectory);
                               AlreadyExists = false;
                          }
                      }
                      catch {}
                }
                catch(Exception e)
                {
                    PhysicalPath = "";
                    BinDirectory = "";
                    ComSoapPublishError.Report(e.ToString());
                }
            }
            else
            {
                 AlreadyExists = Directory.Exists(BinDirectory);
            }
            return AlreadyExists;
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.ParseUrl"]/*' />
        public static void ParseUrl(string FullUrl, out string BaseUrl, out string VirtualRoot)
        {
            // if only a relative path, the constructor will
            // throw an exception
            try
            {
                System.Uri fullVRoot = new System.Uri(FullUrl);
                string[] uriSegs = fullVRoot.Segments;
                // last segment in Uri is the VRoot
                VirtualRoot = uriSegs[uriSegs.GetUpperBound(0)];
                //remove possible slash from end
                BaseUrl = FullUrl.Substring(0, FullUrl.Length - VirtualRoot.Length);
                char[] slash = { '/' };
                VirtualRoot = VirtualRoot.TrimEnd(slash); 
            }
            catch(Exception)
            {
                BaseUrl = "";
                VirtualRoot = FullUrl;
            }
            // get node name if BaseUrl is zero length
            if (BaseUrl.Length <= 0)
            {
                try
                {
                      BaseUrl = "http://";
                      BaseUrl += Dns.GetHostName();
                      BaseUrl += "/";
                }
                catch(Exception e)
                {
                      ComSoapPublishError.Report( e.ToString() );
                }
            }
        }
        
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.CreateVirtualRoot"]/*' />
        public void CreateVirtualRoot(
            string Operation,
            string FullUrl, 
            out string BaseUrl, 
            out string VirtualRoot, 
            out string PhysicalPath,
            out string Error
            )
        {
            // if Operation if an empty string, the VRoot will be published
            BaseUrl = "";
            VirtualRoot = "";
            PhysicalPath = "";
            Error = "";
            if (FullUrl.Length <= 0) return;
            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                ParseUrl(FullUrl, out BaseUrl, out VirtualRoot);
                if (VirtualRoot.Length <= 0)
                {
                    return;
                }
                // set default root web server if the caller has not
                string rootWeb = "IIS://localhost/W3SVC/1/ROOT";
                // create physical directories and get names
                bool CreateDirs = true;
                if (Operation.ToLower(CultureInfo.InvariantCulture) == "delete" || Operation.ToLower(CultureInfo.InvariantCulture) == "addcomponent") 
                {
                    CreateDirs = false;
               }
                string BinDirectory = "";
                GetVRootPhysicalPath(VirtualRoot, out PhysicalPath, out BinDirectory, CreateDirs);
                if (PhysicalPath.Length <= 0)
                {
                    Error = Resource.FormatString("Soap_VRootDirectoryCreationFailed");
                    return;
                }
                if (!CreateDirs) return; // need path only
                // create a shell configuration file
                ServerWebConfig webConfig = new ServerWebConfig();
                string CfgError = "";
                webConfig.Create(PhysicalPath, "Web", out CfgError);
                DiscoFile webDisco = new DiscoFile();
                webDisco.Create(PhysicalPath, "Default.disco");
                HomePage webPage = new HomePage();
                webPage.Create(PhysicalPath, VirtualRoot, "Default.aspx", "Default.disco");

                // use ADSI to publish VRoot
                string vrError = "";
                try
                {
                   IISVirtualRoot iisvr = new IISVirtualRoot();
                   iisvr.Create(rootWeb, PhysicalPath, VirtualRoot, out vrError);
                }
                catch(Exception e)
                {
                    if (vrError.Length <= 0)
                    {
                         string etxt = Resource.FormatString("Soap_VRootCreationFailed");
                         vrError = string.Format(etxt + " " + VirtualRoot + " " + e.ToString());
                    }
                }
                if ( vrError.Length > 0 )
                {
                    Error = vrError;
                    return; // we failed to create a vroot
                }
            }
            catch(Exception e)
            {
                Error = e.ToString();
                ComSoapPublishError.Report(Error);
            }
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.DeleteVirtualRoot"]/*' />
        public void DeleteVirtualRoot(
            string RootWebServer,
            string FullUrl, 
            out string Error
            )
        {
            Error = "";
            try
            {
                if (FullUrl.Length <= 0) return;
                // set default root web server if the caller has not
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                string rootWeb = "IIS://localhost/W3SVC/1/ROOT";
                if (RootWebServer.Length > 0) rootWeb = RootWebServer;
                string BaseUrl = "";
                string VirtualRoot = "";
                ParseUrl(FullUrl, out BaseUrl, out VirtualRoot);
                if (VirtualRoot.Length <= 0) return;
                string PhysicalPath = "";
                string BinDirectory = "";
                GetVRootPhysicalPath(VirtualRoot, out PhysicalPath, out BinDirectory, false);
                if (PhysicalPath.Length <= 0) return;
                //IISVirtualRoot iisvr = new IISVirtualRoot();
                //iisvr.Delete(rootWeb, PhysicalPath, VirtualRoot, out Error);
            }
            catch(Exception e)
            {
                Error = e.ToString();
                ComSoapPublishError.Report(e.ToString());
            }
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.CreateMailBox"]/*' />
        public void CreateMailBox(
            string RootMailServer,
            string MailBox, 
            out string SmtpName, 
            out string Domain, 
            out string PhysicalPath,
            out string Error
            )
        {
            SmtpName = "";
            Domain = "";
            PhysicalPath = "";
            Error = "";
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
            sp.Demand();
            string error = Resource.FormatString("Soap_SmtpNotImplemented");
            ComSoapPublishError.Report(error);
            if (MailBox.Length <= 0) return;
        }
 
        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.DeleteMailBox"]/*' />
        public void DeleteMailBox(
            string RootMailServer, 
            string MailBox, 
            out string Error)
        {
            Error = "";
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
            sp.Demand();
            string error = Resource.FormatString("Soap_SmtpNotImplemented");
            ComSoapPublishError.Report(error);
            if (MailBox.Length <= 0) return;
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.ProcessServerTlb"]/*' />
        public void ProcessServerTlb(
            string ProgId, 
            string SrcTlbPath, 
            string PhysicalPath, 
            string Operation, 
            out string strAssemblyName, 
            out string TypeName,
            out string Error
            )
        {
            strAssemblyName = "";
            TypeName = "";
            Error = "";
            bool bDelete = false;

            try
            {
                SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                sp.Demand();
                if (null != Operation && Operation.ToLower(CultureInfo.InvariantCulture) == "delete") bDelete = true;
                //if ProgId is an empty string, it means it does not go in the configuration file
                if (SrcTlbPath.Length <= 0) return;
                if (!PhysicalPath.EndsWith("/") && !PhysicalPath.EndsWith("\\")) PhysicalPath += "\\";
                string srcdll = SrcTlbPath.ToLower(CultureInfo.InvariantCulture);
                if ( srcdll.EndsWith("mscoree.dll") )
                {
                    Type typ = Type.GetTypeFromProgID(ProgId);
                    //COM+: 31306 - iff an assembly has a SoapVroot attribute and had dependent assemblies that are not in the 
                    //GAC it will return a System.__ComObject.  In that case we want to fail with an exception.
                    if(typ.FullName == "System.__ComObject")
                    {
                       throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_DependencyNotInGAC"));
                    }
                        
                    TypeName = typ.FullName;
                    Assembly assem = typ.Assembly;
                    AssemblyName assemname = assem.GetName();
                    strAssemblyName = assemname.Name;
                }
                else if  ( srcdll.EndsWith("scrobj.dll") )
                {
                    if (!bDelete)
                    {
                       throw new ServicedComponentException(Resource.FormatString("ServicedComponentException_WSCNotSupported"));
                    }
                }
                else
                {
                    GenerateMetadata metaGen = new GenerateMetadata();
                    if (bDelete) strAssemblyName = metaGen.GetAssemblyName(SrcTlbPath, PhysicalPath + "bin\\");
                    else strAssemblyName = metaGen.GenerateSigned(SrcTlbPath, PhysicalPath + "bin\\", false, out Error);
                    if (strAssemblyName.Length > 0)
                    {
                         try
                         {
                            TypeName = GetTypeNameFromProgId(PhysicalPath + "bin\\" + strAssemblyName + ".dll", ProgId);
                         }
                         catch(Exception e)
                         {
                                 if (bDelete && e.GetType() != typeof(System.IO.DirectoryNotFoundException) &&
                                    e.GetType() != typeof(System.IO.FileNotFoundException))
                                    {
                                        throw;
                                    }
                         }
                    }
                }
                // pull the generated Assembly.Type from the assembly for configuration files
                if (ProgId.Length > 0 && strAssemblyName.Length > 0 && TypeName.Length > 0)
                {
                    // write to the server configuration files
                    ServerWebConfig webConfig = new ServerWebConfig();
                    DiscoFile discoFile = new DiscoFile();
                    string strFileName = PhysicalPath + "bin\\" + strAssemblyName + ".dll";
                    if (bDelete)
                    {
                        webConfig.DeleteElement(PhysicalPath + "Web.Config", strAssemblyName, TypeName, ProgId, "SingleCall", strFileName);
                        discoFile.DeleteElement(PhysicalPath + "Default.disco", ProgId + ".soap?WSDL");
                        // we have no way of telling from a single component what other components are in this type library
                        // metadata assembly.  If we remove from GAC or delete we kill all the other components simultaneously
                       //try // if for some reason we cannot delete this file, we move on 
                       // {
                                //GacRemove(strFileName);
                                //File.Delete(strFileName);
                        //}
                        //catch(Exception e) 
                        //{
                        //       ComSoapPublishError.Report(e.ToString());
                        //}
                    }
                    else
                    {
                        webConfig.AddGacElement(PhysicalPath + "Web.Config", strAssemblyName, TypeName, ProgId, "SingleCall", strFileName);
                        discoFile.AddElement(PhysicalPath + "Default.disco", ProgId + ".soap?WSDL");
                    }
                 }
            }
            catch(Exception e)
            {
                Error = e.ToString();
                ComSoapPublishError.Report(Error);
                if ( typeof(ServicedComponentException) == e.GetType() || typeof(RegistrationException) == e.GetType() )
                {
                    throw;
                }
            }
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.GetTypeNameFromProgId"]/*' />
        public string GetTypeNameFromProgId(string AssemblyPath, string ProgId)
        {
            try
            {
                 SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                 sp.Demand();
             }
             catch(Exception e)
             {
                 ComSoapPublishError.Report(e.ToString());
                 throw;
             }

            string retVal = "";
            AssemblyManager manager = null;
            AppDomainSetup domainOptions = new AppDomainSetup();
            //domainOptions.ApplicationBase = appdir;
            AppDomain domain = AppDomain.CreateDomain("SoapDomain", null, domainOptions);
            if (null != domain)
            {
               AssemblyName n = typeof(AssemblyManager).Assembly.GetName();    
               ObjectHandle h = domain.CreateInstance(n.FullName, typeof(AssemblyManager).FullName);
               if (null != h)
               {
                 manager = (AssemblyManager)h.Unwrap();
                 retVal = manager.InternalGetTypeNameFromProgId(AssemblyPath, ProgId);
               }
               AppDomain.Unload(domain);
            }
            return retVal;
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.ProcessClientTlb"]/*' />
        public void ProcessClientTlb(
            string ProgId, 
            string SrcTlbPath, 
            string PhysicalPath, 
            string VRoot,
            string BaseUrl,
            string Mode, 
            string Transport,
            out string AssemblyName, 
            out string TypeName,
            out string Error
            )
        {
            AssemblyName = "";
            TypeName = "";
            Error = "";
            try
            {
                 SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                 sp.Demand();
                //if ProgId is an empty string, it means it does not go in the configuration file
                string ClientDir = GetClientPhysicalPath(true);
                string srcdll = SrcTlbPath.ToLower(CultureInfo.InvariantCulture);
                // we still generate metadata on the client to get the assembly and typename
                // but it is not used during activation
                // TODO - find a way of getting the Assembly and TypeName without generating the metadata
                if ( !srcdll.EndsWith("mscoree.dll") && SrcTlbPath.Length > 0)
                {
                    GenerateMetadata metaGen = new GenerateMetadata();
                    AssemblyName = metaGen.Generate(SrcTlbPath, ClientDir);
                    if (ProgId.Length > 0)
                    {
                        TypeName = GetTypeNameFromProgId(ClientDir + AssemblyName + ".dll", ProgId);
                    }
                }
                else
                {
                     //it must be a managed assembly, so pull the typename and assemblyname from the 
                      //registry
                     if (ProgId.Length > 0)
                     {
                         RegistryKey ProgIdKey = Registry.ClassesRoot.OpenSubKey(ProgId+"\\CLSID");
                         string strValue = (string)ProgIdKey.GetValue("");
                         Guid ProgIdGuid = new Guid(strValue);
                         RegistryKey ClsidKey = Registry.ClassesRoot.OpenSubKey("CLSID\\{" + ProgIdGuid + "}\\InprocServer32");
                         AssemblyName = (string)ClsidKey.GetValue("Assembly");
                         int comma = AssemblyName.IndexOf(",") ;
                         if (comma > 0) AssemblyName = AssemblyName.Substring(0, comma);
                         TypeName = (string)ClsidKey.GetValue("Class");
                     }
                }
                if (ProgId.Length > 0)
                {
                    // write to the client configuration file
                    Uri baseUri = new Uri(BaseUrl);
                    Uri fullUri = new Uri(baseUri, VRoot);
                    if (fullUri.Scheme.ToLower(CultureInfo.InvariantCulture) == "https")
                    {
                        string auth = "Windows";   
                        SoapClientConfig.Write(
                            ClientDir,
                            fullUri.AbsoluteUri,
                            AssemblyName, 
                            TypeName, 
                            ProgId, 
                            auth
                            );
                    }
                    else
                    {
                        ClientRemotingConfig.Write(ClientDir, VRoot, BaseUrl, AssemblyName, TypeName, ProgId, Mode, Transport);
                    }
                }
            }
            catch(Exception e)
            {
                Error = e.ToString();
                ComSoapPublishError.Report(Error);
            }
        }

        [DllImport("Fusion.dll", CharSet=CharSet.Auto)]
        internal static extern int CreateAssemblyCache(out IAssemblyCache ppAsmCache, uint dwReserved);

        [DllImport("kernel32.dll", CharSet=CharSet.Unicode)]
        internal static extern uint GetSystemDirectory(StringBuilder lpBuf, uint uSize);

        [DllImport("oleaut32.dll", CharSet = CharSet.Unicode)]
        internal static extern int LoadTypeLib([MarshalAs(UnmanagedType.LPWStr)] string file, out UCOMITypeLib tlib);
    }


    /// <include file='doc\serverpublish.uex' path='docs/doc[@for="GenerateMetadata"]/*' />
    /// <internalonly/>
    [Guid("d8013ff1-730b-45e2-ba24-874b7242c425")]
    public class GenerateMetadata : IComSoapMetadata
    { 
       
            internal bool _signed = false;
            internal bool _nameonly = false;
            
            // return assembly name of already existing metadata for deletion purposes
            internal string GetAssemblyName(string strSrcTypeLib, string outPath)
            {
                _nameonly = true;
                return Generate(strSrcTypeLib, outPath);
            }
            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="GenerateMetadata.Generate"]/*' />
            /// <internalonly/>
            public string Generate(string strSrcTypeLib, string outPath)
            {
                 return GenerateMetaData(strSrcTypeLib, outPath, null, null);
            }

            /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.GenerateSigned"]/*' />
            /// <internalonly/>
            public string GenerateSigned(string strSrcTypeLib, string outPath, bool InstallGac, out string Error)
            {
            string RetString = "";
            _signed = true;
            try
            {
                Error = "";
                string KeyContainer = strSrcTypeLib;
                uint Flags = 0;
                IntPtr KeyBlob = IntPtr.Zero;
                uint KeyBlobSize = 0;
                int retVal = StrongNameKeyGen(KeyContainer, Flags, out KeyBlob, out KeyBlobSize);
                byte[] KeyByteArray = new byte[KeyBlobSize];
                Marshal.Copy(KeyBlob, KeyByteArray, 0, (int)KeyBlobSize);
                StrongNameFreeBuffer(KeyBlob);
                StrongNameKeyPair KeyPair = new StrongNameKeyPair(KeyByteArray);
                RetString = GenerateMetaData(strSrcTypeLib, outPath, null, KeyPair);
            }
            catch(Exception e)
            {
                Error = e.ToString();
                ComSoapPublishError.Report(Error);
            }
            return RetString;
        }

        /// <include file='doc\serverpublish.uex' path='docs/doc[@for="Publish.GenerateMetaData"]/*' />
        /// <internalonly/>
        public string GenerateMetaData(string strSrcTypeLib, string outPath, byte[] PublicKey, StrongNameKeyPair KeyPair)
        {
            try
            {
                 SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                 sp.Demand();
             }
             catch(Exception e)
             {
                 ComSoapPublishError.Report(e.ToString());
                 throw;
             }

            string assemblyName = "";
            if (0 >= strSrcTypeLib.Length || 0 >= outPath.Length) return assemblyName;
            if ( !outPath.EndsWith("/") && !outPath.EndsWith("\\") )
            {
                outPath += "\\";
            }
            
            // Retrieve the typelib name.
            string strMetaFileRoot;
            UCOMITypeLib TypeLib = null;

            TypeLib = CacheInfo.GetTypeLib(strSrcTypeLib);
            if (TypeLib == null)
                return assemblyName;
            
            assemblyName = CacheInfo.GetMetadataName(strSrcTypeLib, TypeLib, out strMetaFileRoot);
            if (assemblyName.Length == 0)
                return assemblyName;
            
            if (_nameonly) return assemblyName;
            string strMetaFileName = outPath + strMetaFileRoot;
            if (_signed)
            {
                 try
                 {
                     // if we can get it from the cache we don't need to generate
                     AssemblyManager manager = new AssemblyManager();
                     if (manager.CompareToCache(strMetaFileName, strSrcTypeLib))
                     {
                         //this should be unnecessary, but if the user has deleted the
                         //file from the GAC this will avoid some test failures
                         Publish publisher = new Publish();
                         publisher.GacInstall(strMetaFileName);
                         return assemblyName;
                     }
                     if (manager.GetFromCache(strMetaFileName, strSrcTypeLib))
                     {
                         //this should be unnecessary, but if the user has deleted the
                         //file from the GAC this will avoid some test failures
                         Publish publisher = new Publish();
                         publisher.GacInstall(strMetaFileName);
                         return assemblyName;
                     }
                 }
                 catch(Exception e)
                {
                   ComSoapPublishError.Report(e.ToString());  
                }
            }
            else
            {
                    if (File.Exists(strMetaFileName)) return assemblyName;
            }

            //----------------------------------------------------------------------
            // Attempt the import.
            try
            {
                     ITypeLibConverter TLBConv = new TypeLibConverter();

                     // Convert the typelib.
                     ImporterCallback callback = new ImporterCallback();
                     callback.OutputDir = outPath;
                     AssemblyBuilder AsmBldr = TLBConv.ConvertTypeLibToAssembly(TypeLib,
                                                                           strMetaFileName,
                                                                           TypeLibImporterFlags.UnsafeInterfaces,
                                                                            callback,
                                                                            PublicKey,
                                                                            KeyPair,
                                                                            null,
                                                                            null);

                    FileInfo assemName = new FileInfo(strMetaFileName);
                    AsmBldr.Save(assemName.Name);
                    if (_signed)
                    {
                          AssemblyManager manager = new AssemblyManager();
                          manager.CopyToCache(strMetaFileName, strSrcTypeLib);
                          Publish publisher = new Publish();
                          publisher.GacInstall(strMetaFileName);
                    }
             }
             catch (ReflectionTypeLoadException e)
             {
                     int i;
                     Exception[] exceptions;
                     exceptions = e.LoaderExceptions;
                     for (i = 0; i < exceptions.Length; i++)
                     {
                           try 
                           {
                                 ComSoapPublishError.Report(exceptions[i].ToString());
                           }
                           catch (Exception ex)
                           {
                                 ComSoapPublishError.Report(ex.ToString());
                           }
                     }
                     return "";
               }
               catch (Exception e)
               {
                         ComSoapPublishError.Report(e.ToString());
                         return "";
               }
               return assemblyName;
        }

      //******************************************************************************
      // The resolution callback class.
      //******************************************************************************
      internal class ImporterCallback : ITypeLibImporterNotifySink
      {
          private string m_strOutputDir = "";
          public void ReportEvent(ImporterEventKind EventKind, int EventCode, String EventMsg)
          {
            // this now reports back every type import, no need to log these
            //ComSoapPublishError.Report(EventMsg);
          }

          internal string GetTlbPath(string guidAttr, string strMajorVer, string strMinorVer)
          {
              string strTlbPath = "";
              string strSubKey = "TypeLib\\{" + guidAttr + "}\\" + strMajorVer + "." + strMinorVer + "\\0\\win32";
              RegistryKey rkTypeLib = Registry.ClassesRoot.OpenSubKey(strSubKey);
              if (null == rkTypeLib)
              {
                  throw new COMException(Resource.FormatString("Soap_ResolutionForTypeLibFailed") + " " + guidAttr, Util.REGDB_E_CLASSNOTREG);
              }
              strTlbPath = (string)rkTypeLib.GetValue("");
              return strTlbPath;
          }
          
          public Assembly ResolveRef(object TypeLib)
          {
                Assembly rslt = null;
                IntPtr pAttr = (IntPtr)0;
                try
                {
                    ((UCOMITypeLib)TypeLib).GetLibAttr(out pAttr);
                    TYPELIBATTR Attr = (TYPELIBATTR)Marshal.PtrToStructure(pAttr, typeof(TYPELIBATTR));
                    string SrcTlbPath = GetTlbPath(Attr.guid.ToString(), Attr.wMajorVerNum.ToString(), Attr.wMinorVerNum.ToString());
                    if (SrcTlbPath.Length > 0)
                    {
                        GenerateMetadata metaGen = new GenerateMetadata();
                        string Error = "";
                        string strAssemblyName = metaGen.GenerateSigned(SrcTlbPath, m_strOutputDir, true, out Error);
                        if (strAssemblyName.Length > 0)
                        {
                            rslt = Assembly.LoadWithPartialName(strAssemblyName);
                        }
                    }
                }
                finally
                {
                    if (pAttr != (IntPtr)0)
                    {
                        ((UCOMITypeLib)TypeLib).ReleaseTLibAttr(pAttr);
                    }
                }
                if (null == rslt)
                {
                    string assemblyName = Marshal.GetTypeLibName((UCOMITypeLib)TypeLib);
                    string etxt = Resource.FormatString("Soap_ResolutionForTypeLibFailed");
                    ComSoapPublishError.Report(etxt + " " + assemblyName);
                }
                return rslt;
           }

          internal string OutputDir
          {
              get
              {
                  return m_strOutputDir;
              }
              set
              {
                  m_strOutputDir = value;
              }
          }
      }

      /// <include file='doc\serverpublish.uex' path='docs/doc[@for="GenerateMetadata.SearchPath"]/*' />
      [DllImport("kernel32.dll", SetLastError=true, CharSet=CharSet.Unicode)]
      public static extern int SearchPath(string path, string fileName, string extension, int numBufferChars, 
            string buffer, int[] filePart);

        [DllImport("mscoree.dll")]
        private static extern int StrongNameKeyGen(string wszKeyContainer, uint dwFlags, 
            out IntPtr ppbKeyBlob, out uint pcbKeyBlob);
  
        [DllImport("mscoree.dll")]
        private static extern void StrongNameFreeBuffer(IntPtr ppbKeyBlob);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\assert.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "unmanagedheaders.h"

#ifdef _DEBUG

#define __UNMANAGED_DEFINES
#include "SimpleStream.h"

#define MAX_MSG_LEN 1023

#include <stdio.h>

void ShowAssert(char* file, int line, LPCWSTR msg)
{
    WCHAR szMsg[MAX_MSG_LEN+1];
    szMsg[MAX_MSG_LEN] = L'\0';

    _snwprintf(szMsg, MAX_MSG_LEN, 
               L"Assertion failure.\n\n"
               L"Location: %S(%d)\n\nExpression: %s\n\n\n"
               L"Press Retry to launch a debugger.",
               file, line, msg);

    int r = MessageBoxW(0, szMsg, 
                        L"ALERT: System.EnterpriseServices",
                        MB_ABORTRETRYIGNORE|MB_ICONEXCLAMATION);

    if(r == IDABORT)
    {
        TerminateProcess(GetCurrentProcess(), 1);
    }
    else if(r == IDRETRY)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\assert.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _THUNKASSERT_H
#define _THUNKASSERT_H

#ifdef _DEBUG

extern void ShowAssert(char* file, int line, LPCWSTR msg);

#define _ASSERT(x) if(!(x)) ::ShowAssert(__FILE__, __LINE__, L#x)

// This can only be called from managed code, but it generates a 
// managed stack trace for the assert.
#define _ASSERTM(x)                                                                                \
if(!(x))                                                                                           \
{                                                                                                  \
    System::Diagnostics::StackTrace* trace = new System::Diagnostics::StackTrace();                \
    String* s = String::Concat(L#x, L"\n\nat: ", trace->ToString());                               \
    BSTR bstr = (BSTR)TOPTR(Marshal::StringToBSTR(s));                                             \
    ::ShowAssert(__FILE__, __LINE__, bstr);                                                         \
    Marshal::FreeBSTR(TOINTPTR(bstr));                                                             \
}

#else // !_DEBUG

#define _ASSERT(x)
#define _ASSERTM(x)

#endif // _DEBUG

#define UNREF(x) x

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\contextapi.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _CONTEXT_API_H
#define _CONTEXT_API_H

ULONG_PTR GetContextCheck();
ULONG_PTR GetContextToken();
HRESULT   GetContext(REFIID riid, void** pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\contextapi.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "unmanagedheaders.h"
#include "ContextAPI.h"

#if defined(_X86_)

__declspec(naked) void ContextCheck()
{
    enum
    {
        POINTER_SIZE    = sizeof(ULONG_PTR)
    };
    
    _asm
    {
        // Extract the context token from the stub data. The stub data is
        // a boxed IntPtr value. So, we load the stub data and move past
        // the method table pointer to get the COM context value.
        mov eax, [eax + POINTER_SIZE];
    
        // Save some registers
        push ecx
        push edx

        // Save the COM Context
        push eax

        // Set up the call parameters and call to get the current COM Context
        call GetContextToken

        // Compare the return value with the COM context
        pop ecx
        sub eax, ecx

        // Restore registers
        pop edx
        pop ecx
        
        ret
    }
}

#elif defined(_IA64_)

// TODO: @ia64: Fix up the implementation of this guy:
void ContextCheck()
{
    _ASSERT(!"@TODO IA64 - ContextCheck (ContextAPI.cpp)");
}

#else
#error Unknown compilation platform, update oletls.h for NtCurrentTeb.
#endif

class Loader
{
private:
    static BOOL _fInit;

public:
    typedef HRESULT (__stdcall *FN_CoGetObjectContext)(REFIID riid, LPVOID* ppv);
    typedef HRESULT (__stdcall *FN_CoGetContextToken)(ULONG_PTR* pToken);

    static inline void Init()
    {
        if(!_fInit)
        {
            // Multiple threads can run through here at once, and that's
            // fine.
            HMODULE hOle = LoadLibraryW(L"ole32.dll");
            if(hOle && hOle != INVALID_HANDLE_VALUE)
            {
                CoGetObjectContext = (FN_CoGetObjectContext)
                  GetProcAddress(hOle, "CoGetObjectContext");
                CoGetContextToken = (FN_CoGetContextToken)
                  GetProcAddress(hOle, "CoGetContextToken");
            }
                
            // First person to get here has to leave those modules open,
            // everybody else can drop their DLL reference:
            if(InterlockedCompareExchange((LPLONG)(&_fInit), TRUE, FALSE) != FALSE)
            {
                if(hOle && hOle != INVALID_HANDLE_VALUE) FreeLibrary(hOle);
            }
        }
    }

    static FN_CoGetObjectContext CoGetObjectContext;
    static FN_CoGetContextToken  CoGetContextToken;
};

BOOL Loader::_fInit = 0;
Loader::FN_CoGetObjectContext Loader::CoGetObjectContext = NULL;
Loader::FN_CoGetContextToken  Loader::CoGetContextToken = NULL;


ULONG_PTR GetContextToken()
{
    Loader::Init();
    if(Loader::CoGetContextToken)
    {
        ULONG_PTR token;
        HRESULT hr = Loader::CoGetContextToken(&token);
        if(FAILED(hr)) return((ULONG_PTR)(-1));
        return(token);
    }
    else
    {
        // raw w2k fallback:  poke some TLS!
        SOleTlsData* pData = (SOleTlsData*) NtCurrentTeb()->ReservedForOle;
        if(!(pData && pData->pCurrentCtx))
        {
            // TODO:  Clean up this horrible hack...
            // Gotta initialize the TLS, cause this is apparently an implicit
            // MTA thread...  There's no lightweight way of doing that,
            // so we just call into ole32, which will return
            // g_pMTAEmptyCtx (or g_pNTAEmptyCtx) to us.  
            // Then, we stick that puppy on the thread.
            // note that we don't release that puppy, cause when it goes
            // onto the thread it's supposed to be addref'd.
            IUnknown* pUnk;
            HRESULT hr = GetContext(IID_IUnknown, (void**)&pUnk);
            _ASSERT(SUCCEEDED(hr));
            _ASSERT(pUnk != NULL);
            
            // Just a check, to make sure something sane happens
            // in a free build, if this fails:
            if(FAILED(hr) || pUnk == NULL) return((ULONG_PTR)(-1));

            pData = (SOleTlsData*) NtCurrentTeb()->ReservedForOle;
            _ASSERT(pData);
            if(pData && pData->pCurrentCtx == NULL)
            {
                // Don't release if we store this on the thread.
                // It's a global which will go away anyway, and besides,
                // it'll to get released when the thread is CoUninit'd
                pData->pCurrentCtx = (CObjectContext*)pUnk;
            }
            else
            {
                pUnk->Release();
            }
        }
        _ASSERT(pData && pData->pCurrentCtx);
        return((ULONG_PTR)(pData->pCurrentCtx));
    }
}

ULONG_PTR GetContextCheck() { return((ULONG_PTR)ContextCheck); }

HRESULT GetContext(REFIID riid, void** ppContext)
{
    Loader::Init();

    if(Loader::CoGetObjectContext)
    {
        HRESULT hr = Loader::CoGetObjectContext(riid, ppContext);
        return(hr);
    }
    return(CONTEXT_E_NOCONTEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\__assembly.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: Jan 2001
//

// This is a collection of attributes which decorate the 
// System.EnterpriseServices assembly:

[assembly: System.CLSCompliant(true)]
[assembly: System.Runtime.InteropServices.Guid("4fb2d46f-efc8-4643-bcd0-6e5bfa6a174c")]

// These attributes describe the application that is created in the COM+ explorer:
[assembly: System.EnterpriseServices.ApplicationID("1e246775-2281-484f-8ad4-044c15b86eb7")]
[assembly: System.EnterpriseServices.ApplicationName(".NET Utilities")]

// The following attribute are required to ensure COM compatibility.
[assembly:System.Runtime.InteropServices.ComCompatibleVersion(1, 0, 3300, 0)]
[assembly:System.Runtime.InteropServices.TypeLibVersion(1, 10)]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\crmthunk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "managedheaders.h"
#include "CrmThunk.h"

OPEN_ROOT_NAMESPACE()
namespace CompensatingResourceManager
{

using namespace System;
using namespace System::Runtime::InteropServices;

CrmLogControl::CrmLogControl()
{
    _pCtrl = NULL;
    ICrmLogControl* pCtrl;

    HRESULT hr = CoCreateInstance(CLSID_CRMClerk, NULL, CLSCTX_SERVER, 
                                  IID_ICrmLogControl, (void**)&pCtrl);
    THROWERROR(hr);

    _pCtrl = pCtrl;
}

CrmLogControl::CrmLogControl(IntPtr ctrl)
{
    IUnknown* pUnk = (IUnknown*)TOPTR(ctrl);
    if(pUnk == NULL) throw new NullReferenceException;

    ICrmLogControl* pCtrl;

    HRESULT hr = pUnk->QueryInterface(IID_ICrmLogControl, (void**)&pCtrl);
    THROWERROR(hr);

    _pCtrl = pCtrl;
}

void CrmLogControl::Dispose()
{
    if(_pCtrl != NULL)
    {
        _pCtrl->Release();
        _pCtrl = NULL;
    }
}

String* CrmLogControl::GetTransactionUOW()
{
    BSTR bstr;

    HRESULT hr = _pCtrl->get_TransactionUOW(&bstr);
    THROWERROR(hr);
    
    String* s = Marshal::PtrToStringBSTR(bstr);
    SysFreeString(bstr);

    return(s);
}

void CrmLogControl::RegisterCompensator(String* progid, String* desc, LONG flags)
{
    LPWSTR wszProgId = NULL;
    LPWSTR wszDesc   = NULL;

    try
    {
        // Marshal params
        LPWSTR wszProgId = (LPWSTR)TOPTR(Marshal::StringToCoTaskMemUni(progid));
        LPWSTR wszDesc   = (LPWSTR)TOPTR(Marshal::StringToCoTaskMemUni(desc));
        
        HRESULT hr = _pCtrl->RegisterCompensator(wszProgId,wszDesc,flags);
        THROWERROR(hr);
    }
    __finally
    {
        // Cleanup marshaled params
        CoTaskMemFree(wszProgId);
        CoTaskMemFree(wszDesc);
    }
}

void CrmLogControl::ForceLog()
{
    THROWERROR(_pCtrl->ForceLog());
}

void CrmLogControl::ForgetLogRecord()
{
    THROWERROR(_pCtrl->ForgetLogRecord());
}

void CrmLogControl::ForceTransactionToAbort()
{
    THROWERROR(_pCtrl->ForceTransactionToAbort());
}

void CrmLogControl::WriteLogRecord(Byte b[])
{
    BLOB blob;

    blob.cbSize = b->get_Length();
    
    Byte __pin* pinb = &(b[0]);
    blob.pBlobData = pinb;

    THROWERROR(_pCtrl->WriteLogRecord(&blob, 1));
}

CrmMonitorLogRecords* CrmLogControl::GetMonitor()
{
    return new CrmMonitorLogRecords(TOINTPTR(_pCtrl));
}

CrmMonitorLogRecords::CrmMonitorLogRecords(IntPtr mon)
{
    IUnknown* pUnk = (IUnknown*)TOPTR(mon);
    if(pUnk == NULL) throw new NullReferenceException;

    ICrmMonitorLogRecords* pMon;

    HRESULT hr = pUnk->QueryInterface(IID_ICrmMonitorLogRecords, (void**)&pMon);
    THROWERROR(hr);

    _pMon = pMon;
}

void CrmMonitorLogRecords::Dispose()
{
    if(_pMon != NULL)
    {
        _pMon->Release();
        _pMon = NULL;
    }
}

int CrmMonitorLogRecords::GetCount()
{
    long count;

    THROWERROR(_pMon->get_Count(&count));

    return((int)count);
}

int CrmMonitorLogRecords::GetTransactionState()
{
    CrmTransactionState state;

    THROWERROR(_pMon->get_TransactionState(&state));
    
    return((int)state);
}

_LogRecord CrmMonitorLogRecords::GetLogRecord(int index)
{
    CrmLogRecordRead record;

    THROWERROR(_pMon->GetLogRecord(index, &record));

    // Marshal out:
    _LogRecord out;

    out.dwCrmFlags = record.dwCrmFlags;
    out.dwSequenceNumber = record.dwSequenceNumber;
    out.blobUserData.cbSize = record.blobUserData.cbSize;
    out.blobUserData.pBlobData  = record.blobUserData.pBlobData;

    // TODO: Destroy old values?

    return(out);
}

CrmMonitor::CrmMonitor()
{
    ICrmMonitor* pMon;

    HRESULT hr = CoCreateInstance(CLSID_CRMRecoveryClerk, NULL, CLSCTX_SERVER,
                                  IID_ICrmMonitor, (void**)&pMon);
    THROWERROR(hr);

    _pMon = pMon;
}

Object* CrmMonitor::GetClerks()
{
    ICrmMonitorClerks* pClerks;
    
    HRESULT hr = _pMon->GetClerks(&pClerks);
    THROWERROR(hr);

    Object* obj = NULL;
    
    try
    {
        obj = Marshal::GetObjectForIUnknown(pClerks);
    }
    __finally
    {
        pClerks->Release();
    }

    return(obj);
}

CrmLogControl* CrmMonitor::HoldClerk(Object* idx)
{
    CrmLogControl* ret = NULL;
    VARIANT vidx;
    VARIANT vitem;
    IntPtr  pvidx = TOINTPTR(&vidx);

    VariantInit(&vidx);
    VariantInit(&vitem);
    
    Marshal::GetNativeVariantForObject(idx, pvidx);

    HRESULT hr = _pMon->HoldClerk(vidx, &vitem);
    // Release the index variant...
    VariantClear(&vidx);
    
    // If we failed, throw
    THROWERROR(hr);

    // Convert the vitem variant into a CrmLogControl object...
    _ASSERTM(vitem.vt == VT_UNKNOWN || vitem.vt == VT_DISPATCH);
    
    IUnknown* pClerk = vitem.punkVal;

    if(pClerk != NULL)
    {
        try
        {
            ret = new CrmLogControl(TOINTPTR(pClerk));
        }
        __finally
        {
            VariantClear(&vitem);
        }
    }
    return(ret);
}

void CrmMonitor::AddRef()
{
    _pMon->AddRef();
}

void CrmMonitor::Release()
{
    _pMon->Release();
}

}
CLOSE_ROOT_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\contextthunk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _CONTEXTTHUNK_H
#define _CONTEXTTHUNK_H

#include "contextAPI.h"

OPEN_NAMESPACE()

using namespace System;
using namespace System::Runtime::InteropServices;

__gc private class ContextThunk
{
private:
    ContextThunk() {}    

public:    

	static bool IsInTransaction()
	{
		IObjectContext* ctx = NULL;
		HRESULT hr = GetContext(IID_IObjectContext, (void**)&ctx);
		if (SUCCEEDED(hr) && NULL != ctx)
		{
			bool retVal = ctx->IsInTransaction();
			ctx->Release();
			return (retVal);
		}
		return false;
	}

	static void SetAbort()
	{
		IObjectContext* ctx = NULL;
		HRESULT hr = GetContext(IID_IObjectContext, (void**)&ctx);
		if (SUCCEEDED(hr) && NULL != ctx)
		{
			hr = ctx->SetAbort();
			ctx->Release();
			if (hr == S_OK)
				return;
		}
		if (hr==E_NOINTERFACE)
			hr = CONTEXT_E_NOCONTEXT;
		Marshal::ThrowExceptionForHR(hr);
	}

	static void SetComplete()
	{
		IObjectContext* ctx = NULL;
		HRESULT hr = GetContext(IID_IObjectContext, (void**)&ctx);
		if (SUCCEEDED(hr) && NULL != ctx)
		{
			hr = ctx->SetComplete();
			ctx->Release();
			if (hr == S_OK)
				return;
		}
		if (hr==E_NOINTERFACE)
			hr = CONTEXT_E_NOCONTEXT;
		Marshal::ThrowExceptionForHR(hr);
	}

	static void DisableCommit()
	{
		IObjectContext* ctx = NULL;
		HRESULT hr = GetContext(IID_IObjectContext, (void**)&ctx);
		if (SUCCEEDED(hr) && NULL != ctx)
		{
			hr = ctx->DisableCommit();
			ctx->Release();
			if (hr == S_OK)
				return;
		}
		if (hr==E_NOINTERFACE)
			hr = CONTEXT_E_NOCONTEXT;
		Marshal::ThrowExceptionForHR(hr);
	}

	static void EnableCommit()
	{
		IObjectContext* ctx = NULL;
		HRESULT hr = GetContext(IID_IObjectContext, (void**)&ctx);
		if (SUCCEEDED(hr) && NULL != ctx)
		{
			hr = ctx->EnableCommit();
			ctx->Release();
			if (hr == S_OK)
				return;
		}
		if (hr==E_NOINTERFACE)
			hr = CONTEXT_E_NOCONTEXT;
		Marshal::ThrowExceptionForHR(hr);
	}

	static Guid GetTransactionId()
	{
		Guid guid;
		GUID txid;

		IObjectContextInfo* ctxinfo = NULL;
		HRESULT hr = GetContext(IID_IObjectContextInfo, (void**)&ctxinfo);
		if (SUCCEEDED(hr) && NULL != ctxinfo)
		{
			// return the guid here
			hr = ctxinfo->GetTransactionId(&txid);
			ctxinfo->Release();
			if (hr==S_OK)
			{
				*((GUID*)&guid) = txid;
				return guid;
			}
		}
		if (hr==E_NOINTERFACE)
			hr = CONTEXT_E_NOCONTEXT;
		Marshal::ThrowExceptionForHR(hr);
		return guid;		// compiler will warn
	}

};

CLOSE_NAMESPACE()

#endif //_CONTEXTTHUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\crmthunk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _CRMTHUNK_H
#define _CRMTHUNK_H

OPEN_ROOT_NAMESPACE()
namespace CompensatingResourceManager
{

using namespace System;
using namespace System::Runtime::InteropServices;
using namespace System::EnterpriseServices::Thunk;

// BUGBUG: @64 Make sure this packing is 64-bit clean.
// My initial guess is that we should pack 4 on 32 bit, 8 on 64.
#pragma pack( push, crm_structs )
#pragma pack(1)

[StructLayout(LayoutKind::Sequential, Pack=1)]
__value private struct _BLOB
{
public:
    int    cbSize;
    IntPtr pBlobData;
};

[StructLayout(LayoutKind::Sequential, Pack=1)]
__value private struct _LogRecord
{
public:
    int    dwCrmFlags;
    int    dwSequenceNumber;
    _BLOB  blobUserData;
};

#pragma pack( pop, crm_structs )

// We use a thunk container in order to avoid interop for some of our
// more dangerous pointers.
__gc private class CrmMonitorLogRecords
{
private:
    ICrmMonitorLogRecords* _pMon;
public:
    CrmMonitorLogRecords(IntPtr mon);

    int        GetCount();
    int        GetTransactionState();
    _LogRecord GetLogRecord(int index);
    void       Dispose();
};

__gc private class CrmLogControl
{
private:
    ICrmLogControl* _pCtrl;
public:
    CrmLogControl();
    CrmLogControl(IntPtr p);

    String* GetTransactionUOW();
    void    RegisterCompensator(String* progid, String* desc, LONG flags);
    void    ForceLog();
    void    ForgetLogRecord();
    void    ForceTransactionToAbort();
    void    WriteLogRecord(Byte b[]);
    void    Dispose();

    CrmMonitorLogRecords* GetMonitor();
};

__gc private class CrmMonitor
{
private:
    ICrmMonitor* _pMon;
public:
    CrmMonitor();
    
    Object*        GetClerks();
    CrmLogControl* HoldClerk(Object* idx);

    void           AddRef();
    void           Release();
};

}
CLOSE_ROOT_NAMESPACE()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices\utility.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Author: ddriver
// Date: May 2000
//

// So that references to the URT Frameworks Debug class will be compiled in,
// we need to define DEBUG.  (But the URT build only defines _DEBUG, so
// we force it on.)

#if _DEBUG
#define DEBUG
#endif

namespace System.EnterpriseServices
{
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using Microsoft.Win32;
    using System.Resources;
    using System.Text;

    internal class Perf
    {
        private static long _count;
        private static long _freq;

        static Perf()
        {
            bool r = Util.QueryPerformanceFrequency(out _freq);
            DBG.Assert(r, "Hardware does not support perf counter!");
        }

        [System.Diagnostics.Conditional("_DEBUG_PERF")]
        internal static void Tick(String name)
        {
            long _count2;
            bool r = Util.QueryPerformanceCounter(out _count2);
            DBG.Assert(r, "Hardware does not support perf counter!");

            if(_count != 0)
            {
                double delta = ((double)(_count2 - _count))/((double)_freq);

                DBG.Info(DBG.Perf, "PERF: " + name + ": " + delta + " s");
            }
            else
            {
                DBG.Info(DBG.Perf, "PERF: " + name + ": First sample.");
            }
            _count = _count2;
        }
    }

    internal class Util
    {
        internal static readonly int FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
        internal static readonly int FORMAT_MESSAGE_FROM_SYSTEM    = 0x00001000;
        internal static readonly int FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000;

        internal static readonly int  CLSCTX_SERVER = 1 | 4 | 16;

        internal static readonly Guid GUID_NULL = new Guid("00000000-0000-0000-0000-000000000000");
        internal static readonly Guid IID_IUnknown = new Guid("00000000-0000-0000-C000-000000000046");
        internal static readonly Guid IID_IObjectContext = new Guid("51372AE0-CAE7-11CF-BE81-00AA00A2FA25");
        internal static readonly Guid IID_ISecurityCallContext = new Guid("CAFC823E-B441-11D1-B82B-0000F8757E2A");

        internal static readonly int E_FAIL = unchecked((int)(0x80004005));
        internal static readonly int E_ACCESSDENIED = unchecked((int)(0x80070005));
        internal static readonly int E_NOINTERFACE = unchecked((int)(0x80004002));
        internal static readonly int REGDB_E_CLASSNOTREG = unchecked((int)0x80040154);
        internal static readonly int COMADMIN_E_OBJECTERRORS = unchecked((int)(0x80110401));
        internal static readonly int CONTEXT_E_NOCONTEXT = unchecked((int)(0x8004E004));
		internal static readonly int DISP_E_UNKNOWNNAME = unchecked((int)(0x80020006));

        internal static readonly int CONTEXT_E_ABORTED = unchecked((int)(0x8004E002));
        internal static readonly int CONTEXT_E_ABORTING = unchecked((int)(0x8004E003));

        internal static readonly int SECURITY_NULL_SID_AUTHORITY    = 0;
        internal static readonly int SECURITY_WORLD_SID_AUTHORITY   = 1;
        internal static readonly int SECURITY_LOCAL_SID_AUTHORITY   = 2;
        internal static readonly int SECURITY_CREATOR_SID_AUTHORITY = 3;
        internal static readonly int SECURITY_NT_SID_AUTHORITY      = 5;

        internal static readonly int ERROR_SUCCESS         = 0;
        internal static readonly int ERROR_NO_TOKEN        = 0x3F0;

        // Messagebox codes:
        internal static readonly int MB_ABORTRETRYIGNORE = 0x02;
        internal static readonly int MB_ICONEXCLAMATION  = 0x30;

        // Type-lib registration helper!
        [DllImport("oleaut32.dll")]
        internal static extern int LoadTypeLibEx([In, MarshalAs(UnmanagedType.LPWStr)] String str, 
                                               int regKind,
                                               [Out] out IntPtr pptlib);
    
        [DllImport("ole32.dll")]
        internal static extern int
        CoGetObjectContext([MarshalAs(UnmanagedType.LPStruct)]Guid riid, 
                           [MarshalAs(UnmanagedType.Interface)] out Object iface);

        [DllImport("user32.dll")]
        internal static extern int
        MessageBox(int hWnd, String lpText, String lpCaption, int type);
        
        [DllImport("kernel32.dll")]
        internal static extern void OutputDebugString(String msg);

        [DllImport("ole32.dll", PreserveSig=false)]
        internal static extern void
        CoCreateInstance([In, MarshalAs(UnmanagedType.LPStruct)]  Guid rclsid,
                         [In, MarshalAs(UnmanagedType.Interface)] Object punkOuter,
                         [In, MarshalAs(UnmanagedType.I4)]        int dwClsContext,
                         [In, MarshalAs(UnmanagedType.LPStruct)]  Guid riid,
                         [Out, MarshalAs(UnmanagedType.Interface)] out Object iface);

        [DllImport("ole32.dll", PreserveSig=false)]
        internal static extern void
        CLSIDFromProgID([In, MarshalAs(UnmanagedType.LPWStr)] String progID,
                        [Out, MarshalAs(UnmanagedType.Struct)] out Guid riid);
    
        [DllImport("ole32.dll", PreserveSig=false)]
        internal static extern void
        CoGetCallContext([MarshalAs(UnmanagedType.LPStruct)]  Guid riid, 
                         [MarshalAs(UnmanagedType.Interface)] out ISecurityCallContext iface);
     
        [DllImport("advapi32.dll")]
        internal static extern int 
        GetSidIdentifierAuthority([MarshalAs(UnmanagedType.LPArray)] 
                                  byte[] sid);
        [DllImport("advapi32.dll")]
        internal static extern byte 
        GetSidSubAuthorityCount([MarshalAs(UnmanagedType.LPArray)] 
                                byte[] sid);
        [DllImport("advapi32.dll")]
        internal static extern IntPtr
        GetSidSubAuthority([MarshalAs(UnmanagedType.LPArray)] 
                           byte[] sid, int index);

        [DllImport("advapi32.dll")]
        internal static extern int 
        EqualSid([MarshalAs(UnmanagedType.LPArray)] byte[] a,
                 [MarshalAs(UnmanagedType.LPArray)] byte[] b);

        // Type-lib registration helper!
        [DllImport("oleaut32.dll")]
        internal static extern int 
        RegisterTypeLib(IntPtr pptlib, [In, MarshalAs(UnmanagedType.LPWStr)] String str, 
                        [In, MarshalAs(UnmanagedType.LPWStr)] String help);

        [DllImport("oleaut32.dll", PreserveSig=false)]
        internal static extern void UnRegisterTypeLib([In, MarshalAs(UnmanagedType.LPStruct)] Guid libID, 
                                                      short wVerMajor, 
                                                      short wVerMinor, 
                                                      int lcid,
                                                      SYSKIND syskind);

        [DllImport("oleaut32.dll")]
        internal static extern int
        LoadRegTypeLib([In, MarshalAs(UnmanagedType.LPStruct)] Guid lidID, 
                       short wVerMajor, short wVerMinor, int lcid,
                       [Out, MarshalAs(UnmanagedType.Interface)] out Object pptlib);

        [DllImport("kernel32.dll")]
		[return : MarshalAs(UnmanagedType.Bool)]
        internal static extern bool QueryPerformanceCounter(out long count);

        [DllImport("kernel32.dll")]
		[return : MarshalAs(UnmanagedType.Bool)]
        internal static extern bool QueryPerformanceFrequency(out long count);

        [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
        internal static extern int FormatMessage(int dwFlags, IntPtr lpSource,
                                                 int dwMessageId, int dwLanguageId, 
                                                 StringBuilder lpBuffer,
                                                 int nSize, int arguments);

        [DllImport("mtxex.dll")]
        internal static extern IntPtr 
        SafeRef([MarshalAs(UnmanagedType.LPStruct)] Guid riid,
                [MarshalAs(UnmanagedType.Interface)] Object pUnk);

        [DllImport("mtxex.dll", CallingConvention=CallingConvention.Cdecl)]
        internal static extern int 
        GetObjectContext([Out, MarshalAs(UnmanagedType.Interface)] out IObjectContext pCtx);                

        [DllImport("xolehlp.dll", PreserveSig=false)]
        internal static extern void
        DtcGetTransactionManagerEx(int pszHost, 
                                   int pszTmName, 
                                   [In, MarshalAs(UnmanagedType.LPStruct)] Guid iid,
                                   int grfOptions,
                                   int pvConfigParams,
                                   [Out, MarshalAs(UnmanagedType.Interface)] out Object pDisp);
                                   
                                   

        internal static String GetErrorString(int hr)
        {
            System.Text.StringBuilder builder = new System.Text.StringBuilder(1024);
            int res = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |
                                    FORMAT_MESSAGE_FROM_SYSTEM |
                                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    (IntPtr)0,
                                    hr,
                                    0,
                                    builder,
                                    builder.Capacity+1,
                                    0);
            if(res != 0) {
                int i = builder.Length;
                while(i > 0) {
                    char ch = builder[i-1];
                    if(ch > 32 && ch != '.') break;
                    i--;
                }
                return(builder.ToString(0, i));
            }
            return(null);
        }

        internal static Exception GetExceptionForHR(int hr)
        {
            try
            {
                Marshal.ThrowExceptionForHR(hr);
            }
            catch(Exception e)
            {
                return(e);
            }
            // This should never get hit, as ThrowExceptionForHR should 
            // always throw.
            DBG.Assert(false, "ThrowExceptionForHR failed to throw.");
            return(null);
        }

        internal static bool ExtendedLifetime
        {
            get 
            { 
                return((Thunk.Proxy.GetManagedExts() & 0x1) != 0);
            }
        }
    }

    internal enum PlatformFeature
    {
        SWC
    }

    // We need to be able to pass in a platform spec and 
    // throw an exception if the current platform isn't supported.
    // At the top of a method, I'd like to be able to do:
    // Platform.Assert(Platform.MTS, "GetSecurityContext")
    // Platform.Assert(Platform.W2K, "GetCallContext")
    // Platform.Assert(Platform.Whistler, "WhistlerGoo")
    // Platform.Current
    // We can add PlatformTableEntries anytime we add features.
    internal class Platform
    {
        // Static class:
        private Platform() { }

        // Supported platforms.
        internal static Version Current { get { Initialize(); return(_current); } }
        internal static Version MTS1 { get { Initialize(); return(_mts1); } }
        internal static Version MTS { get { Initialize(); return(_mts); } }
        internal static Version W2K { get { Initialize(); return(_w2k); } }
        internal static Version Whistler { get { Initialize(); return(_whistler); } }

        private static Version _mts1;
        private static Version _mts;
        private static Version _w2k;
        private static Version _whistler;
        private static Version _current;
        private static volatile bool _initialized;
        private static Hashtable _features = new Hashtable();

        private static void Initialize()
        {
            if(!_initialized)
            {
                lock(typeof(Platform))
                {
                    if(!_initialized)
                    {
                        IntPtr hToken = IntPtr.Zero;

                        _mts1     = new Version(1, 1);
                        _mts      = new Version(2, 0);
                        _w2k      = new Version(3, 0);
                        _whistler = new Version(4, 0);

                        try
                        {
                            try
                            {
                                // We need to do this as the process, rather than the
                                // impersonation token
                                hToken = Thunk.Security.SuspendImpersonation();
                                
                                Admin.IMtsCatalog c = (Admin.IMtsCatalog)(new Admin.xMtsCatalog());
                                
                                _current = new Version(c.MajorVersion(), c.MinorVersion());
                                DBG.Info(DBG.Platform, "Platform: Current version = " + _current);
                            }
                            catch(COMException e)
                            {
                                DBG.Info(DBG.Platform, "Current platform check failed: " + e);
                                // If e is a ClassNotRegistered exception, we're not
                                // installed at all, so we should note that:
                                _current = new Version(0,0);
                            }
                            finally
                            {
                                Thunk.Security.ResumeImpersonation(hToken);
                            }
                        }
                        catch(Exception) 
                        { 
                            // This is a security precaution.  If there is
                            // unpriveleged code above us, while we have
                            // suspended the impersonation, if an exception
                            // is thrown, a user exception handler could run.
                            // It would run in the unimpersonated context.
                            throw;
                        }
                        _initialized = true;
                    }
                }
            }
        }

        private static void SetFeatureData(PlatformFeature feature, Object value)
        {
            lock(_features)
            {
                if (FindFeatureData(feature) == null)
                    _features.Add(feature, value);
            }
        }

        private static Object FindFeatureData(PlatformFeature feature)
        {
            return _features[feature];
        }

        internal static void Assert(Version platform, String function)
        {
            Initialize();
            if(_current.Major < platform.Major || 
               ((_current.Major == platform.Major) && (_current.Minor < platform.Minor)))
            {
                DBG.Info(DBG.Platform, "Platform: Failed assertion: '" + function + "'");
                DBG.Info(DBG.Platform, "Platform: Required '" + platform + "' when current is '" + _current + "'");
                Assert(false, function);
            }
        }

        internal static void Assert(bool fSuccess, String function)
        {
            if(!fSuccess)
            {
                throw new PlatformNotSupportedException(Resource.FormatString("Err_PlatformSupport", function));
            }
        }

        internal static Object GetFeatureData(PlatformFeature feature)
        {
            Object value = FindFeatureData(feature);            

            if (value != null)
                return value;
                
            switch (feature)
            {
            case PlatformFeature.SWC:
                value = Thunk.SWCThunk.IsSWCSupported();               
                break;

            default:
                DBG.Assert(false, "Unknown feature");
                return null;
            }

            SetFeatureData(feature, value);

            return value;
        }

        internal static bool Supports(PlatformFeature feature)
        {
            return (bool)GetFeatureData(feature);
        }        
        
        // Returns true if the current platform is the supplied platform.
        internal static bool Is(Version platform)
        {
            Initialize();
            return(_current.Major == platform.Major && _current.Minor == platform.Minor);
        }

        internal static bool IsLessThan(Version platform)
        {
            Initialize();
            return(_current.Major < platform.Major ||
                   (_current.Major == platform.Major && _current.Minor < platform.Minor));
        }
    }

    internal class BaseSwitch
    {
        protected int    _value;
        protected String _name;

        internal BaseSwitch(String name)
        {
            RegistryKey key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\COM3\\System.EnterpriseServices");
            _name = name;
            if(key == null) 
            {
                _value = 0;
            }
            else
            {
                Object o = key.GetValue(name);
                if(o != null)
                {
                    _value = (int)o;
                }
            }
        }

        internal int Value { get { return(_value); } }
        internal String Name { get { return(_name); } }
    }

    internal class BooleanSwitch : BaseSwitch
    {
        internal BooleanSwitch(String name)
          : base(name)
        {
        }
         
        internal bool Enabled { get { return(_value != 0); } }
    }

    internal class TraceSwitch : BaseSwitch
    {
        internal TraceSwitch(String name)
          : base(name)
        {
        }

        internal int Level { get { return(_value); } }
    }

	[Serializable]
    internal enum TraceLevel
    {
        None = 0,
        Error = 1,
        Warning = 2,
        Status = 3,
        Info = 4
    }

    internal class DBG
    {
        private static TraceSwitch   _genSwitch;
        private static TraceSwitch   _regSwitch;
        private static TraceSwitch   _platSwitch;
        private static TraceSwitch   _crmSwitch;
        private static TraceSwitch   _perfSwitch;
        private static TraceSwitch   _poolSwitch;
        private static TraceSwitch   _thkSwitch;
        private static TraceSwitch   _scSwitch;
        private static BooleanSwitch _conSwitch;
        private static BooleanSwitch _dbgDisable;
        private static BooleanSwitch _stackSwitch;
        private static volatile bool _initialized;

        public static TraceSwitch General
        {
            get { if(!_initialized) InitDBG(); return(_genSwitch); }
        }

        public static TraceSwitch Registration
        {
            get { if(!_initialized) InitDBG(); return(_regSwitch); }
        }

        public static TraceSwitch Pool
        {
            get { if(!_initialized) InitDBG(); return(_poolSwitch); }
        }

        public static TraceSwitch Platform
        {
            get { if(!_initialized) InitDBG(); return(_platSwitch); }
        }

        public static TraceSwitch CRM
        {
            get { if(!_initialized) InitDBG(); return(_crmSwitch); }
        }

        public static TraceSwitch Perf
        {
            get { if(!_initialized) InitDBG(); return(_perfSwitch); }
        }       

        public static TraceSwitch Thunk
        {
            get { if(!_initialized) InitDBG(); return(_thkSwitch); }
        }

        public static TraceSwitch SC
        {
            get { if(!_initialized) InitDBG(); return(_scSwitch); }
        }

        public static void InitDBG()
        {
            lock(typeof(DBG))
            {
                if(!_initialized)
                {
                    // Create a new TraceSwitch to govern output from
                    // the System.EnterpriseServices assembly:
                    _genSwitch   = new TraceSwitch("General");
                    _platSwitch  = new TraceSwitch("Platform");
                    _regSwitch   = new TraceSwitch("Registration");
                    _crmSwitch   = new TraceSwitch("CRM");
                    _perfSwitch  = new TraceSwitch("PerfLog");
                    _poolSwitch  = new TraceSwitch("ObjectPool");
                    _thkSwitch   = new TraceSwitch("Thunk");
                    _scSwitch    = new TraceSwitch("ServicedComponent");
                    _conSwitch   = new BooleanSwitch("ConsoleOutput");
                    _dbgDisable  = new BooleanSwitch("DisableDebugOutput");
                    _stackSwitch = new BooleanSwitch("PrintStacks");
                    _initialized = true;
                }
            }
        }

        public static void RetailTrace(String msg)
        {
            Util.OutputDebugString(TID() + ": " + msg + "\n");
        }

        private static int TID()
        {
            return(System.Threading.Thread.CurrentThread.GetHashCode());
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        public static void Trace(TraceLevel level, TraceSwitch sw, String msg)
        {
            if(!_initialized) InitDBG();

            bool enabled = (sw.Level != 0 && sw.Level >= (int)level);
            if(enabled)
            {                   
                String full = TID() + ": " + sw.Name + ": " + msg;

                if(_stackSwitch.Enabled)
                {
                    full += (new System.Diagnostics.StackTrace(2)).ToString();
                }

                if(_conSwitch.Enabled)   Console.WriteLine(full);
                if(!_dbgDisable.Enabled) Util.OutputDebugString(full + "\n");
            }
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        public static void Info(TraceSwitch sw, String msg)
        {
            Trace(TraceLevel.Info, sw, msg);
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        public static void Status(TraceSwitch sw, String msg)
        {
            Trace(TraceLevel.Status, sw, msg);
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        public static void Warning(TraceSwitch sw, String msg)
        {
            Trace(TraceLevel.Warning, sw, msg);
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        public static void Error(TraceSwitch sw, String msg)
        {
            Trace(TraceLevel.Error, sw, msg);
        }

        private static void DoAssert(String msg, String detail)
        {
            System.Diagnostics.StackTrace trace = new System.Diagnostics.StackTrace();
            String full = msg + "\n\n" + detail + "\n" + trace + "\n\nPress RETRY to launch a debugger.";
            String header = "ALERT: System.EnterpriseServices,  TID=" + TID();
            
            Util.OutputDebugString(header + "\n\n" + full);
            if(!System.Diagnostics.Debugger.IsAttached)
            {
                int r = Util.MessageBox(0, full, header,
                                        Util.MB_ABORTRETRYIGNORE|Util.MB_ICONEXCLAMATION);
                
                if(r == 3) 
                {
                    System.Environment.Exit(1);
                }
                else if(r == 4)
                {
                    if(!System.Diagnostics.Debugger.IsAttached)
                    {
                        System.Diagnostics.Debugger.Launch();
                    }
                    else
                    {
                        System.Diagnostics.Debugger.Break();
                    }
                }
                else if(r == 5) {} // Ignore 
            }
            else
            {
                System.Diagnostics.Debugger.Break();
            }
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        public static void Assert(bool cond, String msg)
        {
            if(!_initialized) InitDBG();
            if(!cond)
            {
                DoAssert("Assertion failed", msg);
            }
        }

        [System.Diagnostics.Conditional("_DEBUG")]
        public static void Assert(bool cond, String msg, String detail)
        {
            if(!_initialized) InitDBG();
            if(!cond)
            {
                DoAssert("Assertion failed", msg + "\n\nDetail: " + detail);
            }
        }
    }

    // Usage:
    // throw new RegistrationException(Resource.GetString(""));
    // throw new RegistrationException(Resource.GetString("", a1, a2));
    internal class Resource
    {
        // For string resources located in a file:
        private static ResourceManager _resmgr;
        
        private static void InitResourceManager()
        {
            if(_resmgr == null)
            {
                _resmgr = new ResourceManager("System.EnterpriseServices", 
                                              typeof(Resource).Module.Assembly);
            }
        }

        internal static String GetString(String key)
        {
            InitResourceManager();
            String s = _resmgr.GetString(key, null);
            DBG.Assert(s != null, "The resource \"" + key + "\" could not be found.",
                       "Please check to make sure that the resource name is spelled correctly, and that such a resource exists in resources.txt");
            return(s);
        }

        internal static String FormatString(String key)
        {
            return(GetString(key));
        }

        internal static String FormatString(String key, Object a1)
        {
            return(String.Format(GetString(key), a1));
        }

        internal static String FormatString(String key, Object a1, Object a2)
        {
            return(String.Format(GetString(key), a1, a2));
        }

        internal static String FormatString(String key, Object a1, Object a2, Object a3)
        {
            return(String.Format(GetString(key), a1, a2, a3));
        }

        internal static String FormatString(String key, Object[] a)
        {
            return(String.Format(GetString(key), a));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\dbg.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// BUGBUG: This is a hack to get access to the debug facilities in 
// System.EnterpriseServices.  It should later be revisited in order
// to figure out how to make it right, so that we don't have this horrible
// hack in place.

OPEN_NAMESPACE()

using namespace System;
using namespace System::Reflection;
using namespace System::Runtime::InteropServices;

#ifdef _DEBUG

__gc private class __WrapDBG
{
private:
    static void Init()
    {
        if(_dbg == NULL)
        {
            Type* t = Type::GetType("System.EnterpriseServices.DBG");
            _ASSERTM(t != NULL);

            _info = t->GetMethod("Info");
            _ASSERTM(_info != NULL);
            
            MethodInfo* thunk = t->GetMethod("get_Thunk");
            _ASSERTM(thunk != NULL);

            Object __gc* arr[] = new Object*[0];

            _switch = thunk->Invoke(NULL, arr);
            _dbg = t;
        }
    }

    static MethodInfo* _info;
    static Object*     _switch;
    static Type*       _dbg;

public:
    static void Info(String* s)
    {
        Init();
        Object* arr[] = { _switch, s };

        _info->Invoke(NULL, arr);
    }
};

#define DBG_INFO(x) System::EnterpriseServices::Thunk::__WrapDBG::Info(x)
#else
#define DBG_INFO(x) do {} while(0)
#endif

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\defines.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CustomMarshalersDefines.h
//
// This file provides standard defines used in defining custom marshalers.
//
//*****************************************************************************

#ifndef _DEFINES_H
#define _DEFINES_H

// #ifndef __UNMANAGED_DEFINES
// #define __IServiceProvider_FWD_DEFINED__
// #endif

// Helper function for dealing with HRESULTS.
#define IfFailThrow(ErrorCode)                      \
do {                                                \
    if (FAILED((ErrorCode)))                        \
        Marshal::ThrowExceptionForHR(ErrorCode);    \
} while(0)

// Undefine symbols defined in windows.h that conflict with ones defined in the classlibs.
#undef GetObject
#undef lstrcpy


#ifdef _WIN64
#define TOINTPTR(x) ((IntPtr)(INT64)(x))
#define TOPTR(x) ((void*)(x).ToInt64())
#else
#define TOINTPTR(x) ((IntPtr)(INT32)(x))
#define TOPTR(x) ((void*)(x).ToInt32())
#endif

#define THROWERROR(hrexp)                                       \
do {                                                            \
    HRESULT __thaxxfahr = (hrexp);                              \
    if(FAILED(__thaxxfahr))                                     \
    {                                                           \
        try                                                     \
        {                                                       \
            Marshal::ThrowExceptionForHR(__thaxxfahr);          \
        }                                                       \
        catch(Exception* pE)                                    \
        {                                                       \
            throw pE;                                           \
        }                                                       \
    }                                                           \
} while(0)

#include "assert.h"

#endif  _CUSTOMMARSHALERSDEFINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\ctxtcall.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for ctxtcall.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ctxtcall_h__
#define __ctxtcall_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IContextCallback_FWD_DEFINED__
#define __IContextCallback_FWD_DEFINED__
typedef interface IContextCallback IContextCallback;
#endif 	/* __IContextCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ctxtcall_0000 */
/* [local] */ 

typedef struct tagComCallData
    {
    DWORD dwDispid;
    DWORD dwReserved;
    void *pUserDefined;
    } 	ComCallData;



extern RPC_IF_HANDLE __MIDL_itf_ctxtcall_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctxtcall_0000_v0_0_s_ifspec;

#ifndef __IContextCallback_INTERFACE_DEFINED__
#define __IContextCallback_INTERFACE_DEFINED__

/* interface IContextCallback */
/* [unique][uuid][object][local] */ 

typedef /* [ref] */ HRESULT ( __stdcall *PFNCONTEXTCALL )( 
    ComCallData *pParam);


EXTERN_C const IID IID_IContextCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("000001da-0000-0000-C000-000000000046")
    IContextCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ContextCallback( 
            /* [in] */ PFNCONTEXTCALL pfnCallback,
            /* [in] */ ComCallData *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ int iMethod,
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IContextCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IContextCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IContextCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ContextCallback )( 
            IContextCallback * This,
            /* [in] */ PFNCONTEXTCALL pfnCallback,
            /* [in] */ ComCallData *pParam,
            /* [in] */ REFIID riid,
            /* [in] */ int iMethod,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } IContextCallbackVtbl;

    interface IContextCallback
    {
        CONST_VTBL struct IContextCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextCallback_ContextCallback(This,pfnCallback,pParam,riid,iMethod,pUnk)	\
    (This)->lpVtbl -> ContextCallback(This,pfnCallback,pParam,riid,iMethod,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IContextCallback_ContextCallback_Proxy( 
    IContextCallback * This,
    /* [in] */ PFNCONTEXTCALL pfnCallback,
    /* [in] */ ComCallData *pParam,
    /* [in] */ REFIID riid,
    /* [in] */ int iMethod,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IContextCallback_ContextCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextCallback_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\i386.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Various helper routines for generating x86 assembly code.
//
//

#ifndef _X86_
#error Should only include "i386.h" for X86 builds
#endif

#ifndef __cgencpu_h__
#define __cgencpu_h__

// Access to the TEB (TIB) from nti386.h
#if defined(MIDL_PASS) || !defined(_M_IX86)
struct _TEB *
NTAPI
NtCurrentTeb( void );
#else
#pragma warning (disable:4035)        // disable 4035 (function must return something)
#define PcTeb 0x18
_inline struct _TEB * NtCurrentTeb( void ) { __asm mov eax, fs:[PcTeb] }
#pragma warning (default:4035)        // reenable it
#endif // defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)

#endif // __cgenx86_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\ia64.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENCPU.H -
//
// Various helper routines for generating IA64 assembly code.
//
// DO NOT INCLUDE THIS FILE DIRECTLY - ALWAYS USE CGENSYS.H INSTEAD
//


#ifndef _IA64_
#error Should only include "ia64.h" for IA64 builds
#endif

#ifndef __cgencpu_h__
#define __cgencpu_h__

// Teb access from ntia64.h
#if !defined(__midl) && !defined(GENUTIL) && !defined(_GENIA64_) && defined(_IA64_)

// Please contact INTEL to get IA64-specific information
// @@BEGIN_DDKSPLIT
void * _cdecl _rdteb(void);
#if defined(_M_IA64)                    // winnt
#pragma intrinsic(_rdteb)               // winnt
#endif                                  // winnt
#define NtCurrentTeb()      ((struct _TEB *)_rdteb())
// @@END_DDKSPLIT

//
// Define functions to get the address of the current fiber and the
// current fiber data.
//

#define GetCurrentFiber() (((PNT_TIB)NtCurrentTeb())->FiberData)
#define GetFiberData() (*(PVOID *)(GetCurrentFiber()))

#endif  // !defined(__midl) && !defined(GENUTIL) && !defined(_GENIA64_) && defined(_M_IA64)

#endif // __cgencpu_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\headers.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma warning(disable : 4800)
#pragma warning(disable : 4127)
#pragma warning(disable : 4100)

#include <windows.h>
#include <ole2.h>
#include <objbase.h>
#include <winerror.h>
#include <winnt.h>
#include "oletls.h"
#include "namespace.h"
#include "defines.h"

OPEN_NAMESPACE()
#include <mtx.h>
#include "ctxtcall.h"
#include "svcintfs.h"
CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\managedheaders.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "managedheaders.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\managedheaders.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "headers.h"
#using <mscorlib.dll>
#include "DBG.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\makefile.inc ===
#
# Makefile for EnterpriseServices.Thunk

BASE_OPT=-base:@$(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\coffbase.txt,$(MINORCOMP)

# If one of these commands fails, notice it.
!CMDSWITCHES -I

!ifdef THUNK_RESOURCE_FILE
{$(THUNK_SOURCE_DIR)}.rc{}.res:
#    type <<$(ECHO_RSP)
#    $(RC_COMPILER) -r -fo $(@R).tmp $(CDEFINES) $(INCPATH0) $<
#<<NOKEEP
    set _oldinclude=$(include)
    set include=$(INCPATHRC)
    $(RC_COMPILER) -r -fo $(@R).tmp $(CDEFINERC) $<
    set include=$(_oldinclude)
    set _oldinclude=
    $(MANAGED_VCDIR)\cvtres -nologo -machine:IX86 -readonly -out:$@ $(@R).tmp
    erase $(@R).tmp
!endif

MANAGED_PCH_FILE = $(O)\managedheaders.pch
UNMANAGED_PCH_FILE = $(O)\unmanagedheaders.pch

OBJ_FILES = \
	$(O)\Thunk.obj		\
	$(O)\SecurityThunk.obj	\
	$(O)\ProxyThunk.obj	\
	$(O)\SimpleStream.obj	\
	$(O)\ContextAPI.obj	\
	$(O)\CrmThunk.obj	\
	$(O)\assert.obj		\
	$(O)\SWCThunk.obj	\
	$(O)\DelayLoad.obj \
	$(O)\TxnStatus.obj		

PCH_OBJ_FILES = \
	$(O)\managedheaders.obj	\
	$(O)\unmanagedheaders.obj

!if "$(OS)" == "Windows_NT"
SYSTEMDIR=$(WINDIR)\system32
!else
SYSTEMDIR=$(WINDIR)\system
!endif

CLR_TARGET_PATH=$(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)

MSCOREE_TARGET=$(SYSTEMDIR)\mscoree.dll
MSCOREE_TARGET_LIB = $(CLR_TARGET_PATH)\mscoree.lib

DELAY_LOAD_TARGET_LIBS=$(CLR_TARGET_PATH)\DelayImp.lib

!IF "$(DDKBUILDENV)" == "checked" || "$(DDKBUILDENV)" == "fastchecked"
C_COMP_FLAGS = /D_WIN32_DCOM /d1PrivateNativeTypes $(C_DEFINES) /nologo /GX /W4 /WX /Bx$(MANAGED_VCDIR)\c1xx.dll /B2$(MANAGED_VCDIR)\c2.dll /c /Zi  /I $(SDK_INC_PATH) /I $(CRT_INC_PATH) /I $(CORBASE)\src\inc\version /I $(CORBASE)\src\inc
!ELSE
C_COMP_FLAGS = /D_WIN32_DCOM /d1PrivateNativeTypes $(C_DEFINES) /nologo /GX /W4 /WX /Bx$(MANAGED_VCDIR)\c1xx.dll /B2$(MANAGED_VCDIR)\c2.dll /c /I $(SDK_INC_PATH) /I $(CRT_INC_PATH) /I $(CORBASE)\src\inc\version /I $(CORBASE)\src\inc
!ENDIF

MANAGED_FLAGS = /Yumanagedheaders.h /Fp$(MANAGED_PCH_FILE) /clr
UNMANAGED_FLAGS = /Yuunmanagedheaders.h /Fp$(UNMANAGED_PCH_FILE)

SHARED_INC= \
    namespace.h \
    defines.h \
    assert.h \
    DBG.h \

$(O)\managedheaders.obj: $(MSCOREE_TARGET) managedheaders.cpp managedheaders.h $(SHARED_INC)
	$(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /clr /Ycmanagedheaders.h /Fp$(MANAGED_PCH_FILE) /Fo$(O)\managedheaders.obj managedheaders.cpp

$(O)\unmanagedheaders.obj: $(MSCOREE_TARGET) unmanagedheaders.cpp unmanagedheaders.h $(SHARED_INC)
	$(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) /Ycunmanagedheaders.h /Fp$(UNMANAGED_PCH_FILE) /Fo$(O)\unmanagedheaders.obj unmanagedheaders.cpp

$(O)\Thunk.obj: $(MSCOREE_TARGET) Thunk.cpp
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(MANAGED_FLAGS) /Fo$(O)\Thunk.obj Thunk.cpp

$(O)\SecurityThunk.obj: $(MSCOREE_TARGET) SecurityThunk.cpp SecurityThunk.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(MANAGED_FLAGS) /Fo$(O)\SecurityThunk.obj SecurityThunk.cpp

$(O)\ProxyThunk.obj: $(MSCOREE_TARGET) ProxyThunk.cpp ProxyThunk.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(MANAGED_FLAGS) /Fo$(O)\ProxyThunk.obj ProxyThunk.cpp

$(O)\CrmThunk.obj: $(MSCOREE_TARGET) CrmThunk.cpp CrmThunk.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(MANAGED_FLAGS) /Fo$(O)\CrmThunk.obj CrmThunk.cpp

$(O)\SimpleStream.obj: $(MSCOREE_TARGET) SimpleStream.cpp SimpleStream.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(UNMANAGED_FLAGS) /Fo$(O)\SimpleStream.obj SimpleStream.cpp

$(O)\ContextAPI.obj: $(MSCOREE_TARGET) ContextAPI.cpp ContextAPI.h oletls.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(UNMANAGED_FLAGS) /Fo$(O)\ContextAPI.obj ContextAPI.cpp

$(O)\DelayLoad.obj: $(MSCOREE_TARGET) DelayLoad.cpp
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(UNMANAGED_FLAGS) /Fo$(O)\DelayLoad.obj DelayLoad.cpp

$(O)\assert.obj: $(MSCOREE_TARGET) assert.cpp assert.h
        $(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(UNMANAGED_FLAGS) /Fo$(O)\assert.obj assert.cpp

$(O)\SWCThunk.obj: $(MSCOREE_TARGET) SWCThunk.cpp SWCThunk.h
	$(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(MANAGED_FLAGS) /Fo$(O)\SWCThunk.obj SWCThunk.cpp

$(O)\TxnStatus.obj: $(MSCOREE_TARGET) TxnStatus.cpp TxnStatus.h
	$(MANAGED_VCDIR)\cl $(C_COMP_FLAGS) $(UNMANAGED_FLAGS) /Fo$(O)\TxnStatus.obj TxnStatus.cpp

UNMGD_LIBS= \
    $(SDK_LIB_PATH)\msvcrt$(DCRT).lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\ole32.lib \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\uuid.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib \
    $(MSCOREE_TARGET_LIB) \
	$(DELAY_LOAD_TARGET_LIBS) \
    ..\EnterpriseServicesPS\$(O)\dlldata.obj \
    ..\EnterpriseServicesPS\$(O)\entsvcps.obj \
    ..\EnterpriseServicesPS\$(O)\entsvcps_i.obj \
    ..\EnterpriseServicesPS\$(O)\entsvcps_p.obj


LINK_FLAGS = /SAFESEH /nologo /nodefaultlib /DLL /NOASSEMBLY /NOENTRY /DEF:thunk.def $(BASE_OPT)

# Delay load the CRT - look at the delay-load goo in DelayImp and ShimLoad
# LINK_FLAGS = $(LINK_FLAGS) /DELAYLOAD:msvcr71$(DCRT).dll

!IF "$(DDKBUILDENV)" == "checked" || "$(DDKBUILDENV)" == "fastchecked"
LINK_FLAGS = $(LINK_FLAGS) /debug
!ELSE
LINK_FLAGS = $(LINK_FLAGS) /debug
!ENDIF

$(OBJ_FILES): $(PCH_OBJ_FILES)

$(TARGETNAME): $(MSCOREE_TARGET) $(OBJ_FILES) $(THUNK_RESOURCE_FILE:.rc=.res)
        $(MANAGED_VCDIR)\link $(LINK_FLAGS) $(OBJ_FILES) $(PCH_OBJ_FILES) .\System.EnterpriseServices.Thunk.res /OUT:$(TARGETPATH)\System.EnterpriseServices.Thunk.dll $(UNMGD_LIBS)
        validate_thunks $(TARGETNAME) $(O)\System.EnterpriseServices.Thunk.il

        set COPYCMD=/Y

# Copy it to the COM+ target directory.
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\System.EnterpriseServices.Thunk.dll $(TARGETCOMPLUS)
	copy entsvcps.reg $(TARGETCOMPLUS)
	copy entsvcpsVersion.reg $(TARGETCOMPLUS)
!if "$(DDKBUILDENV)" == "checked" || "$(DDKBUILDENV)" == "fastchecked"
        copy $(TARGETPATH)\System.EnterpriseServices.Thunk.pdb $(TARGETCOMPLUS)
!elseif "$(DDKBUILDENV)" == "bbt"
        binplace -R $(URTTARGET) -S $(URTTARGET)\Symbols -x -n $(URTTARGET)\Symbols.pri -y -W -f -P $(TARGETPATH)\placefil.txt $(TARGETPATH)\System.EnterpriseServices.Thunk.dll
        copy $(URTTARGET)\System.EnterpriseServices.Thunk.dll $(TARGETPATH)
!endif
!endif

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\System.EnterpriseServices.Thunk.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\namespace.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CustomMarshalersNameSpaceDef.h
//
// This file defines the namespace for the custom marshalers.
//
//*****************************************************************************

#ifndef _NAMESPACE_H
#define _NAMESPACE_H

#define OPEN_NAMESPACE()	                \
namespace System {							\
	namespace EnterpriseServices {			\
    	namespace Thunk {

#define CLOSE_NAMESPACE()	                \
        }                                   \
	}										\
}	

#define OPEN_ROOT_NAMESPACE()               \
namespace System {							\
	namespace EnterpriseServices {

#define CLOSE_ROOT_NAMESPACE()               \
	}										\
}	

										

#endif  _NAMESPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\delayload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "unmanagedheaders.h"
#include <delayimp.h>
#include <malloc.h>

#include <version\__official__.ver>

#define CRT_DLL L"msvcr71.dll"

typedef HRESULT (WINAPI* LoadLibraryShimFTN)(LPCWSTR szDllName,
                                             LPCWSTR szVersion,
                                             LPVOID pvReserved,
                                             HMODULE *phModDll);

static HRESULT LoadLibraryShim(LPCWSTR szDllName, LPCWSTR szVersion, LPVOID pvReserved, HMODULE *phModDll)
{
	static LoadLibraryShimFTN pLLS=NULL;
	if (!pLLS)
	{
		HMODULE hmod = GetModuleHandle("mscoree.dll");

        // Assert now to catch anyone using this code without mscoree loaded.
        // It's okay if we don't hold a reference, cause we have a strong
        // link to mscoree.
		_ASSERT (hmod && "mscoree.dll is not yet loaded");
		pLLS=(LoadLibraryShimFTN)::GetProcAddress(hmod, "LoadLibraryShim");
        
	}

    if (!pLLS)
        return E_POINTER;
	return pLLS(szDllName,szVersion,pvReserved,phModDll);
}

HMODULE LoadCRT()
{
    static HMODULE _hModCRT = NULL;

    if(_hModCRT == NULL)
    {
        // Try to get the DLL from our normal context first.
        // If we can't, then we need to fall back to the versioned install
        // directory.
        HMODULE result = LoadLibraryW(CRT_DLL);
        if(result == NULL)
        {
			WCHAR* wszVersion = (WCHAR*)_alloca(sizeof(WCHAR)*64);
            wsprintfW(wszVersion, L"v%d.%d.%d", COR_BUILD_YEAR, COR_BUILD_MONTH, COR_OFFICIAL_BUILD_NUMBER );
			
            if (FAILED(LoadLibraryShim(CRT_DLL,wszVersion,NULL,&result)))
            {
                result=NULL;
            }
        }
        if(result != NULL)
        {
            _hModCRT = result;
        }
    }

    // Error case:
    if(_hModCRT == NULL)
    {
        OutputDebugStringW(L"System.EnterpriseServices.Thunk.dll - failed to load CRT.");
        RaiseException(ERROR_MOD_NOT_FOUND,
                       0,
                       0,
                       NULL
                       );
    }
    
    return _hModCRT;
}

extern "C"
{

#define DO_LOAD(function) \
    static function##_FN pfn = NULL;                \
                                                    \
    if(pfn == NULL)                                 \
    {                                               \
        pfn = (function##_FN)GetProcAddress(LoadCRT(), #function); \
        if(pfn == NULL)                             \
        {                                           \
            OutputDebugStringW(L"System.EnterpriseServices.Thunk.dll - failed to load required CRT function."); \
            RaiseException(ERROR_PROC_NOT_FOUND,    \
                           0,                       \
                           0,                       \
                           NULL                     \
                           );                       \
        }                                           \
    }                                               \
    do {} while(0)


// Wrap up the list of functions we use from the CRT in a delay-load
// form.  
//
// We have to delay-load this set of functions, because we sometimes
// have to find the CRT in a place outside the search path. (say, when
// we get loaded into an RTM CLR process - that process doesn't have
// msvcr71 in the search path, just msvcr70
//
// If a new dependency is introduced, then we'll see a build break caused
// by validate_thunks.cmd

// We shouldn't introduce a dependency on anything with a mangled name,
// if we do, we'll probably have to modify this scheme.

typedef int (__cdecl *memcmp_FN)(const void*, const void*, size_t);
int __cdecl memcmp(const void *p1, const void *p2, size_t s)
{
    DO_LOAD(memcmp);
    return pfn(p1, p2, s);
}

typedef void* (__cdecl *memcpy_FN)(void *, const void *, size_t);
void* __cdecl memcpy(void* p1, const void* p2, size_t s)
{
    DO_LOAD(memcpy);
    return pfn(p1, p2, s);
}

typedef int (__cdecl *__CxxDetectRethrow_FN)(void* p);
int __cdecl __CxxDetectRethrow(void* p)
{
    DO_LOAD(__CxxDetectRethrow);
    return pfn(p);
}

typedef void (__cdecl *__CxxUnregisterExceptionObject_FN)(void *,int);
void __cdecl __CxxUnregisterExceptionObject(void *p,int i)
{
    DO_LOAD(__CxxUnregisterExceptionObject);
    pfn(p, i);
}

typedef void (__stdcall *_CxxThrowException_FN)(void *,struct _s__ThrowInfo const *);
void __stdcall _CxxThrowException(void *p1,struct _s__ThrowInfo const *p2)
{
    DO_LOAD(_CxxThrowException);
    return pfn(p1, p2);
}

typedef int (__cdecl *__CxxRegisterExceptionObject_FN)(void *,void *);
int __cdecl __CxxRegisterExceptionObject(void *p1,void *p2)
{
    DO_LOAD(__CxxRegisterExceptionObject);
    return pfn(p1, p2);
}

typedef int (__cdecl *__CxxQueryExceptionSize_FN)(void);
int __cdecl __CxxQueryExceptionSize(void)
{
    DO_LOAD(__CxxQueryExceptionSize);
    return pfn();
}

typedef int (__cdecl *__CxxExceptionFilter_FN)(void *,void *,int,void *);
int __cdecl __CxxExceptionFilter(void *p1,void *p2,int i,void *p3)
{
    DO_LOAD(__CxxExceptionFilter);
    return pfn(p1, p2, i, p3);
}

typedef EXCEPTION_DISPOSITION (__cdecl *__CxxFrameHandler_FN)(void *, void *, void *, void *);
EXCEPTION_DISPOSITION __cdecl __CxxFrameHandler(void *p1, void *p2, void *p3, void *p4)
{
    DO_LOAD(__CxxFrameHandler);
    return pfn(p1, p2, p3, p4);
}

typedef void (__cdecl *_local_unwind2_FN)(void*, int); 
void __cdecl _local_unwind2(void* p, int i)
{
    DO_LOAD(_local_unwind2);
    pfn(p, i);
}

typedef EXCEPTION_DISPOSITION (__cdecl *_except_handler3_FN)(void* p1, void* p2, void* p3, void* p4);
EXCEPTION_DISPOSITION __cdecl _except_handler3(void* p1, void* p2, void* p3, void* p4)
{
    DO_LOAD(_except_handler3);
    return pfn(p1, p2, p3, p4);
}

// Only in checked builds...
typedef int (__cdecl *_vsnwprintf_FN)(wchar_t *, size_t, wchar_t*, va_list);
int __cdecl _snwprintf(wchar_t* buf, size_t cch, wchar_t* fmt, ...)
{
    DO_LOAD(_vsnwprintf);
    
    va_list va;
    va_start(va, fmt);
    int r = pfn(buf, cch, fmt, va);
    va_end(va);
    return r;
}

typedef void* (__cdecl *_CRT_RTC_INIT_FN)(void*, void**, int, int, int);
void* __cdecl _CRT_RTC_INIT(void *res0, void **res1, int res2, int res3, int res4)
{
    DO_LOAD(_CRT_RTC_INIT);
    return pfn(res0, res1, res2, res3, res4);
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\oletls.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  File:       tls.hxx
//
//  Purpose:    manage thread local storage for OLE
//
//  Notes:      The gTlsIndex is initialized at process attach time.
//              The per-thread data is allocated in CoInitialize in
//              single-threaded apartments or on first use in
//              multi-threaded apartments.
//
//----------------------------------------------------------------------------
#ifndef _TLS_HXX_
#define _TLS_HXX_

#include "rpc.h"

#ifdef _IA64_
//#include <ntia64.h> // @TODO: Inclusion of this header causes redef's
#define GDT_ENTRIES 24
#endif

//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

class  CAptCallCtrl;                        // see callctrl.hxx
class  CSrvCallState;                       // see callctrl.hxx
class  CObjServer;                          // see sobjact.hxx
class  CSmAllocator;                        // see stg\h\smalloc.hxx
class  CMessageCall;                        // see call.hxx
class  CClientCall;                         // see call.hxx
class  CAsyncCall;                          // see call.hxx
class  CClipDataObject;                     // see ole232\clipbrd\clipdata.h
class  CSurrogatedObjectList;               // see com\inc\comsrgt.hxx
class  CCtxCall;                            // see PSTable.hxx
class  CPolicySet;                          // see PSTable.hxx
class  CObjectContext;                      // see context.hxx
class  CComApartment;                       // see aprtmnt.hxx

//+-------------------------------------------------------------------
//
//  Struct:     CallEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
typedef struct tagCallEntry
{
    void  *pNext;        // ptr to next entry
    void  *pvObject;     // Entry object
} CallEntry;

#define LOCKS_PER_ENTRY         16
typedef struct tagLockEntry
{
    tagLockEntry  *pNext;                // ptr to next entry
    WORD wReaderLevel[LOCKS_PER_ENTRY];  // reader nesting level
} LockEntry;

//+---------------------------------------------------------------------------
//
//  Enum:       OLETLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SOleTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData
{
#if !defined(_CHICAGO_)
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    CSmAllocator       *pSmAllocator;       // per thread docfile allocator
#endif
    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    CMessageCall       *pCallInfo;          // channel call info
    CAsyncCall         *pFreeAsyncCall;     // ptr to available call object for this thread.
    CClientCall        *pFreeClientCall;    // ptr to available call object for this thread.

    CObjServer         *pObjServer;         // Activation Server Object for this apartment.
    DWORD               dwTIDCaller;        // TID of current calling app
    CObjectContext     *pCurrentCtx;        // Current context
    CObjectContext     *pEmptyCtx;          // Empty context

    CObjectContext     *pNativeCtx;         // Native context
    CComApartment      *pNativeApt;         // Native apartment for the thread.
    IUnknown           *pCallContext;       // call context object
    CCtxCall           *pCtxCall;           // Context call object

    CPolicySet         *pPS;                // Policy set
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    CAptCallCtrl       *pCallCtrl;          // call control for RPC for this apartment

    CSrvCallState      *pTopSCS;            // top server-side callctrl state
    IMessageFilter     *pMsgFilter;         // temp storage for App MsgFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call
    ULONG               cPreRegOidsAvail;   // count of server-side OIDs avail
    unsigned hyper     *pPreRegOids;        // ptr to array of pre-reg OIDs

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    IUnknown           *pAsyncRelease;      // Controlling unknown for async release
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    IDataObject         *pDataObjClip;      // Current Clipboard DataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    IUnknown            *punkState;         // Per thread "state" object
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    CAsyncCall*           pAsyncCallList;   // async calls outstanding
    CSurrogatedObjectList *pSurrogateList;  // Objects in the surrogate

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

#ifdef WX86OLE
    IUnknown           *punkStateWx86;      // Per thread "state" object for Wx86
#endif
    void               *pDragCursors;       // Per thread drag cursor table.

#ifdef _CHICAGO_
    LPVOID              pWcstokContext;     // Scan context for wcstok
#endif

    IUnknown           *punkError;          // Per thread error object.
    ULONG               cbErrorData;        // Maximum size of error data.

#if(_WIN32_WINNT >= 0x0500)
    IUnknown           *punkActiveXSafetyProvider;
#endif //(_WIN32_WINNT >= 0x0500)

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif

} SOleTlsData;



#ifndef _NTPSAPI_

#ifndef _NTDEF_
#include <subauth.h>
#endif

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;


//
// Gdi command batching
//

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG Offset;
    ULONG HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH,*PGDI_TEB_BATCH;


//
// Wx86 thread state information
//

typedef struct _Wx86ThreadState {
    PULONG  CallBx86Eip;
    PVOID   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD, *PWX86THREAD;

//
//  TEB - The thread environment block
//

#define STATIC_UNICODE_BUFFER_LENGTH 261
#define WIN32_CLIENT_INFO_LENGTH 62
#define WIN32_CLIENT_INFO_SPIN_COUNT 1

typedef struct _TEB {
    NT_TIB NtTib;
    PVOID  EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    LPVOID ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;          // PtiCurrent
    ULONG User32Reserved[26];       // user32.dll items
    ULONG UserReserved[5];          // Winsrv SwitchStack
    PVOID WOW32Reserved;            // used by WOW
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister; // offset known by outsiders!
#ifdef _IA64_
    ULONGLONG Gdt[GDT_ENTRIES];         // Provide Gdt table entries
    ULONGLONG GdtDescriptor;
    ULONGLONG LdtDescriptor;
    ULONGLONG FsDescriptor;
#else  // _IA64_
    PVOID SystemReserved1[54];      // Used by FP emulator
#endif // _IA64_
    NTSTATUS ExceptionCode;         // for RaiseUserException
    UCHAR SpareBytes1[44];
    GDI_TEB_BATCH GdiTebBatch;      // Gdi batching
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH];    // User32 Client Info
    PVOID glDispatchTable[233];     // OpenGL
    ULONG glReserved1[29];          // OpenGL
    PVOID glReserved2;              // OpenGL
    PVOID glSectionInfo;            // OpenGL
    PVOID glSection;                // OpenGL
    PVOID glTable;                  // OpenGL
    PVOID glCurrentRC;              // OpenGL
    PVOID glContext;                // OpenGL
    ULONG LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
#ifdef  _IA64_
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    PVOID DeallocationStack;
    PVOID TlsSlots[TLS_MINIMUM_AVAILABLE];
    LIST_ENTRY TlsLinks;
    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];
    ULONG HardErrorsAreDisabled;
    PVOID Instrumentation[16];
    PVOID WinSockData;              // WinSock
    ULONG GdiBatchCount;
    ULONG Spare2;
    ULONG Spare3;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WX86THREAD Wx86Thread;
    PVOID *TlsExpansionSlots;
} TEB;
typedef TEB *PTEB;
#endif

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

DEFINE_OLEGUID(IID_IStdIdentity,        0x0000001bL, 0, 0);
DEFINE_OLEGUID(IID_IStdWrapper,         0x000001caL, 0, 0);

#if defined(_X86_)
#include "i386.h"
#elif defined(_IA64_)
#include "ia64.h"
#else
#error Unknown compilation platform, update oletls.h for NtCurrentTeb.
#endif

#endif // _TLS_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\proxythunk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _PROXYTHUNK_H
#define _PROXYTHUNK_H

OPEN_NAMESPACE()

using namespace System;
using namespace System::Reflection;
using namespace System::Runtime::InteropServices;
using namespace System::Runtime::Remoting;
using namespace System::Runtime::Remoting::Messaging;
using namespace System::Collections;
using namespace System::Threading;

typedef struct tagComCallData2
{
    ComCallData    CallData;
    PFNCONTEXTCALL RealCall;
} ComCallData2;


__delegate HRESULT ContextCallbackFunction(ComCallData* pData);
    
typedef HRESULT (__cdecl *FN_CoGetContextToken)(ULONG_PTR* ptr);

[DllImport("kernel32.dll")]
PFNCONTEXTCALL lstrcpynW(ContextCallbackFunction* a, ContextCallbackFunction* b, IntPtr maxlength);

// Define a quick interface between us and the registration helper:
__gc private __interface IThunkInstallation
{
    void DefaultInstall(String* assembly);
};

__gc private __interface IProxyInvoke
{
    IMessage* LocalInvoke(IMessage* msg);
    IntPtr    GetOuterIUnknown();
};

__gc private class Callback
{
private:
    static ContextCallbackFunction* _cb;
    static PFNCONTEXTCALL           _pfn;
    static ContextCallbackFunction* _cbMarshal;
    static PFNCONTEXTCALL           _pfnMarshal;

    static HRESULT CallbackFunction(ComCallData* pData);
    static HRESULT MarshalCallback(ComCallData* pData);

public:
    static Callback()
	{
	    // Use this so that we know we've got an unmanaged callback function
	    // that's appropriate to the target app-domain.
	    _cb = new ContextCallbackFunction(NULL, &Callback::CallbackFunction);
	    _pfn = lstrcpynW(_cb, _cb, 0);
	    _cbMarshal = new ContextCallbackFunction(NULL, &Callback::MarshalCallback);
	    _pfnMarshal = lstrcpynW(_cbMarshal, _cbMarshal, 0);
	}
    
    IMessage* DoCallback(Object* otp, IMessage* msg, IntPtr ctx, bool fIsAutoDone, MemberInfo* mb, bool bHasGit);
    Byte      SwitchMarshal(IntPtr ctx, IntPtr pUnk)  __gc[];
};

__gc private class Tracker
{
private:
    ISendMethodEvents* _pTracker;

private public:
    Tracker(ISendMethodEvents* pTracker)
    {
        _pTracker = pTracker;
        _pTracker->AddRef();
    }

public:
    void SendMethodCall(IntPtr pIdentity, MethodBase* method);
    void SendMethodReturn(IntPtr pIdentity, MethodBase* method, Exception* except);

    void Release() 
    { 
        if(_pTracker != NULL)
        {
            _pTracker->Release(); 
            _pTracker = NULL;
        }
    }
};

__gc private class Proxy
{
private:
    Proxy() {}
    
    static bool                   _fInit;
    static Hashtable*             _regCache;
    static IGlobalInterfaceTable* _pGIT;
    static Assembly*		      _thisAssembly;
    static Mutex*                 _regmutex;

    static bool CheckRegistered(Guid id, Assembly* assembly, bool checkCache, bool cacheOnly);
    static void LazyRegister(Guid id, Type* serverType, bool checkCache);
    static void RegisterAssembly(Assembly* assembly);

public:
    static void Init();

    // GIT interface methods.
    static int       StoreObject(IntPtr ptr);
    static IntPtr    GetObject(int cookie);
    static void      RevokeObject(int cookie);

    static IntPtr 	 CoCreateObject(Type* serverType, bool bQuerySCInfo, bool __gc* bIsAnotherProcess, String __gc** uri);
    static int       GetMarshalSize(Object* o);
    static bool      MarshalObject(Object* o, Byte b[], int cb);
    static IntPtr    UnmarshalObject(Byte b[]);
    static void      ReleaseMarshaledObject(Byte b[]);
    static IntPtr    GetStandardMarshal(IntPtr pUnk);

    // Return an opaque token for context comparisons.
    static IntPtr    GetContextCheck();
    static IntPtr    GetCurrentContextToken();

    // Return an addref'd pointer to the current ctx:
    static IntPtr    GetCurrentContext();

    // Helper to call an unmanaged function pointer with the given value,
    // and return the HRESULT from it:
    static int CallFunction(IntPtr pfn, IntPtr data);

    // Helpers to call API's on the pool:
    static void PoolUnmark(IntPtr pPooledObject);
    static void PoolMark(IntPtr pPooledObject);

    // Check managed extents:
    static int GetManagedExts();

    // Send Creation/Destruction events to COM:
    static void SendCreationEvents(IntPtr ctx, IntPtr stub, bool fDist);
    static void SendDestructionEvents(IntPtr ctx, IntPtr stub, bool disposing);

    // Find the given context's tracker property...
    static Tracker* FindTracker(IntPtr ctx);

    // Register the proxy/stub dll
    static int RegisterProxyStub();

    static int INFO_PROCESSID = 0x00000001;
    static int INFO_APPDOMAINID = 0x00000002;
    static int INFO_URI = 0x00000004;
};

CLOSE_NAMESPACE()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\simplestream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#define __UNMANAGED_DEFINES

#include "unmanagedheaders.h"
#include "SimpleStream.h"

class CSimpleStream : public IStream
{
protected:
    // A pointer to the buffer:
    BYTE*    m_buffer;
    ULONG    m_length;
    ULONG    m_cursor;
    LONG     m_cRef;
#ifdef _DEBUG
    BOOL     m_fStack;
#endif

    void* operator new(size_t sz)
    {
        return CoTaskMemAlloc(sz);
    }

    void operator delete(void* pv, size_t sz)
    {
        CoTaskMemFree(pv);
    }
  
public:
    CSimpleStream(BYTE* buffer, ULONG length, ULONG cursor = 0, BOOL fStack = TRUE) {
        m_buffer = buffer;
        m_length = length;
        m_cursor = cursor;
        if(m_cursor > m_length) m_cursor = m_length;
        // This is always allocated on the stack, so we start w/
        // a refcount of 1 for the "stack reference"
        m_cRef = 1;
#ifdef _DEBUG
        m_fStack = fStack;
#endif
        UNREF(fStack);
    }
    ~CSimpleStream() {
        // We don't own our buffer, so there's nothing to clean up.
        _ASSERT((m_fStack && m_cRef == 1) || !m_fStack);
    }

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IStream methods
    STDMETHOD(Read)(void* pv, ULONG cb, ULONG* pcb);
    STDMETHOD(Write)(const void* pv, ULONG cb, ULONG* pcb);
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                    ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream __RPC_FAR *pstm,
                      ULARGE_INTEGER cb,
                      ULARGE_INTEGER __RPC_FAR *pcbRead,
                      ULARGE_INTEGER __RPC_FAR *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                          DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                            DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG __RPC_FAR *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream __RPC_FAR *__RPC_FAR *ppstm);
};

//////////////////////////////////////////////////////////////////////////
// The buffer stream object takes a simple memory buffer (no relocation,
// no expansion) and exposes efficient stream operations on it.  We use
// this to serialize by hand into managed code.

// IUnknown methods:
STDMETHODIMP CSimpleStream::QueryInterface(REFIID riid, void **ppv)
{
  if(riid == IID_IUnknown || 
     riid == IID_ISequentialStream || 
     riid == IID_IStream) {
    *ppv = static_cast<IStream*>(this);
  }
  else {
    *ppv = NULL;
    return(E_NOINTERFACE);
  }
  
  ((IUnknown*)(*ppv))->AddRef();
  return(S_OK);
}

STDMETHODIMP_(ULONG) CSimpleStream::AddRef()
{
  ULONG r = InterlockedIncrement(&m_cRef);
  return(r);
}

STDMETHODIMP_(ULONG) CSimpleStream::Release()
{
  ULONG ul = InterlockedDecrement(&m_cRef);
  if(ul == 0)
  {
      _ASSERT(!m_fStack);
      delete this;
  }
  return(ul);
}

/////////////////////////////////////////////////////////////////////////
// IStream methods:
//    Because we're expecting this object to be accessed from a single thread,
// we don't do any special sync work, just write to the buffer.  

STDMETHODIMP CSimpleStream::Read(void* pv, ULONG cb, ULONG* pcb)
{
  // Read a chunk of data.  
  if(!pv) return(E_POINTER);
  // Adjust the length to be read based on remaining length:
  ULONG temp   = 0;
  ULONG remain = m_length - m_cursor;
  temp = (cb<remain)?cb:remain;
  memcpy(pv, &(m_buffer[m_cursor]), temp);
  m_cursor += temp;
  if(pcb) *pcb = temp;
  return(S_OK);
}

STDMETHODIMP CSimpleStream::Write(const void* pv, ULONG cb, ULONG* pcb)
{
  // Write a block of data into the stream.
  if(!pv) return(E_POINTER);
  
  ULONG temp   = 0;
  ULONG remain = m_length - m_cursor;
  temp = (cb<remain)?cb:remain;
  memcpy(&(m_buffer[m_cursor]), pv, temp);
  m_cursor += temp;
  if(pcb) *pcb = temp;
  if(cb != temp) return(STG_E_MEDIUMFULL);
  return(S_OK);
}

STDMETHODIMP CSimpleStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                                 ULARGE_INTEGER* plibNewPosition)
{
  __int64 cursor = m_cursor; // signed big number.
  __int64 temp;

  switch(dwOrigin) {
  case STREAM_SEEK_SET: // Move relative to beginning
    cursor = dlibMove.QuadPart;
    if(cursor > m_length) cursor = m_length;
    break;
  case STREAM_SEEK_CUR: // Move relative to current
    temp = cursor + dlibMove.QuadPart;
    if(temp < 0)             cursor = 0;
    else if(temp > m_length) cursor = m_length;
    else                     cursor = temp;
    break;
  case STREAM_SEEK_END: // Move relative to end.
    temp = m_length + dlibMove.QuadPart;
    if(temp < 0)             cursor = 0;
    else if(temp > m_length) cursor = m_length;
    else                     cursor = temp;
    break;
  default:
    return(E_INVALIDARG);
  }
  
  // Propogate new cursor value back into our ULONG:
  _ASSERT(cursor >= 0 && cursor <= m_length);
  m_cursor = (ULONG)cursor;
  
  // Return the new position!
  if(plibNewPosition) (*plibNewPosition).QuadPart = m_cursor;

  return(S_OK);
}

STDMETHODIMP CSimpleStream::SetSize(ULARGE_INTEGER)
{
  return(STG_E_MEDIUMFULL);
}

STDMETHODIMP CSimpleStream::CopyTo(IStream __RPC_FAR *pstm,
                                  ULARGE_INTEGER cb,
                                  ULARGE_INTEGER __RPC_FAR *pcbRead,
                                  ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
  // See how much of the request we can produce:
  if(!pstm || !pcbRead || !pcbWritten) return(E_POINTER);
  ULONG written = 0;
  ULONG remain = m_length - m_cursor;
  ULONG count  = (cb.QuadPart>remain)?remain:((ULONG)(cb.QuadPart));
  HRESULT hr = pstm->Write(&(m_buffer[m_cursor]), count, &written);

  m_cursor += count;
  (*pcbRead).QuadPart    = count;
  (*pcbWritten).QuadPart = written;

  return(hr);
}

STDMETHODIMP CSimpleStream::Commit(DWORD)
{
  return(E_NOTIMPL);
}

STDMETHODIMP CSimpleStream::Revert()
{
  return(E_NOTIMPL);
}

STDMETHODIMP CSimpleStream::LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
{
  return(E_NOTIMPL);
}

STDMETHODIMP CSimpleStream::UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
{
  return(E_NOTIMPL);
}

STDMETHODIMP CSimpleStream::Stat(STATSTG __RPC_FAR *, DWORD)
{
  return(E_NOTIMPL);
}

STDMETHODIMP CSimpleStream::Clone(IStream __RPC_FAR *__RPC_FAR *ppstm)
{
  if(!ppstm) return(E_POINTER);
  CSimpleStream* bst = new CSimpleStream(m_buffer, m_length, m_cursor, FALSE);
  if(!bst) return(E_OUTOFMEMORY);
  *ppstm = NULL;
  HRESULT hr = bst->QueryInterface(IID_IStream, (void**)ppstm);
  if(FAILED(hr)) {
    delete bst;
    *ppstm = NULL;
  }
  return(hr);
}

STDAPI MarshalInterface(BYTE* pBuf, int cb, IUnknown* pUnk, DWORD mshctx)
{
    HRESULT hr = S_OK;

    MarshalPacket* packet = (MarshalPacket*)pBuf;
    pBuf = (BYTE*)(packet+1);
    packet->size = cb - sizeof(MarshalPacket);
    
    CSimpleStream stm(pBuf, packet->size);
    
    hr = CoMarshalInterface((IStream*)&stm, 
                            IID_IUnknown, 
                            pUnk,
                            mshctx,
                            NULL, 
                            MSHLFLAGS_NORMAL);

    return(hr);
}

STDAPI UnmarshalInterface(BYTE* pBuf, int cb, void** ppv)
{
    HRESULT hr = S_OK;

    MarshalPacket* packet = (MarshalPacket*)pBuf;
    pBuf = (BYTE*)(packet+1);

    _ASSERT(packet->size == cb - sizeof(MarshalPacket));
    
    CSimpleStream stm(pBuf, cb - sizeof(MarshalPacket));
    
    hr = CoUnmarshalInterface((IStream*)&stm, IID_IUnknown, ppv);
    return(hr);
}

STDAPI ReleaseMarshaledInterface(BYTE* pBuf, int cb)
{
    HRESULT hr = S_OK;

    MarshalPacket* packet = (MarshalPacket*)pBuf;
    pBuf = (BYTE*)(packet+1);

    _ASSERT(packet->size == cb - sizeof(MarshalPacket));

    CSimpleStream stm(pBuf, cb - sizeof(MarshalPacket));
    
    hr = CoReleaseMarshalData((IStream*)&stm);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\svcintfs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#include "unknwn.h"
#include "oaidl.h"
#include "ocidl.h"
#include <contxt.h>

#ifndef __svcintfs_h__
#define __svcintfs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

typedef interface IManagedObjectInfo       IManagedObjectInfo;
typedef interface IManagedPooledObj        IManagedPooledObj;
typedef interface IManagedActivationEvents IManagedActivationEvents;
typedef interface ISendMethodEvents        ISendMethodEvents;

/* interface IManagedActivationEvents */
/* [uuid][unique][object][local] */ 

EXTERN_C const IID IID_IManagedActivationEvents;

MIDL_INTERFACE("a5f325af-572f-46da-b8ab-827c3d95d99e")
IManagedActivationEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE CreateManagedStub( 
            /* [in] */ IManagedObjectInfo *pInfo,
            /* [in] */ BOOL fDist) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE DestroyManagedStub( 
            /* [in] */ IManagedObjectInfo *pInfo) = 0;
};

/* interface IManagedObjectInfo */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IManagedObjectInfo;

MIDL_INTERFACE("1427c51a-4584-49d8-90a0-c50d8086cbe9")
IManagedObjectInfo : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetIUnknown( 
            /* [out] */ IUnknown **pUnk) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE GetIObjectControl( 
            /* [out] */ IObjectControl **pCtrl) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE SetInPool( 
            /* [in] */ BOOL bInPool,
            /* [in] */ IManagedPooledObj *pPooledObj) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE SetWrapperStrength( 
            /* [in] */ BOOL bStrong) = 0;
};

/* interface IManagedPooledObj */
/* [uuid][unique][object][local] */ 


EXTERN_C const IID IID_IManagedPooledObj;

MIDL_INTERFACE("c5da4bea-1b42-4437-8926-b6a38860a770")
IManagedPooledObj : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE SetHeld( 
            /* [in] */ BOOL m_bHeld) = 0;
};

EXTERN_C const IID IID_ISendMethodEvents;

MIDL_INTERFACE("2732fd59-b2b4-4d44-878c-8b8f09626008")
ISendMethodEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE SendMethodCall( 
            /* [in] */ const void *pIdentity,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwMeth) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE SendMethodReturn( 
            /* [in] */ const void *pIdentity,
            /* [in] */ REFIID riid,
            /* [in] */ DWORD dwMeth,
            /* [in] */ HRESULT hrCall,
            /* [in] */ HRESULT hrServer) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\securitythunk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "managedheaders.h"
#include "SecurityThunk.h"

OPEN_NAMESPACE()

HRESULT Security::Init()
{
    if(!_fInit)
    {
        System::Threading::Monitor::Enter(__typeof(Security));
        try
        {
            if(!_fInit)
            {
                // TODO: fix this: LoadLibrary("Security.dll") and get EnumSec
                /*
                SECURITY_STATUS stat = EnumerateSecurityPackagesW(&_cPackages, &_pPackageInfo);
                if(stat != SEC_E_OK)
                    return(HRESULT_FROM_WIN32(stat));
                */
                _cPackages = 0;

                HMODULE hAdv = LoadLibraryW(L"advapi32.dll");
                if(hAdv && hAdv != INVALID_HANDLE_VALUE)
                {
                    OpenThreadToken = (FN_OpenThreadToken)GetProcAddress(hAdv, "OpenThreadToken");
                    SetThreadToken = (FN_SetThreadToken)GetProcAddress(hAdv, "SetThreadToken");
                }

                _fInit = TRUE;
            }
        }
        __finally
        {
            System::Threading::Monitor::Exit(__typeof(Security));
        }
    }
    return(S_OK);
}

String* Security::GetAuthenticationService(int svcid)
{
    HRESULT hr = Init();
    if(FAILED(hr))
        Marshal::ThrowExceptionForHR(HRESULT_FROM_WIN32(hr));

    // Match against known values:
    if(svcid == 0) return("None");
    if(svcid == -1) return("Default");

    String* name = "<unknown>";

    // Whip through the array looking for svcid:
    for(ULONG i = 0; i < _cPackages; i++)
    {
        if(_pPackageInfo[i].wRPCID == svcid)
        {
            name = Marshal::PtrToStringUni(TOINTPTR(_pPackageInfo[i].Name));
            break;
        }
    }

    return(name);
}

typedef struct _SID1 {
    BYTE  Revision;
    BYTE  SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    DWORD SubAuthority[1];
} SID1;

String* Security::GetEveryoneAccountName()
{
    BOOL r = FALSE;
    SID1 sid = { SID_REVISION, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
    PSID psid = (PSID)&sid;
    WCHAR wszDomain[MAX_PATH];
    DWORD cbDomain = MAX_PATH;
    WCHAR wszAccount[MAX_PATH];
    DWORD cbAccount = MAX_PATH;
    SID_NAME_USE eUse;

    // Look up the account name...
    r = LookupAccountSidW(NULL, psid, 
                          wszAccount, &cbAccount, 
                          wszDomain, &cbDomain,
                          &eUse);
    if(!r)
        THROWERROR(HRESULT_FROM_WIN32(GetLastError()));
    
    // We only care about the account name:
    return(Marshal::PtrToStringUni(TOINTPTR(wszAccount)));
}

IntPtr Security::SuspendImpersonation()
{
    HANDLE hToken = 0;

    HRESULT hr = Init();
    if(FAILED(hr))
        Marshal::ThrowExceptionForHR(hr);

    if(OpenThreadToken && SetThreadToken)
    {
        if(OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &hToken))
        {
            SetThreadToken(NULL, NULL);
            return(TOINTPTR(hToken));
        }
    }

    return(IntPtr::Zero);
}

void Security::ResumeImpersonation(IntPtr hToken)
{
    if(OpenThreadToken && SetThreadToken && hToken != 0)
    {
        // This should never fail - if we have a token, we have IMPERSONATE
        // rights to it, so we can set it on the thread.  If we don't have
        // a token, we don't get here...
        BOOL r = SetThreadToken(NULL, TOPTR(hToken));
        _ASSERTM(r);
        UNREF(r);
        CloseHandle(TOPTR(hToken));
    }
}

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\securitythunk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SECURITYTHUNK_H
#define _SECURITYTHUNK_H

#define SECURITY_WIN32

#include "lmaccess.h"
#include "security.h"

OPEN_NAMESPACE()

using namespace System;
using namespace System::Runtime::InteropServices;
using namespace System::Collections;

__gc private class Security
{
private:
    Security() {}

    static Security()
    {
        _fInit = FALSE;
    }

    static BOOL _fInit = FALSE;
    static ULONG        _cPackages;
    static SecPkgInfoW* _pPackageInfo;

    static HRESULT Init();

    typedef BOOL (__stdcall *FN_OpenThreadToken)(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);
    typedef BOOL (__stdcall *FN_SetThreadToken)(PHANDLE Thread, HANDLE Token);

    static FN_OpenThreadToken OpenThreadToken = NULL;
    static FN_SetThreadToken SetThreadToken = NULL;
    

public:
    static String* GetAuthenticationService(int svcid);
    static String* GetEveryoneAccountName();

    static IntPtr SuspendImpersonation();
    static void ResumeImpersonation(IntPtr hToken);
};

CLOSE_NAMESPACE()

#endif //_SECURITYTHUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\proxythunk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "managedheaders.h"
#include "ProxyThunk.h"
#include "SimpleStream.h"
#include "ContextAPI.h"
#include "..\EnterpriseServicesPS\entsvcps.h"
#include "SecurityThunk.h"

extern "C" {
HRESULT STDAPICALLTYPE DllRegisterServer();
};

OPEN_NAMESPACE()

const IID IID_IObjContext =
{ 0x000001c6, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };

using namespace System;
using namespace System::Threading;
using namespace Microsoft::Win32;
using namespace System::Runtime::Remoting::Proxies;
using namespace System::Runtime::Remoting::Services;

// TODO:  The pinning mechanism for UserCallData is cumbersome.
[Serializable]
__gc private class UserCallData
{
public:
    Object*         otp;
    IMessage*       msg;
    IUnknown*       pDestCtx;
    bool            fIsAutoDone;
    MemberInfo*     mb;
    Object*         except;

    UserCallData(Object* otp, IMessage* msg, IntPtr ctx, bool fIsAutoDone, MemberInfo* mb)
    {
        this->otp = otp;
        this->msg = msg;
        this->pDestCtx = (IObjectContext*)TOPTR(ctx);
        this->fIsAutoDone = fIsAutoDone;
        this->mb = mb;
        this->except = NULL;
    }

    IntPtr Pin()
    {
        GCHandle h = GCHandle::Alloc(this, GCHandleType::Normal);
        _ASSERTM(h.get_IsAllocated());
        _ASSERTM(h.get_Target() != NULL);
        return(GCHandle::op_Explicit(h));
    }
    void  Unpin(IntPtr pinned)
    {
        GCHandle h = GCHandle::op_Explicit(pinned);
        _ASSERTM(h.get_IsAllocated());
        _ASSERTM(h.get_Target() != NULL);
        h.Free();
    }

    static UserCallData* Get(IntPtr pinned)
    {
        GCHandle h = GCHandle::op_Explicit(pinned);
        _ASSERTM(h.get_IsAllocated());
        _ASSERTM(h.get_Target() != NULL);
        return(__try_cast<UserCallData*>(h.get_Target()));
    }
};

[Serializable]
__gc private class UserMarshalData
{
public:
    IntPtr          pUnk;
    Byte            buffer[];

    UserMarshalData(IntPtr pUnk)
    {
        this->pUnk = pUnk;
        this->buffer = NULL;
    }

    IntPtr Pin()
    {
        GCHandle h = GCHandle::Alloc(this, GCHandleType::Normal);
        _ASSERTM(h.get_IsAllocated());
        _ASSERTM(h.get_Target() != NULL);
        return(GCHandle::op_Explicit(h));
    }
    void  Unpin(IntPtr pinned)
    {
        GCHandle h = GCHandle::op_Explicit(pinned);
        _ASSERTM(h.get_IsAllocated());
        _ASSERTM(h.get_Target() != NULL);
        h.Free();
    }

    static UserMarshalData* Get(IntPtr pinned)
    {
        GCHandle h = GCHandle::op_Explicit(pinned);
        _ASSERTM(h.get_IsAllocated());
        _ASSERTM(h.get_Target() != NULL);
        return(__try_cast<UserMarshalData*>(h.get_Target()));
    }
};

int Proxy::RegisterProxyStub()
{
	return DllRegisterServer();
}

void Proxy::Init()
{
    // TODO: @perf can we store a block in TLS that's faster to access than
    // doing this check?
    // Make sure the current thread has been initialized:
    if(Thread::get_CurrentThread()->get_ApartmentState() == ApartmentState::Unknown)
    {
        DBG_INFO("Proxy: Setting apartment state to MTA...");
        Thread::get_CurrentThread()->set_ApartmentState(ApartmentState::MTA);
    }
    if(!_fInit)
    {
        try
        {
            IntPtr hToken = IntPtr::Zero;

            Monitor::Enter(__typeof(Proxy));
            try
            {
                try
                {
                    hToken = Security::SuspendImpersonation();
                    if(!_fInit)
                    {
                        DBG_INFO("Proxy::Init starting...");
                        _regCache = new Hashtable;

                        // Initialize GIT table:
                        DBG_INFO("Initializing GIT...");
                        IGlobalInterfaceTable* pGIT = NULL;
                        HRESULT hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                                                      NULL,
                                                      CLSCTX_INPROC_SERVER,
                                                      IID_IGlobalInterfaceTable,
                                                      (void **)&pGIT);
                        _pGIT = pGIT;
                        if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);

                        _thisAssembly = Assembly::GetExecutingAssembly();

                        _regmutex = new Mutex(false, String::Concat("Local\\", System::Runtime::Remoting::RemotingConfiguration::get_ProcessId()));

                        DBG_INFO("Proxy::Init done.");
                        _fInit = TRUE;
                    }
                }
                __finally
                {
                    Security::ResumeImpersonation(hToken);
                }
            }
            __finally
            {
                Monitor::Exit(__typeof(Proxy));
            }
        }
        catch(...)
        {
            throw;
        }
    }
}

int Proxy::StoreObject(IntPtr ptr)
{
    Init();

    DWORD cookie;
    IUnknown* pUnk = (IUnknown*)TOPTR(ptr);

    HRESULT hr = _pGIT->RegisterInterfaceInGlobal(pUnk, IID_IUnknown, &cookie);
    if(FAILED(hr))
    {
        DBG_INFO(String::Concat("Proxy::StoreObject: failed to register interface: ", ((Int32)hr).ToString("X")));
        Marshal::ThrowExceptionForHR(hr);
    }

    return(cookie);
}

IntPtr Proxy::GetObject(int cookie)
{
    Init();

    IUnknown* pUnk = NULL;
    HRESULT hr = _pGIT->GetInterfaceFromGlobal(cookie, IID_IUnknown, (void**)&pUnk);
    if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);

    return(TOINTPTR(pUnk));
}

void Proxy::RevokeObject(int cookie)
{
    Init();

    HRESULT hr = _pGIT->RevokeInterfaceFromGlobal(cookie);
    if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);
}

bool Proxy::CheckRegistered(Guid id, Assembly* assembly, bool checkCache, bool cacheOnly)
{
    DBG_INFO(String::Concat("Proxy::CheckRegistered: ", id.ToString(), ", CheckCache = ", checkCache.ToString()));

    if(checkCache && _regCache->get_Item(assembly) != NULL) return(true);
    if(cacheOnly) return false;

    // Poke into the registry for id:
    String* keyName = String::Concat(L"CLSID\\{", id.ToString(), "}\\InprocServer32");
    RegistryKey* key = Registry::ClassesRoot->OpenSubKey(keyName, false);

    if (key!=NULL)		// if assembly is already registered, make sure we don't go to the registry again
		_regCache->set_Item(assembly, Boolean::TrueString);

    return(key != NULL);
}

void Proxy::LazyRegister(Guid guid, Type* serverType, bool checkCache)
{
    // First, make sure this isn't System.EnterpriseServices.  It doesn't get auto-reged:
    if(serverType->Assembly != _thisAssembly)
    {
        if(!CheckRegistered(guid, serverType->Assembly, checkCache, true))
        {
            // Take the mutex...
            _regmutex->WaitOne();
            try
            {
                if(!CheckRegistered(guid, serverType->Assembly, checkCache, false))
                {
                    RegisterAssembly(serverType->Assembly);
                }
            }
            __finally
            {
                _regmutex->ReleaseMutex();
            }
        }
    }    
}

void Proxy::RegisterAssembly(Assembly* assembly)
{
    try
    {
        // Call up into System.EnterpriseServices.RegistrationHelper.
        Type* regType = Type::GetType(L"System.EnterpriseServices.RegistrationHelper");
        IThunkInstallation* inst = __try_cast<IThunkInstallation*>(Activator::CreateInstance(regType));
        inst->DefaultInstall(assembly->Location);
    }
    __finally
    {
        // Even if we failed, mark this guy as registered.
        _regCache->set_Item(assembly, Boolean::TrueString);
    }
}

IntPtr Proxy::CoCreateObject(Type* serverType,bool bQuerySCInfo, [ref]bool __gc* bIsAnotherProcess,String __gc** Uri)
{
    Init();

    IUnknown*                pUnkRetVal = NULL;
    bool                     fCheckCache = true;
    HRESULT                  hr = S_OK;

    DBG_INFO("Proxy::CoCreateObject starting...");

    Guid guid = Marshal::GenerateGuidForType(serverType);
    do
    {
        // These guys should be released in the finally block.
        IUnknown*               pUnk = NULL;
        IServicedComponentInfo* pSCI = NULL;
        SAFEARRAY*              sa = NULL;
    
        try
        {
            LazyRegister(guid, serverType, fCheckCache);
            DBG_INFO("Proxy::CoCreateObject finished registration step...");
            
            GUID clsid;
            clsid = *((GUID*)&guid);
            
            MULTI_QI mqi[2] = { 0 };
            
            mqi[0].pIID = &IID_IUnknown;
            mqi[1].pIID = &IID_IServicedComponentInfo;

            DBG_INFO("Proxy::CoCreateObject calling CoCreateInstance...");
            hr = CoCreateInstanceEx((REFCLSID)clsid, NULL, CLSCTX_ALL, NULL, bQuerySCInfo ? 2 : 1, (MULTI_QI*)&mqi);
            if (SUCCEEDED(hr))
            {
                if (SUCCEEDED(mqi[0].hr))
                    pUnk = mqi[0].pItf;

                if (bQuerySCInfo && (SUCCEEDED(mqi[1].hr)))
                    pSCI = (IServicedComponentInfo*) mqi[1].pItf;
                
                // Now that we've read out all the valid values, check
                // for errors (we read everybody first so that cleanup
                // can happen.
                if(FAILED(mqi[0].hr))
                    THROWERROR(mqi[0].hr);
                if(bQuerySCInfo && FAILED(mqi[1].hr))
                    THROWERROR(mqi[1].hr);
            }
            
            // If we failed:
            // if hr == class not registered, and we forced a registry hit
            // (with fCheckCache == false), then we throw.
            // if it isn't registered, force a cache hit.
            // otherwise, throw.
            if(FAILED(hr))
            {
                DBG_INFO(String::Concat("Failed to create: hr = ", ((Int32)hr).ToString()));
                
                if(hr == REGDB_E_CLASSNOTREG && fCheckCache)
                {
                    DBG_INFO("Checking again, reset check cache to false.");
                    fCheckCache = false;
                }
                else
                {
                    Marshal::ThrowExceptionForHR(hr);
                }
            }
            else if (bQuerySCInfo && (pSCI!=NULL))
            {
                BSTR bstrProcessId = NULL;
                BSTR bstrUri = NULL;
                int infoMask = 0;
                String *CurrentProcessId;
                String *ServerProcessId;
                long rgIndices;
                
                infoMask = INFO_PROCESSID;
                hr = pSCI->GetComponentInfo(&infoMask, &sa);
                if (FAILED(hr))
                    Marshal::ThrowExceptionForHR(hr);
                
                rgIndices=0;
                SafeArrayGetElement(sa, &rgIndices, &bstrProcessId);
                
                ServerProcessId = Marshal::PtrToStringBSTR(bstrProcessId);
                CurrentProcessId = System::Runtime::Remoting::RemotingConfiguration::get_ProcessId();
                
                if (bstrProcessId)
                    SysFreeString(bstrProcessId);
                
                SafeArrayDestroy(sa);
                sa = NULL;
                
                if (String::Compare(CurrentProcessId, ServerProcessId) == 0)
                {
                    *bIsAnotherProcess = FALSE;
                }
                else
                {
                    *bIsAnotherProcess = TRUE;
                }
                
                if (*bIsAnotherProcess == TRUE)	// we only want to fetch the URI in OOP cases, since that causes a fullblown Marshal of the SC.
                {
                    infoMask = INFO_URI;
                    hr = pSCI->GetComponentInfo(&infoMask, &sa);
                    if (FAILED(hr))
                        Marshal::ThrowExceptionForHR(hr);
                    
                    rgIndices = 0;
                    SafeArrayGetElement(sa, &rgIndices, &bstrUri);
                    
                    *Uri = Marshal::PtrToStringBSTR(bstrUri);
                    
                    if (bstrUri)
                        SysFreeString(bstrUri);
                    
                    SafeArrayDestroy(sa);
                    sa = NULL;
                }
            }
            else	// either bQuerySCInfo is false (eventclass case), or
                // CoCI succeeded but we couldnt get pSCI so the safe default is to report as Inproc (so that we end up doing GetTypedObjectForIUnknown)
            {
                _ASSERTM(!bQuerySCInfo || !"We were unable to figure out what kind of object we had!  We're just going to end up wrapping it.");
                *bIsAnotherProcess = TRUE;
            }

            pUnkRetVal = pUnk;
            pUnk = NULL;
        }
        __finally
        {
            if(pUnk != NULL) pUnk->Release();
            if(pSCI != NULL) pSCI->Release();
            if(sa != NULL) SafeArrayDestroy(sa);
        }
    }
    while(pUnkRetVal == NULL);

    // TODO:  Assert that we hold a reference on the target object
    // and on the context with our proxy (if necessary).

    _ASSERTM(pUnkRetVal != NULL);
    return(TOINTPTR(pUnkRetVal));
}

int Proxy::GetMarshalSize(Object* o)
{
    Init();

    IUnknown* pUnk = NULL;
    HRESULT hr = S_OK;
    DWORD size = 0;

    try
    {
        pUnk = (IUnknown*)TOPTR(Marshal::GetIUnknownForObject(o));
        _ASSERT(pUnk != NULL);

        hr = CoGetMarshalSizeMax(&size, IID_IUnknown, pUnk,
                                 MSHCTX_DIFFERENTMACHINE,
                                 NULL, MSHLFLAGS_NORMAL);
        if(SUCCEEDED(hr))
        {
            size += sizeof(MarshalPacket);
        }
        else
        {
            DBG_INFO(String::Concat("CoGetMarshalSizeMax failed: ", ((int)hr).ToString()));
            size = (DWORD)-1;
        }
    }
    __finally
    {
        if(pUnk != NULL) pUnk->Release();
    }

    return(size);
}

IntPtr Proxy::UnmarshalObject(Byte b[])
{
    Init();

    HRESULT hr = S_OK;
    IUnknown* pUnk = NULL;

    // Get the array length...
    int cb = b->get_Length();

    // Pin the array:
    Byte __pin* pinb = &(b[0]);
    BYTE __nogc* pBuf = pinb;

    try
    {
        // Thunk across into unmanaged code, in order to avoid
        // the dreaded fromunmanaged RVA:
        hr = UnmarshalInterface(pBuf, cb, (void**)&pUnk);
        if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
    }

    // pinb should go out of scope here:  We assert that the above was
    // the last unmarshal release, so it should be safe to unpin here.

    return(TOINTPTR(pUnk));
}

bool Proxy::MarshalObject(Object* o, Byte b[], int cb)
{
    Init();

    IUnknown*  pUnk = NULL;
    HRESULT    hr = S_OK;

    // Pin the array:
    Byte __pin* pinb = &(b[0]);
    BYTE __nogc* pBuf = pinb;

    _ASSERTM(b->get_Length() == cb);

    try
    {
        // Thunk across into unmanaged code for this, so as to
        // eliminate fromunmanaged RVA thunks.
        pUnk = (IUnknown*)TOPTR(Marshal::GetIUnknownForObject(o));
        hr = MarshalInterface(pBuf, cb, pUnk, MSHCTX_DIFFERENTMACHINE);

        if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if(pUnk != NULL) pUnk->Release();
    }

    // pinb should go out of scope here:  We assert that the above was
    // the last unmarshal release, so it should be safe to unpin here.

    return(true);
}

IntPtr Proxy::GetStandardMarshal(IntPtr pUnk)
{
    IMarshal* pMar;
    HRESULT hr = CoGetStandardMarshal(IID_IUnknown,
                                      (IUnknown*)TOPTR(pUnk),
                                      MSHCTX_DIFFERENTMACHINE,
                                      NULL,
                                      MSHLFLAGS_NORMAL,
                                      &pMar);
    if(FAILED(hr))
        Marshal::ThrowExceptionForHR(hr);

    return(TOINTPTR(pMar));
}

void Proxy::ReleaseMarshaledObject(Byte b[])
{
    Init();

    HRESULT    hr = S_OK;

    // Pin the array:
    Byte __pin* pinb = &(b[0]);
    BYTE __nogc* pBuf = pinb;

    try
    {
        // Thunk across into unmanaged code for this, so as to
        // eliminate fromunmanaged RVA thunks.
        hr = ReleaseMarshaledInterface(pBuf, b->get_Length());
        if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
    }

    // pinb should go out of scope here:  We assert that the above was
    // the last unmarshal release, so it should be safe to unpin here.
}

// Returns an asm stub that checks to see if the current context
// is the right one.
IntPtr Proxy::GetContextCheck()
{
    Init();

    return(TOINTPTR(::GetContextCheck()));
}

// Returns the opaque token used for context checking/switching
IntPtr Proxy::GetCurrentContextToken()
{
    Init();

    return(TOINTPTR(::GetContextToken()));
}

// Return an addref'd pointer to the current context:
IntPtr Proxy::GetCurrentContext()
{
    Init();

    IUnknown* pUnk;

    HRESULT hr = GetContext(IID_IUnknown, (void**)&pUnk);
    _ASSERTM(SUCCEEDED(hr));
    if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);

    return(TOINTPTR(pUnk));
}

typedef HRESULT (__stdcall *FN_CB)(void* pv);

int Proxy::CallFunction(IntPtr xpfn, IntPtr data)
{
    void* pv = TOPTR(data);
    FN_CB pfn = (FN_CB)TOPTR(xpfn);

    return(pfn(pv));
}

void Proxy::PoolUnmark(IntPtr pPooledObject)
{
    IManagedPooledObj* pPO = (IManagedPooledObj*)TOPTR(pPooledObject);
    pPO->SetHeld(FALSE);
}

void Proxy::PoolMark(IntPtr pPooledObject)
{
    IManagedPooledObj* pPO = (IManagedPooledObj*)TOPTR(pPooledObject);
    pPO->SetHeld(TRUE);
}

int Proxy::GetManagedExts()
{
    static DWORD dwExts = (DWORD)-1;

    if(dwExts == -1)
    {
        DWORD dwTemp = 0;
        HMODULE hMod = LoadLibraryW(L"comsvcs.dll");
        if(hMod && hMod != INVALID_HANDLE_VALUE)
        {
            typedef HRESULT (__stdcall *FN_GetExts)(DWORD* dwRet);
            FN_GetExts GetExts = (FN_GetExts)GetProcAddress(hMod, "GetManagedExtensions");
            if(GetExts)
            {
                HRESULT hr = GetExts(&dwTemp);
                if(FAILED(hr)) dwTemp = 0;
            }
        }
        dwExts = dwTemp;
        DBG_INFO(String::Concat("Managed extensions = ", ((Int32)dwExts).ToString()));
    }
    return(dwExts);
}

void Proxy::SendCreationEvents(IntPtr ctx, IntPtr stub, bool fDist)
{
    DBG_INFO("Sending creation events...");

    HRESULT hr = S_OK;
    IUnknown* pctx = (IUnknown*)TOPTR(ctx);
    IObjContext* pObjCtx = NULL;
    IManagedObjectInfo* pInfo = (IManagedObjectInfo*)TOPTR(stub);
    IEnumContextProps* pEnum = NULL;

    hr = pctx->QueryInterface(IID_IObjContext, (void**)&pObjCtx);
    if(FAILED(hr))
        return;

    DBG_INFO("Getting enum");

    try
    {
        hr = pObjCtx->EnumContextProps(&pEnum);
        if(FAILED(hr))
            return;

        ULONG icpMac = 0;
        hr = pEnum->Count(&icpMac);
        if(FAILED(hr))
            Marshal::ThrowExceptionForHR(hr);

        DBG_INFO(String::Concat("Property count = ", ((Int32)icpMac).ToString("X")));
        for(ULONG i = 0; i < icpMac; i++)
        {
            ULONG gotten = 0;
            ContextProperty prop;
            hr = pEnum->Next(1, &prop, &gotten);
            if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);

            if(gotten != 1) break;

            // Check for IManagedActivationEvents, send...
            IManagedActivationEvents* pEv = NULL;
            hr = prop.pUnk->QueryInterface(IID_IManagedActivationEvents, (void**)&pEv);
            if(SUCCEEDED(hr))
            {
                DBG_INFO("Found managed activation events!");
                pEv->CreateManagedStub(pInfo, (BOOL)fDist);
                pEv->Release();
            }
            prop.pUnk->Release();
        }
    }
    __finally
    {
        if(pObjCtx != NULL) pObjCtx->Release();
        if(pEnum != NULL) pEnum->Release();
    }
    DBG_INFO("Done sending creation events.");
}

#pragma unmanaged

struct DestructData
{
    IUnknown* pCtx;
    IManagedObjectInfo* pInfo;
};

HRESULT __stdcall SendDestructionEventsCallback(ComCallData* cbData)
{
    HRESULT hr = S_OK;
    DestructData* pData = (DestructData*)(cbData->pUserDefined);
    IObjContext* pObjCtx = NULL;
    IEnumContextProps* pEnum = NULL;

    hr = pData->pCtx->QueryInterface(IID_IObjContext, (void**)&pObjCtx);
    if(FAILED(hr))
        return S_OK;

    __try
    {
        hr = pObjCtx->EnumContextProps(&pEnum);
        if(FAILED(hr)) return S_OK;

        ULONG icpMac = 0;
        hr = pEnum->Count(&icpMac);
        if(FAILED(hr)) return(hr);

        for(ULONG i = 0; i < icpMac; i++)
        {
            ULONG gotten = 0;
            ContextProperty prop;
            hr = pEnum->Next(1, &prop, &gotten);
            if(FAILED(hr)) return hr;

            if(gotten != 1) break;

            // Check for IManagedActivationEvents, send...
            IManagedActivationEvents* pEv = NULL;
            hr = prop.pUnk->QueryInterface(IID_IManagedActivationEvents, (void**)&pEv);
            if(SUCCEEDED(hr))
            {
                pEv->DestroyManagedStub(pData->pInfo);
                pEv->Release();
            }
            prop.pUnk->Release();

            hr = S_OK;
        }
    }
    __finally
    {
        if(pObjCtx != NULL) pObjCtx->Release();
        if(pEnum != NULL) pEnum->Release();
    }

    return(hr);
}

#pragma managed

void Proxy::SendDestructionEvents(IntPtr ctx, IntPtr stub, bool disposing)
{
    DestructData data;
    data.pCtx = (IUnknown*)TOPTR(ctx);
    data.pInfo = (IManagedObjectInfo*)TOPTR(stub);

    ComCallData comdata;

    comdata.dwDispid     = 0;
    comdata.dwReserved   = 0;
    comdata.pUserDefined = &data;

    IContextCallback* pCB = NULL;
    HRESULT hr            = S_OK;

    __try
    {
        hr = data.pCtx->QueryInterface(IID_IContextCallback, (void**)&pCB);
        if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);

        DBG_INFO("Switching contexts for destruction...");
        
        IID iidCallback = disposing?IID_IUnknown:IID_IEnterActivityWithNoLock;

        hr = pCB->ContextCallback(SendDestructionEventsCallback,
                                  &comdata,
                                  iidCallback,
                                  2,
                                  NULL);
    }
    __finally
    {
        if(pCB != NULL) pCB->Release();
    }

    if(FAILED(hr))
        Marshal::ThrowExceptionForHR(hr);
}

Tracker* Proxy::FindTracker(IntPtr ctx)
{
    const CLSID guidTrkPropPolicy = {0xecabaeb3, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};

    IUnknown* punkTracker = NULL;
    ISendMethodEvents* pTracker = NULL;
    IObjContext* pObjCtx = NULL;
    HRESULT hr = S_OK;
    DWORD junk = 0;

    __try
    {
        hr = ((IUnknown*)TOPTR(ctx))->QueryInterface(IID_IObjContext, (void**)&pObjCtx);
        if(FAILED(hr))
            return NULL;
        
        hr = pObjCtx->GetProperty(guidTrkPropPolicy, &junk, &punkTracker);
        if(FAILED(hr) || punkTracker == NULL)
        {
            DBG_INFO("didn't find tracker - GetProperty failed.");
            punkTracker = NULL;
            return NULL;
        }

        hr = punkTracker->QueryInterface(__uuidof(ISendMethodEvents), (void**)&pTracker);
        if(FAILED(hr))
        {
            DBG_INFO("didn't find tracker - QueryInterface failed.");
            pTracker = NULL;
            return NULL;
        }

        DBG_INFO("Found tracker server!");

        return new Tracker(pTracker);
        
    }
    __finally
    {
        if(pObjCtx != NULL)
            pObjCtx->Release();
        
        if(punkTracker != NULL)
            punkTracker->Release();
        
        if(pTracker != NULL)
            pTracker->Release();
    }
}

void Tracker::SendMethodCall(IntPtr pIdentity, MethodBase* method)
{
    if(_pTracker == NULL) return;

    DBG_INFO("Sending method call");

    Guid miid = Marshal::GenerateGuidForType(method->get_ReflectedType());
    IID iid = *((IID*)&miid);
    int slot = 4;

    if(method->get_ReflectedType()->get_IsInterface())
    {
        slot = Marshal::GetComSlotForMethodInfo(method);
    }
    
    _pTracker->SendMethodCall((void*)pIdentity, iid, slot);
}

void Tracker::SendMethodReturn(IntPtr pIdentity, MethodBase* method, Exception* except)
{
    if(_pTracker == NULL) return;

    DBG_INFO("Sending method return");

    Guid miid = Marshal::GenerateGuidForType(method->get_ReflectedType());
    IID iid = *((IID*)&miid);
    int slot = 4;

    if(method->get_ReflectedType()->get_IsInterface())
    {
        slot = Marshal::GetComSlotForMethodInfo(method);
    }
    HRESULT hrServer = S_OK;

    if(except != NULL)
    {
        hrServer = Marshal::GetHRForException(except);
    }
    
    _pTracker->SendMethodReturn((void*)pIdentity, iid, slot, S_OK, hrServer);
}

#define COR_E_EXCEPTION   0x80131500
#define EXCEPTION_COMPLUS 0xe0434f4d    // 0xe0000000 | 'COM'
#define BOOTUP_EXCEPTION_COMPLUS  0xC0020001

#pragma unmanaged

LONG ManagedCallbackExceptionFilter(LPEXCEPTION_POINTERS lpep)
{
    if((lpep->ExceptionRecord->ExceptionCode == EXCEPTION_COMPLUS) ||
       (lpep->ExceptionRecord->ExceptionCode == BOOTUP_EXCEPTION_COMPLUS))
        return EXCEPTION_EXECUTE_HANDLER;

    return EXCEPTION_CONTINUE_SEARCH;
}

// Sometimes, the runtime will throw an exception preventing us from running
// managed code on this thread.  That sucks, cause we need to catch it
// so's ole32 doesn't freak.  (This is only when the app-domain is unloading,
// which is an OK thing to do, I think.
HRESULT __stdcall FilteringCallbackFunction(ComCallData* pData)
{
    HRESULT hr = S_OK;

    ComCallData2* pData2 = (ComCallData2*)pData;
    _try
    {
        hr = pData2->RealCall(pData);
    }
    _except(ManagedCallbackExceptionFilter(GetExceptionInformation()))
    {
        hr = RPC_E_SERVERFAULT;
    }
    return(hr);
}

#pragma managed

HRESULT Callback::CallbackFunction(ComCallData* pData)
{
    UserCallData* CallData = NULL;
    bool          fExcept = false;

    DBG_INFO("entering CallbackFunction...");

    // Steps:
    try
    {
        // 1. Get the args.
        CallData = UserCallData::Get(TOINTPTR(pData->pUserDefined));

        // 2. Callback on the proxy to do the Invoke:
        IProxyInvoke* pxy = __try_cast<IProxyInvoke*>(RemotingServices::GetRealProxy(CallData->otp));
        CallData->msg = pxy->LocalInvoke(CallData->msg);
        DBG_INFO("CallbackFunction: back from LocalInvoke.");
    }
    catch(Exception* pE)
    {
        DBG_INFO(String::Concat("Infrastructure code threw: ", pE->ToString()));
        fExcept = true;
        if(CallData) CallData->except = pE;
    }

    IMethodReturnMessage* msg = dynamic_cast<IMethodReturnMessage*>(CallData->msg);
    // _ASSERTM(msg != NULL);
    if(msg != NULL && msg->get_Exception() != NULL)
    {
        fExcept = TRUE;
    }

    // 4. If we're auto-done and we failed, abort the tx.
    // This is a hack to make autodone work to some extent on
    // machines before SP2.
    // TODO:  If SP2, we don't need to do this.
    if(fExcept && CallData && CallData->fIsAutoDone)
    {
        DBG_INFO("Calling SetAbort() on the context...");
        IUnknown* pCtx = CallData->pDestCtx;
        IObjectContext* pObjCtx = NULL;

        HRESULT hr2 = pCtx->QueryInterface(IID_IObjectContext, (void**)&pObjCtx);
        if(SUCCEEDED(hr2))
        {
            pObjCtx->SetAbort();
            pObjCtx->Release();
        }
        // If we weren't able to get IObjectContext, just give up and
        // assume that the rest of the world will deal with our inadequacy.

        DBG_INFO("Done with SetAbort...");
    }

    DBG_INFO("Done with callback function");

    return(fExcept ? COR_E_EXCEPTION : S_OK);
}

HRESULT Callback::MarshalCallback(ComCallData* pData)
{
    UserMarshalData* MarshalData = NULL;
    HRESULT hr = S_OK;

    DBG_INFO("entering MarshalCallback...");

    // Steps:
    // 1. Get the args.
    MarshalData = UserMarshalData::Get(TOINTPTR(pData->pUserDefined));

    DWORD     size = 0;
    IUnknown* pUnk = (IUnknown*)TOPTR(MarshalData->pUnk);

    // 2. marshal...
    hr = CoGetMarshalSizeMax(&size, IID_IUnknown, pUnk, MSHCTX_INPROC,
                             NULL, MSHLFLAGS_NORMAL);
    if(SUCCEEDED(hr))
    {
        size += sizeof(MarshalPacket);

        try
        {
            MarshalData->buffer = new Byte[size];
        }
        catch(OutOfMemoryException*)
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            Byte __pin* pinb = &(MarshalData->buffer[0]);
            BYTE __nogc* pBuf = pinb;

            _ASSERTM((DWORD)(MarshalData->buffer->get_Length()) == size);

            hr = MarshalInterface(pBuf, size, pUnk, MSHCTX_INPROC);
        }
    }

    return(hr);
}

Byte Callback::SwitchMarshal(IntPtr ctx, IntPtr ptr) __gc[]
{
    Proxy::Init();

    DBG_INFO("entering SwitchMarshal...");

    Byte buffer[]               = NULL;
    IUnknown* pUnk              = (IUnknown*)TOPTR(ptr);
    IContextCallback* pCB       = NULL;
    HRESULT hr                  = S_OK;
    UserMarshalData* MarshalData = NULL;

    ComCallData2 cbData;

    cbData.CallData.dwDispid     = 0;
    cbData.CallData.dwReserved   = 0;
    cbData.CallData.pUserDefined = 0;
    cbData.RealCall              = _pfnMarshal;

    try
    {
        _ASSERTM(ctx != (IntPtr)-1 && ctx != (IntPtr)0);

        // 1. Get the destination context.
        IUnknown* pCtx = static_cast<IUnknown*>(TOPTR(ctx));

        // 2. QI for IContextCallback
        hr = pCtx->QueryInterface(IID_IContextCallback, (void**)&pCB);
        if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);

        // 3. Pin some callback data:  This is slightly bad, because it
        // means we've got data pinned across a DCOM call.
        MarshalData = new UserMarshalData(ptr);

        cbData.CallData.pUserDefined = TOPTR(MarshalData->Pin());

        // 4. Call ContextCallback
        // REVIEW: Should we enter on IEnterActivityWithNoLock? Should we
        // check for the GipBypass regkey, and then enter with no lock?
        hr = pCB->ContextCallback(FilteringCallbackFunction,
                                  (ComCallData*)&cbData,
                                  IID_IUnknown,
                                  2, // release call?
                                  pUnk);
        if(FAILED(hr))
            Marshal::ThrowExceptionForHR(hr);

        // 5. Strip out the return value:
        buffer = MarshalData->buffer;
    }
    __finally
    {
        // 8. Cleanup.
        if(cbData.CallData.pUserDefined != 0) MarshalData->Unpin(cbData.CallData.pUserDefined);
        if(pCB != NULL) pCB->Release();
    }

    DBG_INFO("Done with SwitchMarshal");

    return(buffer);
}

IMessage* Callback::DoCallback(Object* otp,
                               IMessage* msg,
                               IntPtr ctx,
                               bool fIsAutoDone,
                               MemberInfo* mb, bool bHasGit)
{
    Proxy::Init();

    DBG_INFO("entering DoCallback...");

    IUnknown* pUnk             = NULL;
    IContextCallback* pCB      = NULL;
    HRESULT hr                 = S_OK;
    IMessage* ret              = NULL;
    UserCallData* CallData = NULL;
    ComCallData2 cbData;

    cbData.CallData.dwDispid     = 0;
    cbData.CallData.dwReserved   = 0;
    cbData.CallData.pUserDefined = 0;
    cbData.RealCall              = _pfn;

    try
    {
        // IProxyInvoke* rpx = __try_cast<IProxyInvoke*>(RemotingServices::GetRealProxy(otp));
        // Steps:
        // 1. Get the proxy IUnknown.
        // pUnk = (IUnknown*)TOPTR(rpx->GetRawIUnknown());
        // TODO:  re-enable this assert
        // _ASSERTM(pUnk != NULL);
        _ASSERTM(ctx != (IntPtr)-1 && ctx != (IntPtr)0);

	RealProxy* rpx = RemotingServices::GetRealProxy(otp);
        if (bHasGit)
              pUnk = (IUnknown*)TOPTR(rpx->GetCOMIUnknown(FALSE));

        // 2. Get the destination context.
        IUnknown* pCtx = static_cast<IUnknown*>(TOPTR(ctx));

        // 3. QI for IContextCallback
        hr = pCtx->QueryInterface(IID_IContextCallback, (void**)&pCB);
        if(FAILED(hr)) Marshal::ThrowExceptionForHR(hr);

        // 4. Calculate slot
        int slot = fIsAutoDone?7:8;
        IID iid = IID_IRemoteDispatch;

        Type* reflt = mb->get_ReflectedType();
        if(reflt->get_IsInterface())
        {
            Guid guid  = Marshal::GenerateGuidForType(reflt);
			iid = *((IID*)&guid);

            slot = Marshal::GetComSlotForMethodInfo(mb);
        }

        // 5. Pin some callback data:  This is slightly bad, because it
        // means we've got data pinned across a DCOM call.
        CallData = new UserCallData(otp, msg, ctx, fIsAutoDone, mb);

        cbData.CallData.pUserDefined = TOPTR(CallData->Pin());

        // 6. Call ContextCallback
        hr = pCB->ContextCallback(FilteringCallbackFunction,
                                  (ComCallData*)&cbData,
                                  iid,
                                  slot,
                                  pUnk);

        // 7. Strip out the return value:
        ret = CallData->msg;

        // ERROR HANDLING:  If hr is a failure HR, we need to check
        // first to see if an infrastructure failure occurrd (CallData
        // ->except).  If so, then we throw that.  Otherwise, if
        // a user exception occurred, we need to leave it in the
        // message, and don't throw ourselves.

        if(CallData->except)
        {
            // TODO:  Wrap this in a ServicedComponentException.
            throw CallData->except;
        }

        if(FAILED(hr) && hr != COR_E_EXCEPTION)
        {
            Marshal::ThrowExceptionForHR(hr);
        }
    }
    __finally
    {
        // 8. Cleanup.
        if(cbData.CallData.pUserDefined != 0) CallData->Unpin(cbData.CallData.pUserDefined);
        if(pUnk != NULL) pUnk->Release();
        if(pCB  != NULL) pCB->Release();
    }

    DBG_INFO("Done with DoCallback");

    return(ret);
}

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\simplestream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _UMCSVCS_BUFFER_STREAM_H
#define _UMCSVCS_BUFFER_STREAM_H

struct MarshalPacket
{
    DWORD size;
};

STDAPI MarshalInterface(BYTE* pBuf, int cb, IUnknown* pUnk, DWORD mshctx);
STDAPI UnmarshalInterface(BYTE* pBuf, int cb, void** ppv);
STDAPI ReleaseMarshaledInterface(BYTE* pBuf, int cb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\thunk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CustomMarshalers.cpp
//
// This file contains the assembly level attributes.
//
//*****************************************************************************
#include "managedheaders.h"
#include <__file__.ver>
#include "contextthunk.h"

OPEN_NAMESPACE()

using namespace System::Reflection;

//-----------------------------------------------------------------------
// Strong name the assembly (or half sign it, at least). 
//-----------------------------------------------------------------------
[assembly:AssemblyDelaySignAttribute(true), assembly:AssemblyKeyFileAttribute("../../../bin/FinalPublicKey.snk")];

//-----------------------------------------------------------------------
// Version number of the assembly.
//-----------------------------------------------------------------------
[assembly:AssemblyVersionAttribute(VER_FILEVERSION_STR)];

[assembly:CLSCompliant(true)];

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\swcthunk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma once

#include "ContextAPI.h"
#include "namespace.h"

OPEN_NAMESPACE()

using namespace System;
using namespace System::Runtime::InteropServices;

__gc private class ServiceConfigThunk
{  
private:
    IUnknown *m_pUnkSC;

    CSC_TrackerConfig m_tracker;
    IntPtr m_pTrackerAppName;
    IntPtr m_pTrackerCtxName;

public:
    ServiceConfigThunk();
    ~ServiceConfigThunk(); 
    
    __property IUnknown *get_ServiceConfigUnknown();
    
    __property void set_Inheritance(int val);

    __property void set_ThreadPool(int val);
    __property void set_Binding(int val);
    
    __property void set_Transaction(int val);
    __property void set_TxIsolationLevel(int val);
    __property void set_TxTimeout(int val);
    __property void set_TipUrl(String *pstrVal);
    __property void set_TxDesc(String *pstrVal);
    __property void set_Byot(Object *pObj);

    __property void set_Synchronization(int val);

    __property void set_IISIntrinsics(bool bVal);
    __property void set_COMTIIntrinsics(bool bVal);

    __property void set_Tracker(bool bVal);
    __property void set_TrackerAppName(String *pstrVal);
    __property void set_TrackerCtxName(String *pstrVal);

    __property void set_Sxs(int val);
    __property void set_SxsName(String *pstrVal);
    __property void set_SxsDirectory(String *pstrVal);

    __property void set_Partition(int val);
    __property void set_PartitionId(Guid val);          
};

__gc private class ServiceDomainThunk
{
private:
    static ServiceDomainThunk()
    {
        HMODULE hCS = LoadLibraryW(L"comsvcs.dll");
        if(!hCS || hCS == INVALID_HANDLE_VALUE)
            THROWERROR(HRESULT_FROM_WIN32(GetLastError()));

        CoEnterServiceDomain = (FN_CoEnterServiceDomain)GetProcAddress(hCS, "CoEnterServiceDomain");
        CoLeaveServiceDomain = (FN_CoLeaveServiceDomain)GetProcAddress(hCS, "CoLeaveServiceDomain");
        CoCreateActivity = (FN_CoCreateActivity)GetProcAddress(hCS, "CoCreateActivity");
    }

private public:
    typedef HRESULT (__stdcall *FN_CoEnterServiceDomain)(IUnknown* pConfigObject);
    typedef HRESULT (__stdcall *FN_CoLeaveServiceDomain)(IUnknown* pUnkStatus);
    typedef HRESULT (__stdcall *FN_CoCreateActivity)(IUnknown* pIUnknown, REFIID riid, void** ppObj);

    static FN_CoEnterServiceDomain CoEnterServiceDomain;
    static FN_CoLeaveServiceDomain CoLeaveServiceDomain;
    static FN_CoCreateActivity CoCreateActivity;    

public:
    static void EnterServiceDomain(ServiceConfigThunk *psct);
    static int LeaveServiceDomain();
};

__gc private class ServiceActivityThunk
{
public:
    IServiceActivity *m_pSA;

public:
    ServiceActivityThunk(ServiceConfigThunk *psct);
    ~ServiceActivityThunk();

    void SynchronousCall(Object *pObj);    
    void AsynchronousCall(Object *pObj);
    void BindToCurrentThread();
    void UnbindFromThread();
};

__gc private class SWCThunk
{
public:
    static bool IsSWCSupported();
};

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\txnstatus.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "unmanagedheaders.h"
#include "TxnStatus.h"

OPEN_NAMESPACE()

void* TransactionStatus::operator new(size_t sz)
{
    return CoTaskMemAlloc(sz);
}

void TransactionStatus::operator delete(void* pv, size_t sz)
{
    CoTaskMemFree(pv);
}

TransactionStatus::TransactionStatus()
{
    m_hrStatus = S_OK;
    m_cRefs = 1;
}

TransactionStatus *TransactionStatus::CreateInstance()
{
    return new TransactionStatus();
}

STDMETHODIMP TransactionStatus::QueryInterface(REFIID iid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;
    
    if (iid == IID_IUnknown || iid == IID_ITransactionStatus)
    {
        *ppvObj = (IUnknown *)this;
        AddRef();
        
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) TransactionStatus::AddRef()
{
    return (++m_cRefs);
}

STDMETHODIMP_(ULONG) TransactionStatus::Release()
{
    if ((--m_cRefs) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRefs;
}

STDMETHODIMP TransactionStatus::SetTransactionStatus(HRESULT hrStatus)
{
    m_hrStatus = hrStatus;

    return S_OK;
}

STDMETHODIMP TransactionStatus::GetTransactionStatus(HRESULT *phrStatus)
{
    if (phrStatus == NULL)
        return E_POINTER;

    *phrStatus = m_hrStatus;

    return S_OK;
}

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\txnstatus.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma once

OPEN_NAMESPACE()

class TransactionStatus : public ITransactionStatus
{
private:
    TransactionStatus();

    void* operator new(size_t sz);
    void operator delete(void* pv, size_t sz);
    
public:
    static TransactionStatus *CreateInstance();
    
    STDMETHOD(QueryInterface)(REFIID iid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    
    STDMETHOD(SetTransactionStatus)(HRESULT hrStatus);
    STDMETHOD(GetTransactionStatus)(HRESULT* pHrStatus);

private:
    HRESULT m_hrStatus;
    int m_cRefs;
};

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\unmanagedheaders.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "unmanagedheaders.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\swcthunk.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "managedheaders.h"
#include "SWCThunk.h"
#include "TxnStatus.h"

OPEN_NAMESPACE()

ServiceConfigThunk::ServiceConfigThunk()
{
    HRESULT hr;
    IUnknown *pUnk;

    m_pUnkSC = NULL;
    m_tracker = CSC_DontUseTracker;
    
    hr = CoCreateInstance(CLSID_CServiceConfig, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IUnknown, 
                          (void **)&pUnk);
    
    if (hr == CO_E_NOTINITIALIZED)
    {
        THROWERROR(CoInitializeEx(0, COINIT_MULTITHREADED));
        THROWERROR(CoCreateInstance(CLSID_CServiceConfig, 
                                    NULL, 
                                    CLSCTX_INPROC_SERVER, 
                                    IID_IUnknown, 
                                    (void **)&pUnk));
    }
    else
    {
        THROWERROR(hr);
    }

    m_pTrackerAppName = Marshal::StringToCoTaskMemUni("");
    m_pTrackerCtxName = Marshal::StringToCoTaskMemUni("");
    
    m_pUnkSC = pUnk;      
}

ServiceConfigThunk::~ServiceConfigThunk()
{
    if (m_pUnkSC)
    {
        m_pUnkSC->Release();
        m_pUnkSC = NULL;
    }

    if (m_pTrackerAppName != IntPtr::Zero)
        Marshal::FreeCoTaskMem(m_pTrackerAppName);

    if (m_pTrackerCtxName != IntPtr::Zero)
        Marshal::FreeCoTaskMem(m_pTrackerCtxName);
}

IUnknown *ServiceConfigThunk::get_ServiceConfigUnknown()
{
    if (m_pUnkSC != NULL)
        m_pUnkSC->AddRef();    
    
    return m_pUnkSC;
}  

void ServiceConfigThunk::set_Inheritance(int value)
{
     _ASSERTM(m_pUnkSC != NULL);
    
     IServiceInheritanceConfig *pSic = NULL;
     HRESULT hr;
     
    __try
    {       
        hr = m_pUnkSC->QueryInterface(IID_IServiceInheritanceConfig, (void **)&pSic);
        Marshal::ThrowExceptionForHR(hr);

        hr = pSic->ContainingContextTreatment((CSC_InheritanceConfig)value);
        Marshal::ThrowExceptionForHR(hr);        
    }
    __finally
    {
        if (pSic != NULL)
            pSic->Release();
    }        
}
    
void ServiceConfigThunk::set_ThreadPool(int value)
{
     _ASSERTM(m_pUnkSC != NULL);
        
     IServiceThreadPoolConfig *pTP = NULL;
     HRESULT hr;
        
    __try
    {       
        hr = m_pUnkSC->QueryInterface(IID_IServiceThreadPoolConfig, (void **)&pTP);
        Marshal::ThrowExceptionForHR(hr);

        hr = pTP->SelectThreadPool((CSC_ThreadPool)value);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {    
        if (pTP != NULL)
            pTP->Release();
    }
}

void ServiceConfigThunk::set_Binding(int value)
{
    _ASSERTM(m_pUnkSC != NULL);
    
    IServiceThreadPoolConfig *pTP = NULL;
    HRESULT hr;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceThreadPoolConfig, (void **)&pTP);
        Marshal::ThrowExceptionForHR(hr);

        hr = pTP->SetBindingInfo((CSC_Binding)value);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pTP != NULL)
            pTP->Release() ;
    }
}

void ServiceConfigThunk::set_Transaction(int value)
{
    _ASSERTM(m_pUnkSC != NULL);
    
    IServiceTransactionConfig *pTx = NULL;
    HRESULT hr;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceTransactionConfig, (void **)&pTx);
        Marshal::ThrowExceptionForHR(hr);

        // Fixup difference between ES's TransactionOption enum and COM+'s CSC_TransactionConfig enum.
        if (value > 0)
            value--;

        hr = pTx->ConfigureTransaction((CSC_TransactionConfig)value); 
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pTx != NULL)
            pTx->Release();
    }
}

void ServiceConfigThunk::set_TxIsolationLevel(int value)
{
    _ASSERTM(m_pUnkSC != NULL);
    
    IServiceTransactionConfig *pTx = NULL;
    HRESULT hr;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceTransactionConfig, (void **)&pTx);
        Marshal::ThrowExceptionForHR(hr);   

        hr = pTx->IsolationLevel((COMAdminTxIsolationLevelOptions)value);        
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pTx != NULL)
           pTx->Release();
    }
}

void ServiceConfigThunk::set_TxTimeout(int value)
{
    _ASSERTM(m_pUnkSC != NULL);
    
    IServiceTransactionConfig *pTx = NULL;
    HRESULT hr;
    
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceTransactionConfig, (void **)&pTx);
        Marshal::ThrowExceptionForHR(hr);   

        hr = pTx->TransactionTimeout((ULONG)value);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pTx != NULL)
            pTx->Release();
    }
}

void ServiceConfigThunk::set_TipUrl(String *pstrVal)
{
    _ASSERTM(m_pUnkSC != NULL);
                
    IServiceTransactionConfig *pTx = NULL;
    HRESULT hr;
    IntPtr pVal;
    
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceTransactionConfig, (void **)&pTx);
        Marshal::ThrowExceptionForHR(hr);

        pVal = Marshal::StringToCoTaskMemUni(pstrVal);

        hr = pTx->BringYourOwnTransaction((LPCWSTR)(void *)pVal);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pVal != IntPtr::Zero)
            Marshal::FreeCoTaskMem(pVal);
        
        if (pTx != NULL)
            pTx->Release();
    }
}

void ServiceConfigThunk::set_TxDesc(String *pstrVal)
{
    _ASSERTM(m_pUnkSC != NULL);
        
    IServiceTransactionConfig *pTx = NULL;
    HRESULT hr;
    IntPtr pVal;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceTransactionConfig, (void **)&pTx);
        Marshal::ThrowExceptionForHR(hr);

        pVal = Marshal::StringToCoTaskMemUni(pstrVal);

        hr = pTx->NewTransactionDescription((LPCWSTR)(void *)pVal);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pVal != IntPtr::Zero)
            Marshal::FreeCoTaskMem(pVal);
        
        if (pTx != NULL)
            pTx->Release();
    }
}

void ServiceConfigThunk::set_Byot(Object *obj)
{

    _ASSERTM(m_pUnkSC != NULL);

    IUnknown *pUnk = NULL;
    ITransaction *pTransaction = NULL;
    IServiceTransactionConfig *pTx = NULL;    
    HRESULT hr;    

    __try
    {
        if (obj != NULL)
        {
            pUnk = (IUnknown *)(void *)Marshal::GetIUnknownForObject(obj);
            _ASSERT(pUnk != NULL);

            hr = pUnk->QueryInterface(IID_ITransaction, (void **)&pTransaction);
            Marshal::ThrowExceptionForHR(hr);
        }
        
        hr = m_pUnkSC->QueryInterface(IID_IServiceTransactionConfig, (void **)&pTx);    
        Marshal::ThrowExceptionForHR(hr);
        
        hr = pTx->ConfigureBYOT(pTransaction);
        Marshal::ThrowExceptionForHR(hr);

        GC::KeepAlive(obj);
    }
    __finally
    {
        if (pTx != NULL)
            pTx->Release();
        if (pUnk != NULL)
            pUnk->Release();
        if (pTransaction != NULL)    
            pTransaction->Release();
    }
}

void ServiceConfigThunk::set_Synchronization(int value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceSynchronizationConfig *pSync = NULL;
    HRESULT hr;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceSynchronizationConfig, (void **)&pSync);
        Marshal::ThrowExceptionForHR(hr);   

        // Fixup difference between ES's SynchronizationOption enum and COM+'s CSC_SynchronizationConfig enum.
        if (value > 0)
            value--;
        
        hr = pSync->ConfigureSynchronization((CSC_SynchronizationConfig)value);        
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pSync != NULL)
            pSync->Release();
    }
}

void ServiceConfigThunk::set_IISIntrinsics(bool value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceIISIntrinsicsConfig *pIiisi = NULL;
    HRESULT hr;

    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceIISIntrinsicsConfig, (void **)&pIiisi);
        Marshal::ThrowExceptionForHR(hr);   

        hr = pIiisi->IISIntrinsicsConfig(value ? CSC_InheritIISIntrinsics : CSC_NoIISIntrinsics);        
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pIiisi != NULL)
            pIiisi->Release();
    }
}

void ServiceConfigThunk::set_COMTIIntrinsics(bool value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceComTIIntrinsicsConfig *pComTii = NULL;
    HRESULT hr;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceComTIIntrinsicsConfig, (void **)&pComTii);
        Marshal::ThrowExceptionForHR(hr);   

        hr = pComTii->ComTIIntrinsicsConfig(value ? CSC_InheritCOMTIIntrinsics : CSC_NoCOMTIIntrinsics);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pComTii != NULL)
            pComTii->Release();
    }
}

void ServiceConfigThunk::set_Tracker(bool value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceTrackerConfig *pTracker = NULL;
    HRESULT hr;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceTrackerConfig, (void **)&pTracker);
        Marshal::ThrowExceptionForHR(hr);

        hr = pTracker->TrackerConfig(value ? CSC_UseTracker : CSC_DontUseTracker,
                                    (LPCWSTR)(void *)m_pTrackerAppName,
                                    (LPCWSTR)(void *)m_pTrackerCtxName);        
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {    
        if (pTracker != NULL)
            pTracker->Release();        
    }

    m_tracker = value ? CSC_UseTracker : CSC_DontUseTracker;    
    GC::KeepAlive(this);
}

void ServiceConfigThunk::set_TrackerAppName(String *value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceTrackerConfig *pTracker = NULL;
    HRESULT hr;
    IntPtr pVal;

    __try
    {       
        hr = m_pUnkSC->QueryInterface(IID_IServiceTrackerConfig, (void **)&pTracker);
        Marshal::ThrowExceptionForHR(hr);

        pVal = Marshal::StringToCoTaskMemUni(value);

        hr = pTracker->TrackerConfig(m_tracker, (LPCWSTR)(void *)pVal, (LPCWSTR)(void *)m_pTrackerCtxName);
        if (FAILED(hr))
        {
            Marshal::FreeCoTaskMem(pVal);
            pVal = Marshal::StringToCoTaskMemUni("");
            Marshal::ThrowExceptionForHR(hr);
        }        
    }
    __finally
    {
        if (m_pTrackerAppName != IntPtr::Zero)
            Marshal::FreeCoTaskMem(m_pTrackerAppName);                     

        if (pTracker != NULL)
            pTracker->Release();

        m_pTrackerAppName = pVal;  
    }
    
    GC::KeepAlive(this);
}

void ServiceConfigThunk::set_TrackerCtxName(String *value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceTrackerConfig *pTracker = NULL;
    HRESULT hr;
    IntPtr pVal;

    __try
    {       
        hr = m_pUnkSC->QueryInterface(IID_IServiceTrackerConfig, (void **)&pTracker);
        Marshal::ThrowExceptionForHR(hr);

        pVal = Marshal::StringToCoTaskMemUni(value);

        hr = pTracker->TrackerConfig(m_tracker, (LPCWSTR)(void *)m_pTrackerAppName, (LPCWSTR)(void *)pVal);    
        if (FAILED(hr))
        {
            Marshal::FreeCoTaskMem(pVal);
            pVal = Marshal::StringToCoTaskMemUni("");
            Marshal::ThrowExceptionForHR(hr);
        }    
    }
    __finally
    {
        if (m_pTrackerCtxName != IntPtr::Zero)
            Marshal::FreeCoTaskMem(m_pTrackerCtxName);
        
        if (pTracker != NULL)
            pTracker->Release();

        m_pTrackerCtxName = pVal;
    }
    
    GC::KeepAlive(this);
}

void ServiceConfigThunk::set_Sxs(int value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceSxsConfig *pSxs = NULL;
    HRESULT hr;
        
    __try
    {      
        hr = m_pUnkSC->QueryInterface(IID_IServiceSxsConfig, (void **)&pSxs);
        Marshal::ThrowExceptionForHR(hr);

        hr = pSxs->SxsConfig((CSC_SxsConfig)value);    
        Marshal::ThrowExceptionForHR(hr);
    }   
    __finally
    {
        if (pSxs != NULL)
            pSxs->Release();
    }
}

void ServiceConfigThunk::set_SxsName(String *value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceSxsConfig *pSxs = NULL;
    HRESULT hr;
    IntPtr pVal;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceSxsConfig, (void **)&pSxs);
        Marshal::ThrowExceptionForHR(hr);

        pVal = Marshal::StringToCoTaskMemUni(value);

        hr = pSxs->SxsName((LPCWSTR)(void *)pVal);    
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pVal != IntPtr::Zero)
            Marshal::FreeCoTaskMem(pVal);

        if (pSxs != NULL)
            pSxs->Release();
    }
}

void ServiceConfigThunk::set_SxsDirectory(String *value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServiceSxsConfig *pSxs = NULL;
    HRESULT hr;
    IntPtr pVal;
        
    __try
    {        
        hr = m_pUnkSC->QueryInterface(IID_IServiceSxsConfig, (void **)&pSxs);
        Marshal::ThrowExceptionForHR(hr);

        pVal = Marshal::StringToCoTaskMemUni(value);
    
        hr = pSxs->SxsDirectory((LPCWSTR)(void *)pVal);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pVal != IntPtr::Zero)            
            Marshal::FreeCoTaskMem(pVal);

        if (pSxs != NULL)
            pSxs->Release();
    }
}

void ServiceConfigThunk::set_Partition(int value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServicePartitionConfig *pPart = NULL;
    HRESULT hr;
        
    __try
    {       
        hr = m_pUnkSC->QueryInterface(IID_IServicePartitionConfig, (void **)&pPart);
        Marshal::ThrowExceptionForHR(hr);

        hr = pPart->PartitionConfig((CSC_PartitionConfig)value);    
        Marshal::ThrowExceptionForHR(hr);
    }   
    __finally
    {
        if (pPart != NULL)
            pPart->Release();
    }
}

void ServiceConfigThunk::set_PartitionId(Guid value)
{
    _ASSERTM(m_pUnkSC != NULL);

    IServicePartitionConfig *pPart = NULL;
    HRESULT hr;
    IntPtr pVal;
        
    __try
    {       
        hr = m_pUnkSC->QueryInterface(IID_IServicePartitionConfig, (void **)&pPart);
        Marshal::ThrowExceptionForHR(hr);

        _ASSERTM(Marshal::SizeOf(__box(value)) == sizeof(GUID));
        pVal = Marshal::AllocCoTaskMem(Marshal::SizeOf(__box(value)));
        Marshal::StructureToPtr(__box(value), pVal, false);

        hr = pPart->PartitionID(*(GUID *)(void *)pVal);    
        Marshal::ThrowExceptionForHR(hr);
    }   
    __finally
    {
        if (pVal != IntPtr::Zero)
            Marshal::FreeCoTaskMem(pVal);

        if (pPart != NULL)
            pPart->Release();
    }
}

void ServiceDomainThunk::EnterServiceDomain(ServiceConfigThunk *psct)
{
    IUnknown *pUnkSC = psct->ServiceConfigUnknown;
    HRESULT hr;

    _ASSERTM(pUnkSC != NULL);
   
    hr = ServiceDomainThunk::CoEnterServiceDomain(pUnkSC);
    pUnkSC->Release();

    Marshal::ThrowExceptionForHR(hr);
}

int ServiceDomainThunk::LeaveServiceDomain()
{
    TransactionStatus *pTxnStatus = NULL;
    HRESULT hr = S_OK;

    pTxnStatus = TransactionStatus::CreateInstance();

    if (pTxnStatus == NULL)
        throw new OutOfMemoryException;

    ServiceDomainThunk::CoLeaveServiceDomain(pTxnStatus);   

    pTxnStatus->GetTransactionStatus(&hr);
    pTxnStatus->Release();
    
    return hr;
}

ServiceActivityThunk::ServiceActivityThunk(ServiceConfigThunk *sct)
{
    IUnknown *pUnkSC = sct->ServiceConfigUnknown;
    IServiceActivity *pSA;
    m_pSA = NULL;
    HRESULT hr = S_OK;

    _ASSERTM(pUnkSC != NULL);

    hr = ServiceDomainThunk::CoCreateActivity(pUnkSC, IID_IServiceActivity, (void **)&pSA);
    pUnkSC->Release();
    Marshal::ThrowExceptionForHR(hr);

    m_pSA = pSA;
}

ServiceActivityThunk::~ServiceActivityThunk()
{
    if (m_pSA != NULL)
    {
        m_pSA->Release();
        m_pSA = NULL;
    }
}

void ServiceActivityThunk::SynchronousCall(Object *obj)
{
    _ASSERTM(m_pSA != NULL);

    IUnknown *pUnk = NULL;
    IServiceCall *pSrvCall = NULL;
    HRESULT hr;
        
    __try
    {       
        pUnk = (IUnknown *)(void *)Marshal::GetIUnknownForObject(obj);
        _ASSERTM(pUnk != NULL);

        hr = pUnk->QueryInterface(IID_IServiceCall, (void **)&pSrvCall);
        Marshal::ThrowExceptionForHR(hr);
        
        hr = m_pSA->SynchronousCall(pSrvCall);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pSrvCall != NULL)
            pSrvCall->Release();
    
        if (pUnk != NULL)
            pUnk->Release();

    }
}

void ServiceActivityThunk::AsynchronousCall(Object *obj)
{
    _ASSERTM(m_pSA != NULL);

    IUnknown *pUnk = NULL;
    IServiceCall *pSrvCall = NULL;
    HRESULT hr;

    __try
    {
        pUnk = (IUnknown *)(void *)Marshal::GetIUnknownForObject(obj);
        _ASSERTM(pUnk != NULL);

        hr = pUnk->QueryInterface(IID_IServiceCall, (void **)&pSrvCall);
        Marshal::ThrowExceptionForHR(hr);
        
        hr = m_pSA->AsynchronousCall(pSrvCall);
        Marshal::ThrowExceptionForHR(hr);
    }
    __finally
    {
        if (pSrvCall != NULL)
            pSrvCall->Release();

        if (pUnk != NULL)
            pUnk->Release();
    }
}

void ServiceActivityThunk::BindToCurrentThread()
{
    _ASSERTM(m_pSA != NULL);

    HRESULT hr;

    hr = m_pSA->BindToCurrentThread();
    Marshal::ThrowExceptionForHR(hr);
}

void ServiceActivityThunk::UnbindFromThread()
{
    _ASSERTM(m_pSA != NULL);

    HRESULT hr;

    hr = m_pSA->UnbindFromThread();
    Marshal::ThrowExceptionForHR(hr);
}

bool SWCThunk::IsSWCSupported()
{
    IUnknown *pUnk = NULL;
    IServiceTransactionConfig *pTx = NULL;
    HRESULT hr = S_OK;

    // Weird as it seems, this is how we check for SWC functionality. 
    // The reason is that XP Client shipped with an incomplete implementation of SWC. Officialy, SWC
    // doesn't even exisit on XP Client as originally shipped. At some point, after Everett ships, 
    // the "good" SWC implementation will be ported back to XP Client via a service pack.
    // We can't use the OS version for our check because Everett may ship before the service pack.
    // We can't use the COM+ catalog version because both XP Client and .NET Server use the same
    // version. If we updated the version on .NET Server we'd have to change it on XP Client in the
    // service pack and that may break someone else.
    // IServiceTransactionConfig only exists on the "good" SWC so we use that as an indicator of its
    // presence.
    // On Win2K, CServiceConfig doesn't exist.
   
    hr = CoCreateInstance(CLSID_CServiceConfig, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IUnknown, 
                          (void **)&pUnk);

    if (hr == REGDB_E_CLASSNOTREG)
        return false;

    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(IID_IServiceTransactionConfig, (void **)&pTx);
        if (hr == E_NOINTERFACE)
        {
            pUnk->Release();
            
            return false;
        }
    }

    if (pTx != NULL)
        pTx->Release();

    if (pUnk != NULL)
        pUnk->Release();

    Marshal::ThrowExceptionForHR(hr);
    
    return true;
}

CLOSE_NAMESPACE()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\unmanagedheaders.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "headers.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservices.thunk\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "System.EnterpriseService.Thunk.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Services Native Thunks\0"
#define VER_ORIGFILENAME_STR    "System.EnterpriseServices.Thunk.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "System.Runtime.Remoting.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Object Remoting\0"
#define VER_ORIGFILENAME_STR    "System.Runtime.Remoting.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\activation\activationhook.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.IO;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Activation;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Messaging;
using System.Text;


namespace System.Runtime.Remoting.Channels
{    

    // BUGBUG: GET RID OF THIS CLASS BEFORE RTM!!!
    public class ActivationHook
    {

        public static void ProcessRequest(
            String scheme,
            String url,
            byte[] requestData,
            int requestOffset,  
            int requestSize,       
            out byte[] responseData,
            out int responseOffset,
            out int responseSize            
            )
        {
            try
            {               
                throw new NotImplementedException();
            }
            catch (Exception e)
            {
                throw e;
            }
        } // ProcessRequest        

    } // class ActivationHook    


} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\enterpriseservicesps\entsvcps.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

HRESULT STDAPICALLTYPE DllGetClassObjectInternal(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(DllGetClassObject(rclsid, riid, ppv));
}

extern ProxyFileInfo  *  aProxyFileList[];

/* DllRegisterServer registers the interfaces contained in the proxy DLL. */ 
HRESULT STDAPICALLTYPE DllRegisterServer() 
{ 
    WCHAR* szRegPath;
	HMODULE hProxyDll = NULL;
	HRESULT hr = S_OK;
    HKEY hKey;
    int error;

    szRegPath = (WCHAR*)_alloca(sizeof(WCHAR)*MAX_PATH);

	hProxyDll = LoadLibrary(L"mscoree.dll");
	if (hProxyDll)
	{
        hr = NdrDllRegisterProxy(hProxyDll, aProxyFileList, GET_DLL_CLSID);
		FreeLibrary(hProxyDll);

        if(SUCCEEDED(hr))
        {
            // Add the "Server" key to GET_DLL_CLSID:
            lstrcpyW(szRegPath, L"CLSID\\");
            StringFromGUID2(GET_DLL_CLSID, szRegPath+6, MAX_PATH-6);
            lstrcatW(szRegPath, L"\\Server");
            
            error = RegCreateKeyExW(HKEY_CLASSES_ROOT, 
                                    szRegPath, 
                                    0,
                                    NULL,
                                    0,
                                    KEY_WRITE,
                                    NULL,
                                    &hKey,
                                    NULL);
            if(!error)
            {
                // Server = System.EnterpriseServices.Thunk.dll
                error = RegSetValueExA(hKey, 
                                       NULL, 
                                       0,
                                       REG_SZ,
                                       "System.EnterpriseServices.Thunk.dll",
                                       sizeof("System.EnterpriseServices.Thunk.dll"));
                                       
                RegCloseKey(hKey);
            }

            if(error)
            {
                hr = HRESULT_FROM_WIN32(error);
            }
        }
	}
	else
		hr = E_FAIL;
	return hr;    
}  

/* DllUnregisterServer unregisters the interfaces contained in the proxy DLL. */ 
HRESULT STDAPICALLTYPE DllUnregisterServer() 
{ 
	HMODULE hProxyDll = NULL;
	HRESULT hr = S_OK;
	hProxyDll = LoadLibrary(L"System.EnterpriseServices.Thunk.dll");
	if (hProxyDll)
	{
	        hr = NdrDllUnregisterProxy(hProxyDll, aProxyFileList, GET_DLL_CLSID); 
            FreeLibrary(hProxyDll);
	}
	else
		hr = E_FAIL;
	return hr;
}

#ifdef __cplusplus
}  /*extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\sources.inc ===
#
# Viper build instructions for this directory
#
#   Derek Yenzer
#   March 1998

!CMDSWITCHES -I

NEWCALL_TOO             = 1             # todo remove this after everyone uses new calling conv

!include $(NTMAKEENV)\sources.cool

!ifdef PASS0ONLY
!else
!ifdef LINKONLY
NTTARGETFILE1   = cool_target_sign
!else
NTTARGETFILE0   = 
!endif
!endif

!include $(NTMAKEENV)\sources.cor

MINORCOMP       = Cool

# Note: We are not shipping Smtp channel .. if we do, we should reserve
# a baseAddr for it in the coffBase.txt files in clr/bin/i386/XXX/ directories
# Also, then we may want to not share resources, .rc files etc.

!IF "$(_REM_DLL_NAME)"=="MainDll"
TARGETNAME      = System.Runtime.Remoting
!ELSE
TARGETNAME      = System.Runtime.Remoting.Channels.Smtp
!ENDIF

TARGETPATH      = $(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)
TARGETTYPE      = DYNLINK
NO_BROWSER_FILE = 1
SOURCES         = 

COOL_SOURCE_DIR  = $(CORBASE)\src\Remoting
COOL_CLASS_DIR   = $(COOL_SOURCE_DIR)\$(_OBJ_DIR)\$(TARGET_DIRECTORY)
COOL_TARGET_TYPE = DYNLINK

# Set version information in assembly manifest
COOL_SET_VERSION = 1 
COOL_SET_STRONGNAME = EcmaPublicKey.snk

# Base address to load mscorlib.dll
COOL_BASE         = $(TARGETNAME)

SYNCHRONIZE_DRAIN=1

# Version resource

WIN32_RESOURCE_FILE =remoting.rc

IMPORTS = /R:System.Runtime.Serialization.Formatters.Soap.dll \
        /R:System.dll                           \
        /R:System.xml.dll                       \
        /R:System.Web.dll                       \
        /R:cscompmgd.dll                        \
        /R:System.Data.dll                      \
        /R:System.DirectoryServices.dll         \
#       /D:_DEBUG_CHANNEL \
        
        

### This is used in the ILCode Coverage System
### Please see cschertz before removing it

#ASSEMBLYTITLE="ObjectRemotingLibrary"
#ASSEMBLYDESC="Object Remoting Library"
#COOL_COMPILE_FLAGS = /d:_NEW_CLASSLOADER /nostdlib /d:NODEFAULTLIB /a 
COOL_COMPILE_FLAGS = /d:_NEW_CLASSLOADER

!ifndef _BUILD_WINCE
COOL_COMPILE_FLAGS = $(COOL_EXTRA_PREPROCESS_FLAGS) $(COOL_COMPILE_FLAGS) /d:_USE_NLS_PLUS_TABLE 
!else
COOL_COMPILE_FLAGS = $(COOL_EXTRA_PREPROCESS_FLAGS) $(COOL_COMPILE_FLAGS) /d:UNDER_CE
!endif

!ifndef COOLC_NO_DOC
!IF "$(_REM_DLL_NAME)"=="MainDll"
COOL_COMPILE_FLAGS = $(COOL_COMPILE_FLAGS) /doc:$(URTTARGET)\docs\System.Runtime.Remoting.csx
!ELSE
COOL_COMPILE_FLAGS = $(COOL_COMPILE_FLAGS) /doc:$(URTTARGET)\docs\System.Runtime.Remoting.Channels.Smtp.csx
!ENDIF
!endif

##COOLPORT
#

COOL_PERMISSION_REBUILD = 1
COOL_SECURITY_DB = SecurityDB

COOL_COMPILE_FLAGS = $(COOL_COMPILE_FLAGS) \
!ifdef CCOVER
    /linkres:$(TARGETPATH)\System.Runtime.Remoting.resources,System.Runtime.Remoting.resources
!else
    /res:$(TARGETPATH)\System.Runtime.Remoting.resources,System.Runtime.Remoting.resources
!endif

# The first set of ~17 files are in order of the classes 
# loaded at startup. Try not to change this order. Working set
# perf degrades if done so.
!IF "$(_TGTCPUTYPE)"!="Alpha"
ACTIVATION_SOURCES = \
        ..\Activation\Dispatcher.cs        \
        ..\Activation\ActivationHook.cs    \

CHANNELS_HTTP_SOURCES = \
        ..\Channels\HTTP\CombinedHttpChannel.cs \
        ..\Channels\HTTP\HttpChannelHelper.cs \
        ..\Channels\HTTP\HttpClientChannel.cs \
        ..\Channels\HTTP\HttpServerChannel.cs \
        ..\Channels\HTTP\HttpSocketManager.cs \
        ..\Channels\HTTP\HttpStreams.cs \
        ..\Channels\HTTP\NativeMethods.cs \
        $(O)\HTTPRemotingHandler.cs \
        
CHANNELS_SMTP_SOURCES = \
        ADODB.cs  \
        CDO.cs  \
        SMTPChannel.cs  \
        SMTPMail.cs  \
        SMTPMessageSink.cs  \
        SMTPRegisterSink.cs  \

CHANNELS_TCP_SOURCES = \
        ..\Channels\TCP\CombinedTcpChannel.cs \
        ..\Channels\TCP\TcpChannelHelper.cs \
        ..\Channels\TCP\TcpClientChannel.cs \
        ..\Channels\TCP\TcpClientSocketManager.cs \
        ..\Channels\TCP\TcpServerChannel.cs \
        ..\Channels\TCP\TcpSocketManager.cs \
        ..\Channels\TCP\TcpStreams.cs \
        ..\Channels\TCP\TcpWireProtocol.cs \

CHANNELS_CORE_SOURCES = \
        ..\Channels\CORE\BaseTransportHeaders.cs \
        ..\Channels\CORE\BasicAsyncResult.cs \
        ..\Channels\CORE\ByteBufferPool.cs \
        ..\Channels\CORE\ChunkedMemoryStream.cs \
        ..\Channels\CORE\CommonChannelKeys.cs \
        ..\Channels\CORE\CoreChannel.cs  \
        ..\Channels\CORE\ExclusiveTcpListener.cs \
        ..\Channels\CORE\RequestQueue.cs \
        ..\Channels\CORE\SocketCache.cs \
        ..\Channels\CORE\SocketManager.cs \
        ..\Channels\CORE\SocketStream.cs \
        ..\Channels\CORE\StreamHelper.cs  \
        ..\Channels\CORE\StringHelper.cs  \

CHANNELS_CORE_SOURCES_FOR_SMTP = \
        ..\Channels\CORE\BasicAsyncResult.cs \
        ..\Channels\CORE\ByteBufferPool.cs \
        ..\Channels\CORE\ChunkedMemoryStream.cs \
        ..\Channels\CORE\CommonChannelKeys.cs \
        ..\Channels\CORE\CoreChannel.cs  \
        ..\Channels\CORE\RequestQueue.cs \
        ..\Channels\CORE\SocketCache.cs \
        ..\Channels\CORE\SocketManager.cs \
        ..\Channels\CORE\SocketStream.cs \
        ..\Channels\CORE\StreamHelper.cs  \
        ..\Channels\CORE\StringHelper.cs  \

CHANNELS_SINKS_SOURCES = \
        ..\Channels\Sinks\BinaryFormatterSinks.cs \
        ..\Channels\Sinks\SoapFormatterSinks.cs \

METADATA_SOURCES = \
        ..\metadata\MetaData.cs \
        ..\metadata\SdlChannelSink.cs \
        ..\metadata\SudsParser.cs \
        ..\metadata\SudsWriter.cs \
        ..\metadata\SudsCommon.cs \
        ..\metadata\SdlParser.cs \
        ..\metadata\SdlWriter.cs \
        ..\metadata\WsdlParser.cs \
        ..\metadata\WsdlWriter.cs 

        
SERVICES_SOURCES = \
        ..\services\RemotingClientProxy.cs \
        ..\services\RemotingService.cs     \

!IF "$(_REM_DLL_NAME)"=="MainDll"
COOL_SOURCES  =    \
#       $(ACTIVATION_SOURCES)   \
        $(CHANNELS_CORE_SOURCES)        \
        $(CHANNELS_HTTP_SOURCES)        \
        $(CHANNELS_TCP_SOURCES) \
        $(CHANNELS_SINKS_SOURCES) \
        $(METADATA_SOURCES)     \
        $(SERVICES_SOURCES)     \
!ELSE
COOL_SOURCES  =    \
        $(CHANNELS_CORE_SOURCES_FOR_SMTP)        \
        $(CHANNELS_SMTP_SOURCES)        \
!ENDIF


!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\activation\dispatcher.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

// The Remoting runtime dispatcher
// 

namespace System.Runtime.Remoting.Activation{
    using System.Runtime.InteropServices;       
    using System.Collections;
    using System.Reflection;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Channels.Http;
    using System.Threading;
    using System.IO;
    using System.Text;

    [ComImport, Guid("08a2c56f-9999-41c1-a8be-432917a1a2d1"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
    public interface IRemotingDispatcher {
        void StartProcessing();

        void StopProcessing();

        [PreserveSig]
        int  ProcessRequest(
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            String url, 
                            int cbRequestHdrData,
                            [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)]
                            Byte[] requestHeadersAndBody,
                            out int cbResponseHdrData,
                            [Out, MarshalAs(UnmanagedType.LPArray)]
                            out Byte[] responseHeadersAndBody);

        [PreserveSig]
        int RequestConfigureRemoting(
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            String fullConfigFileName);
        void DoGCCollect();
    }


    [ClassInterface(ClassInterfaceType.None)]
    public sealed class RemotingDispatcher : IRemotingDispatcher
    {
        public RemotingDispatcher()
        {
            if (s_RemotingDispatcherHelper == null)
            {
                lock (typeof(RemotingDispatcher))
                {
                    s_RemotingDispatcherHelper = new RemotingDispatcherHelper();
                }
            }
        }

        // IRemotingDispatcher::StartProcessing
        public void StartProcessing()
        {
            throw new NotImplementedException();
            // Console.WriteLine("### Todo ###");
        }

        // IRemotingDispatcher::StopProcessing
        public void StopProcessing()
        {
            throw new NotImplementedException();
            // Console.WriteLine("### Todo ###");
        }

        // IRemotingDispatcher::ProcessRequest
        public int ProcessRequest(
            String url, 
            int cbReqHdrData,
            Byte[] reqHdrsAndBody, 
            out int cbResponseHdrData,
            out Byte[] respHdrsAndBody)
        {
            throw new NotImplementedException();

            /*
            return s_RemotingDispatcherHelper.ProcessRequest(
                                            url,
                                            cbReqHdrData,
                                            reqHdrsAndBody,
                                            out cbResponseHdrData,
                                            out respHdrsAndBody);
            */
        }

        // IRemotingDispatcher::RequestConfigureRemoting
        public int RequestConfigureRemoting(String fileName)
        {
            throw new NotImplementedException();

            // Assumes full path name for file
            /*
            return s_RemotingDispatcherHelper.RequestConfig(fileName);
            */
        }

        // IRemotingDispatcher::DoGCCollect   
        public void DoGCCollect()
        {
            throw new NotImplementedException();

            // Console.WriteLine("### Todo ###");
        }
        // Only one static object.
        static RemotingDispatcherHelper s_RemotingDispatcherHelper;
    }

    class RemotingDispatcherHelper
    {
        static int s_requestID = 0;
        static bool s_configDone = false;
        static HttpChannel s_chnl = null;

        internal RemotingDispatcherHelper()
        {

        }

        internal int ProcessRequest(
            String url, 
            int cbReqHdrData,
            Byte[] reqHdrsAndBody, 
            out int cbResponseHdrData,
            out Byte[] respHdrsAndBody)
        {
            int id = Interlocked.Increment(ref s_requestID);
            // Console.WriteLine("\n\n@@@ ProcessRequest: # " + id);
            // Console.WriteLine("    Req URI: " + url);
            // Console.WriteLine("\n\nReq HdrAndBody: "+Encoding.ASCII.GetString(reqHdrsAndBody));
            // Console.WriteLine("\n\n");

            // s_chnl.ProcessRequestResponseNP(reqHdrsAndBody);
            String s = " :: " + id + " ::System.Runtime.Remoting::Response Headers and Body!";
            respHdrsAndBody =  Encoding.ASCII.GetBytes(s);
            cbResponseHdrData = respHdrsAndBody.Length;
            int dummy = 0;
            ActivationHook.ProcessRequest(
                "http",
                url,
                reqHdrsAndBody,
                0,
                cbReqHdrData,
                out respHdrsAndBody,
                out dummy,
                out cbResponseHdrData);
                
            return 0;
        }

        internal int RequestConfig(
            String fileName)
        {
            if (!s_configDone)
            {
                if (true == File.Exists(fileName))
                {
                    try
                    {
                        RemotingConfiguration.Configure(fileName);
                    }
                    catch (Exception e)
                    {
                        // Console.WriteLine("Exception in ConfigRemoting"+ e); 
                        throw e;
                    }
                    s_configDone = true;
                    // BUGBUG: temporary HACK to get end-to-end activation
                    // going!!
                    s_chnl = (HttpChannel)ChannelServices.GetChannel("Http");
                }
            }
            return 0;
        }
    }
}

/*
    private void SendResponseFromFileStream(FileStream f, long offset, long leng
th)
    {
        long fileSize = f.Length;

        if (length == -1)
            length = fileSize - offset;

        if (offset < 0 || length > fileSize - offset)
            throw new HttpException(HttpRuntime.FormatResourceString(SR.Invalid_
range));

        if (length > 0)
        {
            if (offset > 0)
                f.Seek(offset, SeekOrigin.Begin);

            byte[] fileBytes = new byte[(int)length];
            int bytesRead = f.Read(fileBytes, 0, (int)length);
            WriteBytesCore(fileBytes, bytesRead);
        }
    }
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\basetransportheaders.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       BaseTransportHeaders.cs
//
//  Summary:    Base class for special-cased transport headers implementations.
//
//==========================================================================


using System;
using System.Collections;
using System.Globalization;
using System.Net;


namespace System.Runtime.Remoting.Channels
{

    [Serializable]
    internal class BaseTransportHeaders : ITransportHeaders
    {
        // IMPORTANT: If a new wellknown header is added, MapHeaderNameToIndex,
        //   GetValueFromHeaderIndex, and SetValueFromHeaderIndex methods must
        //   be updated (as well as WellknownHeaderCount)!!!

        internal const int WellknownHeaderCount = 4;

        private Object _connectionId; // 0) CommonTransportKeys.ConnectionId
        private Object _ipAddress;    // 1) CommonTransportKeys.IPAddress
    
        private String _requestUri;   // 2) CommonTransportKeys.RequestUri
        private String _contentType;  // 3) "Content-Type"


        // transport headers structure is for non well-known headers
        private ITransportHeaders _otherHeaders;


        public BaseTransportHeaders()
        {
            _otherHeaders = null;
        }


        public String RequestUri
        {
            get { return _requestUri; }
            set { _requestUri = value; }
        } // RequestUri


        public String ContentType
        {
            get { return _contentType; }
            set { _contentType = value; }
        } // ContentType


        public Object ConnectionId
        {
            set { _connectionId = value; }
        }

        public IPAddress IPAddress
        {
            set { _ipAddress = value; }
        }        


        //
        // ITransportHeaders implementation
        //

        public Object this[Object key]
        {
            get 
            {
                String strKey = key as String;
                if (strKey != null)
                {
                    int index = MapHeaderNameToIndex(strKey);
                    if (index != -1)
                        return GetValueFromHeaderIndex(index);
                }
            
                if (_otherHeaders != null)
                    return _otherHeaders[key];

                return null;
            } // get

            set
            {
                bool bSet = false;
            
                String strKey = key as String;
                if (strKey != null)
                {
                    int index = MapHeaderNameToIndex(strKey);
                    if (index != -1)     
                    {
                        SetValueFromHeaderIndex(index, value);
                        bSet = true;
                    }
                }

                if (!bSet)
                {
                    if (_otherHeaders == null)
                        _otherHeaders = new TransportHeaders();
                    _otherHeaders[key] = value;
                }
            } // set
        } // Object this[Object key]


        public IEnumerator GetEnumerator() 
        {
            return new BaseTransportHeadersEnumerator(this);
        } // GetEnumerator


        internal IEnumerator GetOtherHeadersEnumerator()
        {
            if (_otherHeaders == null)
                return null;

            return _otherHeaders.GetEnumerator();            
        } // GetOtherHeadersEnumerator



        internal int MapHeaderNameToIndex(String headerName)
        {
            // 0) CommonTransportKeys.ConnectionId
            // 1) CommonTransportKeys.IPAddress
            // 2) CommonTransportKeys.RequestUri
            // 3) "Content-Type"
            
            if (String.Compare(headerName, CommonTransportKeys.ConnectionId, true, CultureInfo.InvariantCulture) == 0)
                return 0;
            else
            if (String.Compare(headerName, CommonTransportKeys.IPAddress, true, CultureInfo.InvariantCulture) == 0)
                return 1;
            else
            if (String.Compare(headerName, CommonTransportKeys.RequestUri, true, CultureInfo.InvariantCulture) == 0)
                return 2;
            else
            if (String.Compare(headerName, "Content-Type", true, CultureInfo.InvariantCulture) == 0)
                return 3;

            return -1;
        } // MapHeaderNameToIndex


        internal String MapHeaderIndexToName(int index)
        {
            // 0) CommonTransportKeys.ConnectionId
            // 1) CommonTransportKeys.IPAddress
            // 2) CommonTransportKeys.RequestUri
            // 3) "Content-Type"

            switch (index)
            {
            case 0: return CommonTransportKeys.ConnectionId;
            case 1: return CommonTransportKeys.IPAddress;            
            case 2: return CommonTransportKeys.RequestUri;
            case 3: return "Content-Type";
            
            default: return null;
            }
            
        } // MapHeaderNameToIndex


        internal Object GetValueFromHeaderIndex(int index)
        {
            // NOTE: If this method returns the null, then that indicates the header has no
            //   value (i.e. isn't in the "dictionary"). For the purposes of iteration, this
            //   means that the header should be skipped.
        
            // 0) CommonTransportKeys.ConnectionId
            // 1) CommonTransportKeys.IPAddress
            // 2) CommonTransportKeys.RequestUri
            // 3) "Content-Type"

            switch (index)
            {
            case 0: return _connectionId;
            case 1: return _ipAddress;            
            case 2: return _requestUri;
            case 3: return _contentType;
            
            default: return null;
            }
            
        } // MapHeaderIndexToValue


        internal void SetValueFromHeaderIndex(int index, Object value)
        {
            // NOTE: If this method returns the null, then that indicates the header has no
            //   value (i.e. isn't in the "dictionary"). For the purposes of iteration, this
            //   means that the header should be skipped.
        
            // 0) CommonTransportKeys.ConnectionId
            // 1) CommonTransportKeys.IPAddress
            // 2) CommonTransportKeys.RequestUri
            // 3) "Content-Type"

            switch (index)
            {
            case 0: _connectionId = value; break;
            case 1: _ipAddress = value; break;        
            case 2: _requestUri = (String)value; break;
            case 3: _contentType = (String)value; break;

            default: 
            {
                InternalRemotingServices.RemotingAssert(false, "someone forgot to update this method"); 
                break;
            }
            
            } // switch (index)
            
        } // MapHeaderIndexToValue
        

    
    } // class BaseTransportHeaders



    internal class BaseTransportHeadersEnumerator : IEnumerator
    {
        private BaseTransportHeaders _headers;
        private bool _bStarted;
        private int _currentIndex;
        private IEnumerator _otherHeadersEnumerator;
    
        public BaseTransportHeadersEnumerator(BaseTransportHeaders headers)
        {
            _headers = headers;
            Reset();
        } // BaseTransportHeadersEnumerator

    
        public bool MoveNext()
        {
            if (_currentIndex != -1)
            {
                if (_bStarted)
                    _currentIndex++;
                else
                    _bStarted = true;

                while (_currentIndex != -1)
                {
                    if (_currentIndex >= BaseTransportHeaders.WellknownHeaderCount)
                    {
                        _otherHeadersEnumerator = _headers.GetOtherHeadersEnumerator();
                        _currentIndex = -1;
                    }
                    else
                    {
                        if (_headers.GetValueFromHeaderIndex(_currentIndex) != null)
                            return true;
                
                        _currentIndex++;
                    }
                }
            }
            
            if (_otherHeadersEnumerator != null)
            {
                if (!_otherHeadersEnumerator.MoveNext())
                {
                    _otherHeadersEnumerator = null;
                    return false;                   
                }
                else
                    return true;                    
            }

            return false;
        } // MoveNext
        
        public void Reset()
        {
            _bStarted = false;
            _currentIndex = 0;
            _otherHeadersEnumerator = null;
        } // Reset

        public Object Current  
        {
            get 
            {
                if (!_bStarted)
                    return null;
            
                if (_currentIndex != -1)
                {
                    return 
                        new DictionaryEntry(
                            _headers.MapHeaderIndexToName(_currentIndex),
                            _headers.GetValueFromHeaderIndex(_currentIndex));
                }

                if (_otherHeadersEnumerator != null)
                {
                    return _otherHeadersEnumerator.Current;
                }

                return null;
            }
        } // Current
        
    } // class BaseTransportHeadersEnumerator




} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\basicasyncresult.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
**  File:    BasicAsyncResult.cs
** 
**  Purpose: Base class for async result implementations.
**
**  Date:    Oct 21, 2001
**
===========================================================*/


using System;
using System.Threading;

namespace System.Runtime.Remoting.Channels
{

    internal class BasicAsyncResult : IAsyncResult
    {
        private AsyncCallback _asyncCallback;
        private Object _asyncState;
        private Object _returnValue;
        private Exception _exception;

        private bool _bIsComplete;

        private ManualResetEvent _manualResetEvent;

        
        internal BasicAsyncResult(AsyncCallback callback, Object state)
        {
            _asyncCallback = callback;
            _asyncState = state;
        } // BasicAsyncResult


        public Object AsyncState
        {
            get { return _asyncState; }
        } // AsyncState

        public WaitHandle AsyncWaitHandle
        {
            get 
            { 
                bool bSavedIsComplete = _bIsComplete;
                if (_manualResetEvent == null)
                {
                    lock (this)
                    {
                        if (_manualResetEvent == null)
                        {
                            _manualResetEvent = new ManualResetEvent(bSavedIsComplete);
                        }                        
                    }
                }

                if (!bSavedIsComplete && _bIsComplete)
                    _manualResetEvent.Set();

                return (WaitHandle)_manualResetEvent;
            }
        } // AsyncWaitHandle

        public bool CompletedSynchronously
        {
            get { return false; }
        } // CompletedSynchronously

        public bool IsCompleted
        {
            get { return _bIsComplete; }
        } // IsCompleted

        internal Object ReturnValue { get { return _returnValue; } }
        internal Exception Exception { get { return _exception; } }

        internal void SetComplete(Object returnValue, Exception exception)
        {
            _returnValue = returnValue;
            _exception = exception;

            CleanupOnComplete();

            _bIsComplete = true;

            try
            {
                if (_manualResetEvent != null)
                    _manualResetEvent.Set();
            }
            catch (Exception e)
            {
                if (_exception == null)
                    _exception = e;
            }


            // invoke the callback
            if (_asyncCallback != null)
                _asyncCallback(this);
        } // SetComplete                


        internal virtual void CleanupOnComplete()
        {
        }
    
    } // BasicAsyncResult

} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\bytebufferpool.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       ByteBufferPool.cs
//
//  Summary:    Stream used for reading from a socket by remoting channels.
//
//==========================================================================

using System;
using System.Threading;


namespace System.IO
{

    internal interface IByteBufferPool
    {
        byte[] GetBuffer();
        void ReturnBuffer(byte[] buffer);
    }


    // This isn't actually a buffer pool. It always creates a new byte buffer.
    internal class ByteBufferAllocator : IByteBufferPool
    {
        private int _bufferSize;

        public ByteBufferAllocator(int bufferSize)
        {
            _bufferSize = bufferSize;
        }

        public byte[] GetBuffer()
        {
            return new byte[_bufferSize];
        }

        public void ReturnBuffer(byte[] buffer)
        {
        }
        
    } // ByteBufferAllocator


    internal class ByteBufferPool : IByteBufferPool
    {
        private byte[][] _bufferPool = null;
    
        private int _current; // -1 for none
        private int _last;
        private int _max;     // maximum number of buffers to pool

        private int _bufferSize;

        private Object _controlCookie = "cookie object";


        public ByteBufferPool(int maxBuffers, int bufferSize)
        {
            _max = maxBuffers;        
            _bufferPool = new byte[_max][];
            _bufferSize = bufferSize;

            _current = -1;
            _last = -1;
        } // ByteBufferPool        
        

        public byte[] GetBuffer()
        {
            Object cookie = null;

            try
            {
                // If a ThreadAbortException gets thrown after the exchange,
                //   but before the result is assigned to cookie, then the
                //   control cookie is lost forever. However, the buffer pool
                //   will still function normally and return everybody a new
                //   buffer each time (that isn't very likely to happen,
                //   so we don't really care).
                cookie = Interlocked.Exchange(ref _controlCookie, null);

                if (cookie != null)
                {
                    // we have the control cookie, so take a buffer
                
                    if (_current == -1)
                    {
                        _controlCookie = cookie;
                        // no pooled buffers available
                        return new byte[_bufferSize];
                    }
                    else
                    {
                        // grab next available buffer
                        byte[] buffer = _bufferPool[_current];
                        _bufferPool[_current] = null;      

                        // update "current" index
                        if (_current == _last)
                        {
                            // this is the last free buffer
                            _current = -1;
                        }
                        else
                        {
                            _current = (_current + 1) % _max;
                        }
    
                        _controlCookie = cookie;
                        return buffer;
                    }              
                }
                else
                {
                    // we don't have the control cookie, so just create a new buffer since
                    //   there will probably be a lot of contention anyway.
                    return new byte[_bufferSize];
                }            
            } 
            catch (ThreadAbortException)
            {
                if (cookie != null)
                {
                    // This should be rare, so just reset
                    //   everything to the initial state.
                    _current = -1;
                    _last = -1;

                    // restore cookie
                    _controlCookie = cookie;
                }
            
                throw;
            }                            
        } // GetBuffer


        public void ReturnBuffer(byte[] buffer)
        {
            if (buffer == null)
                throw new ArgumentNullException("buffer");
                
        
            // The purpose of the buffer pool is to try to reduce the 
            //   amount of garbage generated, so it doesn't matter  if
            //   the buffer gets tossed out. Since we don't want to
            //   take the perf hit of taking a lock, we only return
            //   the buffer if we can grab the control cookie.
            
            Object cookie = null;

            try
            {
                // If a ThreadAbortException gets thrown after the exchange,
                //   but before the result is assigned to cookie, then the
                //   control cookie is lost forever. However, the buffer pool
                //   will still function normally and return everybody a new
                //   buffer each time (that isn't very likely to happen,
                //   so we don't really care).
                cookie = Interlocked.Exchange(ref _controlCookie, null);
                
                if (cookie != null)
                {
                    if (_current == -1)
                    {
                        _bufferPool[0] = buffer;
                        _current = 0;
                        _last = 0;
                    }
                    else
                    {
                        int newLast = (_last + 1) % _max;
                        if (newLast != _current)
                        {
                            // the pool isn't full so store this buffer
                            _last = newLast;
                            _bufferPool[_last] = buffer;
                        }
                    }

                    _controlCookie = cookie;
                }            
            }
            catch (ThreadAbortException)
            {
                if (cookie != null)
                {
                    // This should be rare, so just reset
                    //   everything to the initial state.
                    _current = -1;
                    _last = -1;

                    // restore cookie
                    _controlCookie = cookie;
                }

                throw;            
            }
        } // ReturnBuffer

        

    } // ByteBufferPool


} // namespace System.IO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\chunkedmemorystream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       ChunkedMemoryStream.cs
//
//  Summary:    Memory stream that doesn't need to be resized.
//
//==========================================================================

using System;
using System.IO;
using System.Runtime.Remoting.Channels;

namespace System.Runtime.Remoting.Channels
{

    internal class ChunkedMemoryStream : Stream
    {                               
        private class MemoryChunk
        {
            public byte[] Buffer = null;
            public MemoryChunk Next = null;
        }

        private static IByteBufferPool s_defaultBufferPool = new ByteBufferAllocator(1024);

        // state
        private MemoryChunk     _chunks = null;      // data
        private IByteBufferPool _bufferPool = null;  // pool of byte buffers to use

        private bool        _bClosed = false;   // has the stream been closed.        
        
        private MemoryChunk _writeChunk = null; // current chunk to write to
        private int         _writeOffset = 0; // offset into chunk to write to
        private MemoryChunk _readChunk = null; // current chunk to read from
        private int         _readOffset = 0;  // offset into chunk to read from


        public ChunkedMemoryStream()
        {
            _bufferPool = s_defaultBufferPool;
        } // ChunkedMemoryStream


        public ChunkedMemoryStream(IByteBufferPool bufferPool)
        {
            _bufferPool = bufferPool;
        } // ChunkedMemoryStream


        public override bool CanRead { get { return true; } }
        public override bool CanSeek { get { return true; } }
        public override bool CanWrite { get { return true; } }
        
        public override long Length  
        { 
            get 
            { 
                if (_bClosed)
                {                
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
                }

            
                int length = 0;
                MemoryChunk chunk = _chunks;
                while (chunk != null)
                {
                    MemoryChunk next = chunk.Next;
                    if (next != null)
                        length += chunk.Buffer.Length;
                    else
                        length += _writeOffset;
        
                    chunk = next;
                }

                return (long)length;
            }
        } // Length        

        public override long Position
        {
             get 
             {
                if (_bClosed)
                {                
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
                }
                
                if (_readChunk == null)
                    return 0;

                int pos = 0;
                MemoryChunk chunk = _chunks;
                while (chunk != _readChunk)
                {
                    pos += chunk.Buffer.Length;
                    chunk = chunk.Next;
                }
                pos += _readOffset;

                return (long)pos;
             }
             
             set 
             {
                if (_bClosed)
                {                
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
                }
                
                if (value < 0)
                    throw new ArgumentOutOfRangeException("value");

                // back up current position in case new position is out of range
                MemoryChunk backupReadChunk = _readChunk;
                int backupReadOffset = _readOffset;

                _readChunk = null;
                _readOffset = 0;
                                    
                int leftUntilAtPos = (int)value;
                MemoryChunk chunk = _chunks;
                while (chunk != null)
                {
                    if ((leftUntilAtPos < chunk.Buffer.Length) ||
                            ((leftUntilAtPos == chunk.Buffer.Length) &&
                             (chunk.Next == null)))
                    {
                        // the desired position is in this chunk
                        _readChunk = chunk;
                        _readOffset = leftUntilAtPos; 
                        break;
                    }

                    leftUntilAtPos -= chunk.Buffer.Length;
                    chunk = chunk.Next;
                }

                if (_readChunk == null)
                {
                    // position is out of range
                    _readChunk = backupReadChunk;
                    _readOffset = backupReadOffset;
                    throw new ArgumentOutOfRangeException("value");
                }                          
             }
        } // Position

        public override long Seek(long offset, SeekOrigin origin) 
        { 
            if (_bClosed)
            {                
                throw new RemotingException(
                    CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
            }
            
            switch(origin) 
            {
            case SeekOrigin.Begin: 
                Position = offset; 
                break;
    			
            case SeekOrigin.Current:
                Position = Position + offset;
    			break;
    			
    		case SeekOrigin.End:
    		    Position = Length + offset;
    		    break;
    	    }

    		return Position;
        } // Seek

        
        public override void SetLength(long value) { throw new NotSupportedException(); }

        public override void Close() 
        {            
            _bClosed = true;
            ReleaseMemoryChunks(_chunks);
            _chunks = null;
            _writeChunk = null;
            _readChunk = null;
        } // Close

        public override void Flush()
        {
        } // Flush

        
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (_bClosed)
            {                
                throw new RemotingException(
                CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
            }        
            
            if (_readChunk == null)
            {
                if (_chunks == null)
                    return 0;
                _readChunk = _chunks;
                _readOffset = 0;
            }
            
            byte[] chunkBuffer = _readChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
            if (_readChunk.Next == null)
                chunkSize = _writeOffset;

            int bytesRead = 0;
        
            while (count > 0)
            {
                if (_readOffset == chunkSize)
                {
                    // exit if no more chunks are currently available
                    if (_readChunk.Next == null)
                        break;
                        
                    _readChunk = _readChunk.Next;
                    _readOffset = 0;
                    chunkBuffer = _readChunk.Buffer;
                    chunkSize = chunkBuffer.Length;
                    if (_readChunk.Next == null)
                        chunkSize = _writeOffset;
                }

                int readCount = min(count, chunkSize - _readOffset);
                Buffer.BlockCopy(chunkBuffer, _readOffset, buffer, offset, readCount);
                offset += readCount;
                count -= readCount;
                _readOffset += readCount;
                bytesRead += readCount;
            }

            return bytesRead;
        } // Read

        public override int ReadByte()
        {
            if (_bClosed)
            {                
                throw new RemotingException(
                    CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
            }        
            
            if (_readChunk == null)
            {
                if (_chunks == null)
                    return 0;
                _readChunk = _chunks;
                _readOffset = 0;
            }
            
            byte[] chunkBuffer = _readChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
            if (_readChunk.Next == null)
                chunkSize = _writeOffset;

            if (_readOffset == chunkSize)
            {
                // exit if no more chunks are currently available
                if (_readChunk.Next == null)
                    return -1;
                        
                _readChunk = _readChunk.Next;
                _readOffset = 0;
                chunkBuffer = _readChunk.Buffer;
                chunkSize = chunkBuffer.Length;
                if (_readChunk.Next == null)
                    chunkSize = _writeOffset;
            }

            return chunkBuffer[_readOffset++];
        } // ReadByte
                
        public override void Write(byte[] buffer, int offset, int count)
        {
            if (_bClosed)
            {                
                throw new RemotingException(
                    CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
            }
        
            if (_chunks == null)
            {
                _chunks = AllocateMemoryChunk();
                _writeChunk = _chunks;
                _writeOffset = 0;
            }            

            byte[] chunkBuffer = _writeChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
    
            while (count > 0)
            {
                if (_writeOffset == chunkSize)
                {
                    // allocate a new chunk if the current one is full
                    _writeChunk.Next = AllocateMemoryChunk();
                    _writeChunk = _writeChunk.Next;
                    _writeOffset = 0;
                    chunkBuffer = _writeChunk.Buffer;
                    chunkSize = chunkBuffer.Length;
                }
                             
                int copyCount = min(count, chunkSize - _writeOffset);
                Buffer.BlockCopy(buffer, offset, chunkBuffer, _writeOffset, copyCount);
                offset += copyCount;
                count -= copyCount;
                _writeOffset += copyCount;
            }
            
        } // Write

        public override void WriteByte(byte value)
        {
            if (_bClosed)
            {                
                throw new RemotingException(
                    CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
            }
        
            if (_chunks == null)
            {
                _chunks = AllocateMemoryChunk();
                _writeChunk = _chunks;
                _writeOffset = 0;
            }            

            byte[] chunkBuffer = _writeChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
    
            if (_writeOffset == chunkSize)
            {
                // allocate a new chunk if the current one is full
                _writeChunk.Next = AllocateMemoryChunk();
                _writeChunk = _writeChunk.Next;
                _writeOffset = 0;
                chunkBuffer = _writeChunk.Buffer;
                chunkSize = chunkBuffer.Length;
            }
            
            chunkBuffer[_writeOffset++] = value;
        } // WriteByte


        // copy entire buffer into an array
        public virtual byte[] ToArray() 
        {
            int length = (int)Length; // this will throw if stream is closed
            byte[] copy = new byte[Length];

            MemoryChunk backupReadChunk = _readChunk;
            int backupReadOffset = _readOffset;

            _readChunk = _chunks;
            _readOffset = 0;            
            Read(copy, 0, length);

            _readChunk = backupReadChunk;
            _readOffset = backupReadOffset;           
            
            return copy;
        } // ToArray      


        // write remainder of this stream to another stream
        public virtual void WriteTo(Stream stream)
        {
            if (_bClosed)
            {                
                throw new RemotingException(
                    CoreChannel.GetResourceString("Remoting_Stream_StreamIsClosed"));
            }
            
            if (stream == null)
                throw new ArgumentNullException("stream");

            if (_readChunk == null)
            {
                if (_chunks == null)
                    return;

                _readChunk = _chunks;
                _readOffset = 0;
            }

            byte[] chunkBuffer = _readChunk.Buffer;
            int chunkSize = chunkBuffer.Length;
            if (_readChunk.Next == null)
                chunkSize = _writeOffset;

            // following code mirrors Read() logic (_readChunk/_readOffset should
            //   point just past last byte of last chunk when done)

            for (;;) // loop until end of chunks is found
            {
                if (_readOffset == chunkSize)
                {
                    // exit if no more chunks are currently available
                    if (_readChunk.Next == null)
                        break;
                        
                    _readChunk = _readChunk.Next;
                    _readOffset = 0;
                    chunkBuffer = _readChunk.Buffer;
                    chunkSize = chunkBuffer.Length;
                    if (_readChunk.Next == null)
                        chunkSize = _writeOffset;
                }

                int writeCount = chunkSize - _readOffset;
                stream.Write(chunkBuffer, _readOffset, writeCount);
                _readOffset = chunkSize;
            }
                
        } // WriteTo



        private static int min(int a, int b) { return a < b ? a : b;}

        private MemoryChunk AllocateMemoryChunk()
        {
            MemoryChunk chunk = new MemoryChunk();
            chunk.Buffer = _bufferPool.GetBuffer();
            chunk.Next = null;

            return chunk;
        } // AllocateMemoryChunk

        private void ReleaseMemoryChunks(MemoryChunk chunk)
        {
            // If the buffer pool always allocates a new buffer,
            //   there's no point to trying to return all of the buffers. 
            if (_bufferPool is ByteBufferAllocator)
                return;

            while (chunk != null)
            {
                _bufferPool.ReturnBuffer(chunk.Buffer);
                chunk = chunk.Next;
            }
                
        } // FreeMemoryChunk

    
    } // ChunkedMemoryStream


} // namespace System.IO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\requestqueue.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequestQueue.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//
// Request Queue
//      queues up the requests to avoid thread pool starvation,
//      making sure that there are always available threads to process requests
//
// This code has been taken from the XSP code base and modified for Remoting.
//

namespace System.Runtime.Remoting.Channels {
    using System.Threading;
    using System.Collections;
    using System.Web.Util;

    internal class RequestQueue {
        // configuration params
        private int _minExternFreeThreads;
        private int _minLocalFreeThreads;
        private int _queueLimit;

        // two queues -- one for local requests, one for external
        private Queue _localQueue = new Queue();
        private Queue _externQueue = new Queue();

        // total count
        private int _count;

        // work items queued to pick up new work
        private WaitCallback _workItemCallback;
        private int _workItemCount;
        private const int _workItemLimit = 2;
        private bool _draining;


        // helpers
        private static bool IsLocal(SocketHandler sh) {
            return sh.IsLocal();
        }

        private void QueueRequest(SocketHandler sh, bool isLocal) {
            lock (this) {
                if (isLocal)
                    _localQueue.Enqueue(sh);
                else 
                    _externQueue.Enqueue(sh);

                _count++;
            }
        }

        private SocketHandler DequeueRequest(bool localOnly) {
            Object sh = null;

            if (_count > 0) {
                lock (this) {
                    if (_localQueue.Count > 0) {
                        sh = _localQueue.Dequeue();
                        _count--;
                    }
                    else if (!localOnly && _externQueue.Count > 0) {
                        sh = _externQueue.Dequeue();
                        _count--;
                    }
                }
            }

            return (SocketHandler)sh;
        }

        // ctor
        internal RequestQueue(int minExternFreeThreads, int minLocalFreeThreads, int queueLimit) {
            _minExternFreeThreads = minExternFreeThreads;
            _minLocalFreeThreads = minLocalFreeThreads;
            _queueLimit = queueLimit;
            
            _workItemCallback = new WaitCallback(this.WorkItemCallback);
        }


        // method called to process the next request
        internal void ProcessNextRequest(SocketHandler sh)
        {
            sh = GetRequestToExecute(sh);

            if (sh != null)
                sh.ProcessRequestNow();
        } // ProcessNextRequest
        

        // method called when data arrives for incoming requests
        internal SocketHandler GetRequestToExecute(SocketHandler sh) {
            int workerThreads, ioThreads;
            ThreadPool.GetAvailableThreads(out workerThreads, out ioThreads);
            int freeThreads = (ioThreads > workerThreads) ? workerThreads : ioThreads;

            // fast path when there are threads available and nothing queued
            if (freeThreads >= _minExternFreeThreads && _count == 0)
                return sh;

            bool isLocal = IsLocal(sh);

            // fast path when there are threads for local requests available and nothing queued
            if (isLocal && freeThreads >= _minLocalFreeThreads && _count == 0)
                return sh;

            // reject if queue limit exceeded
            if (_count >= _queueLimit) {
                sh.RejectRequestNowSinceServerIsBusy();
                return null;
            }

            // can't execute the current request on the current thread -- need to queue
            QueueRequest(sh, isLocal);

            // maybe can execute a request previously queued
            if (freeThreads >= _minExternFreeThreads) {
                sh = DequeueRequest(false); // enough threads to process even external requests
            }
            else if (freeThreads >= _minLocalFreeThreads) {
                sh = DequeueRequest(true);  // enough threads to process only local requests
            }
            else {
                sh = null;                  // not enough threads -> do nothing on this thread
                ScheduleMoreWorkIfNeeded(); // try to schedule to worker thread
            }

            return sh;
        }

        // method called from SocketHandler at the end of request
        internal void ScheduleMoreWorkIfNeeded() {
            // too late for more work if draining
            if (_draining)
                return;

            // is queue empty?
            if (_count == 0)
                return;

            // already scheduled enough work items
            if (_workItemCount >= _workItemLimit)
                return;

            // queue the work item
            Interlocked.Increment(ref _workItemCount);
            ThreadPool.QueueUserWorkItem(_workItemCallback);
        }

        // is empty property
        internal bool IsEmpty {
            get { return (_count == 0); }
        }

        // method called to pick up more work
        private void WorkItemCallback(Object state) {
            Interlocked.Decrement(ref _workItemCount);

            // too late for more work if draining
            if (_draining)
                return;

            // is queue empty?
            if (_count == 0)
                return;

            int workerThreads, ioThreads;
            ThreadPool.GetAvailableThreads(out workerThreads, out ioThreads);

            bool bHandledRequest = false;
            // service another request if enough worker threads are available
            if (workerThreads >= _minLocalFreeThreads)
            {
                // pick up request from the queue
                SocketHandler sh = DequeueRequest(workerThreads < _minExternFreeThreads);
                if (sh != null)
                {
                    sh.ProcessRequestNow();
                    bHandledRequest = true;
                }
            }

            if (!bHandledRequest)            
                ScheduleMoreWorkIfNeeded();
        }

        // reject all requests
        internal void Drain() {
            _draining = true;
            // wait for all work items to finish
            while (_workItemCount > 0)
                Thread.Sleep(100);

            // is queue empty?
            if (_count == 0)
                return;

            for (;;) {
                SocketHandler sh = DequeueRequest(false);
                if (sh == null)
                    break;
                sh.RejectRequestNowSinceServerIsBusy();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\socketcache.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       SocketCache.cs
//
//  Summary:    Cache for client sockets.
//
//==========================================================================


using System;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Threading;


namespace System.Runtime.Remoting.Channels
{

    // Delegate to method that will fabricate the appropriate socket handler
    internal delegate SocketHandler SocketHandlerFactory(Socket socket, 
                                                         SocketCache socketCache,
                                                         String machineAndPort);


    // Used to cache client connections to a single port on a server
    internal class RemoteConnection
    {
        private static char[] colonSep = new char[]{':'};
    
        private CachedSocketList _cachedSocketList;        

        // reference back to the socket cache
        private SocketCache _socketCache;        

        // remote endpoint data
        private String     _machineAndPort;
        private IPEndPoint _ipEndPoint;

        // socket timeout data        
        private TimeSpan _socketLifetime = TimeSpan.FromSeconds(10);
        

        internal RemoteConnection(SocketCache socketCache, String machineAndPort)
        {
            _socketCache = socketCache;

            _cachedSocketList = new CachedSocketList();

            // parse "machinename:port"
            String[] parts = machineAndPort.Split(colonSep);
            String machineName = parts[0];
            int port = Convert.ToInt32(parts[1]);
        
            _machineAndPort = machineAndPort;

            IPAddress addr = null;

            // we'll just let the exception bubble up if the machineName cannot
            //   be resolved.
            IPHostEntry ipEntries = Dns.Resolve(machineName);
            addr = CoreChannel.GetMachineAddress(ipEntries, AddressFamily.InterNetwork);

            _ipEndPoint = new IPEndPoint(addr, port);
        } // RemoteConnection


        internal SocketHandler GetSocket()
        {
            // try the cached socket list
            SocketHandler socketHandler = _cachedSocketList.GetSocket();
            if (socketHandler != null)
                return socketHandler;

            // Otherwise, we'll just create a new one.
            return CreateNewSocket();
        } // GetSocket

        internal void ReleaseSocket(SocketHandler socket)
        {
            socket.ReleaseControl();
            _cachedSocketList.ReturnSocket(socket);
        } // ReleaseSocket

        
        private SocketHandler CreateNewSocket()
        {        
            Socket socket = new Socket(AddressFamily.InterNetwork,
                                       SocketType.Stream,
                                       ProtocolType.Tcp);

            // disable nagle delays                                           
            socket.SetSocketOption(SocketOptionLevel.Tcp, 
                                   SocketOptionName.NoDelay,
                                   1);

            InternalRemotingServices.RemotingTrace("RemoteConnection::CreateNewSocket: connecting new socket :: " + _ipEndPoint);

            socket.Connect(_ipEndPoint);

            return _socketCache.CreateSocketHandler(socket, _machineAndPort);
        } // CreateNewSocket


        internal void TimeoutSockets(DateTime currentTime)
        {            
            _cachedSocketList.TimeoutSockets(currentTime, _socketLifetime);                 
        } // TimeoutSockets


            
    } // class RemoteConnection



    internal class CachedSocket
    {
        private SocketHandler _socket;
        private DateTime      _socketLastUsed;

        private CachedSocket _next;

        internal CachedSocket(SocketHandler socket, CachedSocket next)
        {
            _socket = socket;
            _socketLastUsed = DateTime.UtcNow;

            _next = next;
        } // CachedSocket        

        internal SocketHandler Handler { get { return _socket; } }
        internal DateTime LastUsed { get { return _socketLastUsed; } }

        internal CachedSocket Next 
        {
            get { return _next; }
            set { _next = value; }
        } 
        
    } // class CachedSocket


    internal class CachedSocketList
    {
        private int _socketCount;
        private CachedSocket _socketList; // linked list

        internal CachedSocketList()
        {
            _socketCount = 0;
            
            _socketList = null;
        } // CachedSocketList
        

        internal SocketHandler GetSocket()
        {
            if (_socketCount == 0)
                return null;
        
            lock (this)
            {    
                if (_socketList != null)
                {
                    SocketHandler socket = _socketList.Handler;
                    _socketList = _socketList.Next;

                    bool bRes = socket.RaceForControl();

                    // We should always have control since there shouldn't
                    //   be contention here.
                    InternalRemotingServices.RemotingAssert(bRes, "someone else has the socket?");

                    _socketCount--;
                    return socket;
                }                                      
            }

            return null;
        } // GetSocket


        internal void ReturnSocket(SocketHandler socket)
        {                        
            lock (this)
            {
                _socketList = new CachedSocket(socket, _socketList);
                _socketCount++;                      
            }
        } // ReturnSocket


        internal void TimeoutSockets(DateTime currentTime, TimeSpan socketLifetime)
        {            
           lock (this)
           {        
                CachedSocket prev = null;
                CachedSocket curr = _socketList;

                while (curr != null)
                {
                    // see if it's lifetime has expired
                    if ((currentTime - curr.LastUsed) > socketLifetime)
                    {                        
                        curr.Handler.Close();

                        // remove current cached socket from list
                        if (prev == null)
                        {
                            // it's the first item, so update _socketList
                            _socketList = curr.Next;
                            curr = _socketList;
                        }
                        else
                        {
                            // remove current item from the list
                            curr = curr.Next;
                            prev.Next = curr;
                        }

                        // decrement socket count
                        _socketCount--;
                    }       
                    else
                    {
                        prev = curr;
                        curr = curr.Next;
                    }
                }          
            }
        } // TimeoutSockets

        
    } // class CachedSocketList
    




    internal class SocketCache
    {
        // collection of RemoteConnection's.
        private Hashtable _connections = new Hashtable();

        private SocketHandlerFactory _handlerFactory;

        // socket timeout data
        private RegisteredWaitHandle _registeredWaitHandle;
        private WaitOrTimerCallback _socketTimeoutDelegate;
        private AutoResetEvent _socketTimeoutWaitHandle;
        private TimeSpan _socketTimeoutPollTime = TimeSpan.FromSeconds(10);
        

        internal SocketCache(SocketHandlerFactory handlerFactory)
        {        
            _handlerFactory = handlerFactory;

            InitializeSocketTimeoutHandler();
        } // SocketCache


        private void InitializeSocketTimeoutHandler()
        {
            _socketTimeoutDelegate = new WaitOrTimerCallback(this.TimeoutSockets);
            _socketTimeoutWaitHandle = new AutoResetEvent(false);
            _registeredWaitHandle = 
                ThreadPool.UnsafeRegisterWaitForSingleObject(
                    _socketTimeoutWaitHandle, 
                    _socketTimeoutDelegate, 
                    "TcpChannelSocketTimeout", 
                    _socketTimeoutPollTime, 
                    true); // execute only once
        } // InitializeSocketTimeoutHandler

        private void TimeoutSockets(Object state, Boolean wasSignalled)
        {
            DateTime currentTime = DateTime.UtcNow;

            lock (_connections)
            {
                foreach (DictionaryEntry entry in _connections)
                {
                    RemoteConnection connection = (RemoteConnection)entry.Value; 
                    connection.TimeoutSockets(currentTime);
                }
            }
            
            _registeredWaitHandle.Unregister(null);
            _registeredWaitHandle =
                ThreadPool.UnsafeRegisterWaitForSingleObject(
                    _socketTimeoutWaitHandle, 
                    _socketTimeoutDelegate, 
                    "TcpChannelSocketTimeout", 
                    _socketTimeoutPollTime, 
                    true); // execute only once      
        } // TimeoutSockets
        


        internal SocketHandler CreateSocketHandler(Socket socket, String machineAndPort)
        {
            return _handlerFactory(socket, this, machineAndPort);
        }


        // The key is expected to of the form "machinename:port"
        public SocketHandler GetSocket(String machineAndPort)
        {
            RemoteConnection connection = (RemoteConnection)_connections[machineAndPort];
            if (connection == null)
            {
                connection = new RemoteConnection(this, machineAndPort);

                // doesn't matter if different RemoteConnection's get written at
                //   the same time (GC will come along and close them).
                lock (_connections)
                {
                    _connections[machineAndPort] = connection;
                }
            }

            return connection.GetSocket();
        } // GetSocket

        public void ReleaseSocket(String machineAndPort, SocketHandler socket)
        {
            RemoteConnection connection = (RemoteConnection)_connections[machineAndPort];
            if (connection != null)
            {
                connection.ReleaseSocket(socket);
            }
            else
            {
                // there should have been a connection, so let's just close
                //   this socket.
                socket.Close();
            }
        } // ReleaseSocket

        
    } // SocketCache




} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\commonchannelkeys.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       CommonChannelKeys.cs
//
//  Summary:    Common transport keys used in channels.
//
//==========================================================================


namespace System.Runtime.Remoting.Channels
{

    /// <include file='doc\CommonChannelKeys.uex' path='docs/doc[@for="CommonTransportKeys"]/*' />
    public class CommonTransportKeys
    { 
        // The ip address from which an incoming request arrived.
        /// <include file='doc\CommonChannelKeys.uex' path='docs/doc[@for="CommonTransportKeys.IPAddress"]/*' />
        public const String IPAddress = "__IPAddress";

        // A unique id given to each incoming socket connection.
        /// <include file='doc\CommonChannelKeys.uex' path='docs/doc[@for="CommonTransportKeys.ConnectionId"]/*' />
        public const String ConnectionId = "__ConnectionId";  

        // The request uri to use for this request or from the incoming request
        /// <include file='doc\CommonChannelKeys.uex' path='docs/doc[@for="CommonTransportKeys.RequestUri"]/*' />
        public const String RequestUri = "__RequestUri";
        
        
    } // CommonTransportKeys
    
} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\exclusivetcplistener.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExclusiveTcpListener.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Net;
using System.Net.Sockets;

namespace System.Runtime.Remoting.Channels
{
    
    // This class provides a TcpListener that is capable of setting the ExclusiveAddressUse flag
    // on a socket, which will prevent another app from hijacking our port. This flag is not supported
    // on Win9x, so we just omit the call to SetSocketOption on non-NT platforms.
    internal class ExclusiveTcpListener : TcpListener
    {
        internal ExclusiveTcpListener(IPAddress localaddr, int port) : base(localaddr, port) {}

        // Start will attempt to start listening.  If exclusiveAddressUse is true, then
        // we will attempt to use the ExclusiveAddressUse flag, but if bind fails (which will
        // happen for a regular user on win2k and xp), we try again without the flag.
        internal void Start(bool exclusiveAddressUse)
        {
            // we only attempt to set the socket option if
            //   1. the exclusiveAddressUse param is true
            //   2. the platform is NT - this option is unavailable on other platforms
            //   3. Server is not null - if it IS null, base.Start will throw a nice error for us
            //   4. the listener is not already listening - it's too late in that case (base.Start will return immediately)
            bool attemptSetSocketOption = exclusiveAddressUse &&
                                          Environment.OSVersion.Platform == PlatformID.Win32NT &&
                                          base.Server != null &&
                                          !base.Active;

            if (attemptSetSocketOption)
            {
                // Attempt to set the option.  We won't actually find out if this fails until
                // we try to bind (which happens in base.Start()).
                base.Server.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ExclusiveAddressUse, 1);
            }
                
            try
            {
                base.Start();
            }
            catch (SocketException)
            {
                if (attemptSetSocketOption)
                {
                    // Turn off the option and try again - maybe this process doesn't have
                    // permission to use the option.
                    Server.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ExclusiveAddressUse, 0);
                    base.Start();
                }
                else
                {
                    // It wasn't because we set the ExclusiveAddressUse option - let the
                    // exception bubble up
                    throw;
                }
            }
        }

    }

} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\socketmanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       SocketManager.cs
//
//  Summary:    Class for managing a socket connection.
//
//==========================================================================

using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading;


namespace System.Runtime.Remoting.Channels
{
    internal delegate bool ValidateByteDelegate(byte b);


    internal abstract class SocketHandler
    {
        // socket manager data
        protected Socket NetSocket;    // network socket
        protected Stream NetStream; // network stream

        private RequestQueue _requestQueue; // request queue to use for this connection

        private byte[] _dataBuffer; // buffered data
        private int    _dataBufferSize; // size of data buffer
        private int    _dataOffset; // offset of remaining data in buffer
        private int    _dataCount;  // count of remaining bytes in buffer

        private AsyncCallback _beginReadCallback; // callback to use when doing an async read
        private IAsyncResult _beginReadAsyncResult; // async result from doing a begin read
        private WaitCallback _dataArrivedCallback; // callback to signal once data is available
        private Object _dataArrivedCallbackState; // state object to go along with callback
        
        private byte[] _byteBuffer = new byte[4]; // buffer for reading bytes


        // control cookie -
        //   The control cookie is used for synchronization when a "user"
        //   wants to retrieve this client socket manager from the socket
        //   cache.
        private int _controlCookie = 1;

                    

        // hide default constructor        
        private SocketHandler(){}

        public SocketHandler(Socket socket)
        {        
            _beginReadCallback = new AsyncCallback(this.BeginReadMessageCallback);
        
            NetSocket = socket;
            NetStream = new SocketStream(NetSocket);

            _dataBuffer = CoreChannel.BufferPool.GetBuffer();
            _dataBufferSize = _dataBuffer.Length;
            _dataOffset = 0;
            _dataCount = 0;
        } // SocketHandler

        internal SocketHandler(Socket socket, RequestQueue requestQueue) : this(socket)
        {        
            _requestQueue = requestQueue;
        } // SocketHandler



        // If this method returns true, then whoever called it can assume control
        //   of the client socket manager. If it returns false, the caller is on
        //   their honor not to do anything further with this object.
        public bool RaceForControl()
        {
            if (1 == Interlocked.Exchange(ref _controlCookie, 0))
                return true;

            return false;            
        } // RaceForControl

        public void ReleaseControl()
        {
            _controlCookie = 1;
        } // ReleaseControl

        // Determines if the remote connection is from localhost.
        internal bool IsLocalhost()
        {
            IPAddress remoteAddr = ((IPEndPoint)NetSocket.RemoteEndPoint).Address;
            return IPAddress.IsLoopback(remoteAddr) || CoreChannel.IsLocalIpAddress(remoteAddr);
        } // IsLocalhost

        // Determines if the remote connection is from localhost.
        internal bool IsLocal()
        {
            IPAddress remoteAddr = ((IPEndPoint)NetSocket.RemoteEndPoint).Address;
            return IPAddress.IsLoopback(remoteAddr);
        } // IsLocal
        
        internal bool CustomErrorsEnabled()
        {
            try {
                return RemotingConfiguration.CustomErrorsEnabled(IsLocalhost());
            }
            catch(Exception) {
                return true;
            }                
        }

        // does any necessary cleanup before reading the incoming message
        protected abstract void PrepareForNewMessage();

        // allows derived classes to send an error message if the async read
        //   in BeginReadMessage fails.
        protected virtual void SendErrorMessageIfPossible(Exception e)
        {
        }     

        // allows socket handler to do something when an input stream it handed
        //   out is closed. The input stream is responsible for calling this method.
        //   (usually, only client socket handlers will do anything with this).
        //   (input stream refers to data being read off of the network)
        public virtual void OnInputStreamClosed()
        {            
        }
        

        public virtual void Close()
        {        
            if (_requestQueue != null)
                _requestQueue.ScheduleMoreWorkIfNeeded();
        
            if (NetStream != null)
            {
                NetStream.Close();
                NetStream = null;
            }
        
            if (NetSocket != null)
            {
                NetSocket.Close();
                NetSocket = null;
            }

            // return buffer to the pool
            if (_dataBuffer != null)
            {
                CoreChannel.BufferPool.ReturnBuffer(_dataBuffer);
                _dataBuffer = null;
            }
        } // Close


        public WaitCallback DataArrivedCallback
        {
            get { return _dataArrivedCallback; }
            set { _dataArrivedCallback = value; }            
        } // DataArrivedCallback

        public Object DataArrivedCallbackState
        {
            get { return _dataArrivedCallbackState; }
            set { _dataArrivedCallbackState = value; }
        } // DataArrivedCallbackState
        

        public void BeginReadMessage()
        {        
            bool bProcessNow = false;
        
            try
            {
                if (_requestQueue != null)
                    _requestQueue.ScheduleMoreWorkIfNeeded();
        
                PrepareForNewMessage();       
  
                if (_dataCount == 0)
                {
                    _beginReadAsyncResult =
                        NetStream.BeginRead(_dataBuffer, 0, _dataBufferSize, 
                                            _beginReadCallback, null);
                }
                else
                {            
                    // just queue the request if we already have some data
                    //   (note: we intentionally don't call the callback directly to avoid
                    //    overflowing the stack if we service a bunch of calls)    
                    bProcessNow = true;
                }
            }
            catch (Exception e)
            {
                CloseOnFatalError(e);
            }

            if (bProcessNow)
            {
                if (_requestQueue != null)
                    _requestQueue.ProcessNextRequest(this);
                else
                    ProcessRequestNow();
     
                _beginReadAsyncResult = null;
            }
        } // BeginReadMessage


        public void BeginReadMessageCallback(IAsyncResult ar)
        {        
            bool bProcessRequest = false;
        
            // data has been buffered; proceed to call provided callback
            try
            {
                _beginReadAsyncResult = null;  
            
                _dataOffset = 0;              
                _dataCount = NetStream.EndRead(ar);
                if (_dataCount <= 0)
                {
                    // socket has been closed
                    Close();
                }
                else
                {
                    bProcessRequest = true;
                }
            }
            catch (Exception e)
            {        
                CloseOnFatalError(e);       
            }

            if (bProcessRequest)
            {
                if (_requestQueue != null)
                    _requestQueue.ProcessNextRequest(this);
                else
                    ProcessRequestNow();
            }
        } // BeginReadMessageCallback     


        internal void CloseOnFatalError(Exception e)
        {
            try
            {
               SendErrorMessageIfPossible(e);
              
               // Something bad happened, so we should just close everything and 
               // return any buffers to the pool.
               Close();
            }
            catch
            {
                try
                {
                    Close();
                }
                catch
                {
                    // this is to prevent any weird errors with closing
                    // a socket from showing up as an unhandled exception.
                }
            }
        } // CloseOnFatalError


        // Called when the SocketHandler is pulled off the pending request queue.
        internal void ProcessRequestNow()
        {
            try
            {
                WaitCallback waitCallback = _dataArrivedCallback;
                if (waitCallback != null)
                    waitCallback.Invoke(this); 
            }
            catch (Exception e)
            {          
                CloseOnFatalError(e);                
            }            
        } // ProcessRequestNow


        internal void RejectRequestNowSinceServerIsBusy()
        {       
            CloseOnFatalError(
                new RemotingException(
                        CoreChannel.GetResourceString("Remoting_ServerIsBusy")));                 
        } // RejectRequestNow
 


        public int ReadByte()
        {
            if (Read(_byteBuffer, 0, 1) != -1)
                return _byteBuffer[0];
            else
                return -1;
        } // ReadByte

        public void WriteByte(byte value, Stream outputStream)
        {
            _byteBuffer[0] = value;
            outputStream.Write(_byteBuffer, 0, 1);
        } // WriteUInt16


        public UInt16 ReadUInt16() 
        {
            Read(_byteBuffer, 0, 2);
        
            return (UInt16)(_byteBuffer[0] & 0xFF | _byteBuffer[1] << 8);
        } // ReadUInt16
        
        public void WriteUInt16(UInt16 value, Stream outputStream)
        {
            _byteBuffer[0] = (byte)value;
            _byteBuffer[1] = (byte)(value >> 8);
            outputStream.Write(_byteBuffer, 0, 2);
        } // WriteUInt16


        public int ReadInt32() 
        {
            Read(_byteBuffer, 0, 4);
        
            return (int)((_byteBuffer[0] & 0xFF) |
                          _byteBuffer[1] << 8 |
                          _byteBuffer[2] << 16 |
                          _byteBuffer[3] << 24);
        } // ReadInt32

        public void WriteInt32(int value, Stream outputStream)
        {
            _byteBuffer[0] = (byte)value;
            _byteBuffer[1] = (byte)(value >> 8);
            _byteBuffer[2] = (byte)(value >> 16);
            _byteBuffer[3] = (byte)(value >> 24);
            outputStream.Write(_byteBuffer, 0, 4);
        } // WriteInt32


        protected bool ReadAndMatchFourBytes(byte[] buffer)
        {
            InternalRemotingServices.RemotingAssert(buffer.Length == 4, "expecting 4 byte buffer.");

            Read(_byteBuffer, 0, 4);
            
            bool bMatch = 
                (_byteBuffer[0] == buffer[0]) &&
                (_byteBuffer[1] == buffer[1]) &&
                (_byteBuffer[2] == buffer[2]) &&
                (_byteBuffer[3] == buffer[3]);

            return bMatch;
        } // ReadAndMatchFourBytes
        


        public int Read(byte[] buffer, int offset, int count)
        {
            int totalBytesRead = 0;

            // see if we have buffered data
            if (_dataCount > 0)
            {
                // copy minimum of buffered data size and bytes left to read
                int readCount = Math.Min(_dataCount, count);
                StreamHelper.BufferCopy(_dataBuffer, _dataOffset, buffer, offset, readCount);
                _dataCount -= readCount;
                _dataOffset += readCount;
                count -= readCount;
                offset += readCount;
                totalBytesRead += readCount;
            }

            // keep reading (whoever is calling this will make sure that they
            //   don't try to read too much).
            while (count > 0)
            {                
                if (count < 256)
                {
                    // if count is less than 256 bytes, I will buffer more data
                    // because it's not worth making a socket request for less.
                    BufferMoreData();

                    // copy minimum of buffered data size and bytes left to read
                    int readCount = Math.Min(_dataCount, count);
                    StreamHelper.BufferCopy(_dataBuffer, _dataOffset, buffer, offset, readCount);
                    _dataCount -= readCount;
                    _dataOffset += readCount;
                    count -= readCount;
                    offset += readCount;
                    totalBytesRead += readCount;    
                }
                else
                {
                    // just go directly to the socket
                    
                    // the internal buffer is guaranteed to be empty at this point, so just
                    //   read directly into the array given
                
                    int readCount = ReadFromSocket(buffer, offset, count);                    
                    count -= readCount;
                    offset += readCount;
                    totalBytesRead += readCount;
                }
            }
                        
            return totalBytesRead;
        } // Read


        // This should only be called when _dataCount is 0.
        private int BufferMoreData()
        {        
            InternalRemotingServices.RemotingAssert(_dataCount == 0, 
                "SocketHandler::BufferMoreData called with data still in buffer." +
                "DataCount=" + _dataCount + "; DataOffset" + _dataOffset);

            int bytesRead = ReadFromSocket(_dataBuffer, 0, _dataBufferSize);
                
            _dataOffset = 0;
            _dataCount = bytesRead;

            return bytesRead;
        } // BufferMoreData


        private int ReadFromSocket(byte[] buffer, int offset, int count)
        {
            int bytesRead = NetStream.Read(buffer, offset, count);
            if (bytesRead <= 0)
            {
                throw new RemotingException(       
                    CoreChannel.GetResourceString("Remoting_Socket_UnderlyingSocketClosed"));
            }

            return bytesRead;
        } // ReadFromSocket
        

        protected byte[] ReadToByte(byte b)
        {
            return ReadToByte(b, null);
        } /// ReadToByte

        protected byte[] ReadToByte(byte b, ValidateByteDelegate validator)
        {
            byte[] readBytes = null;

            // start at current position and return byte array consisting of bytes
            //   up to where we found the byte.
            if (_dataCount == 0)
                BufferMoreData();
                
            int dataEnd = _dataOffset + _dataCount; // one byte past last valid byte
            int startIndex = _dataOffset; // current position
            int endIndex = startIndex; // current index

            bool foundByte = false;
            bool bufferEnd;
            while (!foundByte)
            {            
                InternalRemotingServices.RemotingAssert(endIndex <= dataEnd, "endIndex shouldn't pass dataEnd");
                bufferEnd = endIndex == dataEnd;
                foundByte = !bufferEnd && (_dataBuffer[endIndex] == b);

                // validate character if necessary
                if ((validator != null) && !bufferEnd && !foundByte)
                {
                    if (!validator(_dataBuffer[endIndex]))
                    {
                        throw new RemotingException(
                            CoreChannel.GetResourceString(
                                "Remoting_Http_InvalidDataReceived"));
                    }
                }

                // we're at the end of the currently buffered data or we've found our byte
                if (bufferEnd || foundByte)
                {
                    // store processed byte in the readBytes array
                    int count = endIndex - startIndex;                                        
                    if (readBytes == null)
                    {
                        readBytes = new byte[count];
                        StreamHelper.BufferCopy(_dataBuffer, startIndex, readBytes, 0, count);
                    }
                    else
                    {
                        int oldSize = readBytes.Length;
                        byte[] newBytes = new byte[oldSize + count];
                        StreamHelper.BufferCopy(readBytes, 0, newBytes, 0, oldSize);
                        StreamHelper.BufferCopy(_dataBuffer, startIndex, newBytes, oldSize, count);
                        readBytes = newBytes;
                    }

                    // update data counters
                    _dataOffset += count;
                    _dataCount -= count;

                    if (bufferEnd)
                    {
                        // we still haven't found the byte, so buffer more data
                        //   and keep looking.
                        BufferMoreData();

                        // reset indices
                        dataEnd = _dataOffset + _dataCount; // last valid byte
                        startIndex = _dataOffset; // current position
                        endIndex = startIndex; // current index
                    }
                    else
                    if (foundByte)
                    {
                        // skip over the byte that we were looking for
                        _dataOffset += 1;
                        _dataCount -= 1;
                    }        
                }
                else
                {
                    // still haven't found character or end of buffer, so advance position
                    endIndex++;
                }
            }
                
            return readBytes;
        } // ReadToByte


        protected String ReadToChar(char ch)
        {
            return ReadToChar(ch, null);
        } // ReadToChar

        protected String ReadToChar(char ch, ValidateByteDelegate validator)
        {
            byte[] strBytes = ReadToByte((byte)ch, validator);
            if (strBytes == null)
                return null;
            if (strBytes.Length == 0)
                return String.Empty;
                
            String str = Encoding.ASCII.GetString(strBytes);

            return str;
        } // ReadToChar


        public String ReadToEndOfLine()
        {
            String str = ReadToChar('\r');
            if (ReadByte() == '\n')
                return str;
            else
                return null;
        } // ReadToEndOfLine        
               
    
    } // SocketHandler


} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\streamhelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    StreamHelper.cs
**
** Purpose: Helper methods for streams.
**
===========================================================*/


using System;
using System.IO;
using System.Runtime.Remoting;
using System.Threading;


namespace System.Runtime.Remoting.Channels
{

    internal class StreamHelper
    {
        private static AsyncCallback _asyncCopyStreamReadCallback = new AsyncCallback(AsyncCopyStreamReadCallback);
        private static AsyncCallback _asyncCopyStreamWriteCallback = new AsyncCallback(AsyncCopyStreamWriteCallback);


        internal static void CopyStream(Stream source, Stream target)
        {
            if (source == null)
                return;

            // see if this is a ChunkedMemoryStream (we can do a direct write)
            ChunkedMemoryStream chunkedMemStream = source as ChunkedMemoryStream;
            if (chunkedMemStream != null)
            {
                chunkedMemStream.WriteTo(target);
            }
            else
            {
                // see if this is a MemoryStream (we can do a direct write)
                MemoryStream memContentStream = source as MemoryStream;
                if (memContentStream != null)
                {
                    memContentStream.WriteTo(target);
                }
                else                    
                {
                    // otherwise, we need to copy the data through an intermediate buffer
                
                    byte[] buffer = CoreChannel.BufferPool.GetBuffer();
                    int bufferSize = buffer.Length;
                    int readCount = source.Read(buffer, 0, bufferSize);
                    while (readCount > 0)
                    {
                        target.Write(buffer, 0, readCount);
                        readCount = source.Read(buffer, 0, bufferSize);
                    }   
                    CoreChannel.BufferPool.ReturnBuffer(buffer);
                }
            }
            
        } // CopyStream       
        


        internal static void BufferCopy(byte[] source, int srcOffset, 
                                        byte[] dest, int destOffset,
                                        int count)
        {
            if (count > 8)
            {
                Buffer.BlockCopy(source, srcOffset, dest, destOffset, count);
            }
            else
            {
                for (int co = 0; co < count; co++)
                    dest[destOffset + co] = source[srcOffset + co];
            }
        } // BufferCopy




        internal static IAsyncResult BeginAsyncCopyStream(
            Stream source, Stream target, 
            bool asyncRead, bool asyncWrite,
            bool closeSource, bool closeTarget,
            AsyncCallback callback, Object state)
        {   
            AsyncCopyStreamResult streamState = new AsyncCopyStreamResult(callback, state);

            byte[] buffer = CoreChannel.BufferPool.GetBuffer();

            streamState.Source = source;
            streamState.Target = target;
            streamState.Buffer = buffer;
            streamState.AsyncRead = asyncRead;
            streamState.AsyncWrite = asyncWrite;
            streamState.CloseSource = closeSource;
            streamState.CloseTarget = closeTarget;

            try
            {
                AsyncCopyReadHelper(streamState);
            } 
            catch (Exception e)
            {
                streamState.SetComplete(null, e);
            }

            return streamState;
        } // BeginAsyncCopyStream

        internal static void EndAsyncCopyStream(IAsyncResult iar)
        {
            AsyncCopyStreamResult asyncResult = (AsyncCopyStreamResult)iar;
        
            if (!iar.IsCompleted)
            {
                iar.AsyncWaitHandle.WaitOne();
            }

            if (asyncResult.Exception != null)
            {
                throw asyncResult.Exception;
            }
        } // EndAsyncCopyStream


        private static void AsyncCopyReadHelper(AsyncCopyStreamResult streamState)
        {
            // There is no try-catch here because the calling method always has a try-catch.
        
            if (streamState.AsyncRead)
            {
                byte[] buffer = streamState.Buffer;
                streamState.Source.BeginRead(buffer, 0, buffer.Length, _asyncCopyStreamReadCallback, streamState);
            }
            else
            {
                byte[] buffer = streamState.Buffer;
                int bytesRead = streamState.Source.Read(buffer, 0, buffer.Length);
                if (bytesRead == 0)
                {
                    streamState.SetComplete(null, null);
                }
                else
                if (bytesRead < 0)
                {
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_UnknownReadError"));
                }
                else
                {
                    AsyncCopyWriteHelper(streamState, bytesRead);
                }
            }
        } // AsyncCopyReadHelper


        private static void AsyncCopyWriteHelper(AsyncCopyStreamResult streamState, int bytesRead)
        {
            // There is no try-catch here because the calling method always has a try-catch.
        
            if (streamState.AsyncWrite)
            {
                byte[] buffer = streamState.Buffer;
                streamState.Target.BeginWrite(buffer, 0, bytesRead, _asyncCopyStreamWriteCallback, streamState);
            }
            else
            {
                byte[] buffer = streamState.Buffer;
                streamState.Target.Write(buffer, 0, bytesRead);
                
                AsyncCopyReadHelper(streamState);
            }
        } // AsyncCopyWriteHelper
        

        private static void AsyncCopyStreamReadCallback(IAsyncResult iar)
        {            
            AsyncCopyStreamResult state = (AsyncCopyStreamResult)iar.AsyncState;

            try
            {
                Stream source = state.Source;

                int bytesRead = source.EndRead(iar);
                if (bytesRead == 0)
                {
                    state.SetComplete(null, null);
                }
                else
                if (bytesRead < 0)
                {
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Stream_UnknownReadError"));
                }
                else
                {
                    AsyncCopyWriteHelper(state, bytesRead);
                }           
            }
            catch (Exception e)
            {
                state.SetComplete(null, e);                
            }
        } // AsyncCopyStreamReadCallback


        private static void AsyncCopyStreamWriteCallback(IAsyncResult iar)
        {            
            AsyncCopyStreamResult state = (AsyncCopyStreamResult)iar.AsyncState;

            try
            {
                state.Target.EndWrite(iar);

                AsyncCopyReadHelper(state);
            }
            catch (Exception e)
            {
                state.SetComplete(null, e);                
            }
        } // AsyncCopyStreamWriteCallback
        
    } // class StreamHelper



    internal class AsyncCopyStreamResult : BasicAsyncResult
    {
        internal Stream Source;
        internal Stream Target;
        internal byte[] Buffer;
        internal bool AsyncRead;
        internal bool AsyncWrite;
        internal bool CloseSource;
        internal bool CloseTarget;

        internal AsyncCopyStreamResult(AsyncCallback callback, Object state) :
            base(callback, state)
        {
        }

        internal override void CleanupOnComplete()
        {
            if (Buffer != null)
                CoreChannel.BufferPool.ReturnBuffer(Buffer);

            if (CloseSource)
                Source.Close();
            if (CloseTarget)
                Target.Close();
                
        } // CleanupOnComplete
        
    } // class AsyncCopyStreamResult
    

} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\socketstream.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       SocketStream.cs
//
//  Summary:    Stream used for reading from a socket by remoting channels.
//
//==========================================================================

using System;
using System.IO;
using System.Runtime.Remoting;
using System.Net;
using System.Net.Sockets;


namespace System.Runtime.Remoting.Channels
{

    // Basically the same as NetworkStream, but adds support for timeouts.
    internal class SocketStream : Stream
    {
        private Socket _socket;        
        private int    _timeout = 0; // throw timout exception if a read takes longer than this many milliseconds

        
        public SocketStream(Socket socket) 
        {
            if (socket == null)
                throw new ArgumentNullException("socket");

            _socket = socket;
        } // SocketStream


        // A synchronous read will throw a RemotingTimeoutException if it takes longer than this value.
        public TimeSpan Timeout
        {
            get { return TimeSpan.FromMilliseconds(_timeout); }
            set { _timeout = (int)(value.TotalMilliseconds); }
        } // Timeout

        
        // Stream implementation

        public override bool CanRead { get { return true; } }
        public override bool CanSeek { get { return false; } }
        public override bool CanWrite { get { return true; } }

        public override long Length { get { throw new NotSupportedException(); } }

        public override long Position 
        {
            get { throw new NotSupportedException(); }
            set { throw new NotSupportedException(); }
        } // Position

        public override long Seek(long offset, SeekOrigin origin) 
        {
            throw new NotSupportedException();
        }
    
        public override int Read(byte[] buffer, int offset, int size) 
        {
            if (_timeout <= 0)
            {
                return _socket.Receive(buffer, offset, size, 0);
            }
            else
            {
                IAsyncResult ar = _socket.BeginReceive(buffer, offset, size, SocketFlags.None, null, null);
                if (_timeout>0 && !ar.IsCompleted) 
                {
                    ar.AsyncWaitHandle.WaitOne(_timeout, false);
                    if (!ar.IsCompleted)
                        throw new RemotingTimeoutException();
                    
                }
                return _socket.EndReceive(ar);
            }
        } // Read

        public override void Write(byte[] buffer, int offset, int count) 
        {
            _socket.Send(buffer, offset, count, 0);
        } // Write

        public override void Close() { _socket.Close(); }
        
        public override void Flush() {}

      
        public override IAsyncResult BeginRead(
            byte[] buffer,
            int offset,
            int size,
            AsyncCallback callback,
            Object state) 
        {
            IAsyncResult asyncResult =
                _socket.BeginReceive(
                    buffer,
                    offset,
                    size,
                    SocketFlags.None,
                    callback,
                    state);

            return asyncResult;
        } // BeginRead


        public override int EndRead(IAsyncResult asyncResult)
        {
            return _socket.EndReceive(asyncResult);
        } // EndRead

  
        public override IAsyncResult BeginWrite(
            byte[] buffer,
            int offset,
            int size,
            AsyncCallback callback,
            Object state) 
        {
            IAsyncResult asyncResult =
                _socket.BeginSend(
                    buffer,
                    offset,
                    size,
                    SocketFlags.None,
                    callback,
                    state);

                return asyncResult;
        } // BeginWrite


        public override void EndWrite(IAsyncResult asyncResult) 
        {
            _socket.EndSend(asyncResult);
        } // EndWrite


        public override void SetLength(long value) { throw new NotSupportedException(); }
        
    } // class SocketStream
    
} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\stringhelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    StringHelper.cs
**
** Purpose: Helper methods for strings.
**
===========================================================*/


using System;
using System.IO;
using System.Runtime.Remoting;


namespace System.Runtime.Remoting.Channels
{

    internal class StringHelper
    {   
        internal static bool StartsWithDoubleUnderscore(String str)
        {
            if (str.Length < 2)
                return false;

            return (str[0] == '_') && (str[1] == '_');
        } // StartsWithDoubleUnderscore

        internal static bool StartsWithAsciiIgnoreCasePrefixLower(String str, String asciiPrefix)
        {
            // The caller should know that the arguments aren't null.

            int prefixLen = asciiPrefix.Length;
            if (str.Length < prefixLen)
                return false;
                
            for (int i = 0; i < prefixLen; i++)
            {
                // The prefix is assumed to be in lowercase
                if (ToLowerAscii(str[i]) != asciiPrefix[i])
                {
                    return false;
                }
            }

            return true;
        } // StartsWithAsciiIgnoreCase

        private static char ToLowerAscii(char ch)
        {
            if ((ch >= 'A') && (ch <= 'Z'))
            {
                return (char)(ch + ('a' - 'A'));
            }

            return ch;
        } // ToLowerAscii
        
        
    } // StringHelper

} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\httpsocketmanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       HttpSocketManager.cs
//
//  Summary:    Provides a base for the client and server http socket 
//              managers.
//
//==========================================================================


using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading;


namespace System.Runtime.Remoting.Channels.Http
{

    // A client socket manager instance should encapsulate the socket
    //   for the purpose of reading a response
    internal abstract class HttpSocketHandler : SocketHandler
    {            
        private static byte[] s_httpVersion = Encoding.ASCII.GetBytes("HTTP/1.1");
        private static byte[] s_httpVersionAndSpace = Encoding.ASCII.GetBytes("HTTP/1.1 ");
        private static byte[] s_headerSeparator = new byte[]{(byte)':',(byte)' '};
        private static byte[] s_endOfLine = new byte[]{(byte)'\r',(byte)'\n'};

    
        public HttpSocketHandler(Socket socket, RequestQueue requestQueue) : base(socket, requestQueue)
        {          
        } // HttpSocketHandler


        protected void ReadToEndOfHeaders(BaseTransportHeaders headers, 
                                          out bool bChunked,
                                          out int contentLength,
                                          ref bool bKeepAlive,
                                          ref bool bSendContinue)
        {
            bChunked = false;
            contentLength = 0;
        
            // read and process headers
            for (;;)
            {
                String header = ReadToEndOfLine();

                // stop reading headers at first blank line
                if (header.Length == 0)
                    break;
                
                int sep = header.IndexOf(":");
                String headerName = header.Substring(0,sep);
                String headerValue = header.Substring(sep+1+1); // skip semi-colon and space

                if (String.Compare(headerName, "Transfer-Encoding", true, CultureInfo.InvariantCulture) == 0)          
                {
                    if (String.Compare(headerValue, "chunked", true, CultureInfo.InvariantCulture) == 0)
                    {
                        bChunked = true;
                    }
                }
                else
                if (String.Compare(headerName, "Connection", true, CultureInfo.InvariantCulture) == 0)
                {
                    if (String.Compare(headerValue, "Keep-Alive", true, CultureInfo.InvariantCulture) == 0)
                        bKeepAlive = true;
                    else
                    if (String.Compare(headerValue, "Close", true, CultureInfo.InvariantCulture) == 0)
                        bKeepAlive = false;
                }
                else
                if (String.Compare(headerName, "Expect", true, CultureInfo.InvariantCulture) == 0)
                {
                    if (String.Compare(headerValue, "100-continue", true, CultureInfo.InvariantCulture) == 0)
                        bSendContinue = true;
                }
                else
                if (String.Compare(headerName, "Content-Length", true, CultureInfo.InvariantCulture) == 0)
                {
                    contentLength = Int32.Parse(headerValue);
                }
                else
                {                
                    headers[headerName] = headerValue;
                }
            }
        } // ReadToEndOfHeaders


        protected void WriteHeaders(ITransportHeaders headers, Stream outputStream)
        {
            if (headers == null)
                return;
        
            foreach (DictionaryEntry header in headers)
            {
                String headerName = (String)header.Key;

                if (!headerName.StartsWith("__")) // exclude special headers
                {
                    WriteHeader(headerName, (String)header.Value, outputStream);
                }
            }

            // write end of headers "\r\n"
            outputStream.Write(s_endOfLine, 0, s_endOfLine.Length);
        } // WriteHeaders

        private void WriteHeader(String name, String value, Stream outputStream)
        {
            byte[] nameBytes = Encoding.ASCII.GetBytes(name); 
            byte[] valueBytes = Encoding.ASCII.GetBytes(value); 
            
            outputStream.Write(nameBytes, 0, nameBytes.Length);
            outputStream.Write(s_headerSeparator, 0, s_headerSeparator.Length);
            outputStream.Write(valueBytes, 0, valueBytes.Length);
            outputStream.Write(s_endOfLine, 0, s_endOfLine.Length);            
        } // WriteHeader


        protected void WriteRequestFirstLine(String requestVerb, String url, Stream outputStream)
        {
            byte[] requestVerbBytes = Encoding.ASCII.GetBytes(requestVerb); 
            byte[] urlBytes = Encoding.ASCII.GetBytes(HttpEncodingHelper.EncodeUriAsXLinkHref(url));

            outputStream.Write(requestVerbBytes, 0, requestVerbBytes.Length);
            outputStream.WriteByte((byte)' ');
            outputStream.Write(urlBytes, 0, urlBytes.Length);
            outputStream.WriteByte((byte)' ');
            outputStream.Write(s_httpVersion, 0, s_httpVersion.Length);
            outputStream.Write(s_endOfLine, 0, s_endOfLine.Length);
        } // WriteRequestFirstLine


        protected void ReadResponseFirstLine(out String version, out String statusCode, out String reasonPhrase)
        {
            version = ReadToChar(' ');
            statusCode = ReadToChar(' ');
            reasonPhrase = ReadToEndOfLine();
        } // ReadResponseFirstLine

        protected void WriteResponseFirstLine(String statusCode, String reasonPhrase, Stream outputStream)
        {
            byte[] statusCodeBytes = Encoding.ASCII.GetBytes(statusCode); 
            byte[] reasonPhraseBytes = Encoding.ASCII.GetBytes(reasonPhrase); 
        
            outputStream.Write(s_httpVersionAndSpace, 0, s_httpVersionAndSpace.Length);
            outputStream.Write(statusCodeBytes, 0, statusCodeBytes.Length);
            outputStream.WriteByte((byte)' ');
            outputStream.Write(reasonPhraseBytes, 0, reasonPhraseBytes.Length);
            outputStream.Write(s_endOfLine, 0, s_endOfLine.Length);
        } // WriteResponseFirstLine        


    } // class HttpSocketHandler


} // namespace System.Runtime.Remoting.Channels.Tcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\core\corechannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Text;
using System.Threading;
using System.DirectoryServices;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Soap;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;       
using System.Runtime.Remoting.Metadata;
using System.IO;
using System.Net;
using System.Collections;
using System.Net.Sockets;
using System.Resources;
using System.Diagnostics;
using System.Web;
using System.Globalization;
using System.Runtime.InteropServices;




// These two attributes are for supporting side-by-side of COM-visible
// objects with NDP 1.0 RTM. This needs to be set on all assemblies that 
// expose COM-visible types to be made Side by Side with NDP 1.0 RTM.
// This declaration covers System.Runtime.Remoting.dll
[assembly:ComCompatibleVersion(1,0,3300,0)]
[assembly:TypeLibVersion(1,10)]


namespace System.Runtime.Remoting.Channels
{

    // Use this internal indicator (as opposed to the nested enum found
    //   on some of the server channel sinks)
    internal enum SinkChannelProtocol
    {
        Http, // special processing needed for http
        Other
    } // ChannelProtocol

    

    internal class CoreChannel    
    {
        private static IByteBufferPool _bufferPool = new ByteBufferPool(10, 4096);
        private static RequestQueue _requestQueue = new RequestQueue(8,4,250);        

        internal static IByteBufferPool BufferPool { get { return _bufferPool; } }
        internal static RequestQueue RequestQueue { get { return _requestQueue; } }
        
    
        internal const int MaxStringLen = 512;

        internal const String SOAPMimeType = "text/xml";
        internal const String BinaryMimeType = "application/octet-stream";

        internal const String SOAPContentType = "text/xml; charset=\"utf-8\"";

        private static String s_hostName = null; 
        private static String s_MachineName = null;
        private static String s_MachineIp = null;
        private static IPAddress s_MachineIpAddress = null;
        // Copy of consts defined in RemotingServices.cs
        internal const int CLIENT_MSG_GEN          = 1;
        internal const int CLIENT_MSG_SINK_CHAIN   = 2;
        internal const int CLIENT_MSG_SER          = 3;
        internal const int CLIENT_MSG_SEND         = 4;
        internal const int SERVER_MSG_RECEIVE      = 5;
        internal const int SERVER_MSG_DESER        = 6;
        internal const int SERVER_MSG_SINK_CHAIN   = 7;
        internal const int SERVER_MSG_STACK_BUILD  = 8;
        internal const int SERVER_DISPATCH         = 9;
        internal const int SERVER_RET_STACK_BUILD  = 10;
        internal const int SERVER_RET_SINK_CHAIN   = 11;
        internal const int SERVER_RET_SER          = 12;
        internal const int SERVER_RET_SEND         = 13;
        internal const int SERVER_RET_END          = 14;
        internal const int CLIENT_RET_RECEIVE      = 15;
        internal const int CLIENT_RET_DESER        = 16;
        internal const int CLIENT_RET_SINK_CHAIN   = 17;
        internal const int CLIENT_RET_PROPAGATION  = 18;
        internal const int CLIENT_END_CALL         = 19;
        internal const int TIMING_DATA_EOF         = 99;

        internal static void DebugInitialize(String s)
        {
        }


        internal static String GetHostName()
        {
            if (s_hostName == null)
            {
                s_hostName = Dns.GetHostName();

                if (s_hostName == null)
                {
                    throw new ArgumentNullException("hostName");
                }
            }

            return s_hostName;
        } // GetHostName

        internal static String GetMachineName()
        {
            if (s_MachineName == null)
            {     
                String machineName = GetHostName();
                if (machineName != null)
                {
                    IPHostEntry host = Dns.GetHostByName(machineName);
                    if (host != null)
                        s_MachineName = host.HostName;
                } 

                if (s_MachineName == null)
                {
                    throw new ArgumentNullException("machine");
                }
            }
            
            return s_MachineName;      
        } // GetMachineName


        // process specified host name to see if it is a meta-hostname that
        //   should be replaced with something else.
        internal static String DecodeMachineName(String machineName)
        {
            if (machineName.Equals("$hostName"))
                return GetHostName();

            return machineName;
        } // DecodeMachineName
        

        internal static String GetMachineIp()
        {
            if (s_MachineIp == null)
            {            
                String hostName = GetMachineName();

                // NOTE: We intentionally allow exceptions from these api's
                //  propagate out to the caller.
                IPHostEntry ipEntries = Dns.GetHostByName(hostName);
                IPAddress addr = GetMachineAddress(ipEntries, AddressFamily.InterNetwork);
                if (addr != null)
                {
                    s_MachineIp = addr.ToString();
                }
                
                if (s_MachineIp == null)
                {
                    throw new ArgumentNullException("ip");
                }
            }
            
            return s_MachineIp;      
        } // GetMachineIp

        // This helper function Checks whether the remote IP Adress is actually a local address
        internal static bool IsLocalIpAddress(IPAddress remoteAddress)
        {
            if (s_MachineIpAddress == null)
            {
                String hostName = GetMachineName();

                // NOTE: We intentionally allow exceptions from these api's
                //  propagate out to the caller.
                IPHostEntry ipEntries = Dns.GetHostByName(hostName);
                // If there is only one entry we should cache it
                if(ipEntries != null && ipEntries.AddressList.Length == 1)
                {
                    s_MachineIpAddress = GetMachineAddress(ipEntries, AddressFamily.InterNetwork);
                }
                else
                {
                    return IsLocalIpAddress(ipEntries, AddressFamily.InterNetwork, remoteAddress);
                }
            }
            return s_MachineIpAddress.Equals(remoteAddress);
        }

        //This helper function compares and IpAddress with all addresses in IpHostEntry
        internal static bool IsLocalIpAddress(IPHostEntry host, AddressFamily addressFamily, IPAddress remoteAddress)
        {
            if (host != null)
            {
                IPAddress[] addressList = host.AddressList;
                for (int i = 0; i < addressList.Length; i++)
                {
                    if (addressList[i].AddressFamily == addressFamily)
                    {
                        if(addressList[i].Equals(remoteAddress))
                            return true;
                    }
                }
            }
            return false;    
       }
        
        // This helper function returns the first IPAddress with family 'addressFamily' from
        // host.AddressList, or null if there is no such address or if host is null.
        internal static IPAddress GetMachineAddress(IPHostEntry host, AddressFamily addressFamily)
        {
            // NOTE: We intentionally allow exceptions from these api's
            //  propagate out to the caller.
            IPAddress result = null;
            if (host != null)
            {
                // find the first address for this address family
                IPAddress[] addressList = host.AddressList;
                for (int i = 0; i < addressList.Length; i++)
                {
                    if (addressList[i].AddressFamily == addressFamily)
                    {
                        result = addressList[i];
                        break;
                    }
                }
            }
            
            //Console.WriteLine("GetMachineAddress(" + hostName + ", " + addressFamily + ") -> " + (result == null ? "<null>" : result.ToString()));
            return result;
        } // GetMachineAddress
        

        //
        // Core Serialization and Deserialization support
        //        
        internal static Header[] GetMessagePropertiesAsSoapHeader(IMessage reqMsg)
        {
            IDictionary d = reqMsg.Properties;
            if (d == null)
                return null;
                
            int count = d.Count;
            if (count == 0)
                return null;

            IDictionaryEnumerator e = (IDictionaryEnumerator) d.GetEnumerator();

            // cycle through the headers to get a length
            bool[] map = new bool[count];
            int len = 0, i=0;
            IMethodMessage msg = (IMethodMessage)reqMsg;
            while (e.MoveNext())
            {                   
                String key = (String)e.Key;
                if ((key.Length >= 2) &&
                    (String.CompareOrdinal(key, 0, "__", 0, 2)  == 0) 
                     &&
                     (
                        key.Equals("__Args") 
                                ||
                        key.Equals("__OutArgs") 
                                ||
                        key.Equals("__Return") 
                                ||
                        key.Equals("__Uri") 
                                ||
                        key.Equals("__MethodName") 
                                ||
                        (key.Equals("__MethodSignature") 
                                && (!RemotingServices.IsMethodOverloaded(msg))
                                && (!msg.HasVarArgs))
                                ||
                        key.Equals("__TypeName") 
                                ||
                        key.Equals("__Fault") 
                                ||
                        (key.Equals("__CallContext") 
                                && ((e.Value != null) ? (((LogicalCallContext)e.Value).HasInfo==false) : true))
                      )                       
                  )
                {
                        i++;
                    continue;
                }
                map[i] = true;
                i++;                
                len++;
            }
            if (len == 0)
                return null;

            
            Header[] ret = new Header[len];
            e.Reset();
            int k=0; 
            i = 0;
            while (e.MoveNext())
            {
                Object key = e.Key;
                if (!map[k])
                {
                    k++;
                    continue;
                }
                
                Header h = e.Value as Header;

                // If the property is not a header, then make a header out of it.
                if (h == null)
                {
                    h = 
                        new Header(
                            (String)key, e.Value, false,
                            "http://schemas.microsoft.com/clr/soap/messageProperties");
                }

                // REVIEW: why would this be needed?
                if (i == ret.Length)
                {
                    InternalRemotingServices.RemotingTrace("HTTPChannel::GetHeaders creating a new array of length " + (i+1) + "\n");
                    Header[] newret= new Header[i+1];
                    Array.Copy(ret, newret, i);
                    ret = newret;
                }
                ret[i] = h;
                i++;
                k++;
            }
            
            return ret;
        } // GetMessagePropertiesAsSoapHeader
        

        internal static Header[] GetSoapHeaders(IMessage reqMsg)
        {    
            // If there are message properties, we'll need to resize the header array.
            Header[] msgProperties = GetMessagePropertiesAsSoapHeader(reqMsg);

            return msgProperties;
        } // GetSoapHeaders



        internal static SoapFormatter CreateSoapFormatter(bool serialize, bool includeVersions)
        {            
            SoapFormatter remotingFormatter = new SoapFormatter();

            if (serialize)
            {
                RemotingSurrogateSelector rss = new RemotingSurrogateSelector();
                remotingFormatter.SurrogateSelector = rss;
                rss.UseSoapFormat();
            }
            else
                remotingFormatter.SurrogateSelector = null;

            remotingFormatter.Context = new StreamingContext(StreamingContextStates.Other);

            remotingFormatter.AssemblyFormat = 
                includeVersions ? 
                    FormatterAssemblyStyle.Full :
                    FormatterAssemblyStyle.Simple;

            return remotingFormatter;
        } // CreateSoapFormatter


        internal static BinaryFormatter CreateBinaryFormatter(bool serialize, 
                                                              bool includeVersionsOrStrictBinding)
        {
            BinaryFormatter remotingFormatter = new BinaryFormatter();

            if (serialize)
            {
                RemotingSurrogateSelector rss = new RemotingSurrogateSelector();
                remotingFormatter.SurrogateSelector = rss;
            }
            else
            {
                remotingFormatter.SurrogateSelector = null;
            }

            remotingFormatter.Context = new StreamingContext(StreamingContextStates.Other);

            remotingFormatter.AssemblyFormat = 
                includeVersionsOrStrictBinding ? 
                    FormatterAssemblyStyle.Full :
                    FormatterAssemblyStyle.Simple;  
            
            return remotingFormatter;
        } // CreateBinaryFormatter




        internal static void SerializeSoapMessage(IMessage msg, Stream outputStream, bool includeVersions)
        {
            // create soap formatter
            SoapFormatter fmt = CreateSoapFormatter(true, includeVersions);

            //check for special options if this is the SoapFormatter
            IMethodMessage methodMsg = msg as IMethodMessage;
            if (methodMsg != null)
            {
                MethodBase mb = methodMsg.MethodBase;
                if (mb != null)
                {
                    Type type = methodMsg.MethodBase.DeclaringType;
                    SoapTypeAttribute cache = 
                        (SoapTypeAttribute)InternalRemotingServices.GetCachedSoapAttribute(type);
                    if ((cache.SoapOptions & SoapOption.AlwaysIncludeTypes) == SoapOption.AlwaysIncludeTypes)
                        fmt.TypeFormat |= FormatterTypeStyle.TypesAlways;
                    if ((cache.SoapOptions & SoapOption.XsdString) == SoapOption.XsdString)
                        fmt.TypeFormat |= FormatterTypeStyle.XsdString;                
                }
            }
            // end of set special options for SoapFormatter
            
            Header[] h = GetSoapHeaders(msg);

            // this is to make messages within a  message serialize correctly 
            // and not use the fake type
            ((RemotingSurrogateSelector)fmt.SurrogateSelector).SetRootObject(msg);
            fmt.Serialize(outputStream, msg, h);
        } // SerializeSoapMessage

        internal static Stream SerializeSoapMessage(IMessage msg, bool includeVersions)
        {
            MemoryStream memStream = new MemoryStream();
            SerializeSoapMessage(msg, memStream, includeVersions);
            memStream.Position = 0;
            return memStream;
        } // SerializeSoapMessage
        


        internal static void SerializeBinaryMessage(IMessage msg, Stream outputStream, bool includeVersions)
        {
            // create binary formatter
            BinaryFormatter fmt = CreateBinaryFormatter(true, includeVersions);

            // WE SHOULD NOT CALL GetHeaders() here. The BinaryFormatter does special
            //   serialization for any headers that might be present.

            fmt.Serialize(outputStream, msg, null);
        } // SerializeBinaryMessage
        
        internal static Stream SerializeBinaryMessage(IMessage msg, bool includeVersions)
        {
            MemoryStream memStream = new MemoryStream();
            SerializeBinaryMessage(msg, memStream, includeVersions);
            memStream.Position = 0;
            return memStream;
        } // SerializeBinaryMessage



        // class used to pass uri into binary serializer, so that the message
        //   gets the object uri.
        private class UriHeaderHandler
        {
            String _uri = null;

            internal UriHeaderHandler(String uri)
            {
                _uri = uri;
            }
        
            public Object HeaderHandler(Header[] Headers)
            {
                return _uri;
            }
            
        } // classUriHeaderHandler


        internal static IMessage DeserializeSoapRequestMessage(
            Stream inputStream, Header[] h, bool bStrictBinding, TypeFilterLevel securityLevel)
        {
            SoapFormatter fmt = CreateSoapFormatter(false, bStrictBinding);
            fmt.FilterLevel = securityLevel;
            MethodCall mc = new MethodCall(h);
            fmt.Deserialize(inputStream, new HeaderHandler(mc.HeaderHandler));

            IMessage resMessage = (IMessage)mc;

            return resMessage;
        } // DeserializeSoapRequestMessage


        internal static IMessage DeserializeSoapResponseMessage(
            Stream inputStream, IMessage requestMsg, Header[] h, bool bStrictBinding)
        {
            SoapFormatter fmt = CreateSoapFormatter(false, bStrictBinding);

            IMethodCallMessage mcm = (IMethodCallMessage)requestMsg;
            MethodResponse mr = new MethodResponse(h, mcm);
            fmt.Deserialize(inputStream, new HeaderHandler(mr.HeaderHandler));

            IMessage resMessage = (IMessage)mr;

            return resMessage;
        } // DeserializeSoapResponseMessage


        internal static IMessage DeserializeBinaryRequestMessage(
            String objectUri, 
            Stream inputStream,
            bool bStrictBinding,
            TypeFilterLevel securityLevel)
        {
            BinaryFormatter fmt = CreateBinaryFormatter(false, bStrictBinding);
            fmt.FilterLevel = securityLevel; 
            UriHeaderHandler uriHH = new UriHeaderHandler(objectUri);

            IMessage reqMsg = 
                (IMessage)fmt.UnsafeDeserialize(inputStream, new HeaderHandler(uriHH.HeaderHandler));

            return reqMsg;
        } // DeserializeBinaryRequestMessage


        internal static IMessage DeserializeBinaryResponseMessage(
            Stream inputStream,
            IMethodCallMessage reqMsg,
            bool bStrictBinding)
        {
            BinaryFormatter fmt = CreateBinaryFormatter(false, bStrictBinding);

            IMessage replyMsg = (IMessage)fmt.UnsafeDeserializeMethodResponse(inputStream, null, reqMsg);
            return replyMsg;
        } // DeserializeBinaryResponseMessage

        

        internal static Stream SerializeMessage(String mimeType, IMessage msg)
        {
            return SerializeMessage(mimeType, msg, false);
        } // SerializeMessage

        internal static Stream SerializeMessage(String mimeType, IMessage msg, bool includeVersions)
        {
            Stream returnStream = new MemoryStream();
            SerializeMessage(mimeType, msg, returnStream, includeVersions);
            returnStream.Position = 0;
            return returnStream;
        } // SerializeMessage


        internal static void SerializeMessage(String mimeType, IMessage msg, Stream outputStream,
                                              bool includeVersions)
        {
            InternalRemotingServices.RemotingTrace("SerializeMessage");
            InternalRemotingServices.RemotingTrace("MimeType: " + mimeType);
            CoreChannel.DebugMessage(msg);
            
            if (string.Compare(mimeType, SOAPMimeType, false, CultureInfo.InvariantCulture) == 0)
            {
                SerializeSoapMessage(msg, outputStream, includeVersions);
            }
            else
            if (string.Compare(mimeType, BinaryMimeType, false, CultureInfo.InvariantCulture) == 0)
            {
                SerializeBinaryMessage(msg, outputStream, includeVersions);
            }                   

            InternalRemotingServices.RemotingTrace("SerializeMessage: OUT");
        } // SerializeMessage



        
        internal static IMessage DeserializeMessage(String mimeType, Stream xstm, bool methodRequest, IMessage msg)
        {
            return DeserializeMessage(mimeType, xstm, methodRequest, msg, null);
        }

        internal static IMessage DeserializeMessage(String mimeType, Stream xstm, bool methodRequest, IMessage msg, Header[] h)
        {
            InternalRemotingServices.RemotingTrace("DeserializeMessage");
            InternalRemotingServices.RemotingTrace("MimeType: " + mimeType);

            CoreChannel.DebugOutXMLStream(xstm, "Deserializing");

            Stream fmtStm = null;

            bool bin64encode = false;
            bool doHeaderBodyAsOne = true;

            if (string.Compare(mimeType, BinaryMimeType, false, CultureInfo.InvariantCulture) == 0)
            {
                doHeaderBodyAsOne = true;
            }

            if (string.Compare(mimeType, SOAPMimeType, false, CultureInfo.InvariantCulture) == 0)
            {
                doHeaderBodyAsOne = false;
            }

            if (bin64encode == false)
            {
                fmtStm  = xstm;
            }
            else
            {
                InternalRemotingServices.RemotingTrace("***************** Before base64 decode *****");

                long Position = xstm.Position;
                MemoryStream inStm = (MemoryStream)xstm;
                byte[] byteArray = inStm.ToArray();
                xstm.Position = Position;

                String base64String = Encoding.ASCII.GetString(byteArray,0, byteArray.Length);

                byte[] byteArrayContent = Convert.FromBase64String(base64String);

                MemoryStream memStm = new MemoryStream(byteArrayContent);

                fmtStm = memStm;
                InternalRemotingServices.RemotingTrace("***************** after base64 decode *****");
            }

            Object ret;
            IRemotingFormatter fmt = MimeTypeToFormatter(mimeType, false);

            if (doHeaderBodyAsOne == true)
            {
                ret = ((BinaryFormatter)fmt).UnsafeDeserializeMethodResponse(fmtStm, null, (IMethodCallMessage)msg);
            }
            else
            {
                InternalRemotingServices.RemotingTrace("Content");
                InternalRemotingServices.RemotingTrace("***************** Before Deserialize Headers *****");

                InternalRemotingServices.RemotingTrace("***************** After Deserialize Headers *****");

                InternalRemotingServices.RemotingTrace("***************** Before Deserialize Message *****");

                if (methodRequest == true)
                {
                    MethodCall mc = new MethodCall(h);
                    InternalRemotingServices.RemotingTrace("***************** Before Deserialize Message - as MethodCall *****");
                    fmt.Deserialize(fmtStm, new HeaderHandler(mc.HeaderHandler));
                    ret = mc;
                }
                else
                {
                    IMethodCallMessage mcm = (IMethodCallMessage)msg;
                    MethodResponse mr = new MethodResponse(h, mcm);
                    InternalRemotingServices.RemotingTrace("***************** Before Deserialize Message - as MethodResponse *****");
                    fmt.Deserialize(fmtStm, new HeaderHandler(mr.HeaderHandler));
                    ret = mr;
                }

                InternalRemotingServices.RemotingTrace("***************** After Deserialize Message *****");
            }

            // Workaround to make this method verifiable
            IMessage resMessage = (IMessage) ret;

            InternalRemotingServices.RemotingTrace("CoreChannel::DeserializeMessage OUT");
            CoreChannel.DebugMessage(resMessage);

            return resMessage;
        }
       
    

        internal static IRemotingFormatter MimeTypeToFormatter(String mimeType, bool serialize)
        {
            InternalRemotingServices.RemotingTrace("MimeTypeToFormatter: mimeType: " + mimeType);

            if (string.Compare(mimeType, SOAPMimeType, false, CultureInfo.InvariantCulture) == 0)
            {
                return CreateSoapFormatter(serialize, true);
            }
            else
            if (string.Compare(mimeType, BinaryMimeType, false, CultureInfo.InvariantCulture) == 0)
            {
                return CreateBinaryFormatter(serialize, true);
            }     

            return null;
        } // MimeTypeToFormatter


        //
        // Other helper methods
        //

        internal static String GetObjectUriFromRequestUri(String uri, IChannel receiver)
        {
            String objectUri;
            String channelUri = receiver.Parse(uri, out objectUri);

            // if there was no channel scheme, then objectUri will be null.
            if (objectUri == null)
                objectUri = uri;

            return RemoveApplicationNameFromUri(objectUri);            
        } // GetObjectUriFromRequestUri


        // combine channel uri with application name to get full channel uri
        internal static String AppendApplicationNameToChannelUri(String channelUri)
        {
            if (channelUri == null)
                return null;

            if (!channelUri.EndsWith("/"))
                channelUri += "/";

            String appName = RemotingConfiguration.ApplicationName;
            if ((appName == null) || (appName.Length == 0))
                return channelUri;
            else
                return channelUri + appName + "/";
            
        } // AppendApplicationNameToChannelUri


        // combine application name with objectURI to get full object uri
        internal static String PrependApplicationNameToObjectUri(String objectUri)
        {
            if (objectUri == null)
                return null;
            
            if (objectUri.StartsWith("/"))
                objectUri = objectUri.Substring(1);

            String appName = RemotingConfiguration.ApplicationName;
            if ((appName == null) || (appName.Length == 0))
                return objectUri;            
            else
                return appName + "/" + objectUri;
        } // PrependApplicationNameToObjectUri
        

        // Removes application name from front of uri if present.
        internal static String RemoveApplicationNameFromUri(String uri)
        {
            if (uri == null)
                return null;
        
            String appName = RemotingConfiguration.ApplicationName;
            if ((appName == null) || (appName.Length == 0))
                return uri;

            // uri must be longer than the appname plus a slash (hence the "+2")
            if (uri.Length < (appName.Length + 2))
                return uri;
            
            // case-insensitively determine if uri starts with app name
            if (String.Compare(appName, 0, uri, 0, appName.Length, true, CultureInfo.InvariantCulture) == 0)
            {
                // make sure a slash follows the app name (we already made sure
                //   uri was long enough above)
                if (uri[appName.Length] == '/')
                {
                    uri = uri.Substring(appName.Length + 1);
                }
            }            

            return uri;            
        } // RemoveApplicationNameFromUri


        internal static void AppendProviderToClientProviderChain(
            IClientChannelSinkProvider providerChain,
            IClientChannelSinkProvider provider)
        {
            if (providerChain == null)
                throw new ArgumentNullException("providerChain");

            // walk to last provider in chain
            while (providerChain.Next != null)
            {
                providerChain = providerChain.Next;
            }

            providerChain.Next = provider;
        } // AppendProviderToClientProviderChain

        internal static void CollectChannelDataFromServerSinkProviders(
            ChannelDataStore channelData,
            IServerChannelSinkProvider provider)
        {
            // walk chain and ask each provider for channel data
            while (provider != null)
            {
                provider.GetChannelData(channelData);
            
                provider = provider.Next;
            }
        } // CollectChannelDataFromServerSinkProviders


        // called by providers that aren't expecting custom provider data
        internal static void VerifyNoProviderData(String providerTypeName, ICollection providerData)
        {
            if ((providerData != null) && (providerData.Count > 0))
            {
                throw new RemotingException(
                    String.Format(
                        CoreChannel.GetResourceString(
                            "Remoting_Providers_Config_NotExpectingProviderData"),
                        providerTypeName));
            }                    
        } // VerifyNoProviderData

        internal static void ReportUnknownProviderConfigProperty(String providerTypeName,
                                                                 String propertyName)
        {
            throw new RemotingException(
                String.Format(
                    CoreChannel.GetResourceString(
                        "Remoting_Providers_Config_UnknownProperty"),
                    providerTypeName, propertyName));
        } // ReportUnknownProviderConfigProperty



        internal static SinkChannelProtocol DetermineChannelProtocol(IChannel channel)
        {
            String objectUri;
            String channelUri = channel.Parse("http://foo.com/foo", out objectUri);
            if (channelUri != null)
                return SinkChannelProtocol.Http;

            return SinkChannelProtocol.Other;
        } // DetermineChannelProtocol



        internal static bool SetupUrlBashingForIisSslIfNecessary()
        {
            // If the incoming request was IIS ssl we  need to add an 
            // entry to the call context so that the ObjRef knows
            // to bash the channel data.           
            // During serialization when using ssl the ObjRef url
            // must have the host name.
            
            HttpContext httpContext = HttpContext.Current;
            bool bBashUrl = false;
            
            if ((httpContext != null) && httpContext.Request.IsSecureConnection)
            {
                // create new url
                Uri requestUrl = httpContext.Request.Url;                

                StringBuilder sb = new StringBuilder(100);
                sb.Append("https://");
                sb.Append(requestUrl.Host);
                sb.Append(":");
                sb.Append(requestUrl.Port);
                sb.Append("/");
                sb.Append(RemotingConfiguration.ApplicationName);
            
                String[] bashInfo = new String[2];
                bashInfo[0] = IisHelper.ApplicationUrl;
                bashInfo[1] = sb.ToString();
                CallContext.SetData("__bashChannelUrl", bashInfo);
                bBashUrl = true;
            }

            return bBashUrl;
        } // SetupUrlBashingForIisSslIfNecessary

        internal static void CleanupUrlBashingForIisSslIfNecessary(bool bBashedUrl)
        {
            if (bBashedUrl)
                CallContext.FreeNamedDataSlot("__bashChannelUrl");
        } // CleanupUrlBashingForIisSslIfNecessary

        

        //** Resource helpers ***************************************************
        internal static ResourceManager SystemResMgr;

        private static ResourceManager InitResourceManager()
        {
			if (SystemResMgr == null)
                SystemResMgr = new ResourceManager("System.Runtime.Remoting", typeof(CoreChannel).Module.Assembly);
			return SystemResMgr;
        }

        // Looks up the resource string value for key.
        // 
        internal static String GetResourceString(String key)
        {
            if (SystemResMgr == null)
                InitResourceManager();
            String s = SystemResMgr.GetString(key, null);
            Debug.Assert(s!=null, "Resource string lookup failed.  Resource name was: \""+key+"\"");
            return s;
        }
    
        //** Debug items ***************************************************
        [Conditional("_DEBUG")]
        internal static void DebugOut(String s)
        {
                InternalRemotingServices.DebugOutChnl(s);
        }

        [Conditional("_DEBUG")]
        internal static void DebugOutXMLStream(Stream stm, String tag)
        {
            /*
            This can't be done when using networked streams.
            long oldpos = stm.Position;
            stm.Position=0;
            StreamReader sr = new StreamReader(stm, Encoding.UTF8);
            String line;
            InternalRemotingServices.DebugOutChnl("\n   -----------" + tag + " OPEN-------------\n") ;
            while ((line = sr.ReadLine()) != null)
            {
                InternalRemotingServices.DebugOutChnl(line);
            }
            InternalRemotingServices.DebugOutChnl("\n   -----------" + tag + " CLOSE------------\n") ;

            stm.Position = oldpos;
            */
        }

        [Conditional("_DEBUG")]
        internal static void DebugMessage(IMessage msg)
        {
            /*
              if (msg is IMethodCallMessage)
                InternalRemotingServices.RemotingTrace("IMethodCallMessage");
                
              if (msg is IMethodReturnMessage)
                InternalRemotingServices.RemotingTrace("IMethodReturnMessage");
        
              if (msg == null)
                InternalRemotingServices.RemotingTrace("***** IMessage is null");
        
              InternalRemotingServices.RemotingTrace("DebugMessage Here");
              IDictionary d = msg.Properties;
              if (d == null)
                InternalRemotingServices.RemotingTrace("***** Properties is null");
        
              InternalRemotingServices.RemotingTrace("DebugMessage Here0");      
              if (d.Count == 0)
              {
                  InternalRemotingServices.RemotingTrace("Zero Properties");
                  return;
              }
        
              InternalRemotingServices.RemotingTrace("DebugMessage Here1");
              IDictionaryEnumerator e = (IDictionaryEnumerator) d.GetEnumerator();
              InternalRemotingServices.RemotingTrace("DebugMessage Here1");
        
              while (e.MoveNext())
              {
                InternalRemotingServices.RemotingTrace("DebugMessage Here2");
        
                Object key = e.Key;
                
                InternalRemotingServices.RemotingTrace("DebugMessage Here3");
        
                String keyName = key.ToString();
        
                InternalRemotingServices.RemotingTrace("DebugMessage Here4");
        
                Object value = e.Value;
        
                InternalRemotingServices.RemotingTrace("DebugMessage Here5");
        
                InternalRemotingServices.RemotingTrace(keyName + ":" + e.Value);
        
                InternalRemotingServices.RemotingTrace("DebugMessage Here6");
        
                if (String.Compare(keyName, "__CallContext", true) == 0)
                {
                }
                
                InternalRemotingServices.RemotingTrace("DebugMessage Here7");
              }
              */
        }

        [Conditional("_DEBUG")]
        internal static void DebugException(String name, Exception e)
        {
            InternalRemotingServices.RemotingTrace("****************************************************\r\n");
            InternalRemotingServices.RemotingTrace("EXCEPTION THROWN!!!!!! - " + name);
            InternalRemotingServices.RemotingTrace("\r\n");

            InternalRemotingServices.RemotingTrace(e.Message);
            InternalRemotingServices.RemotingTrace("\r\n");

            InternalRemotingServices.RemotingTrace(e.GetType().FullName);
            InternalRemotingServices.RemotingTrace("\r\n");

            InternalRemotingServices.RemotingTrace(e.StackTrace);
            InternalRemotingServices.RemotingTrace("\r\n");
            InternalRemotingServices.RemotingTrace("****************************************************\r\n");
        }

        [Conditional("_DEBUG")]
        internal static void DebugStream(Stream stm)
        {
            /*
              try
              {
                long Position = stm.Position;
        
                MemoryStream memStm = (MemoryStream)stm;
                byte[] byteArray = memStm.ToArray();
                int byteArrayLength = byteArray.Length;
                String streamString = Encoding.ASCII.GetString(byteArray,0, byteArrayLength);
                InternalRemotingServices.RemotingTrace(streamString);
                stm.Position = Position;
              }
              catch(Exception e)
              {
                DebugException("DebugStream", e);
              }
              */
        }

    } // class CoreChannel




    internal class IisHelper
    {
        private static bool _bIsSslRequired = false;
        private static String _iisAppUrl = null;
        
        internal static void Initialize()
        {
            // NOTE!!!: This is only called from the synchronized initialization
            //   stage in HTTP remoting handler.
            try
            {
                HttpRequest request = HttpContext.Current.Request;
                String mdPath = request.ServerVariables["APPL_MD_PATH"];
    
                bool bSslRequired = false;
                if (mdPath.StartsWith("/LM/"))
                {
                    mdPath = "IIS://localhost/" + mdPath.Substring(4);  
                    DirectoryEntry dir = new DirectoryEntry(mdPath);
                    bSslRequired = (bool)dir.Properties["AccessSSL"][0];    
                }

                _bIsSslRequired = bSslRequired;
            }
            catch
            {
                // If initialization failed, we just assume that ssl isn't required.
                // This just means that we'll have to manually bash the channel data
                // everytime.         
            }
        } // Initialize
    
        internal static bool IsSslRequired
        {
            get { return _bIsSslRequired; }
        } // IsSslRequired

        internal static String ApplicationUrl
        {
            get { return _iisAppUrl; }

            set { _iisAppUrl = value; }
        } // ApplicationUrl        
        
    } // class IisHelper
   
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\combinedhttpchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       CombinedHttpChannel.cs
//
//  Summary:    Merges the client and server HTTP channels
//
//  Classes:    public HttpChannel
//
//==========================================================================

using System;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;


namespace System.Runtime.Remoting.Channels.Http
{

    /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel"]/*' />
    public class HttpChannel : BaseChannelWithProperties,
                               IChannelReceiver, IChannelSender, IChannelReceiverHook
    {
        // Cached key set value
        private static ICollection s_keySet = null;
    
        private HttpClientChannel  _clientChannel; // client channel
        private HttpServerChannel  _serverChannel; // server channel
    
        private int    _channelPriority = 1;  // channel priority
        private String _channelName = "http"; // channel name


        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.HttpChannel"]/*' />
        public HttpChannel()
        {
            _clientChannel = new HttpClientChannel();
            _serverChannel = new HttpServerChannel();
        } // HttpChannel

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.HttpChannel1"]/*' />
        public HttpChannel(int port)
        {
            _clientChannel = new HttpClientChannel();
            _serverChannel = new HttpServerChannel(port);
        } // HttpChannel

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.HttpChannel2"]/*' />
        public HttpChannel(IDictionary properties, 
                           IClientChannelSinkProvider clientSinkProvider,
                           IServerChannelSinkProvider serverSinkProvider)
        {
            Hashtable clientData = new Hashtable();
            Hashtable serverData = new Hashtable();
        
            // divide properties up for respective channels
            if (properties != null)
            {            
                foreach (DictionaryEntry entry in properties)
                {
                    switch ((String)entry.Key)
                    {
                    // general channel properties
                    case "name": _channelName = (String)entry.Value; break;
                    case "priority": _channelPriority = Convert.ToInt32((String)entry.Value); break;

                    // client properties
                    case "clientConnectionLimit": clientData["clientConnectionLimit"] = entry.Value; break;
                    case "proxyName": clientData["proxyName"] = entry.Value; break;
                    case "proxyPort": clientData["proxyPort"] = entry.Value; break;
                    case "timeout": clientData["timeout"] = entry.Value; break;
                    case "useDefaultCredentials": clientData["useDefaultCredentials"] = entry.Value; break;
                    case "useAuthenticatedConnectionSharing": clientData["useAuthenticatedConnectionSharing"] = entry.Value; break;

                    // server properties
                    case "bindTo": serverData["bindTo"] = entry.Value; break;
                    case "listen": serverData["listen"] = entry.Value; break; 
                    case "machineName": serverData["machineName"] = entry.Value; break; 
                    case "port": serverData["port"] = entry.Value; break;
                    case "suppressChannelData": serverData["suppressChannelData"] = entry.Value; break;
                    case "useIpAddress": serverData["useIpAddress"] = entry.Value; break;
                    case "exclusiveAddressUse": serverData["exclusiveAddressUse"] = entry.Value; break;

                    default: 
                        break;
                    }
                }
            }

            _clientChannel = new HttpClientChannel(clientData, clientSinkProvider);
            _serverChannel = new HttpServerChannel(serverData, serverSinkProvider);
        } // HttpChannel


        // 
        // IChannel implementation
        //

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get { return _channelPriority; }    
        } // ChannelPriority

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.ChannelName"]/*' />
        public String ChannelName
        {
            get { return _channelName; }
        } // ChannelName

        // returns channelURI and places object uri into out parameter
        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {            
            return HttpChannelHelper.ParseURL(url, out objectURI);
        } // Parse
        
        //
        // end of IChannel implementation
        //


        //
        // IChannelSender implementation
        //

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.CreateMessageSink"]/*' />
        public IMessageSink CreateMessageSink(String url, Object remoteChannelData, 
                                                      out String objectURI)
        {
            return _clientChannel.CreateMessageSink(url, remoteChannelData, out objectURI);
        } // CreateMessageSink

        //
        // end of IChannelSender implementation
        //


        //
        // IChannelReceiver implementation
        //

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.ChannelData"]/*' />
        public Object ChannelData
        {
            get { return _serverChannel.ChannelData; }
        } // ChannelData
      
                
        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.GetUrlsForUri"]/*' />
        public String[] GetUrlsForUri(String objectURI)
        {
            return _serverChannel.GetUrlsForUri(objectURI);
        } // GetUrlsForUri

        
        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.StartListening"]/*' />
        public void StartListening(Object data)
        {
            _serverChannel.StartListening(data);
        } // StartListening


        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.StopListening"]/*' />
        public void StopListening(Object data)
        {
            _serverChannel.StopListening(data);
        } // StopListening

        //
        // IChannelReceiver implementation
        //

        //
        // IChannelReceiverHook implementation
        //

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.ChannelScheme"]/*' />
        public String ChannelScheme { get { return "http"; } }

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.WantsToListen"]/*' />
        public bool WantsToListen
        {
            get { return _serverChannel.WantsToListen; }
            set { _serverChannel.WantsToListen = value; }
        } // WantsToListen

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.ChannelSinkChain"]/*' />
        public IServerChannelSink ChannelSinkChain
        {
            get { return _serverChannel.ChannelSinkChain; }
        } // ChannelSinkChain

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.AddHookChannelUri"]/*' />
        public void AddHookChannelUri(String channelUri)
        {
            _serverChannel.AddHookChannelUri(channelUri);
        } // AddHookChannelUri
        
        //
        // IChannelReceiverHook implementation
        //


        //
        // Support for properties (through BaseChannelWithProperties)
        //

        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.Properties"]/*' />
        public override IDictionary Properties
        {
            get
            {
                ArrayList dictionaries = new ArrayList(2);
                dictionaries.Add(_clientChannel.Properties);
                dictionaries.Add(_serverChannel.Properties);

                // return a dictionary that spans all dictionaries provided
                return new AggregateDictionary(dictionaries);
            }
        } // Properties
        
    
        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.this"]/*' />
        public override Object this[Object key]
        {
            get 
            {
                if (_clientChannel.Contains(key))
                    return _clientChannel[key];
                else
                if (_serverChannel.Contains(key))
                    return _serverChannel[key];

                return null;
            }

            set
            {
                if (_clientChannel.Contains(key))
                    _clientChannel[key] = value;
                else
                if (_serverChannel.Contains(key))
                    _serverChannel[key] = value;
            }
        } // this[]


        /// <include file='doc\CombinedHttpChannel.uex' path='docs/doc[@for="HttpChannel.Keys"]/*' />
        public override ICollection Keys
        {
            get
            {
                if (s_keySet == null)
                {
                    // Don't need to synchronize. Doesn't matter if the list gets
                    // generated twice.
                    ICollection clientKeys = _clientChannel.Keys;
                    ICollection serverKeys = _serverChannel.Keys;
                    
                    int count = clientKeys.Count + serverKeys.Count;                                        
                    ArrayList keys = new ArrayList(count);
                    
                    foreach (Object key in clientKeys)
                    {
                        keys.Add(key);
                    }

                    foreach (Object key in serverKeys)
                    {
                        keys.Add(key);
                    }
                    
                    s_keySet = keys;
                }

                return s_keySet;
            }
        } // KeySet


        //
        // end of Support for properties
        //
    
    } // class HttpChannel




    // an enumerator based off of a key set
    // This is a duplicate of the class in mscorlib.
    internal class DictionaryEnumeratorByKeys : IDictionaryEnumerator
    {
        IDictionary _properties;
        IEnumerator _keyEnum;
    
        public DictionaryEnumeratorByKeys(IDictionary properties)
        {
            _properties = properties;
            _keyEnum = properties.Keys.GetEnumerator();
        } // PropertyEnumeratorByKeys

        public bool MoveNext() { return _keyEnum.MoveNext(); }        
        public void Reset() { _keyEnum.Reset(); }        
        public Object Current { get { return Entry; } }

        public DictionaryEntry Entry { get { return new DictionaryEntry(Key, Value); } }
        
        public Object Key { get { return _keyEnum.Current; } }
        public Object Value { get { return _properties[Key]; } }       
        
    } // DictionaryEnumeratorByKeys


    // combines multiple dictionaries into one
    //   (used for channel sink properties
    // This is a duplicate of the class in mscorlib.
    internal class AggregateDictionary : IDictionary
    {
        private ICollection _dictionaries;
            
        public AggregateDictionary(ICollection dictionaries)
        { 
            _dictionaries = dictionaries;
        } // AggregateDictionary  

        // 
        // IDictionary implementation        
        //

        public virtual Object this[Object key]
        {
            get 
            {
                foreach (IDictionary dict in _dictionaries)
                {
                    if (dict.Contains(key))
                        return dict[key];
                }
            
                return null; 
            }
                
            set
            {
                foreach (IDictionary dict in _dictionaries)
                {
                    if (dict.Contains(key))
                        dict[key] = value;
                }
            } 
        } // Object this[Object key]

        public virtual ICollection Keys 
        {
            get
            {
                ArrayList keys = new ArrayList();
                // add keys from every dictionary
                foreach (IDictionary dict in _dictionaries)
                {
                    ICollection dictKeys = dict.Keys;
                    if (dictKeys != null)
                    {
                        foreach (Object key in dictKeys)
                        {
                            keys.Add(key);
                        }
                    }
                }

                return keys;
            }
        } // Keys
        
        public virtual ICollection Values
        {
            get
            {
                ArrayList values = new ArrayList();
                // add values from every dictionary
                foreach (IDictionary dict in _dictionaries)
                {
                    ICollection dictValues = dict.Values;
                    if (dictValues != null)
                    {
                        foreach (Object value in dictValues)
                        {
                            values.Add(value);
                        }
                    }
                }

                return values;
            }
        } // Values

        public virtual bool Contains(Object key) 
        {
            foreach (IDictionary dict in _dictionaries)
            {
                if (dict.Contains(key))
                    return true;
            }
            
            return false; 
        } // Contains

        public virtual bool IsReadOnly { get { return false; } }
        public virtual bool IsFixedSize { get { return true; } } 

        // The following three methods should never be implemented because
        // they don't apply to the way IDictionary is being used in this case
        // (plus, IsFixedSize returns true.)
        public virtual void Add(Object key, Object value) { throw new NotSupportedException(); }
        public virtual void Clear() { throw new NotSupportedException(); }
        public virtual void Remove(Object key) { throw new NotSupportedException(); }
        
        public virtual IDictionaryEnumerator GetEnumerator()
        {
            return new DictionaryEnumeratorByKeys(this);
        } // GetEnumerator
                            

        //
        // end of IDictionary implementation 
        //

        //
        // ICollection implementation 
        //

        //ICollection

        public virtual void CopyTo(Array array, int index) { throw new NotSupportedException(); }

        public virtual int Count 
        {
            get 
            {
                int count = 0;
            
                foreach (IDictionary dict in _dictionaries)
                {
                    count += dict.Count;
                }

                return count;
            }
        } // Count
        
        public virtual Object SyncRoot { get { return this; } }
        public virtual bool IsSynchronized { get { return false; } }

        //
        // end of ICollection implementation
        //

        //IEnumerable
        IEnumerator IEnumerable.GetEnumerator()
        {
            return new DictionaryEnumeratorByKeys(this);
        }
    
    } // class AggregateDictionary


} // namespace System.Runtime.Remoting.Channels.Http
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\httpchannelhelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       HttpChannelHelper.cs
//
//  Summary:    Implements helper methods for http client and server channels.
//
//==========================================================================

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Globalization;

namespace System.Runtime.Remoting.Channels.Http
{

    
    internal class HttpChannelHelper
    {
        private const String _http = "http://";
        private const String _https = "https://";

        private static char[] s_semicolonSeparator = new char[]{';'};

    
        // Determine if the url starts with "http://" or "https://"
        internal static int StartsWithHttp(String url)
        {
            int urlLength = url.Length;
            
            if (StringHelper.StartsWithAsciiIgnoreCasePrefixLower(url, _http))
                return _http.Length;
            else
            if (StringHelper.StartsWithAsciiIgnoreCasePrefixLower(url, _https))
                return _https.Length;
            else
                return -1;
        } // StartsWithHttp
 

        // Used by http channels to implement IChannel::Parse.
        // It returns the channel uri and places object uri into out parameter.
        internal static String ParseURL(String url, out String objectURI)
        {            
            // Set the out parameters
            objectURI = null;

            int separator = StartsWithHttp(url);
            if (separator == -1)
                return null;

            // find next slash (after end of scheme)
            separator = url.IndexOf('/', separator);
            if (-1 == separator)
            {
                return url;  // means that the url is just "tcp://foo:90" or something like that
            }

            // Extract the channel URI which is the prefix
            String channelURI = url.Substring(0, separator);

            // Extract the object URI which is the suffix (leave the slash)
            objectURI = url.Substring(separator);

            InternalRemotingServices.RemotingTrace("HTTPChannel.Parse URI in: " + url);
            InternalRemotingServices.RemotingTrace("HTTPChannel.Parse channelURI: " + channelURI);
            InternalRemotingServices.RemotingTrace("HTTPChannel.Parse objectURI: " + objectURI);

            return channelURI;
        } // ParseURL


        internal static String GetObjectUriFromRequestUri(String uri)
        {
            // We assume uri may be in one of the following forms
            //   http://myhost.com/myobject.rem
            //   https://myhost.com/myobject.rem
            //   /myobject.rem
            //   /myobject
            //   myobject.rem
            // In all cases, myobject is considered to be the object URI (.rem might be absent)

            int start, end; // range of characters to use
            int index;
            start = 0;
            end = uri.Length;

            // first see if uri starts with http:// or http:// and remove up to next slash if it does
            start = StartsWithHttp(uri);
            if (start != -1)
            {
                // remove domain name as well
                index = uri.IndexOf('/', start);
                if (index != -1)
                    start = index + 1;
                else
                    start = end; // uri will end up being ""
            }
            else
            {
                // remove "/" if this is an absolute path
                start = 0; 
                if (uri[start] == '/')
                   start++;
            }

            // remove query string if present ('?' and everything past it)
            index = uri.IndexOf('?');
            if (index != -1)
                end = index;

            if (start < end)
                return CoreChannel.RemoveApplicationNameFromUri(uri.Substring(start, end - start));
            else
                return "";
        } // GetObjectURIFromRequestURI

        
        internal static void ParseContentType(String contentType,
                                              out String value,
                                              out String charset)
        {
            charset = null;
        
            if (contentType == null)
            {
                value = null;
                return;
            }
        
            String[] parts = contentType.Split(s_semicolonSeparator);

            // the actual content-type value is always first
            value = parts[0];

            // examine name value pairs and look for charset
            if (parts.Length > 0)
            {
                foreach (String part in parts)
                {
                    int index = part.IndexOf('=');
                    if (index != -1)
                    {
                        String key = part.Substring(0, index).Trim();
                        if (String.Compare(key, "charset", true, CultureInfo.InvariantCulture) == 0)
                        {
                            if ((index + 1) < part.Length)
                            {
                                // we had to make sure there is something after the 
                                //   equals sign.
                                charset = part.Substring(index + 1);
                            }
                            else
                            {
                                charset = null;
                            }
                            return;
                        }
                    }
                } // foreach
            }
        } // ParseContentType


        // returns url with the machine name replaced with the ip address.
        internal static String ReplaceMachineNameWithIpAddress(String url)
        {
            String objectUri;
            String channelUri = ParseURL(url, out objectUri);    

            // find bounds of machine name
            int index = StartsWithHttp(url);
            if (index == -1)
                return url;
   
            int colonIndex = channelUri.IndexOf(':', index);
            if (colonIndex == -1)
                colonIndex = channelUri.Length;

            // machine name is between index and up to but not including colonIndex, 
            //   so we will replace those characters with the ip address.
            String machineName = url.Substring(index, colonIndex - index);

            // determine ip address (we'll resort to using the machine name
            //   if resolving the ip address fails)

            String ipAddress = machineName;
            try
            {
                IPHostEntry ipEntries = Dns.GetHostByName(machineName);
                IPAddress addr = CoreChannel.GetMachineAddress(ipEntries, AddressFamily.InterNetwork);
                if (addr != null)
                {
                    ipAddress = addr.ToString();
                }
            } 
            catch
            {
            }

 
            String newUrl = url.Substring(0, index) + ipAddress + url.Substring(colonIndex);
            return newUrl;
        } // ReplaceMachineNameWithIpAddress


        internal static String ReplaceChannelUriWithThisString(String url, String channelUri) 
        {
            // NOTE: channelUri is assumed to be scheme://machinename:port
            //   with NO trailing slash.

            String oldChannelUri;
            String objUri;
            oldChannelUri = HttpChannelHelper.ParseURL(url, out objUri);
            InternalRemotingServices.RemotingAssert(oldChannelUri != null, "http url expected.");
            InternalRemotingServices.RemotingAssert(objUri != null, "non-null objUri expected.");
            
            return channelUri + objUri;
        } // ReplaceChannelUriWithThisString


        // returns url with the machine name replaced with the ip address.
        internal static String ReplaceMachineNameWithThisString(String url, String newMachineName)
        {
            String objectUri;
            String channelUri = ParseURL(url, out objectUri);    

            // find bounds of machine name
            int index = StartsWithHttp(url);
            if (index == -1)
                return url;
   
            int colonIndex = channelUri.IndexOf(':', index);
            if (colonIndex == -1)
                colonIndex = channelUri.Length;

            // machine name is between index and up to but not including colonIndex, 
            //   so we will replace those characters with the ip address.
            String newUrl = url.Substring(0, index) + newMachineName + url.Substring(colonIndex);
            return newUrl;
        } // ReplaceMachineNameWithIpAddress


        // Decodes a uri while it is in byte array form
        internal static void DecodeUriInPlace(byte[] uriBytes, out int length)
        {
            int percentsFound = 0;
            int count = uriBytes.Length;
            length = count;
            int co = 0;
            while (co < count)
            {
                if (uriBytes[co] == (byte)'%')
                {
                    // determine location to write to (we skip 2 character for each percent)
                    int writePos = co - (percentsFound * 2);

                    // decode in place by collapsing bytes "%XY" (actual byte is 16*Dec(X) + Dec(Y))
                    uriBytes[writePos] = (byte)
                        (16 * CharacterHexDigitToDecimal(uriBytes[co + 1]) +
                         CharacterHexDigitToDecimal(uriBytes[co + 2]));

                    percentsFound++;      
                    length -= 2; // we eliminated 2 characters from the length
                    co += 3;
                }
                else
                {
                    if (percentsFound != 0)
                    {
                        // we have to copy characters back into place since we will skip some characters

                        // determine location to write to (we skip 2 character for each percent)
                        int writePos = co - (percentsFound * 2);

                        // copy character back into place
                        uriBytes[writePos] = uriBytes[co];
                    }

                    co++;
                }
            }
            
        } // DecodeUri



        // reading helper functions
        internal static int CharacterHexDigitToDecimal(byte b)
        {
            switch ((char)b)
            {
            case 'F': return 15;
            case 'E': return 14;
            case 'D': return 13;
            case 'C': return 12;
            case 'B': return 11;
            case 'A': return 10;
            default: return b - (byte)'0';
            }
        } // CharacterHexDigitToDecimal


        internal static char DecimalToCharacterHexDigit(int i)
        {
            switch (i)
            {
            case 15: return 'F';
            case 14: return 'E';
            case 13: return 'D';
            case 12: return 'C';
            case 11: return 'B';
            case 10: return 'A';
            default: return (char)(i + (byte)'0');
            }

        } // DecimalToCharacterHexDigit
                

    
    } // class HttpChannelHelper



    internal class HttpEncodingHelper
    {
        internal static String EncodeUriAsXLinkHref(String uri)
        {
            if (uri == null)
                return null;
        
            // uses modified encoding rules from xlink href spec for encoding uri's.
            // http://www.w3.org/TR/2000/PR-xlink-20001220/#link-locators

            byte[] uriBytes = Encoding.UTF8.GetBytes(uri);

            StringBuilder sb = new StringBuilder(uri.Length);

            // iterate over uri bytes and build up an encoded string.
            foreach (byte b in uriBytes)
            {
                if (!EscapeInXLinkHref(b))
                {
                    sb.Append((char)b);
                }
                else
                {
                    // the character needs to be encoded as %HH
                    sb.Append('%');
                    sb.Append(HttpChannelHelper.DecimalToCharacterHexDigit(b >> 4));
                    sb.Append(HttpChannelHelper.DecimalToCharacterHexDigit(b & 0xF));
                }
            }

            return sb.ToString();            
        } // EncodeUriAsXLinkHref


        internal static bool EscapeInXLinkHref(byte ch)
        {
            if ((ch <= 32) || // control characters and space
                (ch >= 128) ||  // non-ascii characters
                (ch == (byte)'<') ||
                (ch == (byte)'>') ||
                (ch == (byte)'"'))        
            {
                return true;
            }
                   
            return false;
        } // EscapeInXLinkHref


        internal static String DecodeUri(String uri)
        {
            byte[] uriBytes = Encoding.UTF8.GetBytes(uri);

            int length;
            HttpChannelHelper.DecodeUriInPlace(uriBytes, out length);

            String newUri = Encoding.UTF8.GetString(uriBytes, 0, length);
            return newUri;
        } // DecodeUri
        
    } // class HttpEncodingHelper



} // namespace System.Runtime.Remoting.Channels.Http
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\nativemethods.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================

using System.Runtime.InteropServices;
using System.Text;

namespace System.Runtime.Remoting.Channels.Http { 
    
    internal class NativeMethods {    
        private const string ADVAPI32 = "advapi32.dll";                                                 
        
        [DllImport(ADVAPI32, SetLastError=true)]
        internal static extern bool IsValidSid(IntPtr sidPointer);
                                                    
        [DllImport(ADVAPI32, SetLastError=true)]
        internal static extern IntPtr GetSidIdentifierAuthority(IntPtr sidPointer);
    
        [DllImport(ADVAPI32, SetLastError=true)]
        internal static extern IntPtr GetSidSubAuthorityCount(IntPtr sidPointer);
        
        [DllImport(ADVAPI32, SetLastError=true)]
        internal static extern IntPtr GetSidSubAuthority(IntPtr sidPointer, int count);
    
        [DllImport(ADVAPI32, SetLastError=true)]
        internal static extern bool GetTokenInformation(IntPtr tokenHandle, int tokenInformationClass, IntPtr sidAndAttributesPointer, 
                                                                             int tokenInformationLength, ref int returnLength);                                                                             
                                                                                                                                              
    
        [DllImport(ADVAPI32, SetLastError=true)]
        internal static extern bool ConvertSidToStringSid(IntPtr sidPointer, StringBuilder stringSid);
    
        internal const int ThreadTokenAllAccess  = 0x000F0000 | 0x01FF;
        internal const int BufferTooSmall = 0x7A;
        internal enum TokenInformationClass {
            TokenUser = 1, 
            TokenGroups, 
            TokenPrivileges, 
            TokenOwner, 
            TokenPrimaryGroup, 
            TokenDefaultDacl, 
            TokenSource, 
            TokenType, 
            TokenImpersonationLevel, 
            TokenStatistics, 
            TokenRestrictedSids, 
            TokenSessionId, 
            TokenGroupsAndPrivileges, 
            TokenSessionReference, 
            TokenSandBoxInert
        }             
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\httpstreams.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    HttpStreams.cs
**
** Purpose: Defines streams used by HTTP channels
**
** Date:    October 30, 2000
**
===========================================================*/

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting.Channels;
using System.Text;
using System.Threading;


namespace System.Runtime.Remoting.Channels.Http
{
    internal abstract class HttpServerResponseStream : Stream
    {
        public override bool CanRead { get { return false; } }
        public override bool CanSeek { get { return false; } }
        public override bool CanWrite { get { return true; } }
        
        public override long Length  { get { throw new NotSupportedException(); } }

        public override long Position
        {
             get { throw new NotSupportedException(); }
             set { throw new NotSupportedException(); }
        }

        public override long Seek(long offset, SeekOrigin origin) { throw new NotSupportedException(); }
        public override void SetLength(long value) { throw new NotSupportedException(); }
        
        public override int Read(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException();
        }
    } // HttpServerResponseStream


    internal class HttpFixedLengthResponseStream : HttpServerResponseStream
    {
        private Stream _outputStream = null; // funnel http data into here
        private static int _length;
    
        internal HttpFixedLengthResponseStream(Stream outputStream, int length)
        {
            _outputStream = outputStream;
            _length = length;
        } // HttpFixedLengthResponseStream


        public override void Close() 
        {            
            _outputStream.Flush();
        } // Close

        public override void Flush()
        {
            _outputStream.Flush();
        } // Flush

        private int min(int a, int b) { return a < b ? a : b;}
        
        public override void Write(byte[] buffer, int offset, int count)
        {            
            _outputStream.Write(buffer, offset, count);           
        } // Write

        public override void WriteByte(byte value)
        {
            _outputStream.WriteByte(value);
        } // WriteByte
    
    } // class HttpFixedLengthResponseStream
    

    internal class HttpChunkedResponseStream : HttpServerResponseStream
    {
        private static byte[] _trailer = Encoding.ASCII.GetBytes("0\r\n\r\n"); // 0-length, no trailer, end chunked
        private static byte[] _endChunk = Encoding.ASCII.GetBytes("\r\n");
   
        private Stream _outputStream = null; // funnel chunked http data into here

        private byte[] _chunk;       // chunk of data to write
        private int    _chunkSize;   // size of chunk
        private int    _chunkOffset; // next byte to write in to chunk

        private byte[] _byteBuffer = new byte[1]; // buffer for writing bytes
        

        internal HttpChunkedResponseStream(Stream outputStream)
        {
            _outputStream = outputStream;

            _chunk = CoreChannel.BufferPool.GetBuffer();
            _chunkSize = _chunk.Length - 2; // reserve space for _endChunk directly in buffer
            _chunkOffset = 0;

            // write end chunk bytes at end of buffer (avoids extra socket write)
            _chunk[_chunkSize - 2] = (byte)'\r';
            _chunk[_chunkSize - 1] = (byte)'\n';
        } // HttpChunkedResponseStream
        

        public override void Close() 
        {
            if (_chunkOffset > 0)
                FlushChunk();            
        
            _outputStream.Write(_trailer, 0, _trailer.Length);
            _outputStream.Flush();

            CoreChannel.BufferPool.ReturnBuffer(_chunk);
            _chunk = null;
        } // Close

        public override void Flush()
        {
            if (_chunkOffset > 0)
                FlushChunk();
            _outputStream.Flush();
        } // Flush

        private int min(int a, int b) { return a < b ? a : b;}
        
        public override void Write(byte[] buffer, int offset, int count)
        {
            while (count > 0)
            {
                if ((_chunkOffset == 0) && (count >= _chunkSize))
                {
                    // just write the rest as a chunk directly to the wire
                    WriteChunk(buffer, offset, count);
                    break;
                }
                else
                {
                    // write bytes to current chunk buffer
                    int writeCount = min(_chunkSize - _chunkOffset, count);
                    Array.Copy(buffer, offset, _chunk, _chunkOffset, writeCount);
                    _chunkOffset += writeCount;
                    count -= writeCount;
                    offset += writeCount;

                    // see if we need to terminate the chunk
                    if (_chunkOffset == _chunkSize)
                        FlushChunk();
                }
            }
        } // Write

        public override void WriteByte(byte value)
        {
            _byteBuffer[0] = value;
            Write(_byteBuffer, 0, 1);
        } // WriteByte

        private void FlushChunk()
        {
            WriteChunk(_chunk, 0, _chunkOffset);
            _chunkOffset = 0;
        }

        private void WriteChunk(byte[] buffer, int offset, int count)
        {
            byte[] size = IntToHexChars(count);

            _outputStream.Write(size, 0, size.Length);

            if (buffer == _chunk)
            {
                // _chunk already has end chunk encoding at end
                _outputStream.Write(_chunk, offset, count + 2);
            }
            else
            {
                _outputStream.Write(buffer, offset, count);
                _outputStream.Write(_endChunk, 0, _endChunk.Length);
            }
        } // WriteChunk
        
        
        private byte[] IntToHexChars(int i)
        {
            String str = "";

            while (i > 0)
            {
                int val = i % 16;

                switch (val)
                {
                    case 15: str = 'F' + str; break;
                    case 14: str = 'E' + str; break;
                    case 13: str = 'D' + str; break;
                    case 12: str = 'C' + str; break;
                    case 11: str = 'B' + str; break;
                    case 10: str = 'A' + str; break;

                    default: str = (char)(val + (int)'0') + str; break;
                }

                i = i / 16;
            }

            str += "\r\n";
             
            return Encoding.ASCII.GetBytes(str);
        } // IntToHexChars
        
    } // HttpChunkedResponseStream
    
    

    internal abstract class HttpReadingStream : Stream
    {
        public virtual bool ReadToEnd()
        {
            // This will never be called at a point where it is valid
            //   for someone to use the remaining data, so we don't
            //   need to buffer it.
            
            byte[] buffer = new byte[16];
            int bytesRead = 0;
            do
            {
               bytesRead = Read(buffer, 0, 16);
            } while (bytesRead > 0);

            return bytesRead == 0;
        }  


        public virtual bool FoundEnd { get { return false; } }
        
        public override bool CanRead {  get { return true; } }
        public override bool CanSeek { get { return false; } }
        public override bool CanWrite { get { return false; } }
       
        public override long Length {  get { throw new NotSupportedException(); } }

        public override long Position
        {
             get{ throw new NotSupportedException(); }
             set{ throw new NotSupportedException(); }
        }

        public override  void Flush() { throw new NotSupportedException(); }
        
        public override  long Seek(long offset, SeekOrigin origin) { throw new NotSupportedException(); }
        public override  void SetLength(long value) { throw new NotSupportedException(); }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException();
        }        

    } // HttpReadingStream


    internal class HttpFixedLengthReadingStream : HttpReadingStream
    {    
        private HttpSocketHandler _inputStream = null;  // read content data from here     
        private int _bytesLeft;                               // bytes left in current chunk
       
        internal HttpFixedLengthReadingStream(HttpSocketHandler inputStream, int contentLength)
        {
            _inputStream = inputStream;
            _bytesLeft = contentLength;
        } // HttpFixedLengthReadingStream
        

        public override bool FoundEnd { get { return _bytesLeft == 0; } }

        public override void Close() {}

        private int min(int a, int b) { return a < b ? a : b;}
        
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (_bytesLeft == 0)
                return 0;
        
            int readCount = _inputStream.Read(buffer, offset, min(_bytesLeft, count));
            if (readCount > 0)
                _bytesLeft -= readCount;
            
            return readCount;
        } // Read

        public override int ReadByte()
        {
            if (_bytesLeft == 0)
                return -1;

            _bytesLeft -= 1;
            return _inputStream.ReadByte();           
        } // ReadByte
                
    } // HttpFixedLengthReadingStream



    // Stream class to read chunked data for HTTP
    //   (assumes that provided outputStream will be positioned for
    //    reading the body)    
    internal class HttpChunkedReadingStream : HttpReadingStream
    {
        private static byte[] _trailer = Encoding.ASCII.GetBytes("0\r\n\r\n\r\n"); // 0-length, null trailer, end chunked
        private static byte[] _endChunk = Encoding.ASCII.GetBytes("\r\n");
   
        private HttpSocketHandler _inputStream = null; // read chunked http data from here
        
        private int    _bytesLeft;          // bytes left in current chunk
        private bool   _bFoundEnd = false;  // has end of stream been reached?

        private byte[] _byteBuffer = new byte[1]; // buffer for reading bytes
        
        
        internal HttpChunkedReadingStream(HttpSocketHandler inputStream)
        {
            _inputStream = inputStream;
            
            _bytesLeft = 0;
        } // HttpChunkedReadingStream

        public override bool FoundEnd { get { return _bFoundEnd; } }

        public override void Close() 
        {
        } // Close
        
        private int min(int a, int b) { return a < b ? a : b;}
        
        public override int Read(byte[] buffer, int offset, int count)
        {
            int bytesRead = 0;
        
            while (!_bFoundEnd && (count > 0))
            {
                // see if we need to start reading a new chunk
                if (_bytesLeft == 0)
                {
                    // this loop stops when the end of line is found
                    for (;;)
                    {
                        byte b = (byte)_inputStream.ReadByte();
                    
                        // see if this is the end of the length
                        if (b == '\r')
                        {          
                            // This had better be '\n'
                            if ((char)_inputStream.ReadByte() != '\n')
                            {
                                throw new RemotingException(
                                    CoreChannel.GetResourceString(
                                        "Remoting_Http_ChunkedEncodingError"));
                            }
                            else
                                break; // we've finished reading the length
                        }
                        else
                        {
                            int value = HttpChannelHelper.CharacterHexDigitToDecimal(b);
                            // make sure value is a hex-digit
                            if ((value < 0) || (value > 15))
                            {
                                throw new RemotingException(
                                    CoreChannel.GetResourceString(
                                        "Remoting_Http_ChunkedEncodingError"));
                            }

                            // update _bytesLeft value to account for new digit on the right
                            _bytesLeft = (_bytesLeft * 16) + value;
                        }
                    }
    
                    if (_bytesLeft == 0)
                    {
                        // read off trailing headers and end-line
                        String trailerHeader;
                        do
                        {
                            trailerHeader = _inputStream.ReadToEndOfLine();
                        } while (!(trailerHeader.Length == 0));
                        
                        _bFoundEnd = true;
                    }
                }

                if (!_bFoundEnd)
                {
                    int readCount = min(_bytesLeft, count);
                    int bytesReadThisTime = _inputStream.Read(buffer, offset, readCount);
                    if (bytesReadThisTime <= 0)
                    {
                        throw new RemotingException(
                            CoreChannel.GetResourceString(
                                "Remoting_Http_ChunkedEncodingError"));
                    }
                    
                    _bytesLeft -= bytesReadThisTime;
                    count -= bytesReadThisTime;
                    offset += bytesReadThisTime;
                    bytesRead += bytesReadThisTime;
                
                    // see if the end of the chunk was found
                    if (_bytesLeft == 0)
                    {
                        // read off "\r\n"
                        char ch = (char)_inputStream.ReadByte();
                        if (ch != '\r')
                        {
                            throw new RemotingException(
                                CoreChannel.GetResourceString(
                                    "Remoting_Http_ChunkedEncodingError"));
                        }
                        ch = (char)_inputStream.ReadByte();
                        if (ch != '\n')
                        {                      
                            throw new RemotingException(
                                CoreChannel.GetResourceString(
                                    "Remoting_Http_ChunkedEncodingError"));
                        }
                    }
                }
            } // while (count > 0)  

            return bytesRead;
        } // Read        

        public override int ReadByte()
        {
            int readCount = Read(_byteBuffer, 0, 1);
            if (readCount == 0)
                return -1;
                
            return _byteBuffer[0];         
        } // ReadByte
        
    } // class HttpChunkedReadingStream

    
	[Serializable]
    internal enum HttpVersion
    {
        V1_0,
        V1_1
    } // HttpVersion


    // Maintains control of a socket connection.
    internal class HttpServerSocketHandler : HttpSocketHandler
    {
        // Used to make sure verb characters are valid
        private static ValidateByteDelegate s_validateVerbDelegate =
            new ValidateByteDelegate(HttpServerSocketHandler.ValidateVerbCharacter);
    
        // Used to keep track of socket connections
        private static Int64 _connectionIdCounter = 0;        

        // primed buffer data
        private static byte[] _bufferhttpContinue = Encoding.ASCII.GetBytes("HTTP/1.1 100 Continue\r\n\r\n");
                
        // stream manager data
        private HttpReadingStream _requestStream = null;  // request stream we handed out.
        private HttpServerResponseStream _responseStream = null; // response stream we handed out.

        private Int64 _connectionId; // id for this connection

        // request state flags
        private HttpVersion _version; // http version used by client
        
        private int  _contentLength = 0;        // Content-Length value if found
        private bool _chunkedEncoding = false;  // does request stream use chunked encoding?
        private bool _keepAlive = false;        // does the client want to keep the connection alive?
        private bool _allowChunkedResponse = false;  // can we send a chunked response?
        

        internal HttpServerSocketHandler(Socket socket, RequestQueue requestQueue) : base(socket, requestQueue)
        {          
            _connectionId = Interlocked.Increment(ref _connectionIdCounter);
        } // HttpServerSocketHandler


        public bool KeepAlive { get { return _keepAlive; } }

        // FUTURE: Implement a response stream class that will only switch into chunked
        //   mode once was the response grows beyond a certain size. Chunking is
        //   disabled for now since without the custom stream, it degrades performance
        //   for small calls where chunking is not needed.
        public bool AllowChunkedResponse { get { return false && _allowChunkedResponse; } }


        // Determine if it's possible to service another request
        public bool CanServiceAnotherRequest()
        {
            if (_keepAlive && (_requestStream != null))           
            {
                if (_requestStream.FoundEnd || _requestStream.ReadToEnd())
                    return true;
            }

            return false;
        } // CanServiceAnotherRequest
        

        // Prepare for reading a new request off of the same socket
        protected override void PrepareForNewMessage()
        {
            _requestStream = null;
            _responseStream = null;
            
            _contentLength = 0;
            _chunkedEncoding = false;
            _keepAlive = false; 
            _allowChunkedResponse = false;
        } // PrepareForNewRequest

        string GenerateFaultString(Exception e) {
            //If the user has specified it's a development server (versus a production server) in remoting config,
            //then we should just return e.ToString instead of extracting the list of messages.                        
            if (!CustomErrorsEnabled()) 
                return e.ToString();            
            else {                
                return CoreChannel.GetResourceString("Remoting_InternalError");                                                             
            }            
        }
            
        protected override void SendErrorMessageIfPossible(Exception e)
        {
            // If we haven't started sending a response back, we can do the following.
            if ((_responseStream == null) && !(e is SocketException))
            {                        
                Stream outputStream = new MemoryStream();
                StreamWriter writer = new StreamWriter(outputStream, new UTF8Encoding(false));
                writer.WriteLine(GenerateFaultString(e));
                writer.Flush();            
            
                SendResponse(outputStream, "500", CoreChannel.GetResourceString("Remoting_InternalError"), null);
            }                   
        } // SendErrorMessageIfPossible


        private static bool ValidateVerbCharacter(byte b)
        {
            if (Char.IsLetter((char)b) ||
                (b == '-'))
            {
                return true;
            }

            return false;
        } // ValidateVerbCharacter
            

        // read headers
        public BaseTransportHeaders ReadHeaders()
        {        
            bool bSendContinue = false;
        
            BaseTransportHeaders headers = new BaseTransportHeaders();

            // read first line
            String verb, requestURI, version;
            ReadFirstLine(out verb, out requestURI, out version);

            if ((verb == null) || (requestURI == null) || (version == null))
            {
                throw new RemotingException(
                    CoreChannel.GetResourceString(
                        "Remoting_Http_UnableToReadFirstLine"));
            }

            if (version.Equals("HTTP/1.1")) // most common case
                _version = HttpVersion.V1_1;
            else
            if (version.Equals("HTTP/1.0"))
                _version = HttpVersion.V1_0;
            else
                _version = HttpVersion.V1_1; // (assume it will understand 1.1)

            if (_version == HttpVersion.V1_1)
            {
                _allowChunkedResponse = true;
                _keepAlive = true;
            }   
            else // it's a 1.0 client
            {
                _allowChunkedResponse = false;
                _keepAlive = false;
            }
            

            // update request uri to be sure that it has no channel data
            String channelURI;
            String objectURI;
            channelURI = HttpChannelHelper.ParseURL(requestURI, out objectURI);
            if (channelURI == null)
            {
                objectURI = requestURI;
            }                        

            headers["__RequestVerb"] = verb;
            headers.RequestUri = objectURI;
            headers["__HttpVersion"] = version;

            // check to see if we must send continue
            if ((_version == HttpVersion.V1_1) &&
                (verb.Equals("POST") || verb.Equals("PUT")))
            {
                bSendContinue = true;
            }            

            ReadToEndOfHeaders(headers, out _chunkedEncoding, out _contentLength,
                               ref _keepAlive, ref bSendContinue);       

            if (bSendContinue && (_version != HttpVersion.V1_0))
                SendContinue();

            // add IP address and Connection Id to headers
            headers[CommonTransportKeys.IPAddress] = ((IPEndPoint)NetSocket.RemoteEndPoint).Address;
            headers[CommonTransportKeys.ConnectionId] = _connectionId;
            
            return headers;
        } // ReadHeaders


        public Stream GetRequestStream()
        {
            if (_chunkedEncoding)
                _requestStream = new HttpChunkedReadingStream(this);
            else
                _requestStream = new HttpFixedLengthReadingStream(this, _contentLength);
            return _requestStream;
        } // GetRequestStream


        public Stream GetResponseStream(String statusCode, String reasonPhrase,
                                        ITransportHeaders headers)
        {
            bool contentLengthPresent = false;
            bool useChunkedEncoding = false;
            int contentLength = 0;

            // check for custom user status code and reason phrase
            Object userStatusCode = headers["__HttpStatusCode"]; // someone might have stored an int
            String userReasonPhrase = headers["__HttpReasonPhrase"] as String;

            if (userStatusCode != null)
                statusCode = userStatusCode.ToString();
            if (userReasonPhrase != null)
                reasonPhrase = userReasonPhrase;

            // see if we can handle any more requests on this socket
            if (!CanServiceAnotherRequest())
            {
                headers["Connection"] = "Close";
            }                

            // check for content length
            Object contentLengthEntry = headers["Content-Length"];
            if (contentLengthEntry != null)
            {
                contentLengthPresent = true;
                if (contentLengthEntry is int)
                    contentLength = (int)contentLengthEntry;
                else                
                    contentLength = Convert.ToInt32(contentLengthEntry);
            }

            // see if we are going to use chunked-encoding
            useChunkedEncoding = AllowChunkedResponse && !contentLengthPresent;
            if (useChunkedEncoding)
                headers["Transfer-Encoding"] = "chunked";


            // write headers to stream
            ChunkedMemoryStream headerStream = new ChunkedMemoryStream(CoreChannel.BufferPool);
            WriteResponseFirstLine(statusCode, reasonPhrase, headerStream);
            WriteHeaders(headers, headerStream);

            headerStream.WriteTo(NetStream);
            headerStream.Close();
          
           
            // return stream ready for content
            if (useChunkedEncoding)
                _responseStream = new HttpChunkedResponseStream(NetStream);
            else
                _responseStream = new HttpFixedLengthResponseStream(NetStream, contentLength);

            return _responseStream;
        } // GetResponseStream       


        private bool ReadFirstLine(out String verb, out String requestURI, out String version)
        {
            verb = null;
            requestURI = null;
            version = null;

            verb = ReadToChar(' ', s_validateVerbDelegate);

            byte[] requestUriBytes = ReadToByte((byte)' ');
            int decodedUriLength;
            HttpChannelHelper.DecodeUriInPlace(requestUriBytes, out decodedUriLength);
            requestURI = Encoding.UTF8.GetString(requestUriBytes, 0, decodedUriLength);
            
            version = ReadToEndOfLine();

            return true;
        } // ReadFirstLine
        

        private void SendContinue()
        {
            // Output:
            // HTTP/1.1 100 Continue
            
            // Send the continue response back to the client
            NetStream.Write(_bufferhttpContinue, 0, _bufferhttpContinue.Length);
        } // SendContinue


        public void SendResponse(Stream httpContentStream, 
                                 String statusCode, String reasonPhrase,
                                 ITransportHeaders headers)
        {
            if (_responseStream != null)
            {
                _responseStream.Close();
                if (_responseStream != httpContentStream)
                {
                    throw new RemotingException(
                        "Http transport sink was not given the stream that it returned from GetResponseStream().");
                }

                // we are done with the response stream
                _responseStream = null;
            }
            else
            {
                if (headers == null)
                    headers = new TransportHeaders();

                String serverHeader = (String)headers["Server"];
                if (serverHeader != null)
                    serverHeader = HttpServerTransportSink.ServerHeader + ", " + serverHeader;
                else
                    serverHeader = HttpServerTransportSink.ServerHeader;
                headers["Server"] = serverHeader;
            
                // Add length to response headers if necessary
                if (!AllowChunkedResponse && (httpContentStream != null))
                    headers["Content-Length"] = httpContentStream.Length.ToString();
                else
                if (httpContentStream == null)
                    headers["Content-Length"] = "0";
            
                GetResponseStream(statusCode, reasonPhrase, headers);
        
                // write HTTP content
                if(httpContentStream != null)
                {
                    StreamHelper.CopyStream(httpContentStream, _responseStream);                    

                    _responseStream.Close();
                    httpContentStream.Close();
                }

                // we are done with the response stream
                _responseStream = null;
            }
        } // SendResponse
       
        

    } // class HttpServerSocketHandler



} // namespace System.Runtime.Remoting.Channels.Http
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\httpserverchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       HttpServerChannel.cs
//
//  Summary:    Implements a client channel that transmits method calls over HTTP.
//
//  Classes:    public HttpClientChannel
//              internal HttpClientTransportSink
//
//==========================================================================

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Metadata;
using System.Runtime.Remoting.MetadataServices;
using System.Text;
using System.Threading;

using System.Runtime.InteropServices;


namespace System.Runtime.Remoting.Channels.Http
{

    /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel"]/*' />
    public class HttpServerChannel : BaseChannelWithProperties,
                                     IChannelReceiver, IChannelReceiverHook
    {
        private int               _channelPriority = 1;  // priority of channel (default=1)
        private String            _channelName = "http"; // channel name
        private String            _machineName = null;   // machine name
        private int               _port = -1;            // port to listen on
        private ChannelDataStore  _channelData = null;   // channel data

        private String _forcedMachineName = null; // an explicitly configured machine name
        private bool _bUseIpAddress = true; // by default, we'll use the ip address.
        private IPAddress _bindToAddr = IPAddress.Any; // address to bind to.
        private bool _bSuppressChannelData = false; // should we hand out null for our channel data
        
        private IServerChannelSinkProvider _sinkProvider = null;
        private HttpServerTransportSink    _transportSink = null;
        private IServerChannelSink         _sinkChain = null;

        private bool _wantsToListen = true;
        private bool _bHooked = false; // has anyone hooked into the channel?       
        
        
        private ExclusiveTcpListener  _tcpListener;
        private bool                  _bExclusiveAddressUse = true;
        private Thread                _listenerThread;
        private bool                  _bListening = false; // are we listening at the moment?
        private Exception             _startListeningException = null; // if an exception happens on the listener thread when attempting
                                                                       //   to start listening, that will get set here.
        private AutoResetEvent  _waitForStartListening = new AutoResetEvent(false);


        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.HttpServerChannel"]/*' />
        public HttpServerChannel() : base()
        {
            SetupMachineName();
            SetupChannel();
        }

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.HttpServerChannel1"]/*' />
        public HttpServerChannel(int port) : base()
        {
            _port = port;
            SetupMachineName();
            SetupChannel();
        } // HttpServerChannel()
    
        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.HttpServerChannel2"]/*' />
        public HttpServerChannel(String name, int port) : base()
        {
            _channelName = name;
            _port = port;
            SetupMachineName();
            SetupChannel();
        } // HttpServerChannel()

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.HttpServerChannel3"]/*' />
        public HttpServerChannel(String name, int port, IServerChannelSinkProvider sinkProvider) : base()
        {
            _channelName = name;
            _port = port;
            _sinkProvider = sinkProvider;
            SetupMachineName();
            SetupChannel();
        } // HttpServerChannel()


        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.HttpServerChannel4"]/*' />
        public HttpServerChannel(IDictionary properties, IServerChannelSinkProvider sinkProvider) : base()
        {               
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    switch ((String)entry.Key)
                    {
                    case "name": _channelName = (String)entry.Value; break; 
                    case "bindTo": _bindToAddr = IPAddress.Parse((String)entry.Value); break;
                    case "listen": _wantsToListen = Convert.ToBoolean(entry.Value); break;   
                    case "machineName": _forcedMachineName = (String)entry.Value; break;
                    case "port": _port = Convert.ToInt32(entry.Value); break;
                    case "priority": _channelPriority = Convert.ToInt32(entry.Value); break;
                    case "suppressChannelData": _bSuppressChannelData = Convert.ToBoolean(entry.Value); break;
                    case "useIpAddress": _bUseIpAddress = Convert.ToBoolean(entry.Value); break;
                    case "exclusiveAddressUse": _bExclusiveAddressUse = Convert.ToBoolean(entry.Value); break;
                
                    default: 
                        break;
                    }
                }
            }

            _sinkProvider = sinkProvider;
            SetupMachineName();
            SetupChannel();
        } // HttpServerChannel


        private void SetupMachineName()
        {
            if (_forcedMachineName != null)
            {
                // an explicitly configured machine name was used
                _machineName = CoreChannel.DecodeMachineName(_forcedMachineName);
            }
            else
            {
                if (!_bUseIpAddress)
                    _machineName = CoreChannel.GetMachineName();
                else
                {
                    if (_bindToAddr == IPAddress.Any)
                        _machineName = CoreChannel.GetMachineIp();
                    else
                        _machineName = _bindToAddr.ToString();
                }
            }
        } // SetupMachineName


        private void SetupChannel()
        {   
            // set channel data
            // (These get changed inside of StartListening(), in the case where the listen
            //   port is 0, because we can't determine the port number until after the
            //   TcpListener starts.)

            _channelData = new ChannelDataStore(null);
            if (_port > 0)
            {
                String channelUri = GetChannelUri();
                _channelData.ChannelUris = new String[1];
                _channelData.ChannelUris[0] = channelUri;

                _wantsToListen = false;
            }

            // set default provider (soap formatter) if no provider has been set
            if (_sinkProvider == null)
                _sinkProvider = CreateDefaultServerProviderChain();

            CoreChannel.CollectChannelDataFromServerSinkProviders(_channelData, _sinkProvider);

            // construct sink chain
            _sinkChain = ChannelServices.CreateServerChannelSinkChain(_sinkProvider, this);
            _transportSink = new HttpServerTransportSink(_sinkChain);

            // set sink properties on base class, so that properties will be chained.
            SinksWithProperties = _sinkChain;
            
            if (_port >= 0)
            {
                // Open a TCP port and create a thread to start listening
                _tcpListener = new ExclusiveTcpListener(_bindToAddr, _port);
                ThreadStart t = new ThreadStart(this.Listen);
                _listenerThread = new Thread(t);
                _listenerThread.IsBackground = true;

                // Wait for thread to spin up
                StartListening(null);
            }
        } // SetupChannel


        private IServerChannelSinkProvider CreateDefaultServerProviderChain()
        {
            IServerChannelSinkProvider chain = new SdlChannelSinkProvider();            
            IServerChannelSinkProvider sink = chain;
            
            sink.Next = new SoapServerFormatterSinkProvider();
            sink = sink.Next;
            sink.Next = new BinaryServerFormatterSinkProvider();
            
            return chain;
        } // CreateDefaultServerProviderChain


        //
        // IChannel implementation
        //

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get { return _channelPriority; }
        }

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.ChannelName"]/*' />
        public String ChannelName
        {
            get { return _channelName; }
        }

        // returns channelURI and places object uri into out parameter
        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {            
            return HttpChannelHelper.ParseURL(url, out objectURI);
        } // Parse

        //
        // end of IChannel implementation
        //


        //
        // IChannelReceiver implementation
        //

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.ChannelData"]/*' />
        public Object ChannelData
        {
            get
            {
                if (!_bSuppressChannelData && 
                        (_bListening || _bHooked))
                {
                    return _channelData;
                }
                else
                {
                    return null;
                }
            }
        } // ChannelData


        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.GetChannelUri"]/*' />
        public String GetChannelUri()
        {
            if ((_channelData != null) && (_channelData.ChannelUris != null))
            {
                return _channelData.ChannelUris[0];
            }
            else
            {
                return "http://" + _machineName + ":" + _port;
            }
        } // GetChannelURI


        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.GetUrlsForUri"]/*' />
        public virtual String[] GetUrlsForUri(String objectUri)
        {
            String[] retVal = new String[1];

            if (!objectUri.StartsWith("/"))
                objectUri = "/" + objectUri;
            retVal[0] = GetChannelUri() + objectUri;

            return retVal;
        } // GetURLsforURI


        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.StartListening"]/*' />
        public void StartListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("HttpChannel.StartListening");

            if (_port >= 0)
            {
                if (_listenerThread.IsAlive == false)
                {
                    _listenerThread.Start();
                    _waitForStartListening.WaitOne(); // listener thread will signal this after starting TcpListener

                    if (_startListeningException != null)
                    {
                        // An exception happened when we tried to start listening (such as "socket already in use)
                        Exception e = _startListeningException;
                        _startListeningException = null;
                        throw e;
                    }

                    _bListening = true;

                    // get new port assignment if a port of 0 was used to auto-select a port
                    if (_port == 0)
                    {
                        _port = ((IPEndPoint)_tcpListener.LocalEndpoint).Port;
                        
                        if (_channelData != null)
                        {
                            String channelUri = GetChannelUri();
                            _channelData.ChannelUris = new String[1];
                            _channelData.ChannelUris[0] = channelUri;
                        }
                    }
                }
            }
        } // StartListening


        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.StopListening"]/*' />
        public void StopListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("HTTPChannel.StopListening");

            if (_port > 0)
            {
                _bListening = false;
            
                // Ask the TCP listener to stop listening on the port
                if(null != _tcpListener)
                {
                    _tcpListener.Stop();
                }
            }
        } // StopListening

        //
        // end of IChannelReceiver implementation
        //

        //
        // IChannelReceiverHook implementation
        //

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.ChannelScheme"]/*' />
        public String ChannelScheme { get { return "http"; } }

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.WantsToListen"]/*' />
        public bool WantsToListen 
        { 
            get { return _wantsToListen; } 
            set { _wantsToListen = value; }
        } // WantsToListen

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.ChannelSinkChain"]/*' />
        public IServerChannelSink ChannelSinkChain { get { return _sinkChain; } }

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.AddHookChannelUri"]/*' />
        public void AddHookChannelUri(String channelUri)
        {
            if (_channelData.ChannelUris != null)
            {
                throw new RemotingException(
                    CoreChannel.GetResourceString("Remoting_Http_LimitListenerOfOne"));
            }
            else
            {
                // replace machine name with explicitly configured
                //   machine name or ip address if necessary
                if (_forcedMachineName != null)
                {
                    channelUri = 
                        HttpChannelHelper.ReplaceMachineNameWithThisString(channelUri, _forcedMachineName);
                }
                else
                if (_bUseIpAddress)
                {
                    channelUri = 
                        HttpChannelHelper.ReplaceMachineNameWithThisString(channelUri, CoreChannel.GetMachineIp());
                }
            
                _channelData.ChannelUris = new String[] { channelUri };
                _wantsToListen = false;
                _bHooked = true;
            }
        } // AddHookChannelUri
        
        
        //
        // end of IChannelReceiverHook implementation
        //


        //
        // Server helpers
        //

        // Thread for listening
        void Listen()
        {
            bool bOkToListen = false;
        
            try
            {
                _tcpListener.Start(_bExclusiveAddressUse);
                bOkToListen = true;
            }
            catch (Exception e)
            {
                _startListeningException = e;
            }                

            _waitForStartListening.Set(); // allow main thread to continue now that we have tried to start the socket                

            InternalRemotingServices.RemotingTrace( "Waiting to Accept the Socket on Port: " + _port);

            //
            // Wait for an incoming socket
            //
            Socket socket;
            
            while (bOkToListen)
            {
                InternalRemotingServices.RemotingTrace("TCPChannel::Listen - tcpListen.Pending() == true");                

                try
                {
                    socket = _tcpListener.AcceptSocket();

                    if (socket == null)
                    {
                        throw new RemotingException(
                            String.Format(
                                CoreChannel.GetResourceString("Remoting_Socket_Accept"),
                                Marshal.GetLastWin32Error().ToString()));
                    }
                    else
                    {
                        // disable nagle delay
                        socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, 1);

                        // set linger option
                        LingerOption lingerOption = new LingerOption(true, 3);
                        socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, lingerOption);
                    
                        HttpServerSocketHandler streamManager = new HttpServerSocketHandler(socket, CoreChannel.RequestQueue);
                        streamManager.DataArrivedCallback = new WaitCallback(_transportSink.ServiceRequest);
                        streamManager.BeginReadMessage();               
                    }
                } 
                catch (Exception e)
                {
                    if (!_bListening)
                    {
                        // We called Stop() on the tcp listener, so gracefully exit.
                        bOkToListen = false;                        
                    }
                    else
                    {
                        // we want the exception to show up as unhandled since this
                        //   is an unexpected failure.
                        if (!(e is SocketException))
                        {
                            // FUTURE: Add an internal exception reporting system, so
                            //   that failures won't be masked. For release builds, we
                            //   really don't want to let the listener thread die.
                            //throw;                    
                        }
                    }
                }
            } // while (bOkToListen)
        }


        //
        // Support for properties (through BaseChannelWithProperties)
        //

        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.this"]/*' />
        public override Object this[Object key]
        {
            get { return null; }
        
            set
            {
            }
        } // this[]
    
        /// <include file='doc\HttpServerChannel.uex' path='docs/doc[@for="HttpServerChannel.Keys"]/*' />
        public override ICollection Keys 
        {
            get
            {
                return new ArrayList(); 
            }
        }

    } // HttpServerChannel

    


    internal class HttpServerTransportSink : IServerChannelSink
    {
        private static String s_serverHeader =
            "MS .NET Remoting, MS .NET CLR " + System.Environment.Version.ToString();
    
        // sink state
        private IServerChannelSink _nextSink;
        

        public HttpServerTransportSink(IServerChannelSink nextSink)
        {
            _nextSink = nextSink;
        } // IServerChannelSink
        
    
        internal void ServiceRequest(Object state)
        {        
            HttpServerSocketHandler streamManager = (HttpServerSocketHandler)state;

            ITransportHeaders headers = streamManager.ReadHeaders();
            Stream requestStream = streamManager.GetRequestStream();
            headers["__CustomErrorsEnabled"] = streamManager.CustomErrorsEnabled();

            // process request
            ServerChannelSinkStack sinkStack = new ServerChannelSinkStack();
            sinkStack.Push(this, streamManager);

            IMessage responseMessage;
            ITransportHeaders responseHeaders;
            Stream responseStream;

            ServerProcessing processing = 
                _nextSink.ProcessMessage(sinkStack, null, headers, requestStream, 
                                         out responseMessage,
                                         out responseHeaders, out responseStream);

            // handle response
            switch (processing)
            {                    

            case ServerProcessing.Complete:
            {
                // Send the response. Call completed synchronously.
                sinkStack.Pop(this);
                streamManager.SendResponse(responseStream, "200", "OK", responseHeaders);
                break;
            } // case ServerProcessing.Complete
            
            case ServerProcessing.OneWay:
            {
                // Just send back a 200 OK
                streamManager.SendResponse(null, "202", "Accepted", responseHeaders);
                break;
            } // case ServerProcessing.OneWay

            case ServerProcessing.Async:
            {
                sinkStack.StoreAndDispatch(this, streamManager);
                break;
            }// case ServerProcessing.Async

            } // switch (processing)


            // async processing will take care if handling this later
            if (processing != ServerProcessing.Async)
            {
                if (streamManager.CanServiceAnotherRequest())
                    streamManager.BeginReadMessage();
                else
                    streamManager.Close();
            }
            
        } // ServiceRequest
      



        //
        // IServerChannelSink implementation
        //

        public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
            IMessage requestMsg,
            ITransportHeaders requestHeaders, Stream requestStream,
            out IMessage responseMsg, out ITransportHeaders responseHeaders,
            out Stream responseStream)
        {
            // NOTE: This doesn't have to be implemented because the server transport
            //   sink is always first.
            throw new NotSupportedException();
        } // ProcessMessage
           

        public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                         IMessage msg, ITransportHeaders headers, Stream stream)                 
        {
            HttpServerSocketHandler streamManager = null;

            streamManager = (HttpServerSocketHandler)state;

            // send the response
            streamManager.SendResponse(stream, "200", "OK", headers);

            if (streamManager.CanServiceAnotherRequest())
                streamManager.BeginReadMessage();
            else
                streamManager.Close();            
        } // AsyncProcessResponse


        public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                        IMessage msg, ITransportHeaders headers)
        {
            HttpServerSocketHandler streamManager = (HttpServerSocketHandler)state;

            if (streamManager.AllowChunkedResponse)
                return streamManager.GetResponseStream("200", "OK", headers);
            else
                return null;
        } // GetResponseStream


        public IServerChannelSink NextChannelSink
        {
            get { return _nextSink; }
        }


        public IDictionary Properties
        {
            get { return null; }
        } // Properties
        
        //
        // end of IServerChannelSink implementation
        //


        internal static String ServerHeader
        {
            get { return s_serverHeader; }
        }

        
        
    } // HttpServerTransportSink



    internal class ErrorMessage: IMethodCallMessage
    {

        // IMessage
        public IDictionary Properties     { get{ return null;} }

        // IMethodMessage
        public String Uri                      { get{ return m_URI; } }
        public String MethodName               { get{ return m_MethodName; }}
        public String TypeName                 { get{ return m_TypeName; } }
        public Object MethodSignature          { get { return m_MethodSignature;} }
        public MethodBase MethodBase           { get { return null; }}
        public int ArgCount                    { get { return m_ArgCount;} }
        public String GetArgName(int index)    { return m_ArgName; }
        public Object GetArg(int argNum)       { return null;}
        public Object[] Args                   { get { return null;} }

        public bool HasVarArgs                 { get { return false;} }
        public LogicalCallContext LogicalCallContext { get { return null; }}


        // IMethodCallMessage
        public int InArgCount                  { get { return m_ArgCount;} }
        public String GetInArgName(int index)   { return null; }
        public Object GetInArg(int argNum)      { return null;}
        public Object[] InArgs                { get { return null; }}

        String m_URI = "Exception";
        String m_MethodName = "Unknown";
        String m_TypeName = "Unknown";
        Object m_MethodSignature = null;
        int m_ArgCount = 0;
        String m_ArgName = "Unknown";
    } // ErrorMessage




} // namespace System.Runtime.Remoting.Channels.Http
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\httpremotinghandler.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       HTTPRemotingHandle.cool
//
//  Summary:    Implements an ASP+ handler that forwards requests to the
//              the remoting HTTP Channel.
//
//  Classes:    Derived from IHttpHandler
//
//
//==========================================================================

using System;
using System.DirectoryServices;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Reflection;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Runtime.Remoting.MetadataServices;
using System.Globalization;
using System.Collections.Specialized;

namespace System.Runtime.Remoting.Channels.Http
{

    /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandler"]/*' />
    public class HttpRemotingHandler : IHttpHandler
    {
        //Handler Specific

        private static String ApplicationConfigurationFile = "web.config";
        private static bool bLoadedConfiguration = false;
        
        private static HttpHandlerTransportSink s_transportSink = null; // transport sink


        // If an exception occurs while we are configuring the app domain, it is not possible
        // to recover since remoting is in an indeterminate state, so we will return that 
        // exception every time.
        private static Exception s_fatalException = null;         


        /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandler.HttpRemotingHandler"]/*' />
        public HttpRemotingHandler()
        {
        }

        /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandler.HttpRemotingHandler1"]/*' />
        /// <internalonly/>
        public HttpRemotingHandler(Type type, Object srvID)
        {            
        }

        //
        // Process the ASP+ Request
        //
        /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandler.ProcessRequest"]/*' />
        public void ProcessRequest(HttpContext context)
        {
            InternalProcessRequest(context);
        }

        //
        // Internal
        //
        // Transform the ASP+ Request and Response Structures in
        // Channel Structures:
        // ** Request.ServerVariables
        // ** Request.InputStream
        // ** Response.Headers
        //
        // This is needed to reduce the between dependency COR Channels
        // and ASP+
        //

        private void InternalProcessRequest(HttpContext context)
        {
            try
            {          
                HttpRequest httpRequest = context.Request;
            
                // check if have previously loaded configuration
                if (!bLoadedConfiguration)                
                {
                    // locking a random static variable, so we can lock the class
                    lock(HttpRemotingHandler.ApplicationConfigurationFile)
                    {
                        if (!bLoadedConfiguration)
                        {                                                   
                            // Initialize IIS information
                            IisHelper.Initialize();

                            // set application name
                            if (RemotingConfiguration.ApplicationName == null)
                                RemotingConfiguration.ApplicationName = httpRequest.ApplicationPath;
                    
                            String filename = String.Concat(httpRequest.PhysicalApplicationPath, 
                                                            ApplicationConfigurationFile);
                            
                            if (File.Exists(filename))
                            {
                                try
                                {
                                    RemotingConfiguration.Configure(filename);
                                }
                                catch (Exception e)
                                {
                                    s_fatalException = e;
                                    WriteException(context, e);                            
                                    return;
                                }    
                            }

                            try
                            {
                                // do a search for a registered channel that wants to listen
                                IChannelReceiverHook httpChannel = null;
                                IChannel[] channels = ChannelServices.RegisteredChannels;
                                foreach (IChannel channel in channels)
                                {
                                    IChannelReceiverHook hook = channel as IChannelReceiverHook;
                                    if (hook != null)
                                    {
                                        if (String.Compare(hook.ChannelScheme, "http", true, CultureInfo.InvariantCulture) == 0)
                                        {
                                            if (hook.WantsToListen)
                                            {
                                                httpChannel = hook;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                if (httpChannel == null)
                                {                                                                    
                                    // No http channel that was listening found.
                                    // Create a new channel.
                                    HttpChannel newHttpChannel = new HttpChannel();
                                    ChannelServices.RegisterChannel(newHttpChannel);
                                    httpChannel = newHttpChannel;
                                }

                                String scheme = null;
                                if (IisHelper.IsSslRequired)
                                    scheme = "https";
                                else
                                    scheme = "http";
    
                                String hookChannelUri =
                                    scheme + "://" + CoreChannel.GetMachineIp();

                                int port = context.Request.Url.Port;
                                String restOfUri = ":" + port + "/" + RemotingConfiguration.ApplicationName;
                                hookChannelUri += restOfUri;                                   

                                // add hook uri for this channel                                
                                httpChannel.AddHookChannelUri(hookChannelUri);
                                
                                // If it uses ChannelDataStore, re-retrieve updated url in case it was updated.
                                ChannelDataStore cds = ((IChannelReceiver)httpChannel).ChannelData as ChannelDataStore;
                                if (cds != null)
                                    hookChannelUri = cds.ChannelUris[0];

                                IisHelper.ApplicationUrl = hookChannelUri;

                                // This is a hack to refresh the channel data.
                                //   In V-Next, we will add a ChannelServices.RefreshChannelData() api.
                                ChannelServices.UnregisterChannel(null);
                                                            
                                s_transportSink = new HttpHandlerTransportSink(httpChannel.ChannelSinkChain);                                                               
                            }
                            catch (Exception e)
                            {
                                s_fatalException = e;
                                WriteException(context, e);                            
                                return;
                            }
                            bLoadedConfiguration = true;
                        }
                    }
                }  

                if (s_fatalException == null) 
                {
                   if (!CanServiceRequest(context))
                        WriteException(context, new RemotingException(CoreChannel.GetResourceString("Remoting_ChnlSink_UriNotPublished")));
                   else                                                                   
                        s_transportSink.HandleRequest(context);       
                }                    
                else
                    WriteException(context, s_fatalException);                 
            }
            catch (Exception e)
            {
                WriteException(context, e);
            }
        } // InternalProcessRequest
        

        /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandler.IsReusable"]/*' />
        public bool IsReusable { get { return true; } }
                
        string ComposeContentType(string contentType, Encoding encoding) {
            if (encoding != null) {
                StringBuilder sb = new StringBuilder(contentType);
                sb.Append("; charset=");
                sb.Append(encoding.WebName);
                return sb.ToString();
            }
            else
                return contentType;
        }

        bool CanServiceRequest(HttpContext context) {                        
            //Need to get the object uri first (cannot have query string)
            string requestUri = GetRequestUriForCurrentRequest(context);            
            string objectUri = HttpChannelHelper.GetObjectUriFromRequestUri(requestUri);              
            context.Items["__requestUri"] = requestUri;                                                  
            
            if (String.Compare(context.Request.HttpMethod, "GET", true, CultureInfo.InvariantCulture) != 0) {
                //If the request backed by an existing object
                if (RemotingServices.GetServerTypeForUri(requestUri) != null)
                    return true;                                                                                       
            } 
            else {
                if (context.Request.QueryString.Count != 1) 
                    return false;
            
                string[] values =  context.Request.QueryString.GetValues(0);                       
                if (values.Length != 1 || String.Compare(values[0], "wsdl", true, CultureInfo.InvariantCulture) != 0)
                    return false;                                                        
            
                //If the request specifically asks for the wildcard                
                if (String.Compare(objectUri, "RemoteApplicationMetadata.rem", true, CultureInfo.InvariantCulture) == 0)
                    return true;
            
                // find last index of ?            
                int index = requestUri.LastIndexOf('?');
                if (index != -1) 
                    requestUri =  requestUri.Substring(0, index);

                //If the request backed by an existing object
                if (RemotingServices.GetServerTypeForUri(requestUri) != null)
                    return true;                                                                                                                                               
            }
            
            //If the request is backed by an existing file on disk it should be serviced
            if (File.Exists(context.Request.PhysicalPath))
                return true;                                            
            
            return false;      
        }
        
        string GetRequestUriForCurrentRequest(HttpContext context) {
            // we need to pull off any http specific data plus the application v-dir name
            String rawUrl = context.Request.RawUrl;
            // here's where we pull off channel info
            String channelUri;
            String requestUri;
            channelUri = HttpChannelHelper.ParseURL(rawUrl, out requestUri);
            if (channelUri == null)
                requestUri = rawUrl;
    
            // here's where we pull off the application v-dir name
            String appName = RemotingConfiguration.ApplicationName;
            if (appName != null && appName.Length > 0 && requestUri.Length > appName.Length)                                
                //  "/appname" should always be in front, otherwise we wouldn't
                //   be in this handler.                    
                requestUri = requestUri.Substring(appName.Length + 1);            
            
            return requestUri;
        }
        
        string GenerateFaultString(HttpContext context, Exception e) {
            //If the user has specified it's a development server (versus a production server) in ASP.NET config,
            //then we should just return e.ToString instead of extracting the list of messages.                        
            if (!CustomErrorsEnabled(context)) 
                return e.ToString();            
            else {                
                return CoreChannel.GetResourceString("Remoting_InternalError");                                                             
            }            
        }
        
        void WriteException(HttpContext context, Exception e) {
            InternalRemotingServices.RemotingTrace("HttpHandler: Exception thrown...\n");
            InternalRemotingServices.RemotingTrace(e.StackTrace);
            
            Stream outputStream = context.Response.OutputStream;
            context.Response.Clear();
            context.Response.ClearHeaders();
            context.Response.ContentType = ComposeContentType("text/plain", Encoding.UTF8);
            context.Response.StatusCode = (int) HttpStatusCode.InternalServerError;
            context.Response.StatusDescription = CoreChannel.GetResourceString("Remoting_InternalError");                                                             
            StreamWriter writer = new StreamWriter(outputStream, new UTF8Encoding(false));
            writer.WriteLine(GenerateFaultString(context, e));
            writer.Flush();            
        }                
        
        internal static bool IsLocal(HttpContext context) {            
            string localAddress = context.Request.ServerVariables["LOCAL_ADDR"];
            string remoteAddress = context.Request.UserHostAddress;
            return (context.Request.Url.IsLoopback || (localAddress != null && remoteAddress != null && localAddress == remoteAddress));            
        }
        
        internal static bool CustomErrorsEnabled(HttpContext context) {
            try {            
                if (!context.IsCustomErrorEnabled)
                    return false;
                    
                return RemotingConfiguration.CustomErrorsEnabled(IsLocal(context));                
            }
            catch(Exception) {
                return true;
            }                
        }

    } // HttpRemotingHandler

    /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandlerFactory"]/*' />
    public class HttpRemotingHandlerFactory : IHttpHandlerFactory
    {
        internal object _webServicesFactory = null;
        internal static Type s_webServicesFactoryType = null;
        // REMACT: internal static Type s_remActType = null;

        internal static Object s_configLock = new Object();

        internal static Hashtable s_registeredDynamicTypeTable = Hashtable.Synchronized(new Hashtable());
        

        void DumpRequest(HttpContext context)
        {
            HttpRequest request = context.Request;
            InternalRemotingServices.DebugOutChnl("Process Request called.");
            InternalRemotingServices.DebugOutChnl("Path = " + request.Path);
            InternalRemotingServices.DebugOutChnl("PhysicalPath = " + request.PhysicalPath);
            //InternalRemotingServices.DebugOutChnl("QueryString = " + request.Url.QueryString);
            InternalRemotingServices.DebugOutChnl("HttpMethod = " + request.HttpMethod);
            InternalRemotingServices.DebugOutChnl("ContentType = " + request.ContentType);
            InternalRemotingServices.DebugOutChnl("PathInfo = " + request.PathInfo);

            /*
            String[] keys = request.Headers.AllKeys;
            String[] values = request.Headers.All;

            for (int i=0; i<keys.Length; i++)
            {
                InternalRemotingServices.DebugOutChnl("Header :: " + keys[i] + "/" + values[i]);
            }
            */
        }

        private void ConfigureAppName(HttpRequest httpRequest)
        {
            if (RemotingConfiguration.ApplicationName == null)
            {
                lock (s_configLock)
                {
                    if (RemotingConfiguration.ApplicationName == null) 
                        RemotingConfiguration.ApplicationName = httpRequest.ApplicationPath;
                }
            }
        } // ConfigureAppName


        /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandlerFactory.GetHandler"]/*' />
        public IHttpHandler GetHandler(HttpContext context, string verb, string url, string filePath)
        {
            // REMACT: 
            // If this is a request to the root vdir, we will route it to the activation
            //   handler instead.
            //if (context.Request.ApplicationPath.Equals("/"))
            //{
            //    if (s_remActType == null)
            //        s_remActType = Type.GetType("System.Runtime.Remoting.Channels.Http.RemotingActivationHandler, System.Runtime.Remoting.Activation");
            //
            //    if (s_remActType != null)
            //        return (IHttpHandler)Activator.CreateInstance(s_remActType);                
            //}
        
            //if (CompModSwitches.Remote.TraceVerbose) DumpRequest(context);
            //System.Diagnostics.Debugger.Break();

            InternalRemotingServices.DebugOutChnl("HttpRemotingHandlderFactory::GetHanlder: IN");

            DumpRequest(context);  // UNDONE, should be under a switch

            HttpRequest httpRequest = context.Request;
            ConfigureAppName(httpRequest);
            
            string queryString = httpRequest.QueryString[null];

            bool bVerbIsGET = (String.Compare(httpRequest.HttpMethod, "GET", true, CultureInfo.InvariantCulture) == 0);
            bool bFileExists = File.Exists(httpRequest.PhysicalPath);

            if (bVerbIsGET && bFileExists && queryString == null)
            {
                InternalRemotingServices.DebugOutChnl("HttpRemotingHandlderFactory::GetHanlder: non-post -- send to WebServices");
                return WebServicesFactory.GetHandler(context, verb, url, filePath);
            }
            else
            {
                InternalRemotingServices.DebugOutChnl("HttpRemotingHandlderFactory::GetHandler: post -- handling with Remoting");
                
                if (bFileExists)
                {
                    Type type = WebServiceParser.GetCompiledType(
                       httpRequest.PhysicalPath, context);

                    String machineAndAppName = Dns.GetHostName() + httpRequest.ApplicationPath;
        
                    // determine last part of url
                    String[] urlComponents = httpRequest.PhysicalPath.Split(new char[]{'\\'});
                    String uri = urlComponents[urlComponents.Length - 1] ;

                    // register the type if it has changed or hasn't been registered yet.
                    Type lastType = (Type)s_registeredDynamicTypeTable[uri];
                    if (lastType != type)
                    {
                        RegistrationHelper.RegisterType(machineAndAppName, type, uri);
                        s_registeredDynamicTypeTable[uri] = type;
                    }

                    return new HttpRemotingHandler();
                }
                else
                {
                  return new HttpRemotingHandler();
                }
            }
        }

        private IHttpHandlerFactory WebServicesFactory
        {
            get
            {
                if (_webServicesFactory == null)
                {
                    lock(this)
                    {
                        if (_webServicesFactory == null)
                        {
                            _webServicesFactory = Activator.CreateInstance(WebServicesFactoryType);
                        }
                    }
                }
                return (IHttpHandlerFactory)_webServicesFactory;
            }
        }

        private static Type WebServicesFactoryType
        {
            get
            {
                if (s_webServicesFactoryType == null)
                {
                    Assembly a = Assembly.Load("System.Web.Services, Version="+VER_ASSEMBLYVERSION_STR+", Culture=neutral, PublicKeyToken= "+PUBLIC_KEY_TOKEN);
                    if (a == null)
                    {
                        throw new RemotingException(String.Format(CoreChannel.GetResourceString("Remoting_AssemblyLoadFailed"), "System.Web.Services"));
                    }
        
                    s_webServicesFactoryType = a.GetType("System.Web.Services.Protocols.WebServiceHandlerFactory");

                }
                return s_webServicesFactoryType;
            }
        }


        /// <include file='doc\HTTPRemotingHandler.uex' path='docs/doc[@for="HttpRemotingHandlerFactory.ReleaseHandler"]/*' />
        public void ReleaseHandler(IHttpHandler handler)
        {
            if (_webServicesFactory != null)
            {
                ((IHttpHandlerFactory)_webServicesFactory).ReleaseHandler(handler);
                _webServicesFactory = null;
            }
        }
    } //class HttpRemotingHandlerFactory    





    internal class RegistrationHelper
    {    
        public static void RegisterType(String machineAndAppName, Type type, String uri)
        {
            RemotingConfiguration.RegisterWellKnownServiceType(type, uri, WellKnownObjectMode.SingleCall);

            Type[] allTypes = type.Assembly.GetTypes();
            foreach (Type asmType in allTypes)
            {
                RegisterSingleType(machineAndAppName, asmType);
            }            
        } // RegisterType

        private static void RegisterSingleType(String machineAndAppName, Type type)
        {
            String xmlName = type.Name;            
            String xmlNamespace = "http://" + machineAndAppName + "/" + type.FullName;
            SoapServices.RegisterInteropXmlElement(xmlName, xmlNamespace, type);
            SoapServices.RegisterInteropXmlType(xmlName, xmlNamespace, type);
            
            if (typeof(MarshalByRefObject).IsAssignableFrom(type))
            {
                // register soap action for all methods if this is a MarshalByRefObject type
                MethodInfo[] methods = type.GetMethods();
                foreach (MethodInfo mi in methods)
                {
                    SoapServices.RegisterSoapActionForMethodBase(mi, xmlNamespace + "#" + mi.Name);
                }
            }
            
        } // RegisterSingleType
        
    } // class RegistrationHelper
    




    // channel sink for interfacing with a sink chain
    internal class HttpHandlerTransportSink : IServerChannelSink    
    {
        private const int _defaultChunkSize = 2048;
    
        // sink state
        public IServerChannelSink _nextSink;


        public HttpHandlerTransportSink(IServerChannelSink nextSink)
        {
            _nextSink = nextSink;
        } // HttpHandlerTransportSink
                
        public void HandleRequest(HttpContext context)
        {
            HttpRequest httpRequest = context.Request;
            HttpResponse httpResponse = context.Response;

            // get headers
            BaseTransportHeaders requestHeaders = new BaseTransportHeaders();

            requestHeaders["__RequestVerb"] = httpRequest.HttpMethod;
            requestHeaders["__CustomErrorsEnabled"] = HttpRemotingHandler.CustomErrorsEnabled(context);                       
            requestHeaders.RequestUri = (string)context.Items["__requestUri"];

            NameValueCollection headers = httpRequest.Headers;          
            String[] allKeys = headers.AllKeys;

            for (int httpKeyCount=0; httpKeyCount< allKeys.Length; httpKeyCount++)
            {
                String headerName = allKeys[httpKeyCount];
                String headerValue = headers[headerName];
                requestHeaders[headerName] = headerValue;
            }

            // add ip address to headers list
            requestHeaders.IPAddress = IPAddress.Parse(httpRequest.UserHostAddress);

            // get request stream
            Stream requestStream = httpRequest.InputStream;

            // process message
            ServerChannelSinkStack sinkStack = new ServerChannelSinkStack();
            sinkStack.Push(this, null);
            
            IMessage responseMessage;
            ITransportHeaders responseHeaders;
            Stream responseStream;

            ServerProcessing processing = 
                _nextSink.ProcessMessage(sinkStack, null, requestHeaders, requestStream, 
                                         out responseMessage,
                                         out responseHeaders, out responseStream);
                
            // handle response
            switch (processing)
            {                    

            case ServerProcessing.Complete:
            {
                // Send the response. Call completed synchronously.             
                SendResponse(httpResponse, 200, responseHeaders, responseStream);
                break;
            } // case ServerProcessing.Complete
            
            case ServerProcessing.OneWay:
            {
                // Just send back a 202 Accepted
                SendResponse(httpResponse, 202, responseHeaders, responseStream);
                break;
            } // case ServerProcessing.OneWay

            case ServerProcessing.Async:
            {
                // Async dispatching was cut from V.1.
                //sinkStack.StoreAndDispatch(this, streamManager);
                break;
            }// case ServerProcessing.Async

            } // switch (processing)

            
        } // HandleRequest


        private void SendResponse(HttpResponse httpResponse, int statusCode,
                                  ITransportHeaders responseHeaders, Stream httpContentStream)
        {
            // store headers
            if (responseHeaders != null)
            {
                // set server string
                String serverHeader = (String)responseHeaders["Server"];
                if (serverHeader != null)
                    serverHeader = HttpServerTransportSink.ServerHeader + ", " + serverHeader;
                else
                    serverHeader = HttpServerTransportSink.ServerHeader;
                responseHeaders["Server"] = serverHeader;

                // set status code
                Object userStatusCode = responseHeaders["__HttpStatusCode"]; // someone might have stored an int

                if (userStatusCode != null)
                    statusCode = Convert.ToInt32(userStatusCode);           

                // see if stream has a content length
                if (httpContentStream != null)
                {
                    int length = -1;
                    try
                    {
                        if (httpContentStream != null)
                            length = (int)httpContentStream.Length;
                    } catch (Exception) {}

                    if (length != -1)
                        responseHeaders["Content-Length"] = length;
                }
                else
                    responseHeaders["Content-Length"] = 0;

                // add headers to the response
                foreach (DictionaryEntry entry in responseHeaders)
                {
                    String key = (String)entry.Key;                
                    if (!key.StartsWith("__"))
                        httpResponse.AppendHeader(key, entry.Value.ToString());
                }
            }

            httpResponse.StatusCode = statusCode;

            // send stream
            Stream httpResponseStream = httpResponse.OutputStream;            

            if(httpContentStream != null)
            {
                StreamHelper.CopyStream(httpContentStream, httpResponseStream);
                httpContentStream.Close();
            }
            
        } // SendResponse                 


        //
        // IServerChannelSink implementation
        //

        public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
            IMessage requestMsg,
            ITransportHeaders requestHeaders, Stream requestStream,
            out IMessage responseMsg, out ITransportHeaders responseHeaders,
            out Stream responseStream)
        {
            throw new NotSupportedException();
        }
           

        public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                         IMessage msg, ITransportHeaders headers, Stream stream)                 
        {
            // FUTURE: Async dispatching on the server was cut for v1.
            //   Implement this in the next version when support is added.

            throw new NotSupportedException();            
        } // AsyncProcessResponse


        public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                        IMessage msg, ITransportHeaders headers)
        {
            // we always want a stream to read from
            return null;
        } // GetResponseStream


        public IServerChannelSink NextChannelSink
        {
            get { return _nextSink; }
        } // Next


        public IDictionary Properties
        {
            get { return null; }
        } // Properties
        
        //
        // end of IServerChannelSink implementation
        //
        
    } // class HttpHandlerTransportSink



    
}//nameSpace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\http\httpclientchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       HttpClientChannel.cs
//
//  Summary:    Implements a client channel that transmits method calls over HTTP.
//
//  Classes:    public HttpClientChannel
//              internal HttpClientTransportSink
//
//==========================================================================

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.ComponentModel;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Globalization;
using System.Text;

namespace System.Runtime.Remoting.Channels.Http
{



    /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel"]/*' />
    public class HttpClientChannel : BaseChannelWithProperties, IChannelSender
    {
        // Property Keys (purposely all lower-case)
        private const String ProxyNameKey = "proxyname";
        private const String ProxyPortKey = "proxyport";

        // If above keys get modified be sure to modify, the KeySet property on this
        // class.
        private static ICollection s_keySet = null;
        
    
        // Settings
        private int    _channelPriority = 1;  // channel priority
        private String _channelName = "http"; // channel name

        // Proxy settings (_proxyObject gets recreated when _proxyName and _proxyPort are updated)
        private IWebProxy _proxyObject = null; // proxy object for request, can be overridden in transport sink
        private String    _proxyName = null;
        private int       _proxyPort = -1;  
        private int _timeout = System.Threading.Timeout.Infinite;           // default timeout is infinite

        private int _clientConnectionLimit = 0; // bump connection limit to at least this number (only meaningful if > 0)
        private bool _bUseDefaultCredentials = false; // should default credentials be used?
        private bool _bAuthenticatedConnectionSharing = true;
        
        private IClientChannelSinkProvider _sinkProvider = null; // sink chain provider                       


        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.HttpClientChannel"]/*' />
        public HttpClientChannel()
        {
            SetupChannel();
        } // HttpClientChannel()


        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.HttpClientChannel1"]/*' />
        public HttpClientChannel(String name, IClientChannelSinkProvider sinkProvider)
        {
            _channelName = name;
            _sinkProvider = sinkProvider;

            SetupChannel();
        } // HttpClientChannel(IClientChannelSinkProvider sinkProvider)
       

        // constructor used by config file
        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.HttpClientChannel2"]/*' />
        public HttpClientChannel(IDictionary properties, IClientChannelSinkProvider sinkProvider)
        {
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    switch ((String)entry.Key)
                    {
                    case "name": _channelName = (String)entry.Value; break;
                    case "priority": _channelPriority = Convert.ToInt32(entry.Value); break;

                    case "proxyName": this["proxyName"] = entry.Value; break;
                    case "proxyPort": this["proxyPort"] = entry.Value; break;
                    case "timeout": _timeout = Convert.ToInt32(entry.Value); break;
                    
                    case "clientConnectionLimit": 
                    {
                        _clientConnectionLimit = Convert.ToInt32(entry.Value); 
                        break;
                    }

                    case "useDefaultCredentials":
                    {
                        _bUseDefaultCredentials = Convert.ToBoolean(entry.Value);
                        break;
                    }
                    
                    case "useAuthenticatedConnectionSharing":
                    {
                        _bAuthenticatedConnectionSharing = Convert.ToBoolean(entry.Value); 
                        break;
                    }

                    default: 
                        break;
                    }
                }
            }

            _sinkProvider = sinkProvider;

            SetupChannel();
        } // HttpClientChannel
        

        private void SetupChannel()
        {
            if (_sinkProvider != null)
            {
                CoreChannel.AppendProviderToClientProviderChain(
                    _sinkProvider, new HttpClientTransportSinkProvider(_timeout));                                                
            }
            else
                _sinkProvider = CreateDefaultClientProviderChain();
                
        
            // proxy might have been created by setting proxyname/port in constructor with dictionary
            if (_proxyObject == null) 
            {
                // In this case, try to use the default proxy settings.
                WebProxy defaultProxy = WebProxy.GetDefaultProxy();
                if (defaultProxy != null)
                {
                    Uri address = defaultProxy.Address;
                    if (address != null)
                    {
                        _proxyName = address.Host;
                        _proxyPort = address.Port;
                    }
                }
                UpdateProxy();
            }
        } // SetupChannel()



        //
        // IChannel implementation
        //

        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get { return _channelPriority; }    
        }

        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.ChannelName"]/*' />
        public String ChannelName
        {
            get { return _channelName; }
        }

        // returns channelURI and places object uri into out parameter
        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {            
            return HttpChannelHelper.ParseURL(url, out objectURI);
        } // Parse

        //
        // end of IChannel implementation
        // 



        //
        // IChannelSender implementation
        //

        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.CreateMessageSink"]/*' />
        public virtual IMessageSink CreateMessageSink(String url, Object remoteChannelData, out String objectURI)
        {
            // Set the out parameters
            objectURI = null;
            String channelURI = null;

            
            if (url != null) // Is this a well known object?
            {
                // Parse returns null if this is not one of our url's
                channelURI = Parse(url, out objectURI);
            }
            else // determine if we want to connect based on the channel data
            {
                if (remoteChannelData != null)
                {
                    if (remoteChannelData is IChannelDataStore)
                    {
                        IChannelDataStore cds = (IChannelDataStore)remoteChannelData;

                        // see if this is an http uri
                        String simpleChannelUri = Parse(cds.ChannelUris[0], out objectURI);
                        if (simpleChannelUri != null)
                            channelURI = cds.ChannelUris[0];
                    }
                }
            }

            if (channelURI != null)
            {
                if (url == null)
                    url = channelURI;

                if (_clientConnectionLimit > 0)
                {
                    ServicePoint sp = ServicePointManager.FindServicePoint(new Uri(channelURI));
                    if (sp.ConnectionLimit < _clientConnectionLimit)
                        sp.ConnectionLimit = _clientConnectionLimit;
                }

                // This will return null if one of the sink providers decides it doesn't
                // want to allow (or can't provide) a connection through this channel.
                IClientChannelSink sink = _sinkProvider.CreateSink(this, url, remoteChannelData);
                
                // return sink after making sure that it implements IMessageSink
                IMessageSink msgSink = sink as IMessageSink;
                if ((sink != null) && (msgSink == null))
                {
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_Channels_ChannelSinkNotMsgSink"));
                }
                    
                return msgSink;
            }

            return null;
        } // CreateMessageSink


        //
        // end of IChannelSender implementation
        //


        private IClientChannelSinkProvider CreateDefaultClientProviderChain()
        {
            IClientChannelSinkProvider chain = new SoapClientFormatterSinkProvider();            
            IClientChannelSinkProvider sink = chain;
            
            sink.Next = new HttpClientTransportSinkProvider(_timeout);
            
            return chain;
        } // CreateDefaultClientProviderChain
        


        //
        // Support for properties (through BaseChannelSinkWithProperties)
        //
        
        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.this"]/*' />
        public override Object this[Object key]
        {
            get
            {
                String keyStr = key as String;
                if (keyStr == null)
                    return null;
            
                switch (keyStr.ToLower(CultureInfo.InvariantCulture))
                {
                    case ProxyNameKey: return _proxyName;
                    case ProxyPortKey: return _proxyPort;
                } // switch (keyStr.ToLower(CultureInfo.InvariantCulture))

                return null;
            }

            set
            {
                String keyStr = key as String;
                if (keyStr == null)
                    return;
    
                switch (keyStr.ToLower(CultureInfo.InvariantCulture))
                {
                    case ProxyNameKey: _proxyName = (String)value; UpdateProxy(); break;
                    case ProxyPortKey: _proxyPort = Convert.ToInt32(value); UpdateProxy(); break;                        
                } // switch (keyStr.ToLower(CultureInfo.InvariantCulture))
            }
        } // this[]   


        /// <include file='doc\HttpClientChannel.uex' path='docs/doc[@for="HttpClientChannel.Keys"]/*' />
        public override ICollection Keys
        {
            get
            {
                if (s_keySet == null)
                {
                    // Don't need to synchronize. Doesn't matter if the list gets
                    // generated twice.
                    ArrayList keys = new ArrayList(2);
                    keys.Add(ProxyNameKey);
                    keys.Add(ProxyPortKey);
                    
                    s_keySet = keys;
                }

                return s_keySet;
            }
        } // Keys


        //
        // end of Support for properties
        //


        //
        // Helper functions for processing settings and properties
        //

        // Called to recreate proxy object whenever the proxy name or port is changed.
        private void UpdateProxy()
        {
            if ((_proxyName != null) && (_proxyName.Length > 0) &&                
                (_proxyPort > 0))
            {
                WebProxy proxy = new WebProxy(_proxyName, _proxyPort);
                
                // disable proxy use when the host is local. i.e. without periods
                proxy.BypassProxyOnLocal = true;

                // setup bypasslist to include local ip address
                String[] bypassList = new String[]{ CoreChannel.GetMachineIp() };
                proxy.BypassList = bypassList;

                _proxyObject = proxy;
            }
            else
            {
                _proxyObject = new WebProxy();
            }
        } // UpdateProxy

        //
        // end of Helper functions for processing settings and properties
        //

        //
        // Methods to access properties (internals are for use by the transport sink)     
        //

        internal IWebProxy ProxyObject { get { return _proxyObject; } }
        internal bool UseDefaultCredentials { get { return _bUseDefaultCredentials; } }
        internal bool UseAuthenticatedConnectionSharing { get { return _bAuthenticatedConnectionSharing; } }

        //
        // end of Methods to access properties
        //

    } // class HttpClientChannel




    internal class HttpClientTransportSinkProvider : IClientChannelSinkProvider
    {
        int _timeout;
        
        internal HttpClientTransportSinkProvider(int timeout)
        {
            _timeout = timeout;
        }    
   
        public IClientChannelSink CreateSink(IChannelSender channel, String url, 
                                             Object remoteChannelData)
        {
            // url is set to the channel uri in CreateMessageSink        
            HttpClientTransportSink sink = new HttpClientTransportSink((HttpClientChannel)channel, url);
            sink["timeout"] = _timeout;
            return sink;
        }

        public IClientChannelSinkProvider Next
        {
            get { return null; }
            set { throw new NotSupportedException(); }
        }
    } // class HttpClientTransportSinkProvider




    // transport sender sink used by HttpClientChannel
    internal class HttpClientTransportSink : BaseChannelSinkWithProperties, IClientChannelSink
    {
        private const String s_defaultVerb = "POST";

        private static String s_userAgent =
            "Mozilla/4.0+(compatible; MSIE 6.0; Windows " + 
            System.Environment.OSVersion.Version +
            "; MS .NET Remoting; MS .NET CLR " + System.Environment.Version.ToString() + " )";
        
        // Property keys (purposely all lower-case)
        private const String UserNameKey = "username";
        private const String PasswordKey = "password";
        private const String DomainKey = "domain";
        private const String PreAuthenticateKey = "preauthenticate";
        private const String CredentialsKey = "credentials";
        private const String ClientCertificatesKey = "clientcertificates";
        private const String ProxyNameKey = "proxyname";
        private const String ProxyPortKey = "proxyport";
        private const String TimeoutKey = "timeout";
        private const String AllowAutoRedirectKey = "allowautoredirect";
        private const String UnsafeAuthenticatedConnectionSharingKey = "unsafeauthenticatedconnectionsharing";        
        private const String ConnectionGroupNameKey = "connectiongroupname";        

        // If above keys get modified be sure to modify, the KeySet property on this
        // class.
        private static ICollection s_keySet = null;

        // Property values
        private String _securityUserName = null;
        private String _securityPassword = null;
        private String _securityDomain = null;
        private bool   _bSecurityPreAuthenticate = false;
        private bool   _bUnsafeAuthenticatedConnectionSharing = false;
        private String _connectionGroupName = null;
        private ICredentials _credentials = null; // this overrides all of the other security settings
        private X509CertificateCollection _certificates = null;

        private int  _timeout = System.Threading.Timeout.Infinite; // timeout value in milliseconds (only used if greater than 0)
        private bool _bAllowAutoRedirect = false;

        // Proxy settings (_proxyObject gets recreated when _proxyName and _proxyPort are updated)
        private IWebProxy _proxyObject = null; // overrides channel proxy object if non-null
        private String    _proxyName = null;
        private int       _proxyPort = -1;

        // Other members
        private HttpClientChannel _channel; // channel that created this sink
        private String            _channelURI; // complete url to remote object        

        // settings
        private bool _useChunked = false; // FUTURE: Consider enabling chunked after implementing a method to avoid the perf hit on small requests.
        private bool _useKeepAlive = true;
        private static string s_win9xIdentity = null;

        internal HttpClientTransportSink(HttpClientChannel channel, String channelURI) : base()
        {
            _channel = channel;
        
            _channelURI = channelURI;
            
            // make sure channel uri doesn't end with a slash.
            if (_channelURI.EndsWith("/"))
                _channelURI = _channelURI.Substring(0, _channelURI.Length - 1);
                
        } // HttpClientTransportSink
        

        public void ProcessMessage(IMessage msg,
                                   ITransportHeaders requestHeaders, Stream requestStream,
                                   out ITransportHeaders responseHeaders, out Stream responseStream)
        {

            InternalRemotingServices.RemotingTrace("HttpTransportSenderSink::ProcessMessage");

            HttpWebRequest httpWebRequest = ProcessAndSend(msg, requestHeaders, requestStream);

            // receive server response
            HttpWebResponse response = null;
            try
            {
                response = (HttpWebResponse)httpWebRequest.GetResponse();
            }
            catch (WebException webException)
            {
                ProcessResponseException(webException, out response);
            }
    
            ReceiveAndProcess(response, out responseHeaders, out responseStream);
        } // ProcessMessage


        public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg,
                                        ITransportHeaders headers, Stream stream)
        {
            // Send the webrequest, headers, request stream, and retry count.
            AsyncHttpClientRequestState asyncRequestState =
                new AsyncHttpClientRequestState(this, sinkStack, msg, headers, stream, 1);
                       
            asyncRequestState.StartRequest();
        } // AsyncProcessRequest                      


        private static void ProcessResponseException(WebException webException, out HttpWebResponse response)
        {
            // if a timeout occurred throw a RemotingTimeoutException
            if (webException.Status == WebExceptionStatus.Timeout)
                throw new RemotingTimeoutException(
                    CoreChannel.GetResourceString(
                        "Remoting_Channels_RequestTimedOut"),
                    webException);
        
            response = webException.Response as HttpWebResponse;
            if ((response == null))
                throw webException;                
                
            // if server error (500-599 continue with processing the soap fault);
            //   otherwise, rethrow the exception.

            int statusCode = (int)(response.StatusCode);
            if ((statusCode < 500) || 
                (statusCode > 599))
            {
                throw webException;
            }   
        } // ProcessResponseException


        public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, Object state,
                                         ITransportHeaders headers, Stream stream)
        {
            // We don't have to implement this since we are always last in the chain.
        } // AsyncProcessRequest
        

        
        public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
        {
            // FUTURE: If we decide to support chunked encoding, we'll need to return
            //    the network stream here (probably wrapped with some sort of buffer).
            return null; 
        } // GetRequestStream


        public IClientChannelSink NextChannelSink
        {
            get { return null; }
        }
    


        private HttpWebRequest SetupWebRequest(IMessage msg, ITransportHeaders headers)
        {
            IMethodCallMessage mcMsg = msg as IMethodCallMessage;        

            String msgUri = (String)headers[CommonTransportKeys.RequestUri];
            InternalRemotingServices.RemotingTrace("HttpClientChannel::SetupWebRequest Message uri is " + msgUri);

            if (msgUri == null)
            {
                if (mcMsg != null)
                    msgUri = mcMsg.Uri;
                else
                    msgUri = (String)msg.Properties["__Uri"];
            }
            
            String fullPath;
            if (HttpChannelHelper.StartsWithHttp(msgUri) != -1)
            {
                // this is the full path
                fullPath = msgUri;
            }
            else
            {
                // this is not the full path (_channelURI never has trailing slash)
                if (!msgUri.StartsWith("/"))
                    msgUri = "/" + msgUri;
             
                fullPath = _channelURI + msgUri;                
            }
            InternalRemotingServices.RemotingTrace("HttpClientChannel::SetupWebRequest FullPath " + fullPath);

            // based on headers, initialize the network stream

            String verb = (String)headers["__RequestVerb"];
            if (verb == null)
                verb = s_defaultVerb;            

            HttpWebRequest httpWebRequest = (HttpWebRequest)WebRequest.Create(fullPath);
            httpWebRequest.AllowAutoRedirect = _bAllowAutoRedirect;
            httpWebRequest.Method = verb;
            httpWebRequest.SendChunked = _useChunked; 
            httpWebRequest.KeepAlive = _useKeepAlive;
            httpWebRequest.Pipelined = false;
            httpWebRequest.UserAgent = s_userAgent;
            httpWebRequest.Timeout = _timeout;

            // see if we should use a proxy object
            IWebProxy proxy = _proxyObject;
            if (proxy == null) // use channel proxy if one hasn't been explicity set for this sink
                proxy = _channel.ProxyObject;
            if (proxy != null)
                httpWebRequest.Proxy = proxy; 
                                            
            // see if security should be used
            //   order of applying credentials is:
            //   1. check for explicitly set credentials
            //   2. else check for explicitly set username, password, domain
            //   3. else use default credentials if channel is configured to do so.
            if (_credentials != null)
            {                            
                httpWebRequest.Credentials = _credentials;
                httpWebRequest.PreAuthenticate = _bSecurityPreAuthenticate;
                httpWebRequest.UnsafeAuthenticatedConnectionSharing = _bUnsafeAuthenticatedConnectionSharing;
                if (_connectionGroupName != null)
                    httpWebRequest.ConnectionGroupName = _connectionGroupName;
            }
            else
            if (_securityUserName != null)
            {
                if (_securityDomain == null)
                    httpWebRequest.Credentials = new NetworkCredential(_securityUserName, _securityPassword);
                else
                    httpWebRequest.Credentials = new NetworkCredential(_securityUserName, _securityPassword, _securityDomain);
                                                
                httpWebRequest.PreAuthenticate = _bSecurityPreAuthenticate;                
                httpWebRequest.UnsafeAuthenticatedConnectionSharing = _bUnsafeAuthenticatedConnectionSharing;
                if (_connectionGroupName != null)
                    httpWebRequest.ConnectionGroupName = _connectionGroupName;
                
            }
            else
            if (_channel.UseDefaultCredentials)
            {
                if (_channel.UseAuthenticatedConnectionSharing) 
                {
                    httpWebRequest.ConnectionGroupName = GetCurrentSidString();
                    httpWebRequest.UnsafeAuthenticatedConnectionSharing = true;
                }                    
                
                httpWebRequest.Credentials = CredentialCache.DefaultCredentials;
                httpWebRequest.PreAuthenticate = _bSecurityPreAuthenticate;                
            }

            if (_certificates != null)
            {
                // attach certificates to the outgoing web request
                foreach (X509Certificate certificate in _certificates)
                {
                    httpWebRequest.ClientCertificates.Add(certificate);
                }                

                httpWebRequest.PreAuthenticate = _bSecurityPreAuthenticate;
            }            

            InternalRemotingServices.RemotingTrace("HttpClientTransportSink::SetupWebRequest - Get Http Request Headers");

            // add headers
            foreach (DictionaryEntry header in headers)
            {
                String key = header.Key as String;
                
                // if header name starts with "__", it is a special value that shouldn't be
                //   actually sent out.
                if ((key != null) && !key.StartsWith("__")) 
                {
                    if (key.Equals("Content-Type"))
                        httpWebRequest.ContentType = header.Value.ToString();
                    else
                        httpWebRequest.Headers[key] = header.Value.ToString();
                }
            }

            return httpWebRequest;
        } // SetupWebRequest

        private static string GetCurrentSidString() 
        {   
            if (Environment.OSVersion.Platform != PlatformID.Win32NT) {
                if (s_win9xIdentity == null) {
                    lock(typeof(HttpClientTransportSink)) {
                        if (s_win9xIdentity == null) 
                            s_win9xIdentity = Guid.NewGuid().ToString();
                    }                    
                }   
                return s_win9xIdentity;             
            }             
            
            IntPtr tokenHandle = WindowsIdentity.GetCurrent().Token;
            int requiredLength = 0;
            bool res = NativeMethods.GetTokenInformation(tokenHandle, (int)NativeMethods.TokenInformationClass.TokenUser, IntPtr.Zero,
                                                                               0, ref requiredLength);                                                                                                   
            int lastError = Marshal.GetLastWin32Error();                                                                                 
            if (lastError != NativeMethods.BufferTooSmall)        
                throw new Win32Exception(lastError);                            
                    
            IntPtr sidPointer = Marshal.AllocHGlobal(requiredLength);
            try 
            {
                int allocatedLength = requiredLength;                 
                res = NativeMethods.GetTokenInformation(tokenHandle, (int)NativeMethods.TokenInformationClass.TokenUser, sidPointer,
                                                                            allocatedLength, ref requiredLength);                        
                if (!res)
                    throw new Win32Exception();                             
                                        
                return SidToString(Marshal.ReadIntPtr(sidPointer));                                         
            }
            finally 
            {
                Marshal.FreeHGlobal(sidPointer);
            }
        }
        
        private static string SidToString(IntPtr sidPointer) 
        {
            if (!NativeMethods.IsValidSid(sidPointer))
                throw new RemotingException(CoreChannel.GetResourceString("Remoting_InvalidSid"));
                
            StringBuilder sidString = new StringBuilder();
            IntPtr sidIdentifierAuthorityPointer = NativeMethods.GetSidIdentifierAuthority(sidPointer);            
            int lastError = Marshal.GetLastWin32Error();                                                                                 
            if (lastError != 0)        
                throw new Win32Exception(lastError);                                                           
            byte[] sidIdentifierAuthority = new byte[6];
            Marshal.Copy(sidIdentifierAuthorityPointer, sidIdentifierAuthority, 0, 6); 
            
            IntPtr subAuthorityCountPointer = NativeMethods.GetSidSubAuthorityCount(sidPointer);                    
            lastError = Marshal.GetLastWin32Error();                                                                                 
            if (lastError != 0)        
                throw new Win32Exception(lastError);                                               
            uint subAuthorityCount = (uint)Marshal.ReadByte(subAuthorityCountPointer);
                    
            if (sidIdentifierAuthority[0] != 0 && sidIdentifierAuthority[1] != 0) 
                sidString.Append(String.Format("{0:x2}{1:x2}{2:x2}{3:x2}{4:x2}{5:x2}",
                                                            sidIdentifierAuthority[0], 
                                                            sidIdentifierAuthority[1], 
                                                            sidIdentifierAuthority[2], 
                                                            sidIdentifierAuthority[3], 
                                                            sidIdentifierAuthority[4], 
                                                            sidIdentifierAuthority[5]));        
                                                                                                                        
            else 
            {
                uint number = (uint)sidIdentifierAuthority[5] +
                                    (uint)(sidIdentifierAuthority[4] << 8) +
                                    (uint)(sidIdentifierAuthority[3] << 16) +
                                    (uint)(sidIdentifierAuthority[2] << 24) ;
                
                sidString.Append(String.Format("{0:x12}", number)); 
            }            
                
            for (int index = 0; index < subAuthorityCount; ++index) 
            {
                IntPtr subAuthorityPointer = NativeMethods.GetSidSubAuthority(sidPointer, index);
                lastError = Marshal.GetLastWin32Error();                                                                                 
                if (lastError != 0)        
                    throw new Win32Exception(lastError);                                               
                    
                uint number = (uint)Marshal.ReadInt32(subAuthorityPointer);                            
                sidString.Append(String.Format("-{0:x12}", number));
            }                       
            
            return sidString.ToString();
        }    

        private HttpWebRequest ProcessAndSend(IMessage msg, ITransportHeaders headers, 
                                              Stream inputStream)
        {      
            // If the stream is seekable, we can retry once on a failure to write.
            long initialPosition = 0;
            bool bCanSeek = false;
            if (inputStream != null)
            {
                bCanSeek = inputStream.CanSeek;
                if (bCanSeek)
                    initialPosition = inputStream.Position;
            }
        
            HttpWebRequest httpWebRequest = null;
            Stream writeStream = null;
            try
            {
                httpWebRequest = SetupWebRequest(msg, headers);

                if (inputStream != null)
                {
                    if (!_useChunked)
                        httpWebRequest.ContentLength = (int)inputStream.Length;
          
                    writeStream = httpWebRequest.GetRequestStream();
                    StreamHelper.CopyStream(inputStream, writeStream);                  
                }
            }    
            catch (Exception)
            {
                // try to send one more time if possible
                if (bCanSeek)
                {
                    httpWebRequest = SetupWebRequest(msg, headers);

                    if (inputStream != null)
                    {
                        inputStream.Position = initialPosition;
                    
                        if (!_useChunked)
                            httpWebRequest.ContentLength = (int)inputStream.Length;
          
                        writeStream = httpWebRequest.GetRequestStream();
                        StreamHelper.CopyStream(inputStream, writeStream);                  
                    }                
                } // end of "try to send one more time"
            }

            if (inputStream != null)
                inputStream.Close();                

            if (writeStream != null)
                writeStream.Close(); 

            return httpWebRequest;
        } // ProcessAndSend


        private void ReceiveAndProcess(HttpWebResponse response, 
                                       out ITransportHeaders returnHeaders,
                                       out Stream returnStream)
        {
            //
            // Read Response Message

            // Just hand back the network stream
            //   (NOTE: The channel sinks are responsible for calling Close() on a stream
            //    once they are done with it).
            returnStream = new BufferedStream(response.GetResponseStream(), 1024);  

            // collect headers
            returnHeaders = CollectResponseHeaders(response);
        } // ReceiveAndProcess

        private static ITransportHeaders CollectResponseHeaders(HttpWebResponse response)
        {
            TransportHeaders responseHeaders = new TransportHeaders();
            foreach (Object key in response.Headers)
            {
                String keyString = key.ToString();
                responseHeaders[keyString] = response.Headers[keyString];
            }

            return responseHeaders;
        } // CollectResponseHeaders



        //
        // Support for properties (through BaseChannelSinkWithProperties)
        //

        public override Object this[Object key]
        {
            get
            {
                String keyStr = key as String;
                if (keyStr == null)
                    return null;
            
                switch (keyStr.ToLower(CultureInfo.InvariantCulture))
                {
                case UserNameKey: return _securityUserName; 
                case PasswordKey: return null; // Intentionally refuse to return password.
                case DomainKey: return _securityDomain;
                case PreAuthenticateKey: return _bSecurityPreAuthenticate; 
                case CredentialsKey: return _credentials;
                case ClientCertificatesKey: return null; // Intentionally refuse to return certificates
                case ProxyNameKey: return _proxyName; 
                case ProxyPortKey: return _proxyPort; 
                case TimeoutKey: return _timeout;
                case AllowAutoRedirectKey: return _bAllowAutoRedirect;
                case UnsafeAuthenticatedConnectionSharingKey: return _bUnsafeAuthenticatedConnectionSharing;                
                case ConnectionGroupNameKey: return _connectionGroupName;                  
                } // switch (keyStr.ToLower(CultureInfo.InvariantCulture))

                return null; 
            }
        
            set
            {
                String keyStr = key as String;
                if (keyStr == null)
                    return;
    
                switch (keyStr.ToLower(CultureInfo.InvariantCulture))
                {
                case UserNameKey: _securityUserName = (String)value; break;
                case PasswordKey: _securityPassword = (String)value; break;    
                case DomainKey: _securityDomain = (String)value; break;                
                case PreAuthenticateKey: _bSecurityPreAuthenticate = Convert.ToBoolean(value); break;
                case CredentialsKey: _credentials = (ICredentials)value; break;
                case ClientCertificatesKey: _certificates = (X509CertificateCollection)value; break;
                case ProxyNameKey: _proxyName = (String)value; UpdateProxy(); break;
                case ProxyPortKey: _proxyPort = Convert.ToInt32(value); UpdateProxy(); break;

                case TimeoutKey: 
                {
                    if (value is TimeSpan)
                        _timeout = (int)((TimeSpan)value).TotalMilliseconds;
                    else
                        _timeout = Convert.ToInt32(value); 
                    break;
                } // case TimeoutKey

                case AllowAutoRedirectKey: _bAllowAutoRedirect = Convert.ToBoolean(value); break;                
                case UnsafeAuthenticatedConnectionSharingKey: _bUnsafeAuthenticatedConnectionSharing = Convert.ToBoolean(value); break;                
                case ConnectionGroupNameKey: _connectionGroupName = (String)value; break;  
                
                } // switch (keyStr.ToLower(CultureInfo.InvariantCulturey))
            }
        } // this[]   
        

        public override ICollection Keys
        {
            get
            {
                if (s_keySet == null)
                {
                    // Don't need to synchronize. Doesn't matter if the list gets
                    // generated twice.
                    ArrayList keys = new ArrayList(6);
                    keys.Add(UserNameKey);
                    keys.Add(PasswordKey);
                    keys.Add(DomainKey);
                    keys.Add(PreAuthenticateKey);
                    keys.Add(CredentialsKey);
                    keys.Add(ClientCertificatesKey);
                    keys.Add(ProxyNameKey);
                    keys.Add(ProxyPortKey);
                    keys.Add(TimeoutKey);
                    keys.Add(AllowAutoRedirectKey);                            
                    keys.Add(UnsafeAuthenticatedConnectionSharingKey);
                    keys.Add(ConnectionGroupNameKey);
                    
                    s_keySet = keys;
                }

                return s_keySet;
            }
        } // Keys


        //
        // end of Support for properties
        //


        //
        // Helper functions for processing settings and properties
        //

        // Called to recreate proxy object whenever the proxy name or port is changed.
        private void UpdateProxy()
        {
            if ((_proxyName != null) && (_proxyPort > 0))
            {
                WebProxy proxy = new WebProxy(_proxyName, _proxyPort);
                
                // disable proxy use when the host is local. i.e. without periods
                proxy.BypassProxyOnLocal = true;

                _proxyObject = proxy;
            }
        } // UpdateProxy

        //
        // end of Helper functions for processing settings and properties
        //


        internal static String UserAgent
        {
            get { return s_userAgent; }
        }       
        

        // Used for maintaining async request state
        private class AsyncHttpClientRequestState
        {
            private static AsyncCallback s_processGetRequestStreamCompletionCallback = new AsyncCallback(ProcessGetRequestStreamCompletion);
            private static AsyncCallback s_processAsyncCopyRequestStreamCompletionCallback = new AsyncCallback(ProcessAsyncCopyRequestStreamCompletion);
            private static AsyncCallback s_processGetResponseCompletionCallback = new AsyncCallback(ProcessGetResponseCompletion);
            private static AsyncCallback s_processAsyncCopyRequestStreamCompletion = new AsyncCallback(ProcessAsyncCopyResponseStreamCompletion);

            
            internal HttpWebRequest WebRequest;
            internal HttpWebResponse WebResponse;
            internal IClientChannelSinkStack SinkStack;            
            internal Stream RequestStream;
            internal Stream ActualResponseStream; // stream that will be passed to channel sinks

            private HttpClientTransportSink _transportSink;
            private int _retryCount;
            private long _initialStreamPosition;
            private IMessage _msg;
            private ITransportHeaders _requestHeaders;

            internal AsyncHttpClientRequestState(
                HttpClientTransportSink transportSink,
                IClientChannelSinkStack sinkStack,
                IMessage msg, 
                ITransportHeaders headers, 
                Stream stream,
                int retryCount)
            {
                _transportSink = transportSink;
                SinkStack = sinkStack;
                _msg = msg;
                _requestHeaders = headers;
                RequestStream = stream;
                _retryCount = retryCount;

                if (RequestStream.CanSeek)
                    _initialStreamPosition = RequestStream.Position;
            } // AsyncHttpClientRequestState

            internal void StartRequest()
            {
                WebRequest = _transportSink.SetupWebRequest(_msg, _requestHeaders);
                if (!_transportSink._useChunked)
                {
                    try
                    {
                        WebRequest.ContentLength = (int)RequestStream.Length;
                    }
                    catch
                    {
                        // swallow exception if RequestStream.Length throws; just
                        // means that WebRequest will have to buffer the stream.
                    }
                }
            
                // Chain of methods called is as follows:
                //  1. StartRequest (this one)
                //  2. ProcessGetRequestStreamCompletion
                //  3. ProcessAsyncCopyRequestStreamCompletion
                //  2. ProcessGetResponseCompletion
                //  3. ProcessAsyncCopyResponseStreamCompletion
            
                WebRequest.BeginGetRequestStream(s_processGetRequestStreamCompletionCallback, this);    
            } // StartRequest

            // This should only be done when the send fails.
            internal void RetryOrDispatchException(Exception e)
            {
                bool bRetry = false;
                try
                {
                    if (_retryCount > 0)
                    {
                        _retryCount--;
    
                        if (RequestStream.CanSeek)
                        {
                            RequestStream.Position = _initialStreamPosition;   

                            StartRequest();
                            bRetry = true;
                        }
                    }
                }
                catch
                {
                }

                if (!bRetry)
                {
                    RequestStream.Close();
                    SinkStack.DispatchException(e);
                }
            } // DispatchExceptionOrRetry


            // called from StartRequest
            private static void ProcessGetRequestStreamCompletion(IAsyncResult iar)
            {        
                // We've just received a request stream.
            
                AsyncHttpClientRequestState asyncRequestState = (AsyncHttpClientRequestState)iar.AsyncState;

                try
                {
                    HttpWebRequest httpWebRequest = asyncRequestState.WebRequest;
                    Stream sourceRequestStream = asyncRequestState.RequestStream;

                    Stream webRequestStream = httpWebRequest.EndGetRequestStream(iar);

                    StreamHelper.BeginAsyncCopyStream(
                        sourceRequestStream, webRequestStream,
                        false, true, // sync read, async write
                        false, true, // leave source open, close target
                        s_processAsyncCopyRequestStreamCompletionCallback, 
                        asyncRequestState);                    
                }
                catch (Exception e)
                {
                    asyncRequestState.RetryOrDispatchException(e);
                }
            } // ProcessGetRequestStreamCompletion


            // called from ProcessGetRequestStreamCompletion
            private static void ProcessAsyncCopyRequestStreamCompletion(IAsyncResult iar)
            {       
                // We've just finished copying the original request stream into the network stream.
            
                AsyncHttpClientRequestState asyncRequestState = (AsyncHttpClientRequestState)iar.AsyncState;

                try            
                {
                    StreamHelper.EndAsyncCopyStream(iar);   
                               
                    asyncRequestState.WebRequest.BeginGetResponse(
                        s_processGetResponseCompletionCallback, asyncRequestState);         
                }
                catch (Exception e)
                {
                    // This is the last point where we should retry.
                    asyncRequestState.RetryOrDispatchException(e);
                }
            } // ProcessAsyncCopyRequestStreamCompletion


            // called from ProcessAsyncCopyRequestStreamCompletion
            private static void ProcessGetResponseCompletion(IAsyncResult iar)
            {       
                // We've just received a response.
            
                AsyncHttpClientRequestState asyncRequestState = (AsyncHttpClientRequestState)iar.AsyncState;
        
                try
                {
                    // close the request stream since we are done with it.
                    asyncRequestState.RequestStream.Close();

                    HttpWebResponse httpWebResponse = null;
                    HttpWebRequest httpWebRequest = asyncRequestState.WebRequest;
                    try
                    {
                        httpWebResponse = (HttpWebResponse)httpWebRequest.EndGetResponse(iar);        
                    }
                    catch (WebException webException)
                    {
                        ProcessResponseException(webException, out httpWebResponse);
                    }

                    asyncRequestState.WebResponse = httpWebResponse;

                    // Asynchronously pump the web response stream into a memory stream.
                    ChunkedMemoryStream responseStream = new ChunkedMemoryStream(CoreChannel.BufferPool);
                    asyncRequestState.ActualResponseStream = responseStream;

                    StreamHelper.BeginAsyncCopyStream(
                        httpWebResponse.GetResponseStream(), responseStream, 
                        true, false, // async read, sync write
                        true, false, // close source, leave target open
                        s_processAsyncCopyRequestStreamCompletion,
                        asyncRequestState);
                }
                catch (Exception e)
                {
                    asyncRequestState.SinkStack.DispatchException(e);
                }
            } // ProcessGetResponseCompletion


            // called from ProcessGetResponseCompletion
            private static void ProcessAsyncCopyResponseStreamCompletion(IAsyncResult iar)
            {
                // We've just finished copying the network response stream into a memory stream.
            
                AsyncHttpClientRequestState asyncRequestState = (AsyncHttpClientRequestState)iar.AsyncState;         

                try
                {
                    StreamHelper.EndAsyncCopyStream(iar);

                    HttpWebResponse webResponse = asyncRequestState.WebResponse;
                    Stream responseStream = asyncRequestState.ActualResponseStream;

                    ITransportHeaders responseHeaders = CollectResponseHeaders(webResponse);
        
                    // call down the sink chain
                    asyncRequestState.SinkStack.AsyncProcessResponse(responseHeaders, responseStream);
                }
                catch (Exception e)
                {
                    asyncRequestState.SinkStack.DispatchException(e);
                }
            } // ProcessAsyncResponseStreamCompletion

        
        } // class AsyncHttpClientRequest

                
    } // class HttpClientTransportSink




} // namespace System.Runtime.Remoting.Channels.Http
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\smtp\cdo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    CDO.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Defines the managed versions of classic COM interfaces 
**          that is used to communicate with CDO (Collaboration Data Objects)
**          
**          
**
** Date:    June 26, 2000
**
===========================================================*/
using System;
using System.Runtime.InteropServices;

namespace System.Runtime.Remoting.Channels.Smtp
{
    //[helpstring("Passed to Smtp-NNTP transport event sinks through corresponding event methods and used by sinks to indicate to the event source whether or not they have consumed the event.")] 
    /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoEventStatus"]/*' />
	[Serializable]
    public enum CdoEventStatus
    {
        //[helpstring("Proceed to run the next sink.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoEventStatus.cdoRunNextSink"]/*' />
        cdoRunNextSink  = 0,
        
        //[helpstring("Do not notify (skip) any remaining sinks for the event (i.e. this sink has consumed the event).")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoEventStatus.cdoSkipRemainingSinks"]/*' />
        cdoSkipRemainingSinks  = 1    
    }
    
    // [helpstring("Used to set or examine the IMessage.DSNOptions property, the value of which identifies the condition(s) under which Delivery Status Notifications (DSNs) are to be sent.")] 
    /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions"]/*' />
	[Serializable]
    public enum CdoDSNOptions
    {
        //[helpstring("No DSN commands are issued.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNDefault"]/*' />
        CdoDSNDefault  = 0,
        
        //[helpstring("No DSNs are issued.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNNever"]/*' />
        CdoDSNNever  = 1,
        
        //[helpstring("Return an DSN if delivery fails.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNFailure"]/*' />
        CdoDSNFailure  = 2,
        
        //[helpstring("Return a DSN if delivery succeeds.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNSuccess"]/*' />
        CdoDSNSuccess  = 4,
        
        //[helpstring("Return a DSN if delivery is delayed.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNDelay"]/*' />
        CdoDSNDelay  = 8,
        
        //[helpstring("Return a DSN if delivery succeeds, fails, or is delayed.")] 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="CdoDSNOptions.cdoDSNSuccessFailOrDelay"]/*' />
        CdoDSNSuccessFailOrDelay  = 14
     };

    /*
    *   [ object, uuid(CD000026-8B95-11D1-82DB-00C04FB1625D), dual, nonextensible, helpstring("The interface to implement when creating Smtp OnArrival event sinks"), helpcontext(0x00000200), pointer_default(unique) ] interface ISmtpOnArrival : IDispatch
    */
    /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpOnArrival"]/*' />
    [     
     ComImport,
     Guid("CD000026-8B95-11D1-82DB-00C04FB1625D"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
    ]
    public interface ISmtpOnArrival
    {
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpOnArrival.OnArrival"]/*' />
        // [ id( 256 ), helpstring ( "Called by the Smtp event source when a message arrives" ), helpcontext( 0x00000201 ) ] 
        // HRESULT OnArrival([In] IMessage *Msg, [In,Out]CdoEventStatus *EventStatus);
        void OnArrival(ISmtpMessage Msg,
                       [In, Out] ref CdoEventStatus EventStatus);
    }

        [ object, uuid(CD000020-8B95-11D1-82DB-00C04FB1625D), dual, nonextensible, helpstring("Defines abstract methods and properties used to manage a complete message"), helpcontext(0x00000110), pointer_default(unique) ] interface IMessage : IDispatch
    /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage"]/*' />
    [     
     ComImport,
     Guid("CD000020-8B95-11D1-82DB-00C04FB1625D"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
    ]
    public interface ISmtpMessage
    {
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.BCC"]/*' />
        // [ id( 101 ), propget, helpstring( "The intended blind carbon copy (BCC header) recipients" ), helpcontext(0x00000111) ] 
        // HRESULT BCC ([Out,retval] BSTR* pBCC); 
        //
        // [ id( 101 ), propput, helpstring( "The intended blind carbon copy (BCC header) recipients" ), helpcontext(0x00000111) ] 
        // HRESULT BCC ([In] BSTR varBCC);
         String BCC 
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.CC"]/*' />
           
         // [ id( 103 ), propget, helpstring( "The intended secondary (carbon copy) recipients" ), helpcontext(0x00000112) ] 
         // HRESULT CC ([Out,retval] BSTR* pCC); 
         // [ id( 103 ), propput, helpstring( "The intended secondary (carbon copy) recipients" ), helpcontext(0x00000112) ] 
         // HRESULT CC ([In] BSTR varCC);         
         String CC
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }          
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.FollowUpTo"]/*' />
         
        // [ id( 105 ), propget, helpstring( "The recipient to which follow up messages should be sent" ), helpcontext(0x00000113) ] 
        // HRESULT FollowUpTo ([Out,retval] BSTR* pFollowUpTo); 
        // [ id( 105 ), propput, helpstring( "The recipient to which follow up messages should be sent" ), helpcontext(0x00000113) ] 
        // HRESULT FollowUpTo ([In] BSTR varFollowUpTo);                  
         String FollowUpTo
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }  
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.From"]/*' />
                
         // [ id( 106 ), propget, helpstring( "The principle recipients from which the message is sent" ), helpcontext(0x00000114) ] 
         // HRESULT From ([Out,retval] BSTR* pFrom); 
         // [ id( 106 ), propput, helpstring( "The principle recipients from which the message is sent" ), helpcontext(0x00000114) ] 
         // HRESULT From ([In] BSTR varFrom);         
         String From
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }            
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Keywords"]/*' />
         
        // [ id( 107 ), propget, helpstring( "The keywords for the message" ), helpcontext(0x00000115) ] 
        // HRESULT Keywords ([Out,retval] BSTR* pKeywords); 
        // [ id( 107 ), propput, helpstring( "The keywords for the message" ), helpcontext(0x00000115) ]
        // HRESULT Keywords ([In] BSTR varKeywords);
         String Keywords
         {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
         }            
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.MimeFormatted"]/*' />
         
        // [ id( 110 ), propget, helpstring( "Specifies whether or not the message is to be formatted using MIME (True) or UUEncode (False)" ), helpcontext(0x00000116) ] 
        // HRESULT MimeFormatted ([Out,retval] VARIANT_BOOL* pMimeFormatted); 
        // [ id( 110 ), propput, helpstring( "Specifies whether or not the message is to be formatted using MIME (True) or UUEncode (False)" ), helpcontext(0x00000116) ] 
        // HRESULT MimeFormatted ([In] VARIANT_BOOL varMimeFormatted);
        //
         bool MimeFormatted
         {
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
            [param : MarshalAs(UnmanagedType.VariantBool)]
            set;
         }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Newsgroups"]/*' />
        //[ id( 111 ), propget, helpstring( "The names of newsgroups (NewsGroups header) to which the message is to be posted" ), helpcontext(0x00000117) ] HRESULT Newsgroups ([Out,retval] BSTR* pNewsgroups); 
        //[ id( 111 ), propput, helpstring( "The names of newsgroups (NewsGroups header) to which the message is to be posted" ), helpcontext(0x00000117) ] HRESULT Newsgroups ([In] BSTR varNewsgroups);
        String Newsgroups
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Organization"]/*' />
        //[ id( 112 ), propget, helpstring( "The organization of the sender" ), helpcontext(0x00000118) ] HRESULT Organization ([Out,retval] BSTR* pOrganization); 
        //[ id( 112 ), propput, helpstring( "The organization of the sender" ), helpcontext(0x00000118) ] HRESULT Organization ([In] BSTR varOrganization);
        String Organization
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.ReceivedTime"]/*' />
        
        //[ id( 114 ), propget, helpstring( "Returns the time the message was received" ), helpcontext( 0x00000119 ), readonly ] 
        // HRESULT ReceivedTime ([Out,retval] DATE* varReceivedTime);
        Object ReceivedTime
        {
            get;
        } 
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.ReplyTo"]/*' />
        
        //[ id( 115 ), propget, helpstring( "The addresses (Reply-To header) to which to reply" ), helpcontext(0x0000011a) ] HRESULT ReplyTo ([Out,retval] BSTR* pReplyTo); 
        //[ id( 115 ), propput, helpstring( "The addresses (Reply-To header) to which to reply" ), helpcontext(0x0000011a) ] HRESULT ReplyTo ([In] BSTR varReplyTo);
        String ReplyTo
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.DSNOptions"]/*' />
        
        // [ id( 116 ), propget, helpstring( "The delivery status notification options for the message" ), helpcontext(0x0000011b) ]
        // HRESULT DSNOptions ([Out,retval] CdoDSNOptions* pDSNOptions); 
        // [ id( 116 ), propput, helpstring( "The delivery status notification options for the message" ), helpcontext(0x0000011b) ] 
        // HRESULT DSNOptions ([In] CdoDSNOptions varDSNOptions);
        CdoDSNOptions DSNOptions
        {
            get;
            set;
        }            
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.SentOn"]/*' />
        
        // [ id( 119 ), propget, helpstring( "The date on which the message was sent" ), helpcontext( 0x0000011c ), readonly ] HRESULT SentOn ([Out,retval] DATE* varSentOn);
        Object SentOn
        {
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Subject"]/*' />
        
        // [ id( 120 ), propget, helpstring( "The subject (Subject header) of the message" ), helpcontext(0x0000011d) ] HRESULT Subject ([Out,retval] BSTR* pSubject); 
        // [ id( 120 ), propput, helpstring( "The subject (Subject header) of the message" ), helpcontext(0x0000011d) ] HRESULT Subject ([In] BSTR varSubject);
        String Subject
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.To"]/*' />
        
        // [ id( 121 ), propget, helpstring( "The principle (To header) recipients of the message" ), helpcontext(0x0000011e) ] HRESULT To ([Out,retval] BSTR* pTo); 
        // [ id( 121 ), propput, helpstring( "The principle (To header) recipients of the message" ), helpcontext(0x0000011e) ] HRESULT To ([In] BSTR varTo);
        String To
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.TextBody"]/*' />
        
        // [ id( 123 ), propget, helpstring( "The text/plain portion of the message body" ), helpcontext(0x0000011f) ] HRESULT TextBody ([Out,retval] BSTR* pTextBody); 
        // [ id( 123 ), propput, helpstring( "The text/plain portion of the message body" ), helpcontext(0x0000011f) ] HRESULT TextBody ([In] BSTR varTextBody);
        String TextBody
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.HTMLBody"]/*' />
        
        // [ id( 124 ), propget, helpstring( "The text/html portion of the message body" ), helpcontext(0x00000120) ] HRESULT HTMLBody ([Out,retval] BSTR* pHTMLBody); 
        // [ id( 124 ), propput, helpstring( "The text/html portion of the message body" ), helpcontext(0x00000120) ] HRESULT HTMLBody ([In] BSTR varHTMLBody);
        String HTMLBody
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Attachments"]/*' />

        // [ id( 125 ), propget, helpstring( "Returns the message's Attachments collection" ), helpcontext( 0x00000121 ), readonly ] 
        // HRESULT Attachments ([Out,retval] IBodyParts ** varAttachments);
        Object Attachments
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Sender"]/*' />

        // [ id( 126 ), propget, helpstring( "The sender of the message" ), helpcontext(0x00000122) ] HRESULT Sender ([Out,retval] BSTR* pSender); 
        // [ id( 126 ), propput, helpstring( "The sender of the message" ), helpcontext(0x00000122) ] HRESULT Sender ([In] BSTR varSender);
        String Sender
        {
            [return : MarshalAs(UnmanagedType.BStr)]
            get;
            [param : MarshalAs(UnmanagedType.BStr)]
            set;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Configuration"]/*' />
            
        // [ id( 127 ), propget, helpstring( "The object's associated Configuration object" ), helpcontext( 0x00000123) ] HRESULT Configuration ([Out,retval] IConfiguration ** pConfiguration); [ id( 127 ), propput, helpstring( "The object's associated Configuration object" ), helpcontext( 0x00000123 ) ] HRESULT Configuration ([In] IConfiguration * varConfiguration); 
        // [ id( 127 ), propputref, helpstring( "The object's associated Configuration object" ), helpcontext( 0x00000123 ) ] HRESULT Configuration ([In] IConfiguration * varConfiguration);
        Object Configuration
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
            [param : MarshalAs(UnmanagedType.Interface)]
            set;        
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.let_Configuration"]/*' />
        
        // NOTE: Dummy method to mimic let_Configuration
        Object let_Configuration(Object obj);
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.AutoGenerateTextBody"]/*' />
        
            
        // [ id( 128 ), propget, helpstring( "Specifies whether a text/plain alternate representation should automatically be generated from the text/html part of the message body" ), helpcontext(0x00000124) ] HRESULT AutoGenerateTextBody ([Out,retval] VARIANT_BOOL* pAutoGenerateTextBody); 
        // [ id( 128 ), propput, helpstring( "Specifies whether a text/plain alternate representation should automatically be generated from the text/html part of the message body" ), helpcontext(0x00000124) ] HRESULT AutoGenerateTextBody ([In] VARIANT_BOOL varAutoGenerateTextBody);
        bool AutoGenerateTextBody
        {
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
            [param : MarshalAs(UnmanagedType.VariantBool)]
            set;
        }            
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.EnvelopeFields"]/*' />

        // [ id( 129 ), propget, helpstring( "Returns the transport envelope Fields collection for the message (transport event sinks only) " ), helpcontext( 0x00000125 ), readonly ] HRESULT EnvelopeFields ([out,retval] Fields ** varEnvelopeFields);
        Smtp.Fields EnvelopeFields
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.TextBodyPart"]/*' />
            
        // [ id( 130 ), propget, helpstring( "Returns the BodyPart object (IBodyPart interface) containing the text/plain part of the message body" ), helpcontext( 0x00000126 ), readonly ] HRESULT TextBodyPart ([Out,retval] IBodyPart ** varTextBodyPart);
        Object TextBodyPart
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.HTMLBodyPart"]/*' />

        // [ id( 131 ), propget, helpstring( "Returns the BodyPart object (IBodyPart interface) containing the text/html portion of the message body" ), helpcontext( 0x00000127 ), readonly ] HRESULT HTMLBodyPart ([Out,retval] IBodyPart ** varHTMLBodyPart);
        Object HTMLBodyPart
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.BodyPart"]/*' />
            
        // [ id( 132 ), propget, helpstring( "Returns the IBodyPart interface on the object" ), helpcontext( 0x00000128 ), readonly ] HRESULT BodyPart ([Out,retval] IBodyPart ** varBodyPart);
        Object BodyPart
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.DataSource"]/*' />

        // [ id( 133 ), propget, helpstring( "Returns the IDataSource interface on the object" ), helpcontext( 0x00000129 ), readonly ] HRESULT DataSource ([Out,retval] IDataSource ** varDataSource);
        Object DataSource
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Fields"]/*' />
        
        // [ id( 134 ), propget, helpstring( "Returns the Fields collection for the message" ), helpcontext( 0x0000012a ), readonly ] HRESULT Fields ([out,retval] Fields ** varFields);
        Smtp.Fields Fields
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.MDNRequested"]/*' />
        
        // [ id( 135 ), propget, helpstring( "Specifies whether or not mail delivery notifications should be sent when the message is received" ), helpcontext(0x0000012b) ] HRESULT MDNRequested ([Out,retval] VARIANT_BOOL* pMDNRequested); [ id( 135 ), propput, helpstring( "Specifies whether or not mail delivery notifications should be sent when the message is received" ), helpcontext(0x0000012b) ] HRESULT MDNRequested ([In] VARIANT_BOOL varMDNRequested);
        bool MDNRequested
        {
            [return : MarshalAs(UnmanagedType.VariantBool)]
            get;
            [param : MarshalAs(UnmanagedType.VariantBool)]
            set;
       }         
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.AddRelatedBodyPart"]/*' />
            
       // [ id( 150 ), helpstring ( "Adds a BodyPart object with content referenced within the text/html portion of the message body" ), helpcontext( 0x0000012c ) ] HRESULT AddRelatedBodyPart(
       //               [In]            BSTR URL, 
       //               [In]            BSTR Reference,
       //               [In]            CdoReferenceType ReferenceType,
       //               [In, optional]  BSTR UserName,
       //               [In, optional]  BSTR Password,
       //               [Out,retval]    IBodyPart **ppBody);
        Object AddRelatedBodyPart();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.AddAttachment"]/*' />
                                
       // [ id( 151 ), helpstring ( "Adds an attachment (BodyPart) to the message" ), helpcontext( 0x0000012d ) ] HRESULT AddAttachment(
       //               [In]            BSTR URL,
       //               [In, optional]  BSTR UserName,
       //               [In, optional]  BSTR Password,
       //               [Out,retval]    IBodyPart **ppBody);
        Object AddAttachment();                        
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.CreateMHTMLBody"]/*' />
                    
       // [ id( 152 ), helpstring ( "Creates an MHTML-formatted message body using the contents at the specified URL" ), helpcontext( 0x0000012e ) ] HRESULT CreateMHTMLBody(
       //            [In]                   BSTR URL, 
       //            [In, defaultvalue(cdoSuppressNone)]    CdoMHTMLFlags Flags,
       //            [In, optional] BSTR UserName,
       //            [In, optional] BSTR Password);
        void CreateMHTMLBody();                           
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Forward"]/*' />
                        
       // [ id( 153 ), helpstring ( "Returns a Message object that can be used to forward the message" ), helpcontext( 0x0000012f ) ] HRESULT Forward(
       //            [Out,retval]   IMessage **ppMsg);
        void Forward();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Post"]/*' />
        
            
       // [ id( 154 ), helpstring ( "Post the message using the method specified in the associated Configuration object" ), helpcontext( 0x00000130 ) ] HRESULT Post();
        void Post();            
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.PostReply"]/*' />
        
       // [ id( 155 ), helpstring ( "Returns a Message object that can be used to post a reply to the message" ), helpcontext( 0x00000131 ) ] HRESULT PostReply(
       //               [Out,retval]    IMessage **ppMsg);
        void PostReply();                        
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Reply"]/*' />
                        
        //   [ id( 156 ), helpstring ( "Returns a Message object that can be used to reply to the message" ), helpcontext( 0x00000132 ) ] HRESULT Reply(
                    [Out,retval]    IMessage//*ppMsg);
         Object Reply();
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.ReplyAll"]/*' />
                        
        // [ id( 157 ), helpstring ( "Returns a Message object that can be used to post a reply to all recipients of the message" ), helpcontext( 0x00000133 ) ] HRESULT ReplyAll(
        //              [Out,retval] IMessage **ppMsg);
         Object ReplyAll();
         /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.Send"]/*' />
                        
        //[ id( 158 ), helpstring ( "Send the message using the method specified in the associated Configuration object" ), helpcontext( 0x00000136 ) ] HRESULT Send();
         void Send();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.GetStream"]/*' />
        
       // [ id( 159 ), helpstring ( "Returns a Stream object containing the message in serialized format" ), helpcontext( 0x00000134 ) ] HRESULT GetStream(
       //               [Out,retval] _Stream **ppStream);
        Object GetStream();
        /// <include file='doc\CDO.uex' path='docs/doc[@for="ISmtpMessage.GetInterface"]/*' />
        
        // [ id( 160 ), helpstring ( "Returns the specified interface on the object" ), helpcontext( 0x00000135 ) ] HRESULT GetInterface(
        //           [In] BSTR Interface,
        //           [Out, retval] IDispatch** ppUnknown);
        Object GetInterface();       
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\smtp\adodb.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    ADODB.cs
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements ADODB interfaces that are used by Smtp to
**          deliver mail messages.
**          
**
** Date:    October 12, 2000
**
===========================================================*/

using System.Runtime.InteropServices;
using System.Reflection;
using System.Collections;

namespace System.Runtime.Remoting.Channels.Smtp
{
    /*
        [
          uuid(00000569-0000-0010-8000-00AA006D2EA4),
          helpcontext(0x0012c908),
          dual,
          nonextensible
        ]
     */
    /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field"]/*' />
    [     
     ComImport,
     Guid("00000569-0000-0010-8000-00AA006D2EA4"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
    ]
    public interface Field
    {
        
        /*
            [id(0x000001f4), propget, helpcontext(0x0012c900)]
            Properties* Properties();
         */
        
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Properties"]/*' />
        Object Properties
        {
            get;
        }

        /*
            [id(0x00000455), propget, helpcontext(0x0012c90c)]
            long ActualSize();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.ActualSize"]/*' />
        long ActualSize
        {
            get;
        }
        
        /*
            [id(0x0000045a), propget, helpcontext(0x0012c90d)]
            long Attributes();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Attributes_One"]/*' />
        long Attributes_One
        {
            get;
        }

        /*
            [id(0x0000044f), propget, helpcontext(0x0012c91e)]
            long DefinedSize();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DefinedSize_One"]/*' />
        long DefinedSize_One
        {
            get;
        }

        /*
            [id(0x0000044c), propget, helpcontext(0x0012c92f)]
            BSTR Name();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Name"]/*' />
        String Name
        {
            get;
        }

        /*
            [id(0x0000044e), propget, helpcontext(0x0012c94a)]
            DataTypeEnum Type();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Type_One"]/*' />
        Object Type_One
        {
            get;
        }
        
        /*
            [id(00000000), propget, helpcontext(0x0012c94d)]
            VARIANT Value();
         */
        /*
            [id(00000000), propput, helpcontext(0x0012c94d)]
            void Value([in] VARIANT rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Value"]/*' />
        Object Value
        {
            get;

            set;
        }

        /*
            [id(0x00000458), propget, helpcontext(0x0012c938)]
            unsigned char Precision();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Precision_One"]/*' />
        char Precision_One
        {
            get;
        }

        /*
            [id(0x00000459), propget, helpcontext(0x0012c932)]
            unsigned char NumericScale();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.NumericScale_One"]/*' />
        char NumericScale_One
        {
            get;
        }

        /*
            [id(0x00000453), helpcontext(0x0012c8b6)]
            void AppendChunk([in] VARIANT Data);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.AppendChunk"]/*' />
        void AppendChunk(Object o);

        /*
            [id(0x00000454), helpcontext(0x0012c8ce)]
            VARIANT GetChunk([in] long Length);
        */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.GetChunk"]/*' />
        Object GetChunk(long length);

        /*
            [id(0x00000450), propget, helpcontext(0x0012c934)]
            VARIANT OriginalValue();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.OriginalValue"]/*' />
        Object OriginalValue
        {
            get;
        }

        /*
            [id(0x00000451), propget, helpcontext(0x0012c94b)]
            VARIANT UnderlyingValue();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.UnderlyingValue"]/*' />
        Object UnderlyingValue
        {
            get;
        }

        /*
            [id(0x0000045b), propget]
            IUnknown* DataFormat();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DataFormat_One"]/*' />
        Object DataFormat_One();

        /*
            [id(0x0000045b), propputref]
            void DataFormat([in] IUnknown* rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DataFormat_Two"]/*' />
        Object DataFormat_Two
        {
            set;
        }

        /*
            [id(0x00000458), propput, helpcontext(0x0012c938)]
            void Precision([in] unsigned char rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Precision_Two"]/*' />
        char Precision_Two
        {
            set;
        }

        /*
            [id(0x00000459), propput, helpcontext(0x0012c932)]
            void NumericScale([in] unsigned char rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.NumericScale_Two"]/*' />
        char NumericScale_Two
        {
            set;
        }
        
        /*
            [id(0x0000044e), propput, helpcontext(0x0012c94a)]
            void Type([in] DataTypeEnum rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Type_Two"]/*' />
        Object Type_Two
        {
            set;
        }

        /*
            [id(0x0000044f), propput, helpcontext(0x0012c91e)]
            void DefinedSize([in] long rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.DefinedSize_Two"]/*' />
        long DefinedSize_Two
        {
            set;
        }

        /*
            [id(0x0000045a), propput, helpcontext(0x0012c90d)]
            void Attributes([in] long rhs);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Attributes_Two"]/*' />
        long Attributes_Two
        {
            set;
        }

        /*
            [id(0x0000045c), propget, helpcontext(0x0012c90e)]
            long Status();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Field.Status"]/*' />
        long Status
        {
            get;
        }
     }


    /*
        [
            uuid(00000564-0000-0010-8000-00AA006D2EA4),
            helpcontext(0x0012c8fe),
            dual,
            nonextensible
        ]
    */
    /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields"]/*' />
    [     
     ComImport,
     Guid("00000564-0000-0010-8000-00AA006D2EA4"),
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)
     //DefaultMemberAttribute("Item")
    ]
    public interface Fields
    {

       /*
            [id(0x00000001), propget, helpcontext(0x0012c91a)]
            long Count();
        */        
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Count"]/*' />
        long Count
        {
            get;
        }
        
        /*
            [id(0xfffffffc), restricted]
            IUnknown* _NewEnum();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.GetEnumerator"]/*' />
        IEnumerator GetEnumerator();
        
        /*
            [id(0x00000002), helpcontext(0x0012c8da)]
            void Refresh();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Refresh"]/*' />
        void Refresh();

        /*  
            [id(00000000), propget, helpcontext(0x0012c8d1)]
            Field* Item([in] VARIANT Index);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.this"]/*' />
        Field this[Object key]
        {
            [return : MarshalAs(UnmanagedType.Interface)]
            get;
        }

        /*
            [id(0x60040000), hidden]
            void _Append(
                        [in] BSTR Name, 
                        [in] DataTypeEnum Type, 
                        [in, optional, defaultvalue(0)] long DefinedSize, 
                        [in, optional, defaultvalue(-1)] FieldAttributeEnum Attrib);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields._Append"]/*' />
        void _Append();

        /*  
            [id(0x00000004), helpcontext(0x0012f05c)]
            void Delete([in] VARIANT Index);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Delete"]/*' />
        void Delete();

        /*
            [id(0x00000003), helpcontext(0x0012f05d)]
            void Append(
                        [in] BSTR Name, 
                        [in] DataTypeEnum Type, 
                        [in, optional, defaultvalue(0)] long DefinedSize, 
                        [in, optional, defaultvalue(-1)] FieldAttributeEnum Attrib, 
                        [in, optional] VARIANT FieldValue);
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Append"]/*' />
        void Append();

        /*  
            [id(0x00000005), helpcontext(0x0012f05e)]
            void Update();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Update"]/*' />
        void Update();

        /*
            [id(0x00000006), helpcontext(0x0012f05f)]
            void Resync([in, optional, defaultvalue(2)] ResyncEnum ResyncValues);            
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.Resync"]/*' />
        void Resync();

        /*
            [id(0x00000007), helpcontext(0x0012f060)]
            void CancelUpdate();
         */
        /// <include file='doc\ADODB.uex' path='docs/doc[@for="Fields.CancelUpdate"]/*' />
        void CancelUpdate();
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\smtp\smtpmail.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpMail.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements a managed wrapper to send mail messages via Smtp
**          
**          
**
** Date:    June 26, 2000
**
===========================================================*/

using System.Runtime.Serialization.Formatters;
using System.Collections;
using System.Reflection;
using System.Runtime.Remoting.Channels;

namespace System.Runtime.Remoting.Channels.Smtp
{

// Class that sends MailMessage using CDO
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail"]/*' />
public class SmtpMail
{
    private static Type _newMailType; // cached Type of CDONTS.NewMail

    private static Type GetNewMailType()
    {
        if (_newMailType == null)
        {
            try { _newMailType = Type.GetTypeFromProgID("CDONTS.NewMail"); }
            catch(Exception) {}

            if (_newMailType == null)
                throw new Exception(String.Format(CoreChannel.GetResourceString("Remoting_UnableToCreateProgID"), "CDONTS.NewMail"));
        }

        return _newMailType;
    }

    private static void CallNewMail(Object newMail, String methodName, Object[] args)
    {
        try
        {
            GetNewMailType().InvokeMember(methodName, 
                                          BindingFlags.InvokeMethod, 
                                          null, 
                                          newMail,
                                          args);
        }
        catch (Exception e)
        {
            throw new Exception("Could_not_access_cdo_newmail_object", e);
        }
    }

    private static void SetNewMailProp(Object newMail, String propName, Object propValue)
    {
        try
        {
            GetNewMailType().InvokeMember(propName, 
                                          BindingFlags.SetProperty, 
                                          null, 
                                          newMail,
                                          new Object[1] { propValue });
        }
        catch (Exception e)
        {
            throw new Exception("Could_not_access_cdo_newmail_object", e);
        }
    }

    private static void SetNewMailProp(Object newMail, String propName, Object propKey, Object propValue)
    {
        try
        {
            GetNewMailType().InvokeMember(propName, 
                                          BindingFlags.SetProperty, 
                                          null, 
                                          newMail,
                                          new Object[2] { propKey, propValue });
        }
        catch (Exception e)
        {
            throw new Exception("Could_not_access_cdo_newmail_object", e);
        }
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail.Send"]/*' />
    public static void Send(String from, String to, String subject, String messageText)
    {
        Object newMail = Activator.CreateInstance(GetNewMailType());

        CallNewMail(newMail, 
                    "Send",
                    new Object[5] { from, to, subject, messageText, (Object)1 });
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="SmtpMail.Send1"]/*' />
    public static void Send(MailMessage message)
    {
        // create mail object

        Object newMail = Activator.CreateInstance(GetNewMailType());

        // set properties

        if (message.From != null)
            SetNewMailProp(newMail, "From", message.From);

        if (message.To != null)
            SetNewMailProp(newMail, "To", message.To);

        if (message.Cc != null)
            SetNewMailProp(newMail, "Cc", message.Cc);

        if (message.Bcc != null)
            SetNewMailProp(newMail, "Bcc", message.Bcc);

        if (message.Subject != null)
            SetNewMailProp(newMail, "Subject", message.Subject);

        if (message.Priority != MailPriority.Normal)
        {
            int p = 0;
            switch (message.Priority)
            {
            case MailPriority.Low:      p = 0;  break;
            case MailPriority.Normal:   p = 1;  break;
            case MailPriority.High:     p = 2;  break;
            }
            SetNewMailProp(newMail, "Importance", p);
        }

        if (message.UrlContentBase != null)
            SetNewMailProp(newMail, "ContentBase", message.UrlContentBase);

        if (message.UrlContentLocation != null)
            SetNewMailProp(newMail, "ContentLocation", message.UrlContentLocation);

        int numHeaders = message.Headers.Count;
        if (numHeaders > 0)
        {
            IDictionaryEnumerator e = message.Headers.GetEnumerator();
            while (e.MoveNext())
            {
                String k = (String)e.Key;
                String v = (String)e.Value;
                SetNewMailProp(newMail, "Value", k, v);
            }
        }

        if (message.BodyFormat == MailFormat.Html)
        {
            SetNewMailProp(newMail, "BodyFormat", 0);
            SetNewMailProp(newMail, "MailFormat", 0);
        }

        if (message.Body != null)
            SetNewMailProp(newMail, "Body", message.Body);

        for (IEnumerator e = message.Attachments.GetEnumerator(); e.MoveNext(); )
        {
            MailAttachment a = (MailAttachment)e.Current;

            int c = 0;
            switch (a.Encoding)
            {
            case MailEncoding.UUEncode: c = 0;  break;
            case MailEncoding.Base64:   c = 1;  break;
            }

            CallNewMail(newMail, "AttachFile", new Object[3] { a.Filename, null, (Object)c });
        }

        // send mail

        CallNewMail(newMail, 
                    "Send",
                    new Object[5] { null, null, null, null, null });

    }
}

//
// Enums for message elements
//

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat"]/*' />
[Serializable]
public enum MailFormat
{
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat.Text"]/*' />
    Text = 0,       // note - different from CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailFormat.Html"]/*' />
    Html = 1
}

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority"]/*' />
[Serializable]
public enum MailPriority
{
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.Normal"]/*' />
    Normal = 0,     // note - different from CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.Low"]/*' />
    Low = 1,
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailPriority.High"]/*' />
    High = 2
}

/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding"]/*' />
[Serializable]
public enum MailEncoding
{
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding.UUEncode"]/*' />
    UUEncode = 0,   // note - same as CDONTS.NewMail
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailEncoding.Base64"]/*' />
    Base64 = 1
}

// Immutable struct that holds a single attachment
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment"]/*' />
public class MailAttachment
{
    private String _filename;
    private MailEncoding _encoding;

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.Filename"]/*' />
    public String Filename { get { return _filename; } }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.Encoding"]/*' />
    public MailEncoding Encoding { get { return _encoding; } }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.MailAttachment"]/*' />
    public MailAttachment(String filename)
    {
        _filename = filename;
        _encoding = MailEncoding.UUEncode;
    }

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailAttachment.MailAttachment1"]/*' />
    public MailAttachment(String filename, MailEncoding encoding)
    {
        _filename = filename;
        _encoding = encoding;
    }
}

// Struct that holds a single message
/// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage"]/*' />
public class MailMessage
{
    private Hashtable _headers = new Hashtable();
    private ArrayList _attachments = new ArrayList();

    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.From"]/*' />
    public String       From;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.To"]/*' />
    public String       To;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Cc"]/*' />
    public String       Cc;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Bcc"]/*' />
    public String       Bcc;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Subject"]/*' />
    public String       Subject;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Priority"]/*' />
    public MailPriority Priority = MailPriority.Normal;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.UrlContentBase"]/*' />
    public String       UrlContentBase;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.UrlContentLocation"]/*' />
    public String       UrlContentLocation;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Body"]/*' />
    public String       Body;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.BodyFormat"]/*' />
    public MailFormat   BodyFormat = MailFormat.Text;
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Headers"]/*' />
    public IDictionary  Headers { get { return _headers; } }
    /// <include file='doc\SmtpMail.uex' path='docs/doc[@for="MailMessage.Attachments"]/*' />
    public IList        Attachments { get { return _attachments; } }
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\smtp\smtpmessagesink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpMessageSink.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements a Smtp message sink which transmits method calls
**          as Smtp messages.
**          
**
** Date:    June 26, 2000
**
===========================================================*/

using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Soap;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;

namespace System.Runtime.Remoting.Channels.Smtp
{
  /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink"]/*' />
  public class SmtpMessageSink : IMessageSink, IDictionary
  {        
        private SmtpChannel     m_channel;
        private String          m_channelURI;
        private String          m_mimeType;
        private IDictionary     m_items;             

        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.SmtpMessageSink"]/*' />
        public SmtpMessageSink(SmtpChannel smtpChannel, String smtpchannelURI,  String mimeType)
        {
            m_items = new Hashtable();
        
            m_channel = smtpChannel;
            m_channelURI = smtpchannelURI;
            m_mimeType = mimeType;

            InternalRemotingServices.RemotingTrace("SmtpMessageSink ctor channel: " + m_channel);                                                                                     
            InternalRemotingServices.RemotingTrace("SmtpMessageSink ctor channelURI: " + m_channelURI);
            InternalRemotingServices.RemotingTrace("SmtpMessageSink ctor mimeType: " + m_mimeType);
        }

        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.SyncProcessMessage"]/*' />
        public IMessage SyncProcessMessage(IMessage reqMsg)
        {
            return m_channel.SyncProcessMessage(reqMsg, m_channelURI); 
        }

        
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.AsyncProcessMessage"]/*' />
        public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            InternalRemotingServices.RemotingTrace("SmtpMessageSink::AsyncProcessMessage");
            return m_channel.AsyncProcessMessage(msg, replySink, m_channelURI);
        }


        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.NextSink"]/*' />
        public IMessageSink NextSink
        {
          get
          {
            return NextSink;
          }
        }

        /// <include file='doc\SMTPMessageSink.uex' path='docs/doc[@for="SMTPMessageSink.Finalize"]/*' />
        ~SmtpMessageSink()
        {
              // @TODO use this for safe cleanup at for now
        }


        //IDictionary
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.this"]/*' />
        public Object this[Object key] 
        {
            get { return m_items[key];}
            set { m_items[key] = value;}
        }
    
        // Returns a collections of the keys in this dictionary.
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Keys"]/*' />
        public ICollection Keys {
            get { return m_items.Keys;}
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Values"]/*' />
        public ICollection Values {
            get {return m_items.Values;}
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Contains"]/*' />
        public bool Contains(Object key)
        { 
          return m_items.Contains(key);
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Add"]/*' />
        public void Add(Object key, Object value)
        {
          m_items.Add(key, value);
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Clear"]/*' />
        public void Clear()
        {
          m_items.Clear();
        }
    
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.GetEnumerator"]/*' />
        public virtual IDictionaryEnumerator GetEnumerator() 
        {
          return m_items.GetEnumerator();
        }

        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Remove"]/*' />
        public void Remove(Object key)
        {
          m_items.Remove(key);
        }

        //ICollection

          /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.CopyTo"]/*' />
          public void CopyTo(Array array, int index)
          {
            m_items.CopyTo(array, index);
          }
        
          /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.Count"]/*' />
          public int Count
        { get {return m_items.Count;} }
        
        
        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.SyncRoot"]/*' />
        public Object SyncRoot
        { get {return m_items.SyncRoot;} }
    
      /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.IsReadOnly"]/*' />
      public  bool IsReadOnly 
        { get {return m_items.IsReadOnly;} }

		/// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.IsFixedSize"]/*' />
		public  bool IsFixedSize 
        { get {return m_items.IsFixedSize;} }


        /// <include file='doc\SmtpMessageSink.uex' path='docs/doc[@for="SmtpMessageSink.IsSynchronized"]/*' />
        public bool IsSynchronized
        { get {return m_items.IsSynchronized;} }

      //IEnumerable
      IEnumerator IEnumerable.GetEnumerator() 
      {
          return m_items.GetEnumerator();
      }


    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\smtp\smtpchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpChannel.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: Implements a channel that transmits method calls in the 
**          SOAP format over Smtp.
**          
**
** Date:    June 26, 2000
**
===========================================================*/

using System;
using System.Text;
using System.Threading;
using System.Collections;
using System.Reflection;
using System.Globalization;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Soap;
using System.Runtime.Serialization.Formatters.Binary;
using System.IO;
using System.Net;
using System.Net.Sockets;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.MetadataServices;
using System.Runtime.InteropServices;


namespace System.Runtime.Remoting.Channels.Smtp
{

//
// URL format
//
// Smtp://host@domainname/uri
//

    /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase"]/*' />
    public class SmtpChannelBase
    {
        const int     DefaultChannelPriority=1;
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.DefaultChannelName"]/*' />
        protected const String  DefaultChannelName = "Smtp";        
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.DefaultMimeType"]/*' />
        protected const String  DefaultMimeType = CoreChannel.SOAPMimeType;

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.m_mimeType"]/*' />
        protected String m_mimeType;

        
        internal SmtpChannelBase() 
        {
                m_mimeType = DefaultMimeType;
        }

        internal bool IsMimeTypeSupported(String mimeType)
        {
            return (    mimeType.Equals(CoreChannel.SOAPMimeType)
                    ||  mimeType.Equals(CoreChannel.BinaryMimeType)
                    );
        }

        // IChannel
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get 
            {
                return DefaultChannelPriority;
                }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.ChannelName"]/*' />
        public String ChannelName
        {
            get
            {
                return  DefaultChannelName;
            }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.MimeType"]/*' />
        public String MimeType
        {
            get 
            { 
                return m_mimeType; 
            }
            set 
            { 
                m_mimeType = value; 
            }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannelBase.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {
            return InternalParse(url, out objectURI);
        }

        //------------------------ I_CHANNEL_SENDER ------------------
        // IChannelSender
        internal static String InternalParse(String url, out String objectURI)
        {
            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse URL in: " + url);
            
            // Set the out parameters
            objectURI = null;
            String trm = DefaultChannelName + "://";  

            // Find the starting point of channelName + ://
            int separator = String.Compare(url, 0, trm, 0, trm.Length, true, CultureInfo.InvariantCulture);
            if ((-1 == separator) || (0 != separator))
            {
                throw new ArgumentException("Argument_InvalidValue");
            }
            String suffix = url.Substring(separator + trm.Length);

            separator = suffix.IndexOf('/');

            if (-1 == separator)
            {
                throw new ArgumentException("Argument_InvalidValue");
            }

            // Extract the channel URI which is the prefix
            String channelURI = suffix.Substring(0, separator);

            // Extract the object URI which is the suffix
            objectURI = suffix.Substring(separator+1);

            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse URI in: " + url);
            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse channelURI: " + channelURI);
            InternalRemotingServices.RemotingTrace("SmtpChannel.Parse objectURI: " + objectURI);
            
            return channelURI;      
        }

    }

    /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel"]/*' />
    public class SmtpChannel 
        :   SmtpChannelBase, 
            IChannelSender, IChannelReceiver, IDictionary,            
            ISmtpOnArrival
    {        
        // ----------------- Sender data -------------------
        private const String s_defaultSenderSubject = "SOAPRequest";
        private static long s_msgSequenceNumber = 0; 
        private static String s_prefixGuid = Guid.NewGuid().ToString() + "/";
        private Hashtable m_hashTable;
        // ----------------- End-Sender data ---------------


        // ----------------- Receiver data -----------------
        private const String s_defaultReceiverSubject = "SOAPResponse";
        private static Hashtable s_receiverTable = new Hashtable();
        private String m_mailboxName;
        private Guid m_receiverGuid;
        private IDictionary m_items;             

        // ----------------- End-Receiver data --------------

        // CTOR used to implicitly create and register a channel.
        // It assumes that the mailbox name is passed in as a command line
        // argument
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SmtpChannel"]/*' />
        public SmtpChannel()
        {
            String[] args = System.Environment.GetCommandLineArgs();
            if(1 <= args.Length)
            {
                Init(args[1]);
            }
            else
            {
                throw new ArgumentNullException("Must specify the mailbox name as the first command line parameter");
            }
            InternalRemotingServices.RemotingTrace("Finished default const");
        }   
                             
        // CTOR used to manually register the channel
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SmtpChannel1"]/*' />
        public SmtpChannel(String mailbox)
        {
            InternalRemotingServices.RemotingTrace("Reached common constr " + mailbox);
            
            // This constructor is used when messages are sent and received
            // from a mailbox
            Init(mailbox);

            InternalRemotingServices.RemotingTrace("Finished common constr");
        }
                
        // CTOR used via the configuration file
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SmtpChannel2"]/*' />
        public SmtpChannel(String[] data)
        {
            if((null != data) && (0 != data.Length))
            {
                for(int i = 0; i < data.Length; i++)
                {
                    Init(data[i]);
                }
            }
            else
            {
                throw new ArgumentNullException("Must specify a mailbox name");
            }
        }

        // All the ctors delegate to this function to do the initialization
        private void Init(String mailbox)
        {
            if(null == mailbox)
            {
                throw new ArgumentNullException("mailbox");
            }
            m_mailboxName = mailbox;
            
            m_hashTable = new Hashtable();
            
            m_items = Hashtable.Synchronized(new Hashtable());
            
            InternalRemotingServices.RemotingTrace("SmtpChannel::Init Register the smtp listener");

            // Register the smtp listener                        
            lock(s_receiverTable)
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::Init Register the smtp listener - lock acquired");
                // Check if we have already registered a listener for this 
                // guid
                if(!s_receiverTable.Contains(m_mailboxName))
                {
                    InternalRemotingServices.RemotingTrace("SmtpChannel::Init Creating registry entry and registering guid");
                    m_receiverGuid = SmtpRegisterSink.CreateRegistryEntryForMailbox(mailbox);
                    InternalRemotingServices.RemotingTrace("Registering receiver for  " + m_receiverGuid);
                    s_receiverTable.Add(m_mailboxName, this);
                    new RegistrationServices().RegisterTypeForComClients(typeof(SmtpChannel), ref m_receiverGuid);
                }
            }
        }
               
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.CreateMessageSink"]/*' />
        public virtual IMessageSink CreateMessageSink(String url, Object data, out String objectURI)
        {

            // Set the out parameters
            objectURI = null;
            String channelURI = null;
            if ((null != url))
            {
                if (0 == String.Compare(url, 0, ChannelName, 0, ChannelName.Length, true, CultureInfo.InvariantCulture))
                {
                    channelURI = Parse(url, out objectURI);
                }
            }
            else
            {
                if ((null != data) && (data is String))
                {
                  channelURI = (String)data; 
                }
            }            

            if (null != channelURI)
            {                
                IMessageSink sink = new SmtpMessageSink(this, channelURI, m_mimeType);
                InternalRemotingServices.RemotingTrace("SmtpChannel::CreateMessageSink ChnlURI: " + channelURI + " ObjURI: " + objectURI);

                return sink;          
            }

            return null;
        }

        
        //------------------------ END: I_CHANNEL_SENDER --------------
        
        //------------------------ I_CHANNEL_RECEIVER -----------------
        // IChannelReceiver
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.ChannelData"]/*' />
        public Object ChannelData
        {
            get
            {
                if (null != m_mailboxName)
                {
                    StartListening(null);
                    return GetChannelUri();
                }
                else
                {                    
                    return null;
                }
            }
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.GetChannelUri"]/*' />
        public String GetChannelUri()
        {
            return m_mailboxName;
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.GetUrlsForUri"]/*' />
        public virtual String[] GetUrlsForUri(String objectURI)
        {
            String[] retVal = new String[1];
            
            retVal[0] = "smtp://" + GetChannelUri() + "/" + objectURI;
            
            return retVal;
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.StartListening"]/*' />
        public void StartListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("SmtpChannel.StartListening");
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.StopListening"]/*' />
        public void StopListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("SmtpChannel.StopListening");
        }

        
        //------------------------ END: I_CHANNEL_RECEIVER ------------
        
        // DICTIONARY IMPLEMENTION        
        //Properties
        
        //IDictionary
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.this"]/*' />
        public Object this[Object key] 
        {                
            get { return m_items[key];}
            set 
            { 
                 m_items[key] = value;                 
            }                
        }
    
        // Returns a collections of the keys in this dictionary.
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Keys"]/*' />
        public ICollection Keys 
        {
            get { return m_items.Keys;}
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Values"]/*' />
        public ICollection Values 
        {        
            get {return m_items.Values;}
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Contains"]/*' />
        public bool Contains(Object key)
        { 
            return m_items.Contains(key);
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Add"]/*' />
        public void Add(Object key, Object value)
        {
            m_items.Add(key, value);
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Clear"]/*' />
        public void Clear()
        {
            m_items.Clear();
        }
    
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.GetEnumerator"]/*' />
        public virtual IDictionaryEnumerator GetEnumerator() 
        {
            return m_items.GetEnumerator();
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Remove"]/*' />
        public void Remove(Object key)
        {
            m_items.Remove(key);
        }

        //ICollection

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.CopyTo"]/*' />
        public void CopyTo(Array array, int index)
        {
            m_items.CopyTo(array, index);
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.Count"]/*' />
        public int Count
        { 
            get {return m_items.Count;} 
        }


        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.SyncRoot"]/*' />
        public Object SyncRoot
        {   
            get {return m_items.SyncRoot;} 
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.IsReadOnly"]/*' />
        public  bool IsReadOnly 
        { 
            get {return m_items.IsReadOnly;} 
        }

		/// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.IsFixedSize"]/*' />
		public  bool IsFixedSize 
        { 
            get {return m_items.IsFixedSize;} 
        }

        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.IsSynchronized"]/*' />
        public bool IsSynchronized
        { 
            get {return m_items.IsSynchronized;} 
        }

        //IEnumerable
        IEnumerator IEnumerable.GetEnumerator() 
        {
            return m_items.GetEnumerator();
        }    
        // END: DICTIONARY IMPLEMENTION                        

        // ISmtpOnArrival 
        // Receives incoming messages which can either be a request to dispatch
        // a call or a response to a call
        /// <include file='doc\SmtpChannel.uex' path='docs/doc[@for="SmtpChannel.OnArrival"]/*' />
        public virtual void OnArrival(ISmtpMessage  smtpMessage, ref CdoEventStatus EventStatus)        
        {
           bool fIsOneWay = false;
           try
           {
                InternalRemotingServices.RemotingTrace("Reached OnArrival");                
                
                ISmtpOnArrival receiver = null;
                // Get the global receiver. If this instance is the global 
                // receiver then proceed else delegate to it.
                if(IsReceiver(smtpMessage, ref receiver))
                {
                    // Check whether this message is a SOAP request message or a
                    // SOAP response message
                    String subject = smtpMessage.Subject;
                    bool fRequest = false;                    
                    // Proceed only if this is a SOAP request or response
                    if(s_defaultSenderSubject.Equals(subject))
                    {
                        fRequest = true;
                    }
                    else if(!s_defaultReceiverSubject.Equals(subject))
                    {
                        throw new Exception("Invalid subject type " + subject);
                    }
                    
                    // Extract the releavant mail headers                            
                    String contentType = null;
                    Smtp.Fields headers = null;
                    Header[] msgHeaders = null;
                    String seqNum = GetHeaders(smtpMessage, ref headers, ref contentType, ref msgHeaders);
                    
                    // Create a stream out of the body of the mail
                    MemoryStream stm = new MemoryStream(Encoding.ASCII.GetBytes(smtpMessage.TextBody));
                    InternalRemotingServices.RemotingTrace("Created memory stream");
                    
                    // Check whether this is a request or a response message
                    if(fRequest)
                    {
                        // Dispatch this method and determine whether this 
                        // method is one way. 
                        ProcessRequest(smtpMessage, headers, msgHeaders, contentType, seqNum, stm, ref fIsOneWay);
                    }
                    else
                    {
                        ProcessResponse(smtpMessage, contentType, seqNum, stm);
                    }                            
                }
                else
                {
                    if(null != receiver)
                    {
                        // A message was addressed to us .. delegate to the
                        // global receiver
                        receiver.OnArrival(smtpMessage, ref EventStatus);
                    }
                }
                        
                InternalRemotingServices.RemotingTrace("Success!");                                
            }
            catch(Exception e)
            {
                InternalRemotingServices.RemotingTrace("Reached an exception " + e.StackTrace);
                InternalRemotingServices.RemotingTrace("Exception message " + e.Message);
                if(!fIsOneWay)
                {
                    //@TODO
                    //ProcessException(smtpMessage, contentType, headers, seqNum);
                }
            }
            finally
            {
                EventStatus = CdoEventStatus.cdoRunNextSink;
            }
        }
        
        
        // Internal methods         
        internal IMessage SyncProcessMessage(IMessage reqMsg, String receiver)
        {
            IMessage desResMsg = null;
            bool fAdded = true;
            String seqNum = null;
            try
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::SyncProcessMessage");
    
                // HACKALERT::
                // we are going to temporarily not send the call context
                Object callContext = reqMsg.Properties["__CallContext"];
                if (callContext != null)
                {
                    reqMsg.Properties["__CallContext"] = null;
                }
    
                //
                // Create a new wait object which will wait for the
                // response to arrive 
                //
                WaitObject obj = new WaitObject(reqMsg, null);                
                seqNum = GetNextSequenceNumber();
                m_hashTable.Add(seqNum, obj);
                fAdded = true;
                
                //
                // Serialize the message and send it using Smtp 
                //
                SendMessage(reqMsg, receiver, seqNum);
    
                //
                // Receive server response
                //
                InternalRemotingServices.RemotingTrace("SmtpMessageSink::SyncProcessMessage before ReceiveResponse");            
            
                desResMsg = ReceiveMessage(obj);
                
                if (callContext != null)
                {
                    desResMsg.Properties["__CallContext"] = callContext;
                }                
                
                InternalRemotingServices.RemotingTrace("SmtpChannel::Returning successfully from SyncProcessMessage");
            }
            catch(Exception e)
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::SyncProcessMessage threw exception " + e.StackTrace);
                try
                {
                    if(fAdded)
                    {
                        m_hashTable.Remove(seqNum);
                    }
                    desResMsg = new ReturnMessage(e, null);
                }
                catch(Exception )
                {
                    // Fatal error.. return null
                }            
            }
            return desResMsg;
        }
        
        internal IMessageCtrl AsyncProcessMessage(IMessage msg,
                                                  IMessageSink replySink,
                                                  String receiver)        
        {
            IMessage desResMsg = null;
            bool fAdded = true;
            String seqNum = null;
            try
            {
                //
                // Create a new wait object which will wait for the
                // response to arrive 
                //
                if(null != replySink)
                {
                    WaitObject obj = new WaitObject(msg, replySink);
                    seqNum = GetNextSequenceNumber();
                    m_hashTable.Add(seqNum, obj);
                    fAdded = true;
                }

                SendMessage(msg, receiver, seqNum);

                // Note: The response will be deliverd to the OnArrival method
                // which is responsible for notifying the sink.                                                           
            }
            catch(Exception e)
            {
                InternalRemotingServices.RemotingTrace("SmtpChannel::AsyncProcessMessage threw exception " + e.StackTrace);
                try
                {
                    // Cleanup state
                    if(fAdded)
                    {
                        m_hashTable.Remove(seqNum);
                    }
                                        
                    // Notify the sink
                    if(null != replySink)
                    {
                        // Create a message which encapsulates an exception
                        desResMsg = new ReturnMessage(e, null);
                        replySink.SyncProcessMessage(desResMsg);
                    }
                }
                catch(Exception )
                {
                    // Fatal error.. return null
                }            
            }
            
            return null;
        }        
        
        void SendMessage(IMessage msg, String receiver, String seqNum)
        {
            if (msg == null)
                throw new ArgumentNullException("msg");            

            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend 1");

            //
            // Serialize the message
            //
            byte [] byteMessage;
            int byteMessageLength = 0;

            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend 2");

            MemoryStream stm = (MemoryStream)CoreChannel.SerializeMessage(m_mimeType, msg);

            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend 3");
            // reset stream to beginning
            stm.Position = 0;
            byteMessage = stm.ToArray();
            byteMessageLength = byteMessage.Length;

            //
            // Create a new mail message
            //
            MailMessage mail = new MailMessage();
            
            // Add the required and optional headers
            PutHeaders(mail, (IMethodCallMessage)msg, receiver, seqNum, byteMessageLength);
            
            // Add the body of the message
            mail.Body = System.Text.Encoding.ASCII.GetString(byteMessage, 0, byteMessage.Length);
            
            //
            // Send request
            //
            InternalRemotingServices.RemotingTrace("SmtpMessageSink::ProcessAndSend before Send");
            SmtpMail.Send(mail);                
        }
        
        IMessage ReceiveMessage(WaitObject obj)
        {
            IMessage desResMsg = null;
            
            InternalRemotingServices.RemotingTrace("SmtpChannel::RecieveMessage IN");            
            lock(obj)
            {
                if(obj.ShouldWait)
                {
                    InternalRemotingServices.RemotingTrace("ReceiveMessage Staring wait...");
                    
                    // This will release the lock and wait till the
                    // receiving thread signals it
                    Monitor.Wait(obj);
                }
                
                // Extract the response object which is set by the
                // thread which received the response
                desResMsg = obj.Response;
            }
            
            InternalRemotingServices.RemotingTrace("Received message");            
            return desResMsg;
        }
        
        // Generates a reply to an incoming Smtp message and sends it
        void ReplyMessage(IMessage replyMsg, ISmtpMessage smtpInMsg, 
                          String seqNum, Smtp.Fields headers)
        {
            MemoryStream stm = (MemoryStream)CoreChannel.SerializeMessage(m_mimeType, replyMsg);
            // reset stream to beginning
            stm.Position = 0;
            byte[] byteMessage = stm.ToArray();
            int byteMessageLength = byteMessage.Length;
            String reply = System.Text.Encoding.ASCII.GetString(byteMessage, 0, byteMessage.Length);

            // Create a reply message
            MailMessage smtpOutMsg = new MailMessage();
            
            // Fill in the headers
            PutHeaders(smtpOutMsg, smtpInMsg, (IMethodMessage)replyMsg, seqNum, reply.Length);
         
            // Set the body
            smtpOutMsg.Body = reply;
               
            // Send the message 
            SmtpMail.Send(smtpOutMsg);
        }
        
        // Generate headers for request message
        void PutHeaders(MailMessage mail, IMethodCallMessage mcMessage,
                        String receiver, String seqNum, int msgLength)
        {
            String sender = (String)ChannelData;
            String action = SoapServices.GetSoapActionFromMethodBase(mcMessage.MethodBase);
            PutHeaders(mail, sender, receiver, s_defaultSenderSubject, action,
                       mcMessage.Uri, seqNum, msgLength); 
        }
        
        // Generate headers for reply message
        void PutHeaders(MailMessage mail, ISmtpMessage inMessage, 
                        IMethodMessage replyMsg, String seqNum, int msgLength)
        {            
            String sender = inMessage.To;
            String receiver = inMessage.From;
            String action = SoapServices.GetSoapActionFromMethodBase(replyMsg.MethodBase);
            String uri = replyMsg.Uri;
            
            PutHeaders(mail, sender, receiver, s_defaultReceiverSubject, 
                       action, uri, seqNum, msgLength);
        }
        
        // Common routine for adding SOAP headers in a mail
        void PutHeaders(MailMessage mail, String sender, String receiver, 
                        String subject, String action, String uri, 
                        String seqNum, int msgLength)        
        {
                        
            // Set the required Smtp headers
            mail.From = sender;
            mail.To = receiver;
            
            // Set the optional Smtp headers
            mail.Subject = subject;
            //MailPriority Priority = MailPriority.Normal;
            //String       UrlContentBase;
            //String       UrlContentLocation;
            //MailFormat   BodyFormat = MailFormat.Text;
            //IList        Attachments 
            
            //
            // Add additional headers which is used by SOAP to dispatch calls
            // 
            IDictionary  smtpHeaders = mail.Headers; 
            
            // Action
            smtpHeaders.Add("SOAPAction", action);
            
            // Content-type 
            smtpHeaders.Add("ContentType", m_mimeType);
            
            // Message sequence number            
            if(null != seqNum)
            {
                smtpHeaders.Add("SOAPMsgSeqNum", seqNum);
            }
            
            // Request type
            smtpHeaders.Add("SOAPRequestType", "POST");
            
            // URI
            smtpHeaders.Add("RequestedURI", uri);

            //@TODO Version number
                                    
            // Content-length
            smtpHeaders.Add("Content-length", (msgLength).ToString());                        
        }                         
        
        bool IsReceiver(ISmtpMessage smtpMessage, ref ISmtpOnArrival receiver)
        {
            bool fReceive = false;
            
            // Get the one and only receiver 
            //BCLDebug.Assert(m_receiverGuid != Guid.Empty, "m_receiverGuid != Guid.Empty");                
            receiver = (ISmtpOnArrival)s_receiverTable[m_mailboxName];
            if(null == receiver)
            {
                throw new Exception(CoreChannel.GetResourceString("Remoting_NoReceiverRegistered"));
            }                 
            
            if(receiver == this)
            {
                String mailbox = smtpMessage.To;
                
                // Only process those messages which are addressed to us
                InternalRemotingServices.RemotingTrace("mailbox " + m_mailboxName + " receiver " + mailbox);
                if((null != m_mailboxName) && 
                   (-1 != CultureInfo.CurrentCulture.CompareInfo.IndexOf(mailbox, m_mailboxName, CompareOptions.IgnoreCase)))
                {
                    InternalRemotingServices.RemotingTrace("Mailboxes match");
                    fReceive = true;
                }
                else
                {
                    // We don't do anything with messages not addressed to us
                    receiver = null;
                }    
            }
            
            return fReceive;
        }
        
        String GetHeaders(ISmtpMessage smtpMessage, ref Smtp.Fields headers, ref String contentType, ref Header[] msgHeaders)
        {
            // Get the headers from the message object
            headers = smtpMessage.Fields;
#if _DEBUG                            
            long count = headers.Count;
            InternalRemotingServices.RemotingTrace(" Count of fields " + count);
            for(long i = 0; i < count; i++)
            {
                //InternalRemotingServices.RemotingTrace(" Field " + i + " " + headers[i].Name + " " + headers[i].Value);
            }
#endif                            
                            
            // Get the content type string
            Field typeField = headers["urn:schemas:mailheader:contenttype"];
            if(null == typeField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingContentType"));
            }
            contentType = (String)(typeField.Value);     
            InternalRemotingServices.RemotingTrace("Content type " + typeField.Name + " " + contentType);

            // Extract the requested uri from the mail header
            Field uriField = headers["urn:schemas:mailheader:requesteduri"];    
            if(null == uriField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingRequestedURIHeader"));
            }
            String uriValue = (String)uriField.Value;
            if(null == uriValue)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingRequestedURIHeader"));
            }
        
            // process SoapAction (extract the type and the name of the method to be invoked)
            Field actionField = headers["urn:schemas:mailheader:soapaction"];   
            if(null == actionField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_SoapActionMissing"));
            }
            String actionValue = (String)actionField.Value;
            if(null == actionValue)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_SoapActionMissing"));
            }

            String typeName, methodName;
            if (!SoapServices.GetTypeAndMethodNameFromSoapAction(actionValue, out typeName, out methodName))
            {
                // This means there are multiple methods for this soap action, so we will have to
                // settle for the type based off of the uri.
                Type type = RemotingServices.GetServerTypeForUri(uriValue);
                typeName = type.FullName + ", " + type.Module.Assembly.GetName().Name;
            }
            
            // BUGBUG: need code to verify soap action after the message has been deserialized.
            //   this will probably be done once we have the new activation scenario working.
            
            msgHeaders = new Header[3];
            msgHeaders[0] = new Header("__Uri", uriValue);
            msgHeaders[1] = new Header("__TypeName", typeName);
            msgHeaders[2] = new Header("__MethodName", methodName);

            // Extract the message sequence number field from the 
            // mail header
            Field seqField = headers["urn:schemas:mailheader:soapmsgseqnum"];
            if(null == seqField)
            {
                throw new FormatException(CoreChannel.GetResourceString("Remoting_MissingSoapMsgSeqNum"));
            }
            String seqValue = (String)(seqField.Value);
            InternalRemotingServices.RemotingTrace("Guid value " + seqValue);            
            
            return seqValue;
        }
        
        void ProcessRequest(ISmtpMessage smtpMessage, Smtp.Fields headers,
                            Header[] msgHeaders, String contentType, String seqNum, 
                            MemoryStream stm, ref bool fIsOneWay)
        {
            IMessage outMsg = null;
            fIsOneWay = false;    
            
            // Deserialize - Stream to IMessage
            IMessage inMsg = CoreChannel.DeserializeMessage(contentType, stm, true, null, msgHeaders);
            InternalRemotingServices.RemotingTrace("Deserialized message");
            
            if (inMsg == null)
            {
                throw new Exception(CoreChannel.GetResourceString("Remoting_DeserializeMessage"));
            }
            
            // Set URI - BUGBUG: temp hack
            String url = ((IMethodMessage)inMsg).Uri;
            String objectURL = null;
            try
            {
                Parse(url, out objectURL);
            }
            catch(Exception )
            {
                objectURL = url;
            }
            inMsg.Properties["__Uri"] = objectURL;
            
            // Dispatch Call
            InternalRemotingServices.RemotingTrace("ChannelServices.SyncDispatchMessage - before");
            outMsg = ChannelServices.SyncDispatchMessage(inMsg);
            InternalRemotingServices.RemotingTrace("ChannelServices.SyncDispatchMessage - after");
            
            // We do not send a reply for one way messages. If the message
            // is not one way and we have a null return message then we 
            // throw an exception
            if (null == outMsg)
            {
                MethodBase method = ((IMethodMessage)inMsg).MethodBase;
                fIsOneWay = RemotingServices.IsOneWay(method);
                if(!fIsOneWay)
                {
                    throw new Exception(CoreChannel.GetResourceString("Remoting_DispatchMessage"));
                }
            }
            else
            {                            
                ReplyMessage(outMsg, smtpMessage, seqNum, headers);
                InternalRemotingServices.RemotingTrace("Reply sent");        
            }                            
        }
        
        void ProcessResponse(ISmtpMessage smtpMessage, String contentType, 
                             String seqNum, MemoryStream stm)
        {
            InternalRemotingServices.RemotingTrace("Received response");
            
            // Notify the waiting object that its response
            // has arrived
            WaitObject obj = (WaitObject)m_hashTable[seqNum];
            if(null != obj)
            {
                InternalRemotingServices.RemotingTrace("Found an object waiting");
                
                // First remove the object in a threadsafe manner
                // so that we do not deliver the response twice
                // due to duplicate replies or other errors from
                // Smtp
                
                lock(obj)
                {
                    if(m_hashTable.Contains(seqNum))
                    {
                        InternalRemotingServices.RemotingTrace("Found an object to notify");
                        m_hashTable.Remove(seqNum);
                        
                        IMethodCallMessage request = (IMethodCallMessage)obj.Request;
                        Header[] h = new Header[3];
                        h[0] = new Header("__TypeName", request.TypeName);
                        h[1] = new Header("__MethodName", request.MethodName);
                        h[2] = new Header("__MethodSignature", request.MethodSignature);
                        
                        IMessage response = CoreChannel.DeserializeMessage(contentType, stm, false, request, h);
                        InternalRemotingServices.RemotingTrace("Deserialized message");
        
                        if (response == null)
                        {
                            throw new Exception(CoreChannel.GetResourceString("Remoting_DeserializeMessage"));
                        }
                                                                                                                                                 
                        // Notify the object
                        obj.Notify(response);
                    }
                }
                
            }
            else
            {
                InternalRemotingServices.RemotingTrace("No object waiting");
            }
        }
        
        private void ProcessException(ISmtpMessage smtpMessage, Smtp.Fields headers,
                                      String contentType, String seqNum)
        {
            try
            {
            }
            catch(Exception )
            {
                // Fatal error .. ignore
            }
        }
                                              
        private static String GetNextSequenceNumber()
        {
            return s_prefixGuid + (Interlocked.Increment(ref s_msgSequenceNumber)).ToString();
        }
    }

    // Class used to rendezvous request and response messages
    internal class WaitObject
    {
        private bool m_fWait;
        private IMessage m_response;
        private IMessage m_request;
        private IMessageSink m_sink;
        
        internal WaitObject(IMessage request, IMessageSink sink)
        {
            m_fWait = true;
            m_request = request;
            m_sink = sink;
        }
        
        internal bool ShouldWait
        {
            get { return m_fWait; }
            set { m_fWait = value; } 
        }
        
        internal IMessage Response 
        {
            get { return m_response; }
            set { m_response = value; }
        }
        
        internal IMessage Request
        {
            get { return m_request; }
        }
        
        internal void Notify(IMessage response)
        {
            // Set a flag to indicate that
            // it is no longer necessary to wait if one
            // hasn't started waiting yet
            m_fWait = false;                                                
            
            // Set the response message
            m_response = response;
            
            // Check whether we have to pulse the object 
            // or call on a sink            
            if(null == m_sink)
            {                
                // Pulse the object if it is waiting
                Monitor.Pulse(this);               
            }
            else
            {
                // Notify the sink that the response has arrived
                m_sink.SyncProcessMessage(response);
            }
        }
    }
    
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\tcpchannelhelper.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       TcpChannelHelper.cs
//
//  Summary:    Implements helper methods for tcp client and server channels.
//
//==========================================================================

using System;
using System.Runtime.Remoting.Channels;

namespace System.Runtime.Remoting.Channels.Tcp
{
    
    internal class TcpChannelHelper
    {
        private const String _tcp = "tcp://";
            
        // see if the string starts with "tcp://"
        internal static bool StartsWithTcp(String url)
        {
            return StringHelper.StartsWithAsciiIgnoreCasePrefixLower(url, _tcp);
        } // StartsWithTcp
        

        // Used by tcp channels to implement IChannel::Parse.
        // It returns the channel uri and places object uri into out parameter.
        internal static String ParseURL(String url, out String objectURI)
        {            
            // Set the out parameters
            objectURI = null;

            int separator;

            // Find the starting point of tcp://
            // NOTE: We are using this version of String.Compare to ensure
            // that string operations are case-insensitive!!
            if (StringHelper.StartsWithAsciiIgnoreCasePrefixLower(url, _tcp))
            {
                separator = _tcp.Length;
            }
            else
            {
                return null;
            }

            // find next slash (after end of scheme)
            separator = url.IndexOf('/', separator);
            if (-1 == separator)
            {
                return url; // means that the url is just "tcp://foo:90" or something like that
            }

            // Extract the channel URI which is the prefix
            String channelURI = url.Substring(0, separator);

            // Extract the object URI which is the suffix
            objectURI = url.Substring(separator); // leave the slash

            return channelURI;
        } // ParseURL

    
    } // class TcpChannelHelper


} // namespace System.Runtime.Remoting.Channels.Tcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\combinedtcpchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       CombinedTcpChannel.cs
//
//  Summary:    Merges the client and server TCP channels
//
//  Classes:    public TcpChannel
//
//==========================================================================

using System;
using System.Collections;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;


namespace System.Runtime.Remoting.Channels.Tcp
{

    /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel"]/*' />
    public class TcpChannel : IChannelReceiver, IChannelSender
    {
        private TcpClientChannel  _clientChannel = null; // client channel
        private TcpServerChannel  _serverChannel = null; // server channel
    
        private int    _channelPriority = 1;  // channel priority
        private String _channelName = "tcp"; // channel name


        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.TcpChannel"]/*' />
        public TcpChannel()
        {
            _clientChannel = new TcpClientChannel();
            // server channel will not be activated.
        } // TcpChannel

        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.TcpChannel1"]/*' />
        public TcpChannel(int port) : this()
        {
            _serverChannel = new TcpServerChannel(port);
        } // TcpChannel

        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.TcpChannel2"]/*' />
        public TcpChannel(IDictionary properties, 
                          IClientChannelSinkProvider clientSinkProvider,
                          IServerChannelSinkProvider serverSinkProvider)
        {
            Hashtable clientData = new Hashtable();
            Hashtable serverData = new Hashtable();

            bool portFound = false;
        
            // divide properties up for respective channels
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    switch ((String)entry.Key)
                    {
                    // general channel properties
                    case "name": _channelName = (String)entry.Value; break;
                    case "priority": _channelPriority = Convert.ToInt32((String)entry.Value); break;

                    // client properties (none yet)

                    // server properties
                    case "bindTo": serverData["bindTo"] = entry.Value; break;
                    case "machineName": serverData["machineName"] = entry.Value; break; 
                    
                    case "port": 
                    {
                        serverData["port"] = entry.Value; 
                        portFound = true;
                        break;
                    }
                    case "rejectRemoteRequests": serverData["rejectRemoteRequests"] = entry.Value; break;
                    case "suppressChannelData": serverData["suppressChannelData"] = entry.Value; break;
                    case "useIpAddress": serverData["useIpAddress"] = entry.Value; break;
                    case "exclusiveAddressUse": serverData["exclusiveAddressUse"] = entry.Value; break;

                    default: 
                        break;
                    }
                }                    
            }

            _clientChannel = new TcpClientChannel(clientData, clientSinkProvider);

            if (portFound)
                _serverChannel = new TcpServerChannel(serverData, serverSinkProvider);
        } // TcpChannel


        // 
        // IChannel implementation
        //

        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get { return _channelPriority; }    
        } // ChannelPriority

        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.ChannelName"]/*' />
        public String ChannelName
        {
            get { return _channelName; }
        } // ChannelName

        // returns channelURI and places object uri into out parameter
        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {            
            return TcpChannelHelper.ParseURL(url, out objectURI);
        } // Parse
        
        //
        // end of IChannel implementation
        //


        //
        // IChannelSender implementation
        //

        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.CreateMessageSink"]/*' />
        public IMessageSink CreateMessageSink(String url, Object remoteChannelData, 
                                                      out String objectURI)
        {
            return _clientChannel.CreateMessageSink(url, remoteChannelData, out objectURI);
        } // CreateMessageSink

        //
        // end of IChannelSender implementation
        //


        //
        // IChannelReceiver implementation
        //

        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.ChannelData"]/*' />
        public Object ChannelData
        {
            get 
            {
                if (_serverChannel != null)
                    return _serverChannel.ChannelData;
                else
                    return null;
            }
        } // ChannelData
      
                
        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.GetUrlsForUri"]/*' />
        public String[] GetUrlsForUri(String objectURI)
        {
            if (_serverChannel != null)
                return _serverChannel.GetUrlsForUri(objectURI);
            else
                return null;
        } // GetUrlsforURI

        
        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.StartListening"]/*' />
        public void StartListening(Object data)
        {
            if (_serverChannel != null)
                _serverChannel.StartListening(data);
        } // StartListening


        /// <include file='doc\CombinedTcpChannel.uex' path='docs/doc[@for="TcpChannel.StopListening"]/*' />
        public void StopListening(Object data)
        {
            if (_serverChannel != null)
                _serverChannel.StopListening(data);
        } // StopListening

        //
        // IChannelReceiver implementation
        //

    
    } // class TcpChannel


} // namespace System.Runtime.Remoting.Channels.Tcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\sinks\binaryformattersinks.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       BinaryFormatterSinks.cs
//
//  Summary:    Binary formatter client and server sinks.
//
//==========================================================================


using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Metadata;
using System.Security;
using System.Security.Permissions;
using System.Globalization;


namespace System.Runtime.Remoting.Channels
{

    //
    // CLIENT-SIDE BINARY FORMATTER SINKS
    //

    /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSinkProvider"]/*' />
    public class BinaryClientFormatterSinkProvider : IClientFormatterSinkProvider
    {
        private IClientChannelSinkProvider _next;

        // settings from config
        private bool _includeVersioning = true;
        private bool _strictBinding = false;
        

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSinkProvider.BinaryClientFormatterSinkProvider"]/*' />
        public BinaryClientFormatterSinkProvider()
        {
        } // BinaryClientFormatterSinkProvider


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSinkProvider.BinaryClientFormatterSinkProvider1"]/*' />
        public BinaryClientFormatterSinkProvider(IDictionary properties, ICollection providerData)
        {
            // look at properties
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    String keyStr = entry.Key.ToString();
                    switch (keyStr)
                    {
                    case "includeVersions": _includeVersioning = Convert.ToBoolean(entry.Value); break;
                    case "strictBinding": _strictBinding = Convert.ToBoolean(entry.Value); break;

                    default:
                        CoreChannel.ReportUnknownProviderConfigProperty(
                            this.GetType().Name, keyStr);
                        break;
                    }
                }
            }
        
            // not expecting any provider data
            CoreChannel.VerifyNoProviderData(this.GetType().Name, providerData);
        } // BinaryClientFormatterSinkProvider

   
        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSinkProvider.CreateSink"]/*' />
        public IClientChannelSink CreateSink(IChannelSender channel, String url, 
                                             Object remoteChannelData)
        {
            IClientChannelSink nextSink = null;
            if (_next != null)
            {
                nextSink = _next.CreateSink(channel, url, remoteChannelData);
                if (nextSink == null)
                    return null;
            }

            SinkChannelProtocol protocol = CoreChannel.DetermineChannelProtocol(channel);

            BinaryClientFormatterSink sink = new BinaryClientFormatterSink(nextSink);
            sink.IncludeVersioning = _includeVersioning;
            sink.StrictBinding = _strictBinding;
            sink.ChannelProtocol = protocol;
            return sink;
        } // CreateSink

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSinkProvider.Next"]/*' />
        public IClientChannelSinkProvider Next
        {
            get { return _next; }
            set { _next = value; }
        }
    } // class BinaryClientFormatterSinkProvider

    
    /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink"]/*' />
    public class BinaryClientFormatterSink : IClientFormatterSink
    {
        private IClientChannelSink _nextSink = null;

        private bool _includeVersioning = true; // should versioning be used
        private bool _strictBinding = false; // strict binding should be used
        
        private SinkChannelProtocol _channelProtocol = SinkChannelProtocol.Other;
        
    
        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.BinaryClientFormatterSink"]/*' />
        public BinaryClientFormatterSink(IClientChannelSink nextSink)
        {                                                                
            _nextSink = nextSink;
        } // BinaryClientFormatterSink

        internal bool IncludeVersioning
        {
            set { _includeVersioning = value; }
        } // IncludeVersioning

        internal bool StrictBinding
        {
            set { _strictBinding = value; }
        } // StrictBinding

        internal SinkChannelProtocol ChannelProtocol
        {
            set { _channelProtocol = value; }
        } // ChannelProtocol



        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.NextSink"]/*' />
        public IMessageSink NextSink { get { throw new NotSupportedException(); } }


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.SyncProcessMessage"]/*' />
        public IMessage SyncProcessMessage(IMessage msg)
        {
            IMethodCallMessage mcm = msg as IMethodCallMessage;
            IMessage retMsg;
        
            try 
            {
                // serialize message
                ITransportHeaders headers;
                Stream requestStream;
                RemotingServices.LogRemotingStage(CoreChannel.CLIENT_MSG_SER);
                SerializeMessage(msg, out headers, out requestStream);

                RemotingServices.LogRemotingStage(CoreChannel.CLIENT_MSG_SEND);
            
                // process message
                Stream returnStream;
                ITransportHeaders returnHeaders;
                _nextSink.ProcessMessage(msg, headers, requestStream,
                                         out returnHeaders, out returnStream);
                if (returnHeaders == null)
                    throw new ArgumentNullException("returnHeaders");                                         
                                     
                // deserialize stream
                RemotingServices.LogRemotingStage(CoreChannel.CLIENT_RET_DESER);
                retMsg = DeserializeMessage(mcm, returnHeaders, returnStream);
            }
            catch (Exception e)
            {
                retMsg = new ReturnMessage(e, mcm);
            }
            
            RemotingServices.LogRemotingStage(CoreChannel.CLIENT_RET_SINK_CHAIN);
            return retMsg;
        } // SyncProcessMessage


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.AsyncProcessMessage"]/*' />
        public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            IMethodCallMessage mcm = (IMethodCallMessage)msg;
            IMessage retMsg;

            try
            {
                // serialize message
                ITransportHeaders headers;
                Stream requestStream;
                SerializeMessage(msg, out headers, out requestStream);
            
                // process message
                ClientChannelSinkStack sinkStack = new ClientChannelSinkStack(replySink);
                sinkStack.Push(this, msg);
                _nextSink.AsyncProcessRequest(sinkStack, msg, headers, requestStream);
            }
            catch (Exception e)
            {
                retMsg = new ReturnMessage(e, mcm);
                if (replySink != null)
                    replySink.SyncProcessMessage(retMsg);
            }
                                          
            return null;
        } // AsyncProcessMessage


        // helper function to serialize the message
        private void SerializeMessage(IMessage msg, 
                                      out ITransportHeaders headers, out Stream stream)
        {
            BaseTransportHeaders requestHeaders = new BaseTransportHeaders();
            headers = requestHeaders;

            // add other http soap headers
            requestHeaders.ContentType = CoreChannel.BinaryMimeType;
            if (_channelProtocol == SinkChannelProtocol.Http)
                headers["__RequestVerb"] = "POST";

            bool bMemStream = false;
            stream = _nextSink.GetRequestStream(msg, headers);
            if (stream == null)
            {
                stream = new ChunkedMemoryStream(CoreChannel.BufferPool);
                bMemStream = true;
            }
            CoreChannel.SerializeBinaryMessage(msg, stream, _includeVersioning);
            if (bMemStream)
                stream.Position = 0;               
        } // SerializeMessage


        // helper function to deserialize the message
        private IMessage DeserializeMessage(IMethodCallMessage mcm, 
                                            ITransportHeaders headers, Stream stream)
        {
            // deserialize the message
            IMessage retMsg = CoreChannel.DeserializeBinaryResponseMessage(stream, mcm, _strictBinding); 
                
            stream.Close();
            return retMsg;
        } // DeserializeMessage
       

        //
        // IClientChannelSink implementation
        //
        
        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.ProcessMessage"]/*' />
        public void ProcessMessage(IMessage msg,
                                   ITransportHeaders requestHeaders, Stream requestStream,
                                   out ITransportHeaders responseHeaders, out Stream responseStream)
        {
            // should never gets called, since this sink is always first
            throw new NotSupportedException();
        } // ProcessMessage


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.AsyncProcessRequest"]/*' />
        public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg,
                                        ITransportHeaders headers, Stream stream)
        {
            // should never be called, this sink is always first
            throw new NotSupportedException();
        } // AsyncProcessRequest


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.AsyncProcessResponse"]/*' />
        public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, Object state,
                                         ITransportHeaders headers, Stream stream)
        {
            // previously we stored the outgoing message in state
            IMethodCallMessage mcm = (IMethodCallMessage)state;  
            IMessage retMsg = DeserializeMessage(mcm, headers, stream);
            sinkStack.DispatchReplyMessage(retMsg);
        } // AsyncProcessRequest

       
        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.GetRequestStream"]/*' />
        public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
        {
            // never called on formatter sender sink
            throw new NotSupportedException();
        }
        

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.NextChannelSink"]/*' />
        public IClientChannelSink NextChannelSink
        {
            get { return _nextSink; }
        }


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryClientFormatterSink.Properties"]/*' />
        public IDictionary Properties
        {
            get { return null; }
        } // Properties

        //
        // end of IClientChannelSink implementation
        //
        
    } // class BinaryClientFormatterSink



    //
    // SERVER-SIDE SOAP FORMATTER SINKS
    //

    /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSinkProvider"]/*' />
    public class BinaryServerFormatterSinkProvider : IServerFormatterSinkProvider
    {
        private IServerChannelSinkProvider _next = null;

        // settings from config
        private bool _includeVersioning = true;
        private bool _strictBinding = false;
        private TypeFilterLevel _formatterSecurityLevel = TypeFilterLevel.Low;     

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSinkProvider.BinaryServerFormatterSinkProvider"]/*' />
        public BinaryServerFormatterSinkProvider()
        {
        } // BinaryServerFormatterSinkProvider


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSinkProvider.BinaryServerFormatterSinkProvider1"]/*' />
        public BinaryServerFormatterSinkProvider(IDictionary properties, ICollection providerData)
        {       
            // look at properties
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    String keyStr = entry.Key.ToString();
                    switch (keyStr)
                    {
                    case "includeVersions": _includeVersioning = Convert.ToBoolean(entry.Value); break;
                    case "strictBinding": _strictBinding = Convert.ToBoolean(entry.Value); break;
                    case "typeFilterLevel": 
                        _formatterSecurityLevel = (TypeFilterLevel) Enum.Parse(typeof(TypeFilterLevel), (string)entry.Value); 
                        break;
         
                    default:
                        break;
                    }
                }
            }
        
            // not expecting any provider data
            CoreChannel.VerifyNoProviderData(this.GetType().Name, providerData);        
        } // BinaryServerFormatterSinkProvider
        

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSinkProvider.GetChannelData"]/*' />
        public void GetChannelData(IChannelDataStore channelData)
        {
        } // GetChannelData
   
        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSinkProvider.CreateSink"]/*' />
        public IServerChannelSink CreateSink(IChannelReceiver channel)
        {
            if(null == channel)
            {
                throw new ArgumentNullException("channel");               
            }

            IServerChannelSink nextSink = null;
            if (_next != null)
                nextSink = _next.CreateSink(channel);

            BinaryServerFormatterSink.Protocol protocol = 
                BinaryServerFormatterSink.Protocol.Other;

            // see if this is an http channel
            String uri = channel.GetUrlsForUri("")[0];
            if (String.Compare("http", 0, uri, 0, 4, true, CultureInfo.InvariantCulture) == 0)
                protocol = BinaryServerFormatterSink.Protocol.Http;            

            BinaryServerFormatterSink sink = new BinaryServerFormatterSink(protocol, nextSink, channel);
            sink.TypeFilterLevel = _formatterSecurityLevel;
            sink.IncludeVersioning = _includeVersioning;
            sink.StrictBinding = _strictBinding;
            return sink;
        } // CreateSink

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSinkProvider.Next"]/*' />
        public IServerChannelSinkProvider Next
        {
            get { return _next; }
            set { _next = value; }
        } // Next
        
        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSinkProvider.TypeFilterLevel"]/*' />                                                          
        [System.Runtime.InteropServices.ComVisible(false)]        
        public TypeFilterLevel TypeFilterLevel {
            get {
                return _formatterSecurityLevel;
            }
            
            set {
                _formatterSecurityLevel = value;
            }
        }
        
    } // class BinaryServerFormatterSinkProvider
    

    /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink"]/*' />
    public class BinaryServerFormatterSink : IServerChannelSink
    {
        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="Protocol"]/*' />
		[Serializable]
        public enum Protocol
        {
            /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="Protocol.Http"]/*' />
            Http, // special processing needed for http
            /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="Protocol.Other"]/*' />
            Other
        }
    
        private IServerChannelSink _nextSink; // If this sink doesn't recognize, the incoming
                                              //   format then it should call the next
                                              //   sink if there is one.

        private Protocol _protocol; // remembers which protocol is being used
        
        private IChannelReceiver _receiver; // transport sink used to parse url

        private bool _includeVersioning = true; // should versioning be used
        private bool _strictBinding = false; // strict binding should be used
        private TypeFilterLevel _formatterSecurityLevel = TypeFilterLevel.Low;                     

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink.BinaryServerFormatterSink"]/*' />
        public BinaryServerFormatterSink(Protocol protocol, IServerChannelSink nextSink,
                                         IChannelReceiver receiver)
        {
            if (receiver == null)
                throw new ArgumentNullException("receiver");

            _nextSink = nextSink;
            _protocol = protocol;
            _receiver = receiver;            
        } // BinaryServerFormatterSinkProvider


        internal bool IncludeVersioning
        {
            set { _includeVersioning = value; }
        } // IncludeVersioning

        internal bool StrictBinding
        {
            set { _strictBinding = value; }
        } // StrictBinding

        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink.TypeFilterLevel"]/*' />                                                          
        [System.Runtime.InteropServices.ComVisible(false)]        
        public TypeFilterLevel TypeFilterLevel {
            get {
                return _formatterSecurityLevel;
            }
            
            set {
                _formatterSecurityLevel = value;
            }
        }


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink.ProcessMessage"]/*' />
        public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
            IMessage requestMsg,
            ITransportHeaders requestHeaders, Stream requestStream,
            out IMessage responseMsg, out ITransportHeaders responseHeaders, 
            out Stream responseStream)
        {
            if (requestMsg != null)
            {
                // The message has already been deserialized so delegate to the next sink.
                return _nextSink.ProcessMessage(
                    sinkStack,
                    requestMsg, requestHeaders, requestStream, 
                    out responseMsg, out responseHeaders, out responseStream);
            }
        
            if (requestHeaders ==  null)
                throw new ArgumentNullException("requestHeaders");

            BaseTransportHeaders wkRequestHeaders = requestHeaders as BaseTransportHeaders;
        
            ServerProcessing processing;
        
            responseHeaders = null;
            responseStream = null;

            String verb = null;
            String contentType = null;

            bool bCanServiceRequest = true;

            // determine the content type
            String contentTypeHeader = null;
            if (wkRequestHeaders != null)
                contentTypeHeader = wkRequestHeaders.ContentType;
            else
                contentTypeHeader = requestHeaders["Content-Type"] as String;
            if (contentTypeHeader != null)
            {
                String charsetValue;
                HttpChannelHelper.ParseContentType(contentTypeHeader,
                                                   out contentType, out charsetValue);
            }

            // check to see if Content-Type matches
            if ((contentType != null) &&
                (String.CompareOrdinal(contentType, CoreChannel.BinaryMimeType) != 0))
            {
                bCanServiceRequest = false;                
            }

            // check for http specific verbs
            if (_protocol == Protocol.Http)
            {
                verb = (String)requestHeaders["__RequestVerb"];    
                if (!verb.Equals("POST") && !verb.Equals("M-POST"))
                    bCanServiceRequest = false;
            }

            // either delegate or return an error message if we can't service the request
            if (!bCanServiceRequest)
            {
                // delegate to next sink if available
                if (_nextSink != null)
                {
                    return _nextSink.ProcessMessage(sinkStack, null, requestHeaders, requestStream,   
                        out responseMsg, out responseHeaders, out responseStream);
                }
                else
                {
                    // send back an error message
                    if (_protocol == Protocol.Http)
                    {
                        // return a client bad request error     
                        responseHeaders = new TransportHeaders();
                        responseHeaders["__HttpStatusCode"] = "400";
                        responseHeaders["__HttpReasonPhrase"] = "Bad Request";
                        responseStream = null;
                        responseMsg = null;
                        return ServerProcessing.Complete;
                    }
                    else
                    {
                        // The transport sink will catch this and do something here.
                        throw new RemotingException(
                            CoreChannel.GetResourceString("Remoting_Channels_InvalidRequestFormat"));
                    }
                }
            }
            

            try
            {
                String objectUri = null;

                bool bIsCustomErrorEnabled = true;
                object oIsCustomErrorEnabled = requestHeaders["__CustomErrorsEnabled"];
                if (oIsCustomErrorEnabled != null && oIsCustomErrorEnabled is bool){
                    bIsCustomErrorEnabled = (bool)oIsCustomErrorEnabled;
                }
                CallContext.SetData("__CustomErrorsEnabled", bIsCustomErrorEnabled);
              
                if (wkRequestHeaders != null)
                    objectUri = wkRequestHeaders.RequestUri;
                else
                    objectUri = (String)requestHeaders[CommonTransportKeys.RequestUri];              

                if (RemotingServices.GetServerTypeForUri(objectUri) == null)
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_ChnlSink_UriNotPublished"));

                RemotingServices.LogRemotingStage(CoreChannel.SERVER_MSG_DESER);
                
                PermissionSet currentPermissionSet = null;                  
                if (this.TypeFilterLevel != TypeFilterLevel.Full) {                    
                    currentPermissionSet = new PermissionSet(PermissionState.None);                
                    currentPermissionSet.SetPermission(new SecurityPermission(SecurityPermissionFlag.SerializationFormatter));                    
                }
                                    
                try {
                    if (currentPermissionSet != null)
                        currentPermissionSet.PermitOnly();
                        
                    // Deserialize Request - Stream to IMessage
                    requestMsg = CoreChannel.DeserializeBinaryRequestMessage(objectUri, requestStream, _strictBinding, this.TypeFilterLevel);                    
                }
                finally {
                    if (currentPermissionSet != null)
                        CodeAccessPermission.RevertPermitOnly();
                }                    

                requestStream.Close();
                if(requestMsg == null)
                {
                    throw new RemotingException(CoreChannel.GetResourceString("Remoting_DeserializeMessage"));
                }
                

                // Dispatch Call
                sinkStack.Push(this, null);
                RemotingServices.LogRemotingStage(CoreChannel.SERVER_MSG_SINK_CHAIN);
                processing =                    
                    _nextSink.ProcessMessage(sinkStack, requestMsg, requestHeaders, null,
                        out responseMsg, out responseHeaders, out responseStream);
                // make sure that responseStream is null
                if (responseStream != null)
                {
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_ChnlSink_WantNullResponseStream"));
                }
                
                switch (processing)
                {

                case ServerProcessing.Complete:
                {
                    if (responseMsg == null)
                        throw new RemotingException(CoreChannel.GetResourceString("Remoting_DispatchMessage"));

                    sinkStack.Pop(this);

                    RemotingServices.LogRemotingStage(CoreChannel.SERVER_RET_SER);
                    SerializeResponse(sinkStack, responseMsg,
                                      ref responseHeaders, out responseStream);
                    break;
                } // case ServerProcessing.Complete

                case ServerProcessing.OneWay:
                {
                    sinkStack.Pop(this);
                    break;
                } // case ServerProcessing.OneWay:

                case ServerProcessing.Async:
                {
                    sinkStack.Store(this, null);
                    break;   
                } // case ServerProcessing.Async
                    
                } // switch (processing)                
            }
            catch(Exception e)
            {
                processing = ServerProcessing.Complete;
                responseMsg = new ReturnMessage(e, (IMethodCallMessage)(requestMsg==null?new ErrorMessage():requestMsg));
                //TODO, sowmys: See if we could call SerializeResponse here
                //We always set __ClientIsClr here since interop is not an issue
                CallContext.SetData("__ClientIsClr", true);
                responseStream = (MemoryStream)CoreChannel.SerializeBinaryMessage(responseMsg, _includeVersioning);
                CallContext.FreeNamedDataSlot("__ClientIsClr");
                responseStream.Position = 0;
                responseHeaders = new TransportHeaders();

                if (_protocol == Protocol.Http)
                {
                    responseHeaders["Content-Type"] = CoreChannel.BinaryMimeType;
                }
            }
            finally{
                CallContext.FreeNamedDataSlot("__CustomErrorsEnabled");
            }

            RemotingServices.LogRemotingStage(CoreChannel.SERVER_RET_SEND);
            return processing;
        } // ProcessMessage


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink.AsyncProcessResponse"]/*' />
        public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                         IMessage msg, ITransportHeaders headers, Stream stream)
        {
            SerializeResponse(sinkStack, msg, ref headers, out stream);
            sinkStack.AsyncProcessResponse(msg, headers, stream);
        } // AsyncProcessResponse


        private void SerializeResponse(IServerResponseChannelSinkStack sinkStack,
                                       IMessage msg, ref ITransportHeaders headers,
                                       out Stream stream)
        {
            BaseTransportHeaders responseHeaders = new BaseTransportHeaders();
            if (headers != null)
            {
                // copy old headers into new headers
                foreach (DictionaryEntry entry in headers)
                {
                    responseHeaders[entry.Key] = entry.Value;
                }
            }            
            headers = responseHeaders;

            if (_protocol == Protocol.Http)
            {
                responseHeaders.ContentType = CoreChannel.BinaryMimeType;
            }

            bool bMemStream = false;
            stream = sinkStack.GetResponseStream(msg, headers);
            if (stream == null)
            {
                stream = new ChunkedMemoryStream(CoreChannel.BufferPool);
                bMemStream = true;
            }


            bool bBashUrl = CoreChannel.SetupUrlBashingForIisSslIfNecessary(); 
            try
            {
                CallContext.SetData("__ClientIsClr", true);
                CoreChannel.SerializeBinaryMessage(msg, stream, _includeVersioning);
            }
            finally
            {
                CallContext.FreeNamedDataSlot("__ClientIsClr");
                CoreChannel.CleanupUrlBashingForIisSslIfNecessary(bBashUrl);
            }

            if (bMemStream)            
                stream.Position = 0;
        } // SerializeResponse


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink.GetResponseStream"]/*' />
        public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                        IMessage msg, ITransportHeaders headers)
        {
            // This should never get called since we're the last in the chain, and never
            //   push ourselves to the sink stack.
            throw new NotSupportedException();
        } // GetResponseStream


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink.NextChannelSink"]/*' />
        public IServerChannelSink NextChannelSink
        {
            get { return _nextSink; }
        }


        /// <include file='doc\BinaryFormatterSinks.uex' path='docs/doc[@for="BinaryServerFormatterSink.Properties"]/*' />
        public IDictionary Properties
        {
            get { return null; }
        } // Properties
        
        
    } // class BinaryServerFormatterSink



} // namespace System.Runtime.Remoting.Channnels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\smtp\smtpregistersink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SmtpRegisterSink.cool
**
** Author(s):   Tarun Anand (TarunA)
**              
**
** Purpose: (1) Creates registry entries for the given mailbox if one has
**              not been created yet.
**          (2) Registers the mailbox with the Smtp service so that 
**              incoming or outgoing messages can be intercepted.
**          
**
** Date:    June 26, 2000
**
===========================================================*/
using System;
using Microsoft.Win32;
using System.IO;
using System.Runtime.Remoting.Channels;
using System.Globalization;


namespace System.Runtime.Remoting.Channels.Smtp
{

/// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink"]/*' />
public class SmtpRegisterSink
{
    private const String s_strSink = "SmtpSink";
    private const String s_eventSourceName = "smtpsvc 1";   // ServiceName + Virtual service instance number
    private static Guid s_onArrivalGuid = new Guid("{ff3caa23-00b9-11d2-9dfb-00C04FA322BA}");
    private static Object s_lockObject = new Object();
    //private static String s_strRuleTemplate = "RCPT TO=";
    
    // Creates registry entries for the given mailbox if one has
    // not been created yet.
    // NOTE: The process name is the name of the process qualified with the 
    // path. This process handles all the messages addressed to the mailbox.
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.CreateRegistryEntryForMailbox"]/*' />
    public static Guid CreateRegistryEntryForMailbox(String processName, String mailbox)
    {
        Guid regGuid = Guid.Empty;
        
        // Sanity check
        if(null == processName)
        {
            throw new ArgumentNullException("processName");
        }        
        if(null == mailbox)
        {
            throw new ArgumentNullException("mailbox");
        }
                
        // Try to find an existing ProgID with this name
        lock(s_lockObject)
        {
            regGuid = GetGuidForMailbox(mailbox);
            
            // If we do not have a guid for this mailbox then create
            // one and put the appropriate entries in the registry
            if(regGuid.Equals(Guid.Empty))
            {                
                regGuid = Guid.NewGuid();
                Console.WriteLine("Creating new Entry " + regGuid);
                String strClsId = "{" + regGuid.ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
                
                //
                // Write the actual type information in the registry.
                //
    
                // Create the HKEY_CLASS_ROOT\<wzProgId> key.
                RegistryKey TypeNameKey = Registry.ClassesRoot.CreateSubKey(mailbox);
                TypeNameKey.SetValue("", s_strSink);
    
                // Create the HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
                RegistryKey ProgIdClsIdKey = TypeNameKey.CreateSubKey("CLSID");
                ProgIdClsIdKey.SetValue("", strClsId);
                // Close HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
                ProgIdClsIdKey.Close();
    
                // Close HKEY_CLASS_ROOT\<wzProgId> key.
                TypeNameKey.Close();
                
                // Create the HKEY_CLASS_ROOT\CLSID\<CLSID> key.
                RegistryKey ClsIdKey = Registry.ClassesRoot.OpenSubKey("CLSID", true).CreateSubKey(strClsId);
                ClsIdKey.SetValue("", s_strSink);
                ClsIdKey.SetValue("AppID", strClsId);
    
                // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\LocalServer32 key.
                RegistryKey LocalServerKey = ClsIdKey.CreateSubKey("LocalServer32");
                // The value is ProcessName.exe <mailbox>
                LocalServerKey.SetValue("", processName + " " + mailbox);                
                
                // Close HKEY_CLASS_ROOT\CLSID\<CLSID>\LocalServer32 key.
                LocalServerKey.Close();
    
                // Create the HKEY_CLASS_ROOT\CLSID\<CLSID>\ProgId key.
                RegistryKey ProgIdKey = ClsIdKey.CreateSubKey("ProgId");
                ProgIdKey.SetValue("", mailbox);
                
                // Close HKEY_CLASS_ROOT\CLSID\<CLSID>\ProgId key.
                ProgIdKey.Close();
                
                // Close HKEY_CLASS_ROOT\CLSID\<CLSID> key.
                ClsIdKey.Close();
                
                // Create the HKEY_CLASS_ROOT\APPID\<APPID> key.
                RegistryKey AppIdKey = Registry.ClassesRoot.OpenSubKey("AppID", true).CreateSubKey(strClsId);
                AppIdKey.SetValue("", s_strSink);
                AppIdKey.SetValue("RunAs", "Interactive User");                                
                
                // Close HKEY_CLASS_ROOT\APPID\<APPID> key.
                AppIdKey.Close();
            }
        }
        
        return regGuid;
    }
    
     
    // Creates registry entries for the given mailbox if one has
    // not been created yet.
    // NOTE: The process name is the name of the `current' process qualified 
    // with the path. This process handles all the messages addressed to the mailbox.
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.CreateRegistryEntryForMailbox1"]/*' />
    public static Guid CreateRegistryEntryForMailbox(String mailbox)
    {
        // Get the fully qualified name of the executable which launched the
        // current process
        String processName = Path.GetFullPath(System.Environment.GetCommandLineArgs()[0]);
        Console.WriteLine("The full path to the executable is " + processName);
        return CreateRegistryEntryForMailbox(processName, mailbox);
    }
    
    // Deletes the registry entries for a given mailbox if one exists, otherwise
    // it returns.
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.DeleteRegistryEntryForMailbox"]/*' />
    public static void DeleteRegistryEntryForMailbox(String mailbox)
    {
        
        // Sanity check
        if(null == mailbox)
        {
            throw new ArgumentNullException("mailbox");
        }
                
        // Try to find an existing ProgID with this name
        lock(s_lockObject)
        {
            // Get the CLSID for the mailbox
            Guid regGuid = GetGuidForMailbox(mailbox);
            
            if(!regGuid.Equals(Guid.Empty))
            {
                String strClsId = null;
                
                // Open the HKEY_CLASS_ROOT\<wzProgId> key.
                RegistryKey TypeNameKey = Registry.ClassesRoot.OpenSubKey(mailbox, true);
                if(null != TypeNameKey)
                {
                    // Get the CLSID
                    RegistryKey ProgIdClsIdKey = TypeNameKey.OpenSubKey("CLSID", false);
                    if(null != ProgIdClsIdKey)
                    {
                        strClsId = (String)ProgIdClsIdKey.GetValue("");
                    }
                    // Close the type name key
                    TypeNameKey.Close();
                    
                    // Delete the type name key and all its keys
                    Registry.ClassesRoot.DeleteSubKeyTree(mailbox);
                }
                
                if(null != strClsId)
                {
                    // Open the HKEY_CLASSES_ROOT\CLSID key
                    RegistryKey ClsIdRootKey = Registry.ClassesRoot.OpenSubKey("CLSID", true);
                    // Open the HKEY_CLASS_ROOT\CLSID\<CLSID> key.
                    RegistryKey ClsIdKey = ClsIdRootKey.OpenSubKey(strClsId, true);
                    if(null != ClsIdKey)
                    {
                        // Close the CLSID Key
                        ClsIdKey.Close();
                        
                        // Delete the CLSID Key and all its keys
                        ClsIdRootKey.DeleteSubKeyTree(strClsId);
                    }
                    
                    // Close the HKEY_CLASSES_ROOT\CLSID key
                    ClsIdRootKey.Close();
                    
                    // Open the HKEY_CLASSES_ROOT\AppID key
                    RegistryKey AppIdRootKey = Registry.ClassesRoot.OpenSubKey("AppID", true);
                    // Open the HKEY_CLASS_ROOT\AppID\<CLSID> key.
                    RegistryKey AppIdKey = AppIdRootKey.OpenSubKey(strClsId, true);
                    if(null != AppIdKey)
                    {
                        // Close the AppID Key
                        AppIdKey.Close();
                        
                        // Delete the CLSID Key and all its keys
                        AppIdRootKey.DeleteSubKeyTree(strClsId);
                    }
                    
                    // Close the HKEY_CLASSES_ROOT\AppID key
                    AppIdRootKey.Close();                    
                }
            }
        }
    }
    
    // Looks up a guid for a given mailbox (essentially CLSIDFromProgID)
    // Returns an empty guid if one is not found.
    // Assumes that a lock is held by the calling function
    internal static Guid GetGuidForMailbox(String mailbox)
    {
        Guid regGuid = Guid.Empty;
        
        // Open the HKEY_CLASS_ROOT\<wzProgId> key.
        RegistryKey TypeNameKey = Registry.ClassesRoot.OpenSubKey(mailbox, false);
        if(null != TypeNameKey)
        {
            // Open the HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
            RegistryKey ProgIdClsIdKey = TypeNameKey.OpenSubKey("CLSID", false);
            String strClsId = (String)ProgIdClsIdKey.GetValue("");
            if(null != strClsId)
            {
                Console.WriteLine("Found Entry " + strClsId);
                regGuid = new Guid(strClsId);
            }
            
            // Close HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
            ProgIdClsIdKey.Close();
            
            // Close HKEY_CLASS_ROOT\<wzProgId> key.
            TypeNameKey.Close();
        }
        
        return regGuid;
    }
    
    // Register a sink with Smtp service so that incoming or outgoing messages
    // can be intercepted
    /// <include file='doc\SmtpRegisterSink.uex' path='docs/doc[@for="SmtpRegisterSink.RegisterSinkWithSmtp"]/*' />
    public static void RegisterSinkWithSmtp(String mailbox)
    {
        /*Guid regGuid = CreateRegistryEntryForMailbox(mailbox);
        RemotingServices.RegisterTypeForComClients(typeof(SmtpChannel), ref regGuid);
        */
                
        /*// Create an instance of the event manager object
        IEventManager manager = (IEventManager)Type.CreateInstanceFromProgID("Event.Manager");
        
        // Get the source types
        IEventSourceTypes sourceTypes = manager.SourceTypes();
        
        // Get the source type for Smtp 
        IEventSourceType sourceType = sourceTypes.Source(s_onArrivalGuid);
        
        // Get the sources for Smtp
        IEventSources sources = sourceType.Sources();
        
        // Iterate over the sources till we reach the Smtp source
        for(int i = 0; i < sources.Count; i++)
        {
            IEventSource source = sources[i];
            if(s_eventSourceName.Equals(source.DisplayName))
            {
                String strRule = s_strRuleTemplate + mailbox;        
                
                // we've found the desired instance.  now add a new binding
                // with the right event GUID.  by not specifying a GUID to the
                // Add method we get server events to create a new ID for this
                // event
                IEventBinding binding = source.GetBindingManager().Bindings(s_onArrivalGuid).Add("");
                
                // set the binding properties                
                binding.DisplayName = mailbox;
                binding.SinkClass = mailbox;
                // register a rule with the binding
                binding.SourceProperties.Add("Rule", strRule);
                // register a priority with the binding
                int prioVal = GetNextPriority(source, GUIDComCat);
                
                if(prioVal < 0 )
                {
                    Console.WriteLine("assigning priority to default value (24575)")
                    binding.SourceProperties.Add ("Priority", 24575);
                }
                else    
                {
                    Console.WriteLine("assigning priority (" + prioVal + " of 32767)");
                    binding.SourceProperties.Add("Priority", prioVal);
                }
            }
        }*/
    }
}

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\tcpclientsocketmanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       TcpClientSocketManager.cs
//
//  Summary:    Class for managing a socket connection.
//
//==========================================================================


using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading;


namespace System.Runtime.Remoting.Channels.Tcp
{

    // A client socket manager instance should encapsulate the socket
    //   for the purpose of reading a response
    internal class TcpClientSocketHandler : TcpSocketHandler
    {    
        // prebaked bytes
        private static byte[] s_endOfLineBytes = Encoding.ASCII.GetBytes("\r\n");
        
    
        private String _machineAndPort; // "machineName:port"                     
    
        // connection state information
        private bool _bOneWayRequest = false;  // was the request made OneWay?
        private bool _bChunked;    
        private int  _contentLength;

        private Stream _requestStream; // the request stream that we return from GetRequestStream()
        private TcpReadingStream _responseStream; // the stream that we returned from GetResponseStream()
        

        public TcpClientSocketHandler(Socket socket, String machineAndPort) :
            base(socket)            
        {          
            _machineAndPort = machineAndPort;
        } // TcpClientSocketHandler
 
        

        // Prepare for reading a new request off of the same socket
        protected override void PrepareForNewMessage()
        {
            _requestStream = null;
            _responseStream = null;
        } // PrepareForNewRequest


        public override void OnInputStreamClosed()
        {       
            // make sure we read to the end of the response stream
            if (_responseStream != null)
            {
                _responseStream.ReadToEnd();
                _responseStream = null;                
            }
        
            // return socket to the cache
            ReturnToCache();
        } // OnInputStreamClosed



        public BaseTransportHeaders ReadHeaders()
        {           
            BaseTransportHeaders headers = new BaseTransportHeaders();

            UInt16 operation;
            ReadVersionAndOperation(out operation);

            // At this point, we're always expecting a Reply, so check for that.
            if (operation != TcpOperations.Reply)
            {
                throw new RemotingException(
                    String.Format(
                        CoreChannel.GetResourceString("Remoting_Tcp_ExpectingReplyOp"),
                        operation.ToString()));
            }                        
                   
            // content length must come next (may be chunked or a specific length)
            ReadContentLength(out _bChunked, out _contentLength);
            
            // read to end of headers  
            ReadToEndOfHeaders(headers); 
                               
            return headers;
        } // ReadHeaders  


        public Stream GetRequestStream(IMessage msg, int contentLength,
                                       ITransportHeaders headers)
        {
            IMethodCallMessage mcm = (IMethodCallMessage)msg;        
            String uri = mcm.Uri;
            _bOneWayRequest = RemotingServices.IsOneWay(mcm.MethodBase);

            ChunkedMemoryStream headerStream = new ChunkedMemoryStream(CoreChannel.BufferPool);

            // output preamble and version
            WritePreambleAndVersion(headerStream);
            // output opcode 
            if (!_bOneWayRequest)
                WriteUInt16(TcpOperations.Request, headerStream);
            else
                WriteUInt16(TcpOperations.OneWayRequest, headerStream);            
            // output content delimiter style
            WriteUInt16(TcpContentDelimiter.ContentLength, headerStream);
            WriteInt32(contentLength, headerStream);
            
            // output request uri
            WriteUInt16(TcpHeaders.RequestUri, headerStream);
            WriteByte(TcpHeaderFormat.CountedString, headerStream);
            WriteCountedString(uri, headerStream);         

            // output rest of headers
            WriteHeaders(headers, headerStream);   
            
            headerStream.WriteTo(NetStream);
            headerStream.Close();

            _requestStream = NetStream;

            return _requestStream;
        } // GetRequestStream

        public void SendRequest(IMessage msg, ITransportHeaders headers, Stream contentStream)
        {
            int requestLength = (int)contentStream.Length;
            GetRequestStream(msg, requestLength, headers);

            StreamHelper.CopyStream(contentStream, NetStream);           

            contentStream.Close();
        } // SendRequest


        public Stream GetResponseStream()
        {
            if (!_bChunked)
                _responseStream = new TcpFixedLengthReadingStream(this, _contentLength);
            else
                _responseStream = new TcpChunkedReadingStream(this);
            
            return _responseStream;
        } // GetResponseStream


        public bool OneWayRequest
        {
            get { return _bOneWayRequest; }
        }

        public void ReturnToCache()
        {
            TcpClientTransportSink.ClientSocketCache.ReleaseSocket(
                _machineAndPort, this);
        }
    
    } // TcpClientSocketHandler

} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\sinks\soapformattersinks.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       SoapFormatterSinks.cs
//
//  Summary:    Soap formatter client and server sinks.
//
//==========================================================================


using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Metadata;
using System.Runtime.Serialization;
using System.Security;
using System.Security.Permissions;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Soap;
using System.Text;
using System.Globalization;


namespace System.Runtime.Remoting.Channels
{

    //
    // CLIENT-SIDE SOAP FORMATTER SINKS
    //

    /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSinkProvider"]/*' />
    public class SoapClientFormatterSinkProvider : IClientFormatterSinkProvider
    {
        private IClientChannelSinkProvider _next = null;

        // settings from config
        private bool _includeVersioning = true;
        private bool _strictBinding = false;


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSinkProvider.SoapClientFormatterSinkProvider"]/*' />
        public SoapClientFormatterSinkProvider()
        {
        }

        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSinkProvider.SoapClientFormatterSinkProvider1"]/*' />
        public SoapClientFormatterSinkProvider(IDictionary properties, ICollection providerData)
        {
            // look at properties
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    String keyStr = entry.Key.ToString();
                    switch (keyStr)
                    {
                    case "includeVersions": _includeVersioning = Convert.ToBoolean(entry.Value); break;
                    case "strictBinding": _strictBinding = Convert.ToBoolean(entry.Value); break;

                    default:
                        CoreChannel.ReportUnknownProviderConfigProperty(
                            this.GetType().Name, keyStr);
                        break;
                    }
                }
            }
            
            // not expecting any provider data
            CoreChannel.VerifyNoProviderData(this.GetType().Name, providerData);
        }
    
   
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSinkProvider.CreateSink"]/*' />
        public IClientChannelSink CreateSink(IChannelSender channel, String url, 
                                             Object remoteChannelData)
        {
            IClientChannelSink nextSink = null;
            if (_next != null)
            {
                nextSink = _next.CreateSink(channel, url, remoteChannelData);
                if (nextSink == null)
                    return null;
            }

            SinkChannelProtocol protocol = CoreChannel.DetermineChannelProtocol(channel);

            SoapClientFormatterSink sink = new SoapClientFormatterSink(nextSink);
            sink.IncludeVersioning = _includeVersioning;
            sink.StrictBinding = _strictBinding;
            sink.ChannelProtocol = protocol;
            return sink;
        }

        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSinkProvider.Next"]/*' />
        public IClientChannelSinkProvider Next
        {
            get { return _next; }
            set { _next = value; }
        }
    } // class SoapClientFormatterSinkProvider

    
    /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink"]/*' />
    public class SoapClientFormatterSink : IClientFormatterSink
    {
        private IClientChannelSink _nextSink = null;

        private bool _includeVersioning = true; // should versioning be used
        private bool _strictBinding = false; // strict binding should be used
        private SinkChannelProtocol _channelProtocol = SinkChannelProtocol.Other;
        
    
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.SoapClientFormatterSink"]/*' />
        public SoapClientFormatterSink(IClientChannelSink nextSink)
        {
            _nextSink = nextSink;
        } // SoapClientFormatterSink


        internal bool IncludeVersioning
        {
            set { _includeVersioning = value; }
        } // IncludeVersioning

        internal bool StrictBinding
        {
            set { _strictBinding = value; }
        } // StrictBinding

        internal SinkChannelProtocol ChannelProtocol
        {
            set { _channelProtocol = value; }
        } // ChannelProtocol


        //
        // IMessageSink implementation
        //

        // formatter sender sink is always last "IMessageSink"
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.NextSink"]/*' />
        public IMessageSink NextSink { get { throw new NotSupportedException(); } }


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.SyncProcessMessage"]/*' />
        public IMessage SyncProcessMessage(IMessage msg)
        {
            IMethodCallMessage mcm = (IMethodCallMessage)msg;
            IMessage retMsg;
        
            try 
            {               
                // serialize message
                ITransportHeaders headers;
                Stream requestStream;
                SerializeMessage(mcm, out headers, out requestStream);
            
                // process message
                Stream returnStream;
                ITransportHeaders returnHeaders;
                _nextSink.ProcessMessage(msg, headers, requestStream,
                                         out returnHeaders, out returnStream);
                if (returnHeaders == null)
                    throw new ArgumentNullException("returnHeaders");
                                     
                // deserialize stream
                retMsg = DeserializeMessage(mcm, returnHeaders, returnStream);
            }
            catch (Exception e)
            {
                retMsg = new ReturnMessage(e, mcm);
            }

            return retMsg;
        } // SyncProcessMessage


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.AsyncProcessMessage"]/*' />
        public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            IMethodCallMessage mcm = (IMethodCallMessage)msg;
            IMessage retMsg;

            try
            {
                // serialize message
                ITransportHeaders headers;
                Stream requestStream;
                SerializeMessage(mcm, out headers, out requestStream);
            
                // process message
                ClientChannelSinkStack sinkStack = new ClientChannelSinkStack(replySink);
                sinkStack.Push(this, mcm);
                _nextSink.AsyncProcessRequest(sinkStack, msg, headers, requestStream);
            }
            catch (Exception e)
            {
                retMsg = new ReturnMessage(e, mcm);
                if (replySink != null)
                    replySink.SyncProcessMessage(retMsg);                
            }
                                          
            return null;
        } // AsyncProcessMessage


        //
        // end of IMessageSink implementation
        //


        // helper function to serialize the message
        private void SerializeMessage(IMethodCallMessage mcm, 
                                      out ITransportHeaders headers, out Stream stream)
        {
            BaseTransportHeaders requestHeaders = new BaseTransportHeaders();
            headers = requestHeaders;
        
            // add SOAPAction header
            MethodBase mb = mcm.MethodBase;
            headers["SOAPAction"] = 
                '"' + 
                HttpEncodingHelper.EncodeUriAsXLinkHref(
                    SoapServices.GetSoapActionFromMethodBase(mb)) + 
                '"';

            // add other http soap headers
            requestHeaders.ContentType = CoreChannel.SOAPContentType;
            if (_channelProtocol == SinkChannelProtocol.Http)
                headers["__RequestVerb"] = "POST";

            bool bMemStream = false;
            stream = _nextSink.GetRequestStream(mcm, headers);
            if (stream == null)
            {
                stream = new ChunkedMemoryStream(CoreChannel.BufferPool);
                bMemStream = true;
            }
            CoreChannel.SerializeSoapMessage(mcm, stream, _includeVersioning);
            if (bMemStream)
                stream.Position = 0;
        } // SerializeMessage


        // helper function to deserialize the message
        private IMessage DeserializeMessage(IMethodCallMessage mcm, 
                                            ITransportHeaders headers, Stream stream)
        {
            IMessage retMsg;
        
            Header[] h = new Header[3];
            h[0] = new Header("__TypeName", mcm.TypeName);
            h[1] = new Header("__MethodName", mcm.MethodName);
            h[2] = new Header("__MethodSignature", mcm.MethodSignature);

            String contentTypeHeader = headers["Content-Type"] as String;
            String contentTypeValue, charsetValue;
            HttpChannelHelper.ParseContentType(contentTypeHeader,
                                               out contentTypeValue, out charsetValue);
            
            if (String.Compare(contentTypeValue, CoreChannel.SOAPMimeType, false, CultureInfo.InvariantCulture) == 0)
            {
                // deserialize the message
                retMsg = CoreChannel.DeserializeSoapResponseMessage(stream, mcm, h, _strictBinding);
            }
            else
            {
                // an error has occurred
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                StringBuilder sb = new StringBuilder();

                int readCount = stream.Read(buffer, 0, bufferSize);
                while (readCount > 0)
                {
                    sb.Append(Encoding.ASCII.GetString(buffer, 0, readCount));
                    readCount = stream.Read(buffer, 0, bufferSize);
                }
                
                retMsg = new ReturnMessage(new RemotingException(sb.ToString()), mcm);
            }

            // Close the stream since we're done with it (especially important if this
            //   happened to be a network stream)
            stream.Close();

            return retMsg;
        } // DeserializeMessage
       

        //
        // IClientChannelSink implementation
        //        
        
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.ProcessMessage"]/*' />
        public void ProcessMessage(IMessage msg,
                                   ITransportHeaders requestHeaders, Stream requestStream,
                                   out ITransportHeaders responseHeaders, out Stream responseStream)
        {
            // never gets called, this sink is always first
            throw new NotSupportedException();
        } // ProcessMessage


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.AsyncProcessRequest"]/*' />
        public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg,
                                        ITransportHeaders headers, Stream stream)
        {
            // never gets called, this sink is always first
            throw new NotSupportedException();
        } // AsyncProcessRequest


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.AsyncProcessResponse"]/*' />
        public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, Object state,
                                         ITransportHeaders headers, Stream stream)
        {
            // previously we stored the outgoing message in state
            IMethodCallMessage mcm = (IMethodCallMessage)state;  
            IMessage retMsg = DeserializeMessage(mcm, headers, stream);
            sinkStack.DispatchReplyMessage(retMsg);
        } // AsyncProcessRequest

       
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.GetRequestStream"]/*' />
        public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
        {
            // should never be called on formatter sender sink
            throw new NotSupportedException();
        } // GetRequestStream


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.NextChannelSink"]/*' />
        public IClientChannelSink NextChannelSink
        {
            get { return _nextSink; }
        } // Next
        

        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapClientFormatterSink.Properties"]/*' />
        public IDictionary Properties
        {
            get { return null; }
        } // Properties

        //
        // end of IClientChannelSink implementation
        //
        
    } // class SoapClientFormatterSink



    //
    // SERVER-SIDE SOAP FORMATTER SINKS
    //

    /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSinkProvider"]/*' />
    public class SoapServerFormatterSinkProvider : IServerFormatterSinkProvider
    {
        private IServerChannelSinkProvider _next = null;

        // settings from config
        private bool _includeVersioning = true;
        private bool _strictBinding = false;
        private TypeFilterLevel _formatterSecurityLevel = TypeFilterLevel.Low; 

        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSinkProvider.SoapServerFormatterSinkProvider"]/*' />
        public SoapServerFormatterSinkProvider()
        {
        } // SoapServerFormatterSinkProvider

        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSinkProvider.SoapServerFormatterSinkProvider1"]/*' />
        public SoapServerFormatterSinkProvider(IDictionary properties, ICollection providerData)
        {
            // look at properties
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    String keyStr = entry.Key.ToString();
                    switch (keyStr)
                    {
                    case "includeVersions": _includeVersioning = Convert.ToBoolean(entry.Value); break;
                    case "strictBinding": _strictBinding = Convert.ToBoolean(entry.Value); break;
                    case "typeFilterLevel": 
                        _formatterSecurityLevel = (TypeFilterLevel) Enum.Parse(typeof(TypeFilterLevel), (string)entry.Value); 
                        break;
                    default:
                        break;
                    }
                }
            }
            
            // not expecting any provider data
            CoreChannel.VerifyNoProviderData(this.GetType().Name, providerData);
        } // SoapServerFormatterSinkProvider
        

        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSinkProvider.GetChannelData"]/*' />
        public void GetChannelData(IChannelDataStore channelData)
        {
        } // GetChannelData
   
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSinkProvider.CreateSink"]/*' />
        public IServerChannelSink CreateSink(IChannelReceiver channel)
        {
            if(null == channel)
            {
                throw new ArgumentNullException("channel");               
            }

            IServerChannelSink nextSink = null;
            if (_next != null)
                nextSink = _next.CreateSink(channel);

            SoapServerFormatterSink.Protocol protocol = 
                SoapServerFormatterSink.Protocol.Other;

            // see if this is an http channel
            String uri = channel.GetUrlsForUri("")[0];
            if (String.Compare("http", 0, uri, 0, 4, true, CultureInfo.InvariantCulture) == 0)
                protocol = SoapServerFormatterSink.Protocol.Http;  

            SoapServerFormatterSink sink = new SoapServerFormatterSink(protocol, nextSink, channel);
            sink.IncludeVersioning = _includeVersioning;
            sink.StrictBinding = _strictBinding;
            sink.TypeFilterLevel = _formatterSecurityLevel;
            return sink;
        }

        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSinkProvider.Next"]/*' />
        public IServerChannelSinkProvider Next
        {
            get { return _next; }
            set { _next = value; }
        } 
        
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSinkProvider.TypeFilterLevel"]/*' />
        [System.Runtime.InteropServices.ComVisible(false)]
        public TypeFilterLevel TypeFilterLevel {
            get {
                return _formatterSecurityLevel;
            }
            
            set {
                _formatterSecurityLevel = value;
            }
        }
        
    } // class SoapServerFormatterSinkProvider
    

    /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink"]/*' />
    public class SoapServerFormatterSink : IServerChannelSink
    {
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="Protocol"]/*' />
		[Serializable]
        public enum Protocol
        {
            /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="Protocol.Http"]/*' />
            Http, // special processing needed for http
            /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="Protocol.Other"]/*' />
            Other
        }
        
    
        private IServerChannelSink _nextSink; // If this sink doesn't recognize, the incoming
                                              //   format then he should call the next
                                              //   sink if there is one.

        private Protocol _protocol; // transport protocol being used
        
        private IChannelReceiver _receiver; // transport sink used to parse url

        private bool _includeVersioning = true; // should versioning be used
        private bool _strictBinding = false;  // should strict binding be used
        private TypeFilterLevel _formatterSecurityLevel = TypeFilterLevel.Low;     
    
    
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink.SoapServerFormatterSink"]/*' />
        public SoapServerFormatterSink(Protocol protocol, IServerChannelSink nextSink,
                                       IChannelReceiver receiver)
        {                            
            if (receiver == null)
                throw new ArgumentNullException("receiver");

            _nextSink = nextSink;
            _protocol = protocol;
            _receiver = receiver;
        } // SoapServerFormatterSinkProvider


        internal bool IncludeVersioning
        {
            set { _includeVersioning = value; }
        } // IncludeVersioning

        internal bool StrictBinding
        {
            set { _strictBinding = value; }
        } // StrictBinding


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink.TypeFilterLevel"]/*' />
        [System.Runtime.InteropServices.ComVisible(false)]
        public TypeFilterLevel TypeFilterLevel {
            get {
                return _formatterSecurityLevel;
            }
            
            set {
                _formatterSecurityLevel = value;
            }
        }
        
        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink.ProcessMessage"]/*' />
        public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
            IMessage requestMsg,
            ITransportHeaders requestHeaders, Stream requestStream,
            out IMessage responseMsg, out ITransportHeaders responseHeaders, 
            out Stream responseStream)
        {
            if (requestMsg != null)
            {
                // The message has already been deserialized so delegate to the next sink.
                return _nextSink.ProcessMessage(
                    sinkStack,
                    requestMsg, requestHeaders, requestStream, 
                    out responseMsg, out responseHeaders, out responseStream);
            }
        
            if (requestHeaders ==  null)
                throw new ArgumentNullException("requestHeaders");
            BaseTransportHeaders wkRequestHeaders = requestHeaders as BaseTransportHeaders;
        
            ServerProcessing processing;        

            responseHeaders = null;
            responseStream = null;

            String verb = null;
            String contentType = null;

            bool bCanServiceRequest = true;

            // determine the content type
            String contentTypeHeader = null;
            if (wkRequestHeaders != null)
                contentTypeHeader = wkRequestHeaders.ContentType;
            else
                contentTypeHeader = requestHeaders["Content-Type"] as String;
            if (contentTypeHeader != null)
            {
            String charsetValue;
            HttpChannelHelper.ParseContentType(contentTypeHeader,
                                               out contentType, out charsetValue);
            }
            
            // check to see if Content-Type matches
            if ((contentType != null) &&
                (String.Compare(contentType, CoreChannel.SOAPMimeType, false, CultureInfo.InvariantCulture) != 0))
            {
                bCanServiceRequest = false;                
            }

            // check for http specific verbs
            if (_protocol == Protocol.Http)
            {                
                verb = (String)requestHeaders["__RequestVerb"];
                if (!verb.Equals("POST") && !verb.Equals("M-POST"))
                    bCanServiceRequest = false;
            }

            // either delegate or return an error message if we can't service the request
            if (!bCanServiceRequest)
                {
                    // delegate to next sink if available
                    if (_nextSink != null)
                    {
                        return _nextSink.ProcessMessage(sinkStack, null, requestHeaders, requestStream,   
                            out responseMsg, out responseHeaders, out responseStream);
                    }
                    else
                    {
                    // send back an error message
                    if (_protocol == Protocol.Http)
                    {
                        // return a client bad request error     
                        responseHeaders = new TransportHeaders();
                        responseHeaders["__HttpStatusCode"] = "400";
                        responseHeaders["__HttpReasonPhrase"] = "Bad Request";
                        responseStream = null;
                        responseMsg = null;
                        return ServerProcessing.Complete;
                    }
                    else
                    {
                        // The transport sink will catch this and do something here.
                        throw new RemotingException(
                            CoreChannel.GetResourceString("Remoting_Channels_InvalidRequestFormat"));
                    }
                }
            }
            
            bool bClientIsClr = true;
            try
            {
                String objectUri = null;
                if (wkRequestHeaders != null)
                    objectUri = wkRequestHeaders.RequestUri;
                else
                    objectUri = (String)requestHeaders[CommonTransportKeys.RequestUri];              
                
                if (RemotingServices.GetServerTypeForUri(objectUri) == null)
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_ChnlSink_UriNotPublished"));
                
                
                if (_protocol == Protocol.Http)
                {
                    String userAgent = (String)requestHeaders["User-Agent"];
                    if (userAgent != null)
                    {                       
                        if (userAgent.IndexOf("MS .NET Remoting") == -1)
                        {
                            // user agent string did not contain ".NET Remoting", so it is someone else
                            bClientIsClr = false;
                        }
                    }
                    else
                    {
                        bClientIsClr = false;
                    }
                }

                bool bIsCustomErrorEnabled = true;
                object oIsCustomErrorEnabled = requestHeaders["__CustomErrorsEnabled"];
                if (oIsCustomErrorEnabled != null && oIsCustomErrorEnabled is bool){
                    bIsCustomErrorEnabled = (bool)oIsCustomErrorEnabled;
                }
                CallContext.SetData("__CustomErrorsEnabled", bIsCustomErrorEnabled);                
                
                String soapActionToVerify;                
                Header[] h = GetChannelHeaders(requestHeaders, out soapActionToVerify);                                    
                PermissionSet currentPermissionSet = null;
                if (this.TypeFilterLevel != TypeFilterLevel.Full) {
                    currentPermissionSet = new PermissionSet(PermissionState.None);                
                    currentPermissionSet.SetPermission(new SecurityPermission(SecurityPermissionFlag.SerializationFormatter));                    
                }
                                    
                try {
                    if (currentPermissionSet != null) 
                        currentPermissionSet.PermitOnly();                                                                    

                    // Deserialize Request - Stream to IMessage                                        
                    requestMsg = CoreChannel.DeserializeSoapRequestMessage(requestStream, h, _strictBinding, this.TypeFilterLevel);
                }
                finally {
                    if (currentPermissionSet != null)
                        CodeAccessPermission.RevertPermitOnly();
                }
                
                requestStream.Close();

                if(requestMsg == null)
                {
                    throw new RemotingException(CoreChannel.GetResourceString("Remoting_DeserializeMessage"));
                }

                // verify soap action if necessary
                if ((soapActionToVerify != null) &&
                    (!SoapServices.IsSoapActionValidForMethodBase(
                        soapActionToVerify, ((IMethodMessage)requestMsg).MethodBase)))
                {
                    throw new RemotingException(
                        String.Format(
                            CoreChannel.GetResourceString("Remoting_Soap_InvalidSoapAction"),
                            soapActionToVerify)
                        );
                }                
             
                // Dispatch Call
                sinkStack.Push(this, null);                                                
                
                processing = 
                    _nextSink.ProcessMessage(sinkStack, requestMsg, requestHeaders, null,
                        out responseMsg, out responseHeaders, out responseStream);
                // make sure that responseStream is null
                if (responseStream != null)
                {
                    throw new RemotingException(
                        CoreChannel.GetResourceString("Remoting_ChnlSink_WantNullResponseStream"));
                }
                
                switch (processing)
                {

                case ServerProcessing.Complete:
                {
                    if (responseMsg == null)
                        throw new RemotingException(CoreChannel.GetResourceString("Remoting_DispatchMessage"));

                    sinkStack.Pop(this);

                    SerializeResponse(sinkStack, responseMsg, bClientIsClr,
                                      ref responseHeaders, out responseStream);
                    break;
                } // case ServerProcessing.Complete

                case ServerProcessing.OneWay:
                {
                    sinkStack.Pop(this);
                    break;
                } // case ServerProcessing.OneWay:

                case ServerProcessing.Async:
                {
                    sinkStack.Store(this, null);
                    break;   
                } // case ServerProcessing.Async
                    
                } // switch (processing)                
            }
            catch(Exception e)
            {
                processing = ServerProcessing.Complete;
                responseMsg = new ReturnMessage(e, (IMethodCallMessage)(requestMsg==null?new ErrorMessage():requestMsg));
                //TODO, sowmys: See if we could call SerializeResponse here
                CallContext.SetData("__ClientIsClr", bClientIsClr);
                responseStream = (MemoryStream)CoreChannel.SerializeSoapMessage(responseMsg, _includeVersioning);
                CallContext.FreeNamedDataSlot("__ClientIsClr");
                responseStream.Position = 0;
                responseHeaders = new TransportHeaders();

                if (_protocol == Protocol.Http)
                {
                    responseHeaders["__HttpStatusCode"] = "500";
                    responseHeaders["__HttpReasonPhrase"] = "Internal Server Error";
                    responseHeaders["Content-Type"] = CoreChannel.SOAPContentType;
                }
            }
            finally{
                CallContext.FreeNamedDataSlot("__CustomErrorsEnabled");
            }

            return processing;
        } // ProcessMessage


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink.AsyncProcessResponse"]/*' />
        public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                         IMessage msg, ITransportHeaders headers, Stream stream)
        {
            // FUTURE: When async dispatching is enabled in V.Next, we will need to
            //   carry over bClientIsClr info.
            SerializeResponse(sinkStack, msg, true, ref headers, out stream);
            sinkStack.AsyncProcessResponse(msg, headers, stream);
        } // AsyncProcessResponse


        private void SerializeResponse(IServerResponseChannelSinkStack sinkStack,
                                       IMessage msg, bool bClientIsClr, ref ITransportHeaders headers,
                                       out Stream stream)
        {
            BaseTransportHeaders responseHeaders = new BaseTransportHeaders();
            if (headers != null)
            {
                // copy old headers into new headers
                foreach (DictionaryEntry entry in headers)
                {
                    responseHeaders[entry.Key] = entry.Value;
                }
            }  
            headers = responseHeaders;
            responseHeaders.ContentType = CoreChannel.SOAPContentType;

            if (_protocol == Protocol.Http)
            {
                // check to see if an exception occurred (requires special status code for HTTP)
                IMethodReturnMessage mrm = msg as IMethodReturnMessage;
                if ((mrm != null) && (mrm.Exception != null))
                {
                    headers["__HttpStatusCode"] = "500";
                    headers["__HttpReasonPhrase"] = "Internal Server Error";
                }                
            }

            bool bMemStream = false;
            stream = sinkStack.GetResponseStream(msg, headers);
            if (stream == null)
            {
                stream = new ChunkedMemoryStream(CoreChannel.BufferPool);
                bMemStream = true;
            }


            bool bBashUrl = CoreChannel.SetupUrlBashingForIisSslIfNecessary();            
            CallContext.SetData("__ClientIsClr", bClientIsClr);
            try
            {
                CoreChannel.SerializeSoapMessage(msg, stream, _includeVersioning);           
            }
            finally
            {            
                CallContext.FreeNamedDataSlot("__ClientIsClr");
                CoreChannel.CleanupUrlBashingForIisSslIfNecessary(bBashUrl);
            }

            if (bMemStream)               
                stream.Position = 0;
        } // SerializeResponse


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink.GetResponseStream"]/*' />
        public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                        IMessage msg, ITransportHeaders headers)
        {
            // We don't need to implement this because it will never be called.
            throw new NotSupportedException();
        } // GetResponseStream


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink.NextChannelSink"]/*' />
        public IServerChannelSink NextChannelSink
        {
            get { return _nextSink; }
        }


        /// <include file='doc\SoapFormatterSinks.uex' path='docs/doc[@for="SoapServerFormatterSink.Properties"]/*' />
        public IDictionary Properties
        {
            get { return null; }
        } // Properties


        // Helper method for analyzing headers
        private Header[] GetChannelHeaders(ITransportHeaders requestHeaders, 
                                           out String soapActionToVerify)
        {
            soapActionToVerify = null;

            // transport sink removes any channel specific information
            String objectURI = (String)requestHeaders[CommonTransportKeys.RequestUri];        

            // see if a unique SOAPAction is present (if more than one SOAPAction is present some
            //   scenarios won't work, but one-many soap action to method base relationships are
            //   for interop scenarios only)
            String soapAction = (String) requestHeaders["SOAPAction"];
            if (soapAction == null)
                throw new RemotingException(CoreChannel.GetResourceString("Remoting_SoapActionMissing"));
            soapAction = HttpEncodingHelper.DecodeUri(soapAction);                

            soapActionToVerify = soapAction;
            
            String typeName, methodName;
            if (!SoapServices.GetTypeAndMethodNameFromSoapAction(soapAction, out typeName, out methodName))
            {
                // This means there are multiple methods for this soap action, so we will have to
                // settle for the type based off of the uri.
                Type type = RemotingServices.GetServerTypeForUri(objectURI);
                if (type == null)
                {
                    throw new RemotingException(                        
                        String.Format(
                            CoreChannel.GetResourceString(
                                "Remoting_TypeNotFoundFromUri"), objectURI));                
                }
                typeName = "clr:" + type.FullName + ", " + type.Module.Assembly.GetName().Name;
            }
            else
            {
                typeName = "clr:" + typeName;
            }
                         
            // Create a new header array and pass it back.
            int headerLen = 2;
            Header[] h = new Header[headerLen];
            h[0] = new Header("__Uri", objectURI);
            h[1] = new Header("__TypeName", typeName);

            return h;
        } // GetChannelHeaders
        
        
    } // class SoapServerFormatterSink



} // namespace System.Runtime.Remoting.Channnels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\tcpclientchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//===========================================================================
//  File:       TcpClientChannel.cs
//
//  Summary:    Implements a channel that transmits method calls over TCP.
//
//==========================================================================

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Threading;


namespace System.Runtime.Remoting.Channels.Tcp
{

    /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel"]/*' />
    public class TcpClientChannel : IChannelSender
    {
        private int    _channelPriority = 1;  // channel priority
        private String _channelName = "tcp"; // channel name
        
        private IClientChannelSinkProvider _sinkProvider = null; // sink chain provider
        

        /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel.TcpClientChannel"]/*' />
        public TcpClientChannel()
        {
            SetupChannel();        
        } // TcpClientChannel


        /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel.TcpClientChannel1"]/*' />
        public TcpClientChannel(String name, IClientChannelSinkProvider sinkProvider)
        {
            _channelName = name;
            _sinkProvider = sinkProvider;

            SetupChannel();
        }


        // constructor used by config file
        /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel.TcpClientChannel2"]/*' />
        public TcpClientChannel(IDictionary properties, IClientChannelSinkProvider sinkProvider)
        {
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    switch ((String)entry.Key)
                    {
                    case "name": _channelName = (String)entry.Value; break;
                    case "priority": _channelPriority = Convert.ToInt32(entry.Value); break;

                    default: 
                        break;   
                    }
                }
            }

            _sinkProvider = sinkProvider;

            SetupChannel();
        } // TcpClientChannel


        private void SetupChannel()
        {
            if (_sinkProvider != null)
            {
                CoreChannel.AppendProviderToClientProviderChain(
                    _sinkProvider, new TcpClientTransportSinkProvider());                                                
            }
            else
                _sinkProvider = CreateDefaultClientProviderChain();
        } // SetupChannel


        //
        // IChannel implementation
        //

        /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get { return _channelPriority; }    
        }

        /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel.ChannelName"]/*' />
        public String ChannelName
        {
            get { return _channelName; }
        }

        // returns channelURI and places object uri into out parameter
        /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {            
            return TcpChannelHelper.ParseURL(url, out objectURI);
        } // Parse

        //
        // end of IChannel implementation
        // 



        //
        // IChannelSender implementation
        //

        /// <include file='doc\TcpClientChannel.uex' path='docs/doc[@for="TcpClientChannel.CreateMessageSink"]/*' />
        public virtual IMessageSink CreateMessageSink(String url, Object remoteChannelData, out String objectURI)
        {
            // Set the out parameters
            objectURI = null;
            String channelURI = null;

            
            if (url != null) // Is this a well known object?
            {
                // Parse returns null if this is not one of our url's
                channelURI = Parse(url, out objectURI);
            }
            else // determine if we want to connect based on the channel data
            {
                if (remoteChannelData != null)
                {
                    if (remoteChannelData is IChannelDataStore)
                    {
                        IChannelDataStore cds = (IChannelDataStore)remoteChannelData;

                        // see if this is an tcp uri
                        String simpleChannelUri = Parse(cds.ChannelUris[0], out objectURI);
                        if (simpleChannelUri != null)
                            channelURI = cds.ChannelUris[0];
                    }
                }
            }

            if (null != channelURI)
            {
                if (url == null)
                    url = channelURI;

                IClientChannelSink sink = _sinkProvider.CreateSink(this, url, remoteChannelData);
                
                // return sink after making sure that it implements IMessageSink
                IMessageSink msgSink = sink as IMessageSink;
                if ((sink != null) && (msgSink == null))
                {
                    throw new RemotingException(
                        CoreChannel.GetResourceString(
                            "Remoting_Channels_ChannelSinkNotMsgSink"));
                }
                    
                return msgSink;           
            }

            return null;
        } // CreateMessageSink


        //
        // end of IChannelSender implementation
        //

        private IClientChannelSinkProvider CreateDefaultClientProviderChain()
        {
            IClientChannelSinkProvider chain = new BinaryClientFormatterSinkProvider();            
            IClientChannelSinkProvider sink = chain;
            
            sink.Next = new TcpClientTransportSinkProvider();
            
            return chain;
        } // CreateDefaultClientProviderChain

    } // class TcpClientChannel




    internal class TcpClientTransportSinkProvider : IClientChannelSinkProvider
    {
        internal TcpClientTransportSinkProvider()
        {
        }    
   
        public IClientChannelSink CreateSink(IChannelSender channel, String url, 
                                             Object remoteChannelData)
        {
            // url is set to the channel uri in CreateMessageSink        
            return new TcpClientTransportSink(url);
        }

        public IClientChannelSinkProvider Next
        {
            get { return null; }
            set { throw new NotSupportedException(); }
        }
    } // class TcpClientTransportSinkProvider



    internal class TcpClientTransportSink : IClientChannelSink
    {
        // socket cache
        internal static SocketCache ClientSocketCache = 
            new SocketCache(new SocketHandlerFactory(TcpClientTransportSink.CreateSocketHandler));

        private static SocketHandler CreateSocketHandler(
            Socket socket, SocketCache socketCache, String machineAndPort)
        {
            return new TcpClientSocketHandler(socket, machineAndPort);
        } // CreateSocketHandler

        
        // transport sink state
        private String m_machineName;
        private int    m_port;

        private String _machineAndPort;


        internal TcpClientTransportSink(String channelURI)
        {
            String objectURI;
            String simpleChannelUri = TcpChannelHelper.ParseURL(channelURI, out objectURI);
        
            // extract machine name and port
            int start = simpleChannelUri.IndexOf("://");
            start += 3;
            int index = simpleChannelUri.IndexOf(':', start);
            if (index == -1)
            {
                // If there is no colon, then there is no port number.
                throw new RemotingException(
                    String.Format(  
                        CoreChannel.GetResourceString(
                            "Remoting_Tcp_UrlMustHavePort"),
                        channelURI));
            }
            
            m_machineName = simpleChannelUri.Substring(start, index - start);            
            m_port = Int32.Parse(simpleChannelUri.Substring(index + 1));

            _machineAndPort = m_machineName + ":" + m_port;
        } // TcpClientTransportSink


        public void ProcessMessage(IMessage msg,
                                   ITransportHeaders requestHeaders, Stream requestStream,
                                   out ITransportHeaders responseHeaders, out Stream responseStream)
        {
            InternalRemotingServices.RemotingTrace("TcpClientTransportSink::ProcessMessage");

            TcpClientSocketHandler clientSocket = 
                SendRequestWithRetry(msg, requestHeaders, requestStream);

            // receive response
            responseHeaders = clientSocket.ReadHeaders();
            responseStream = clientSocket.GetResponseStream();    

            // The client socket will be returned to the cache
            //   when the response stream is closed.
            
        } // ProcessMessage


        public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg,
                                        ITransportHeaders headers, Stream stream)
        {
            InternalRemotingServices.RemotingTrace("TcpClientTransportSink::AsyncProcessRequest");
        
            TcpClientSocketHandler clientSocket = 
                SendRequestWithRetry(msg, headers, stream);

            if (clientSocket.OneWayRequest)
            {
                clientSocket.ReturnToCache();
            }
            else
            {
                // do an async read on the reply
                clientSocket.DataArrivedCallback = new WaitCallback(this.ReceiveCallback);
                clientSocket.DataArrivedCallbackState = sinkStack;
                clientSocket.BeginReadMessage();
            }
        } // AsyncProcessRequest


        public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, Object state,
                                         ITransportHeaders headers, Stream stream)
        {
            // We don't have to implement this since we are always last in the chain.
            throw new NotSupportedException();
        } // AsyncProcessRequest
        

        
        public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
        {
            // Currently, we require a memory stream be handed to us since we need
            //   the length before sending.      
            return null; 
        } // GetRequestStream


        public IClientChannelSink NextChannelSink
        {
            get { return null; }
        } // Next


        private TcpClientSocketHandler SendRequestWithRetry(IMessage msg, 
                                                            ITransportHeaders requestHeaders,
                                                            Stream requestStream)
        {
            // If the stream is seekable, we can retry once on a failure to write.
            long initialPosition = 0;
            bool bCanSeek = requestStream.CanSeek;
            if (bCanSeek)
                initialPosition = requestStream.Position;

            TcpClientSocketHandler clientSocket = null;
            try
            {
                clientSocket = (TcpClientSocketHandler)ClientSocketCache.GetSocket(_machineAndPort);
                clientSocket.SendRequest(msg, requestHeaders, requestStream);
            }
            catch (SocketException)
            {
                // retry sending if possible
                if (bCanSeek)
                {
                    // reset position...
                    requestStream.Position = initialPosition;

                    // ...and try again.
                    clientSocket = (TcpClientSocketHandler)
                        ClientSocketCache.GetSocket(_machineAndPort);
                        
                    clientSocket.SendRequest(msg, requestHeaders, requestStream);
                }
            }

            requestStream.Close();

            return clientSocket;
        } // SendRequestWithRetry


        private void ReceiveCallback(Object state)
        {   
            TcpClientSocketHandler clientSocket = null;
            IClientChannelSinkStack sinkStack = null;
                
            try            
            {
                clientSocket = (TcpClientSocketHandler)state;
                sinkStack = (IClientChannelSinkStack)clientSocket.DataArrivedCallbackState;
            
                ITransportHeaders responseHeaders = clientSocket.ReadHeaders();
                Stream responseStream = clientSocket.GetResponseStream(); 
                
                // call down the sink chain
                sinkStack.AsyncProcessResponse(responseHeaders, responseStream);
            }
            catch (Exception e)
            {
                try
                {
                    if (sinkStack != null)
                        sinkStack.DispatchException(e);
                }
                catch(Exception )
                {
                    // Fatal Error.. ignore
                }
            }

            // The client socket will be returned to the cache
            //   when the response stream is closed.
            
        } // ReceiveCallback
                


        //
        // Properties
        //

        public IDictionary Properties
        {
            get 
            {
                return null;
            }
        } // Properties

        //
        // end of Properties
        //

    } // class TcpClientTransportSink



} // namespace namespace System.Runtime.Remoting.Channels.Tcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\tcpsocketmanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       TcpSocketManager.cs
//
//  Summary:    Provides a base for the client and server tcp socket 
//              managers.
//
//==========================================================================


using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Threading;


namespace System.Runtime.Remoting.Channels.Tcp
{

    // A client socket manager instance should encapsulate the socket
    //   for the purpose of reading a response
    internal abstract class TcpSocketHandler : SocketHandler
    {            
        private static byte[] s_protocolPreamble = Encoding.ASCII.GetBytes(".NET");
        private static byte[] s_protocolVersion1_0 = new byte[]{1,0};


        public TcpSocketHandler(Socket socket) : this(socket, null)
        {          
        } // TcpSocketHandler    
    
        public TcpSocketHandler(Socket socket, RequestQueue requestQueue) : base(socket, requestQueue)
        {          
        } // TcpSocketHandler    


        private void ReadAndMatchPreamble()
        {
            // make sure that the incoming data starts with the preamble
            InternalRemotingServices.RemotingAssert(
                s_protocolPreamble.Length == 4, 
                "The preamble is supposed to be 4 bytes ('.NET'). Somebody changed it...");

            if (ReadAndMatchFourBytes(s_protocolPreamble) == false)
            {
                throw new RemotingException(
                    CoreChannel.GetResourceString("Remoting_Tcp_ExpectingPreamble"));
            }
        } // ReadAndMatchPreamble

        protected void WritePreambleAndVersion(Stream outputStream)
        {
            outputStream.Write(s_protocolPreamble, 0, s_protocolPreamble.Length);
            outputStream.Write(s_protocolVersion1_0, 0, s_protocolVersion1_0.Length);
        } // WritePreamble


        protected void ReadVersionAndOperation(out UInt16 operation)
        {
            // check for the preamble
            ReadAndMatchPreamble();
        
            // Check the version number.
            byte majorVersion = (byte)ReadByte();
            byte minorVersion = (byte)ReadByte();
            if ((majorVersion != 1) || (minorVersion != 0))
            {
                throw new RemotingException(
                    String.Format(
                        CoreChannel.GetResourceString("Remoting_Tcp_UnknownProtocolVersion"),
                        majorVersion.ToString() + "." + minorVersion.ToString()));
            }

            // Read the operation
            operation = ReadUInt16();

        } // ReadVersionAndOperation


        protected void ReadContentLength(out bool chunked, out int contentLength)
        {        
            contentLength = -1;
        
            UInt16 header = ReadUInt16();
            if (header == TcpContentDelimiter.Chunked)
            {
                chunked = true;
            }
            else
            if (header == TcpContentDelimiter.ContentLength)
            {
                chunked = false;
                contentLength = ReadInt32();
            }
            else
            {
                throw new RemotingException(
                    String.Format(
                        CoreChannel.GetResourceString("Remoting_Tcp_ExpectingContentLengthHeader"),
                        header.ToString()));
                    
            }            
        } // ReadContentLength 


        protected void ReadToEndOfHeaders(BaseTransportHeaders headers)
        {
            bool bError = false;
            String statusPhrase = null; 
        
            UInt16 headerType = ReadUInt16();
            while (headerType != TcpHeaders.EndOfHeaders)
            {
                if (headerType == TcpHeaders.Custom)
                {
                    String headerName = ReadCountedString();
                    String headerValue = ReadCountedString();

                    headers[headerName] = headerValue;
                }
                else
                if (headerType == TcpHeaders.RequestUri)
                {         
                    ReadAndVerifyHeaderFormat("RequestUri", TcpHeaderFormat.CountedString);
                
                    // read uri (and make sure that no channel specific data is present)
                    String uri = ReadCountedString();
                    
                    String channelURI;
                    String objectURI;
                    channelURI = TcpChannelHelper.ParseURL(uri, out objectURI);
                    if (channelURI == null)
                        objectURI = uri;              
            
                    headers.RequestUri = objectURI;
                }
                else
                if (headerType == TcpHeaders.StatusCode)
                {
                    ReadAndVerifyHeaderFormat("StatusCode", TcpHeaderFormat.UInt16);
                    
                    UInt16 statusCode = ReadUInt16();
                    // We'll throw an exception here if there was an error. If an error
                    //   occurs above the transport level, the status code will still be
                    //   success here.
                    if (statusCode != TcpStatusCode.Success)
                        bError = true;
                }
                else
                if (headerType == TcpHeaders.StatusPhrase)
                {
                    ReadAndVerifyHeaderFormat("StatusPhrase", TcpHeaderFormat.CountedString);
                
                    statusPhrase = ReadCountedString();
                }
                else
                if (headerType == TcpHeaders.ContentType)
                {
                    ReadAndVerifyHeaderFormat("Content-Type", TcpHeaderFormat.CountedString);
                
                    String contentType = ReadCountedString();
                    headers.ContentType = contentType;
                }
                else
                {
                    // unknown header: Read header format and ignore rest of data
                    byte headerFormat = (byte)ReadByte();

                    switch (headerFormat)
                    {
                    case TcpHeaderFormat.Void: break;
                    case TcpHeaderFormat.CountedString: ReadCountedString(); break;
                    case TcpHeaderFormat.Byte: ReadByte(); break;
                    case TcpHeaderFormat.UInt16: ReadUInt16(); break;
                    case TcpHeaderFormat.Int32: ReadInt32(); break;

                    default:
                    {
                        // unknown format
                        throw new RemotingException(
                            String.Format(
                                CoreChannel.GetResourceString("Remoting_Tcp_UnknownHeaderType"),
                                headerType, headerFormat));
                    }
                    
                    } // switch (format)
                
                }

                // read next header token
                headerType = ReadUInt16();
            } // loop until end of headers         

            // if an error occurred, throw an exception
            if (bError)
            {
                if (statusPhrase == null)
                    statusPhrase = "";
                    
                throw new RemotingException(
                    String.Format(
                        CoreChannel.GetResourceString("Remoting_Tcp_GenericServerError"),
                        statusPhrase));
            }
        } // ReadToEndOfHeaders


        protected void WriteHeaders(ITransportHeaders headers, Stream outputStream)
        {
            IEnumerator it = null;
            BaseTransportHeaders wkHeaders = headers as BaseTransportHeaders;

            if (wkHeaders != null)
            {
                // write out well known headers
                //   NOTE: RequestUri is written out elsewhere.
            
                if (wkHeaders.ContentType != null)
                {
                    WriteContentTypeHeader(wkHeaders.ContentType, outputStream);
                }

                it = wkHeaders.GetOtherHeadersEnumerator();
            }
            else
            {
                it = headers.GetEnumerator();
            }

        
            // write custom headers
            if (it != null)
            {
                while (it.MoveNext())
                {
                    DictionaryEntry header = (DictionaryEntry)it.Current;
            
                    String headerName = (String)header.Key;

                    if (!StringHelper.StartsWithDoubleUnderscore(headerName)) // exclude special headers
                    {
                        String headerValue = header.Value.ToString();

                        if (wkHeaders == null)
                        {
                            if (String.Compare(headerName, "Content-Type", true, CultureInfo.InvariantCulture) == 0)
                            {
                                WriteContentTypeHeader(headerValue, outputStream);
                                continue;
                            }
                        }

                        WriteCustomHeader(headerName, headerValue, outputStream);
                    }                                
                } // while (it.MoveNext())            
            }

            // write EndOfHeaders token
            WriteUInt16(TcpHeaders.EndOfHeaders, outputStream);
        } // WriteHeaders


        private void WriteContentTypeHeader(String value, Stream outputStream)
        {
            WriteUInt16(TcpHeaders.ContentType, outputStream);
            WriteByte(TcpHeaderFormat.CountedString, outputStream);  
            WriteCountedString(value, outputStream);
        } // WriteContentTypeHeader

        private void WriteCustomHeader(String name, String value, Stream outputStream)
        {
            WriteUInt16(TcpHeaders.Custom, outputStream);                    
            WriteCountedString(name, outputStream);
            WriteCountedString(value, outputStream);
        } // WriteCustomHeader
        


        protected String ReadCountedString()
        {
            // strings are formatted as follows 
            // [string format (1-byte)][encoded-size (int32)][string value (encoded-size length in bytes)]
            
            byte strFormat = (byte)ReadByte();
            int strDataSize = ReadInt32();

            if (strDataSize > 0)
            {
                byte[] data = new byte[strDataSize];

                // SocketHander::Read waits until it reads all requested data
                Read(data, 0, strDataSize);

                switch (strFormat)
                {
                    case TcpStringFormat.Unicode:
                        return Encoding.Unicode.GetString(data);

                    case TcpStringFormat.UTF8:
                        return Encoding.UTF8.GetString(data);

                    default:
                        throw new RemotingException(
                            String.Format(
                                CoreChannel.GetResourceString("Remoting_Tcp_UnrecognizedStringFormat"),
                                strFormat.ToString()));
                }
            }
            else
            {
                return null;
            }
        } // ReadCountedString


        protected void WriteCountedString(String str, Stream outputStream)
        {
            // strings are formatted as follows [string length (int32)][string value (unicode)]
            int strLength = 0;
            if (str != null)
                strLength = str.Length;

            if (strLength > 0)
            {            
                byte[] strBytes = Encoding.UTF8.GetBytes(str);          

                // write string format
                WriteByte(TcpStringFormat.UTF8, outputStream);

                // write string data size
                WriteInt32(strBytes.Length, outputStream);
                
                // write string data
                outputStream.Write(strBytes, 0, strBytes.Length);  
            }
            else
            {
                // write string format
                //   (just call it Unicode (doesn't matter since there is no data))
                WriteByte(TcpStringFormat.Unicode, outputStream);
            
                // stream data size is 0.
                WriteInt32(0, outputStream);
            }
        } // WriteCountedString


        private void ReadAndVerifyHeaderFormat(String headerName, byte expectedFormat)
        {
            byte headerFormat = (byte)ReadByte();

            if (headerFormat != expectedFormat)
            {
                throw new RemotingException(
                    String.Format(
                        CoreChannel.GetResourceString("Remoting_Tcp_IncorrectHeaderFormat"),
                        expectedFormat, headerName));
            }
        } // ReadAndVerifyHeaderFormat
   
    } // TcpSocketHandler

} // namespace System.Runtime.Remoting.Channels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\tcpserverchannel.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//===========================================================================
//  File:       TcpServerChannel.cs
//
//  Summary:    Implements a channel that receives method calls over TCP.
//
//==========================================================================

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Threading;

using System.Runtime.InteropServices;


namespace System.Runtime.Remoting.Channels.Tcp
{

    /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel"]/*' />
    public class TcpServerChannel : IChannelReceiver
    {
        private int               _channelPriority = 1;  // priority of channel (default=1)
        private String            _channelName = "tcp";  // channel name
        private String            _machineName = null;   // machine name
        private int               _port = -1;            // port to listen on
        private ChannelDataStore  _channelData = null;   // channel data

        private String _forcedMachineName = null; // an explicitly configured machine name
        private bool _bUseIpAddress = true; // by default, we'll use the ip address.
        private IPAddress _bindToAddr = IPAddress.Any; // address to bind to.
        private bool _bSuppressChannelData = false;  // should we hand out null for our channel data
        
        private IServerChannelSinkProvider _sinkProvider = null;
        private TcpServerTransportSink    _transportSink = null;

        
        private ExclusiveTcpListener  _tcpListener;
        private bool                  _bExclusiveAddressUse = true;
        private Thread                _listenerThread;
        private bool                  _bListening = false;
        private Exception             _startListeningException = null; // if an exception happens on the listener thread when attempting
                                                                       //   to start listening, that will get set here.
        private AutoResetEvent  _waitForStartListening = new AutoResetEvent(false);


        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.TcpServerChannel"]/*' />
        public TcpServerChannel(int port)
        {
            _port = port;
            SetupMachineName();
            SetupChannel();
        } // TcpServerChannel
    
        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.TcpServerChannel1"]/*' />
        public TcpServerChannel(String name, int port)
        {
            _channelName =name;
            _port = port;
            SetupMachineName();
            SetupChannel();
        } // TcpServerChannel

        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.TcpServerChannel2"]/*' />
        public TcpServerChannel(String name, int port, IServerChannelSinkProvider sinkProvider)
        {
            _channelName = name;
            _port = port;
            _sinkProvider = sinkProvider;
            SetupMachineName();
            SetupChannel();
        } // TcpServerChannel


        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.TcpServerChannel3"]/*' />
        public TcpServerChannel(IDictionary properties, IServerChannelSinkProvider sinkProvider)
        {                   
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    switch ((String)entry.Key)
                    {
                    case "name": _channelName = (String)entry.Value; break;  
                    case "bindTo": _bindToAddr = IPAddress.Parse((String)entry.Value); break;
                    case "port": _port = Convert.ToInt32(entry.Value); break;
                    case "priority": _channelPriority = Convert.ToInt32(entry.Value); break;

                    case "machineName": _forcedMachineName = (String)entry.Value; break;

                    case "rejectRemoteRequests":
                    {
                        bool bReject = Convert.ToBoolean(entry.Value);
                        if (bReject)
                            _bindToAddr = IPAddress.Loopback;
                        break;
                    }
                    
                    case "suppressChannelData": _bSuppressChannelData = Convert.ToBoolean(entry.Value); break;
                    case "useIpAddress": _bUseIpAddress = Convert.ToBoolean(entry.Value); break;
                    case "exclusiveAddressUse": _bExclusiveAddressUse = Convert.ToBoolean(entry.Value); break;
                
                    default: 
                        break;
                    }
                }
            }

            _sinkProvider = sinkProvider;
            SetupMachineName();
            SetupChannel();
        } // TcpServerChannel


        private void SetupMachineName()
        {
            if (_forcedMachineName != null)
            {
                // an explicitly configured machine name was used
                _machineName = CoreChannel.DecodeMachineName(_forcedMachineName);
            }
            else
            {
                if (!_bUseIpAddress)
                    _machineName = CoreChannel.GetMachineName();
                else
                {
                    if (_bindToAddr == IPAddress.Any)
                        _machineName = CoreChannel.GetMachineIp();
                    else
                        _machineName = _bindToAddr.ToString();
                }
            }
        } // SetupMachineName



        private void SetupChannel()
        {   
            // set channel data
            // (These get changed inside of StartListening(), in the case where the listen
            //   port is 0, because we can't determine the port number until after the
            //   TcpListener starts.)
            
            _channelData = new ChannelDataStore(null);
            if (_port > 0)
            {
                _channelData.ChannelUris = new String[1];
                _channelData.ChannelUris[0] = GetChannelUri();
            }

            // set default provider (soap formatter) if no provider has been set
            if (_sinkProvider == null)
                _sinkProvider = CreateDefaultServerProviderChain();

            CoreChannel.CollectChannelDataFromServerSinkProviders(_channelData, _sinkProvider);

            // construct sink chain
            IServerChannelSink sink = ChannelServices.CreateServerChannelSinkChain(_sinkProvider, this);
            _transportSink = new TcpServerTransportSink(sink);
            
            if (_port >= 0)
            {
                // Open a TCP port and create a thread to start listening
                _tcpListener = new ExclusiveTcpListener(_bindToAddr, _port);
                ThreadStart t = new ThreadStart(this.Listen);
                _listenerThread = new Thread(t);
                _listenerThread.IsBackground = true;

                // Wait for thread to spin up
                StartListening(null);
            }
        } // SetupChannel


        private IServerChannelSinkProvider CreateDefaultServerProviderChain()
        {
            IServerChannelSinkProvider chain = new BinaryServerFormatterSinkProvider();            
            IServerChannelSinkProvider sink = chain;
            
            sink.Next = new SoapServerFormatterSinkProvider();
            
            return chain;
        } // CreateDefaultServerProviderChain


        //
        // IChannel implementation
        //

        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.ChannelPriority"]/*' />
        public int ChannelPriority
        {
            get { return _channelPriority; }
        }

        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.ChannelName"]/*' />
        public String ChannelName
        {
            get { return _channelName; }
        }

        // returns channelURI and places object uri into out parameter
        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.Parse"]/*' />
        public String Parse(String url, out String objectURI)
        {            
            return TcpChannelHelper.ParseURL(url, out objectURI);
        } // Parse

        //
        // end of IChannel implementation
        //


        //
        // IChannelReceiver implementation
        //

        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.ChannelData"]/*' />
        public Object ChannelData
        {
            get
            {
                if (_bSuppressChannelData || !_bListening)
                {
                    return null;
                }
                else
                {
                    return _channelData;
                }
            }
        } // ChannelData


        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.GetChannelUri"]/*' />
        public String GetChannelUri()
        {
            return "tcp://" + _machineName + ":" + _port;
        } // GetChannelUri


        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.GetUrlsForUri"]/*' />
        public virtual String[] GetUrlsForUri(String objectUri)
        {
            String[] retVal = new String[1];

            if (!objectUri.StartsWith("/"))
                objectUri = "/" + objectUri;
            retVal[0] = GetChannelUri() + objectUri;

            return retVal;
        } // GetURLsforURI


        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.StartListening"]/*' />
        public void StartListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("HTTPChannel.StartListening");

            if (_port >= 0)
            {
                if (_listenerThread.IsAlive == false)
                {
                    _listenerThread.Start();
                    _waitForStartListening.WaitOne(); // listener thread will signal this after starting TcpListener

                    if (_startListeningException != null)
                    {
                        // An exception happened when we tried to start listening (such as "socket already in use)
                        Exception e = _startListeningException;
                        _startListeningException = null;
                        throw e;
                    }

                    _bListening = true;

                    // get new port assignment if a port of 0 was used to auto-select a port
                    if (_port == 0)
                    {
                        _port = ((IPEndPoint)_tcpListener.LocalEndpoint).Port;
                        if (_channelData != null)
                        {
                            _channelData.ChannelUris = new String[1];
                            _channelData.ChannelUris[0] = GetChannelUri();
                        }
                    }
                }
            }
        } // StartListening


        /// <include file='doc\TcpServerChannel.uex' path='docs/doc[@for="TcpServerChannel.StopListening"]/*' />
        public void StopListening(Object data)
        {
            InternalRemotingServices.RemotingTrace("HTTPChannel.StopListening");

            if (_port > 0)
            {
                _bListening = false;

                // Ask the TCP listener to stop listening on the port
                if(null != _tcpListener)
                {
                    _tcpListener.Stop();
                }
            }
        } // StopListening

        //
        // end of IChannelReceiver implementation
        //


        //
        // Server helpers
        //

        // Thread for listening
        void Listen()
        {
            bool bOkToListen = false;
        
            try
            {
                _tcpListener.Start(_bExclusiveAddressUse);
                bOkToListen = true;
            }
            catch (Exception e)
            {
                _startListeningException = e;
            }   

            _waitForStartListening.Set(); // allow main thread to continue now that we have tried to start the socket

            InternalRemotingServices.RemotingTrace( "Waiting to Accept the Socket on Port: " + _port);

            //
            // Wait for an incoming socket
            //
            Socket socket;

            while (bOkToListen)
            {
                InternalRemotingServices.RemotingTrace("TCPChannel::Listen - tcpListen.Pending() == true");

                try
                {
                    socket = _tcpListener.AcceptSocket();

                    if (socket == null)
                    {
                        throw new RemotingException(
                            String.Format(
                                CoreChannel.GetResourceString("Remoting_Socket_Accept"),
                                Marshal.GetLastWin32Error().ToString()));
                    }                
                
                    // disable nagle delay
                    socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, 1);

                    // set linger option
                    LingerOption lingerOption = new LingerOption(true, 3);
                    socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, lingerOption);
                
                    TcpServerSocketHandler streamManager = new TcpServerSocketHandler(socket, CoreChannel.RequestQueue);
                    streamManager.DataArrivedCallback = new WaitCallback(_transportSink.ServiceRequest);
                    streamManager.BeginReadMessage();
                }
                catch (Exception e)
                {
                    if (!_bListening)
                    {
                        // We called Stop() on the tcp listener, so gracefully exit.
                        bOkToListen = false;                        
                    }
                    else
                    {
                        // we want the exception to show up as unhandled since this
                        //   is an unexpected failure.
                        if (!(e is SocketException))
                        {
                            // FUTURE: Add an internal exception reporting system, so
                            //   that failures won't be masked. For release builds, we
                            //   really don't want to let the listener thread die.
                            //throw;                      
                        }
                    }
                }
            }
        }

    } // class TcpServerChannel



    internal class TcpServerTransportSink : IServerChannelSink
    {
        //private const int _defaultChunkSize = 4096;
        private const int s_MaxSize =  (2 << 24); // Max size of the payload

        // sink state
        private IServerChannelSink _nextSink;


        public TcpServerTransportSink(IServerChannelSink nextSink)
        {
            _nextSink = nextSink;
        } // TcpServerTransportSink
        
    
        internal void ServiceRequest(Object state)
        {
            TcpServerSocketHandler streamManager = (TcpServerSocketHandler)state;

            ITransportHeaders headers = streamManager.ReadHeaders();
            Stream requestStream = streamManager.GetRequestStream();
            RemotingServices.LogRemotingStage(CoreChannel.SERVER_MSG_RECEIVE);
            headers["__CustomErrorsEnabled"] = streamManager.CustomErrorsEnabled();

            // process request
            ServerChannelSinkStack sinkStack = new ServerChannelSinkStack();
            sinkStack.Push(this, streamManager);

            IMessage responseMessage;
            ITransportHeaders responseHeaders;
            Stream responseStream;

            ServerProcessing processing = 
                _nextSink.ProcessMessage(sinkStack, null, headers, requestStream, 
                                         out responseMessage,
                                         out responseHeaders, out responseStream);

            // handle response
            switch (processing)
            {                    

            case ServerProcessing.Complete:
            {
                // Send the response. Call completed synchronously.
                sinkStack.Pop(this);
                RemotingServices.LogRemotingStage(CoreChannel.SERVER_RET_END);
                streamManager.SendResponse(responseHeaders, responseStream);
                break;
            } // case ServerProcessing.Complete
            
            case ServerProcessing.OneWay:
            {                       
                // No response needed, but the following method will make sure that
                //   we send at least a skeleton reply if the incoming request was
                //   not marked OneWayRequest (client/server metadata could be out of
                //   sync).
                streamManager.SendResponse(responseHeaders, responseStream);
                break;
            } // case ServerProcessing.OneWay

            case ServerProcessing.Async:
            {
                sinkStack.StoreAndDispatch(this, streamManager);
                break;
            }// case ServerProcessing.Async

            } // switch (processing) 
                   

            // async processing will take care if handling this later
            if (processing != ServerProcessing.Async)
            {
                if (streamManager.CanServiceAnotherRequest())
                    streamManager.BeginReadMessage();
                else
                    streamManager.Close();
            }
            
        } // ServiceRequest               


        //
        // IServerChannelSink implementation
        //

        public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
            IMessage requestMsg,
            ITransportHeaders requestHeaders, Stream requestStream,
            out IMessage responseMsg, out ITransportHeaders responseHeaders,
            out Stream responseStream)
        {
            // NOTE: This doesn't have to be implemented because the server transport
            //   sink is always first.
            throw new NotSupportedException();
        }
           

        public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                         IMessage msg, ITransportHeaders headers, Stream stream)                 
        {
            TcpServerSocketHandler streamManager = null;

            streamManager = (TcpServerSocketHandler)state;

            // send the response
            streamManager.SendResponse(headers, stream);
            
            if (streamManager.CanServiceAnotherRequest())
                streamManager.BeginReadMessage();
            else
                streamManager.Close(); 
        } // AsyncProcessResponse


        public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                        IMessage msg, ITransportHeaders headers)
        {            
            // We always want a stream to read from.
            return null;
        } // GetResponseStream


        public IServerChannelSink NextChannelSink
        {
            get { return _nextSink; }
        }


        public IDictionary Properties
        {
            get { return null; }
        } // Properties
        
        //
        // end of IServerChannelSink implementation
        //

        
    } // class TcpServerTransportSink


} // namespace System.Runtime.Remoting.Channels.Tcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\tcpstreams.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    TcpStreams.cs
**
** Purpose: Defines streams used by TCP channel.
**
** Date:    December 4, 2000
**
===========================================================*/



using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;


namespace System.Runtime.Remoting.Channels.Tcp
{

    internal abstract class TcpReadingStream : Stream
    {
        public void ReadToEnd()
        {
            // This method should never be called where it would be valid
            //   to use this data, so it is ok to throw the excess bytes
            //   away.
            byte[] buffer = new byte[64];
            int readCount;
            do
            {
                readCount = Read(buffer, 0, 64);
            } while (readCount > 0);
        }
    
        public virtual bool FoundEnd { get { return false; } }
        
        public override bool CanRead {  get { return true; } }
        public override bool CanSeek { get { return false; } }
        public override bool CanWrite { get { return false; } }
       
        public override long Length {  get { throw new NotSupportedException(); } }

        public override long Position
        {
             get{ throw new NotSupportedException(); }
             set{ throw new NotSupportedException(); }
        }

        public override  void Flush() { throw new NotSupportedException(); }
        
        public override  long Seek(long offset, SeekOrigin origin) { throw new NotSupportedException(); }
        public override  void SetLength(long value) { throw new NotSupportedException(); }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotSupportedException();
        }        

    } // TcpReadingStream


    internal class TcpFixedLengthReadingStream : TcpReadingStream
    { 
        private SocketHandler _inputStream; 
        private int _bytesLeft;   // bytes left to read

        internal TcpFixedLengthReadingStream(SocketHandler inputStream, 
                                             int contentLength)
        {
            _inputStream = inputStream;
            _bytesLeft = contentLength;
        } // TcpFixedLengthReadingStream

        public override bool FoundEnd { get { return _bytesLeft == 0; } }

        public override void Close()
        {
            _inputStream.OnInputStreamClosed();
        }
        
        public override int Read(byte[] buffer, int offset, int count)
        {
            if (_bytesLeft == 0)
                return 0;
        
            int readCount = _inputStream.Read(buffer, offset, Math.Min(_bytesLeft, count));
            if (readCount > 0)
                _bytesLeft -= readCount;
            
            return readCount;
        } // Read

        public override int ReadByte()
        {
            if (_bytesLeft == 0)
                return -1;

            _bytesLeft -= 1;
            return _inputStream.ReadByte();
        } // ReadByte
                
    } // TcpFixedLengthReadingStream


    internal class TcpChunkedReadingStream : TcpReadingStream
    {   
        private SocketHandler _inputStream = null; // read chunked tcp data from here
        
        private int    _bytesLeft;          // bytes left in current chunk
        private bool   _bFoundEnd = false;  // has end of stream been reached?

        private byte[] _byteBuffer = new byte[1]; // buffer for reading bytes
        
        
        internal TcpChunkedReadingStream(SocketHandler inputStream)
        {
            _inputStream = inputStream;
            
            _bytesLeft = 0;
        } // HttpChunkedRequestStream

        public override bool FoundEnd { get { return _bFoundEnd; } }

        public override void Close() 
        {
        } // Close
        
        private int min(int a, int b) { return a < b ? a : b;}
        
        public override int Read(byte[] buffer, int offset, int count)
        {
            int bytesRead = 0;
        
            while (!_bFoundEnd && (count > 0))
            {
                // see if we need to start reading a new chunk
                if (_bytesLeft == 0)
                {
                    _bytesLeft = _inputStream.ReadInt32();
                                        
                    if (_bytesLeft == 0)
                    {
                        ReadTrailer();                        
                        _bFoundEnd = true;
                    }
                }

                if (!_bFoundEnd)
                {
                    int readCount = min(_bytesLeft, count);
                    int bytesReadThisTime = _inputStream.Read(buffer, offset, readCount);
                    if (bytesReadThisTime <= 0)
                    {
                        throw new RemotingException(
                            CoreChannel.GetResourceString(
                                "Remoting_Tcp_ChunkedEncodingError"));
                    }
                    
                    _bytesLeft -= bytesReadThisTime;
                    count -= bytesReadThisTime;
                    offset += bytesReadThisTime;
                    bytesRead += bytesReadThisTime;
                
                    // see if the end of the chunk was found
                    if (_bytesLeft == 0)
                    {
                        ReadTrailer();
                    }
                }
            } // while (count > 0)  

            return bytesRead;
        } // Read        

        public override int ReadByte()
        {
            int readCount = Read(_byteBuffer, 0, 1);
            if (readCount == 0)
                return -1;
                
            return _byteBuffer[0];         
        } // ReadByte


        private void ReadTrailer()
        {
            // read trailer bytes "\r\n" and throw an exception if they aren't correct.
            int ch = _inputStream.ReadByte();
            if (ch != '\r')
            {
                throw new RemotingException(
                    CoreChannel.GetResourceString(
                        "Remoting_Tcp_ChunkedEncodingError"));
            }

            ch = _inputStream.ReadByte();
            if (ch != '\n')
            {
                throw new RemotingException(
                    CoreChannel.GetResourceString(
                        "Remoting_Tcp_ChunkedEncodingError"));
            }
        }
        
    } // TcpChunkedReadingStream

    


     // Maintains control of a socket connection.
    internal class TcpServerSocketHandler : TcpSocketHandler
    {
        // prebaked bytes
        private static byte[] s_endOfLineBytes = Encoding.ASCII.GetBytes("\r\n");
        
    
        // Used to keep track of socket connections
        private static Int64 _connectionIdCounter = 0;        
        
        private Int64 _connectionId;   // id for this connection

        private bool _bOneWayRequest;  // is the incoming request one way?
        private bool _bChunked;        // is the incoming request chunked?
        private int  _contentLength;   // content length of incoming request

        TcpReadingStream _requestStream; // the request stream

        
        internal TcpServerSocketHandler(Socket socket, RequestQueue requestQueue) : base(socket, requestQueue)
        {                 
            _connectionId = Interlocked.Increment(ref _connectionIdCounter);
        } // TcpServerSocketHandler


        // Determine if it's possible to service another request
        public bool CanServiceAnotherRequest()
        {
            return true;
        } // CanServiceAnotherRequest
        

        // Prepare for reading a new request off of the same socket
        protected override void PrepareForNewMessage()
        {
            if (_requestStream != null)
            {
                if (!_requestStream.FoundEnd)
                    _requestStream.ReadToEnd();
                _requestStream = null;
            }
        } // PrepareForNewRequest
            
        protected override void SendErrorMessageIfPossible(Exception e)
        {        
            // An fatal exception occurred. We communicate this error by
            // writing an error message and empty message body.
            try
            {
                SendErrorResponse(e, true);
            }
            catch
            {
                // the connection must be dead, so it doesn't really matter.
            }
        } // SendErrorMessageIfPossible
            

        // read headers
        public ITransportHeaders ReadHeaders()
        {        
            BaseTransportHeaders headers = new BaseTransportHeaders();

            UInt16 operation;
            ReadVersionAndOperation(out operation);

            // make sure the operation is Request or OneWayRequest.
            if (operation == TcpOperations.Request)
            {
                _bOneWayRequest = false;
            }
            else
            if (operation == TcpOperations.OneWayRequest)
            {
                _bOneWayRequest = true;
            }
            else
            {
                throw new RemotingException(
                    String.Format(
                        CoreChannel.GetResourceString("Remoting_Tcp_ExpectingRequestOp"),
                        operation.ToString()));
            }            

            // content length must come next (may be chunked or a specific length)
            ReadContentLength(out _bChunked, out _contentLength);

            // read to end of headers  
            ReadToEndOfHeaders(headers);   
                           
            // add IP address and Connection Id to headers
            headers.IPAddress = ((IPEndPoint)NetSocket.RemoteEndPoint).Address;
            headers.ConnectionId = _connectionId;
            
            return headers;
        } // ReadHeaders


        public Stream GetRequestStream()
        {
            if (!_bChunked)
                _requestStream =  new TcpFixedLengthReadingStream(this, _contentLength);
            else
                _requestStream =  new TcpChunkedReadingStream(this);
            return _requestStream;
        } // GetRequestStream
      

        public void SendResponse(ITransportHeaders headers, Stream contentStream)
        {           
            // bail out if the original request was OneWay (means the client doesn't even
            //   want or expect to receive responses or error messages)
            if (_bOneWayRequest)
                return;            
        
            // build up headers and send      
            ChunkedMemoryStream headerStream = new ChunkedMemoryStream(CoreChannel.BufferPool);

            // output preamble and version
            WritePreambleAndVersion(headerStream);
            // output opcode
            WriteUInt16(TcpOperations.Reply, headerStream);
            // output content length delimiter
            WriteUInt16(TcpContentDelimiter.ContentLength, headerStream);
            WriteInt32((int)contentStream.Length, headerStream);

            // No status code header is needed because if we're in this code path
            //   the data transfer succeeded as far as the transport protocol is
            //   concerned (and the success status code is optional).

            WriteHeaders(headers, headerStream);
            
            headerStream.WriteTo(NetStream);
            headerStream.Close();

            StreamHelper.CopyStream(contentStream, NetStream);          
                         
            contentStream.Close();            
        } // SendResponse


        string GenerateFaultString(Exception e) {
            //If the user has specified it's a development server (versus a production server) in remoting config,
            //then we should just return e.ToString instead of extracting the list of messages.                        
            if (!CustomErrorsEnabled()) 
                return e.ToString();            
            else {                
                return CoreChannel.GetResourceString("Remoting_InternalError");                                                             
            }            
        }

        public void SendErrorResponse(Exception e, bool bCloseConnection)
        {
            // bail out if the original request was OneWay (means the client doesn't even
            //   want or expect to receive responses or error messages)
            if (_bOneWayRequest)
                return;
        
            // build up headers and send      
            ChunkedMemoryStream headerStream = new ChunkedMemoryStream(CoreChannel.BufferPool);

            // output preamble and version
            WritePreambleAndVersion(headerStream);
            // output opcode
            WriteUInt16(TcpOperations.Reply, headerStream);
            // output content length delimiter (0-length stream)
            WriteUInt16(TcpContentDelimiter.ContentLength, headerStream);
            WriteInt32(0, headerStream);

            // output status code and reason
            WriteUInt16(TcpHeaders.StatusCode, headerStream);
            WriteByte(TcpHeaderFormat.UInt16, headerStream);
            WriteUInt16(TcpStatusCode.GenericError, headerStream);
            // we purposely don't include the stack trace to avoid giving
            //   out too much information for security purposes.
            WriteUInt16(TcpHeaders.StatusPhrase, headerStream);
            WriteByte(TcpHeaderFormat.CountedString, headerStream);
            WriteCountedString(GenerateFaultString(e), headerStream);

            // indicate that we are about to close the connection
            WriteUInt16(TcpHeaders.CloseConnection, headerStream);
            WriteByte(TcpHeaderFormat.Void, headerStream);

            // end of headers
            WriteUInt16(TcpHeaders.EndOfHeaders, headerStream);
            
            headerStream.WriteTo(NetStream);
            headerStream.Close();
        } // SendErrorResponse
               

    } // class TcpServerSocketHandler

    
    

} // namespace System.Runtime.Remoting.Channels.Tcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\metadata.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    MetaDataServices
**
** Author:  Gopal Kakivaya (GopalK)
**
** Purpose: Defines APIs for yyyyyyyyyyyyy
**
** Date:    April 01, 2000
**
===========================================================*/
namespace System.Runtime.Remoting.MetadataServices
{
    using System;
    using System.Threading;
    using System.Collections;
    using System.Reflection;
    using System.Xml;
    using System.Diagnostics;
    using System.IO;
    using System.Net;
    using System.Text;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Metadata;

    using Microsoft.CSharp;

    /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData"]/*' />
    public class MetaData
    {

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertTypesToSchemaToFile"]/*' />
        public static void ConvertTypesToSchemaToFile(Type[] types, SdlType sdlType, String path)
        {
			Util.Log("MetaData.ConvertTypesToSchemaToFile 1 "+path);						
            ConvertTypesToSchemaToStream(types, sdlType, File.Create(path));
        } // ConvertTypesToSchemaToFile

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertTypesToSchemaToStream"]/*' />
        public static void ConvertTypesToSchemaToStream(Type[] types, SdlType sdlType, Stream outputStream)
        {
			Util.Log("MetaData.ConvertTypesToSchemaToFile 2 ");						
            //    This should actually delegate to the version that accepts ServiceType once
            //   support for that is added in sudsgen.

            ServiceType[] serviceTypes = new ServiceType[types.Length];
            for (int i=0; i<types.Length; i++)
                serviceTypes[i] = new ServiceType(types[i]);

            ConvertTypesToSchemaToStream(serviceTypes, sdlType, outputStream);

        } // ConvertTypesToSchemaToStream


        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertTypesToSchemaToFile1"]/*' />
        public static void ConvertTypesToSchemaToFile(ServiceType[] types, SdlType sdlType, String path)
        {
            Util.Log("MetaData.ConvertTypesToSchemaToFile 3 "+path);
            ConvertTypesToSchemaToStream(types, sdlType, File.Create(path));
        } // ConvertTypesToSchemaToFile


        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertTypesToSchemaToFile2"]/*' />
        public static void ConvertTypesToSchemaToStream(ServiceType[] serviceTypes, SdlType sdlType, Stream outputStream)
        {
			Util.Log("MetaData.ConvertTypesToSchemaToStream 4");			
			TextWriter tw = new StreamWriter(outputStream, new UTF8Encoding(false, true));
            SUDSGenerator sgen = new SUDSGenerator(serviceTypes, sdlType, tw);
            sgen.Generate();
            tw.Flush();

        } // ConvertTypesToSchemaToStream

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.RetrieveSchemaFromUrlToStream"]/*' />
        public static void RetrieveSchemaFromUrlToStream(String url, Stream outputStream)
        {
            WebRequest              Request;
            WebResponse             Response;
            Stream                  RespStream;
			Util.Log("MetaData.RetrieveSchemaFromUrlToStream "+url);						
            TextWriter tw = new StreamWriter(outputStream, new UTF8Encoding(false, true));

            Request = WebRequest.Create(url);
            Response = Request.GetResponse();
            RespStream = Response.GetResponseStream();
			StreamReader sr = new StreamReader(RespStream);
			tw.Write(sr.ReadToEnd());
            tw.Flush();
        }

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.RetrieveSchemaFromUrlToFile"]/*' />
        public static void RetrieveSchemaFromUrlToFile(String url, String path)
        {
			Util.Log("MetaData.RetrieveSchemaFromUrlToFile "+url+" file "+path);									
            RetrieveSchemaFromUrlToStream(url, File.Create(path));
        }




        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertSchemaStreamToCodeSourceStream"]/*' />
        public static void ConvertSchemaStreamToCodeSourceStream(bool clientProxy, String outputDirectory, Stream inputStream, ArrayList outCodeStreamList, String proxyUrl, String proxyNamespace)
        {
			Util.Log("MetaData.ConvertSchemaStreamToCodeSourceStream 1 "+outputDirectory+" proxyUrl "+proxyNamespace);									
            TextReader input;

            input = (TextReader) new StreamReader(inputStream);

            SUDSParser parser = new SUDSParser(input, outputDirectory, outCodeStreamList, proxyUrl, clientProxy, proxyNamespace);
            parser.Parse();
        }

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertSchemaStreamToCodeSourceStream2"]/*' />
        public static void ConvertSchemaStreamToCodeSourceStream(bool clientProxy, String outputDirectory, Stream inputStream, ArrayList outCodeStreamList, String proxyUrl)
        {
			Util.Log("MetaData.ConvertSchemaStreamToCodeSourceStream 3 "+outputDirectory);									
          ConvertSchemaStreamToCodeSourceStream(clientProxy, outputDirectory, inputStream, outCodeStreamList, proxyUrl, "");
        }

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertSchemaStreamToCodeSourceStream1"]/*' />
        public static void ConvertSchemaStreamToCodeSourceStream(bool clientProxy, String outputDirectory, Stream inputStream, ArrayList outCodeStreamList)
        {
			Util.Log("MetaData.ConvertSchemaStreamToCodeSourceStream 2 "+outputDirectory);									
          ConvertSchemaStreamToCodeSourceStream(clientProxy, outputDirectory, inputStream, outCodeStreamList, "", "");
        }
        

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertCodeSourceStreamToAssemblyFile"]/*' />
        public static void ConvertCodeSourceStreamToAssemblyFile(ArrayList outCodeStreamList, String assemblyPath, String strongNameFilename)
        {
			Util.Log("MetaData.ConvertCodeSourceStreamToAssemblyFile "+assemblyPath);												
            CompilerError[] errors = null;


            try
            {
                if (strongNameFilename != null)
                {
                    // Create strong name file with assembly attribute
                    String stfilename = "__Sn.cs";
                    if (assemblyPath != null)
                    {
                        int index = assemblyPath.LastIndexOf("\\");
                        if (index > 0)
                        {
                            stfilename = assemblyPath.Substring(0,index+1)+stfilename;
                        }
                    }
                    FileStream fs = new FileStream(stfilename, FileMode.Create, FileAccess.ReadWrite);
                    StreamWriter fsWriter = new StreamWriter(fs, new UTF8Encoding(false, true));
                    fsWriter.WriteLine("// CLR Remoting Autogenerated Key file (to create a key file use: sn -k tmp.key)");
                    fsWriter.WriteLine("using System;");
                    fsWriter.WriteLine("using System.Reflection;");
                    fsWriter.WriteLine("[assembly: AssemblyKeyFile(\""+strongNameFilename+"\")]");
                    fsWriter.WriteLine("[assembly: AssemblyVersion(\"1.0.0.1\")]");
                    fsWriter.Flush();
                    fsWriter.Close();
                    fs.Close();
                    outCodeStreamList.Add(stfilename);
                    Util.Log("MetaData.ConvertCodeSourceStreamToAssemblyFile key file "+stfilename);												
                }

                String[] sourceTexts = new String[outCodeStreamList.Count];
                String[] sourceTextNames = new String[outCodeStreamList.Count];

                int streamCount = 0; // used for naming sourceTexts streams

                for(int item=0;item<outCodeStreamList.Count;item++)
                {
                  Stream inputStream;
                  bool close=false;

                  if (outCodeStreamList[item] is String)
                  {
                    // it's a file
                    String filename = (String)outCodeStreamList[item];
                    sourceTextNames[item] = (String)filename;
					Util.Log("MetaData.ConvertCodeSourceStreamToAssemblyFile  filename "+filename);																	
                    inputStream = File.OpenRead(filename);
                    close = true;
                  }
                  else if (outCodeStreamList[item] is Stream)
                  {
                    // it's a stream
                    inputStream = (Stream)outCodeStreamList[item];
                    sourceTextNames[item] = "Stream" + (streamCount++);
                  }
                  else
                  {
                     throw new RemotingException(CoreChannel.GetResourceString("Remoting_UnknownObjectInCodeStreamList"));
                  }

				  StreamReader streamReader = new StreamReader(inputStream);
                  sourceTexts[item] = streamReader.ReadToEnd();

                  if (true == close)
                    inputStream.Close();
                }

                String target = assemblyPath;

                String[] imports = new String[5];
                imports[0] = "System.dll";
                imports[1] = "System.Runtime.Remoting.dll";
                imports[2] = "System.Data.dll";
                imports[3] = "System.Xml.dll";
                imports[4] = "System.Web.Services.dll";
 
                Hashtable options = new Hashtable();
                options.Add( "target", "library");
//                options.Add( "debug", true);

				if (sourceTexts.Length > 0)
				{
					errors = Microsoft.CSharp.Compiler.Compile(sourceTexts, sourceTextNames, target, imports, options);
					for (int i=0; i<errors.Length; i++)
					{
						Util.Log("MetaData.ConvertCodeSourceStreamToAssemblyFile  errors "+errors[i].SourceLine+" "+errors[i].ErrorMessage);
					}
				}
            }

            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }

            if (errors != null)
            {
                if (errors.Length > 0)
                {
                    for (int i = 0; i < errors.Length; i++)
                    {
                        Console.WriteLine(errors[i].ToString());  
                    }
                }
            }
        }


/*
/target:module -> Name="target", Value="module"
/target:library -> Name="target", Value="library"
/main:MyClass -> Name="m", Value="MyClass"
/debug+ -> Name="debug", Value=true

// The dictionary of options takes almost ALL of the normal command-line options, but only using their 'short form' and without the preceding slash or dash.
*/

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.ConvertCodeSourceFileToAssemblyFile"]/*' />
        public static void ConvertCodeSourceFileToAssemblyFile(String codePath, String assemblyPath, String strongNameFilename)
        {
			Util.Log("MetaData.ConvertCodeSourceFileToAssemblyFile codePath "+codePath+" assemblyPath "+assemblyPath);												
            ArrayList arrayList = new ArrayList();
            arrayList.Add(codePath);
            ConvertCodeSourceStreamToAssemblyFile(arrayList, assemblyPath, strongNameFilename);
        }

        // Helpers

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="MetaData.SaveStreamToFile"]/*' />
        public static void SaveStreamToFile(Stream inputStream, String path)
        {
			Util.Log("MetaData.SaveStreamToFile "+path);			
            Stream outputStream = File.Create(path);
            TextWriter tw = new StreamWriter(outputStream, new UTF8Encoding(false, true));
			StreamReader sr = new StreamReader(inputStream);
			tw.Write(sr.ReadToEnd());
            tw.Flush();
            tw.Close();
            outputStream.Close();
        }


    } // class MetaData
        
        
    /// <include file='doc\MetaData.uex' path='docs/doc[@for="ServiceType"]/*' />
    public class ServiceType
        {
        private Type    _type;  // Type of object being exported.
        private String  _url;   // This may be null if no address is available.
        
        /// <include file='doc\MetaData.uex' path='docs/doc[@for="ServiceType.ServiceType"]/*' />
        public ServiceType(Type type)
        {
            _type = type;
            _url = null;
        } // ServiceType

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="ServiceType.ServiceType1"]/*' />
        public ServiceType(Type type, String url)
            {
            _type = type;
            _url = url;
        } // ServiceType

        /// <include file='doc\MetaData.uex' path='docs/doc[@for="ServiceType.ObjectType"]/*' />
        public Type   ObjectType { get { return _type; } }
        /// <include file='doc\MetaData.uex' path='docs/doc[@for="ServiceType.Url"]/*' />
        public String Url { get { return _url; } }        
       
    } // ServiceType
        
        

} // namespace System.Runtime.Remoting.MetadataServices
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\maindll\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\HTTPRemotingHandler.cs: $(O)\doc\HTTPRemotingHandler.uex ..\channels\HTTP\HTTPRemotingHandler.cs $(CORBASE)\src\inc\version\__file__.ver $(CORBASE)\bin\FinalPublicKey.Tok
        cl /EP /C /DCOOL_INCLUDE /FI $(CORBASE)\src\inc\version\__file__.ver /FI $(CORBASE)\bin\FinalPublicKey.Tok ..\channels\HTTP\HTTPRemotingHandler.cs > $(O)\HTTPRemotingHandler.cs

$(O)\doc: 
        @mkdir $(O)\doc

$(O)\doc\HTTPRemotingHandler.uex: $(O)\doc
        copy ..\channels\HTTP\doc\HTTPRemotingHandler.uex $(O)\doc\HTTPRemotingHandler.uex

SETUP: $(O)\HTTPRemotingHandler.cs $(O)\doc\HTTPRemotingHandler.uex

$(COOL_TARGET): $(COOL_SOURCES) $(O)\System.Runtime.Remoting.resources  CopyManagedPdb

cool_target_sign: $(COOL_TARGET)
        gacutil -i $(TARGETPATH)\$(TARGETNAME)

$(O)\System.Runtime.Remoting.resources: ..\resources.txt
    $(TARGETPATH)\InternalResGen.Exe ..\resources.txt $(TARGETPATH)\System.Runtime.Remoting.resources

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\System.Runtime.Remoting.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\channels\tcp\tcpwireprotocol.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       TcpWireProtocol.cs
//
//  Summary:    Class for managing a socket connection.
//
//==========================================================================


using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;


namespace System.Runtime.Remoting.Channels.Tcp
{

    // After the version, one of the following 16-bit opcodes will appear.
    internal class TcpOperations
    {
        internal const UInt16 Request       = 0;
        internal const UInt16 OneWayRequest = 1;
        internal const UInt16 Reply         = 2;
    } // TcpOpcodes

    internal class TcpContentDelimiter
    {
        internal const UInt16 ContentLength     = 0; 
        internal const UInt16 Chunked           = 1;
    }

    // These are special header values. (Custom can be used for arbitrary
    //   pairs).
    internal class TcpHeaders
    {
        internal const UInt16 EndOfHeaders      = 0; // (can appear once at end of headers)
        internal const UInt16 Custom            = 1;
        internal const UInt16 StatusCode        = 2;
        internal const UInt16 StatusPhrase      = 3;
        internal const UInt16 RequestUri        = 4;
        internal const UInt16 CloseConnection   = 5;
        internal const UInt16 ContentType       = 6;
    } // TcpHeaders

    // These are used by special headers (non-Custom) to indicate the format of the data,
    //   so that unknown special headers added in the future can be ignored.
    internal class TcpHeaderFormat
    {
        internal const byte Void          = 0; // There is no further data.
        internal const byte CountedString = 1; // A single counted string follows.
        internal const byte Byte          = 2; // A single byte follows
        internal const byte UInt16        = 3; // A single unsigned 16-bit int follows.        
        internal const byte Int32         = 4; // A single 32-bit int follows.
    } // TcpHeaderFormat

    
    // status codes only apply to the transmission of data itself.
    internal class TcpStatusCode
    {
        internal const UInt16 Success      = 0; // data was successfully received
        internal const UInt16 GenericError = 1; // an unknown error occurred
    } // TcpStatusCode


    // string format indicators
    // (strings have the following format on the wire:
    //   [format (1-byte)][encoded-size (int32)][string data (encoded-size bytes in length)]
    internal class TcpStringFormat
    {
        internal const byte Unicode = 0;
        internal const byte UTF8    = 1;
    } // TcpStringFormat
    


} // namespace System.Runtime.Remoting.Channels.Tcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\sdlchannelsink.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       SdlChannelSink.cs
//
//  Summary:    Sdl channel sink for generating sdl dynamically on the server.
//
//==========================================================================


using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Http;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Web;


namespace System.Runtime.Remoting.MetadataServices
{

    /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSinkProvider"]/*' />
    public class SdlChannelSinkProvider : IServerChannelSinkProvider
    {
        private IServerChannelSinkProvider _next = null;
        private bool _bRemoteApplicationMetadataEnabled = false;
        private bool _bMetadataEnabled = true;        
                                                         
        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSinkProvider.SdlChannelSinkProvider"]/*' />
        public SdlChannelSinkProvider()
        {
        }

        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSinkProvider.SdlChannelSinkProvider1"]/*' />
        public SdlChannelSinkProvider(IDictionary properties, ICollection providerData)
        {        
            if (properties != null)
            {
                foreach (DictionaryEntry entry in properties)
                {
                    switch ((String)entry.Key)
                    {
                    case "remoteApplicationMetadataEnabled": _bRemoteApplicationMetadataEnabled = Convert.ToBoolean(entry.Value); break;
                    case "metadataEnabled": _bMetadataEnabled = Convert.ToBoolean(entry.Value); break;
                    default:
                        CoreChannel.ReportUnknownProviderConfigProperty(
                            this.GetType().Name, (String)entry.Key);
                        break;                    
                    }
                }
            }                                            
        }

        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSinkProvider.GetChannelData"]/*' />
        public void GetChannelData(IChannelDataStore localChannelData)
        {
        }
   
        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSinkProvider.CreateSink"]/*' />
        public IServerChannelSink CreateSink(IChannelReceiver channel)
        {
            IServerChannelSink nextSink = null;
            if (_next != null)
                nextSink = _next.CreateSink(channel);
                
            SdlChannelSink channelSink = new SdlChannelSink(channel, nextSink);                
            channelSink.RemoteApplicationMetadataEnabled = _bRemoteApplicationMetadataEnabled; 
            channelSink.MetadataEnabled = _bMetadataEnabled;
            return channelSink;
        }

        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSinkProvider.Next"]/*' />
        public IServerChannelSinkProvider Next
        {
            get { return _next; }
            set { _next = value; }
        }
    } // class SdlChannelSinkProvider

   
    

    /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSink"]/*' />
    public class SdlChannelSink : IServerChannelSink
    {
        private IChannelReceiver _receiver;
        private IServerChannelSink _nextSink; 
        private bool _bRemoteApplicationMetadataEnabled = false;
        private bool _bMetadataEnabled = false;        

    
        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSink.SdlChannelSink"]/*' />
        public SdlChannelSink(IChannelReceiver receiver, IServerChannelSink nextSink)
        {
            _receiver = receiver;
            _nextSink = nextSink;
        } // SdlChannelSink

        internal bool RemoteApplicationMetadataEnabled 
        {
            get { return _bRemoteApplicationMetadataEnabled; }            
            set { _bRemoteApplicationMetadataEnabled = value; }
        }
        
        internal bool MetadataEnabled 
        {
            get { return _bMetadataEnabled; }            
            set { _bMetadataEnabled = value; }
        }                 

        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSink.ProcessMessage"]/*' />
        public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
            IMessage requestMsg,
            ITransportHeaders requestHeaders, Stream requestStream,
            out IMessage responseMsg, out ITransportHeaders responseHeaders, 
            out Stream responseStream)
        {
            if (requestMsg != null)
            {
                // The message has already been deserialized so delegate to the next sink.
                return _nextSink.ProcessMessage(
                    sinkStack,
                    requestMsg, requestHeaders, requestStream, 
                    out responseMsg, out responseHeaders, out responseStream);
            }
        
            SdlType sdlType;
            if (!ShouldIntercept(requestHeaders, out sdlType))
                return _nextSink.ProcessMessage(sinkStack, null, requestHeaders, requestStream,
                                                out responseMsg, out responseHeaders, out responseStream);            
                        
            // generate sdl and return it
            responseHeaders = new TransportHeaders();
            GenerateSdl(sdlType, sinkStack, requestHeaders, responseHeaders, out responseStream);
            responseMsg = null;

            return ServerProcessing.Complete;            
        } // ProcessMessage


        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSink.AsyncProcessResponse"]/*' />
        public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, Object state,
                                         IMessage msg, ITransportHeaders headers, Stream stream)
        {
            // We don't need to implement this because we never push ourselves to the sink
            //   stack.
        } // AsyncProcessResponse


        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSink.GetResponseStream"]/*' />
        public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, Object state,
                                        IMessage msg, ITransportHeaders headers)
        {
            // We don't need to implement this because we never push ourselves
            //   to the sink stack.
            throw new NotSupportedException();
        } // GetResponseStream


        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSink.NextChannelSink"]/*' />
        public IServerChannelSink NextChannelSink
        {
            get { return _nextSink; }
        }


        /// <include file='doc\SdlChannelSink.uex' path='docs/doc[@for="SdlChannelSink.Properties"]/*' />
        public IDictionary Properties
        {
            get { return null; }
        } // Properties


        // Should we intercept the call and return some SDL
        private bool ShouldIntercept(ITransportHeaders requestHeaders, out SdlType sdlType)
        {
            sdlType = SdlType.Sdl;
            
            String requestVerb = requestHeaders["__RequestVerb"] as String;
            String requestURI = requestHeaders["__RequestUri"] as String;
    
            // http verb must be "GET" to return sdl (and request uri must be set)
            if ((requestURI == null) ||
                (requestVerb == null) || !requestVerb.Equals("GET"))              
                return false;

            // find last index of ? and look for "sdl" or "sdlx"
            int index = requestURI.LastIndexOf('?');
            if (index == -1)
                return false; // no query string

            String queryString = requestURI.Substring(index).ToLower(CultureInfo.InvariantCulture);

            // sdl?
            if ((String.CompareOrdinal(queryString, "?sdl") == 0) ||
                (String.CompareOrdinal(queryString, "?sdlx") == 0))
            { 
                sdlType = SdlType.Sdl;
                return true;
            }

            // wsdl?
            if (String.CompareOrdinal(queryString, "?wsdl") == 0)
            { 
                sdlType = SdlType.Wsdl;
                return true;
            }            
            
            return false;            
        } // ShouldIntercept


        private void GenerateSdl(SdlType sdlType,
                                 IServerResponseChannelSinkStack sinkStack,
                                 ITransportHeaders requestHeaders,
                                 ITransportHeaders responseHeaders,
                                 out Stream outputStream)
        {
            if (!MetadataEnabled)
                throw new RemotingException(CoreChannel.GetResourceString("Remoting_MetadataNotEnabled"));
            
            String requestUri = requestHeaders[CommonTransportKeys.RequestUri] as String;           
            String objectUri = HttpChannelHelper.GetObjectUriFromRequestUri(requestUri);            
            
            if (!RemoteApplicationMetadataEnabled && 
                (String.Compare(objectUri, "RemoteApplicationMetadata.rem", true, CultureInfo.InvariantCulture) == 0))
                throw new RemotingException(CoreChannel.GetResourceString("Remoting_RemoteApplicationMetadataNotEnabled"));

            // If the host header is present, we will use this in the generated uri's
            String hostName = (String)requestHeaders["Host"];
            if (hostName != null)
            {
                // filter out port number if present
                int index = hostName.IndexOf(':');
                if (index != -1)
                    hostName = hostName.Substring(0, index);
            }

            // For IIS, we will bash the scheme://hostname:port with the incoming value
            String iisHostOverride = null;
            HttpContext context = HttpContext.Current;
            if (context != null)
            {
                HttpRequest request = context.Request;
                String scheme = null;
                if (request.IsSecureConnection)
                    scheme = "https";
                else
                    scheme = "http";
                    
                int port = context.Request.Url.Port;

                StringBuilder sb = new StringBuilder(100);
                sb.Append(scheme);
                sb.Append("://");
                if (hostName != null)
                    sb.Append(hostName);
                else
                    sb.Append(CoreChannel.GetMachineName());
                sb.Append(":");
                sb.Append(port.ToString());

                iisHostOverride = sb.ToString();
            }
            

            ServiceType[] types = null;

            if (String.Compare(objectUri, "RemoteApplicationMetadata.rem", true, CultureInfo.InvariantCulture) == 0)
            {
                // get the service description for all registered service types
                
                ActivatedServiceTypeEntry[] activatedTypes = 
                    RemotingConfiguration.GetRegisteredActivatedServiceTypes();

                WellKnownServiceTypeEntry[] wellKnownTypes = 
                    RemotingConfiguration.GetRegisteredWellKnownServiceTypes();

                // determine total number of types
                int typeCount = 0;
                
                if (activatedTypes != null)
                    typeCount += activatedTypes.Length;
                    
                if (wellKnownTypes != null)
                    typeCount += wellKnownTypes.Length;

                types = new ServiceType[typeCount];

                // collect data
                int co = 0;
                if (activatedTypes != null)
                {
                    foreach (ActivatedServiceTypeEntry entry in activatedTypes)
                    {
                        types[co++] = new ServiceType(entry.ObjectType, null);
                    }                    
                }

                if (wellKnownTypes != null)
                {
                    foreach (WellKnownServiceTypeEntry entry in wellKnownTypes)
                    {   
                        String[] urls = _receiver.GetUrlsForUri(entry.ObjectUri);
                        String url = urls[0];
                        if (iisHostOverride != null)
                            url = HttpChannelHelper.ReplaceChannelUriWithThisString(url, iisHostOverride);
                        else
                        if (hostName != null)
                            url = HttpChannelHelper.ReplaceMachineNameWithThisString(url, hostName);

                        types[co++] = new ServiceType(entry.ObjectType, url);
                    } 
                }

                InternalRemotingServices.RemotingAssert(co == typeCount, "Not all types were processed.");                
            }
            else
            {    
                // get the service description for a particular object
                Type objectType = RemotingServices.GetServerTypeForUri(objectUri);
                if (objectType == null)
                {
                    throw new RemotingException(
                        String.Format(
                            "Object with uri '{0}' does not exist at server.",
                            objectUri));
                }
                
                String[] urls = _receiver.GetUrlsForUri(objectUri);
                String url = urls[0];
                if (iisHostOverride != null)
                    url = HttpChannelHelper.ReplaceChannelUriWithThisString(url, iisHostOverride);
                else
                if (hostName != null)
                    url = HttpChannelHelper.ReplaceMachineNameWithThisString(url, hostName);

                types = new ServiceType[1];
                types[0] = new ServiceType(objectType, url);
            }

            responseHeaders["Content-Type"] = "text/xml";

            bool bMemStream = false;

            outputStream = sinkStack.GetResponseStream(null, responseHeaders);
            if (outputStream == null)
            {
                outputStream = new MemoryStream(1024);
                bMemStream = true;
            }        

            MetaData.ConvertTypesToSchemaToStream(types, sdlType, outputStream);

            if (bMemStream)
                outputStream.Position = 0;
        } // GenerateXmlForUri               
        
    } // class SdlChannelSink



} // namespace System.Runtime.Remoting.Channnels
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\sudsparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SudsParser.cool
**
** Author:  Gopal Kakivaya (GopalK)
**
** Purpose: Defines SUDSParser that parses a given SUDS document
**          and generates types defined in it.
**
** Date:    April 01, 2000
** Revised: November 15, 2000 (Wsdl) pdejong
**
===========================================================*/
namespace System.Runtime.Remoting.MetadataServices
{
    using System;
    using System.IO;
    using System.Runtime.Remoting;
    using System.Collections;

    // Represents exceptions thrown by the SUDSParser
    /// <include file='doc\SudsParser.uex' path='docs/doc[@for="SUDSParserException"]/*' />
    public class SUDSParserException : Exception
    {
        internal SUDSParserException(String message)
        : base(message)
        {
        }
    }

    // Represents a block type of a complex type
	[Serializable]
    internal enum SchemaBlockType { ALL, SEQUENCE, CHOICE, ComplexContent}

    // This class parses SUDS documents
    /// <include file='doc\SudsParser.uex' path='docs/doc[@for="SUDSParser"]/*' />
    internal class SUDSParser
    {
        WsdlParser wsdlParser;
                                                        
        // Main parser
        internal SUDSParser(TextReader input, String outputDir, ArrayList outCodeStreamList, String locationURL, bool bWrappedProxy, String proxyNamespace)
        {
			Util.Log("SUDSParser.SUDSParser outputDir "+outputDir+" locationURL "+locationURL+" bWrappedProxy "+bWrappedProxy+" proxyNamespace "+proxyNamespace);
            Util.LogInput(ref input);
            wsdlParser = new WsdlParser(input, outputDir, outCodeStreamList, locationURL, bWrappedProxy, proxyNamespace);
        }

        internal void Parse()
        {
			Util.Log("SUDSParser.Parse");
            wsdlParser.Parse();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\sudswriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** File:    SudsWriter.cool
 **
 ** Author:  Gopal Kakivaya (GopalK)
 **
 ** Purpose: Defines SUDSParser that parses a given SUDS document
 **          and generates types defined in it.
 **
 ** Date:    April 01, 2000
 ** Revised: November 15, 2000 (Wsdl) pdejong
 **
 ===========================================================*/
namespace System.Runtime.Remoting.MetadataServices
{
	using System;
    using System.IO;
    using System.Reflection;

	// Represents exceptions thrown by the SUDSGenerator
    /// <include file='doc\SudsWriter.uex' path='docs/doc[@for="SUDSGeneratorException"]/*' />
	public class SUDSGeneratorException : Exception
	{
		internal SUDSGeneratorException(String msg)
				: base(msg)
		{
		}
	}

	// This class generates SUDS documents
	internal class SUDSGenerator
	{
        WsdlGenerator wsdlGenerator = null;
        SdlGenerator sdlGenerator = null;
        SdlType sdlType;
		// Constructor
		internal SUDSGenerator(Type[] types, TextWriter output)
		{
			Util.Log("SUDSGenerator.SUDSGenerator 1");
            wsdlGenerator = new WsdlGenerator(types, output);
            sdlType = SdlType.Wsdl;
		}

		// Constructor
		internal SUDSGenerator(Type[] types, SdlType sdlType, TextWriter output)
		{
			Util.Log("SUDSGenerator.SUDSGenerator 2");
            if (sdlType == SdlType.Sdl)
                sdlGenerator = new SdlGenerator(types, sdlType, output);
            else
                wsdlGenerator = new WsdlGenerator(types, sdlType, output);
            this.sdlType = sdlType;
		}

		// Constructor
		internal SUDSGenerator(Type[] types, TextWriter output, Assembly assembly, String url)
		{
			Util.Log("SUDSGenerator.SUDSGenerator 3 "+url);
            wsdlGenerator = new WsdlGenerator(types, output, assembly, url);
            sdlType = SdlType.Wsdl;
		}

		// Constructor
		internal SUDSGenerator(Type[] types, SdlType sdlType, TextWriter output, Assembly assembly, String url)
		{
			Util.Log("SUDSGenerator.SUDSGenerator 4 "+url);			
            if (sdlType == SdlType.Sdl)
                sdlGenerator = new SdlGenerator(types, sdlType, output, assembly, url);
            else
                wsdlGenerator = new WsdlGenerator(types, sdlType, output, assembly, url);
            this.sdlType =sdlType;
		}

		internal SUDSGenerator(ServiceType[] serviceTypes, SdlType sdlType, TextWriter output)
		{
			Util.Log("SUDSGenerator.SUDSGenerator 5 ");
            if (sdlType == SdlType.Sdl)
                sdlGenerator = new SdlGenerator(serviceTypes, sdlType, output);
            else
                wsdlGenerator = new WsdlGenerator(serviceTypes, sdlType, output);
            this.sdlType = sdlType;
		}


		// Generates SUDS
		internal void Generate()
		{
			Util.Log("SUDSGenerator.Generate");			
            if (sdlType == SdlType.Sdl)
                sdlGenerator.Generate();
            else
                wsdlGenerator.Generate();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\sudscommon.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** File:    SudsCommon.cool
**
** Author:  Peter de Jong (pdejong)
**
** Purpose: Classes common to the SudsWriter and SudsParser
**
** Date:    November 18, 2000
**
===========================================================*/

namespace System.Runtime.Remoting.MetadataServices
{
    using System;
    using System.Collections;
    using System.Text;
    using System.Reflection;   
    using System.IO;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Metadata.W3cXsd2001;
    using System.Globalization;

    /// <include file='doc\SudsCommon.uex' path='docs/doc[@for="SdlType"]/*' />
    [Serializable]
    public enum SdlType
    {
        /// <include file='doc\SudsCommon.uex' path='docs/doc[@for="SdlType.Sdl"]/*' />
        Sdl = 0,
        /// <include file='doc\SudsCommon.uex' path='docs/doc[@for="SdlType.Wsdl"]/*' />
        Wsdl = 1
    }

    [Serializable]
    internal enum UrtType
    {
        None = 0,
        Interop = 1,
        UrtSystem = 2,
        UrtUser = 3,
        Xsd = 4,
    }

    [Serializable]
    internal enum SUDSType
    {
        None = 0,
        ClientProxy = 1,
        MarshalByRef = 2,
    }


    [Serializable]
    internal enum XsdVersion
    {
        V1999 = 0,
        V2000 = 1,
        V2001 = 2,
    }


    internal sealed class SudsConverter
    {

        internal static String Xsd1999 = "http://www.w3.org/1999/XMLSchema";
        internal static String Xsi1999 = "http://www.w3.org/1999/XMLSchema-instance";
        internal static String Xsd2000 = "http://www.w3.org/2000/10/XMLSchema";
        internal static String Xsi2000 = "http://www.w3.org/2000/10/XMLSchema-instance";
        internal static String Xsd2001 = "http://www.w3.org/2001/XMLSchema";
        internal static String Xsi2001 = "http://www.w3.org/2001/XMLSchema-instance";

        internal static Type typeofByte = typeof(Byte);
        internal static Type typeofSByte = typeof(SByte);
        internal static Type typeofBoolean = typeof(Boolean);
        internal static Type typeofChar = typeof(Char);
        internal static Type typeofDouble = typeof(Double);
        internal static Type typeofSingle = typeof(Single);
        internal static Type typeofDecimal = typeof(Decimal);
        internal static Type typeofInt16 = typeof(Int16);
        internal static Type typeofInt32 = typeof(Int32);
        internal static Type typeofInt64 = typeof(Int64);
        internal static Type typeofUInt16 = typeof(UInt16);
        internal static Type typeofUInt32 = typeof(UInt32);
        internal static Type typeofUInt64 = typeof(UInt64);
        internal static Type typeofSoapTime = typeof(SoapTime);
        internal static Type typeofSoapDate = typeof(SoapDate);
        internal static Type typeofSoapYearMonth = typeof(SoapYearMonth);
        internal static Type typeofSoapYear = typeof(SoapYear);
        internal static Type typeofSoapMonthDay = typeof(SoapMonthDay);
        internal static Type typeofSoapDay = typeof(SoapDay);
        internal static Type typeofSoapMonth = typeof(SoapMonth);
        internal static Type typeofSoapHexBinary = typeof(SoapHexBinary);
        internal static Type typeofSoapBase64Binary = typeof(SoapBase64Binary);
        internal static Type typeofSoapInteger = typeof(SoapInteger);
        internal static Type typeofSoapPositiveInteger = typeof(SoapPositiveInteger);
        internal static Type typeofSoapNonPositiveInteger = typeof(SoapNonPositiveInteger);
        internal static Type typeofSoapNonNegativeInteger = typeof(SoapNonNegativeInteger);
        internal static Type typeofSoapNegativeInteger = typeof(SoapNegativeInteger);
        internal static Type typeofSoapAnyUri = typeof(SoapAnyUri);
        internal static Type typeofSoapQName = typeof(SoapQName);
        internal static Type typeofSoapNotation = typeof(SoapNotation);
        internal static Type typeofSoapNormalizedString = typeof(SoapNormalizedString);
        internal static Type typeofSoapToken = typeof(SoapToken);
        internal static Type typeofSoapLanguage = typeof(SoapLanguage);
        internal static Type typeofSoapName = typeof(SoapName);
        internal static Type typeofSoapIdrefs = typeof(SoapIdrefs);
        internal static Type typeofSoapEntities = typeof(SoapEntities);
        internal static Type typeofSoapNmtoken = typeof(SoapNmtoken);
        internal static Type typeofSoapNmtokens = typeof(SoapNmtokens);
        internal static Type typeofSoapNcName = typeof(SoapNcName);
        internal static Type typeofSoapId = typeof(SoapId);
        internal static Type typeofSoapIdref = typeof(SoapIdref);
        internal static Type typeofSoapEntity = typeof(SoapEntity);
        internal static Type typeofString = typeof(String);
        internal static Type typeofObject = typeof(Object);
        internal static Type typeofVoid = typeof(void);
        internal static Type typeofDateTime = typeof(DateTime);
        internal static Type typeofTimeSpan = typeof(TimeSpan);
        internal static Type typeofISoapXsd = typeof(ISoapXsd);


        
        internal static String GetXsdVersion(XsdVersion xsdVersion)
        {
            String version = null;
            if (xsdVersion == XsdVersion.V1999)
                version = Xsd1999;
            else if (xsdVersion == XsdVersion.V2000)
                version = Xsd2000;
            else
                version = Xsd2001;
            return version;
        }

        internal static String GetXsiVersion(XsdVersion xsdVersion)
        {
            String version = null;
            if (xsdVersion == XsdVersion.V1999)
                version = Xsi1999;
            else if (xsdVersion == XsdVersion.V2000)
                version = Xsi2000;
            else
                version = Xsi2001;
            return version;
        }

        internal static String MapClrTypeToXsdType(Type clrType)
        {
            String typeName = null;

            if (clrType == typeofChar)
                return null;


            if (clrType.IsPrimitive)
            {
                if (clrType == typeofByte)
                    typeName = "xsd:unsignedByte";
                else if (clrType == typeofSByte)
                    typeName = "xsd:byte";
                else if (clrType == typeofBoolean)
                    typeName = "xsd:boolean";
                else if (clrType == typeofChar)
                    typeName = "xsd:char"; //Not an xsd type, but need a way to identify a char
                else if (clrType == typeofDouble)
                    typeName = "xsd:double";
                else if (clrType == typeofSingle)
                    typeName = "xsd:float";
                else if (clrType == typeofDecimal)
                    typeName = "xsd:decimal";
                else if (clrType == typeofDateTime)
                    typeName = "xsd:dateTime";
                else if (clrType == typeofInt16)
                    typeName = "xsd:short";
                else if (clrType == typeofInt32)
                    typeName = "xsd:int";
                else if (clrType == typeofInt64)
                    typeName = "xsd:long";
                else if (clrType == typeofUInt16)
                    typeName = "xsd:unsignedShort";
                else if (clrType == typeofUInt32)
                    typeName = "xsd:unsignedInt";
                else if (clrType == typeofUInt64)
                    typeName = "xsd:unsignedLong";
                else if (clrType == typeofTimeSpan)
                    typeName = "xsd:duration";

            }
            else if (typeofISoapXsd.IsAssignableFrom(clrType))
            {
                if (clrType == typeofSoapTime)
                    typeName = SoapTime.XsdType;
                else if (clrType == typeofSoapDate)
                    typeName = SoapDate.XsdType;
                else if (clrType == typeofSoapYearMonth)
                    typeName = SoapYearMonth.XsdType;
                else if (clrType == typeofSoapYear)
                    typeName = SoapYear.XsdType;
                else if (clrType == typeofSoapMonthDay)
                    typeName = SoapMonthDay.XsdType;
                else if (clrType == typeofSoapDay)
                    typeName = SoapDay.XsdType;
                else if (clrType == typeofSoapMonth)
                    typeName = SoapMonth.XsdType;
                else if (clrType == typeofSoapHexBinary)
                    typeName = SoapHexBinary.XsdType;
                else if (clrType == typeofSoapBase64Binary)
                    typeName = SoapBase64Binary.XsdType;
                else if (clrType == typeofSoapInteger)
                    typeName = SoapInteger.XsdType;
                else if (clrType == typeofSoapPositiveInteger)
                    typeName = SoapPositiveInteger.XsdType;
                else if (clrType == typeofSoapNonPositiveInteger)
                    typeName = SoapNonPositiveInteger.XsdType;
                else if (clrType == typeofSoapNonNegativeInteger)
                    typeName = SoapNonNegativeInteger.XsdType;
                else if (clrType == typeofSoapNegativeInteger)
                    typeName = SoapNegativeInteger.XsdType;
                else if (clrType == typeofSoapAnyUri)
                    typeName = SoapAnyUri.XsdType;
                else if (clrType == typeofSoapQName)
                    typeName = SoapQName.XsdType;
                else if (clrType == typeofSoapNotation)
                    typeName = SoapNotation.XsdType;
                else if (clrType == typeofSoapNormalizedString)
                    typeName = SoapNormalizedString.XsdType;
                else if (clrType == typeofSoapToken)
                    typeName = SoapToken.XsdType;
                else if (clrType == typeofSoapLanguage)
                    typeName = SoapLanguage.XsdType;
                else if (clrType == typeofSoapName)
                    typeName = SoapName.XsdType;
                else if (clrType == typeofSoapIdrefs)
                    typeName = SoapIdrefs.XsdType;
                else if (clrType == typeofSoapEntities)
                    typeName = SoapEntities.XsdType;
                else if (clrType == typeofSoapNmtoken)
                    typeName = SoapNmtoken.XsdType;
                else if (clrType == typeofSoapNmtokens)
                    typeName = SoapNmtokens.XsdType;
                else if (clrType == typeofSoapNcName)
                    typeName = SoapNcName.XsdType;
                else if (clrType == typeofSoapId)
                    typeName = SoapId.XsdType;
                else if (clrType == typeofSoapIdref)
                    typeName = SoapIdref.XsdType;
                else if (clrType == typeofSoapEntity)
                    typeName = SoapEntity.XsdType;
                typeName = "xsd:"+typeName;
            }
            else if (clrType == typeofString)
                typeName = "xsd:string";
            else if (clrType == typeofDecimal)
                typeName = "xsd:decimal";
            else if (clrType == typeofObject)
                typeName = "xsd:anyType";
            else if (clrType == typeofVoid)
                typeName = "void";
            else if (clrType == typeofDateTime)
                typeName = "xsd:dateTime";
            else if (clrType == typeofTimeSpan)
                typeName = "xsd:duration";

            return typeName;
        }

        internal static String MapXsdToClrTypes(String xsdType)
        {
            String lxsdType = xsdType.ToLower(CultureInfo.InvariantCulture);
            String clrType = null;

            if (xsdType == null || xsdType.Length == 0)
                return null;

            switch (lxsdType[0])
            {
                case 'a':
                    if (lxsdType == "anyuri")
                        clrType = "SoapAnyUri";
                    else if (lxsdType == "anytype" || lxsdType == "ur-type")
                        clrType = "Object";

                    break;
                case 'b':
                    if (lxsdType == "boolean")
                        clrType = "Boolean";
                    else if (lxsdType == "byte")
                        clrType = "SByte";
                    else if (lxsdType == "base64binary")
                        clrType = "SoapBase64Binary";

                    break;
                case 'c':
                    if (lxsdType == "char")
                        clrType = "Char";
                    break;
                case 'd':
                    if (lxsdType == "double")
                        clrType = "Double";
                    else if (lxsdType == "datetime")
                        clrType = "DateTime";
                    else if (lxsdType == "decimal")
                        clrType = "Decimal";
                    else if (lxsdType == "duration")
                        clrType = "TimeSpan";
                    else if (lxsdType == "date")
                        clrType = "SoapDate";

                    break;
                case 'e':
                    if (lxsdType == "entities")
                        clrType = "SoapEntities";
                    else if (lxsdType == "entity")
                        clrType = "SoapEntity";
                    break;
                case 'f':
                    if (lxsdType == "float")
                        clrType = "Single";
                    break;
                case 'g':
                    if (lxsdType == "gyearmonth")
                        clrType = "SoapYearMonth";
                    else if (lxsdType == "gyear")
                        clrType = "SoapYear";
                    else if (lxsdType == "gmonthday")
                        clrType = "SoapMonthDay";
                    else if (lxsdType == "gday")
                        clrType = "SoapDay";
                    else if (lxsdType == "gmonth")
                        clrType = "SoapMonth";
                    break;
                case 'h':
                    if (lxsdType == "hexbinary")
                        clrType = "SoapHexBinary";
                    break;
                case 'i':
                    if (lxsdType == "int")
                        clrType = "Int32";
                    else if (lxsdType == "integer")
                        clrType = "SoapInteger";
                    else if (lxsdType == "idrefs")
                        clrType = "SoapIdrefs";
                    else if (lxsdType == "id")
                        clrType = "SoapId";
                    else if (lxsdType == "idref")
                        clrType = "SoapIdref";
                    break;
                case 'l':
                    if (lxsdType == "long")
                        clrType = "Int64";
                    else if (lxsdType == "language")
                        clrType = "SoapLanguage";
                    break;
                case 'n':
                    if (lxsdType == "number")
                        clrType = "Decimal";
                    else if (lxsdType == "normalizedstring")
                        clrType = "SoapNormalizedString";
                    else if (lxsdType == "nonpositiveinteger")
                        clrType = "SoapNonPositiveInteger";
                    else if (lxsdType == "negativeinteger")
                        clrType = "SoapNegativeInteger";
                    else if (lxsdType == "nonnegativeinteger")
                        clrType = "SoapNonNegativeInteger";
                    else if (lxsdType == "notation")
                        clrType = "SoapNotation";
                    else if (lxsdType == "nmtoken")
                        clrType = "SoapNmtoken";
                    else if (lxsdType == "nmtokens")
                        clrType = "SoapNmtokens";
                    else if (lxsdType == "name")
                        clrType = "SoapName";
                    else if (lxsdType == "ncname")
                        clrType = "SoapNcName";
                    break;
                case 'p':
                    if (lxsdType == "positiveinteger")
                        clrType = "SoapPositiveInteger";
                    break;
                case 'q':
                    if (lxsdType == "qname")
                        clrType = "SoapQName";
                    break;
                case 's':
                    if (lxsdType == "string")
                        clrType = "String";
                    else if (lxsdType == "short")
                        clrType = "Int16";
                    break;
                case 't':
                    if (lxsdType == "time")
                        clrType = "SoapTime";
                    else if (lxsdType == "token")
                        clrType = "SoapToken";
                    break;
                case 'u':
                    if (lxsdType == "unsignedlong")
                        clrType = "UInt64";
                    else if (lxsdType == "unsignedint")
                        clrType = "UInt32";
                    else if (lxsdType == "unsignedshort")
                        clrType = "UInt16";
                    else if (lxsdType == "unsignedbyte")
                        clrType = "Byte";
                    break;

                default:
                    break;
            }
            return clrType;
        }
    }

    internal sealed class Util
    {
        //internal static FileStream fout = null;
        internal static StreamWriter writer = null;

        [System.Diagnostics.Conditional("_LOGGING")]
        internal static void Log(String message)
        {
            //InternalRM.InfoSoap(message); //uncomment for traces
            /*
            if (fout == null)
            {
                fout = new FileStream("suds.log", FileMode.Create, FileAccess.Write, FileShare.ReadWrite);
                writer = new StreamWriter(fout);
                writer.AutoFlush = true;
            }
            writer.WriteLine(message);
            */
            //System.Runtime.Serialization.Formatters.InternalST.InfoSoap(messages);

        }

        [System.Diagnostics.Conditional("_LOGGING")]
        internal static void LogInput(ref TextReader input)
        {
            //System.Runtime.Serialization.Formatters.InternalST.InfoSoap(messages);
            if (InternalRM.SoapCheckEnabled())
            {
                String strbuffer = input.ReadToEnd();
                InternalRM.InfoSoap("******************WSDL******************");
                InternalRM.InfoSoap(strbuffer);
                InternalRM.InfoSoap("******************End WSDL******************");
                input = (TextReader)new StringReader(strbuffer);
            }
        }

        [System.Diagnostics.Conditional("_LOGGING")]
        internal static void LogString(String strbuffer)
        {
            InternalRM.InfoSoap("******************WSDL******************");
            InternalRM.InfoSoap(strbuffer);
            InternalRM.InfoSoap("******************End WSDL******************");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\managedlibraries\remoting\metadata\sdlwriter.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 **
 ** File:    SudsWriter.cool
 **
 ** Author:  Gopal Kakivaya (GopalK)
 **
 ** Purpose: Defines SUDSParser that parses a given SUDS document
 **          and generates types defined in it.
 **
 ** Date:    April 01, 2000
 ** Revised: November 15, 2000 (Wsdl) pdejong
 **
 ===========================================================*/
namespace System.Runtime.Remoting.MetadataServices
{
	using System;
	using System.Threading;
	using System.Collections;
	using System.Reflection;
	using System.Xml;
	using System.Diagnostics;
	using System.IO;
	using System.Text;
	using System.Net;
	using System.Runtime.Remoting.Messaging;
	using System.Runtime.Remoting.Metadata; 
	using System.Runtime.Remoting.Channels; // This is so we can get the resource strings.

	// This class generates SUDS documents
	internal class SdlGenerator
	{
		// Constructor
		internal SdlGenerator(Type[] types, TextWriter output)
		{
			Util.Log("SdlGenerator.SdlGenerator 1");
			_textWriter = output;
			_queue = new Queue();
			_name = null;
			_namespaces = new ArrayList();
			_dynamicAssembly = null;
			_serviceEndpoint = null;
			for (int i=0;i<types.Length;i++)
			{
				if (types[i] != null)
				{
					if (types[i].BaseType != null)
						_queue.Enqueue(types[i]);
				}
			}
		}

		// Constructor
		internal SdlGenerator(Type[] types, SdlType sdlType, TextWriter output)
		{
			Util.Log("SdlGenerator.SdlGenerator 2");
			_textWriter = output;
			_queue = new Queue();
			_name = null;
			_namespaces = new ArrayList();
			_dynamicAssembly = null;
			_serviceEndpoint = null;
			_sdlType = sdlType;
			for (int i=0;i<types.Length;i++)
			{
				if (types[i] != null)
				{
					if (types[i].BaseType != null)
						_queue.Enqueue(types[i]);
				}
			}
		}

		// Constructor
		internal SdlGenerator(Type[] types, TextWriter output, Assembly assembly, String url)
				: this(types, output)
		{
			Util.Log("SdlGenerator.SdlGenerator 3 "+url);           
			_dynamicAssembly = assembly;
			_serviceEndpoint = url;
		}

		// Constructor
		internal SdlGenerator(Type[] types, SdlType sdlType, TextWriter output, Assembly assembly, String url)
				: this(types, output)
		{
			Util.Log("SdlGenerator.SdlGenerator 4 "+url);           
			_dynamicAssembly = assembly;
			_serviceEndpoint = url;
			_sdlType = sdlType;
		}

		internal SdlGenerator(ServiceType[] serviceTypes, SdlType sdlType, TextWriter output)
		{
			Util.Log("SdlGenerator.SdlGenerator 5 ");
			_textWriter = output;
			_queue = new Queue();
			_name = null;
			_namespaces = new ArrayList();
			_dynamicAssembly = null;
			_serviceEndpoint = null;
			_sdlType = sdlType;

			for (int i=0; i<serviceTypes.Length; i++)
			{
				if (serviceTypes[i] != null)
				{
					if (serviceTypes[i].ObjectType.BaseType != null)
						_queue.Enqueue(serviceTypes[i].ObjectType);
				}

				// Associate serviceEndpoint with type. A type can multiple serviceEndpoints
				if (serviceTypes[i].Url != null)
				{
					if (_typeToServiceEndpoint == null)
						_typeToServiceEndpoint = new Hashtable(10);
					if (_typeToServiceEndpoint.ContainsKey(serviceTypes[i].ObjectType.Name))
					{
						ArrayList serviceEndpoints = (ArrayList)_typeToServiceEndpoint[serviceTypes[i].ObjectType.Name];
						serviceEndpoints.Add(serviceTypes[i].Url);
					}
					else
					{
						ArrayList serviceEndpoints = new ArrayList(10);
						serviceEndpoints.Add(serviceTypes[i].Url);
						_typeToServiceEndpoint[serviceTypes[i].ObjectType.Name] = serviceEndpoints;
					}

				}
			}
		}


		// Generates SUDS
		internal void Generate()
		{
			Util.Log("SdlGenerator.Generate");          
			// Generate the trasitive closure of the types reachable from
			// the supplied types
			while (_queue.Count > 0)
			{
				// Dequeue from not yet seen queue
				Type type = (Type) _queue.Dequeue();

				// Check if the type was encountered earlier
				String ns;
				Assembly assem;
				bool bInteropType = GetNSAndAssembly(type, out ns, out assem);
				Util.Log("SdlGenerator.Generate Dequeue "+type+" ns "+ns+" assem "+assem);                          
				XMLNamespace xns = LookupNamespace(ns, assem);
				if (xns != null)
				{
					if (xns.LookupSchemaType(type.Name) != null)
					{
						continue;
					}
				}
				else
				{
					xns = AddNamespace(ns, assem, bInteropType);
				}

				// Check if type needs to be represented as a SimpleSchemaType
				SimpleSchemaType ssType = SimpleSchemaType.GetSimpleSchemaType(type, xns, false);
				if (ssType != null)
				{
					// Add to namespace as a SimpleSchemaType
					xns.AddSimpleSchemaType(ssType);
				}
				else
				{
					// Check for the first MarshalByRef type
					bool bUnique = false;
					String connectURL = null;
					Hashtable connectTypeToServiceEndpoint = null;
					if ((_name == null) && s_marshalByRefType.IsAssignableFrom(type))
					{
						_name = type.Name;
						_targetNS = xns.Namespace;
						connectURL = _serviceEndpoint;
						connectTypeToServiceEndpoint = _typeToServiceEndpoint;
						bUnique = true;
					}
					RealSchemaType rsType = new RealSchemaType(type, xns, connectURL, connectTypeToServiceEndpoint, bUnique);

					// Add to namespace as a RealSchemaType
					xns.AddRealSchemaType(rsType);

					// Enqueue types reachable from this type
					EnqueueReachableTypes(rsType);
				}
			}

			// At this point we have the complete list of types
			// to be processed. Resolve cross references between
			// them
			Resolve();

			// At this stage, we are ready to print the schemas
			PrintSdl();

			// Flush cached buffers
			_textWriter.Flush();

			return;
		}

		// Adds types reachable from the given type
		private void EnqueueReachableTypes(RealSchemaType rsType)
		{
			Util.Log("SdlGenerator.EnqueueReachableTypes ");            
			// Get the XML namespace object
			XMLNamespace xns = rsType.XNS;

			// Process base type
			if (rsType.Type.BaseType != null)
				AddType(rsType.Type.BaseType, xns);

			// Check if this is a suds type
			bool bSUDSType = rsType.Type.IsInterface ||
							 s_marshalByRefType.IsAssignableFrom(rsType.Type) ||
							 s_delegateType.IsAssignableFrom(rsType.Type);
			if (bSUDSType)
			{
				// Process implemented interfaces
				Type[] interfaces = rsType.GetIntroducedInterfaces();
				if (interfaces.Length > 0)
				{
					for (int i=0;i<interfaces.Length;i++)
					{
						Util.Log("SdlGenerator.EnqueueReachableTypes Interfaces "+interfaces[i].Name+" "+xns.Name);                     
						AddType(interfaces[i], xns);
					}
				}

				// Process methods
				MethodInfo[] methods = rsType.GetIntroducedMethods();
				if (methods.Length > 0)
				{
					String methodNSString = null;
					XMLNamespace methodXNS = null;  

					if (xns.IsInteropType)
					{
						methodNSString = xns.Name;
						methodXNS = xns;
					}
					else
					{
						StringBuilder sb = new StringBuilder();
						sb.Append(xns.Name);
						sb.Append('.');
						sb.Append(rsType.Name);
						methodNSString = sb.ToString();
						methodXNS = AddNamespace(methodNSString, xns.Assem);
						xns.DependsOnSchemaNS(methodXNS);
					}

					for (int i=0;i<methods.Length;i++)
					{
						MethodInfo method = methods[i];
						Util.Log("SdlGenerator.EnqueueReachableTypes methods "+method.Name+" "+methodXNS.Name);
						AddType(method.ReturnType, methodXNS);
						ParameterInfo[] parameters = method.GetParameters();
						for (int j=0;j<parameters.Length;j++)
							AddType(parameters[j].ParameterType, methodXNS);
					}
				}
			}
			else
			{
				// Process fields
				FieldInfo[] fields = rsType.GetInstanceFields();
				for (int i=0;i<fields.Length;i++)
				{
					if (fields[i].FieldType == null)
						continue;
					AddType(fields[i].FieldType, xns);
				}
			}

			return;
		}

		// Adds the given type if it has not been encountered before
		private void AddType(Type type, XMLNamespace xns)
		{
			Util.Log("SdlGenerator.AddTypes "+type);                        
			//         System.Array says that it has element type, but returns null
			//         when asked for the element type. IMO, System.Array should not
			//         say that it has an element type. I have already pointed this
			//         out to David Mortenson
			if (type.HasElementType)
			{
				Type eType = type.GetElementType();
				if (eType != null)
				{
					type = eType;
					while (type.HasElementType)
						type = type.GetElementType();
				}
			}

			if (type.IsPrimitive == false)
			{
				String ns;
				Assembly assem;
				bool bInteropType = GetNSAndAssembly(type, out ns, out assem);

				// Lookup the namespace
				XMLNamespace dependsOnNS = LookupNamespace(ns, assem);
				// Creat a new namespace if neccessary
				if (dependsOnNS == null)
					dependsOnNS = AddNamespace(ns, assem, bInteropType);

				// The supplied namespace depends directly on the namespace of the type
				xns.DependsOnSchemaNS(dependsOnNS);

				// Enqueue the type if does not belong to system namespace
				if ((ns == null) || !ns.StartsWith("System"))
				{
					_queue.Enqueue(type);
				}
			}

			return;
		}

		private static bool GetNSAndAssembly(Type type, out String ns, out Assembly assem)
		{
			Util.Log("SdlGenerator.GetNSAndAssembly "+type);

			String xmlNamespace = null;
			String xmlElement = null;
			bool bInterop = false;
			SoapServices.GetXmlElementForInteropType(type, out xmlElement, out xmlNamespace);
			if (xmlNamespace != null)
			{
				ns = xmlNamespace;
				assem = null;
				bInterop = true;
			}
			else
			{
				// Return the namespace and assembly in which the type is defined
				ns = type.Namespace;
				assem = type.Module.Assembly;
				bInterop = false;
			}
			return bInterop;
		}

		private XMLNamespace LookupNamespace(String name, Assembly assem)
		{
			Util.Log("SdlGenerator.LookupNamespace "+name);                     
			for (int i=0;i<_namespaces.Count;i++)
			{
				XMLNamespace xns = (XMLNamespace) _namespaces[i];
				if ((name == xns.Name) && (assem == xns.Assem))
					return(xns);
			}

			return(null);
		}

		private XMLNamespace AddNamespace(String name, Assembly assem)
		{
			return AddNamespace(name, assem, false);
		}

		private XMLNamespace AddNamespace(String name, Assembly assem, bool bInteropType)
		{
			Util.Log("SdlGenerator.AddNamespace "+name);                        
			Debug.Assert(LookupNamespace(name, assem) == null, "Duplicate Type found");

			XMLNamespace xns = new XMLNamespace(name, assem,
												//(assem == _dynamicAssembly) ? _serviceEndpoint : null,
												_serviceEndpoint,
												_typeToServiceEndpoint,
												"ns" + _namespaces.Count,
												bInteropType);
			_namespaces.Add(xns);

			return(xns);
		}

		// Maps schema types to schema types
		private static String MapURTTypesToSchemaTypes(String typeName)
		{
			Util.Log("SdlGenerator.MapURTTypesToSchemaTypes "+typeName);                        
			String newTypeName = typeName;
			if (typeName == "SByte")
				newTypeName = "byte";
			else if (typeName == "Byte")
				newTypeName = "unsigned-byte";
			else if (typeName == "Int16")
				newTypeName = "short";
			else if (typeName == "UInt16")
				newTypeName = "unsigned-short";
			else if (typeName == "Int32")
				newTypeName = "int";
			else if (typeName == "UInt32")
				newTypeName = "unsigned-int";
			else if (typeName == "Int64")
				newTypeName = "long";
			else if (typeName == "UInt64")
				newTypeName = "unsigned-long";
			else if (typeName == "Char")
				newTypeName = "character";
			else if (typeName == "Single")
				newTypeName = "float";
			else if (typeName == "Double")
				newTypeName = "double";
			else if (typeName == "Boolean")
				newTypeName = "boolean";
			else if (typeName == "DateTime")
				newTypeName = "timeInstant";

			return(newTypeName);
		}

		private void Resolve()
		{
			Util.Log("SdlGenerator.Resolve ");                      
			for (int i=0;i<_namespaces.Count;i++)
				((XMLNamespace) _namespaces[i]).Resolve();

			return;
		}

		private void PrintSdl()
		{
			Util.Log("SdlGenerator.PrintSdl");                                                          
			String indent = "";
			String indent1 = IndentP(indent);
			_textWriter.WriteLine("<?xml version='1.0' encoding='UTF-8'?>");
			_textWriter.Write("<serviceDescription ");
			if (_name != null)
			{
				_textWriter.Write("name='");
				_textWriter.Write(_name);
				_textWriter.WriteLine('\'');
				_textWriter.Write("                    targetNamespace='");
				_textWriter.Write(_targetNS);
				_textWriter.WriteLine('\'');
				_textWriter.Write("                    ");
			}
			_textWriter.WriteLine("xmlns='urn:schemas-xmlsoap-org:sdl.2000-01-25'>");
			for (int i=0;i<_namespaces.Count;i++)
				((XMLNamespace) _namespaces[i]).PrintSdl(_textWriter, indent1);
			_textWriter.WriteLine("</serviceDescription>");

			return;
		}



		// Private fields
		private TextWriter _textWriter;
		private Queue _queue;
		private String _name;
		private String _targetNS;
		private ArrayList _namespaces;
		private Assembly _dynamicAssembly;
		private String _serviceEndpoint; //service endpoint for all types
		private SdlType _sdlType = SdlType.Sdl;
		internal Hashtable _typeToServiceEndpoint; //service endpoint for each type

		private static Type s_marshalByRefType = typeof(System.MarshalByRefObject);
		private static Type s_contextBoundType = typeof(System.ContextBoundObject);
		private static Type s_delegateType = typeof(System.Delegate);

		private static Type s_remotingClientProxyType = typeof(System.Runtime.Remoting.Services.RemotingClientProxy);
		private static SchemaBlockType blockDefault = SchemaBlockType.SEQUENCE;

		/***************************************************************
		 **
		 ** Private classes used by SUDS generator
		 **
		 ***************************************************************/
		private interface IAbstractElement
		{
			void Print(TextWriter textWriter, StringBuilder sb, String indent);
		}

		private class EnumElement : IAbstractElement
		{
			internal EnumElement(String value)
			{
				Util.Log("EnumElement.EnumElement "+value);
				_value = value;
			}

			public void Print(TextWriter textWriter, StringBuilder sb, String indent)
			{
				Util.Log("EnumElement.Print");
				sb.Length = 0;
				sb.Append(indent);
				sb.Append("<enumeration value='");
				sb.Append(_value);
				sb.Append("'/>");
				textWriter.WriteLine(sb);
				return;
			}

			// Fields
			private String _value;
		}

		private class EncodingElement : IAbstractElement
		{
			public EncodingElement(String value)
			{
				Util.Log("EncodingElement.EncodingElement "+value);
				_value = value;
			}

			public void Print(TextWriter textWriter, StringBuilder sb, String indent)
			{
				Util.Log("EncodingElement.Print");
				sb.Length = 0;
				sb.Append(indent);
				sb.Append("<encoding value='");
				sb.Append(_value);
				sb.Append("'/>");
				textWriter.WriteLine(sb);
				return;
			}

			// Fields
			private String _value;
		}

		private class SchemaAttribute : IAbstractElement
		{
			internal SchemaAttribute(String name, String type)
			{
				Util.Log("SchemaAttribute "+name+" type "+type);
				_name = name;
				_type = type;
			}

			public void Print(TextWriter textWriter, StringBuilder sb, String indent)
			{
				Util.Log("SchemaAttribute.Print");
				sb.Length = 0;
				sb.Append(indent);
				sb.Append("<attribute name='");
				sb.Append(_name);
				sb.Append("' type='");
				sb.Append(_type);
				sb.Append("'/>");
				textWriter.WriteLine(sb);

				return;
			}

			// Fields
			private String _name;
			private String _type;
		}

		private abstract class Particle : IAbstractElement
		{
			protected Particle() {}
			public abstract void Print(TextWriter textWriter, StringBuilder sb, String indent);
		}

		private class SchemaElement : Particle
		{
			internal SchemaElement(String name, Type type, bool bEmbedded, XMLNamespace xns)
					: base()
			{
				Util.Log("SchemaElement.SchemaElement Particle "+name+" type "+type+" bEmbedded "+bEmbedded);
				_name = name;
				_typeString = null;
				_schemaType = SimpleSchemaType.GetSimpleSchemaType(type, xns, true);
				if (_schemaType == null)
					_typeString = RealSchemaType.TypeName(type, bEmbedded, xns);
			}

			public override void Print(TextWriter textWriter, StringBuilder sb, String indent)
			{
				Util.Log("SchemaElement.Print");
				sb.Length = 0;
				sb.Append(indent);
				sb.Append("<element name='");
				sb.Append(_name);
				if (_schemaType != null)
				{
					sb.Append("'>");
					textWriter.WriteLine(sb);
					_schemaType.PrintSchemaType(textWriter, sb, IndentP(indent), true);

					sb.Length = 0;
					sb.Append(indent);
					sb.Append("</element>");
				}
				else
				{
					if (_typeString != null)
					{
						sb.Append("' type='");
						sb.Append(_typeString);
						sb.Append('\'');
					}
					sb.Append("/>");
				}
				textWriter.WriteLine(sb);

				return;
			}

			// Fields
			private String _name;
			private String _typeString;
			private SchemaType _schemaType;
		}

		private abstract class SchemaType
		{
			internal abstract void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous);
		}

		private class SimpleSchemaType : SchemaType
		{
			private SimpleSchemaType(Type type, XMLNamespace xns)
			{
				Util.Log("SimpleSchemaType.SimpleSchemaType "+type+" xns "+((xns != null) ? xns.Name : "Null"));
				_type = type;
				_xns = xns;
				_abstractElms = new ArrayList();
			}

			internal Type Type
			{
				get { return(_type);}
			}

			internal String BaseName
			{
				get { return(_baseName);}
			}

			internal XMLNamespace XNS
			{
				get { return(_xns);}
			}

			internal override void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous)
			{
				Util.Log("SimpleSchemaType.PrintSchemaType");
				sb.Length = 0;
				sb.Append(indent);
				if (bAnonymous == false)
				{
					sb.Append("<simpleType name='");
					sb.Append(_type.Name);
					sb.Append("' base='");
				}
				else
				{
					sb.Append("<simpleType base='");
				}
				sb.Append(BaseName);
				bool bEmpty = _abstractElms.Count == 0;
				if (bEmpty)
					sb.Append("'/>");
				else
					sb.Append("'>");
				textWriter.WriteLine(sb);
				if (bEmpty)
					return;

				if (_abstractElms.Count > 0)
				{
					for (int i=0;i<_abstractElms.Count; i++)
						((IAbstractElement) _abstractElms[i]).Print(textWriter, sb, IndentP(indent));
				}

				textWriter.Write(indent);
				textWriter.WriteLine("</simpleType>");

				return;
			}

			internal static SimpleSchemaType GetSimpleSchemaType(Type type, XMLNamespace xns, bool fInline)
			{
				Util.Log("SimpleSchemaType.GetSimpleSchemaType "+type+" xns "+xns.Name);                
				SimpleSchemaType ssType = null;
				if (fInline)
				{
					if ((type.IsArray == true) &&
						  (type.GetArrayRank() == 1) &&
						  (type.GetElementType() == typeof(byte)))
					{
						if (_byteArraySchemaType == null)
						{
							_byteArraySchemaType = new SimpleSchemaType(type, null);
							_byteArraySchemaType._baseName = "xsd:binary";
							_byteArraySchemaType._abstractElms.Add(new EncodingElement("base64"));
						}
						ssType = _byteArraySchemaType;
					}
				}
				else
				{
					if (type.IsEnum)
					{
						ssType = new SimpleSchemaType(type, xns);
						ssType._baseName = RealSchemaType.TypeName(Enum.GetUnderlyingType(type), true, null);
						String[] values = Enum.GetNames(type);
						for (int i=0;i<values.Length;i++)
							ssType._abstractElms.Add(new EnumElement(values[i]));
					}
					else
					{
					}
				}

				return(ssType);
			}

			private Type _type;
			private String _baseName;
			private XMLNamespace _xns;
			private ArrayList _abstractElms;

			private static SimpleSchemaType _byteArraySchemaType = null;
		}

		private abstract class ComplexSchemaType : SchemaType
		{
			internal ComplexSchemaType(String name, bool bSealed)
			{
				Util.Log("ComplexSchemaType.ComplexSchemaType "+name+" bSealed "+bSealed);              
				_name = name;
				_baseName = null;
				_elementName = name;
				_bSealed = bSealed;
				_blockType = SchemaBlockType.ALL;
				_particles = new ArrayList();
				_abstractElms = new ArrayList();
			}

			internal String Name
			{
				get { return(_name);}
				set { _name = value;}
			}

			protected String BaseName
			{
				get { return(_baseName);}
				set { _baseName = value;}
			}

			internal String ElementName
			{
				get { return(_elementName);}
				set { _elementName = value;}
			}

			protected SchemaBlockType BlockType
			{
				get { return(_blockType);}
				set { _blockType = value;}
			}

			protected bool IsSealed
			{
				get { return(_bSealed);}
			}

			protected bool IsEmpty
			{
				get {
					return((_abstractElms.Count == 0) &&
						   (_particles.Count == 0));
				}
			}

			internal void AddParticle(Particle particle)
			{
				Util.Log("SimpleSchemaType.AddParticle");               
				_particles.Add(particle);
			}

			internal void AddAbstractElement(IAbstractElement elm)
			{
				Util.Log("SimpleSchemaType.AddAbstractElement");                
				_abstractElms.Add(elm);
			}

			protected void PrintBody(TextWriter textWriter, StringBuilder sb, String indent)
			{
				Util.Log("SimpleSchemaType.PrintBody");             
				int particleCount = _particles.Count;
				String indent1 = IndentP(indent);
				if (particleCount > 0)
				{
					bool bPrintBlockElms = /*(particleCount > 1) && */(SdlGenerator.blockDefault != _blockType);
					if (bPrintBlockElms)
					{
						sb.Length = 0;
						sb.Append(indent);
						sb.Append(schemaBlockBegin[(int) _blockType]);
						textWriter.WriteLine(sb);
					}

					for (int i=0;i<particleCount; i++)
						((Particle) _particles[i]).Print(textWriter, sb, IndentP(indent1));

					if (bPrintBlockElms)
					{
						sb.Length = 0;
						sb.Append(indent);
						sb.Append(schemaBlockEnd[(int) _blockType]);
						textWriter.WriteLine(sb);
					}
				}

				int abstractElmCount = _abstractElms.Count;
				for (int i=0;i<abstractElmCount; i++)
					((IAbstractElement) _abstractElms[i]).Print(textWriter, sb, IndentP(indent));

				return;
			}

			private String _name;
			private String _baseName;
			private String _elementName;
			private bool _bSealed;
			private SchemaBlockType _blockType;
			private ArrayList _particles;
			private ArrayList _abstractElms;

			static private String[] schemaBlockBegin = { "<all>", "<sequence>", "<choice>"};
			static private String[] schemaBlockEnd = { "</all>", "</sequence>", "</choice>"};
		}

		private class PhonySchemaType : ComplexSchemaType
		{
			internal PhonySchemaType(String name)
					: base(name, true)
			{
				Util.Log("PhonySchemaType.PhonySchemaType "+name);              
				_numOverloadedTypes = 0;
			}

			internal int OverloadedType()
			{
				Util.Log("PhonySchemaType.OverLoadedTypeType");             
				return(++_numOverloadedTypes);
			}

			internal override void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous)
			{
				Util.Log("PhonySchemaType.PrintSchemaType");                
				Debug.Assert(bAnonymous == true, "PhonySchemaType should always be printed as anonymous types");
				String indent1 = IndentP(indent);
				String indent2 = IndentP(indent1);              
				sb.Length = 0;
				sb.Append(indent);
				sb.Append("<element name='");
				sb.Append(ElementName);
				sb.Append("'>");
				textWriter.WriteLine(sb);

				sb.Length = 0;
				sb.Append(indent1);
				sb.Append("<complexType");
				if (BaseName != null)
				{
					sb.Append(" base='");
					sb.Append(BaseName);
					sb.Append('\'');
				}
				bool bEmpty = IsEmpty;
				if (bEmpty)
					sb.Append("/>");
				else
					sb.Append('>');
				textWriter.WriteLine(sb);

				if (bEmpty == false)
				{
					base.PrintBody(textWriter, sb, indent2);

					textWriter.Write(indent1);
					textWriter.WriteLine("</complexType>");
				}

				textWriter.Write(indent);
				textWriter.WriteLine("</element>");

				return;
			}

			private int _numOverloadedTypes;
		}

		private class RealSchemaType : ComplexSchemaType
		{
			internal RealSchemaType(Type type, XMLNamespace xns, String serviceEndpoint, Hashtable typeToServiceEndpoint, bool bUnique)
					: base(type.Name, type.IsSealed)
			{
				Util.Log("RealSchemaType.RealSchemaType "+type+" xns "+xns.Name+" serviceEndpoint "+serviceEndpoint+" bUnique "+bUnique);               
				_type = type;
				_serviceEndpoint = serviceEndpoint;
				_typeToServiceEndpoint = typeToServiceEndpoint;
				_bUnique = bUnique;
				_bStruct = type.IsValueType;
				_xns = xns;
				_implIFaces = null;
				_iFaces = null;
				_methods = null;
				_fields = null;
				_methodTypes = null;
			}

			internal Type Type
			{
				get { return(_type);}
			}

			internal XMLNamespace XNS
			{
				get { return(_xns);}
			}

			internal bool IsStruct
			{
				get { return(_bStruct);}
			}

			internal bool IsUnique
			{
				get { return(_bUnique);}
			}

			internal bool IsSUDSType
			{
				get { return((_fields == null) &&
							 ((_iFaces.Length > 0) || (_methods.Length > 0) ||
							  (_type.IsInterface) || (s_delegateType.IsAssignableFrom(_type))));}
			}

			internal Type[] GetIntroducedInterfaces()
			{
				Util.Log("RealSchemaType.GetIntroducedInterfaces");
				Debug.Assert(_iFaces == null, "variable set");
				_iFaces = GetIntroducedInterfaces(_type);
				return(_iFaces);
			}

			internal MethodInfo[] GetIntroducedMethods()
			{
				Util.Log("RealSchemaType.GetIntroducedMethods");                
				Debug.Assert(_methods == null, "variable set");
				_methods = GetIntroducedMethods(_type);
				_methodTypes = new String[2*_methods.Length];
				return(_methods);
			}

			internal FieldInfo[] GetInstanceFields()
			{
				Util.Log("RealSchemaType.GetInstanceFields");               
				Debug.Assert(_fields == null, "variable set");
				Debug.Assert(!SdlGenerator.s_marshalByRefType.IsAssignableFrom(_type), "Invalid Type");
				_fields = GetInstanceFields(_type);
				return(_fields);
			}

			internal void Resolve(StringBuilder sb)
			{
				Util.Log("RealSchemaType.Resolve");             
				sb.Length = 0;

				// Check if this is a suds type
				bool bSUDSType = IsSUDSType;

				// Resolve base type eliminating system defined roots of the class heirarchy
				if (!_type.IsInterface &&
					  !_type.IsValueType &&
					  (_type.BaseType.BaseType != null) &&
					  (_type.BaseType != SdlGenerator.s_marshalByRefType) &&
					  (_type.BaseType != SdlGenerator.s_contextBoundType) &&
					  (_type.BaseType != SdlGenerator.s_remotingClientProxyType) &&
					  ((_type.IsCOMObject == false) ||
					   (_type.BaseType.BaseType.IsCOMObject == true)))
				{
					String ns;
					Assembly assem;
					Util.Log("RealSchemaType.Resolve Not System Defined root "+_type.BaseType);                                 
					bool InteropType = SdlGenerator.GetNSAndAssembly(_type.BaseType, out ns, out assem);
					XMLNamespace xns = _xns.LookupSchemaNamespace(ns, assem);
					Debug.Assert(xns != null, "Namespace should have been found");
					sb.Append(xns.Prefix);
					sb.Append(':');
					sb.Append(_type.BaseType.Name);
					BaseName = sb.ToString();
					if (bSUDSType)
						_xns.DependsOnSUDSNS(xns);
				}

				// The element definition of this type depends on itself
				_xns.DependsOnSchemaNS(_xns);

				if (bSUDSType)
				{
					Util.Log("RealSchemaType.Resolve AddRealSUDSType  "+_type);                                                     
					_xns.AddRealSUDSType(this);

					// Resolve interfaces introduced by this type
					if (_iFaces.Length > 0)
					{
						_implIFaces = new String[_iFaces.Length];
						for (int i=0;i<_iFaces.Length;i++)
						{
							String ns;
							Assembly assem;
							Util.Log("RealSchemaType.Resolve iFace  "+_iFaces[i].Name);                                                                                     
							bool bInteropType = SdlGenerator.GetNSAndAssembly(_iFaces[i], out ns, out assem);
							XMLNamespace xns = _xns.LookupSchemaNamespace(ns, assem);
							Debug.Assert(xns != null, "SchemaType should have been found");
							sb.Length = 0;
							sb.Append(xns.Prefix);
							sb.Append(':');
							sb.Append(_iFaces[i].Name);
							_implIFaces[i] = sb.ToString();
							_xns.DependsOnSUDSNS(xns);
						}
					}

					// Resolve methods introduced by this type
					if (_methods.Length > 0)
					{
						String useNS = null;
						if (_xns.IsInteropType)
							useNS = _xns.Name;
						else
						{
							sb.Length = 0;
							sb.Append(_xns.Name);
							sb.Append('.');
							sb.Append(Name);
							useNS = sb.ToString();
						}
						XMLNamespace methodXNS = _xns.LookupSchemaNamespace(useNS, _xns.Assem);
						Debug.Assert(methodXNS != null, "Namespace is null");
						_xns.DependsOnSUDSNS(methodXNS);
						for (int i=0;i<_methods.Length;i++)
						{
							// Process the request
							MethodInfo method = _methods[i];
							String methodRequestName = method.Name;
							Util.Log("RealSchemaType.Resolve Phony  "+methodRequestName);                                                                                                                   
							PhonySchemaType methodRequest = new PhonySchemaType(methodRequestName);
							ParameterInfo[] parameters = method.GetParameters();
							for (int j=0;j<parameters.Length;j++)
							{
								ParameterInfo parameter = parameters[j];
								if (!parameter.IsOut)
									methodRequest.AddParticle(new SchemaElement(parameter.Name,
										parameter.ParameterType,
										false, methodXNS));
							}
							methodXNS.AddPhonySchemaType(methodRequest);
							_methodTypes[2*i] = methodRequest.ElementName;

							if (!RemotingServices.IsOneWay(method))
							{
								// Process response (look at custom attributes to get values

								String returnName = null;
								SoapMethodAttribute soapAttribute = (SoapMethodAttribute)InternalRemotingServices.GetCachedSoapAttribute(method);
								if (soapAttribute.ReturnXmlElementName != null)
									returnName = soapAttribute.ReturnXmlElementName;
								else
									returnName = "__return";

								String responseName = null;
								if (soapAttribute.ResponseXmlElementName != null)
									responseName = soapAttribute.ResponseXmlElementName;
								else
									responseName = methodRequestName + "Response";

								Util.Log("RealSchemaType.Resolve Phony  "+responseName);                                                                                                                    
								PhonySchemaType methodResponse = new PhonySchemaType(responseName);
								//  Handle a void method that has an out parameter. This can only
								//         be handled through parameterOrder attribute
								if (method.ReturnType.FullName != "System.Void")
									methodResponse.AddParticle(new SchemaElement(returnName,
										method.ReturnType,
										false, methodXNS));

								for (int j=0;j<parameters.Length;j++)
								{
									ParameterInfo parameter = parameters[j];
									/*if(!parameter.IsIn &&
									(parameter.ParameterType.IsByRef ||
									(!parameter.ParameterType.IsPrimitive &&
									parameter.ParameterType.FullName != "System.String")))*/
									if (parameter.IsOut || parameter.ParameterType.IsByRef)
										methodResponse.AddParticle(new SchemaElement(parameter.Name,
											parameter.ParameterType,
											false, methodXNS));
								}
								methodXNS.AddPhonySchemaType(methodResponse);
								_methodTypes[2*i+1] = methodResponse.ElementName;
							}
						}
					}
				}

				// Resolve fields
				if (_fields != null)
				{
					for (int i=0;i<_fields.Length;i++)
					{
						FieldInfo field = _fields[i];
						Debug.Assert(!field.IsStatic, "Static field");
						Type fieldType = field.FieldType;
						if (fieldType == null)
							fieldType = typeof(Object);
						Util.Log("RealSchemaType.Resolve fields  "+field.Name+" type "+fieldType);                                                                                                              
						AddParticle(new SchemaElement(field.Name, fieldType, false, _xns));
					}
				}

				// Resolve attribute elements
				if (_bStruct == false)
					AddAbstractElement(new SchemaAttribute("id", "xsd:ID"));

				return;
			}

			internal override void PrintSchemaType(TextWriter textWriter, StringBuilder sb, String indent, bool bAnonymous)
			{
				Util.Log("RealSchemaType.PrintSchemaType");             
				if (bAnonymous == false)
				{
					sb.Length = 0;
					sb.Append(indent);
					sb.Append("<element name='");
					sb.Append(ElementName);
					sb.Append("' type='");
					sb.Append(_xns.Prefix);
					sb.Append(':');
					sb.Append(Name);
					sb.Append("'/>");
					textWriter.WriteLine(sb);
				}

				sb.Length = 0;
				sb.Append(indent);
				if (bAnonymous == false)
				{
					sb.Append("<complexType name='");
					sb.Append(Name);
					sb.Append('\'');
				}
				else
				{
					sb.Append("<complexType ");
				}
				if (BaseName != null)
				{
					sb.Append(" base='");
					sb.Append(BaseName);
					sb.Append('\'');
				}
				if ((IsSealed == true) &&
					  (bAnonymous == false))
					sb.Append(" final='#all'");
				bool bEmpty = IsEmpty;
				if (bEmpty)
					sb.Append("/>");
				else
					sb.Append('>');
				textWriter.WriteLine(sb);
				if (bEmpty)
					return;

				base.PrintBody(textWriter, sb, indent);

				textWriter.Write(indent);
				textWriter.WriteLine("</complexType>");

				return;
			}


			internal void PrintSUDSType(TextWriter textWriter, StringBuilder sb, String indent)
			{
				Util.Log("RealSchemaType.PrintSUDSType");                               
				String elementTag = "<service name='";
				String implTag = "<implements name='";
				String indent1 = IndentP(indent);
				String indent2 = IndentP(indent1);
				if (_type.IsInterface)
				{
					elementTag = "<interface name='";
					implTag = "<extends name='";
				}

				sb.Length = 0;
				sb.Append(indent);
				if (_bUnique)
				{
					sb.Append("<service");
				}
				else
				{
					sb.Append(elementTag);
					sb.Append(Name);
				}

				bool bExtendsElm = (BaseName != null);
				if ((bExtendsElm == false) && (_implIFaces == null) && (_methods.Length == 0))
				{
					if (_bUnique)
						sb.Append("/>");
					else
						sb.Append("'/>");
					textWriter.WriteLine(sb);
					return;
				}
				if (_bUnique)
					sb.Append('>');
				else
					sb.Append("'>");
				textWriter.WriteLine(sb);

				if (bExtendsElm)
				{
					sb.Length = 0;
					sb.Append(indent1);
					sb.Append("<extends name='");
					sb.Append(BaseName);
					sb.Append("'/>");
					textWriter.WriteLine(sb);
				}
				if (_implIFaces != null)
				{
					for (int i=0;i<_implIFaces.Length;i++)
					{
						if (_implIFaces[i] != String.Empty)
						{
							sb.Length = 0;
							sb.Append(indent1);
							sb.Append(implTag);
							sb.Append(_implIFaces[i]);
							sb.Append("'/>");
							textWriter.WriteLine(sb);
						}
					}
				}

				if (_methods.Length > 0)
				{
					String useNS = null;
					if (_xns.IsInteropType)
						useNS = _xns.Name;
					else
					{
						sb.Length = 0;
						sb.Append(_xns.Name);
						sb.Append('.');
						sb.Append(Name);
						useNS = sb.ToString();
					}
					XMLNamespace methodXns = _xns.LookupSche