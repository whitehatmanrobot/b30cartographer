                               &pClassInfo->pOldObjClasses,
                                                      &pClassInfo->cOldObjClasses_alloced,
                                                      &pClassInfo->cOldObjClasses,
                                                      NULL)) {
                        return err;
                    }
                    *ppClassInfo = pClassInfo;
                }
                else {
                    Assert (ppClassInfo);
                    Assert (*ppClassInfo);
                    pClassInfo = *ppClassInfo;
                }
                break;

   
            case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                // check if additional-dns-host-name is changed but forest version is < whistler
                if ( !pTHS->fDSA ) {

                    if (gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET ) 
                      {
                         return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                            ERROR_DS_NOT_SUPPORTED);
                      }
                }
                break;



            case ATT_MS_DS_NC_REPLICA_LOCATIONS:
                // If were modifying a replica set on a crossRef, check that the this
                // crossRef is enabled. (or that we are fDSA in the case of a creation
                // of a new NDNC)
                if ( !pTHS->fDSA ){
                    // Get the Enabled attribute off this object/CR.
                    err = DBGetSingleValue(pTHS->pDB,
                                           ATT_ENABLED,
                                           &fEnabledCR,
                                           sizeof(fEnabledCR),
                                           NULL);
                    if(err == DB_ERR_NO_VALUE){
                        // Deal w/ no value, because, no value means TRUE in
                        // the context of the Enabled attribute.
                        fEnabledCR = TRUE;
                    } else if (err){
                        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                      DIRERR_UNKNOWN_ERROR,
                                      err);
                        return(pTHS->errCode);
                    }

                    if(!fEnabledCR){
                        // This cross ref is disabled, and we're trying to add/delete
                        // something from the replica set, that's No Good!
                        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR);
                        return(pTHS->errCode);
                    }
                }
                break;


            case ATT_GROUP_TYPE:

                // check whether we are changing the group type 

                if (hVerifyAtts->fGroupTypeChange = fGroupObject) {

                    // originating change on group type - keep copy of
                    // the old group type
                    err = DBGetSingleValue(pTHS->pDB,
                                           ATT_GROUP_TYPE,
                                           &hVerifyAtts->ulGroupTypeOld,
                                           sizeof(hVerifyAtts->ulGroupTypeOld),
                                           NULL);
                    if (err) {
                        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                                      ERROR_DS_MISSING_EXPECTED_ATT,
                                      err); 
                        return pTHS->errCode;
                    }
                }
                break;

            case ATT_MS_DS_UPDATESCRIPT:

                // check that the DC holds the Domain FSMO role
                err = CheckRoleOwnership( pTHS,
                                          gAnchor.pPartitionsDN,
                                          pModifyArg->pResObj->pObj );

                if (err) {
                    DPRINT(0, "DC should hold the domain FSMO role to update script \n");
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
                    return pTHS->errCode;
                }

                // check that the user has used a secure (encryption implies sign-and-seal).
                if (pTHS->CipherStrength < 128) {
                    DPRINT(0, "msDs-UpdateScript can only be modified over a secure LDAP connection\n");
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_CONFIDENTIALITY_REQUIRED);
                    return pTHS->errCode;
                }
                break;


           case ATT_WELL_KNOWN_OBJECTS:
                // DCR: Enable Redirecting Default Users and Computers Container locations
                //
                // we allow these containers to be redirected to new locations
                // on the PDC via a special modify of this attribute on the
                // domainDNS object.  this change is accompanied by the transfer
                // of the critical systemFlags from the old to the new location
                // all in the same transaction
                if (!pTHS->fDSA) {
                    err = ValidateRedirectOfWellKnownObjects(pTHS,
                                                             pAttList,
                                                             pModifyArg,
                                                             hVerifyAtts);
                    
                    if (err || !hVerifyAtts->fRedirectWellKnownObjects ){
                        
                        // we allows the addition of a certain WKO, check for if
                        // certain conditions are met.  This is used to solve the
                        // problem that the ds quotas WKO cannot not registered on 
                        // the  ndnc head when upgrading from .NET pre-RC2 build.

                        fAllowedWellKnownObjectsChange = 
                             isWellKnownObjectsChangeAllowed(pTHS,
                                                             pAttList,
                                                             pModifyArg,
                                                             hVerifyAtts);

                        if (fAllowedWellKnownObjectsChange) {

                            // clear the error set in 
                            // ValidateRedirectOfWellKnownObjects().
                            THClearErrors();
                            
                        }
                        else {
                            //set the error code if it is not set
                            if (!err) {
                                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                            ERROR_DS_UNWILLING_TO_PERFORM);
                            }
                            return pTHS->errCode;
                        }
                    }
                }
                break;

            case ATT_DS_HEURISTICS:

                if (ValidateDsHeuristics(pModifyArg->pResObj->pObj, pAttList)) {
                    return pTHS->errCode;
                }
                break;

            default:
                // this is ok. go on
                break;
            }  // end switch 

            // Does this need an FPO reference?
            if (FPOAttrAllowed(attType)) {

                BOOL fCreate = FALSE;

                if ((pAttList->choice == AT_CHOICE_ADD_ATT) 
                 || (pAttList->choice == AT_CHOICE_ADD_VALUES)
                 || (pAttList->choice == AT_CHOICE_REPLACE_ATT)) {
                    fCreate = TRUE;
                }

                err = FPOUpdateWithReference(pTHS,
                                             pModifyArg->pResObj->NCDNT,
                                             fCreate, // create a reference if necessary
                                             pModifyArg->CommArg.Svccntl.fAllowIntraForestFPO,
                                             pModifyArg->pObject,
                                             &pAttList->AttrInf);
                if (err) {
                    Assert(0 != pTHS->errCode);
                    return pTHS->errCode;
                }
            }

            // Is this something that an external caller needs to know 
            // about?
            if (isAttributeInModifyProcessUpdate(attType, &index)) {
                // Copy value to the verify atts structure, making sure to remove 
                // any existing value
                if (pAttList->AttrInf.AttrVal.valCount != 1) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
                    return pTHS->errCode;
                }
                if (hVerifyAtts->UpdateList[index] != NULL) {
                    THFreeEx(pTHS, hVerifyAtts->UpdateList[index]);
                    hVerifyAtts->UpdateList[index] = NULL;
                }
                hVerifyAtts->UpdateList[index] = THAllocEx(pTHS, pAttList->AttrInf.AttrVal.pAVal->valLen);
                RtlCopyMemory(hVerifyAtts->UpdateList[index],
                              pAttList->AttrInf.AttrVal.pAVal->pVal,
                              pAttList->AttrInf.AttrVal.pAVal->valLen);
            }
        
        } // end if not DRA



        // next continue with tests for attributes that are of interest
        // at any time (originating or not)
        //
        // most of the attribute cases can fit in the below switch 
        // all the rest that can take place without DRA, are handled above
        //
        switch ( attType) {
        

        case ATT_MAX_PWD_AGE:
        case ATT_LOCKOUT_DURATION:
        case ATT_MS_DS_ALLOWED_DNS_SUFFIXES:
            //
            // MaxPasswordAge and Lockout Duration are cached in the anchor.
            // if we are modifiying one of these attributes, remember to
            // invalidate anchor after the apply Att succeeds
            //
            if (pTHS->pDB->DNT == gAnchor.ulDNTDomain) {
                pTHS->fAnchorInvalidated = TRUE;
            }

            break;


        case ATT_MS_DS_BEHAVIOR_VERSION:
            // check the msDs-Behavior-Version attribute

            if (!pTHS->fDRA && !pTHS->fDSA ) {
                if (!IsValidBehaviorVersionChange(pTHS, pAttList, pModifyArg,
                                                  pClassSch, 
                                                  &hVerifyAtts->NewForestVersion,
                                                  &hVerifyAtts->NewDomainVersion)) {
                    return pTHS->errCode;
                }
            }
            
            if (  ( gAnchor.pPartitionsDN
                    && NameMatched(gAnchor.pPartitionsDN,pModifyArg->pResObj->pObj))
                ||  NameMatched(gAnchor.pDomainDN,pModifyArg->pResObj->pObj) ){

                // forest or domain version are changed
                // rebuild the gAnchor, and invoke the behavior version udpate
                // thread to update the behavior info
                
                pTHS->fAnchorInvalidated = TRUE;
                pTHS->fBehaviorVersionUpdate = TRUE;

            }
            else if ( gAnchor.ForestBehaviorVersion == DS_BEHAVIOR_WIN2000 
                      &&  CLASS_NTDS_DSA == pClassSch->ClassId ) {
                
                // We postpone publishing ntMixedDomain onto the crossRef
                // until all the DSA are whistler, this is to avoid a LSA bug
                // in w2k. Whenever a behavior version on dsa object replicates in,
                // we should check if we need to publish the ntMixedDomain.
                
                pTHS->fBehaviorVersionUpdate = TRUE;
                
            }

            break;

        case ATT_MS_DS_DNSROOTALIAS:
            // check if ms-DS-DnsRootAlias is changed
            if ( IsCurrentOrRootDomainCrossRef(pTHS,pModifyArg) ) {
                pTHS->fNlDnsRootAliasNotify = TRUE;
            } 
            break;

        case ATT_NT_MIXED_DOMAIN:
            // if ntMixedDomain attribute of current domain is changed,
            // invoke behaviorVersionUpdate thread to update the ntMixedDomain
            // attribute on the crossref object of current domain.
            if ( NameMatched(gAnchor.pDomainDN, pModifyArg->pResObj->pObj)) {
                pTHS->fBehaviorVersionUpdate = TRUE;
            }
            else if( !pTHS->fDSA && !pTHS->fDRA ){
                // we don't allow the users to modify this attributes 
                // on cross ref.
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
                return pTHS->errCode;

            }
            break;

        
        case ATT_FSMO_ROLE_OWNER:
            // if the PDC role is changed, we should check if 
            // we need to update the behavior version info.
            if (NameMatched(gAnchor.pDomainDN,pModifyArg->pResObj->pObj)) {
                pTHS->fBehaviorVersionUpdate = TRUE;
            }
            break;


        case ATT_MS_DS_DEFAULT_QUOTA:
        case ATT_MS_DS_TOMBSTONE_QUOTA_FACTOR:
            // if this is is a Quotas container for a writable NC (ie. one on this
            // machine), need to rebuild anchor, because these values are actually
            // cached in the Master NCL hanging off the anchor
            //
            if ( CLASS_MS_DS_QUOTA_CONTAINER == pModifyArg->pResObj->MostSpecificObjClass
                && ( pModifyArg->pResObj->InstanceType & IT_WRITE )
                && !( pModifyArg->pResObj->InstanceType & IT_UNINSTANT ) ) {
                pTHS->fRebuildCatalogOnCommit = TRUE;
            }
            break;

        case ATT_WELL_KNOWN_OBJECTS:
            // When the wellKnownObjects attribute is changed, reload the catelog.  
            // This is to make sure when the "ntds quotas" container is added, 
            // the NCL list is updated properly.  We don't expect to run into this 
            // often, as wellKnownObjects is system-only.
            
            pTHS->fRebuildCatalogOnCommit = TRUE;
            break;

        default:
            // this is ok. go on
            break;

        } // end switch


        // finally, test for special flags on attributes
        //
        // objectClass, msDs-behavior-version, and systemFlags
        // are special Attributes and although they are system only,
        // we want to be able to change them in some cases.
        //
        if (   (attType != ATT_OBJECT_CLASS)
            && (attType != ATT_MS_DS_BEHAVIOR_VERSION)
            && (attType != ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME)
            // Allow user to set, but not reset, FLAG_ATTR_IS_RDN
            && (attType != ATT_SYSTEM_FLAGS
                || !fAttrSchemaObject
                || FixSystemFlagsForMod(pTHS, pAttList))
            && (attType != ATT_WELL_KNOWN_OBJECTS
                || !(hVerifyAtts->fRedirectWellKnownObjects
                     || fAllowedWellKnownObjectsChange )  )
            // If this is undelete op, then allow to set isDeleted and DN
            && (attType != ATT_IS_DELETED || !hVerifyAtts->fIsUndelete)
            && (attType != ATT_OBJ_DIST_NAME || !hVerifyAtts->fIsUndelete)
            && SysModReservedAtt(pTHS, pAC, pClassSch)
            && !gAnchor.fSchemaUpgradeInProgress) {

            if (!pTHS->fDRA) {
                // This is a reserved attribute which we won't let you
                // change unless a schema upgrade is in progress
                return SetAttError(pModifyArg->pObject, attType,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                                   ERROR_DS_CANT_MOD_SYSTEM_ONLY);
            }
        } 

        // pheeeeeeeww, this is ok to go on and modify this attr
        // this is done in the ModSetAttsHelperProcess function
        
        // continue with the next one

    }  // for loop

    return pTHS->errCode;
}

DWORD ModSetAttsHelperProcess(THSTATE *pTHS,
                              MODIFYARG *pModifyArg,
                              CLASSCACHE **ppClassSch,
                              CLASSSTATEINFO  **ppClassInfo,
                              HVERIFY_ATTS hVerifyAtts,
                              ULONG *pcNonReplAtts,
                              ATTRTYP **ppNonReplAtts
                              ) 
{
    USHORT           count;
    DWORD            err;
    CLASSSTATEINFO  *pClassInfo;
    CLASSCACHE      *pClassSch = *ppClassSch;
    ATTRTYP          attType;
    ATTCACHE        *pAC;
    ATTRMODLIST     *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/
    ULONG            index;
    ULONG           cAllocs;

    *pcNonReplAtts = cAllocs = 0;

    // Visit and apply each att.
    for (count = 0; 
         count < pModifyArg->count
                && (pTHS->errCode == 0 || pTHS->errCode == attributeError);
         count++, pAttList = pAttList->pNextMod) {

        // Get the target attribute type.  Remove att uses only ATTRTYP.
        // All other choices use an ATTR data structure.

        attType = pAttList->AttrInf.attrTyp;

        if(!(pAC = SCGetAttById(pTHS, attType))) {
            DPRINT1(2, "Att not in schema <%lx>\n",attType);
            return SetAttError(pModifyArg->pObject, attType,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                               ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
        }

        if (attType == ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {

            // Funky EntryTTL can be set (actually sets msDS-Entry-Time-To-Die)
            //

            ModSetEntryTTL(pTHS, pModifyArg, pAttList, pAC);

        } 
        else if (attType == ATT_SCHEMA_INFO && DsaIsRunning() && pTHS->fDRA) {
            // Skip writing SchemaInfo if fDRA during normal running. It will
            // be written directly by the dra thread at the end of schema NC
            // sync.
            continue;
        }
        else if (hVerifyAtts->fIsUndelete && (attType == ATT_IS_DELETED || attType == ATT_OBJ_DIST_NAME)) {
            // Doing undelete, skip isDeleted and objDistName
            continue;
        }
        else {
            // make a list of non-replicated attributes
            if (pAC->bIsNotReplicated) {
                if (*pcNonReplAtts>=cAllocs) {
                        if (0==cAllocs) {
                            cAllocs = 8;
                            *ppNonReplAtts = THAllocEx(pTHS, cAllocs*sizeof(ATTRTYP));
                        }
                        else {
                            cAllocs *=2;
                            *ppNonReplAtts = THReAllocEx(pTHS,*ppNonReplAtts, cAllocs*sizeof(ATTRTYP));
                        }
                }
                (*ppNonReplAtts)[(*pcNonReplAtts)++] = pAC->id;
            }
        
            ApplyAtt(pTHS, pModifyArg->pObject, hVerifyAtts, pAC, pAttList,
                     &pModifyArg->CommArg);

        }

        switch (attType) {
        case ATT_OBJECT_CLASS:
            // if we changed (originating) the objectClass, 
            // we want to fix the values stored 
            //
            if (!pTHS->fDRA) {
                pClassInfo = *ppClassInfo;

                Assert (pClassInfo);

                // read the new objectClass
                if (err = ReadClassInfoAttribute (pTHS->pDB, 
                                                  pAC,
                                                  &pClassInfo->pNewObjClasses,
                                                  &pClassInfo->cNewObjClasses_alloced,
                                                  &pClassInfo->cNewObjClasses,
                                                  NULL)) {
                    return err;
                }

                pClassInfo->fObjectClassChanged = TRUE;

                // compute and write new objectClass
                if (err = SetClassInheritance (pTHS, ppClassSch, pClassInfo, FALSE, pModifyArg->pObject)) {
                    return err;
                }
                pClassSch = *ppClassSch;
            }
            break;


        case ATT_LOCKOUT_TIME:
            //
            // if the client is trying to set the AccountLockoutTime attribute, 
            // get the new value, we will check the new value later.
            // 
            if (err = DBGetSingleValue(pTHS->pDB, 
                                       ATT_LOCKOUT_TIME, 
                                       &hVerifyAtts->LockoutTimeNew, 
                                       sizeof(hVerifyAtts->LockoutTimeNew), 
                                       NULL) ) 
            {
                // can't retrieve LockoutTime attribute, will leave BadPwdCount as it is.
                hVerifyAtts->fLockoutTimeUpdated = FALSE;
            }
            else
            {
                hVerifyAtts->fLockoutTimeUpdated = TRUE;
            }
            break;


        case ATT_MS_DS_UPDATESCRIPT:
            // if the client is updating the updateScript, we need to know
            //
            hVerifyAtts->fUpdateScriptChanged = TRUE;
            break;

        } // end switch


    }  // for loop

    return pTHS->errCode;
}

DWORD ModSetAttsHelperPostProcess(THSTATE *pTHS,
                                  MODIFYARG *pModifyArg,
                                  CLASSCACHE *pClassSch,
                                  HVERIFY_ATTS hVerifyAtts) 
{
    DWORD            err;
    ULONG            i;

    if (hVerifyAtts->fGroupTypeChange) {
        // Originating change on group type - need to touch the
        // member property for the GC filtering logic if this is
        // a change from non-universal group to universal group.
        ULONG ulGroupTypeNew;
        ATTCACHE *pACMember;

        err = DBGetSingleValue(pTHS->pDB,
                               ATT_GROUP_TYPE,
                               &ulGroupTypeNew,
                               sizeof(ulGroupTypeNew),
                               NULL);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                          ERROR_DS_MISSING_EXPECTED_ATT,
                          err); 
            return pTHS->errCode;
        }

        if (!(hVerifyAtts->ulGroupTypeOld & GROUP_TYPE_UNIVERSAL_GROUP)
            && (ulGroupTypeNew & GROUP_TYPE_UNIVERSAL_GROUP)) {
            // We have just changed a non-universal group to
            // universal group.  Touch the member property so that
            // the membership will replicate out to GCs.
            pACMember = SCGetAttById(pTHS, ATT_MEMBER);
            Assert(NULL != pACMember);

            if (pTHS->fLinkedValueReplication) {
                // See the comments to this routine for semantics
                DBTouchLinks_AC(pTHS->pDB, pACMember, FALSE /* forward links */);
            } else {
                DBTouchMetaData(pTHS->pDB, pACMember);
            }
        }
    }

    if ( hVerifyAtts->fLockoutTimeUpdated && 
         (hVerifyAtts->LockoutTimeNew.QuadPart == 0) )
    {
        DWORD    dwErr;
        ATTCACHE *pAttSchema = NULL;
        ULONG    BadPwdCount = 0;
        ATTRVAL  AttrVal;
        ATTRVALBLOCK AttrValBlock;


        AttrVal.pVal = (PCHAR) &BadPwdCount;
        AttrVal.valLen = sizeof(ULONG);

        AttrValBlock.pAVal = &AttrVal;
        AttrValBlock.valCount = 1;


        if (!(pAttSchema = SCGetAttById(pTHS, ATT_BAD_PWD_COUNT)))
        {
            DPRINT1(2, "Att not in schema (%lx)\n", ATT_BAD_PWD_COUNT);
            return SetAttError(pModifyArg->pObject, ATT_BAD_PWD_COUNT,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                               DIRERR_ATT_NOT_DEF_IN_SCHEMA);
        }
        if (dwErr = DBReplaceAtt_AC(pTHS->pDB, pAttSchema, &AttrValBlock, NULL) )
        {
            SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);

            return pTHS->errCode;
        }
    }

    if (hVerifyAtts->fUpdateScriptChanged) {

        // if this attribute changed on a cross ref container
        // we want to reset the hidden key
        if (pClassSch->ClassId == CLASS_CROSS_REF_CONTAINER) {

            // was it a change on the partitions container ?
            //
            Assert (pModifyArg->pResObj->pObj);

            if (NameMatched (pModifyArg->pResObj->pObj, gAnchor.pPartitionsDN)) {

                DWORD    dwErr;
                ATTCACHE *pAttSchema = NULL;
                
                if (!(pAttSchema = SCGetAttById(pTHS, ATT_MS_DS_EXECUTESCRIPTPASSWORD)))
                {
                    DPRINT1(2, "Att not in schema (%lx)\n", ATT_MS_DS_EXECUTESCRIPTPASSWORD);
                    return SetAttError(pModifyArg->pObject, ATT_MS_DS_EXECUTESCRIPTPASSWORD,
                                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
                }

                dwErr = DBRemAtt_AC(pTHS->pDB, pAttSchema);

                if (dwErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST && dwErr != DB_success) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);

                    return pTHS->errCode;
                }

                // Remember that we changed the script value.
                pTHS->JetCache.dataPtr->objCachingInfo.fUpdateScriptChanged = TRUE;
            }
        }
    }

    if (hVerifyAtts->NewForestVersion>0 
        && hVerifyAtts->NewForestVersion>gAnchor.ForestBehaviorVersion) {
        // if the forest version is raised, in an originating write,
        // execute the coresponding script(s)
        err = forestVersionRunScript(pTHS, gAnchor.ForestBehaviorVersion, hVerifyAtts->NewForestVersion);
                    
        if (err) {
            return SetSvcErrorEx( SV_PROBLEM_DIR_ERROR,
                                  DIRERR_UNKNOWN_ERROR,
                                  err );
        }

        // remember that we need to enable LVR on commit.
        pTHS->JetCache.dataPtr->objCachingInfo.fEnableLVR = TRUE;
    }

    if (hVerifyAtts->fRedirectWellKnownObjects) {
        if (CompleteRedirectOfWellKnownObjects(pTHS, hVerifyAtts)) {
            return pTHS->errCode;
        }
    }

    for (i = 0; i < RTL_NUMBER_OF(hVerifyAtts->UpdateList); i++) {
        if (hVerifyAtts->UpdateList[i] != NULL) {
            // Call out to notify component
            err = processModifyUpdateNotify(pTHS, 
                                            i,
                                            hVerifyAtts->UpdateList[i]);
            if (err) {
                Assert(0 != pTHS->errCode);
                return pTHS->errCode;
            }
        }
    }


    // if ever we need to have a loop here through all the attrs in
    // pModifyArgList, then we should expand inline the ModCheckSingleValue
    // call below.

    // Verify Single-Value constraints are being met.
    ModCheckSingleValue(pTHS, pModifyArg, pClassSch);

    return pTHS->errCode;
}



int ModSetAtts(THSTATE *pTHS,
               MODIFYARG *pModifyArg,
               CLASSCACHE **ppClassSch,
               CLASSSTATEINFO **ppClassInfo,
               ATTRTYP rdnType,
               BOOL fIsUndelete,
               LONG *forestVersion,
               LONG *domainVersion,
               ULONG *pcNonReplAtts,
               ATTRTYP **ppNonReplAtts )
{
    HVERIFY_ATTS hVerifyAtts;
    
    hVerifyAtts = VerifyAttsBegin(pTHS, pModifyArg->pObject,
                                  pModifyArg->pResObj->NCDNT,
                                  NULL);
    hVerifyAtts->fIsUndelete = fIsUndelete;

    __try {

        if (ModSetAttsHelperPreProcess(pTHS,
                                       pModifyArg,
                                       hVerifyAtts,
                                       ppClassSch,
                                       ppClassInfo,
                                       rdnType)) {
            __leave;
        }


        if (ModSetAttsHelperProcess(pTHS,
                                    pModifyArg,
                                    ppClassSch,
                                    ppClassInfo,
                                    hVerifyAtts,
                                    pcNonReplAtts,
                                    ppNonReplAtts)) {
            __leave;
        }

        if (ModSetAttsHelperPostProcess(pTHS,
                                        pModifyArg,
                                        *ppClassSch,
                                        hVerifyAtts)) {
            __leave;
        }
        
        *forestVersion = hVerifyAtts->NewForestVersion;
        *domainVersion = hVerifyAtts->NewDomainVersion;
        
    } __finally {
        VerifyAttsEnd(pTHS, &hVerifyAtts);
    }

    return pTHS->errCode;
}/*ModSetAtts*/

int
BreakObjectClassesToAuxClasses (
        THSTATE *pTHS,
        CLASSCACHE **ppClassSch,
        CLASSSTATEINFO  *pClassInfo)
/*++
Routine Description

    Given the full new objectClass (set by the user), 
    it figures out which classes belong to the hierarchy of 
    the stuctural object class and which classes are auxClasses.
    
    Note, this function does not assume any special order on the values 
    passed in

    On success, pClassInfo->pNewAuxClasses contains the auxClasses that 
    should be present on the object

Parameters

Return
    0 on Success
    Err on Failure

--*/

{
    DWORD           err;
    DWORD           fFound, usedPos, j, k;
    ATTRVALBLOCK    *pAttrVal;
    CLASSCACHE      *pClassSch, *pCCNew, *pCCtemp;

    // if we don't have a change in the objectClass
    // don't bother checking
    if (!pClassInfo) {
        return 0;
    }

    // we can not assert that pClassInfo->cNewObjClasses > 0 because
    // user might have deleted all values in this mod. Note this operation
    // will be rejected because we will fail to find the original structural
    // object class in the new value (see ~75 lines below).

    // since we are here, it means that we modified the objectClass
    // we have todo several checks and later on re-adjust the 
    // values stored in the various columns (objectClass, auxClass)

    ClassInfoAllocOrResizeElement2(pClassInfo->pNewAuxClasses,              // p
                                   pClassInfo->pNewAuxClassesCC,            // pCC
                                   pClassInfo->cNewObjClasses_alloced,      // startsize
                                   pClassInfo->cNewAuxClasses_alloced,      // allocedSize
                                   pClassInfo->cNewObjClasses_alloced);     // newsize

    pClassInfo->cNewAuxClasses = 0;

    // find the position of the class that is the same as our objectClass
    fFound = FALSE;
    pClassSch = *ppClassSch;
    for (j=0; j<pClassInfo->cNewObjClasses;j++) {
        if (pClassInfo->pNewObjClasses[j] == pClassSch->ClassId) {
            usedPos = j;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound) {

        ATTRTYP InetOrgPersonId = ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId;

        // possibly, we are converting an inetOrgPerson to a User
        // (removing the inetOrgPerson class).
        // we want to allow this conversion
        //
        if (pClassSch->ClassId == InetOrgPersonId) {
            
            DPRINT (0, "Changing InetOrgPerson to a User\n");

            for (j=0; j<pClassInfo->cNewObjClasses;j++) {
                if (pClassInfo->pNewObjClasses[j] == CLASS_USER) {
                    usedPos = j;
                    fFound = TRUE;
                    pClassSch = SCGetClassById(pTHS, CLASS_USER);
                    if (!pClassSch) {
                        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                           DIRERR_OBJ_CLASS_NOT_DEFINED);
                    }

                    *ppClassSch = pClassSch;
                    break;
                }
            }
        }
        else if (pClassSch->ClassId == CLASS_USER) {

            DPRINT (0, "Changing User to InetOrgPerson\n");

            for (j=0; j<pClassInfo->cNewObjClasses;j++) {
                if (pClassInfo->pNewObjClasses[j] == InetOrgPersonId) {
                    usedPos = j;
                    fFound = TRUE;
                    pClassSch = SCGetClassById(pTHS, InetOrgPersonId);
                    if (!pClassSch) {
                        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                           DIRERR_OBJ_CLASS_NOT_DEFINED);
                    }

                    *ppClassSch = pClassSch;
                    break;
                }
            }
        }
        
        if (!fFound) {
            DPRINT1 (1, "Original Structural Object Class 0x%x not found on new value\n", pClassSch->ClassId);
            return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                               ERROR_DS_ILLEGAL_MOD_OPERATION);
        }
    }

    // Now, look at all the object classes.  Make sure they describe a
    // (possibly incomplete) inheritence chain, not a web.
    for(j=0 ; j<pClassInfo->cNewObjClasses; j++) {
        if (j == usedPos) {
            // we have seen this position
            continue;
        }
        if(!(pCCNew = SCGetClassById(pTHS, pClassInfo->pNewObjClasses[j]))) {
            DPRINT1(0, "Object class 0x%x undefined.\n", pClassInfo->pNewObjClasses[j]);
            return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                               DIRERR_OBJ_CLASS_NOT_DEFINED);
        }

        // make sure pCCNew inherits from pClassSch or vice versa
        pCCtemp = FindMoreSpecificClass(pClassSch, pCCNew);
        if(!pCCtemp) {
            // Ooops, pCCNew is not in the chain for objectClass.
            // It might be an auxClass, or a chain for an auxClass
            //

            // better check explicitly for the classes rather than checking for 
            // not beeing DS_STRUCTURAL_CLASS
            //
            if (pCCNew->ClassCategory == DS_AUXILIARY_CLASS || 
                pCCNew->ClassCategory == DS_88_CLASS || 
                pCCNew->ClassCategory == DS_ABSTRACT_CLASS) {

                DPRINT1 (1, "Found auxClass (%s) while creating object\n", pCCNew->name);

                pClassInfo->cNewAuxClasses++;

                ClassInfoAllocOrResizeElement2(pClassInfo->pNewAuxClasses, 
                                               pClassInfo->pNewAuxClassesCC, 
                                               MIN_NUM_OBJECT_CLASSES, 
                                               pClassInfo->cNewAuxClasses_alloced, 
                                               pClassInfo->cNewAuxClasses);

                pClassInfo->pNewAuxClasses[pClassInfo->cNewAuxClasses-1] = pCCNew->ClassId;
                pClassInfo->pNewAuxClassesCC[pClassInfo->cNewAuxClasses-1] = pCCNew;

            }
            else {
                DPRINT1 (1, "Found a class(%s) that does not belong to the object\n", pCCNew->name);
                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   DIRERR_OBJ_CLASS_NOT_SUBCLASS);
            }
        }
        else {
            // we have to see whether pCCNew is a subClass of pClassSch

            if (pCCtemp == pCCNew) {
                // somehow we are changing the structural object Class
                // is this an allowed change ?
                if ((pClassSch->ClassId == CLASS_USER) && 
                    (pCCtemp->ClassId == ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId)) {

                    pClassSch = pCCtemp;
                    *ppClassSch = pClassSch;
                    DPRINT1 (1, "Changing User to InetOrgPerson: 0x%x\n", pClassSch);

                }
                else {
                    DPRINT1 (1, "Found a class(%s) that does not belong to the object\n", pCCNew->name);
                    return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                       ERROR_DS_ILLEGAL_MOD_OPERATION);
                }
            }
        }
    }

#ifdef DBG
    for (j = 0; j < pClassInfo->cNewAuxClasses ; j++) {    
        DPRINT2 (1, "NewAuxClasses[%d]=0x%x \n", j, pClassInfo->pNewAuxClasses[j]);
    }
#endif

    return pTHS->errCode;
} // BreakObjectClassesToAuxClasses


int
BreakObjectClassesToAuxClassesFast (
        THSTATE *pTHS,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo)
/*++
Routine Description

    Given the full new objectClass (read from the database), 
    it figures out which classes belong to the hierarchy of 
    the stuctural object class and which classes are auxClasses.
    
    Note, this function ASSUMES a special order on the values passed in.

    On success, pClassInfo->pNewAuxClasses contains the auxClasses of the object.
    
Parameters

Return
    0 on Success
    Err on Failure

--*/
{
    DWORD i;

    // if we don't have a change in the objectClass
    // don't bother checking
    if (!pClassInfo) {
        return 0;
    }

    Assert (pClassInfo->cNewObjClasses);
    
    if (pClassInfo->cNewObjClasses == (pClassSch->SubClassCount+1 )) {
        pClassInfo->cNewAuxClasses = 0;
        return 0;
    }

    ClassInfoAllocOrResizeElement2(pClassInfo->pNewAuxClasses,              // p
                                   pClassInfo->pNewAuxClassesCC,            // pCC
                                   pClassInfo->cNewObjClasses,              // startsize
                                   pClassInfo->cNewAuxClasses_alloced,      // allocedSize
                                   pClassInfo->cNewObjClasses);            // newsize

    pClassInfo->cNewAuxClasses = 0;
    for (i=pClassSch->SubClassCount; i<pClassInfo->cNewObjClasses-1; i++) {
        pClassInfo->pNewAuxClasses [ pClassInfo->cNewAuxClasses ] = 
                    pClassInfo->pNewObjClasses[i];

        pClassInfo->pNewAuxClassesCC[ pClassInfo->cNewAuxClasses++ ] = 
                    SCGetClassById(pTHS, pClassInfo->pNewObjClasses[i]);
    }

    return 0;
}


int 
CloseAuxClassList (
    THSTATE *pTHS, 
    CLASSCACHE *pClassSch,
    CLASSSTATEINFO  *pClassInfo)
/*++
Routine Description

    The auxClass list contains all the classes that are not on 
    the structural object class hierarchy.
    
    For all these classes, this function finds the closed set, 
    by adding all the superclasses needed. 
    
    The pClassInfo->?NewAuxClasses* variables are expanded to hold the 
    addition auxClasses.

Return
    0 on Success
    Err on Failure

--*/
{
    BOOL            fFound;
    DWORD           i, j, k, cUpperBound;
    DWORD           cCombinedObjClass, cCombinedObjClass_alloced;
    ATTRTYP         *pCombinedObjClass;
    CLASSCACHE      *pCC, *pCCNew;
    
    if (!pClassInfo || !pClassInfo->cNewAuxClasses) {
        return 0;
    }

    // combinedObjClass contains all the structural object classes plus the auxClasses
    cCombinedObjClass_alloced = (pClassInfo->cNewAuxClasses + 1 + pClassSch->SubClassCount) * 2;
    pCombinedObjClass = THAllocEx (pTHS, sizeof (ATTRTYP) * cCombinedObjClass_alloced);
    
    pCombinedObjClass[0] = pClassSch->ClassId;
    cCombinedObjClass = 1;

    for (i=0; i<pClassSch->SubClassCount; i++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassSch->pSubClassOf[i];
    }

    for (i=0; i < pClassInfo->cNewAuxClasses; i++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassInfo->pNewAuxClasses[i];
    }
    
    qsort(pCombinedObjClass,
          cCombinedObjClass,
          sizeof(ATTRTYP),
          CompareAttrtyp);


    // the point where we start adding new auxClasses
    cUpperBound = pClassInfo->cNewAuxClasses;

    // check for all the existing auxClasses
    for (i=0; i < pClassInfo->cNewAuxClasses; i++) {

        // check whether all the superiors of this class are present
        pCC = pClassInfo->pNewAuxClassesCC[i];

        for (j=0; j<pCC->SubClassCount; j++) {
            fFound = FALSE;

            // first check the sorted array
            if (bsearch(&pCC->pSubClassOf[j],
                         pCombinedObjClass,
                         cCombinedObjClass,
                         sizeof(ATTRTYP),
                         CompareAttrtyp)) {

                fFound = TRUE;
            }
            else {
                DPRINT1 (0, "Class (0x%x) not found in sorted hierarchy\n", pCC->pSubClassOf[j]);

                // search only in the new additions
                for (k=cUpperBound; k<pClassInfo->cNewAuxClasses; k++) {

                    if (pClassInfo->pNewAuxClasses[k] == pCC->pSubClassOf[j]) {
                        fFound = TRUE;
                        break;
                    }
                }
            }

            if (!fFound) {
                DPRINT1 (0, "Class (0x%x) not found at all.\n", pCC->pSubClassOf[j]);

                pClassInfo->cNewAuxClasses++;
                if (pClassInfo->cNewAuxClasses > pClassInfo->cNewAuxClasses_alloced) {
                    pClassInfo->cNewAuxClasses_alloced = pClassInfo->cNewAuxClasses_alloced*2;
                    pClassInfo->pNewAuxClasses = THReAllocEx(pTHS, pClassInfo->pNewAuxClasses, 
                                                             sizeof (ATTRTYP) * pClassInfo->cNewAuxClasses_alloced);
                    pClassInfo->pNewAuxClassesCC = THReAllocEx (pTHS, pClassInfo->pNewAuxClassesCC,
                                                                sizeof (CLASSCACHE *) * pClassInfo->cNewAuxClasses_alloced);
                }

                if(!(pCCNew = SCGetClassById(pTHS, pCC->pSubClassOf[j]))) {
                    return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                       DIRERR_OBJ_CLASS_NOT_DEFINED);
                }
                pClassInfo->pNewAuxClasses[pClassInfo->cNewAuxClasses-1] = pCC->pSubClassOf[j];
                pClassInfo->pNewAuxClassesCC[pClassInfo->cNewAuxClasses-1] = pCCNew;
                DPRINT2 (0, "Added new AuxObjectClass[%d]=%s  \n", 
                         pClassInfo->cNewAuxClasses-1, pCCNew->name);
            }
        }
    }

    THFreeEx (pTHS, pCombinedObjClass);

    return 0;
}


int
VerifyAndAdjustAuxClasses (
        THSTATE *pTHS,
        DSNAME *pObject,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo)
//
//
//  Assumes that the auxClass set is closed.
//
//
{
    DWORD           err;
    DWORD           seekIdx, i, j;
    BOOL            fFound;
    CLASSCACHE      *pCC, *pCCparent, *pCCold;
    BOOL            fOldDynamicObjectId;
    BOOL            fNewDynamicObjectId;
    ATTRTYP         DynamicObjectId;
    DWORD           cOriginalAuxClasses;
    ATTRTYP         *pOriginalAuxClasses = NULL;
    DWORD           cOldAuxClasses;
    ATTRTYP         *pOldAuxClasses = NULL;
    BOOL            fChangedAuxClass=FALSE;


    // if we don't have a change in the objectClass
    // don't bother checking
    if (!pClassInfo || !pClassInfo->fObjectClassChanged) {
        return 0;
    }

    // check whether we have a real change in the objectClass stored on the object
    //
    if ((pClassInfo->cNewObjClasses != pClassInfo->cOldObjClasses) ||
        (pClassInfo->cNewObjClasses &&
         pClassInfo->cOldObjClasses &&
         memcmp (pClassInfo->pNewObjClasses, 
                 pClassInfo->pOldObjClasses,
                 pClassInfo->cNewObjClasses * sizeof (ATTRVAL)) != 0)) {

        pClassInfo->fObjectClassChanged = TRUE;
    }
    else {
        pClassInfo->fObjectClassChanged = FALSE;
        return 0;
    }


    // so somebody changed the objectClass and as a result 
    // we have additional/less auxClasses 

    // we don't have to check for dynamic auxclass removal if this was an add
    //
    if (!pClassInfo->fOperationAdd) {
        // the dynamic-object auxclass cannot be added or removed
        DynamicObjectId = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId;
        fOldDynamicObjectId = FALSE;
        for (seekIdx=0; seekIdx < pClassInfo->cOldObjClasses; seekIdx++) {
            if (pClassInfo->pOldObjClasses[seekIdx] == DynamicObjectId) {
                fOldDynamicObjectId = TRUE;
                break;
            }
        }

        fNewDynamicObjectId = FALSE;
        for (seekIdx=0; seekIdx < pClassInfo->cNewObjClasses; seekIdx++) {
            if (pClassInfo->pNewObjClasses[seekIdx] == DynamicObjectId) {
                fNewDynamicObjectId = TRUE;
                break;
            }
        }
        if (fNewDynamicObjectId != fOldDynamicObjectId) {
            return SetAttError(pObject, 
                               ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->DynamicObjectId,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL, 
                               ERROR_DS_OBJ_CLASS_VIOLATION);
        }
    }


    // check to see that for every auxClass that we removed
    // we also removed all the parent abstract classes
    // if not we have to remove them

    // calculate the old set of auxClasses
    // we assume that the objectClass set is in a normalized form
    // i.e. mostSpecificClass; parentClasses; auxClasses; Top


    // what an Assert !!
    Assert (!pClassInfo->pOldObjClasses || 
              (pClassInfo->pOldObjClasses && 
                ( pClassInfo->pOldObjClasses[0] == pClassSch->ClassId || 
                 (pClassInfo->pOldObjClasses[0] == CLASS_USER &&
                  pClassSch->ClassId == ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId) ||
                 (pClassSch->ClassId == CLASS_USER &&
                  pClassInfo->pOldObjClasses[0] == ((SCHEMAPTR *)(pTHS->CurrSchemaPtr))->InetOrgPersonId)
                )
               )
            );

    cOldAuxClasses = 0;
    if (pClassInfo->cOldObjClasses) {
        if(!(pCCold = SCGetClassById(pTHS, pClassInfo->pOldObjClasses[0]))) {
             return SetAttError(pObject, pClassInfo->pOldObjClasses[0],
                                PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                                ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        }
    
        pOldAuxClasses = THAllocEx (pTHS, sizeof (ATTRTYP) * pClassInfo->cOldObjClasses);
        for (seekIdx=pCCold->SubClassCount; seekIdx < pClassInfo->cOldObjClasses; seekIdx++) {
            pOldAuxClasses[cOldAuxClasses++]=pClassInfo->pOldObjClasses[seekIdx];
        }
        if (cOldAuxClasses) {
            // got the last one too
            cOldAuxClasses--;
        }
    }

    DPRINT2 (1, "Found OldAuxClasses: %d %x\n", cOldAuxClasses, pOldAuxClasses);

    // make a copy of the newAuxClasses, since we will be changing the array

    cOriginalAuxClasses = pClassInfo->cNewAuxClasses;
    if (cOriginalAuxClasses) {
        pOriginalAuxClasses = THAllocEx (pTHS, sizeof (ATTRTYP) * cOriginalAuxClasses);
        memcpy (pOriginalAuxClasses, pClassInfo->pNewAuxClasses, sizeof (ATTRTYP) * cOriginalAuxClasses);
    }

    for (seekIdx=0; seekIdx < cOldAuxClasses; seekIdx++) {

        fFound = FALSE;

        for (i=0; i<cOriginalAuxClasses; i++) {
            if (pOriginalAuxClasses[i] == pOldAuxClasses[seekIdx]) {
                fFound=TRUE;
                break;
            }
        }

        if (!fFound) {
            // we removed this objectClass so we have to remove  
            // its abstract superClass(es), unless it is used in 
            // another auxClass in the new list
            //
            // if this class parent is not an abstract class, we don't do anything
            if(!(pCC = SCGetClassById(pTHS, pOldAuxClasses[seekIdx]))) {
                 return SetAttError(pObject, pOldAuxClasses[seekIdx],
                                    PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
            }

            for (i=0; i<pCC->SubClassCount; i++) {
                if (!(pCCparent = SCGetClassById(pTHS, pCC->pSubClassOf[i]))) {
                    return SetAttError(pObject, pCC->pSubClassOf[i],
                                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL, 
                                       ERROR_DS_OBJ_CLASS_NOT_DEFINED);
                }

                // we found an abstract class as a parent of the class that we
                // removed. we have to remove it from the auxClass list
                // unless it is used by another auxClass
                if ((pCCparent->ClassCategory == DS_ABSTRACT_CLASS) && 
                    (pCCparent->ClassId != CLASS_TOP)) {

                    for (j=0; j<pClassInfo->cNewAuxClasses; j++) {
                        if (pClassInfo->pNewAuxClasses[j] == pCCparent->ClassId) {

                            // it is easier to remove this class now
                            // and add it later if it is needed
                            // our comparison of what auxClasses originally
                            // got removed still works, since we have a copy
                            // of the original array

                            DPRINT1 (0, "Removing abstract parent class (%s) from auxClass\n", 
                                     pCCparent->name);

                            if (j==(pClassInfo->cNewAuxClasses-1)) {
                                pClassInfo->cNewAuxClasses--;
                            }
                            else {
                                memmove(&pClassInfo->pNewAuxClasses[j],
                                        &pClassInfo->pNewAuxClasses[j+1],
                                        (pClassInfo->cNewAuxClasses - j - 1)*sizeof(ATTRTYP));
                                memmove(&pClassInfo->pNewAuxClassesCC[j],
                                        &pClassInfo->pNewAuxClassesCC[j+1],
                                        (pClassInfo->cNewAuxClasses - j - 1)*sizeof(ATTRTYP));

                                pClassInfo->cNewAuxClasses--;
                            }

                            fChangedAuxClass = TRUE;
                            break;
                        }
                    }
                }
                else {
                    // we either found an auxiliaryClass or TOP
                    // we leave them there, and we are finished
                    break;
                }
            }
        }
    }

    // the auxClass list should contain only auxClass or abstract classes
    // for all the abstract classes, check that they belong on the
    // hierarchy of one of the auxClasses

    for (j=0; j<pClassInfo->cNewAuxClasses; j++) {

        if (pClassInfo->pNewAuxClassesCC[j]->ClassCategory == DS_ABSTRACT_CLASS) {

            fFound = FALSE;
            for (i=0; i<pClassInfo->cNewAuxClasses; i++) {
                if (pClassInfo->pNewAuxClassesCC[i]->ClassCategory == DS_AUXILIARY_CLASS) {
                    
                    // see whether one class is subclass of the other
                    if (FindMoreSpecificClass(pClassInfo->pNewAuxClassesCC[i], 
                                              pClassInfo->pNewAuxClassesCC[j])) {
                        fFound = TRUE;
                        break;
                    }
                }
            }

            if (!fFound) {
                DPRINT1(0, "Object class(%s) should not be in list.\n", 
                        pClassInfo->pNewAuxClassesCC[j]->name);
                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   ERROR_DS_OBJ_CLASS_NOT_DEFINED);
            }
        }
    }

    // in case we implement targetPermittedclasses, this is the place for the check


    // possibly we removed a bunch of classes, some of them might be needed
    // the ones that are needed, we are going to add them back
    // in addition, we are going to add superclasses that are not 
    // already on the list

    if (fChangedAuxClass) {
        if (err = CloseAuxClassList (pTHS, pClassSch, pClassInfo)) {
            return err;
        }
    }

    if (pOriginalAuxClasses) {
        THFreeEx (pTHS, pOriginalAuxClasses);
    }

    if (pOldAuxClasses) {
        THFreeEx (pTHS, pOldAuxClasses);
    }

    return pTHS->errCode;
} // VerifyAndAdjustAuxClasses


//
// Reads the specified attribute from the object into the specified location
// This is to help filling in CLASSSTATEINFO datatypes
//
int ReadClassInfoAttribute (DBPOS *pDB,
                            ATTCACHE *pAC,
                            ATTRTYP **ppClassID,
                            DWORD    *pcClasses_alloced,
                            DWORD    *pcClasses,
                            CLASSCACHE ***ppClassCC)
{
    THSTATE *pTHS = pDB->pTHS;
    CLASSCACHE      *pCC;
    DWORD           err;
    ULONG           cLen;
    ATTRTYP         Temp, *pTemp;

    if (!*ppClassID) {
        *ppClassID = THAllocEx (pTHS, sizeof (ATTRTYP) * MIN_NUM_OBJECT_CLASSES);
        *pcClasses_alloced = MIN_NUM_OBJECT_CLASSES;
    }

    if (ppClassCC) {
        if (!*ppClassCC) {
            *ppClassCC = THAllocEx (pTHS, sizeof (CLASSCACHE *) * (*pcClasses_alloced));
        }
        else {
            *ppClassCC = THReAllocEx (pTHS, *ppClassCC, sizeof (CLASSCACHE *) * (*pcClasses_alloced));
        }
    }
    *pcClasses = 0;

    pTemp = &Temp;
    
    do {
        err = DBGetAttVal_AC(pDB, 
                             *pcClasses+1, 
                             pAC, 
                             DBGETATTVAL_fCONSTANT,
                             sizeof(ATTRTYP), 
                             &cLen, 
                             (UCHAR **)&pTemp);

        switch (err) {
           case DB_ERR_NO_VALUE:
                break;

           case 0:
                (*pcClasses)++;

                if (*pcClasses > *pcClasses_alloced) {
                    *pcClasses_alloced = *pcClasses_alloced * 2;
                    *ppClassID = THReAllocEx(pTHS, *ppClassID, 
                                             sizeof (ATTRTYP) * (*pcClasses_alloced));

                    if (ppClassCC) {
                        *ppClassCC = THReAllocEx (pTHS, *ppClassCC, 
                                             sizeof (CLASSCACHE *) * (*pcClasses_alloced));
                    }
                }
                (*ppClassID)[*pcClasses-1] = *pTemp;
                
                if (ppClassCC) {
                    if(!(pCC = SCGetClassById(pTHS, *pTemp))) {
                        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                                           ERROR_DS_MISSING_EXPECTED_ATT);
                    }

                    (*ppClassCC)[*pcClasses-1] = pCC;
                }
                break;

            default:
                // other error
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                              ERROR_DS_DATABASE_ERROR,
                              err); 
                return pTHS->errCode;

        }  /* switch */

    } while ( err == 0 );


    return pTHS->errCode;
} // ReadClassInfoAttribute


CLASSSTATEINFO  *ClassStateInfoCreate (THSTATE *pTHS) 
{
    CLASSSTATEINFO  *pClassInfo = THAllocEx (pTHS, sizeof (CLASSSTATEINFO));

    // set the objectClass
    if(!(pClassInfo->pObjClassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS))) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        
        THFreeEx (pTHS, pClassInfo);
        return NULL;
    }

    return pClassInfo;
}

void ClassStateInfoFree (THSTATE *pTHS, CLASSSTATEINFO  *pClassInfo)
{
    if (pClassInfo->pOldObjClasses) {
        THFreeEx(pTHS, pClassInfo->pOldObjClasses);
    }
    if (pClassInfo->pNewObjClasses) {
        THFreeEx(pTHS, pClassInfo->pNewObjClasses);
    }
    if (pClassInfo->pNewAuxClasses) {
        THFreeEx(pTHS, pClassInfo->pNewAuxClasses);
    }
    if (pClassInfo->pNewAuxClassesCC) {
        THFreeEx(pTHS, pClassInfo->pNewAuxClassesCC);
    }
    THFreeEx(pTHS, pClassInfo);
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check each attribute for which we actually added values to make sure that
   they do not violate any single valued constraints.  Do this now because we
   supressed this check while adding values since it is legal for mod to
   transiently violate single valuedness.
*/

int
ModCheckSingleValue (
        THSTATE *pTHS,
        MODIFYARG *pModifyArg,
        CLASSCACHE *pClassSch
        )
{
   ATTRMODLIST *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/
   ATTCACHE    *pAC;
   DWORD        dwErr;
   BOOL         bSamClassRef;
   DWORD        iClass;


    if (pTHS->fDRA ||
        (pTHS->fSAM && pTHS->fDSA)){
        // Replication is allowed to perform modifications that violate the
        // schema, OR if it's SAM calling us and he's swearing that he's
        // only modifying SAM owned attributes, we'll trust him.
        return 0;
   }

   bSamClassRef = SampSamClassReferenced (pClassSch, &iClass);


   // visit and appy each att

   while (pAttList) {
       switch(pAttList->choice) {
       case AT_CHOICE_REPLACE_ATT:
       case AT_CHOICE_ADD_ATT:
       case AT_CHOICE_ADD_VALUES:
           // These operations all add values to the database, so they might
           // have violated single-value constraints.

           // Objects are in schema or we'd have failed already.
           pAC = SCGetAttById(pTHS, pAttList->AttrInf.attrTyp);
           Assert(pAC != NULL);
           
           // ignore the funky constructed attribute, EntryTTL
           
           // check for referencing of description on a sam class
           // this is because the downlevel APIs expose description
           // as a single valued attribute, so we want to enforce this
           // without doing the loopback
           // 

           if(    pAC 
               && ( pAC->isSingleValued || 
                    (bSamClassRef && pAC->id == ATT_DESCRIPTION) )
               && pAC->id != ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {

               ULONG Len;
               ULONG Temp, *pTemp;
               pTemp = &Temp;

               // Ok, look for too many values.
               dwErr = DBGetAttVal_AC(pTHS->pDB, 2, pAC,
                                      DBGETATTVAL_fINTERNAL | DBGETATTVAL_fCONSTANT,
                                      sizeof(Temp),
                                      &Len,
                                      (UCHAR **) &pTemp);
               if(dwErr != DB_ERR_NO_VALUE) {
                   // Too many values. Gronk.
                   return SetAttError(pModifyArg->pObject,
                                      pAttList->AttrInf.attrTyp,
                                      PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                      ERROR_DS_SINGLE_VALUE_CONSTRAINT);
               }
           }
           break;
       default:
           // These operations do not add values to the database, so they can't
           // have violated single-value constraints.
           break;
       }
       pAttList = pAttList->pNextMod;
   }

   return pTHS->errCode;
} /* ModCheckSIngleValue */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

BOOL
SysModReservedAtt (
        THSTATE *pTHS,
        ATTCACHE *pAC,
        CLASSCACHE *pClassSch
        )
{
    // TRUE means the attribute is reserved and should not be added
    // We discriminate based on attribute id. Also, we don't allow
    // adding backlink attributes or attributes marked as system only.

    if(pAC->bSystemOnly && !(pTHS->fDRA || pTHS->fDSA) ) {
        // only the DRA or the DSA can modify system only attributes.
        return TRUE;
    }

    switch (pAC->id) {
    case ATT_OBJ_DIST_NAME:
    case ATT_USN_CREATED:
    case ATT_SUB_REFS:
    case ATT_USN_LAST_OBJ_REM:
    case ATT_USN_DSA_LAST_OBJ_REMOVED:
    case ATT_RDN:
        return TRUE;
        break;

    case ATT_IS_DELETED:
    case ATT_HAS_MASTER_NCS: // deprecated "old" hasMasterNCs
    case ATT_MS_DS_HAS_MASTER_NCS: // "new" msDS-HasMasterNCs.
    case ATT_HAS_PARTIAL_REPLICA_NCS:
        // fall through
    case ATT_OBJECT_CLASS:
    case ATT_WHEN_CREATED:
        // NOTE: The DRA must be allowed to do these to instantiate a naked
        // SUBREF into the real NC head.
        return !(pTHS->fDRA);
        break;

    default:
        return FIsBacklink(pAC->ulLinkID);
    }

}/*SysModReservedAtt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add or remove whole attributes of specific attribute values.  Attributes
   and attribute values to be added require that that the attribute type
   exist in the schema.
*/

int
ApplyAtt(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pObj,
    IN  HVERIFY_ATTS    hVerifyAtts,
    IN  ATTCACHE *      pAttSchema,
    IN  ATTRMODLIST *   pAttList,
    IN  COMMARG *       pCommArg
    )
{
    ATTRTYP attType = pAttList->AttrInf.attrTyp;
    DWORD dwFlags;
    DWORD err;

    DPRINT(1, "ApplyAtt entered\n");

    switch (pAttList->choice){
    case AT_CHOICE_REPLACE_ATT:
        DPRINT1(2, "Replace att <%lu>\n", attType);
        return ReplaceAtt(pTHS,
                          hVerifyAtts,
                          pAttSchema,
                          &(pAttList->AttrInf.AttrVal),
                          TRUE);

    case AT_CHOICE_ADD_ATT:
        DPRINT1(2, "Add att <%lu>\n", attType);
        return AddAtt(pTHS, hVerifyAtts, pAttSchema,
                      &pAttList->AttrInf.AttrVal);

    case AT_CHOICE_REMOVE_ATT:
        DPRINT1(2, "Remove att <%lu>\n", attType);
        err = DBRemAtt_AC(pTHS->pDB, pAttSchema);
        switch (err) {
        case DB_ERR_ATTRIBUTE_DOESNT_EXIST:
            if (pCommArg->Svccntl.fPermissiveModify) {
                /* caller doesn't care if it wasn't there to begin with */
                return 0;
            }
            DPRINT1(2, "Att does not exist %lu\n", attType);
            return SetAttError(pObj, attType,
                               PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                               ERROR_DS_ATT_IS_NOT_ON_OBJ);
        case 0:
            return 0;

        default:
            Assert(!"New return code added for DBRemAtt_AC?");
            return SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_DATABASE_ERROR);
        }

        break;

    case AT_CHOICE_ADD_VALUES:
        DPRINT1(2, "Add vals <%lu>\n", attType);
        dwFlags = AAV_fCHECKCONSTRAINTS;
        if (pCommArg->Svccntl.fPermissiveModify) {
            dwFlags |= AAV_fPERMISSIVE;
        }
        return AddAttVals(pTHS,
                          hVerifyAtts,
                          pAttSchema, 
                          &(pAttList->AttrInf.AttrVal),
                          dwFlags); 

    case AT_CHOICE_REMOVE_VALUES:
        DPRINT1(2, "Rem vals from att <%lu>\n", attType);
        return RemAttVals(pTHS,
                          hVerifyAtts,
                          pAttSchema,
                          &(pAttList->AttrInf.AttrVal),
                          pCommArg->Svccntl.fPermissiveModify);

    default:
        DPRINT(2, "Bad modify choice given by the user.. will not perform\n");
        return SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                             ERROR_DS_ILLEGAL_MOD_OPERATION,
                             pAttList->choice);
    }/*switch*/

    //
    // Added to remove sundown warning. Should never come here.
    //

    Assert(FALSE);
    return 0;

}/*ApplyAtt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function compares the pre and post modification instance types
    and updates the system catalog if they are changed.  For now we take
   the simple approach deleting and re-adding the catalog info if the type
   has changed.  Since this is an update event, expense is no problem.

   Note that mdmoddn:LocalModifyDn has a logically equivalent lump of code
   to handle nc head objects being restructured (reparented) due to domain
   rename.
*/

int
ModCheckCatalog(THSTATE *pTHS,
                RESOBJ *pResObj)
{
    SYNTAX_INTEGER beforeInstance = pResObj->InstanceType;
    SYNTAX_INTEGER afterInstance;
    DWORD err;

    DPRINT(1,"ModCheckCatalog entered\n");

    /* Position on the attribute instance.  */
    if (err = DBGetSingleValue(pTHS->pDB,
                               ATT_INSTANCE_TYPE,
                               &afterInstance,
                               sizeof(afterInstance),
                               NULL)) {

        SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, 
                      ERROR_DS_MISSING_EXPECTED_ATT,
                      err); 
        DPRINT(0,"Couldn't retrieve INSTANCE type error already set\n");
        return pTHS->errCode;
    }

    DPRINT2(2,"Before Instance <%lu>.  After Instance <%lu>\n",
            beforeInstance, afterInstance);

    /* Update global info inf the object instance has changed*/

    if (beforeInstance == afterInstance){
        DPRINT(2, "Object instance unchanged...return\n");
        return 0;
    }
    DPRINT(2,"instance type different..process\n");

    /* In most cases a change in instance type is handled by simply deleting
       old catalog info and adding new stuff. The following IF handles
       two special cases.. One is moving from a NC to an INT reference and
       the other is from an INT to an NC.  These are special because the
       SUBREF info kept on these objects must be moved.  Handle this special
       case and then perform the standard delete then add.
       */
    if(!(beforeInstance & IT_UNINSTANT) && !(afterInstance & IT_UNINSTANT)) {
        // Ok, we aren't dealing with a pure subref here.

        if( (beforeInstance & IT_NC_HEAD) &&
           !(afterInstance  & IT_NC_HEAD)    ) {

            DPRINT(2,"Special case NC->INT .move SUB info to it's parentNC\n");
            if (MoveSUBInfoToParentNC(pTHS, pResObj->pObj))
                return pTHS->errCode;
        }
        else if(!(beforeInstance & IT_NC_HEAD) &&
                (afterInstance  & IT_NC_HEAD)    ) {

            DPRINT(2,"Special case INT->NC ref,take SUB info from parentNC\n");
            if (MoveParentSUBInfoToNC(pTHS, pResObj->pObj))
                return pTHS->errCode;
        }
    }

    // If the IT_ABOVE status of this object is changing, update its NCDNT
    if ( (beforeInstance & IT_NC_ABOVE) != (afterInstance & IT_NC_ABOVE) ) {
        Assert( beforeInstance & IT_NC_HEAD );
        if (ModNCDNT( pTHS, pResObj->pObj, beforeInstance, afterInstance )) {
            return pTHS->errCode;
        }
    }

    /* Remove all catalog references for the object under its old type and
       add catalog info under its new type...
       */

    DPRINT(2, "Object instance changed so delete then add global info\n");

    if (DelCatalogInfo(pTHS, pResObj->pObj, beforeInstance)){
        DPRINT(2,"Error while deleting global object info\n");
        return pTHS->errCode;
    }

    DPRINT(2, "Global obj info deleted...no add \n");

    return AddCatalogInfo(pTHS, pResObj->pObj);

}/*ModCheckCatalog*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function check if there is any DC with version older than lNewVersion 
   in the forest.  If yes, ERROR_DS_LOW_DSA_VERSION will be returned, and 
   if ppDSA is not NULL, it will be set to the DN of such a DC.
*/

DWORD VerifyNoOldDC(THSTATE * pTHS, LONG lNewVersion, BOOL fDomain, PDSNAME *ppDSA){
    
    DWORD err;
    FILTER ObjCategoryFilter, DomainFilter, AndFilter, VersionFilter, NotFilter;
        
    CLASSCACHE *pCC;
    SEARCHARG SearchArg;
    SEARCHRES SearchRes;

    //initialize SearchArg
    memset(&SearchArg,0,sizeof(SearchArg));
    SearchArg.pObject = gAnchor.pConfigDN;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;

    if (err = DBFindDSName(pTHS->pDB,SearchArg.pObject)) {
        return err;
    }

    SearchArg.pResObj = CreateResObj(pTHS->pDB,SearchArg.pObject);

    InitCommarg(&SearchArg.CommArg);

    pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA);
    Assert(pCC);

    //set filters "( (objCategory==NTDSA) && !(msDs-Behavior-Version>=lNewVersion))"
    memset(&AndFilter,0,sizeof(AndFilter));
    AndFilter.choice = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;

    memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
    ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
    ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                     pCC->pDefaultObjCategory->structLen;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                     (BYTE*)(pCC->pDefaultObjCategory);
    ObjCategoryFilter.pNextFilter = &NotFilter;

    memset(&NotFilter,0,sizeof(NotFilter));
    NotFilter.choice = FILTER_CHOICE_NOT;
    NotFilter.FilterTypes.pNot = &VersionFilter;

    memset(&VersionFilter,0,sizeof(VersionFilter));
    VersionFilter.choice = FILTER_CHOICE_ITEM;
    VersionFilter.FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
    VersionFilter.FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_BEHAVIOR_VERSION;
    VersionFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(lNewVersion);
    VersionFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)&lNewVersion;

    SearchArg.pFilter = &AndFilter;

    //return one object only
    SearchArg.CommArg.ulSizeLimit = 1;

    if (fDomain) {
        //change the msDs-Behavior-Version of the DomainDNS object
        //we only need to check the nTDSDSA objects in the domain
        //so here we append (hasMasterNCs==current domain) to the AND-filter above
        memset(&DomainFilter,0,sizeof(DomainFilter));
        DomainFilter.choice = FILTER_CHOICE_ITEM;
        DomainFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;                                            
        // NTRAID#NTBUG9-582921-2002/03/21-Brettsh - This is cute, basically this is a 
        // catch-22, we can't use ATT_MS_DS_HAS_MASTER_NCS, because then we'd "miss"
        // any Win2k DSA object, because it didn't have that attribute set, which is 
        // exactly the DSAs we're trying to find anyway.
        DomainFilter.FilterTypes.Item.FilTypes.ava.type = ATT_HAS_MASTER_NCS; // deprecated "old" hasMasterNCs
        DomainFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = 
                    gAnchor.pDomainDN->structLen;
        DomainFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                    (BYTE*)gAnchor.pDomainDN;

        NotFilter.pNextFilter = &DomainFilter;

        AndFilter.FilterTypes.And.count = 3;  //3 items instead of 2

    }
    else {
        AndFilter.FilterTypes.And.count = 2; //only 2 items
    }

    memset(&SearchRes,0,sizeof(SearchRes));

    if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
        return err;
    }

    if (0 != SearchRes.count) {
        err = ERROR_DS_LOW_DSA_VERSION;
        if (ppDSA) {
            *ppDSA = SearchRes.FirstEntInf.Entinf.pName;
        }
        
    }
    return err;


}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function check if there is a mixed mode domain in the forest.
   This function does a search in the Partitions container for a domain 
   cross-ref with non-zero ntmixeddomain attribute or 
   without this attribute.
*/

DWORD VerifyNoMixedDomain(THSTATE *pTHS)
{

    LONG lMixedDomain = 0;
    DWORD err;
    DWORD FlagValue = FLAG_CR_NTDS_DOMAIN;
    CLASSCACHE * pCC;
    FILTER AndFilter, SystemFlagsFilter, NotFilter, ObjCategoryFilter, MixedDomainFilter;
    SEARCHARG SearchArg;
    SEARCHRES SearchRes;

    //looks for mixed domain forest-wide
    
    //initialize SearchArg
    memset(&SearchArg,0,sizeof(SearchArg));
    SearchArg.pObject = gAnchor.pPartitionsDN;
    SearchArg.choice  = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.bOneNC  = TRUE;

    if (err = DBFindDSName(pTHS->pDB,SearchArg.pObject)) {
        SetSvcErrorEx( SV_PROBLEM_WILL_NOT_PERFORM,
                       ERROR_DS_DATABASE_ERROR,
                       err );
        return err;
    }

    SearchArg.pResObj = CreateResObj(pTHS->pDB,SearchArg.pObject);

    InitCommarg(&SearchArg.CommArg);

    pCC = SCGetClassById(pTHS, CLASS_CROSS_REF);
    Assert(pCC);

    // construct filter "(objCategory==CROSS_REF)&&(systemFlags&2)&&!(ntMixedDomain==0)"
    memset(&AndFilter,0,sizeof(AndFilter));
    AndFilter.choice = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;
    
    memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
    ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
    ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                     pCC->pDefaultObjCategory->structLen;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                     (BYTE*)(pCC->pDefaultObjCategory);
    ObjCategoryFilter.pNextFilter = &SystemFlagsFilter;
    
    memset(&SystemFlagsFilter,0,sizeof(SystemFlagsFilter));
    SystemFlagsFilter.choice = FILTER_CHOICE_ITEM;
    SystemFlagsFilter.FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
    SystemFlagsFilter.FilterTypes.Item.FilTypes.ava.type = ATT_SYSTEM_FLAGS;
    SystemFlagsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                     sizeof(DWORD);
    SystemFlagsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                     (BYTE*)&FlagValue;
    SystemFlagsFilter.pNextFilter = &NotFilter;
    
    memset(&NotFilter,0,sizeof(NotFilter));
    NotFilter.choice = FILTER_CHOICE_NOT;
    NotFilter.FilterTypes.pNot = &MixedDomainFilter;
    
    memset(&MixedDomainFilter,0,sizeof(MixedDomainFilter));
    MixedDomainFilter.choice = FILTER_CHOICE_ITEM;
    MixedDomainFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    MixedDomainFilter.FilterTypes.Item.FilTypes.ava.type = ATT_NT_MIXED_DOMAIN;
    MixedDomainFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(lMixedDomain);
    MixedDomainFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)&lMixedDomain;
    
    SearchArg.pFilter = &AndFilter;

    //return one object only
    SearchArg.CommArg.ulSizeLimit = 1;

    memset(&SearchRes,0,sizeof(SearchRes));

    if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
        DPRINT1(2, "IsValidBehaviorVersionChange returns FALSE, LocalSearch failed with err(%x)\n", err);
        return err;
    }
    
    if (0 != SearchRes.count) {
        err = ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN;
        SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                     err );
        DPRINT(2, "IsValidBehaviorVersionChange returns FALSE, a dsa with lower version exists.\n");
        return err;
    }

    return 0;

}


DWORD
CheckNcNameForMangling(
    THSTATE *pTHS,
    DSNAME *pObj,
    DSNAME *pNCParent,
    DSNAME *pNCName
    )

/*++

Routine Description:

    This function is called under the following special circumstances:
1. A cross ref object is being added or reanimated.
2. We are being called in the middle of a LocalAdd or LocalModify operation.
3. We are called with the pNCName value as it is stored on the local machine.  This
may be mangled as compared with the ideal attribute which came in with the request.

The name referenced by the NCName attribute used to be present on this machine,
either as a live object, a subref or a phantom. However when the cross-ref was deleted
earlier, that name was delete managled.  Now we are bringing the cross-ref back, and we
need to unmangle the name.

Cross-ref caching: We are being called at the point in the LocalAdd process before the
cross-ref is cached. It is expected that if we correct the situation now, the cross ref
that gets cached will have the correct unmangled name.

It is assumed that the caller will update the parents ATT_SUB_REF list if necessary as a
result of adding (or reanimating) this cross ref.

It is assumed that the caller has checked that the cross ref being added is not in
the deleted state.

Arguments:

    pTHS - Thread state.
    We assume we are in a transaction.
    This code assumes the DBPOS in the thread state can have its currency changed.

    pObj - Name of the cross ref that is being added, or reanimated

    pNCParent - The parent of the local NCName value. It may be live object or phantom.
    It may be the root.

    pNCName - An add operation is underway and the NCName attribute on the cross ref has
    been added to the database in the current transaction. The value of this attribute on
    the database object is read here. This name may be delete mangled indicating that the
    local object is deleted.

Return Value:

    DWORD - Thread state error
    A note on error handling. This routine executes on a best-effort basis. If something
    is obviously wrong with the environment, we set an error. We try to unmangle the name.
    If we fail for a reason we don't expect, we simply clear the error and keep going.

--*/

{
    DWORD err;
    WCHAR wchRDNOld[MAX_RDN_SIZE], wchRDNNew[MAX_RDN_SIZE];
    DWORD cchRDNOld, cchRDNNew;
    //GUID guidMangled;
    //MANGLE_FOR eMangleFor;
    ATTRTYP attrtypRDNOld;
    ATTRVAL attrvalRDN;
    RESOBJ *pResParent = NULL;
    DSNAME *pNewNCName = NULL;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    // Don't go any further if the NCName doesn't have a guid
    if (fNullUuid(&pNCName->Guid)) {
        return 0;
    }
    // Get the Old RDN
    if (GetRDNInfo(pTHS, pNCName, wchRDNOld, &cchRDNOld, &attrtypRDNOld)) {
        return SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pNCName, ERROR_DS_BAD_NAME_SYNTAX);
    }
    // See if the reference is mangled.
    if (!IsMangledRDNExternal( wchRDNOld, cchRDNOld, &cchRDNNew )) {
        // No work for us to do!
        return 0;
    }

    // cchRDNNew now holds the length in chars of the unmangled name.
    // If the original name was very long, it is possible that part of the name
    // was truncated in the unmangling.
    // Extract the unmangled RDN
    memcpy( wchRDNNew, wchRDNOld, cchRDNNew * sizeof(WCHAR) );

    // Position on the parent
    // This has to handle the case where pNCParent is the root
    err = DBFindDSName(pTHS->pDB, pNCParent);
    if ( (err != 0) && (err != DIRERR_NOT_AN_OBJECT) ) {
        Assert( !"pNCParent reference is neither an object nor phantom!?" );
        return SetNamError(NA_PROBLEM_NO_OBJECT, pNCParent, err);
    }
    pResParent = CreateResObj(pTHS->pDB, pNCParent);
    if (!pResParent) {
        /*Couldn't create a resobj when we're on the object? Bogus */
        return SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, DIRERR_OBJ_NOT_FOUND);
    }

    // Construct new unmangled name
    // It will be smaller than the old conflicted name
    pNewNCName = (DSNAME *) THAllocEx(pTHS, pNCName->structLen);
    if ( AppendRDN(pNCParent, 
                   pNewNCName, 
                   pNCName->structLen,
                   wchRDNNew,
                   cchRDNNew,
                   attrtypRDNOld) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME, pNCParent, DIRERR_BAD_NAME_SYNTAX));
    }

    // See if the new name is available
    err = CheckNameForRename( pTHS, pResParent, wchRDNNew, cchRDNNew, pNewNCName );
    if (err) {
        // Log event indicating that the name is busy
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_ADD_CR_NCNAME_MANGLE_BUSY,
                   szInsertDN(pObj),
                   szInsertDN(pNCName),
                   szInsertDN(pNewNCName),
                   szInsertThStateErrCode( err ),
                   szInsertThStateErrMsg(),
                   NULL, NULL, NULL );
        THClearErrors();        // This is not fatal
        return 0;
    }

    // Position on the managled NC. It may be just a phantom.
    err = DBFindDSName(pTHS->pDB, pNCName);
    if ( (err != 0) && (err != DIRERR_NOT_AN_OBJECT) ) {
        Assert( !"NCName reference is neither an object nor phantom!?" );
        return SetNamError(NA_PROBLEM_NO_OBJECT, pNCName, err);
    }

    if (err == 0) {
        // NC head has a mangled name. It may be a tombstone.
        // Undelete it so it will be suitable for ReplicaAdd to use again.
        BOOL isDeleted = 0;
        SYNTAX_TIME timeDeleted = 0;
        DBResetAtt(pTHS->pDB,
                   ATT_IS_DELETED,
                   0, // delete column
                   &isDeleted,
                   SYNTAX_INTEGER_TYPE);
        DBResetAtt(pTHS->pDB,
                   FIXED_ATT_DEL_TIME,
                   0, // delete column
                   &timeDeleted,
                   SYNTAX_TIME_TYPE);
    } else {
        // Already a phantom
        // Note that phantoms normally have a DelTime and we shouldn't remove it
        Assert( err == DIRERR_NOT_AN_OBJECT );
        err = 0;
    }

    // Give the mangled NC the unmangled name. Reset the rdn to be the unmangled rdn.
    attrvalRDN.valLen = cchRDNNew * sizeof(WCHAR);
    attrvalRDN.pVal = (UCHAR *) wchRDNNew;

    Assert( err == 0 );

    err = DBResetRDN( pTHS->pDB, &attrvalRDN );
    if(!err) {
        err = DBUpdateRec(pTHS->pDB);
        if (err) {
            DPRINT1( 0, "Failed to update, err = %d\n", err );
        }
    } else {
        DPRINT1( 0, "Failed to reset rdn, err = %d\n", err );
    }

    if(!err) {
        // Log success
        LogEvent( DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ADD_CR_NCNAME_MANGLE_RENAME_SUCCESS,
                  szInsertDN(pObj),
                  szInsertDN(pNCName),
                  szInsertDN(pNewNCName) );
    } else {
        DBCancelRec(pTHS->pDB);
        // Log failure
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_ADD_CR_NCNAME_MANGLE_RENAME_FAILURE,
                   szInsertDN(pObj),
                   szInsertDN(pNCName),
                   szInsertDN(pNewNCName),
                   szInsertDbErrCode(err),
                   szInsertDbErrMsg(err),
                   NULL, NULL, NULL );
        // Do not reflect the error up to caller - keep going
        THClearErrors();
    }

    return 0;

} /* CheckNcNameForMangling */


BOOL
isModReanimation(
    THSTATE *pTHS,
    MODIFYARG *pModArg
    )

/*++

Routine Description:

Does the modification stream indicate a reanimation.

Note that this checks whether another server rewrote the is deleted attribute.
It doesn't say whether the local object was deleted prior to receiving this mod.

Arguments:

    pTHS - thread state
    pModArg - LocalModify arguments, in progress

Return Value:

    BOOL - true if is deleted was cleared in this request

--*/

{
    ULONG err;
    ATTRMODLIST *CurrentMod;
    BOOL isDeletionBeingReversed = FALSE;

    for (CurrentMod=&pModArg->FirstMod;
         NULL!=CurrentMod;
         CurrentMod=CurrentMod->pNextMod)
    {
        // See if ATT_IS_DELETED is being removed, or replaced by no value,
        // or being replaced by a value of 0.
        if ((ATT_IS_DELETED==CurrentMod->AttrInf.attrTyp) &&
            ( (AT_CHOICE_REMOVE_ATT==CurrentMod->choice) ||
              ( (AT_CHOICE_REPLACE_ATT==CurrentMod->choice) &&
                ( (0==CurrentMod->AttrInf.AttrVal.valCount) ||
                  ( (1==CurrentMod->AttrInf.AttrVal.valCount) &&
                    (CurrentMod->AttrInf.AttrVal.pAVal[0].valLen>=sizeof(ULONG)) &&
                    (NULL!=CurrentMod->AttrInf.AttrVal.pAVal[0].pVal) &&
                    (0==(*((ULONG*)CurrentMod->AttrInf.AttrVal.pAVal[0].pVal)))
                      )
                    )
                  )
                )
            ) {
            isDeletionBeingReversed = TRUE;
            // Remove this line if you add any more if's to the for loop
            break;
        }
    }

    return isDeletionBeingReversed;

} /* isModReanimation */


int
ModAutoSubRef(
    THSTATE *pTHS,
    ULONG id,
    MODIFYARG *pModArg
    )

/*++

Routine Description:

This routine handles automatic subref processing when a cross ref object is modified.

The only scenario that is supported here is that of reanimating a deleted cross ref.
A reanimation appears as an authoritative restore of the attributes of the cross ref
before it was deleted.  When the cross ref is reanimated, the nc name attribute will
referred to a nc head tombstone or a delete mangled phantom. Since we are restoring the
cross ref, we need to correct the nc name reference to be something useful.

Please also see our sister routine, mdadd.c::AddAutoSubRef().

Arguments:

    pTHS - thread state
    id - class id of the object being modified
    pModArg - modify arguments

Return Value:

    int - thread state error

--*/

{
    DSNAME *pObj = pModArg->pObject;
    DBPOS  *pDBTmp, *pDBSave;
    ULONG err;
    DSNAME *pNCName = NULL;
    BOOL    fDsaSave;
    BOOL    fDraSave;
    BOOL    fCommit;
    DSNAME *pNCParent = NULL;
    ULONG   len;
    BOOL fIsDeleted = FALSE;
    SYNTAX_INTEGER iType;

    // We only need to do something if we're adding a cross ref
    // We don't operate on deleted cross ref's
    // If it is still deleted, it can't be a reanimation!
    // Note that this check does not prove that the object was reanimated on this
    // transaction, only that is not deleted now. It could have been ok before too.
    // We are only interested in the case of the reanimation of a cross ref
    if ( (id != CLASS_CROSS_REF) ||
         ( (!( DBGetSingleValue(pTHS->pDB, ATT_IS_DELETED, &fIsDeleted,
                                sizeof(fIsDeleted),NULL) ) ) &&
           (fIsDeleted) ) ||
         (!isModReanimation( pTHS, pModArg )) ) {
        return 0;
    }

    // We enter this routine pre-positioned on the cross-ref object
    // being added, so we can read the NC-Name directly.
    err = DBGetAttVal(pTHS->pDB,
              1,
              ATT_NC_NAME,
              0,
              0,
              &len,
              (UCHAR**) &pNCName);
    if (err) {
        SetAttError(pObj,
                    ATT_NC_NAME,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_MISSING_REQUIRED_ATT);
        return pTHS->errCode;
    }

    pNCParent = THAllocEx(pTHS, pNCName->structLen);
    TrimDSNameBy(pNCName, 1, pNCParent);

    fDsaSave = pTHS->fDSA;
    fDraSave = pTHS->fDRA;
    pDBSave = pTHS->pDB;
    fCommit = FALSE;

    DBOpen(&pDBTmp);
    pTHS->pDB = pDBTmp; // make temp DBPOS the default
    pTHS->fDSA = TRUE;  // suppress checks
    pTHS->fDRA = FALSE; // not a replicated add
    __try {
        // 1. Check existence of parent
        err = DBFindDSName(pDBTmp, pNCParent);
        if (err == DIRERR_NOT_AN_OBJECT) {
            // Parent is a phantom object - no subref necessary
            err = 0;
            goto leave_actions;
        } else if (err) {
            // Error finding parent
            Assert( !"Unexpected error locating parent of nc" );
            SetSvcErrorEx(SV_PROBLEM_UNABLE_TO_PROCEED,
                          DIRERR_OBJ_NOT_FOUND, err);
            __leave;
        }

        // 2. Check the parent's instance type.  If the parent is uninstantiated,
        // then we don't want a subref under a subref and can bail.
        if ( err = DBGetSingleValue(pDBTmp, ATT_INSTANCE_TYPE, &iType,
                                    sizeof(iType),NULL) ) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_CANT_RETRIEVE_INSTANCE, err);
            __leave;
        }
        else if ( iType & IT_UNINSTANT ) {
            // No subref required.
            Assert( !err );
            goto leave_actions;
        }

        // 3. See if named nc exists as a normal object
        // Since this is a reanimation of a cross ref that already existed here,
        // and we know that if we got this far that the parent exists, then there
        // should be a real object here (actual nc head or auto subref).
        err = DBFindDSName(pDBTmp, pNCName);
        if (err) {
            // There should have been a real object here already ?
            Assert( !"should have found a real object here" );
            // Keep going
            err = 0;
            goto leave_actions;
        }

        err = AddSubToNC(pTHS, pNCName,DSID(FILENO,__LINE__));

    leave_actions:

        // Always check for name mangling on success
        if (!err) {
            err = CheckNcNameForMangling( pTHS, pModArg->pObject, pNCParent, pNCName );
        }

        Assert(!err || pTHS->errCode);
        fCommit = (0 == pTHS->errCode);

    } __finally {
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDsaSave;
        pTHS->fDRA = fDraSave;
        DBClose(pDBTmp, fCommit);
    }

    // Be heap friendly
    if (pNCName) {
        THFreeEx(pTHS, pNCName);
    }
    if (pNCParent) {
        THFreeEx(pTHS, pNCParent);
    }

    return pTHS->errCode;

} /* ModAutoSubRef */

/* Following array stores the XML scripts that are invoked
when the forest version is raised. Element i stores the 
script for forest version raised from i to i+1 or greater.
*/

WCHAR * pForestVersionUpdateScripts[] =
{ 
 /* Script that will be executed when rasing forest version from 0 to 1*/
 L"<?xml version='1.0'?>\r\n"
 L"<NTDSAscript opType=\"behaviorversionupgrade\">\r\n" 
 L"   <!-- Executed when forest version is raised from 0 to 1*-->\r\n"
 L"   <action>\r\n"
 L"      <condition>\r\n"
 L"        <if>\r\n"
 L"         <predicate test=\"compare\" path=\"$CN=ms-DS-Trust-Forest-Trust-Info,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"        <then>\r\n"
 L"         <action>\r\n"
 L"            <update path=\"$CN=ms-DS-Trust-Forest-Trust-Info,$SchemaNCDN$\">\r\n"
 L"              <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"             </update>\r\n"
 L"             </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=Trust-Direction,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"        <then>\r\n"
 L"         <action>\r\n"
 L"            <update path=\"$CN=Trust-Direction,$SchemaNCDN$\">\r\n"
 L"              <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"             </update>\r\n"
 L"         </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"            <predicate test=\"compare\" path=\"$CN=Trust-Attributes,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"       <then>\r\n"
 L"         <action>\r\n"
 L"               <update path=\"$CN=Trust-Attributes,$SchemaNCDN$\">\r\n"
 L"              <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"         </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"       <if>\r\n"
 L"         <predicate test=\"compare\" path=\"$CN=Trust-Type,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"      <then>\r\n"
 L"         <action>\r\n"
 L"           <update path=\"$CN=Trust-Type,$SchemaNCDN$\">\r\n"
 L"             <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"           </update>\r\n"
 L"         </action>\r\n"
 L"       </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=Trust-Partner,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"       <then>\r\n"
 L"         <action>\r\n"
 L"           <update path=\"$CN=Trust-Partner,$SchemaNCDN$\">\r\n"
 L"                 <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=Security-Identifier,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"       <then>\r\n"
 L"         <action>\r\n"
 L"           <update path=\"$CN=Security-Identifier,$SchemaNCDN$\">\r\n"
 L"             <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"         </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=ms-DS-Entry-Time-To-Die,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"             <update path=\"$CN=ms-DS-Entry-Time-To-Die,$SchemaNCDN$\" >\r\n"
 L"               <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"              </update>\r\n"
 L"           </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"     <condition>\r\n"
 L"        <if>\r\n"
 L"           <predicate test=\"compare\" path=\"$CN=MSMQ-Secured-Source,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"        </if>\r\n"
 L"       <then>\r\n"
 L"         <action>\r\n"
 L"            <update path=\"$CN=MSMQ-Secured-Source,$SchemaNCDN$\" >\r\n"
 L"               <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"             </update>\r\n"
 L"         </action>\r\n"
 L"        </then>\r\n"
 L"     </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"         <predicate test=\"compare\" path=\"$CN=MSMQ-Multicast-Address,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"          <then>\r\n"
 L"        <action>\r\n"
 L"           <update path=\"$CN=MSMQ-Multicast-Address,$SchemaNCDN$\" >\r\n"
 L"             <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"        </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=Print-Memory,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"           <update path=\"$CN=Print-Memory,$SchemaNCDN$\" >\r\n"
 L"                 <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=Print-Rate,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"           <update path=\"$CN=Print-Rate,$SchemaNCDN$\" >\r\n"
 L"                 <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=Print-Rate-Unit,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"           <update path=\"$CN=Print-Rate-Unit,$SchemaNCDN$\" >\r\n"
 L"                 <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L"   <action>\r\n"
 L"    <condition>\r\n"
 L"       <if>\r\n"
 L"          <predicate test=\"compare\" path=\"$CN=MS-DRM-Identity-Certificate,$SchemaNCDN$\" attribute=\"isMemberOfPartialAttributeSet\" attrval=\"FALSE\" defaultvalue=\"FALSE\" />\r\n"
 L"       </if>\r\n"
 L"       <then>\r\n"
 L"          <action>\r\n"
 L"           <update path=\"$CN=MS-DRM-Identity-Certificate,$SchemaNCDN$\" >\r\n"
 L"                 <isMemberOfPartialAttributeSet op=\"replace\">TRUE</isMemberOfPartialAttributeSet>\r\n"
 L"            </update>\r\n"
 L"          </action>\r\n"
 L"       </then>\r\n"
 L"    </condition>\r\n"
 L"   </action>\r\n"
 L"\r\n"
 L" </NTDSAscript>\r\n"
 ,
 /* Script that will be executed when raising forest version from 1 to 2*/
 NULL

};

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function is called when the forest version is raised, and it will 
   execute the XML scripts to do some necessary updates.  So far, when the
   forest version is changed from 0 to 1, we put some attributes into 
   partial attribute set.
   
   Return value: 0 on success; win32 error code otherwise.
*/

DWORD forestVersionRunScript(THSTATE * pTHS, DWORD oldVersion, DWORD newVersion)
{
    DWORD i;
    DWORD err = 0;
    DBPOS *pDBSave;
    SCENUM SchemaUpdate;
    BOOL fDsaSave;

    Assert(oldVersion <= newVersion && newVersion <= DS_BEHAVIOR_VERSION_CURRENT);
    Assert(DS_BEHAVIOR_VERSION_CURRENT<=sizeof(pForestVersionUpdateScripts)/sizeof(WCHAR*));

    pDBSave = pTHS->pDB;
    pTHS->pDB = NULL;
    SchemaUpdate = pTHS->SchemaUpdate;
    fDsaSave = pTHS->fDSA;
    pTHS->fDSA = TRUE;
    DBOpen2(TRUE, &pTHS->pDB);
    __try{
        for (i=oldVersion; i<newVersion; i++) {
            if (pForestVersionUpdateScripts[i]) {
                err = GeneralScriptExecute(pTHS,pForestVersionUpdateScripts[i]);
                DPRINT2(0,"Behavior version update script %d is executed, err=%d\n", i, err);
                if (err) {
                    __leave;
                }
            
            }
    
        } 
    }
    __finally{
        DBClose(pTHS->pDB,!err);
        pTHS->pDB = pDBSave;
        pTHS->SchemaUpdate = SchemaUpdate;
        pTHS->fDSA = fDsaSave;

    }
    return err;

}

// check if this modify op is an undelete operation
// It is, if there is a remove for isDeleted and replace for DN.
BOOL isModUndelete(MODIFYARG* pModifyArg) {
    ATTRMODLIST *pMod;
    BOOL fHasIsDeleted = FALSE;
    BOOL fHasDN = FALSE;

    for (pMod = &pModifyArg->FirstMod; pMod != NULL; pMod = pMod->pNextMod) {
        switch (pMod->AttrInf.attrTyp) {
        case ATT_IS_DELETED:
            if (pMod->choice == AT_CHOICE_REMOVE_ATT) {
                fHasIsDeleted = TRUE;
            }
            break;

        case ATT_OBJ_DIST_NAME:
            if (pMod->choice == AT_CHOICE_REPLACE_ATT && 
                pMod->AttrInf.AttrVal.valCount == 1 && 
                pMod->AttrInf.AttrVal.pAVal[0].valLen > 0) 
            {
                fHasDN = TRUE;
            }
            break;
        }

        if (fHasIsDeleted && fHasDN) {
            return TRUE;
        }
    }
    return FALSE;
}

DWORD 
UndeletePreProcess(
    THSTATE* pTHS,
    MODIFYARG* pModifyArg, 
    DSNAME** pNewDN) 
/*++
Description:
    Perform the preprocessing steps for the undelete operation:
    1. Check security
    2. Check is the operation is valid
    3. Reset isDeleted and DelTime on the object
    4. Update pResObj in pModifyArg (no longer deleted)
++*/    
{
    DWORD err;
    BOOL fNeedsCleaning;
    NAMING_CONTEXT_LIST *pNCL;
    BOOL fHasObjectCategoryMod;
    ATTRMODLIST *pMod;
    RESOBJ* pResObj;

    // DRA should not be doing undeletes.
    Assert(!pTHS->fDRA);

    *pNewDN = NULL;

    pResObj = pModifyArg->pResObj;

    // check security first
    if (CheckUndeleteSecurity(pTHS, pResObj)) {
        goto exit;
    }

    // now do a bunch of other checks.

    if (!pResObj->IsDeleted) {
        // can not undelete an object that is not deleted.
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    if (pResObj->InstanceType & IT_NC_HEAD) {
        // can not undelete NC heads
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // find the naming context
    pNCL = FindNCLFromNCDNT(pResObj->NCDNT, TRUE);
    if (pNCL == NULL) {
        // something is wrong. Can not find the subref. We can't undelete it then!
        LooseAssert(!"Naming context not found", GlobalKnowledgeCommitDelay);
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }
    if (pResObj->DNT == pNCL->DelContDNT) {
        // They are trying to undelete the deleted objects container! No, can't do that.
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // A user can not undelete himself. Check if the Sid in the ResObj matches
    // the user sid in the Authz client context (i.e. in our token).
    if (pResObj->pObj->SidLen > 0) {
        BOOL fMatches;
        err = SidMatchesUserSidInToken(&pResObj->pObj->Sid, pResObj->pObj->SidLen, &fMatches);
        if (err || fMatches) {
            // The user is attempting to delete self
            SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION, err);
            goto exit;
        }
    }

    // We should be positioned on the correct object
    Assert(pResObj->DNT == pTHS->pDB->DNT);

    // make sure the object is marked as clean, i.e. the delayed
    // link cleanup task has finished deleting this object's links
    err = DBGetSingleValue(pTHS->pDB, FIXED_ATT_NEEDS_CLEANING, &fNeedsCleaning, sizeof(fNeedsCleaning), NULL);
    if (err == 0 && fNeedsCleaning) {
        // the object is not clean yet. Return busy
        SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_OBJECT_BEING_REMOVED);
        goto exit;
    }

    // check if we have a mod for objectCategory
    // if not, we will prefill this value with the default one.
    fHasObjectCategoryMod = FALSE;

    // update the modarg
    for (pMod = &pModifyArg->FirstMod; pMod != NULL; pMod = pMod->pNextMod) {
        switch (pMod->AttrInf.attrTyp) {
        case ATT_OBJ_DIST_NAME:
            if (pMod->choice == AT_CHOICE_REPLACE_ATT && 
                pMod->AttrInf.AttrVal.valCount == 1 &&
                pMod->AttrInf.AttrVal.pAVal[0].valLen > 0) 
            {
                // remember this value
                *pNewDN = (DSNAME*)pMod->AttrInf.AttrVal.pAVal[0].pVal;
            }
            break;

        case ATT_OBJECT_CATEGORY:
            fHasObjectCategoryMod = TRUE;
            break;
        }
    }

    // We should have found the new DN: this mod was found before, in isModUndelete()
    Assert(*pNewDN);
    if ((*pNewDN)->NameLen == 0) {
        // we require that the new dn has a name in it.
        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION, ERROR_DS_INVALID_DN_SYNTAX);
        goto exit;
    }

    // Reset isDeleted and DelTime
    // succeeds or excepts (we know this att is present)
    DBRemAtt(pTHS->pDB, ATT_IS_DELETED);
    DBResetAtt(pTHS->pDB, FIXED_ATT_DEL_TIME, 0, NULL, SYNTAX_TIME_TYPE);

    if (!fHasObjectCategoryMod && !DBHasValues(pTHS->pDB, ATT_OBJECT_CATEGORY)) {
        // There is no value for objectCategory set, so populate with the default value
        CLASSCACHE *pClassSch = SCGetClassById(pTHS, pResObj->MostSpecificObjClass);
        Assert(pClassSch);
        if (!pClassSch) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_OBJ_CLASS_NOT_DEFINED);
            goto exit;
        }
    
        if (err = DBAddAttVal(pTHS->pDB,
                              ATT_OBJECT_CATEGORY,
                              pClassSch->pDefaultObjCategory->structLen,
                              pClassSch->pDefaultObjCategory)){
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
            goto exit;
        }
    }

    // flush the write buffers to the database so that we can go on with regular LocalModify checks
    // which might require moving DB currency.
    if (InsertObj(pTHS, pModifyArg->pObject, pModifyArg->pMetaDataVecRemote, TRUE, META_STANDARD_PROCESSING)) {
        // pTHS->errCode should be already set.
        Assert(pTHS->errCode);
        goto exit;
    }
    
    // now we can update the modifyarg->pResObj, it's no longer a deleted one.
    pResObj->IsDeleted = FALSE;

exit:
    return pTHS->errCode;
}

DWORD 
UndeletePostProcess(
    THSTATE* pTHS, 
    MODIFYARG* pModifyArg, 
    DSNAME* pNewDN)
{
    // ok, we are done with the modify. Now do the move.
    MODIFYDNARG modDnArg;
    MODIFYDNRES modDnRes;
    PDSNAME pNewParentDN;
    ATTRBLOCK* pRdnAttr = NULL;
    DWORD dwErr;

    Assert(pNewDN && pNewDN->NameLen > 0);
    
    pNewParentDN = THAllocEx(pTHS, pNewDN->structLen);
    if (dwErr = TrimDSNameBy(pNewDN, 1, pNewParentDN)) {
        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION, dwErr);
        goto exit;
    }

    // break the dsname in parts
    if (dwErr = DSNameToBlockName (pTHS, pNewDN, &pRdnAttr, FALSE)) {
        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_MOD_OPERATION, dwErr);
        goto exit;
    }

    memset(&modDnArg, 0, sizeof(modDnArg));
    modDnArg.CommArg = pModifyArg->CommArg;
    modDnArg.pObject = pModifyArg->pObject;
    modDnArg.pResObj = pModifyArg->pResObj;
    modDnArg.pNewParent = pNewParentDN;
    Assert(pRdnAttr->attrCount >= 1);
    modDnArg.pNewRDN = &pRdnAttr->pAttr[pRdnAttr->attrCount-1];
    
    memset(&modDnRes, 0, sizeof(modDnRes));

    // and do the move.
    LocalModifyDN(pTHS, &modDnArg, &modDnRes, TRUE);

exit:
    if (pNewParentDN) {
        THFreeEx(pTHS, pNewParentDN);
    }
    if (pRdnAttr) {
        FreeBlockName(pRdnAttr);
    }

    return pTHS->errCode;
}

DWORD
ValidateDsHeuristics(
    DSNAME       *pObject,
    ATTRMODLIST  *pAttList
    )
/*++

Routine Description:

    This routine validate the format of the dsHeuristics attribute.  This
    attribute is made up of a string of characters, normally ascii digits.  This
    function makes certain that every tenth digit equals stringlength/10.
    
Arguments:

    pTHS - thread state
    id - class id of the object being modified
    pModArg - modify arguments

Return Value:

    int - thread state error

--*/
{
    DWORD i, j;
    PWCHAR pwcHeuristic;
    DWORD  cchHeuristic;

    if (pAttList->choice != AT_CHOICE_REMOVE_ATT 
        && pAttList->choice != AT_CHOICE_REMOVE_VALUES
        && pAttList->AttrInf.AttrVal.valCount > 0) {

        pwcHeuristic = (PWCHAR)pAttList->AttrInf.AttrVal.pAVal->pVal;
        cchHeuristic = pAttList->AttrInf.AttrVal.pAVal->valLen/sizeof(WCHAR);

        for (i=9, j=1; (i < cchHeuristic) && (j < 10); i+=10, j++) {
            if (pwcHeuristic[i] != ('0' + j)) {
                return SetAttError(pObject, pAttList->AttrInf.attrTyp,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                    ERROR_DS_CONSTRAINT_VIOLATION);
            }
        }
    }

    return 0;
}

// check if this modify op is an SD change only.
BOOL isModSDChangeOnly(MODIFYARG* pModifyArg) {
    if (   pModifyArg->count == 1 
        && pModifyArg->FirstMod.choice == AT_CHOICE_REPLACE_ATT
        && pModifyArg->FirstMod.AttrInf.attrTyp == ATT_NT_SECURITY_DESCRIPTOR) 
    {
        // yep, they are modifying the SD, and SD only
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mderror.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mderror.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>			// schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>			// needed for output allocation
#include <attids.h>

// Logging headers.
#include "dsevent.h"			// header Audit\Alert logging
#include "mdcodes.h"			// header for error codes

// Assorted DSA headers.
#include "drserr.h"
#include "debug.h"			// standard debugging header
#include "dsexcept.h"
#define DEBSUB "MDERROR:"               // define the subsystem for debugging

#include <errno.h>
#include <fileno.h>
#define  FILENO FILENO_MDERROR




// Reason to put this this output even in Free Build is in order to facilitate
// diagnosis of problems rapidly. Many people will be calling the DIR apis
// via LDAP/XDS/SAM and they will either through Operator Error or Bug
// hit problems. They may or may not be running a Fixed build and may feel
// an unnecessary imposition if we tell them that to find their problem we
// need them to run a checked build. Just reducing Total-Cost-Of-Delivery.
void DbgPrintErrorInfo();
DWORD   NTDSErrorFlag=0;
#define DUMPERRTODEBUGGER(ProcessFlag,ThreadFlag)                     \
{                                                                     \
    UCHAR *pString=NULL;                                              \
    DWORD cbString=0;                                                 \
    if ((ProcessFlag|ThreadFlag) &                                    \
        (NTDSERRFLAG_DISPLAY_ERRORS|NTDSERRFLAG_DISPLAY_ERRORS_AND_BREAK))\
    {                                                                 \
        DbgPrintErrorInfo();                                          \
    }                                                                 \
                                                                      \
    if ((ProcessFlag|ThreadFlag)& NTDSERRFLAG_DISPLAY_ERRORS_AND_BREAK)\
    {                                                                 \
        DbgPrint("NTDS: User Requested BreakPoint, Hit 'g' to continue\n");\
        DbgBreakPoint();                                             \
    }                                                                \
    if(LogEventWouldLog(DS_EVENT_CAT_INTERNAL_PROCESSING,DS_EVENT_SEV_VERBOSE)) { \
        if(CreateErrorString(&pString, &cbString)) {                     \
            LogEvent( DS_EVENT_CAT_INTERNAL_PROCESSING,                  \
                      DS_EVENT_SEV_VERBOSE,                              \
                      DIRLOG_DSA_OBJECT_FAILURE,                         \
                      szInsertSz(pString),                               \
                      szInsertThStateErrCode(pTHS->errCode),             \
                      NULL );                                            \
            THFree(pString);                                             \
        }                                                                \
    }                                                                    \
}

SYSERR errNoMem = {ENOMEM,0};

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function sets an update error for output */

int APIENTRY
DoSetUpdError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid)
{
    THSTATE *pTHS=pTHStls;

    pTHS->pErrInfo = THAllocEx(pTHS, sizeof(DIRERR));
    pTHS->pErrInfo->UpdErr.problem     = problem;
    pTHS->pErrInfo->UpdErr.extendedErr = extendedErr;
    pTHS->pErrInfo->UpdErr.extendedData = extendedData;
    pTHS->pErrInfo->UpdErr.dsid = dsid;
    pTHS->errCode = updError;  /*Set the error code */
    
    //
    // Output Failure on a per process or per thread basis
    //
    DUMPERRTODEBUGGER(NTDSErrorFlag , pTHS->NTDSErrorFlag);
    
    if (pTHS->fDRA) {
        if (   (   ( UP_PROBLEM_NAME_VIOLATION == problem)
                && ( ERROR_DS_KEY_NOT_UNIQUE == extendedErr )) 
            || (    ( UP_PROBLEM_ENTRY_EXISTS == problem )
                && ( DIRERR_OBJ_STRING_NAME_EXISTS == extendedErr ) )) {
            // In these cases, we failed to do an add because the string name
            // exists or the key wasn't unique enough.  In either case, trigger
            // the appropriate dra exception to force name mangling.
            DRA_EXCEPT_DSID(DRAERR_NameCollision,
                            DIRERR_OBJ_STRING_NAME_EXISTS,
                            dsid);
        }
        else if (    ( UP_PROBLEM_OBJ_CLASS_VIOLATION == problem )
                 && ( DIRERR_OBJ_CLASS_NOT_DEFINED == extendedErr )
               ) {
           // Object class not yet defined in the local schema.
           DRA_EXCEPT_DSID(DRAERR_SchemaMismatch,
                           DIRERR_OBJ_CLASS_NOT_DEFINED,
                           dsid);
       }
       else {
           DRA_EXCEPT_DSID(DRAERR_InternalError, extendedErr, dsid);
       }
   }

   return updError;

}/*SetUpdError*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function sets a name error for output. A NULL DistName will
   set the DistName to the Root
*/
int APIENTRY
DoSetNamError (
        USHORT problem,
        DSNAME *pDN,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid)
{
    THSTATE *pTHS=pTHStls;
    NAMERR *pNamErr;



    pTHS->pErrInfo = THAllocEx(pTHS, sizeof(DIRERR));

    /*return name error.  */

    pNamErr = (NAMERR *)pTHS->pErrInfo;
    pNamErr->problem     = problem;
    pNamErr->extendedErr = extendedErr;
    pNamErr->extendedData = extendedData;
    pNamErr->dsid = dsid;
    
    if (pDN) {
	pNamErr->pMatched = THAllocEx(pTHS,  pDN->structLen );
	memcpy( pNamErr->pMatched, pDN, pDN->structLen );
    }
    else {
	pNamErr->pMatched = THAllocEx(pTHS, sizeof(DSNAME));
	pNamErr->pMatched->structLen = sizeof(DSNAME);
	pNamErr->pMatched->NameLen = 0;
    }

    pTHS->errCode = nameError;  /*Set the error code */


   //
   // Output Failure on a per process or per thread basis
   // Added Here instead of Dir return path->Want to catch
   // Local calls to.
    DUMPERRTODEBUGGER(NTDSErrorFlag , pTHS->NTDSErrorFlag);

    // If this is the DRA, bad error.

    if (pTHS->fDRA) {
        DRA_EXCEPT_DSID(DRAERR_InternalError, extendedErr, dsid);
    }

    return nameError;

}/*SetNamError*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function sets a security error for output */

int APIENTRY
DoSetSecError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid)
{
    THSTATE *pTHS=pTHStls;

    DPRINT1(2,"Setting a SECURITY ERROR with problem <%u>\n",problem);



    pTHS->pErrInfo = THAllocEx(pTHS, sizeof(DIRERR));
    pTHS->pErrInfo->SecErr.problem     = problem;
    pTHS->pErrInfo->SecErr.extendedErr = extendedErr;
    pTHS->pErrInfo->SecErr.extendedData = extendedData;
    pTHS->pErrInfo->SecErr.dsid = dsid;

    pTHS->errCode = securityError;  /*Set the error code */


   //
   // Output Failure on a per process or per thread basis
   // Added Here instead of Dir return path->Want to catch
   // Local calls to.
    DUMPERRTODEBUGGER(NTDSErrorFlag , pTHS->NTDSErrorFlag);

    // If this is the DRA, bad error.
    if (pTHS->fDRA) {
        DRA_EXCEPT_DSID(DRAERR_InternalError, extendedErr, dsid);
    }


    return securityError;

}/*SetSecErr*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function sets a service error for output */

int APIENTRY
DoSetSvcError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid)
{
    THSTATE * pTHS=pTHStls;

    if (problem == SV_PROBLEM_BUSY) {
        DPRINT2(1, "Busy with extended error %d at id 0x%x\n",
                extendedErr, dsid);
    }

    pTHS->pErrInfo = THAllocEx(pTHS, sizeof(DIRERR));
    pTHS->pErrInfo->SvcErr.problem     = problem;
    pTHS->pErrInfo->SvcErr.extendedErr = extendedErr;
    pTHS->pErrInfo->SvcErr.extendedData = extendedData;
    pTHS->pErrInfo->SvcErr.dsid = dsid;
    
    pTHS->errCode = serviceError;  /*Set the error code */


   //
   // Output Failure on a per process or per thread basis
   // Added Here instead of Dir return path->Want to catch
   // Local calls to.
    DUMPERRTODEBUGGER(NTDSErrorFlag , pTHS->NTDSErrorFlag);

    return serviceError;

}/*SetSvcError*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function sets a system error for output */

int APIENTRY
DoSetSysError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid)
{
    THSTATE *pTHS=pTHStls;

    if (problem == ENOMEM) {
	pTHS->pErrInfo = (DIRERR *) &errNoMem;
    }
    else {
	pTHS->pErrInfo = THAllocEx(pTHS, sizeof(DIRERR));
	pTHS->pErrInfo->SysErr.problem = problem;
	pTHS->pErrInfo->SysErr.extendedErr = extendedErr;
        pTHS->pErrInfo->SysErr.extendedData = extendedData;
        pTHS->pErrInfo->SysErr.dsid = dsid;
    }

    if ((problem == ENOSPC) && gfDsaWritable) {
        SetDsaWritability(FALSE, extendedErr);
    }

    pTHS->errCode = systemError;  /*Set the error code */


   //
   // Output Failure on a per process or per thread basis
   // Added Here instead of Dir return path->Want to catch
   // Local calls to.
    DUMPERRTODEBUGGER(NTDSErrorFlag , pTHS->NTDSErrorFlag);

    return systemError;

}/*SetSysError*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*++
 *  This function sets the att error.  Each call will add a new problem
 *  to the list.  The object name is only set the first time.  pVal can be
 *  set to NULL if not needed.
 */
int APIENTRY
DoSetAttError (
        DSNAME *pDN,
        ATTRTYP aTyp,
        USHORT problem,
        ATTRVAL *pAttVal,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid)
{
    THSTATE *pTHS=pTHStls;
    ATRERR *pAtrErr;
    PROBLEMLIST *pProblem;



    if (pTHS->errCode != attributeError){   /*First Time*/
	pTHS->pErrInfo = THAllocEx(pTHS, sizeof(DIRERR));

	pAtrErr = (ATRERR *) pTHS->pErrInfo;

	pAtrErr->pObject = THAllocEx(pTHS, pDN->structLen);
	memcpy(pAtrErr->pObject, pDN, pDN->structLen);

	pAtrErr->count = 0;
	pProblem = &(pAtrErr->FirstProblem);

    }
    else{
	pAtrErr = (ATRERR *)pTHS->pErrInfo;

	for (pProblem = &(pAtrErr->FirstProblem);
	     pProblem->pNextProblem != NULL;
	     pProblem = pProblem->pNextProblem)
	  ;

	pProblem->pNextProblem = THAllocEx(pTHS, sizeof(PROBLEMLIST));

	pProblem = pProblem->pNextProblem;  /* Point to new problem*/
    }

    pProblem->pNextProblem = NULL;
    ++(pAtrErr->count);
    pProblem->intprob.problem     = problem;
    pProblem->intprob.extendedErr = extendedErr;
    pProblem->intprob.extendedData = extendedData;
    pProblem->intprob.dsid = dsid;
    pProblem->intprob.type        = aTyp;

    /* If a problem att value is included, add to error */

    if (pAttVal == NULL) {
	pProblem->intprob.valReturned = FALSE;
    }
    else{
	pProblem->intprob.valReturned = TRUE;
	pProblem->intprob.Val.valLen = pAttVal->valLen;
	pProblem->intprob.Val.pVal = pAttVal->pVal;
    }

    pTHS->errCode = attributeError;  /*Set the error code */



   //
   // Output Failure on a per process or per thread basis
   // Added Here instead of Dir return path->Want to catch
   // Local calls to.
    DUMPERRTODEBUGGER(NTDSErrorFlag , pTHS->NTDSErrorFlag);


    if (pTHS->fDRA) {
        if (    ( ATT_OBJ_DIST_NAME == aTyp )
             && ( PR_PROBLEM_ATT_OR_VALUE_EXISTS == problem )
             && ( DIRERR_OBJ_STRING_NAME_EXISTS == extendedErr ) ) {
            // Name collision.
            DRA_EXCEPT_DSID(DRAERR_NameCollision, extendedErr, dsid);
        }
        else {
            // else this error reflects mismatched schemas
            DRA_EXCEPT_DSID(DRAERR_SchemaMismatch, extendedErr, dsid);
        }
    }

    return attributeError;

}/*SetAtrError*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function sets a referral error.  Each call will add a new access pnt
   to the list.  The contref info and base object name is only set the
   first time.
*/

int APIENTRY
DoSetRefError (
        DSNAME *pDN,
        USHORT aliasRDN,
        NAMERESOP *pOpState,
        USHORT RDNsInternal,
        USHORT refType,
        DSA_ADDRESS *pDSA,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid)
{
    THSTATE *pTHS=pTHStls;
    REFERR *pRefErr;
    DSA_ADDRESS_LIST *pdal;

    DPRINT(2,"Setting a Referral Error\n");

    pRefErr = (REFERR*)pTHS->pErrInfo;
    if ( (pTHS->errCode != referralError) || (pRefErr == NULL) ){    /*First Time*/

        pTHS->pErrInfo = THAllocEx(pTHS, sizeof(DIRERR));

        pRefErr = (REFERR *)pTHS->pErrInfo;

        pRefErr->extendedErr = extendedErr;
        pRefErr->extendedData = extendedData;
        pRefErr->dsid = dsid;

        pRefErr->Refer.pTarget = THAllocEx(pTHS, pDN->structLen);
        memcpy(pRefErr->Refer.pTarget, pDN, pDN->structLen);

        pRefErr->Refer.aliasRDN      = aliasRDN;
        memcpy(&(pRefErr->Refer.OpState), pOpState, sizeof(NAMERESOP));
        pRefErr->Refer.RDNsInternal = RDNsInternal;
        pRefErr->Refer.refType      = (UCHAR) refType;

        pRefErr->Refer.count = 0;
        pRefErr->Refer.pDAL = NULL;
        pRefErr->Refer.pNextContRef = NULL;
    }

    pdal = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
    pdal->Address = *pDSA;
    pdal->pNextAddress = pRefErr->Refer.pDAL;
    pRefErr->Refer.pDAL = pdal;
    ++(pRefErr->Refer.count);

    pTHS->errCode = referralError;  /*Set the error code */

    // Output Failure on a per process or per thread basis
    // Added Here instead of Dir return path->Want to catch
    // Local calls too.
    DUMPERRTODEBUGGER(NTDSErrorFlag , pTHS->NTDSErrorFlag);

    // If this is the DRA, bad error.
    if (pTHS->fDRA) {
        DRA_EXCEPT_DSID(DRAERR_InternalError, extendedErr, dsid);
    }

    return referralError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdinidsa.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdinidsa.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <attids.h>
#include <ntdsa.h>
#include <dsjet.h>              /* for error codes */
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dominfo.h>                    // InitializeDomainInformation()

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "drs.h"
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include <heurist.h>
#include "usn.h"
#include "drserr.h"
#include "dsexcept.h"
#include "dstaskq.h"
#include "drautil.h"
#include "drasig.h"
#include "drancrep.h"
#include "drameta.h"
#include "dramail.h"
#include "ntdsctr.h"                    // for perfmon counter definitions
#include <filtypes.h>                   // Def of FILTER_CHOICE_?? and
                                        // FI_CHOICE_???
#include <dsutil.h>

#include "debug.h"                      // standard debugging header
#define DEBSUB "MDINIDSA:"              // define the subsystem for debugging

#include "dsconfig.h"

#include <ntdsbsrv.h>
#include <nlwrap.h>                     // I_NetLogon* wrappers
#include <dsgetdc.h>                    // for DS_GC_FLAG
#include <ldapagnt.h>                   // LdapStartGcPort
#include <dns.h>

#include "dbintrnl.h"

#include <fileno.h>
#include <nspi.h>
#define  FILENO FILENO_MDINIDSA

BOOL gfUserPasswordSupport = FALSE;

// From dsamain.c.
ULONG GetRegistryOrDefault(char *pKey, ULONG uldefault, ULONG ulMultiplier);

// From dblayer.
extern JET_COLUMNID usnchangedid;
extern JET_COLUMNID linkusnchangedid;
//From msrpc.c
extern int gRpcListening;

/* Internal functions */
void ResetVirtualGcStatus();
void InvalidateGCUnilaterally();

/* Forward declarations */
int  GetDMDNameDSAAddr(DBPOS *pDB, DSNAME **ppSchemaDMDName);
void GetDMDAtt(DBPOS *pDB, DSNAME **ppDMDNameAddr,ULONG size);
int  GetNodeAddress(UNALIGNED SYNTAX_ADDRESS *pAddr, ULONG size);
int  DeriveConfigurationAndPartitionsDNs(void);
int  DeriveDomainDN(void);
int  WriteSchemaVersionToReg( DBPOS *pDB );
int  MakeProtectedList (DSNAME *pDSAName, DWORD ** ppList, DWORD * pCount);
void ValidateLocalDsaName(THSTATE *pTHS, DSNAME **ppDSAName);
int  DeriveSiteDNFromDSADN(IN  DSNAME * pDSADN, OUT DSNAME ** ppSiteDN, OUT ULONG * pSiteDNT, OUT ULONG  * pOptions);
void UpdateAnchorWithInvocationID(IN THSTATE *pTHS);
DWORD UpdateHasMasterNCs( void );
int  DeriveInfrastructureDN(THSTATE *pTHS);
DWORD ReadDSAHeuristics(THSTATE *pTHS);
void GetSystemDNT();

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initializes DSA by getting the DSAname and address from lanman and
   loading the Catalog information (NC's) and loading all knowledge
   into memory.
*/

extern int APIENTRY
InitDSAInfo (
        void
        )
{
    THSTATE *pTHS=pTHStls;
    UCHAR NodeAddr[MAX_ADDRESS_SIZE];
    SYNTAX_ADDRESS *pNodeAddr = (SYNTAX_ADDRESS *)NodeAddr;
    int err;
    size_t cb;
    DSNAME *pDSAName;  /*The name of this DSA */
    ULONG SiteDNT;
    void * pDummy = NULL;
    DWORD dummyDelay;

    // we are going to modify the gAnchor, so take the CS in case someone
    // else tries to do this in parallel.
    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {
        /* DSAName is globallly allocated and must be freed*/

        if (err = DBGetHiddenRec(&pDSAName, &gusnEC)) {
            DPRINT(0,"DB Error missing DSA Name..\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_DSA_NAME,
                     NULL,
                     NULL,
                     NULL);
            __leave;
        }

        gusnDSAStarted = gusnEC;

        // Initialize the UsnIssued and UsnCommitted
        // perfmon counter - as soon as it gusnEC is read
        // from the hidden record. This is initialize phase
        // and there are no outstanding transactions. So,
        // committed and issued USN values are the same.
        ISET(pcHighestUsnIssuedLo,    LODWORD(gusnEC - 1));
        ISET(pcHighestUsnIssuedHi,    HIDWORD(gusnEC - 1));
        ISET(pcHighestUsnCommittedLo, LODWORD(gusnEC - 1));
        ISET(pcHighestUsnCommittedHi, HIDWORD(gusnEC - 1));


        if (err = DBReplaceHiddenUSN(gusnInit = gusnEC+USN_DELTA_INIT)){
           DPRINT(0,"DB Error missing DSA Name..\n");
           LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_FIND_DSA_NAME,
                 NULL,
                 NULL,
                 NULL);
           __leave;
        }

        ValidateLocalDsaName(pTHS,
                             &pDSAName);

        /* Get the node address from the system and build the DSA anchor
           of type SYNTAX_DISTNAME_ADDRESS.
        */

        if (err = GetNodeAddress(pNodeAddr, sizeof(NodeAddr))){

           DPRINT(0,"Couldn't retrieve computer name for this DSA\n");
           LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_FIND_NODE_ADDRESS,
                 NULL,
                 NULL,
                 NULL);
           __leave;
        }

        gAnchor.pDSA = malloc((USHORT)DERIVE_NAME_DATA_SIZE(pDSAName, pNodeAddr));
        if (!gAnchor.pDSA) {
            MemoryPanic(DERIVE_NAME_DATA_SIZE(pDSAName, pNodeAddr));
            err = ERROR_OUTOFMEMORY;
            __leave;
        }

        BUILD_NAME_DATA(gAnchor.pDSA, pDSAName, pNodeAddr);

        // We use the DN portion alone often, so make it a separate field
        gAnchor.pDSADN = malloc(pDSAName->structLen);
        if (!gAnchor.pDSADN) {
            MemoryPanic(pDSAName->structLen);
            err = ERROR_OUTOFMEMORY;
            __leave;
        }
        memcpy(gAnchor.pDSADN, pDSAName, pDSAName->structLen);

        //
        // Get machine DNS name
        //

        {
            DWORD len = DNS_MAX_NAME_BUFFER_LENGTH+1;
            WCHAR tmpBuffer[DNS_MAX_NAME_BUFFER_LENGTH+1];

            gAnchor.pwszHostDnsName = NULL;
            if ( !GetComputerNameExW(
                         ComputerNameDnsFullyQualified,
                         tmpBuffer,
                         &len
                         ) ) {
                len = 0;
                tmpBuffer[0] = L'\0';
                DPRINT1(0,"Cannot get host name. error %x\n",GetLastError());
            }

            len++;
            gAnchor.pwszHostDnsName = (PWCHAR)malloc(len * sizeof(WCHAR));

            if ( gAnchor.pwszHostDnsName == NULL ) {
                MemoryPanic(len*sizeof(WCHAR));
                err = ERROR_OUTOFMEMORY;
                __leave;
            }

            memcpy(gAnchor.pwszHostDnsName,tmpBuffer,len*sizeof(WCHAR));
        }

        // Retrieve our invocation ID from the database and save it to gAnchor to
        // be used by other threads.
        GetInvocationId();

        // Initially we are not a GC until promotion checks have completed
        Assert( gAnchor.fAmGC == 0 );
        // Do we need to give netlogon an initial service bits gc setting?
        if ( 0 != (err = UpdateNonGCAnchorFromDsaOptions( TRUE ) )) {
            LogUnhandledError(err);
            DPRINT1(0, "Failed to update anchor from dsa options, %d\n",err);
            __leave;
        }

        if ( 0 != (err = DeriveConfigurationAndPartitionsDNs() )) {
            LogUnhandledError(err);
            DPRINT1(0, "Failed to derive configuration and partitions, %d\n",err);
            __leave;
        }

        /* Cache all knowledge references*/

        if (err = BuildRefCache(FALSE)){
            LogUnhandledError(err);
            DPRINT1(0,"Cache build failed, error %d \n",err);
            __leave;
        }

        // Set up the RPC transport address of this DSA
        if ( 0 != (err = UpdateMtxAddress() )) {
            LogUnhandledError(err);
            DPRINT1(0,"Failed to update MtxAddress, error %d\n", err);
            __leave;
        }

        // Figure out which site we're in.
        if (err = DeriveSiteDNFromDSADN(pDSAName, &gAnchor.pSiteDN, &SiteDNT, &gAnchor.SiteOptions)) {
            LogUnhandledError(err);
            DPRINT1(0, "Failed to derive site DN, error %d.\n", err);
            __leave;
        }
        gAnchor.pLocalDRSExtensions->SiteObjGuid = gAnchor.pSiteDN->Guid;

        if (err = MakeProtectedList (pDSAName,
                                    &gAnchor.pAncestors,
                                    &gAnchor.AncestorsNum)) {
            LogUnhandledError(err);
            DPRINT1(0,"Local DSA find failed in InitDSAInfo, error %d \n",err);
            __leave;
        }

        free(pDSAName);

        // Update old hasMasterNCs to new msDS-HasNasterNCs if necessary.
        if ( 0 != (err = UpdateHasMasterNCs()) ) {
            LogUnhandledError(err);
            DPRINT1(0, "Failed to UpdateHasMasterNCs(), err %d\n", err);
            __leave;
        }

        /* Load  NC catalogue into memory cache. */

        gAnchor.pMasterNC = gAnchor.pReplicaNC = NULL;
        RebuildCatalog(NULL, &pDummy, &dummyDelay);
        pTHS->fCatalogCacheTouched = FALSE;
        pTHS->fRebuildCatalogOnCommit = FALSE;

        if ( 0 != (err = DeriveDomainDN())) {
            LogUnhandledError(err);
            DPRINT1(0,"Failed to derive domain dn DN, error %d\n", err);
            __leave;
        }

        GetSystemDNT();

        if (0 != (err =DeriveInfrastructureDN(pTHS))) {
            LogUnhandledError(err);
            DPRINT1(0,"Failed to derive infrastructure DN, error %d\n",err);
            __leave;
        }

        if (err = ReadDSAHeuristics(pTHS)) {
            LogUnhandledError(err);
            DPRINT1(0,"DS Heuristics not initialized, error %d\n",err);
            // ignore this.
            err = 0;
        }

        // initialize with NULL, this will get read in RebuildAnchor
        gAnchor.allowedDNSSuffixes = NULL;
    }
    __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }

    return err;

}/*InitDSAInfo*/


DWORD
UpdateHasMasterNCs(
    )
/*++

Routine Description:

    This routine will "fix" up the hasMasterNCs and the msDS-HasMasterNCs.
    
    Between .NET Beta3 Server and .NET RC1 Server arosed the "need" to move to 
    a "new" hasMasterNCs (called msDS-HasMasterNCs), and move the original (or 
    "old") hasMasterNCs to contain only the original 3 NCs that it did in 
    Win2k.  This change will make Exchange happy.
    
    // NTRAID#NTBUG9-531591-2002/03/20-BrettSh -- See this RAID bug for a full
    // listing of the bug causing this paticular problem, references to the
    // appropriate DCR, etc.

    An original install of a domain will populate the attributes correctly, so
    this function is expected to only get to step 3 below (the real guts of 
    the function) on an upgrade from a DC (Win2k, .NET Beta 3) to a .NET RC1 
    DC.
        
        A) Copy all NCs from the old hasMasterNCs to the new 
           msDS-HasMasterNCs
           
        B) Remove all NDNCs from the old hasMasterNCs, so 
           Exchange doesn't wig out.
        
        C) (Optional Test Hook) Remove all values from 
           hasMasterNCs, for testing purposes.
           
        // NTRAID#NTBUG9-582921-2002/03/21-Brettsh but you'll have to look for
        // other occurences of this tag line and fix some of them before you
        // could truely remeove the hasMasterNCs altogether.

    The heart (below step 3) of this function assumes the following:
        These attributes are present:
            gAnchor.pDSADN
            gAnchor.pConfigDN
            gAnchor.pCRL
        These attributes are not present (so we can't use them):
            gAnchor.pDMD
            gAnchor.pMasterNCs
            Schema Cache Invalid (except for the two XX_HAS_MASTER_NCS attrs!)
        
Return Values:
    
    Win32 Error, depending on success.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DBPOS *     pDBCat;
    ATTCACHE *  pAC_NewMsDsHasMasterNCs;
    ATTCACHE *  pAC_OldHasMasterNCs;
    DSNAME *    pdnNC = NULL;
    ULONG       cbNC = 0;
    DSNAME **   ppNCRemoveList = NULL;
    ULONG       cbNCRemoveList;
    ULONG       cNCRemoveList;
    BOOL        fRemoveHasMasterNCs = FALSE; // See (3.C) below 
    DWORD       err = ERROR_DS_CODE_INCONSISTENCY;
    ULONG       NthValIndex;
    ULONG       iNC;
    DSNAME *    pdnSchemaNc = NULL;
    CROSS_REF * pCR = NULL;
    COMMARG     CommArg;
    ULONG       dsid = DSID(FILENO, __LINE__);


#ifdef DBG
    // This #ifdef forces us to only allow removal of the hasMasterNCs in 
    // debug mode.  Don't want customers accidentally doing this.
    // NTRAID#NTBUG9-582921-2002/03/21-Brettsh - For more info see this bug 
    // and other occurrences of this RAID tag line through the code:
    GetConfigParam(DEBUG_REMOVE_HAS_MASTER_NCS, 
                   &fRemoveHasMasterNCs, 
                   sizeof(fRemoveHasMasterNCs));
#endif
    
    DPRINT(3, "Entering UpdateHasMasterNCs()\n");

    if (DsaIsInstalling()) {
        return(ERROR_SUCCESS);
    }
    
    Assert(gAnchor.pDSADN);
    Assert(gAnchor.pConfigDN);

    DBOpen(&pDBCat);
    __try
    {
        //
        // 1) Position on DSA object.
        //
        // PREFIX: dereferencing uninitialized pointer 'pDBCat'
        //         DBOpen returns non-NULL pDBCat or throws an exception
        if (FindAliveDSName(pDBCat, gAnchor.pDSADN)) {
            DPRINT(2,"***Couldn't locate the DSA object\n");

            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_DSA_OBJ,
                     NULL,
                     NULL,
                     NULL);

            dsid = DSID(FILENO, __LINE__);
            err = ERROR_DS_CANT_FIND_DSA_OBJ;
            __leave;
        }

        //
        // 2) See if we have a msDS-HasMasterNCs (the "NEW" hasMasterNCs)
        //
        pAC_NewMsDsHasMasterNCs = SCGetAttById(pTHS, ATT_MS_DS_HAS_MASTER_NCS);
        Assert(pAC_NewMsDsHasMasterNCs);
        err = DBGetAttVal_AC(pDBCat, 1, pAC_NewMsDsHasMasterNCs,
                                     0, 0, &cbNC, (UCHAR **) &pdnNC);

        if (err == ERROR_SUCCESS) {

            // 
            // Yeah! Normal case, we have values in msDS-HasMasterNCs, return.
            //

            THFreeEx(pTHS, pdnNC);
            pdnNC = NULL;
            err = ERROR_SUCCESS;
            __leave;

        } else if (err != DB_ERR_NO_VALUE){

            dsid = DSID(FILENO, __LINE__);
            DPRINT1(0, "***Got error %d trying to load ATT_MS_DS_HAS_MASTER_NCS\n", err);
            Assert(!"Is this a valid state, I don't think so, maybe out of mem while booting?");
            __leave;

        }
        Assert(err == DB_ERR_NO_VALUE);
        err = 0;
        
        //
        // 3) Missing msDS-HasMasterNCs, so upgrade it from hasMasterNCs 
        //    (the "OLD" hasMasterNCs)
        //
        // This is expected when we've been upgraded from DC that 
        // previously didn't know about the "new" msDS-HasMasterNCs
        // attribute.
        DPRINT(0, "Upgrading hasMasterNCs to msDS-HasMasterNCs ...\n");

        //
        // We need the schema NC, because it isn't in the anchor yet.
        //
        if (err = DBGetAttVal(pDBCat,1, ATT_DMD_LOCATION, 0, 0,
                              &cbNC, (PUCHAR *)&pdnSchemaNc)){
            dsid = DSID(FILENO, __LINE__);
            DPRINT1(0,"DMD Att missing from DSA object..., err = %d\n", err);
            __leave;
        }
        Assert(pdnSchemaNc);
        
        //
        // Init List of NCs to remove.
        //
        cbNCRemoveList = sizeof(DSNAME*) * 6; // good first guess, most DCs have from 3 to 6 NCs.
        ppNCRemoveList = THAllocEx(pTHS, cbNCRemoveList);
        cNCRemoveList = 0;
        
        // Walk old hasMasterNCs.
        pAC_OldHasMasterNCs = SCGetAttById(pTHS, ATT_HAS_MASTER_NCS); // "Old" value
        Assert(pAC_OldHasMasterNCs);
        NthValIndex = 0;
        while(!(err = DBGetAttVal_AC(pDBCat, ++NthValIndex, pAC_OldHasMasterNCs,
                                     0, 0, &cbNC, (UCHAR **) &pdnNC))) {

            Assert(cbNC == pdnNC->structLen);
            
            // Add this value to the "NEW" msDS-HasMasterNCs.
            err = DBAddAttVal_AC(pDBCat, pAC_NewMsDsHasMasterNCs, pdnNC->structLen, pdnNC);
            if (err) {
                dsid = DSID(FILENO, __LINE__);
                DPRINT1(0, "Couldn't add an NC to the new msDS-HasMasterNCs attr on the DSA, err = %d ...\n", err);
                __leave;
            }
            DPRINT1(2, "    moving NC to msDS-HasMasterNCs: %ws\n", pdnNC->StringName); 

            InitCommarg(&CommArg);
            pCR = FindExactCrossRef(pdnNC, &CommArg);
            if (pCR == NULL) {
                dsid = DSID(FILENO, __LINE__);
                err = ERROR_DS_CANT_FIND_EXPECTED_NC;
                __leave;
            }

            if (fRemoveHasMasterNCs ||
                (!NameMatched(gAnchor.pConfigDN, pdnNC) &&
                 !NameMatched(pdnSchemaNc, pdnNC) &&
                 !(pCR->flags & FLAG_CR_NTDS_DOMAIN))
                ) {
                // Flag this NC for removal from hasMasterNCs, if it's an 
                // NDNC or we're supposed to remove the whole hasMasterNCs.

                if ( (cbNCRemoveList/sizeof(DSNAME*)) <= cNCRemoveList ) {
                    // Expand existing array if necessary.
                    cbNCRemoveList *= 2;
                    ppNCRemoveList = THReAllocEx(pTHS, ppNCRemoveList, cbNCRemoveList);
                }

                // Add to removal array
                ppNCRemoveList[cNCRemoveList] = pdnNC;
                cNCRemoveList++;
                pdnNC = NULL; // We've consumed pdnNC.

            } else {
                // We don't need this particular value.
                THFreeEx(pTHS, pdnNC);
                pdnNC = NULL;
            }

        }
        Assert(NthValIndex >= 4); // Must have at least 3 values
        if (err != DB_ERR_NO_VALUE) {
            dsid = DSID(FILENO, __LINE__);
            DPRINT1(0, "***Error reading db value: 0x%x\n\n", err);
            __leave;
        }
        err = 0;

        //
        // 4) Remove all NDNCs from the old hasMsaterNCs, so Exchange
        //    doesn't wig out.
        //
        // NOTE: Optionally, this will also remove all values from 
        // hasMasterNCs if fRemoveHasMasterNCs was set.
        for (iNC = 0; iNC < cNCRemoveList; iNC++) {

            // Remove this value
            Assert(ppNCRemoveList[iNC]);
            err = DBRemAttVal_AC(pDBCat, pAC_OldHasMasterNCs, 
                                 ppNCRemoveList[iNC]->structLen, 
                                 ppNCRemoveList[iNC] );
            if (err) {
                dsid = DSID(FILENO, __LINE__);
                DPRINT1(0, "Couldn't remove an NC from the DSA, err = %d ...\n", err);
                __leave;
            }
            DPRINT1(1, "    removed NC from hasMasterNCs: %ws\n", ppNCRemoveList[iNC]->StringName);

            THFreeEx(pTHS, ppNCRemoveList[iNC]);
            ppNCRemoveList[iNC] = NULL;
        }


        // Update the DSA with all new "has master NCs" attributes.
        err = DBRepl(pDBCat, FALSE,  0, NULL, META_STANDARD_PROCESSING);
        if (err) {
            dsid = DSID(FILENO, __LINE__);
            DPRINT1(0, "Couldn't update the master ncs attrs, err = %d ...\n", err);
            __leave;
        }

    } __finally {

        if (pdnSchemaNc) { THFreeEx(pTHS, pdnSchemaNc); }
        if (pdnNC) { THFreeEx(pTHS, pdnNC); }
        if (ppNCRemoveList) {
            for (iNC = 0; iNC < cNCRemoveList; iNC++) {
                if (ppNCRemoveList[iNC]) { THFreeEx(pTHS, ppNCRemoveList[iNC]); }
                ppNCRemoveList[iNC] = NULL;
            }
            THFreeEx(pTHS, ppNCRemoveList);
        }

        // If we had an error, we don't want to make any changes!
        DBClose( pDBCat, !( AbnormalTermination() || err ) );

    }

    if (err) {
        Assert(!"I see no reason an error should occur?");
        LogAndAlertUnhandledErrorDSID(err, dsid);
    }

    return(err);
}



/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Loads the global gpRootDomainSid with the root domain's Sid, which
   is used for  SD conversions during schema cache load and during install.
   The Sid is provided in registry during install, and is extracted from
   gAnchor (filled in by InitDsaInfo) during normal running
*/

void LoadRootDomainSid()
{
    ULONG buffLen = sizeof(NT4SID) + 1;

    // allocate max sid size (the 1 is for the null RegQueryValueEx appends
    // at the end)

    gpRootDomainSid = (PSID) malloc(buffLen);
    if (!gpRootDomainSid) {
      DPRINT(0,"Failed to allocate memory for root domain sid\n");
      // not fatal, go on
      return;
    }

    // Set to 0
    memset(gpRootDomainSid, 0, buffLen);

    // First try the registry. The root domain sid will be there during
    // install (and NOT there during normal running)

    if (!GetConfigParam(ROOTDOMAINSID, gpRootDomainSid, buffLen)) {

        // got the sid from the registry, return
        DPRINT(1,"Found root domain sid in registry\n");
        return;
    }
    else {
       DPRINT(1,"Failed to get root domain sid in registry, trying gAnchor\n");
    }

    // Not in registry, try the gAnchor

    // Set to 0 again, in case GetConfigParam mess with the buffer
    memset(gpRootDomainSid, 0, buffLen);

    // Copy from the gAnchor if present
    if ( gAnchor.pRootDomainDN && gAnchor.pRootDomainDN->SidLen) {

       // there is a sid
       memcpy(gpRootDomainSid, &gAnchor.pRootDomainDN->Sid, gAnchor.pRootDomainDN->SidLen);
       DPRINT(1,"Found root domain sid in gAnchor\n");
    }
    else {

        DPRINT(1,"No root domain sid found at all!!!\n");

        // No Sid found. Free the memory and set the global back to NULL
        // so that the conversion routines will revert to default behavior
        // (the default behavior is to replace EA by DA and resolve SA
        // relative to the current domain)

        free(gpRootDomainSid);
        gpRootDomainSid = NULL;
    }

     return;

}  /* LoadRootDomainSid */


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Make a list of the DNTS of the ancestors of the local DSA object, the
 * local DSA object itself.
*/

int MakeProtectedList (DSNAME *pDSAName,
                       DWORD **ppList,
                       DWORD *pCount)
{
    DBPOS *pDBTmp;
    int err;
    DWORD *pList = NULL, Count;

    *ppList = NULL;
    *pCount = 0;

    // If not yet installed, nothing to do.

    if ( DsaIsInstalling() ) {
        return 0;
    }

    // Get the DNTs of all the ancestors of the local DSA object and save
    // them in gAnchor. Needed to prevent replicated deletion of these
    // objects.  Note that the list must be ordered from the bottom of the tree
    // toward the top of the tree.

    DBOpen (&pDBTmp);
    __try
    {
        // PREFIX: dereferencing uninitialized pointer 'pDBTmp'
        //         DBOpen returns non-NULL pDBTmp or throws an exception
        if  (!(err = DBFindDSName (pDBTmp, pDSAName))) {
            
            ULONG cAVA;

            CountNameParts(pDSAName, &cAVA);

            pList = malloc(cAVA * sizeof(ULONG));
            if (!pList) {
                MemoryPanic(cAVA * sizeof(ULONG));
                err = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            Count = 0;
            do {
                pList[Count++] = pDBTmp->DNT;
                cAVA--;
                DBFindDNT(pDBTmp, pDBTmp->PDNT);
            } while (pDBTmp->PDNT != ROOTTAG);
            Assert(cAVA==1);
            *ppList = pList;
            *pCount = Count;
        }
    }
    __finally
    {
        DBClose (pDBTmp, !AbnormalTermination() && err == ERROR_SUCCESS);
        if (AbnormalTermination()) {
            if (pList) {
                free(pList);
            }
        }
    }

    return err;
}

ULONG
GetNextObjByUsn(
    IN OUT  DBPOS *   pDB,
    IN      ULONG     ncdnt,
    IN      USN       usnSeekStart,
    OUT     USN *     pusnFound         OPTIONAL
    )
/*++

Routine Description:

   Return objects found on the given Usn index.

   Note that this version does not consider values. To do so,
   use GetNextObjOrValByUsn()

Arguments:

    pDB (IN/OUT) - On successful return, is positioned on candidate.

    ncdnt (IN) - NC being replicated.

    usnSeekStart (IN) - Consider only objects with >= this USN.

    pusnFound (OUT/OPTIONAL) - last usn found

Return Values:

    ERROR_SUCCESS - Next candidate found and positioned in object table.

    ERROR_NO_MORE_ITEMS - No more objects to be replicated.

--*/
{
    unsigned len;
    DB_ERR  err;
    ULONG ncdntFound, usnFound;
    ULONG retval = ERROR_DS_GENERIC_ERROR;
    char objval;
    BOOL fSeekToNext = TRUE;

    // NOTE, this used to leave the currency in the object table somewhere else
    // if it didn't find an object.  It might also have left a different current
    // index.

#if DBG
    // Check for valid USN
    if (usnSeekStart < USN_START) {
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }
#endif

    // Set index as supplied.
    if ((err = DBSetCurrentIndex(pDB, Idx_DraUsn, NULL, FALSE)) != DB_success) {
        DRA_EXCEPT (DRAERR_DBError, err);
    }

    do { // Until we find a record, complete, or time out

        // Seek or move to next record.
        if (!fSeekToNext) {
            // The next record is found by doing a Move
            if (err = DBMove(pDB, FALSE, DB_MoveNext)) {
                // If the error is No current record, we're done.

                if (err == DB_ERR_NO_CURRENT_RECORD) {
                    retval = ERROR_NO_MORE_ITEMS;
                    break;
                }
                else {
                    DRA_EXCEPT (DRAERR_DBError, err);
                }
	    }

	}
        else {
            INDEX_VALUE IV[3];

            // Make appropriate key for seek to next record.
            DWORD numVals = 0;

            IV[numVals].pvData =  &ncdnt;
            IV[numVals].cbData = sizeof(ncdnt);
            numVals++;

            IV[numVals].pvData = &usnSeekStart;
            IV[numVals].cbData = sizeof(usnSeekStart);
            numVals++;

            err = DBSeek(pDB, IV, numVals,  DB_SeekGE);
            if (err != DB_success) {
                retval = ERROR_NO_MORE_ITEMS;
                break;
            }
            fSeekToNext = FALSE;
        }

        if (NULL != pusnFound) {
            // Caller requested USN -- get it.
            err = DBGetSingleValueFromIndex(pDB,
                                            ATT_USN_CHANGED,
                                            pusnFound,
                                            sizeof(USN),
                                            NULL);
            if (err) {
                DRA_EXCEPT(DRAERR_DBError, err);
            }
        }

        // Retrieve ncdnt
        // Read from Index instead of record for performance
        err = DBGetSingleValueFromIndex(pDB,
                                        FIXED_ATT_NCDNT,
                                        &ncdntFound,
                                        sizeof(ncdntFound),
                                        &len);
        if (err || (len != sizeof(ncdntFound))) {
            DRA_EXCEPT (DRAERR_DBError, err);
        }

        // Check to see if this record has the correct ncdnt. If not then
        // we're past end of NC, and we're done.
        if (ncdnt != ncdntFound) {
            // Past this NC. Exit with found all
            retval = ERROR_NO_MORE_ITEMS;
            break;
        }

        // Check that is an object and not just a record.
        err = DBGetSingleValue(pDB,
                               FIXED_ATT_OBJ,
                               &objval,
                               sizeof(objval),
                               NULL);
        if (err || !objval) {
            // If this assert fires, need to reconsider timeout support
            Assert( !"Not expecting to find a phantom on the usn index" );
            // Not an object, continue search.
            DPRINT1(0, "[PERF] Phantom @ DNT %d has an NCDNT.\n", pDB->DNT);
            continue;
        }

        // We found an object, return object found.
        retval = ERROR_SUCCESS;
        break;

    } while (1);

    // We need to flip to the DNTIndex, preseverving currency.
    DBSetCurrentIndex(pDB, Idx_Dnt, NULL, TRUE);

    // Unexpected errors should generate exceptions; "normal" errors should be
    // one of the below.
    Assert((ERROR_SUCCESS == retval)
           || (ERROR_NO_MORE_ITEMS == retval));

    return retval;
}

enum _FIND_NEXT_STATE {
    FIND_NEXT_SEEK,
    FIND_NEXT_MOVE,
    FIND_NEXT_STAY,
    FIND_NEXT_END
};

ULONG
GetNextObjOrValByUsn(
    IN OUT  DBPOS *   pDB,
    IN      ULONG     ncdnt,
    IN      USN       usnSeekStart,
    IN      BOOL      fCritical,
    IN      BOOL      fIncludeValues,
    IN      ULONG *   pulTickToTimeOut  OPTIONAL,
    IN OUT  VOID **   ppvCachingContext,
    OUT     USN *     pusnFound         OPTIONAL,
    OUT     BOOL *    pfValueChangeFound OPTIONAL
    )
/*++

Routine Description:

Find the next outbound replication candidate.

This routine finds either object or value changes, sorted by increasing usn.
Both kinds of changes are intermingled on the same usn change stream.

The DBPOS is left positioned on the change. The DBPOS can hold currency on
one object and currency on one link value at the same time.

If an object change is found, we are positioned on that object and the link
table currency is undefined.

If a value change is found, the link table is positioned on that record. The
object table is positioned to the object containing that value.  In this way,
the usual checks for criticality, ancestors, etc can be performed on behalf
of the value by doing them to the value's containing object.

Some effort has been spent to optimize this routine, since it is the heart of the
server-side of GetNCChanges().  All reads of attributes in this routine should
be from an index.  Since criticality is not stored on the records in the
link table, a cache is used to save the expense of looking up the corresponding
data table object each time to determine criticality.

The indexes have been designed to support this function efficiently. There are two
indexes that are used. See dblayer/dbinit.c for their definition.
Link Table Index SZLINKDRAUSNINDEX
Key Segments: SZLINKNCDNT SZLINKUSNCHANGED SZLINKDNT

Data Table Index SZDRAUSNCRITICALINDEX
Key Segments: SZNCDNT SZUSNCHANGED SZISCRITICAL SZDNT
Flags: IgnoreAnyNull
Since SZISCRITICAL is an optional attribute, the flag has the effect of pruning
the index to only those objects that are critical, or were in the past.  Thus,
when searching for critical objects, only very likely critical objects are
considered.

Data Table Index SZDRAUSNINDEX
Key Segments: SZNCDNT SZUSNCHANGED
Note that SZISCRITICAL and SZDNT are not on this index. Since we have a
dedicated index for criticality, we don't need them.  This does mean that in
the code below we delay fetching critical and dnt until we are doing critical
processing.

Having the DNT on both indexes allows an efficient pairing of the link
change to the containing object. It is necessary to find the containing
object of a link when computing criticality.

FUTURE ENHANCEMENT:
One future enhancement to this routine is to preserve the routine context
across calls.  If the find-next-state were preserved, it would be possible
to skip reseeking to an index that was already at the end.  If the last
usnObject were preserved when a value change was found, it would be possible
to postpone a reseek to an object change until we know if it would win against
the next value change.

Arguments:

    pDB (IN/OUT) - On successful return, is positioned on candidate.

    ncdnt (IN) - NC being replicated.

    usnSeekStart (IN) - Consider only objects with >= this USN.

    fCritical (IN) - If true, return critical objects only; if false, ignore
        criticality.

    fIncludeValues(IN) - Always return objects. If true, include values as well.

    pulTickToTimeOut (IN, OPTIONAL) - If present, terminate search once this
        tick has transpired.

    ppvCachingContext (IN, OUT) - Holds caching context opaque to caller across
                   multiple calls. Contents set to NULL on first call.

    pusnFound (OUT, OPTIONAL) - If present, holds the USN of the candidate
        object on successful return.

    pfValueChangeFound (OUT, OPTIONAL) - If present, will be set according to
        whether a value change was found.

Return Values:

    ERROR_SUCCESS - Next candidate found and positioned in object table.
              usnFound and valueChangeFound are valid.

    ERROR_NO_MORE_ITEMS - No more objects to be replicated.
        Neither usnFound and valueChangeFound are valid.

    ERROR_TIMEOUT - The timeout given in pulTickToTimeOut transpired before
        a suitable candidate could be found.
        Only usnFound is valid.

--*/
{
    unsigned len;
    DB_ERR  err;
    ULONG ncdntFound, dntLink;
    USN usnObj, usnLink, usnFound;
    ULONG retval = ERROR_TIMEOUT;
    enum _FIND_NEXT_STATE findNextObjState, findNextLinkState;
    INDEX_VALUE IV[2];
    BOOL fValueFound, fRefresh;

    DPRINT3( 3, "GetNextObjOrValByUsn, ncdnt=%d, usnseekstart=%I64d, fCritical=%d\n",
             ncdnt, usnSeekStart, fCritical );
#if DBG
    // Check for valid USN
    if (usnSeekStart < USN_START) {
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }
#endif

    // Make appropriate key for seek to next record.
    IV[0].pvData =  &ncdnt;
    IV[0].cbData = sizeof(ncdnt);
    IV[1].pvData = &usnSeekStart;
    IV[1].cbData = sizeof(usnSeekStart);

    // Initialize caching context if first time
    if ( (fCritical) && (NULL == *ppvCachingContext) ) {
        *ppvCachingContext = dntHashTableAllocate( pDB->pTHS );
    }

    // Initialize search state. Only search what we need to.
    findNextObjState = FIND_NEXT_SEEK;
    findNextLinkState = (pDB->pTHS->fLinkedValueReplication && fIncludeValues) ?
        FIND_NEXT_SEEK : FIND_NEXT_END;

    usnObj = usnLink = usnSeekStart;

    do { // Until we find a record, complete, or time out

        // Object State
        fRefresh = FALSE;
        switch (findNextObjState) {
        case FIND_NEXT_SEEK:
            // Set object table index to DraUsn
            if ((err = DBSetCurrentIndex(pDB,
                                         fCritical ? Idx_DraUsnCritical : Idx_DraUsn,
                                         NULL, FALSE)) != DB_success) {
                DRA_EXCEPT (DRAERR_DBError, err);
            }

            err = DBSeekEx(pDB, pDB->JetObjTbl, IV, 2, DB_SeekGE);
            if (err != DB_success) {
                // ERROR_NO_MORE_ITEMS;
                findNextObjState = FIND_NEXT_END;
                break;
            }
            findNextObjState = FIND_NEXT_MOVE;
            fRefresh = TRUE;
            break;
        case FIND_NEXT_MOVE:
            // The next record is found by doing a Move
            if (err = DBMoveEx(pDB, pDB->JetObjTbl, DB_MoveNext)) {
                // If the error is No current record, we're done.
                if (err == DB_ERR_NO_CURRENT_RECORD) {
                    // ERROR_NO_MORE_ITEMS;
                    findNextObjState = FIND_NEXT_END;
                    break;
                }
                else {
                    DRA_EXCEPT (DRAERR_DBError, err);
                }
            }
            fRefresh = TRUE;
            break;
        case FIND_NEXT_STAY:
            findNextObjState = FIND_NEXT_MOVE;
            break;
        }

        // If our position has moved, refresh our variables
        if ( fRefresh ) {

            // Retrieve data from index
            DBGetObjectTableDataUsn( pDB, &ncdntFound, &usnObj, NULL );

            // Check to see if this record has the correct ncdnt. If not then
            // we're past end of NC, and we're done.
            if (ncdnt != ncdntFound) {
                findNextObjState = FIND_NEXT_END;
                usnObj = 0;
            }
        }

        // Link State
        fRefresh = FALSE;
        switch (findNextLinkState) {
        case FIND_NEXT_SEEK:
            // Set link table index to LinkDraUsn
            if ((err = DBSetCurrentIndex(pDB, Idx_LinkDraUsn, NULL, FALSE)) != DB_success) {
                DRA_EXCEPT (DRAERR_DBError, err);
            }
            err = DBSeekEx(pDB, pDB->JetLinkTbl, IV, 2, DB_SeekGE);
            if (err != DB_success) {
                // ERROR_NO_MORE_ITEMS;
                findNextLinkState = FIND_NEXT_END;
                break;
            }
            findNextLinkState = FIND_NEXT_MOVE;
            fRefresh = TRUE;
            break;
        case FIND_NEXT_MOVE:
            // The next record is found by doing a Move
            if (err = DBMoveEx(pDB, pDB->JetLinkTbl, DB_MoveNext)) {
                // If the error is No current record, we're done.
                if (err == DB_ERR_NO_CURRENT_RECORD) {
                    // ERROR_NO_MORE_ITEMS;
                    findNextLinkState = FIND_NEXT_END;
                    break;
                }
                else {
                    DRA_EXCEPT (DRAERR_DBError, err);
                }
            }
            fRefresh = TRUE;
            break;
        case FIND_NEXT_STAY:
            findNextLinkState = FIND_NEXT_MOVE;
            break;
        }

        // If our position has moved, refresh our variables
        if ( fRefresh ) {

            DBGetLinkTableDataUsn( pDB, &ncdntFound, &usnLink, &dntLink );

            // Check to see if this record has the correct ncdnt. If not then
            // we're past end of NC, and we're done.
            if (ncdnt != ncdntFound) {
                findNextLinkState = FIND_NEXT_END;
                usnLink = 0;
                dntLink = 0;
            }
        }

        // The following are now initialized:
        // ncdntFound, usnObj, usnLink, dntLink

        Assert( (findNextObjState == FIND_NEXT_END) ||
                (findNextObjState == FIND_NEXT_MOVE) );
        Assert( (findNextLinkState == FIND_NEXT_END) ||
                (findNextLinkState == FIND_NEXT_MOVE) );

        // If both streams are at an end, we are done
        if ( (findNextObjState == FIND_NEXT_END) &&
             (findNextLinkState == FIND_NEXT_END) ) {
            retval = ERROR_NO_MORE_ITEMS;
            break;
        }

        if (findNextLinkState == FIND_NEXT_END) {
            // Only an object change is available
            fValueFound = FALSE;
            usnFound = usnObj;
            Assert( findNextObjState == FIND_NEXT_MOVE );
            // findNextLinkState == FIND_NEXT_END

        } else if (findNextObjState == FIND_NEXT_END) {
            // Only an link change is available
            fValueFound = TRUE;
            usnFound = usnLink;
            Assert( findNextLinkState == FIND_NEXT_MOVE );
            // findNextObjState == FIND_NEXT_END

        } else {
            // Both changes are available

            Assert( findNextObjState == FIND_NEXT_MOVE );
            Assert( findNextLinkState == FIND_NEXT_MOVE );

            if (usnObj < usnLink) {
                // The object change is next
                fValueFound = FALSE;
                usnFound = usnObj;
                findNextLinkState = FIND_NEXT_STAY;
            } else if (usnObj > usnLink) {
                // The link change is next
                fValueFound = TRUE;
                usnFound = usnLink;
                findNextObjState = FIND_NEXT_STAY;
            } else {
                Assert( FALSE );
                DRA_EXCEPT (DRAERR_DBError, ERROR_DS_INTERNAL_FAILURE );
            }
        }

        // Return usn to caller if desired
        // Must be return on ERROR_TIMEOUT so do it now
        if (NULL != pusnFound) {
            *pusnFound = usnFound;
        }

#if DBG
        if (fValueFound) {
            Assert( findNextLinkState == FIND_NEXT_MOVE );
            Assert( (findNextObjState == FIND_NEXT_STAY) ||
                    (findNextObjState == FIND_NEXT_END) );
        } else {
            Assert( findNextObjState == FIND_NEXT_MOVE );
            Assert( (findNextLinkState == FIND_NEXT_STAY) ||
                    (findNextLinkState == FIND_NEXT_END) );
        }
#endif

        // Check if object is critical, highly optimized
        if (fCritical) {
            BOOL critical = FALSE;
            DWORD dntFound;

            if (fValueFound) {
                dntFound = dntLink;
            } else {
                // Ugh. We delay getting the DNT until now because the DNT is on
                // the SZDRAUSNCRITICAL, but not on SZDRAUSN. We could add it, but
                // it is not really needed.
                err = DBGetSingleValueFromIndex( pDB, FIXED_ATT_DNT,
                                                 &dntFound, sizeof( dntFound ), NULL );
                if (err) {
                    DRA_EXCEPT (DRAERR_DBError, err);
                }
            }
            // Determine the dnt of the object we need to check

            // Have we already cached it?
            if (FALSE == dntHashTablePresent( *ppvCachingContext,
                                     dntFound, &critical )) {
                // Not cached
                if (fValueFound) {
                    // Don't do anything to disturb the object table
                    // PERF NOTE: This is expensive. We essentially have to "join"
                    // the link and object tables in order to determine if the
                    // link is critical. Use a special index for this.
                    DBSearchCriticalByDnt( pDB, dntFound, &critical );
                } else {
                    // Object remains on usn index, so use it
                    // We know this to be non-null by virtue SZDRAUSNCRITICAL index
                    err = DBGetSingleValueFromIndex( pDB, ATT_IS_CRITICAL_SYSTEM_OBJECT,
                                                 &critical, sizeof( BOOL ), NULL );
                    if (err) {
                        DRA_EXCEPT (DRAERR_DBError, err);
                    }
                }
                // Cache the result
                dntHashTableInsert( pDB->pTHS, *ppvCachingContext, dntFound, critical );
            }
            // else DNT is cached

            if (!critical) {
                // We wanted critical and its not...
                continue;
            }
#if DBG
            if (fValueFound) {
                DPRINT1( 1, "Found critical value on object %s\n",
                         DBGetExtDnFromDnt( pDB, dntFound ) );
            } else {
                DPRINT1( 1, "Found critical object %s\n", GetExtDN( pDB->pTHS, pDB ) );
            }
#endif
        }

#if DBG
        // Verify that our object is valid
        // Do this last since it is not a read from index
        if (!fValueFound) {
            char objval;

            Assert( findNextObjState == FIND_NEXT_MOVE );
            Assert( (findNextLinkState == FIND_NEXT_STAY) ||
                    (findNextLinkState == FIND_NEXT_END) );

            err = DBGetSingleValue(pDB, FIXED_ATT_OBJ,
                               &objval, sizeof(objval), NULL);
            if (err || !objval) {
                Assert( !"Not expecting to find a phantom on the usn index" );
                // Not an object, continue search.
                continue;
            }
        }
#endif

        // We found an object, return object found.
        retval = ERROR_SUCCESS;
        // Indicate what kind of currency we have
        if (pfValueChangeFound) {
            *pfValueChangeFound = fValueFound;
        }
        break;

    } while ((NULL == pulTickToTimeOut)
             || (CompareTickTime(GetTickCount(), *pulTickToTimeOut)
                 < 0));

    if (ERROR_TIMEOUT == retval) {
        // This should be a rare condition, isolated to critical object
        // replication in large domains and oddball cases where a long sync
        // did not quite complete (ergo, no UTD vector update) and then a
        // different source was chosen (e.g., the original source went down).
        DPRINT(0, "Time expired looking for outbound replication candidates.\n");
    }

#if DBG
    if ((NULL != pusnFound)
        && ((ERROR_SUCCESS == retval)
            || (ERROR_TIMEOUT == retval))
        && (!fValueFound)
        ) {
        // Assert that we're returning the correct usn.
        USN usnTmp;

        err = DBGetSingleValueFromIndex(pDB,
                                        ATT_USN_CHANGED,
                                        &usnTmp,
                                        sizeof(usnTmp),
                                        NULL);
        Assert(!err);
        Assert(*pusnFound == usnTmp);
    }
#endif

    if (retval == ERROR_SUCCESS) {
        // If an object change was found, the object table is already positioned
        // For a value, position object table on containing object
        if (fValueFound) {
            // Position on the containing object
            // Index is changed as a result of this call
            DBFindDNT( pDB, dntLink );

            // Object currency has been lost
        } else {
            // We need to flip to the DNTIndex, preseverving currency.
            // BUGBUG: Why?
            DBSetCurrentIndex(pDB, Idx_Dnt, NULL, TRUE);
        }
    }

    // Unexpected errors should generate exceptions; "normal" errors should be
    // one of the below.
    Assert((ERROR_SUCCESS == retval)
           || (ERROR_TIMEOUT == retval)
           || (ERROR_NO_MORE_ITEMS == retval));

    return retval;
}


/* Initializes Schema by getting the DMD name and DSA accesspoint and
   calling creighton's schema loading functions.
*/

int APIENTRY LoadSchemaInfo(THSTATE *pTHS){

   DSNAME *pSchemaDMDName = NULL;
   DBPOS *pDB = NULL;
   int err = 0;
   BOOL fCommit = FALSE;
   DSNAME *pLDAPDMD = NULL;

   DPRINT(1,"LoadSchemaInfo entered\n");

   DBOpen(&pDB);
   __try {

       // If the schema has previously been downloaded, unload it and
       // free the DMD name if it exists.

       if (gAnchor.pDMD){
           free(gAnchor.pLDAPDMD);
           gAnchor.pLDAPDMD = NULL;
           free(gAnchor.pDMD);
           gAnchor.pDMD = NULL;
           SCUnloadSchema (FALSE);
       }

       if (pTHS && !pTHS->pDB) {
           pTHS->pDB = pDB;
       }


       //SCCacheSchemaInit();

       if (err = GetDMDNameDSAAddr(pDB, &pSchemaDMDName)){

           DPRINT(2, "Couldn't find DMD name/address to load\n");
           __leave;
       }

       // Schema loaded so set the DMD name/DNT in our global data structure.

       gAnchor.pDMD = pSchemaDMDName;

       if (    DBFindDSName( pDB, gAnchor.pDMD )
            || DBGetSingleValue(
                    pDB,
                    FIXED_ATT_DNT,
                    &gAnchor.ulDNTDMD,
                    sizeof( gAnchor.ulDNTDMD ),
                    NULL
                    )
          )
       {
           err = DIRERR_INVALID_DMD;
           LogUnhandledError( err );
           DPRINT( 0, "Couldn't retrieve DMD DNT\n" );
           __leave;
       }

       // Read the object version attribute from the schema,
       // and write to the registry
       if ( err = WriteSchemaVersionToReg(pDB) ) {
         DPRINT(0, "Error writing schema version to registry\n");
         __leave;
       }

       // register this as the active schema container.
       if(err = RegisterActiveContainer(pSchemaDMDName,
                                        ACTIVE_CONTAINER_SCHEMA)) {
           LogUnhandledError(err);
           DPRINT(0, "Couldn't register active schema container\n");
           __leave;
       }

       // Create the pLDAPDMD. Allocate more than enough space
       pLDAPDMD = (DSNAME *)THAllocEx(pTHS,
                                      gAnchor.pDMD->structLen +
                                       (MAX_RDN_SIZE+MAX_RDN_KEY_SIZE)*(sizeof(WCHAR)) );
       if(err = AppendRDN(gAnchor.pDMD,
                          pLDAPDMD,
                          gAnchor.pDMD->structLen +
                            (MAX_RDN_SIZE+MAX_RDN_KEY_SIZE)*(sizeof(WCHAR)),
                          L"Aggregate",
                          9,
                          ATT_COMMON_NAME)) {
           LogUnhandledError(err);
           DPRINT(0, "Couldn't create LDAP DMD name\n");
           __leave;
       }

       gAnchor.pLDAPDMD = malloc(pLDAPDMD->structLen);
       if(!gAnchor.pLDAPDMD) {
           MemoryPanic(pLDAPDMD->structLen);
           err = 1;
           __leave;
       }
       memcpy(gAnchor.pLDAPDMD,pLDAPDMD,pLDAPDMD->structLen);
       err = DBFindDSName(pDB, gAnchor.pLDAPDMD);
       if (!err) {
           gAnchor.ulDntLdapDmd = pDB->DNT;
       }


       /* Download the schema */
       if (err = SCCacheSchema2()) {
         LogUnhandledError(err);
         DPRINT1(0,"LoadSchemaInfo: Error from SCCacheSchema2 %d\n", err);
         __leave;
       }
       if (err = SCCacheSchema3()) {
         LogUnhandledError(err);
         DPRINT1(0,"LoadSchemaInfo: Error from SCCacheSchema3 %d\n", err);
         __leave;
       }

       fCommit = TRUE;
       err = 0;
   }
   __finally
   {
        DBClose(pDB, fCommit);
        if (pLDAPDMD) THFreeEx(pTHS,pLDAPDMD);
   }

   return err;

}/*LoadSchemaInfo*/



DSNAME *
SearchExactCrossRef(
    THSTATE *pTHS,
    DSNAME *pNC
    )

/*++

Routine Description:

    Search the database for a cross ref with a NCNAME matching the given NC. For use when the
    in-memory cross ref cache might be inconsistent and we must be positive of the correct
    result.

    A new dbpos is used so that currency is not affected.

Arguments:

    pTHS - thread state
    pNC - Naming context to match

Return Value:

    Exception raised on error
    DSNAME * - NULL if not found
               DSNAME of cross ref if found
    The DSNAME returned is part of the search result. The search result is left
    dangling in thread-allocated memory.

--*/

{
    CLASSCACHE *pCC;
    DWORD err;
    SEARCHARG SearchArg;
    SEARCHRES SearchRes;
    FILTER AndFilter,NcNameFilter,ObjCategoryFilter;
    DBPOS *pDBSave;
    BOOL fDSASave;
    
    Assert(VALID_THSTATE(pTHS));
    Assert( pNC );

    pCC = SCGetClassById(pTHS, CLASS_CROSS_REF);
    Assert(pCC);

    //set filters "objCategory==CLASS_CROSS_REF && NC_NAME=pNC"
    memset(&AndFilter,0,sizeof(AndFilter));
    AndFilter.choice = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.count = 2;
    AndFilter.FilterTypes.And.pFirstFilter = &ObjCategoryFilter;

    // Use ObjectCategory because it is indexed
    memset(&ObjCategoryFilter,0,sizeof(ObjCategoryFilter));
    ObjCategoryFilter.choice = FILTER_CHOICE_ITEM;
    ObjCategoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                     pCC->pDefaultObjCategory->structLen;
    ObjCategoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                     (BYTE*)(pCC->pDefaultObjCategory);
    
    ObjCategoryFilter.pNextFilter = &NcNameFilter;

    memset(&NcNameFilter,0,sizeof(NcNameFilter));
    NcNameFilter.choice = FILTER_CHOICE_ITEM;
    NcNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_NC_NAME;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = pNC->structLen;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)pNC;

    //initialize SearchArg
    memset(&SearchArg,0,sizeof(SearchArg));
    SearchArg.pObject = gAnchor.pPartitionsDN;
    SearchArg.choice  = SE_CHOICE_IMMED_CHLDRN; // one level search
    SearchArg.bOneNC  = TRUE;
    SearchArg.pSelection = NULL; // No attributes needed

    InitCommarg(&SearchArg.CommArg);

    SearchArg.pFilter = &AndFilter;

    memset(&SearchRes,0,sizeof(SearchRes));

    //save current DBPOS etc
    fDSASave = pTHS->fDSA;
    pDBSave  = pTHS->pDB;
    __try {
        //open another DBPOS
        pTHS->pDB = NULL;
        DBOpen(&(pTHS->pDB));
        __try {
            // Position on partitions container
            if (err = DBFindDSName(pTHS->pDB,SearchArg.pObject)) {
                DRA_EXCEPT (DRAERR_DBError, err);
            }

            SearchArg.pResObj = CreateResObj(pTHS->pDB,SearchArg.pObject);

            if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
                DPRINT1( 0, "LocalSearch failed with error %d\n", err );
#if DBG
                DbgPrintErrorInfo();
#endif
                DRA_EXCEPT (DRAERR_DBError, err);
            }
        } __finally {
            // faster to commit a read transaction than rollback
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __finally {
        //restore the saved value
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASave;
    }

    if (!SearchRes.count) {
        DPRINT1( 1, "Cross ref for partition %ws does not exist.\n", pNC->StringName );
        return NULL;
    }

    if (SearchRes.count > 1) {
        DRA_EXCEPT(ERROR_DS_CROSS_REF_EXISTS, 0);
    }

    Assert( SearchRes.FirstEntInf.Entinf.pName );

    DPRINT2( 1, "Cross ref %ws has partition %ws.\n",
             SearchRes.FirstEntInf.Entinf.pName->StringName,
             pNC->StringName );

    return SearchRes.FirstEntInf.Entinf.pName;
} /* SearchExactCrossRef */

// Enumerate all cross-refs in the db.
// Note: the currency on the pDB is not preserved.
DWORD EnumerateCrossRefs(THSTATE* pTHS, DBPOS* pDBCat, PFN_ENUMERATE_CROSS_REFS pfnCallback, PVOID pContext) {
    FILTER ClassFil;
    SYNTAX_OBJECT_ID CRClass  = CLASS_CROSS_REF;
    RESOBJ *pResObj = NULL;
    int  err;
    FILTER *pInternalFilter = NULL;

    if ( NULL == gAnchor.pPartitionsDN ) {
        return ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER;
    }

    // Set up common part of filter struct.

    memset (&ClassFil, 0, sizeof (ClassFil));
    ClassFil.pNextFilter = NULL;
    ClassFil.choice = FILTER_CHOICE_ITEM;
    ClassFil.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ClassFil.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ClassFil.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(CRClass);
    ClassFil.FilterTypes.Item.FilTypes.pbSkip = NULL;

    // Set a filter to return only cross reference child objects
    ClassFil.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *)&CRClass;

    DPRINT(2,"find the Partitions container\n");

    if (err = FindAliveDSName(pDBCat, gAnchor.pPartitionsDN)) {

        DPRINT(0,"***Couldn't locate the partitions container object\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_CANT_FIND_PARTITIONS_OBJ,
            NULL,
            NULL,
            NULL);
        goto exit;
    }
    pResObj = CreateResObj(pDBCat, gAnchor.pPartitionsDN);

    pInternalFilter = NULL;
    if ( (err = DBMakeFilterInternal(pDBCat, &ClassFil, &pInternalFilter, NULL)) != ERROR_SUCCESS)
    {
        goto exit;
    }
    DBSetFilter(pDBCat, pInternalFilter,NULL, NULL,0,NULL);
    DBSetSearchScope(pDBCat, SE_CHOICE_IMMED_CHLDRN, FALSE, pResObj);
    DBChooseIndex(pDBCat, 0,0,0, SORT_NEVER, DBCHOOSEINDEX_fUSEFILTER, 0xFFFFFFFF);

    DPRINT(2,"LOADING the Cross Reference List\n");

    while (!DBGetNextSearchObject(pDBCat, 0, 0, 
                                  DB_SEARCH_FORWARD | DB_SEARCH_DONT_EVALUATE_SECURITY)) {
        err = (*pfnCallback)(pTHS, pDBCat, pContext);
        if(err) {
            break;
        }
    }
    
exit:
    if (pResObj) {
        THFree(pResObj);
    }
    return err;
}

typedef struct {
    PWCHAR pszRootDomainDnsName;
    CROSS_REF_LIST *pNewList;
    CROSS_REF_LIST *pLastCR;
} BUILD_REF_CACHE_CONTEXT;

DWORD buildRefCacheCallback (THSTATE* pTHS, DBPOS* pDBCat, BUILD_REF_CACHE_CONTEXT* pContext) {
    DWORD err;
    CROSS_REF_LIST *pCRL;

    // don't check for dups right now. We will do it later, after the search is done.
    err = MakeStorableCRL(pTHS,
                          pDBCat,
                          NULL,
                          &pCRL,
                          NULL);
    if(err) {
        return err;
    }
    if (pContext->pLastCR == NULL) {
        // first entry
        pContext->pNewList = pContext->pLastCR = pCRL;
    }
    else {
        pContext->pLastCR->pNextCR = pCRL;
        pCRL->pPrevCR = pContext->pLastCR;
        pContext->pLastCR = pCRL;
    }

    if ((NULL != gAnchor.pRootDomainDN)
         && NameMatched( gAnchor.pRootDomainDN, pCRL->CR.pNC)) {
        // remember the root dns name
        pContext->pszRootDomainDnsName = pCRL->CR.DnsName;
    }

#if defined(DBG)
    // Update that we haven't updated our latest global knowledge yet.
    gdwLastGlobalKnowledgeOperationTime = GetTickCount();
#endif

    return err;
}


DWORD addPapvPtr(VOID* ptr, DWORD_PTR** ppapv, DWORD* plenpapv);
DWORD appendCRDataToPapv(CROSS_REF_LIST* pCRL, DWORD_PTR** ppapv, DWORD* plenpapv);
VOID FreeCrossRefListEntry(CROSS_REF_LIST **ppCRL);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int APIENTRY
BuildRefCache(
    BOOL IN   fNotifyNetLogon
    )
/* Rebuild the cache that holds cross and superior knowledge references.

   Basically,  the cross references and seperior reference for this DSA
   reside as children objects of the DSA object itself.  The DSA object is
   a child of the Server object.  The steps are as follows:

 - We free all existing cross references and the superior reference.

 - We retrieve the DSA object and set a filter for the
   cross-reference  object class.  We retrieve each object and move
   it to the cache.

 - We reposition on the DSA, set a filter for the superior reference
   (only 1), retrieve it an relocate it to the cache.
*/
{
    THSTATE *pTHS=pTHStls;
    ULONG len;
    DBPOS *pDBCat = NULL;
    CROSS_REF_LIST *pCRL;       /*Used to free existing cr buffer*/
    int err = 0;
    DWORD_PTR *papv = NULL;         // for delayed freeing
    DWORD lenpapv = 0;              // length of the papv array
    BUILD_REF_CACHE_CONTEXT context;
#ifdef DBG
    DWORD    cCRs = 0;
#endif

    DPRINT(2,"BuildRefCache entered\n");

    context.pszRootDomainDnsName = NULL;
    context.pNewList = context.pLastCR = NULL;

    if ( NULL == gAnchor.pPartitionsDN ) {
        // there is no partitions container
        // this is allowed during setup.
        goto UpdateAnchor;
    }

    /*cache all cross references and the superior reference*/

    DBOpen(&pDBCat);
    __try {
        err = EnumerateCrossRefs(pTHS, pDBCat, buildRefCacheCallback, &context);
        #if defined(DBG)
        gdwLastGlobalKnowledgeOperationTime = GetTickCount();
        #endif
    }
    __finally {
        DBClose(pDBCat, !AbnormalTermination() && err == 0);
    }

    if (err) {
        goto exit;
    }

    // now, check for dups in the list
    for (pCRL = context.pNewList; pCRL != NULL; pCRL = pCRL->pNextCR) {
        CROSS_REF *pCRexisting;
        // check for dup cross ref in the tail of the list
        pCRexisting = FindCrossRefInList(pCRL->CR.pNCBlock, pCRL->pNextCR);
        if ( pCRexisting
            && BlockNamePrefix(pTHS, pCRL->CR.pNCBlock, pCRexisting->pNCBlock)) {
            Assert(NameMatched(pCRL->CR.pNC, pCRexisting->pNC));
            // The only way this could happen is if a CR is already present
            // for the exact NC we're trying to add a CR for now.  Although
            // the DS handles this, we don't want to encourage people in
            // doing so.  Therefore fail the operation unless it's the DS
            // itself or the replicator who's creating the object, or we
            // have asked to ignore this case since a prior deletion will
            // remove this before adding the new one.
            Assert(!"We should never hit this, as we moved this error condition to be checked in VerifyNcName()");
            SetSvcError(SV_PROBLEM_INVALID_REFERENCE, DIRERR_CROSS_REF_EXISTS);
            err = ERROR_DS_CROSS_REF_EXISTS;
            break;
        }
#ifdef DBG
        cCRs++;
#endif        
    }

#ifdef DBG
    GlobalKnowledgeCommitDelay = (cCRs > 10) ? ((cCRs < 100) ? 
                                                             (cCRs/10+1)*5 : 
                                                             GLOBAL_KNOWLEDGE_COMMIT_DELAY_MAX) :
                                             GLOBAL_KNOWLEDGE_COMMIT_DELAY_MIN;
#endif

    if (err) {
        goto exit;
    }

UpdateAnchor:

    // no try-finally because no exception can be raised in the block
    EnterCriticalSection(&gAnchor.CSUpdate);

    for (pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR){
        err = appendCRDataToPapv(pCRL, &papv, &lenpapv);
        if (err) goto LeaveCS;
    }

    err = addPapvPtr(gAnchor.pwszRootDomainDnsName, &papv, &lenpapv);
    if (err) goto LeaveCS;

    gAnchor.pCRL = context.pNewList;
    if (lenpapv > 0) {
        DelayedFreeMemoryEx(papv, 3600);
    }
    context.pNewList = NULL;
    papv = NULL;

    ResetVirtualGcStatus();

    if (context.pszRootDomainDnsName) {
        if (err = UpdateRootDomainDnsName(context.pszRootDomainDnsName)) {
            DPRINT(2,"DNS root missing from cross-ref object\n");
            goto LeaveCS;
        }
    }
    else {
        gAnchor.pwszRootDomainDnsName = NULL;
    }

LeaveCS:
    LeaveCriticalSection(&gAnchor.CSUpdate);
    
exit:
    // if we allocated some memory, but did not succeed writing it into gAnchor then free it
    while (pCRL = context.pNewList) {
        context.pNewList = pCRL->pNextCR;
        FreeCrossRefListEntry(&pCRL);
    }
    if (papv) {
        free(papv);
    }

    if (fNotifyNetLogon && err == 0) {
        dsI_NetNotifyDsChange(NlNdncChanged);
    }

    Assert(    ( NULL == gAnchor.pRootDomainDN )
            || ( NULL != gAnchor.pwszRootDomainDnsName )
          );
    
    return err;

}/*BuildRefCache*/

// retry in 5 minutes if failed
#define RebuildRefCacheRetrySecs 5 * 60

void
RebuildRefCache(void * fNotifyNetLogon,
                void ** ppvNext,
                DWORD * pcSecsUntilNextIteration )
// BuildRefCache variant for the task queue
{
    DWORD err;
    PVOID dwEA;
    ULONG dwException, dsid;
    
    __try {
        err = BuildRefCache( (fNotifyNetLogon==NULL) ? FALSE : TRUE );
    }
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwEA,
                              &err,
                              &dsid)) {
        if (err == 0) {
            err = ERROR_DS_UNKNOWN_ERROR;
        }
        HandleDirExceptions(dwException, err, dsid);
    }

    if (err) {
        // We didn't succeed, so try again in a few minutes
        *ppvNext = NULL;
        *pcSecsUntilNextIteration = RebuildRefCacheRetrySecs;

        DPRINT2(0, "RebuildRefCache failed err=0x%08x. Will retry in %d minutes.\n", err, RebuildRefCacheRetrySecs/60);
        LogEvent(
            DS_EVENT_CAT_INTERNAL_PROCESSING,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_REF_CACHE_REBUILD_FAILURE,
            szInsertInt(err),
            szInsertWin32Msg(err),
            szInsertInt(RebuildRefCacheRetrySecs/60)
            );
    }
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

/* Get the DMD name and DSA access point that holds the DMD.
   We get the DMD (name address) attributed and set the return DMDName to
   the name portion of this attr.  We setup an access point by setting
   the DSA name to root (not used) and the address to the addr portion
   of the DMD attribute.

*/

int  GetDMDNameDSAAddr(DBPOS *pDB, DSNAME **ppSchemaDMDName)
{

   DSNAME   *pDMDNameAddr=NULL;

   DPRINT(1,"GetDMDNameDSAAddr entered\n");


   DPRINT(2,"Get the DMD Name from the Local DSA\n");

   // Since we do not know the size, set size parameter to 0.
   // The call to DBGetAttVal inside GetDMDAtt will allocate
   // buffer of proper size and set pDMDNameAddr to point to it
   GetDMDAtt(pDB, &pDMDNameAddr, 0);

   if (!pDMDNameAddr) {
       DPRINT(1,"GetDMDNameDSAddr could not GetDMDAtt\n");
       return 1;
   }

   *ppSchemaDMDName = calloc(1,pDMDNameAddr->structLen);
   if (!*ppSchemaDMDName) {
       MemoryPanic(pDMDNameAddr->structLen);
       return 1;
   }
   memcpy(*ppSchemaDMDName, pDMDNameAddr, pDMDNameAddr->structLen);

   if(pDMDNameAddr) {
       THFree(pDMDNameAddr);
   }


   return 0;

}/*GetDMDNameDSAAddr*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* returns the DMD attribute from the DSA.  A name structlen of 0 indicates
   that for some reason this attribute could not be returned.
*/

void GetDMDAtt(DBPOS *pDB, DSNAME **ppDMDNameAddr, ULONG size){

   UCHAR      syntax;
   ULONG      len, lenX;
   UCHAR     *pVal, *pValX;

   DPRINT(1,"GetDMDAtt entered\n");

   /* Initialize the structure to 0 indicating the default of not found */

   if (FindAliveDSName(pDB, gAnchor.pDSADN)){
      DPRINT(2,"Retrieval of the DSA object failed\n");
      return;
   }

   if (DBGetAttVal(pDB,1, ATT_DMD_LOCATION,
                         DBGETATTVAL_fREALLOC,
                         size,
                         &len, (PUCHAR *)ppDMDNameAddr)){

       DPRINT(2,"DMD Att missing from DSA object...\n");
       return;
   }
   return;
}/*GetDMDAtt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function should derive the address of the node  by getting the
    the lanman.ini node name.
*/

int
GetNodeAddress (
        UNALIGNED SYNTAX_ADDRESS *pAddr,
        ULONG size
        )
{
    DWORD byteCount;
    WCHAR pDSAString[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cbDSAString = sizeof(pDSAString) / sizeof(pDSAString[0]);

    DPRINT(1,"GetNodeAddress entered\n");

    if (!GetComputerNameW( pDSAString, &cbDSAString)) {
        DPRINT(2,"GetComputerName failed?\n");
        return GetLastError();
    }

    byteCount = wcslen(pDSAString) * sizeof(WCHAR);
    pAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( byteCount );
    if (pAddr->structLen > size) {
        pAddr->structLen = 0;
        return ERROR_INSUFFICIENT_BUFFER;
    }
    memcpy(pAddr->byteVal, pDSAString,byteCount);

    return 0;

}/*GetNodeAddress*/


/*** GetInvocationId - get the DSAs invocation id from the database and
   save it in a global. If the invocation id does not exist, which it
    won't before installation, set invocation id to zero.
*/
void
APIENTRY
GetInvocationId(void)
{
    THSTATE *pTHS;
    DBPOS *pDB;
    BOOL fCommit = FALSE;

    DBOpen(&pDB);
    pTHS = pDB->pTHS;

    __try {
        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        if (!DBFindDSName(pDB, gAnchor.pDSADN)) {
            if(DBGetSingleValue(pDB, ATT_INVOCATION_ID, &pTHS->InvocationID,
                                sizeof(pTHS->InvocationID), NULL)) {
                // No invocation id yet, set to zero.
                memset(&pTHS->InvocationID, 0, sizeof(UUID));
            }
        }

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_SET_UUID,
                 szInsertUUID(&pTHS->InvocationID),
                 NULL,
                 NULL);

        fCommit = TRUE;
    }
    __finally {
        DBClose(pDB, TRUE);
    }

    UpdateAnchorWithInvocationID(pTHS);
}


int
DeriveConfigurationAndPartitionsDNs(void)

/*++

Description:

    Derive DSNAMEs of the Configuration and Partitions containers
    and the Directory Service enterprise-wide config onject using
    knowledge of where the DSA object lives and place them in gAnchor.

Arguments:

    None

Return Value:

    0 on success, !0 otherwise.

--*/

{
    DBPOS       *pDB = NULL;
    unsigned    cParts;
    int         err;
    ULONG       len;
    DWORD       dwTmp;
    UCHAR      *pTmp;
    THSTATE    *pTHS=pTHStls;

    // During normal operation, the DSA's DN is
    // CN=NTDS-Settings,CN=Some Server,CN=Servers,CN=Some Site,CN=Sites, ...
    // During initial install, the DSA lives in CN=BootMachine,O=Boot.
    // So we can easily detect the install case by testing for
    // a DSA name length of two.

    Assert(NULL != gAnchor.pDSADN);

    if ( 0 != CountNameParts(gAnchor.pDSADN, &cParts) )
        return(1);

    if ( 2 == cParts )
        return(0);              // install case - nothing to do

    // Next Allocate proper sized memories for configDN, partitionsDN,
    // and DsDvcConfigDN in gAnchor.

    // ConfigDN's size will be less than that of the DSA DN
    gAnchor.pConfigDN = (PDSNAME) malloc(gAnchor.pDSADN->structLen);

    if ( NULL == gAnchor.pConfigDN )
    {
        MemoryPanic(gAnchor.pDSADN->structLen);
        return(1);
    }

    // Root domain DN's size will be less than that of the DSA DN
    gAnchor.pRootDomainDN = (PDSNAME) malloc(gAnchor.pDSADN->structLen);

    if ( NULL == gAnchor.pRootDomainDN )
    {
        free(gAnchor.pConfigDN);
        MemoryPanic(gAnchor.pDSADN->structLen);
        return(1);
    }
    // PartitionsDN adds only L"CN=Partitions" to config DN. DSADN might have
    // been renamed, but we know it sits inside the configuration container.
    // So, to be safe, we will allocate a bit more memory.
    gAnchor.pPartitionsDN = (PDSNAME) malloc(gAnchor.pDSADN->structLen + 20*sizeof(WCHAR));

    if ( NULL == gAnchor.pPartitionsDN )
    {
        free(gAnchor.pConfigDN);
        free(gAnchor.pRootDomainDN);
        MemoryPanic(gAnchor.pDSADN->structLen);
        return(1);
    }


    gAnchor.pExchangeDN = NULL;


    // DSSvcConfigDN adds L"CN=Directory Service,CN=Windows NT,CN=Services,"
    // to the ConfigDN. Allocate more than enough space
    gAnchor.pDsSvcConfigDN = (PDSNAME) malloc(gAnchor.pDSADN->structLen +
                                                 64*(sizeof(WCHAR)) );

    if ( NULL == gAnchor.pDsSvcConfigDN )
    {
        free(gAnchor.pConfigDN);
        free(gAnchor.pRootDomainDN);
        free(gAnchor.pPartitionsDN);
        MemoryPanic(gAnchor.pDSADN->structLen + 64*sizeof(WCHAR));
        return(1);
    }

    // Set all allocated memory to 0, and the structLens to size of
    // memory allocated

    memset(gAnchor.pConfigDN, 0, gAnchor.pDSADN->structLen);
    memset(gAnchor.pRootDomainDN, 0, gAnchor.pDSADN->structLen);
    memset(gAnchor.pPartitionsDN, 0, gAnchor.pDSADN->structLen);
    memset(gAnchor.pDsSvcConfigDN, 0,
           gAnchor.pDSADN->structLen + 64*sizeof(WCHAR));

    gAnchor.pConfigDN->structLen = gAnchor.pDSADN->structLen;
    gAnchor.pRootDomainDN->structLen = gAnchor.pDSADN->structLen;
    gAnchor.pPartitionsDN->structLen = gAnchor.pDSADN->structLen;
    gAnchor.pDsSvcConfigDN->structLen = ( gAnchor.pDSADN->structLen +
                                         64*sizeof(WCHAR) );

    // We need the name of a couple of containers, but just temporarily.
    // To be cheap, we're going to use those tempting blocks of memory
    // that we just allocated for more permanent uses.  The first
    // container we want is the Sites container.  We know it will fit in
    // the buffer we just allocated for the Config DN, because we allocated
    // enough space to hold the DN of the DSA, which we know to be a
    // descendent of the Sites container.
    TrimDSNameBy(gAnchor.pDSADN, 4, gAnchor.pConfigDN);
    RegisterActiveContainer(gAnchor.pConfigDN, ACTIVE_CONTAINER_SITES);

    // Ok, next we need the subnets container, which is an immediate child
    // of the sites container.  We still know that things will fit, because
    // "Subnets" is shorter than "NTDS Settings".
    if ( 0 != AppendRDN(gAnchor.pConfigDN,
                        gAnchor.pRootDomainDN,
                        gAnchor.pRootDomainDN->structLen,
                        L"Subnets",
                        0,
                        ATT_COMMON_NAME)) 
    {
        // failed to append RDN for whatever reason...
        Assert(!"Failed to Append RDN");
        return 1;
    }
    RegisterActiveContainer(gAnchor.pRootDomainDN, ACTIVE_CONTAINER_SUBNETS);

    // We're all done now, so return this memory to its pristine state
    memset(gAnchor.pConfigDN, 0, gAnchor.pDSADN->structLen);
    memset(gAnchor.pRootDomainDN, 0, gAnchor.pDSADN->structLen);

    // Trim CN=NTDS-Settings,CN=Some Server,CN=Servers,CN=Some Site,CN=Sites
    // of the DSA DSNAME to get the configuration container name.

    if ( 0 != TrimDSNameBy(gAnchor.pDSADN, 5, gAnchor.pConfigDN) )
        return(1);

    // Trim "CN=Configuration" off the configuration container name to get the
    // root domain.

    if ( 0 != TrimDSNameBy(gAnchor.pConfigDN, 1, gAnchor.pRootDomainDN) )
        return(1);

    // Partitions container is a child of the Configuration container.
    if ( 0 != AppendRDN(gAnchor.pConfigDN,
                        gAnchor.pPartitionsDN,
                        gAnchor.pPartitionsDN->structLen,
                        L"Partitions",
                        0,
                        ATT_COMMON_NAME))
    {
        // failed to append RDN for whatever reason...
        Assert(!"Failed to Append RDN");
        return 1;
    }

    RegisterActiveContainer(gAnchor.pPartitionsDN,
                            ACTIVE_CONTAINER_PARTITIONS);

    // Directory Service container is a distant child of the Configuration
    // container.

    wcscpy(
        gAnchor.pDsSvcConfigDN->StringName,
        L"CN=Directory Service,CN=Windows NT,CN=Services,"
        );
    wcscat(gAnchor.pDsSvcConfigDN->StringName, gAnchor.pConfigDN->StringName);
    gAnchor.pDsSvcConfigDN->NameLen =wcslen(gAnchor.pDsSvcConfigDN->StringName);

    // We have the names.  Now look them up in the database so that
    // the cached versions have the right GUIDs.

    DBOpen(&pDB);
    err = 1;


    __try
    {
        // First the Configuration container.

        if ( 0 != DBFindDSName(pDB, gAnchor.pConfigDN) )
            leave;

        if (   ( 0 != DBGetAttVal(
                        pDB,
                        1,                      // get one value
                        ATT_OBJ_DIST_NAME,
                        DBGETATTVAL_fCONSTANT,  // providing our own buffer
                        gAnchor.pConfigDN->structLen,      // buffer size
                        &len,                   // buffer used
                        (UCHAR **) &gAnchor.pConfigDN) )
            || ( 0 != DBGetSingleValue(
                        pDB,
                        FIXED_ATT_DNT,
                        &gAnchor.ulDNTConfig,
                        sizeof( gAnchor.ulDNTConfig ),
                        NULL) ) )
        {
            leave;
        }

        // Now the root domain container.  Note that in the case of the
        // non-root domain and non-GC, this is a phantom and phantoms
        // don't have ATT_OBJ_DIST_NAMEs.  But they should have GUIDs
        // and (optionally) SIDs (at least replicated in phantoms do)
        // so just grab those.

        dwTmp = DBFindDSName(pDB, gAnchor.pRootDomainDN);

        if ( (0 != dwTmp) && (DIRERR_NOT_AN_OBJECT != dwTmp) )
            leave;

        pTmp = (UCHAR *) &gAnchor.pRootDomainDN->Guid;

        if ( 0 != DBGetAttVal(
                pDB,
                1,                      // get one value
                ATT_OBJECT_GUID,
                DBGETATTVAL_fCONSTANT,  // providing our own buffer
                sizeof(GUID),           // buffer size
                &len,                   // buffer used
                (UCHAR **) &pTmp) )
        {
            leave;
        }


        //
        // During the install phase in which we have created a new domain
        // object, and are re-initializing ourselves so SAM can place all of its
        // principals in the ds, including the domain sid, the domain object
        // will not yet have a sid. So just do the following in the running case
        //
        if ( DsaIsRunning() && gfRunningInsideLsa ) {

            pTmp = (UCHAR *) &gAnchor.pRootDomainDN->Sid;

            if ( 0 != DBGetAttVal(
                    pDB,
                    1,                                  // get one value
                    ATT_OBJECT_SID,
                    DBGETATTVAL_fCONSTANT,              // providing our own buffer
                    sizeof(gAnchor.pRootDomainDN->Sid), // buffer size
                    &gAnchor.pRootDomainDN->SidLen,     // buffer used
                    &pTmp) )
            {
                leave;
            }
        }

        // Now the Partitions container.

        if ( 0 != DBFindDSName(pDB, gAnchor.pPartitionsDN) )
            leave;

        if ( 0 != DBGetAttVal(
                    pDB,
                    1,                      // get one value
                    ATT_OBJ_DIST_NAME,
                    DBGETATTVAL_fCONSTANT,  // providing our own buffer
                    gAnchor.pPartitionsDN->structLen,      // buffer size
                    &len,                   // buffer used
                    (UCHAR **) &gAnchor.pPartitionsDN) )
        {
            leave;
        }

        // And lastly the Directory Service object.
        if (err = DBFindDSName(pDB, gAnchor.pDsSvcConfigDN)) {
            // it's ok, we will be able to continue without this object, just log an event
            DPRINT2(0, "DS Service object %ws is not found. Err=%d\n", 
                    gAnchor.pDsSvcConfigDN->StringName, err);
            LogEvent(
                DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_DS_SERVICE_CONFIG_NOT_FOUND,
                szInsertDN(gAnchor.pDsSvcConfigDN),
                szInsertWin32ErrCode(err),
                szInsertWin32Msg(err)
                );
            free(gAnchor.pDsSvcConfigDN);
            gAnchor.pDsSvcConfigDN = NULL;
        }
        else {
            if ( 0 != DBGetAttVal(
                        pDB,
                        1,                      // get one value
                        ATT_OBJ_DIST_NAME,
                        DBGETATTVAL_fCONSTANT,  // providing our own buffer
                        gAnchor.pDsSvcConfigDN->structLen,      // buffer size
                        &len,                   // buffer used
                        (UCHAR **) &gAnchor.pDsSvcConfigDN) )
            {
                leave;
            }
        }

        // The Exchange Service object (may not exist in the DIT).
        gAnchor.pExchangeDN = mdGetExchangeDNForAnchor(pTHS, pDB);

        err = 0;
    }
    __finally
    {
         DBClose(pDB, FALSE);
    }

    if ( err )
    {
        free(gAnchor.pConfigDN);
        free(gAnchor.pRootDomainDN);
        free(gAnchor.pPartitionsDN);
        if (gAnchor.pDsSvcConfigDN) {
            free(gAnchor.pDsSvcConfigDN);
        }
        gAnchor.pConfigDN = NULL;
        gAnchor.pRootDomainDN = NULL;
        gAnchor.pPartitionsDN = NULL;
        gAnchor.pDsSvcConfigDN = NULL;
    }

    return(err);
}

PDSNAME
mdGetExchangeDNForAnchor (
        THSTATE  *pTHS,
        DBPOS    *pDB
        )
/*++
    Description:
       Look under the services container for a single exchange config object.
       If there is 1 and only 1, return its DN in malloced memory.  If there is
       none, or more than one, return NULL.

    Parameters:
       pTHS - The thread state
       pDB  - DBPos to use.  May be pTHS->pDB, but doesn't have to be.
--*/
{
    PDSNAME   pServices;
    PDSNAME   pObj = NULL;
    ULONG     objlen = 0;
    ATTRTYP   objClass = CLASS_MS_EXCH_CONFIGURATION_CONTAINER;
    FILTER    ClassFil;
    RESOBJ   *pResObj = NULL;
    FILTER   *pInternalFilter = NULL;
    ATTCACHE *pACobj;
    PDSNAME   retVal = NULL;

    if(!gAnchor.pDsSvcConfigDN) {
        return NULL;
    }

    pServices=THAllocEx(pTHS, gAnchor.pDsSvcConfigDN->structLen);

    TrimDSNameBy(gAnchor.pDsSvcConfigDN, 2, pServices);


    // First, find the services container.  It is a parent
    if( DBFindDSName(pDB, pServices)) {
        THFreeEx(pTHS, pServices);
        return NULL;
    }

    // Set up filter struct to find objects of the correct class.
    memset (&ClassFil, 0, sizeof (ClassFil));
    ClassFil.pNextFilter = NULL;
    ClassFil.choice = FILTER_CHOICE_ITEM;
    ClassFil.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ClassFil.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ClassFil.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(objClass);
    ClassFil.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR)&objClass;
    ClassFil.FilterTypes.Item.FilTypes.pbSkip = NULL;

    pResObj = CreateResObj(pDB, pServices);

    pInternalFilter = NULL;
    if (DBMakeFilterInternal(pDB, &ClassFil, &pInternalFilter, NULL) != ERROR_SUCCESS) {
        return NULL;
    }
    DBSetFilter(pDB, pInternalFilter,NULL, NULL,0,NULL);
    DBSetSearchScope(pDB, SE_CHOICE_IMMED_CHLDRN, FALSE, pResObj);
    DBChooseIndex(pDB, 0,0,0, SORT_NEVER, DBCHOOSEINDEX_fUSEFILTER, 0xFFFFFFFF);

    pACobj = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);

    DPRINT(2,"Looking for the exchange config obj.\n");

    if(DBGetNextSearchObject(pDB, 0, 0, DB_SEARCH_FORWARD | DB_SEARCH_DONT_EVALUATE_SECURITY)) {
        // No exchange config object.
        THFreeEx(pTHS, pServices);
        THFreeEx(pTHS, pResObj);
        return NULL;
    }

    // At least one exchange config object.
    if (0 != DBGetAttVal_AC(pDB,
                            1,
                            pACobj,
                            DBGETATTVAL_fREALLOC,
                            objlen,
                            &objlen,
                            (UCHAR **) &pObj)) {
        Assert(!"Could not read DN off the object")
        THFreeEx(pTHS, pServices);
        THFreeEx(pTHS, pResObj);
        return NULL;
    }

    if(DBGetNextSearchObject(pDB, 0, 0, DB_SEARCH_FORWARD | DB_SEARCH_DONT_EVALUATE_SECURITY)) {
        // Only one exchange config object.
        retVal = malloc(pObj->structLen);
        if(retVal) {
            memcpy(retVal, pObj, pObj->structLen);
        }
        else {
            MemoryPanic(pObj->structLen);
        }
    }
    else {
        // complain about more than one exchange config object.
        LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_TOO_MANY_MSEXCHCONFIGURATIONCONTAINER,
			NULL,
			NULL,
			NULL
			);
    }

    THFreeEx(pTHS, pObj);
    THFreeEx(pTHS, pServices);
    THFreeEx(pTHS, pResObj);
    return retVal;
}


/*
    Find the DNT of the system cotainer.  
*/

void 
GetSystemDNT(){

    DBPOS *pDB=NULL;
    DWORD DNT;

    gAnchor.ulDNTSystem = INVALIDDNT;

    //
    // Bail quickly if we are installing
    //
    if ((NULL==gAnchor.pConfigDN )
         || (DsaIsInstalling()))
    {
        return;
    }


    DBOpen(&pDB);
    __try {
        // First, find the domain object.
        DBFindDNT(pDB, gAnchor.ulDNTDomain);

        // Now, get the DNT of the system container
        if(GetWellKnownDNT(pDB,
                           (GUID *)GUID_SYSTEMS_CONTAINER_BYTE,
                           &DNT)) { 
            
            gAnchor.ulDNTSystem = DNT;
        }
    }
    __finally {
       DBClose(pDB, TRUE);
    }
    
    return;
}


int
DeriveInfrastructureDN(
        THSTATE *pTHS
        )
/*--
  Description:
      Find the DN of the Infrastructure Object by looking in the
      well-known-objects attribute of the domain object.  Put the DN in the
      anchor.

  Return:
     0 on success, an error code otherwise.

--*/
{
    DSNAME *pVal=NULL;
    DWORD len=0;
    BOOL fCommit=FALSE;
    DBPOS *pDB=NULL;
    DWORD DNT;
    DWORD err = ERROR_DS_UNKNOWN_ERROR;

    gAnchor.pInfraStructureDN = NULL;

    //
    // Bail quickly if we are installing
    //
    if ((NULL==gAnchor.pConfigDN )
         || (DsaIsInstalling()))
    {
        return 0;
    }


    DBOpen(&pDB);
    __try {
        // First, find the domain object.
        DBFindDNT(pDB, gAnchor.ulDNTDomain);

        // Now, get the DNT of the
        if(GetWellKnownDNT(pDB,
                           (GUID *)GUID_INFRASTRUCTURE_CONTAINER_BYTE,
                           &DNT) &&
           DNT != INVALIDDNT) {
            // OK,
            DBFindDNT(pDB, DNT);
            err = DBGetAttVal(
                    pDB,
                    1,                      // get one value
                    ATT_OBJ_DIST_NAME,
                    0,
                    0,
                    &len,
                    (PUCHAR *)&pVal);
            if(err) {
                __leave;
            }

            gAnchor.pInfraStructureDN = (DSNAME *)malloc(len);
            if(!gAnchor.pInfraStructureDN) {
                err = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            else {
                memcpy(gAnchor.pInfraStructureDN, pVal, len);
            }
        }
        else {
            err = ERROR_DS_MISSING_EXPECTED_ATT;
            __leave;
        }
        fCommit = TRUE;
    }
    __finally {
        THFreeEx(pTHS, pVal);
        DBClose(pDB, fCommit);
    }


    // Actually, don't return an error if we simply couldn't find the value.
    // This means that we will silently ignore not having one of these; other
    // parts of the code have to deal with a NULL pInfraStructureDN;
    if(err == ERROR_DS_MISSING_EXPECTED_ATT) {
        err = 0;
    }

    return err;
}


int
DeriveDomainDN(void)

/*++

Description:

    Derive DSNAME of the locally hosted domain and place it in gAnchor.

Arguments:

    None

Return Value:

    0 on success, !0 otherwise.

--*/

{
    int                 cDomain;
    DSNAME              *pDomain;
    NAMING_CONTEXT_LIST *pNCL;
    unsigned            cConfigParts;
    unsigned            cParts;
    DSNAME              *pTmpObj = NULL;
    DWORD                err=0;
    DBPOS               *pDB;
    COMMARG              CommArg;
    CROSS_REF           *pCR;
    CROSS_REF_LIST      *pCRL;
    NCL_ENUMERATOR      nclEnum;

    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    pNCL = NCLEnumeratorGetNext(&nclEnum);
    // We have a list of master NCs with at least one value
    Assert(pNCL);
    
    if ( NULL == NCLEnumeratorGetNext(&nclEnum) )
    {
        // During install we have only one NC, so just use that.
        pDomain = pNCL->pNC;
    }
    else
    {
        // In product 2, every DC hosts 1 domain NC, 1 config NC, 1 schema
        // NC, and 0 or more Non-Domain NCs.  Assuming gAnchor.pConfigDN
        // is known, we can derive the domain DN by noting that the
        // schema container is an immediate child of the domain DN and
        // the domain DN is never a child of the configuration container,
        // and all NDNCs (Non-Domain NCs) don't have the FLAG_CR_NTDS_DOMAIN
        // flag set on the cross-ref.

        Assert(NULL != gAnchor.pConfigDN);

        cDomain = 0;
        pDomain = NULL;

        if ( 0 != CountNameParts(gAnchor.pConfigDN, &cConfigParts) )
            return(1);

        pCRL = gAnchor.pCRL;
        while ( pCRL != NULL){
            if(pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN){
                NCLEnumeratorReset(&nclEnum);
                NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, pCRL->CR.pNC);
                if (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
                    // Got the NC (pNCL) for this cross ref (pCRL).
    
                    // Note in Whistler/Win2k+1 release, there is
                    // one domain per DC.
                    cDomain++;

                    Assert(pDomain == NULL);
                    pDomain = pNCL->pNC;
                }
            } // if CR is NTDS_DOMAIN
            pCRL = pCRL->pNextCR;
        } // end while more CR's to look at.
        
        Assert(1 == cDomain); // Designed this to break when people add multiple
        // domains ... but this will be the least of that person's worries ;)
    }

    Assert(NULL != pDomain);
    Assert(!fNullUuid(&pDomain->Guid));

    if (!pDomain) {
        return 2;
    }

    gAnchor.pDomainDN = malloc(pDomain->structLen);

    if ( NULL == gAnchor.pDomainDN )
    {
        MemoryPanic(pDomain->structLen);
        return(1);
    }

    memcpy(gAnchor.pDomainDN, pDomain, pDomain->structLen);

    // Read in the DNT of the Domain Object into gAnchor
    __try
    {
        DBOpen(&pDB);

        if (0 != DBFindDSName( pDB, pDomain))
        {
            LogEvent(
                DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_DSA_OBJ,
                NULL,
                NULL,
                NULL
                );
            err =  DIRERR_CANT_FIND_DSA_OBJ;
        }
        else
        {
            gAnchor.ulDNTDomain = pDB->DNT;
        }
    }
    __finally
    {
        DBClose(pDB,TRUE);
    }

    // Find the CrossRef object for our domain and keep people from deleting it
    InitCommarg(&CommArg);
    pCR = FindExactCrossRef(pDomain, &CommArg);
    if (pCR) {
        DirProtectEntry(pCR->pObj);
    }

    // NTRAID#NTRAID-580234-2002/03/18-andygo:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
    // REVIEW:  CHECK_FOR_ADMINISTRATOR_LOSS is dead code
    //  On October 22 1997, the NTWSTA Self Host Domain
    //  lost all builtin group memberships. To track the
    //  problem down if it happens again, have a hard coded
    //  check for Administrator being removed from Administrators
    //  The check works by reading in the DNT of Administrators
    //  and the DNT of Administrator at boot time, and then
    //  checking for them in DBRemoveLinkVal
    //
#ifdef CHECK_FOR_ADMINISTRATOR_LOSS

    //
    // Read in DNT of the Administrators and Administrator
    //

    DBGetAdministratorAndAdministratorsDNT();

#endif



    return(0);
}

int
DeriveSiteDNFromDSADN(
    IN  DSNAME *    pDSADN,
    OUT DSNAME **   ppSiteDN,
    OUT ULONG  *    pSiteDNT,
    OUT ULONG  *    pOptions
    )
/*++

Routine Description:

    Derive the SiteDN, SiteDNT and grab Ntds Site Settings/Options for the given DSADN

Arguments:

    pDSADN (IN) - The DSNAME of the local ntdsDsa object.

    ppSiteDN (OUT) - On successful return, holds the DSNAME of the site
        containing the local ntdsDsa object.
        
    pSiteDNT (OUT) - the DNT of the site
    
    pOptions (OUT) - the options attribute of the Ntds Site Settings corresponding to the site

Return Values:

    0 on success, non-zero on failure.

--*/
{
    THSTATE *pTHS = pTHStls;
    int       err;
    DBPOS *   pDBTmp;
    DSNAME *  pSiteDN;
    DSNAME  *pSiteSettingsDN = NULL;
    WCHAR    SiteSettingsCN[] = L"Ntds Site Settings";
    ULONG    Options = 0;
    ULONG    SiteDNT = 0;

    pSiteDN = malloc(pDSADN->structLen);
    if (NULL == pSiteDN) {
        MemoryPanic(pDSADN->structLen);
        return ERROR_OUTOFMEMORY;
    }

    // Trim off CN=NTDS Settings,CN=ServerName,CN=Servers.
    if (TrimDSNameBy(pDSADN, 3, pSiteDN)) {
        // Couldn't trim that many -- pDSADN must be CN=BootMachine,O=Boot.
        // We'll call O=Boot the site name, for lack of a better idea.
        Assert(DsaIsInstalling());
        if (TrimDSNameBy(pDSADN, 1, pSiteDN)) {
            Assert(!"Bad DSA DN!");
            free (pSiteDN);
            return ERROR_DS_INTERNAL_FAILURE;
        }
    } else {

        // Determine the Ntds Site Settings DN
        ULONG size = 0;

        size = AppendRDN(pSiteDN,
                         pSiteSettingsDN,
                         size,
                         SiteSettingsCN,
                         0,
                         ATT_COMMON_NAME
                         );

        pSiteSettingsDN = THAllocEx(pTHS,size);
        pSiteSettingsDN->structLen = size;
        AppendRDN(pSiteDN,
                  pSiteSettingsDN,
                  size,
                  SiteSettingsCN,
                  0,
                  ATT_COMMON_NAME
                  );
    }

    *pOptions = 0;

    DBOpen(&pDBTmp);
    __try {

        err = DBFindDSName(pDBTmp, pSiteDN);
        if (err) {
            __leave;
        }

        // get site DNT
        SiteDNT = pDBTmp->DNT;

        // grab the GUID
        err = DBGetSingleValue(pDBTmp, ATT_OBJECT_GUID, &pSiteDN->Guid,
                               sizeof(GUID), NULL);
        if (err) {
            __leave;
        }

        //
        // Get the Ntds Site Settings for this site
        //

        if (pSiteSettingsDN) {

            err = DBFindDSName(pDBTmp, pSiteSettingsDN);
            if (err) {
                // can't read site settings object
                // use defaults.
                err = 0;
                Options = 0;

                //
                // BUGBUG: report event about missing/inconsistent
                // ntds site settings
                //
                DPRINT2(0, "DeriveSiteDNFromDSADN: Missing SiteSettings %ws (error %lu)\n",
                           pSiteSettingsDN->StringName, err);
            }
            else {
                //
                // Get options off site settings
                //
                err = DBGetSingleValue(pDBTmp, ATT_OPTIONS, &Options,
                                       sizeof(ULONG), NULL);
                if (err) {
                    // doesn't exist?  that's ok
                    err = 0;
                    Options = 0;
                }
            }               // end-else
        }                   // pSiteSettingsDN
    }                       // try
    __finally {
        DBClose(pDBTmp, TRUE);

        if (pSiteSettingsDN) THFreeEx(pTHS,pSiteSettingsDN);
        if (AbnormalTermination()) {
            free(pSiteDN);
        }
    }

    if (!err) {
        *ppSiteDN = pSiteDN;
        *pSiteDNT = SiteDNT;
        *pOptions = Options;
    }
    else {
        free(pSiteDN);
    }
    
    return err;
}

int
DeriveComputerDN(
    THSTATE *pTHS,
    DSNAME **ppComputerDN
    )
/*--
  Description:
      Find the DN of the computer object by getting the name of the computer
      and looking for its object in the sam index.

      This routine allocates using malloc since the memory it initializes is to
      be kept in the anchor for the system lifetime.

      This routine may fail if the computer account does not exist.

  Return:
     0 on success, an error code otherwise.

--*/
{
    DBPOS *pDB=NULL;
    int       err = 0;
    DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH+1;
    WCHAR *wComputerName=NULL;
    DSNAME *pComputerDN = NULL;
    DWORD cbComputerDN = 0;

    //
    // Bail quickly if we are installing
    //
    if (DsaIsInstalling())
    {
        *ppComputerDN = NULL;
        return 0;
    }

    // This logic for finding the computer object is the same as that done in
    // servinfo.c.  Note that someday we might have to deal with the fact that
    // the computer name can change dynamically.

    // Allocate temp storage for the computer name
    wComputerName = THAllocEx( pTHS,cchComputerName*sizeof(WCHAR));

    if(!GetComputerNameExW(ComputerNamePhysicalNetBIOS, &wComputerName[0], &cchComputerName)) {
        err = GetLastError();
        DPRINT1(0,"GetComputerNameW failed with error %d\n", err );
        goto cleanup;
    }

    DBOpen(&pDB);
    __try {

        // find the computer object of this DC;
            
        if(err = DBFindComputerObj(pDB,
                                   cchComputerName,
                                   wComputerName)) {
            DPRINT1(0, "Can't find computer object for %ws\n", wComputerName );
            __leave;
        }

        err = DBGetAttVal(
            pDB,
            1,                      // get one value
            ATT_OBJ_DIST_NAME,
            0,
            0,
            &cbComputerDN,
            (PUCHAR *)&pComputerDN);
        if(err) {
            __leave;
        }
        Assert( pComputerDN->structLen == cbComputerDN );
    }
    __finally {
        // read-only transaction. Faster to commit.
        DBClose(pDB, !AbnormalTermination() && err == ERROR_SUCCESS); 
    }

    if (!err) {
        *ppComputerDN = malloc(pComputerDN->structLen);
        if ( NULL == *ppComputerDN )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        memcpy(*ppComputerDN, pComputerDN, pComputerDN->structLen);
    }

 cleanup:
    if (wComputerName) {
        THFreeEx( pTHS, wComputerName );
    }
    if (pComputerDN) {
        THFreeEx( pTHS, pComputerDN );
    }

    return err;
}

int
UpdateMtxAddress( void )
/*++

Routine Description:

    Derive the network address of the local DSA and set gAnchor.pmtxDSA
    appropriately.  The derived name is of the form

    c330a94f-e814-11d0-8207-a69f0923a217._msdcs.CLIFFVDOM.NTDEV.MICROSOFT.COM

    where "CLIFFVDOM.NTDEV.MICROSOFT.COM" is the DNS name of the root domain of
    the DS enterprise (not necessarily the DNS name of the _local_ domain) and
    "c330a94f-e814-11d0-8207-a69f0923a217" is the stringized of the local
    invocation ID (which is the same as the object GUID of the NTDS-DSA object
    corresponding to the local DSA when installation is complete).

Arguments:

    None.

Return Values:

    0 on success, non-zero on failure.

--*/
{
    MTX_ADDR *  pmtxTemp;
    MTX_ADDR *  pmtxDSA;
    THSTATE  *  pTHS=pTHStls;
    DWORD       cb;

    if (NULL == gAnchor.pwszRootDomainDnsName) {
        // We don't have the root domain DNS name at install time, so we cannot
        // construct our DNS-based MTX address.
        return 0;
    }

    Assert(NULL != gAnchor.pDSADN);
    Assert(!fNullUuid(&gAnchor.pDSADN->Guid));

    pmtxTemp = draGetTransportAddress(NULL, gAnchor.pDSADN, ATT_DNS_HOST_NAME);
    if (NULL == pmtxTemp) {
        Assert( !"Cannot derive own DSA address!" );
        return -1;
    }

    // pmtxTemp is allocated off the thread heap; re-allocate it to the malloc()
    // heap.

    cb = MTX_TSIZE(pmtxTemp);
    pmtxDSA = (MTX_ADDR *) malloc(cb);

    if (NULL == pmtxDSA) {
        MemoryPanic(cb);
        return -1;
    }

    memcpy(pmtxDSA, pmtxTemp, cb);
    THFree(pmtxTemp);

    // Update the anchor.
    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {
        if (NULL != gAnchor.pmtxDSA) {
            DELAYED_FREE(gAnchor.pmtxDSA);
        }

        gAnchor.pmtxDSA = pmtxDSA;
    }
    __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }

    return 0;
}

DWORD
UpdateNonGCAnchorFromDsaOptions(
    BOOL fInStartup
    )

/*++

Routine Description:

This routine is responsible for updating the Non-GC related parts of the anchor.

Arguments:

    fInStartup - Whether we are being called at startup, or as a result of a
                 dsa object modification later in system life.

Return Value:

    int -

--*/

{
    DBPOS *     pDB = NULL;
    DWORD       err;
    DWORD       dwOptions;
    DWORD       cbOptions;
    DWORD *     pdwOptions = &dwOptions;
    NTSTATUS    ntStatus;
    THSTATE    *pTHS=pTHStls;
    DWORD       dwReplEpoch;

    DBOpen( &pDB );
    err = DIRERR_INTERNAL_FAILURE;

    __try
    {
        // PREFIX: dereferencing NULL pointer 'pDB' 
        //         DBOpen returns non-NULL pDB or throws an exception
        if ( 0 != DBFindDSName( pDB, gAnchor.pDSADN ) )
        {
            LogEvent(
                DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_DSA_OBJ,
                NULL,
                NULL,
                NULL
                );

            err = DIRERR_CANT_FIND_DSA_OBJ;
        }
        else
        {
            if ( 0 != DBGetAttVal(
                        pDB,
                        1,                      // get one value
                        ATT_OPTIONS,
                        DBGETATTVAL_fCONSTANT,  // providing our own buffer
                        sizeof( dwOptions ),    // buffer size
                        &cbOptions,             // buffer used
                        (unsigned char **) &pdwOptions
                        )
               )
            {
                // 'salright -- no options set
                dwOptions = 0;
            }

            // log event if we're switching inbound periodic repl on or off
            if (0 != DBGetSingleValue(pDB, ATT_MS_DS_REPLICATIONEPOCH,
                                      &dwReplEpoch, sizeof(dwReplEpoch), NULL))
            {
                // 'salright -- assume default value of 0.
                dwReplEpoch = 0;
            }

            // [wlees] Always log if startup and disabled. We want to know!
            if ( ( fInStartup && ( dwOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL ) ) ||
                 ( !!( gAnchor.fDisableInboundRepl ) != !!( dwOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL ) ) )
            {
                LogEvent(
                    DS_EVENT_CAT_REPLICATION,
                    DS_EVENT_SEV_ALWAYS,
                    ( dwOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL )
                        ? DIRLOG_DRA_DISABLED_INBOUND_REPL
                        : DIRLOG_DRA_REENABLED_INBOUND_REPL,
                    NULL,
                    NULL,
                    NULL
                    );

                DPRINT1(
                    0,
                    "Inbound replication is %s.\n",
                    (   ( dwOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL )
                      ? "disabled"
                      : "re-enabled"
                    )
                    );
            }

            // log event if we're switching outbound repl on or off
            // [wlees] Always log if startup and disabled. We want to know!
            if ( ( fInStartup && ( dwOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL ) ) ||
                 ( !!( gAnchor.fDisableOutboundRepl ) != !!( dwOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL ) ) )
            {
                LogEvent(
                    DS_EVENT_CAT_REPLICATION,
                    DS_EVENT_SEV_ALWAYS,
                    ( dwOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL )
                        ? DIRLOG_DRA_DISABLED_OUTBOUND_REPL
                        : DIRLOG_DRA_REENABLED_OUTBOUND_REPL,
                    NULL,
                    NULL,
                    NULL
                    );

                DPRINT1(
                    0,
                    "Outbound replication is %s.\n",
                    (   ( dwOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL )
                      ? "disabled"
                      : "re-enabled"
                    )
                    );
            }

            // Log event if not startup/install and we're changing the replication epoch.
            if (!fInStartup
                && !DsaIsInstalling()
                && (dwReplEpoch != gAnchor.pLocalDRSExtensions->dwReplEpoch)) {
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_REPL_EPOCH_CHANGED,
                         szInsertDN(gAnchor.pDSADN),
                         szInsertUL(gAnchor.pLocalDRSExtensions->dwReplEpoch),
                         szInsertUL(dwReplEpoch));
            }

            //
            // update the anchor with the selected options
            //

            EnterCriticalSection( &gAnchor.CSUpdate );
            gAnchor.fDisableInboundRepl  = !!( dwOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL );
            gAnchor.fDisableOutboundRepl = !!( dwOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL );
            gAnchor.pLocalDRSExtensions->dwReplEpoch = dwReplEpoch;
            LeaveCriticalSection( &gAnchor.CSUpdate );

            // success
            err = 0;
        }
    }
    __finally
    {
        // read-only transaction. Faster to commit.
        DBClose( pDB, !AbnormalTermination() && err == ERROR_SUCCESS );
    }

    return err;
}

DWORD
UpdateGCAnchorFromDsaOptions( BOOL fInStartup )

/*++

Routine Description:

This routine is responsible for updating the GC related parts of the anchor.

This routine is usually not called directly, but is called from
UpdateGCAnchorFromDsaOptionsDelayed or its task queue entry
CheckGCPromotionProgress.

Arguments:

    fInStartup - Whether we are being called at startup, or as a result of a
                 dsa object modification later in system life.

Return Value:

    int -

--*/

{
    DBPOS *     pDB = NULL;
    DWORD       err = ERROR_SUCCESS;
    DWORD       dwOptions;
    DWORD       cbOptions;
    DWORD *     pdwOptions = &dwOptions;
    NTSTATUS    ntStatus;
    BOOL        fOldGC;
    THSTATE    *pTHS=pTHStls;
    DWORD   len = 0;

    //from msrpc.c
    extern VOID InitRPCInterface( RPC_IF_HANDLE hServerIf );

    DBOpen( &pDB );

    __try
    {
        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        if ( 0 != DBFindDSName( pDB, gAnchor.pDSADN ) )
        {
            LogEvent(
                DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_DSA_OBJ,
                NULL,
                NULL,
                NULL
                );

            err = DIRERR_CANT_FIND_DSA_OBJ;
            // fatal: How can we not find our own dsa dn?
            __leave;
        }

        if ( 0 != DBGetAttVal(
                    pDB,
                    1,                      // get one value
                    ATT_OPTIONS,
                    DBGETATTVAL_fCONSTANT,  // providing our own buffer
                    sizeof( dwOptions ),    // buffer size
                    &cbOptions,             // buffer used
                    (unsigned char **) &pdwOptions
                    )
           )
        {
            // 'salright -- no options set
            dwOptions = 0;
        }

        // log/notify netlogon of GC status
        if (    fInStartup
             || (    !!( gAnchor.fAmGC )
                  != !!( dwOptions & NTDSDSA_OPT_IS_GC )
                )
           )
        {
            if ( !fInStartup )
            {
                LogEvent(
                    DS_EVENT_CAT_GLOBAL_CATALOG,
                    DS_EVENT_SEV_ALWAYS,
                    ( dwOptions & NTDSDSA_OPT_IS_GC )
                        ? DIRLOG_GC_PROMOTED
                        : DIRLOG_GC_DEMOTED,
                    NULL,
                    NULL,
                    NULL
                    );

                if ( dwOptions & NTDSDSA_OPT_IS_GC )
                {
                    DPRINT( 0, "Local DSA has been promoted to a GC.\n" );
                }
                else
                {
                    DPRINT( 0, "Local DSA has been demoted to a non-GC.\n" );
                }
            }

            // notify netlogon
            __try {
                ntStatus = dsI_NetLogonSetServiceBits(
                           DS_GC_FLAG,
                           ( dwOptions & NTDSDSA_OPT_IS_GC )
                                                    ? DS_GC_FLAG
                                                    : 0
                           );
            } __except (HandleAllExceptions(GetExceptionCode())) {
                ntStatus = STATUS_UNSUCCESSFUL;
            }

            if ( !NT_SUCCESS( ntStatus ) )
            {
                // we'll notify debugger/log about the failure,
                // but don't fail promotion/demotion
                // because of this - just spew/log this and continue.  the 
		// user can reboot later to attempt the netlogon call again.
                DPRINT1(0, "dsI_NetLogonSetServiceBits() returned 0x%X!\n",
                        ntStatus );
		LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
			 DS_EVENT_SEV_ALWAYS,
			 DIRLOG_GC_NETLOGON_NOTIFICATION_FAILURE,
			 szInsertWin32Msg(RtlNtStatusToDosError(ntStatus)),
			 szInsertUL(RtlNtStatusToDosError(ntStatus)),
			 NULL
			 );
		// BUGBUG - should retry this notification later rather
		// than having the user reboot.
            }
        }

        //
        // update the anchor with the selected options
        // If we switch to becoming a GC, we need to startup the LDAP
        // GC port.

        fOldGC = gAnchor.fAmGC;

        // ResetVirtualGcStatus can not except, so no need for try/finally
        EnterCriticalSection( &gAnchor.CSUpdate );
        gAnchor.fAmGC = !!( dwOptions & NTDSDSA_OPT_IS_GC );
        ResetVirtualGcStatus();
        LeaveCriticalSection( &gAnchor.CSUpdate );

        // Following call acquires gcsFindGC and therefore doesn't
        // need to be inside of the gAnchor.CSUpdate lock above.

        InvalidateGCUnilaterally();

        if ( fOldGC ) {
            // Was a GC before
            if ( !gAnchor.fAmGC ) {
                //
                // Demotion. Used to be a GC, not anymore.
                //

                // Change of GC-ness affects the topology
                // Request the KCC to run when transaction commits
                pTHS->fExecuteKccOnCommit = TRUE;

                //
                // We stopped being a GC
                //

                gfWasPreviouslyPromotedGC = FALSE;
                SetConfigParam( GC_PROMOTION_COMPLETE, REG_DWORD,
                                &gfWasPreviouslyPromotedGC,
                                sizeof( BOOL ) );

                LdapStopGCPort( );


                //
                // If there's an outstanding task in the queue
                // get rid of it.
                //
                (void)CancelTask(TQ_CheckGCPromotionProgress, NULL);

                //disable NSPI, unless registry indicates otherwise
                DsStartOrStopNspisInterface();
                
            }
        } else {
            // Wasn't a GC before.

            if ( gAnchor.fAmGC ) {
                //
                // We are now a GC whereas we were'nt before
                //

                gfWasPreviouslyPromotedGC = TRUE;
                SetConfigParam( GC_PROMOTION_COMPLETE, REG_DWORD,
                                &gfWasPreviouslyPromotedGC,
                                sizeof( BOOL ) );

                LdapStartGCPort( );

                //activate NSPI if it is not activated already
                //this is only necessary when GC status is changed at runtime
                //and we should ingore this when startup
                if ( !fInStartup ) {
                    DsStartOrStopNspisInterface();
                } // if ( !fInStartup )
            }     // if ( gAnchor.fAmGC )
        }         // else wasn't a GC.

        Assert(err == ERROR_SUCCESS);
    }
    __finally
    {
        // read-only transaction, faster to commit
        DBClose( pDB, !AbnormalTermination() && err == ERROR_SUCCESS );
    }

    return err;
}

DWORD
UpdateGCAnchorFromDsaOptionsDelayed(
    BOOL fInStartup
    )

/*++

Routine Description:

I have divided the original UpdateAnchorFromDsaOptions into GC and non-GC
related parts.  See the above routines UpdateGcAnchor and UpdateNonGCAnchor.
The non-GC part is done as it was previously, being called from
InitDSAInfo and ModLocalDsaObj.  The new UpdateGCAnchor is called from this
wrapper.

This routine is a wrapper around UpdateAnchorFromDsaOptions(). It determines if
a GC promotion is requested.  If so, it starts a verification process to see if
all the readonly ncs are here and synced atleast once.  If not, a task queue
function requeues to continue the verification later.  Once the criteria is met,
the real UpdateAnchorFromDsaOptions is called.  If a GC promotion was not the reason
that this routine was called, we call UpdateAnchorFromDsaOptions immediately.

If the user does not want the verification feature, he can set a registry parameter
to disable it.  If we see that the check is disabled, we call UpdateAnchor
immmediately without doing the verification process.  The verification task queue
entry will also complete immediately (when it runs again) if it later finds the
registry key to have been set.

A piece of global state is used to track whether we have a GC promotion verification
task queue entry in the queue.  The global is gfDelayedGCPromotionPending.  We
use this state to prevent queuing more than one task entry in the case of a
promotion, demotion, promotion in rapid succession.  If we promote and then demote
rapidly, the entry is left in the queue (because we have no cancel function). When
the entry executes, it checks whether it still needs to do its work.  In this
case it will not be needed, so it will exit without doing anything.


Arguments:

    fInStartup - Whether we are being called at startup, or as a result of a
                 dsa object modification later in system life.

Return Value:

    DWORD - error in DIRERR error space

--*/

{
    DBPOS *     pDB = NULL;
    DWORD       err = ERROR_SUCCESS;
    DWORD       dwOptions;
    DWORD       cbOptions;
    DWORD *     pdwOptions = &dwOptions;
    DWORD       dwQDelay = 0;
    THSTATE    *pTHS=pTHStls;

    DPRINT1( 1, "UpdateGCAnchorFromDsaOptionsDelayed( %d )\n", fInStartup );

    EnterCriticalSection(&csGCState);

    __try {
        DBOpen( &pDB );

        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        if ( 0 != DBFindDSName( pDB, gAnchor.pDSADN ) )
            {
            LogEvent(
                DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_CANT_FIND_DSA_OBJ,
                NULL,
                NULL,
                NULL
                );

            err = DIRERR_CANT_FIND_DSA_OBJ;
            // fatal enough to leave right away
            __leave;
        }

        if ( 0 != DBGetAttVal(
            pDB,
            1,                      // get one value
            ATT_OPTIONS,
            DBGETATTVAL_fCONSTANT,  // providing our own buffer
            sizeof( dwOptions ),    // buffer size
            &cbOptions,             // buffer used
            (unsigned char **) &pdwOptions
            )
             )
            {
            // 'salright -- no options set
            dwOptions = 0;
        }

        // Cases:
        // 1. Startup. System may (a) or may not (b) be a GC.
        // 2. DSA options changed. System is entering (a) or leaving (b) being a GC
        if ( (!(gAnchor.fAmGC)) && ( dwOptions & NTDSDSA_OPT_IS_GC ) ) {
            //
            // System is becoming a GC.
            //

            if ( !fInStartup ) {
                //
                // Online promotion (i.e. not during startup load time)
                //  - Run KCC.
                //  - Delay promotion task to give replicas time to arrive.
                //  - Notify user via event log on the delay.
                //

                pTHS->fExecuteKccOnCommit = TRUE;
                dwQDelay = GC_PROMOTION_INITIAL_CHECK_PERIOD_MINS * 60;
                DPRINT1(0, "GC Promotion being delayed for %d minutes.\n ",
                        GC_PROMOTION_INITIAL_CHECK_PERIOD_MINS );
                LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_GC_PROMOTION_DELAYED,
                         szInsertUL(GC_PROMOTION_INITIAL_CHECK_PERIOD_MINS),
                         NULL,
                         NULL);  
            }
            
            InsertInTaskQueueSilent(
                TQ_CheckGCPromotionProgress,
                UlongToPtr(fInStartup),
                dwQDelay, 
                FALSE       // don't re-schedule
                );

        } else {
            // 1b or 2b
            // Do startup and GC demotion actions here

            err = UpdateGCAnchorFromDsaOptions( fInStartup );
        }

    }
    __finally {
        if (pDB) {
            // read-only transaction. Faster to commit.
            DBCloseSafe( pDB, !AbnormalTermination() && err == ERROR_SUCCESS );
        }
        LeaveCriticalSection(&csGCState);
    }

    return err;
} /* UpdateAnchorFromDsaOptionsDelayed */


int
UpdateRootDomainDnsName(
    IN  WCHAR *pDnsName
    )
/*++

Routine Description:

    Cache the DNS name from the current Cross-Ref object as the DNS name of
    the root domain in gAnchor.

Arguments:

    pDnsName

Return Values:

    0 on success, !0 on failure.

--*/
{
    int     err;
    WCHAR   *pNewDnsName;
    DWORD   cb;

    if (NULL == pDnsName) {
        return ERROR_DS_MISSING_EXPECTED_ATT;
    }

    // This is the cross-ref for the root domain.
    // Take this opportunity to cache its DNS name.

    cb = (wcslen(pDnsName) + 1) * sizeof(WCHAR);
    if (NULL == (pNewDnsName = malloc(cb))) {
        MemoryPanic(cb);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(pNewDnsName, pDnsName, cb);

    // Update the anchor.
    EnterCriticalSection(&gAnchor.CSUpdate);
    gAnchor.pwszRootDomainDnsName = pNewDnsName;
    LeaveCriticalSection(&gAnchor.CSUpdate);

    return 0;
}

VOID
DsFreeServersAndSitesForNetLogon(
    SERVERSITEPAIR *         paServerSites
    )
{
    ULONG                    i=0;

    Assert(paServerSites);
    while(paServerSites[i].wszDnsServer || paServerSites[i].wszSite){
        if(paServerSites[i].wszDnsServer){
            LocalFree(paServerSites[i].wszDnsServer);
        }
        Assert(paServerSites[i].wszSite);
        if(paServerSites[i].wszSite){
            LocalFree(paServerSites[i].wszSite);
        }
        i++;
    }
    LocalFree(paServerSites);
}


void
FillHasMasterNCsFilters(
    DSNAME * pdnNC,
    FILTER * pHasNcFilter,
    FILTER * pNewHasNcFilter,
    FILTER * pOldHasNcFilter
    )
/*++

Routine Description:

    This function fills the three passed in FILTER objects to be an
    OR filter to get DSAs with both the new msDS-HasMasterNCs and 
    DSAs with the old (win2k) hasMasterNCs attribute.

Arguments:

    pdnNC (IN) - DN of NC to create the filters for.
    pHasNcFilter (IN/OUT) - This is the main filter, that the caller
        should link to, and should link in the pNextFilter of.  But
        note don't link into it's pNextFilter til after the function
        is called, because we zero memory the whole thing.
    pNewHasNcFilter (IN/OUT) - this gets the msDS-HasMasterNCs attr 
        filter.
    pOldHasNcFilter (IN/OUT) - this gets the old hasMasterNCs attr 
        filter.
    
    All of these filters should have been allocated bye the caller.

Return Value;

    None, always succeeds.

// NTRAID#NTBUG9-582921-2002/03/21-Brettsh - When win2k compatibility
// is not longer required, we can remove the OR filter and just
// search on the new ATT_MS_DS_HAS_MASTER_NCS

--*/
{

    Assert(pdnNC && pHasNcFilter && pNewHasNcFilter && pOldHasNcFilter);
    RtlZeroMemory( pHasNcFilter, sizeof( FILTER ) );
    RtlZeroMemory( pNewHasNcFilter, sizeof( FILTER ) );
    RtlZeroMemory( pOldHasNcFilter, sizeof( FILTER ) );

    // Setup filter to catch NCs in the "new" msDS-HasMasterNCs
    pNewHasNcFilter->choice = FILTER_CHOICE_ITEM;
    pNewHasNcFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pNewHasNcFilter->FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_HAS_MASTER_NCS;
    pNewHasNcFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnNC->structLen;
    pNewHasNcFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pdnNC;


    // Setup filter item for "old" hasMasterNCs
    pOldHasNcFilter->choice = FILTER_CHOICE_ITEM;
    pOldHasNcFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pOldHasNcFilter->FilterTypes.Item.FilTypes.ava.type = ATT_HAS_MASTER_NCS; // deprecated.
    pOldHasNcFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnNC->structLen;
    pOldHasNcFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) pdnNC;

    // Setup OR filter item.
    pHasNcFilter->choice = FILTER_CHOICE_OR;
    pHasNcFilter->FilterTypes.Or.count = 2;

    // Link the filters into the OR
    pHasNcFilter->FilterTypes.Or.pFirstFilter = pNewHasNcFilter;
    pNewHasNcFilter->pNextFilter = pOldHasNcFilter;
    pOldHasNcFilter->pNextFilter = NULL;

}


DWORD
GetDcsInNc(
    IN  THSTATE *     pTHS,
    IN  DSNAME *      pdnNC,
    IN  UCHAR         cInfoType,
    OUT SEARCHRES **  ppSearchRes
    ){
    DWORD             DirError;
    NTSTATUS          NtStatus;

    SEARCHARG         SearchArg;
    ENTINFSEL         eiSel;

    CLASSCACHE *      pCC;

    DSNAME      *     ConfigContainer;
    WCHAR             wszSites [] = L"Sites";
    DSNAME *          pdnSitesContainer;
    ULONG             cbSitesContainer;
    DWORD             Size;
    FILTER            ObjClassFilter, HasNcFilter, AndFilter, NewHasNcFilter, OldHasNcFilter;


    ASSERT( pdnNC );
    ASSERT( ppSearchRes );
    Assert( VALID_THSTATE(pTHS) );
    Assert( !pTHS->errCode ); // Don't overwrite previous errors
    Assert( cInfoType == EN_INFOTYPES_SHORTNAMES || cInfoType == EN_INFOTYPES_TYPES_VALS );

    //
    // Default the out parameter
    //
    *ppSearchRes = NULL;

    //
    //  Get the Sites Container DN for the base to search from
    //
    Size = 0;
    ConfigContainer = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                     &Size,
                                     ConfigContainer );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL ){
        ConfigContainer = (DSNAME*) THAllocEx(pTHS,Size);
        NtStatus = GetConfigurationName( DSCONFIGNAME_CONFIGURATION,
                                         &Size,
                                         ConfigContainer );
    }
    if ( !NT_SUCCESS( NtStatus ) ){
        if (ConfigContainer)  THFreeEx(pTHS,ConfigContainer);
        return(ERROR_DS_UNAVAILABLE);
    }

    cbSitesContainer = ConfigContainer->structLen +
                             (MAX_RDN_SIZE+MAX_RDN_KEY_SIZE)*(sizeof(WCHAR));
    pdnSitesContainer = THAllocEx(pTHS, cbSitesContainer);
    AppendRDN(ConfigContainer,
              pdnSitesContainer,
              cbSitesContainer,
              wszSites,
              lstrlenW(wszSites),
              ATT_COMMON_NAME );
    
    THFreeEx(pTHS,ConfigContainer);

    //
    // Setup the filter
    //
    RtlZeroMemory( &AndFilter, sizeof( AndFilter ) );
    RtlZeroMemory( &ObjClassFilter, sizeof( HasNcFilter ) );
    RtlZeroMemory( &HasNcFilter, sizeof( HasNcFilter ) );

    // This fills the Filters for getting a DC with the correct NC in it's Master NCs.
    FillHasMasterNCsFilters(pdnNC, 
                            &HasNcFilter,
                            &NewHasNcFilter,
                            &OldHasNcFilter);
    
    pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA);
    if (NULL == pCC) {
        return(ERROR_DS_UNAVAILABLE);
    }
    ObjClassFilter.choice = FILTER_CHOICE_ITEM;
    ObjClassFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.type         = ATT_OBJECT_CATEGORY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = pCC->pDefaultObjCategory->structLen;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.pVal   = (BYTE *) pCC->pDefaultObjCategory;

    AndFilter.choice                    = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.count     = 2;
    AndFilter.FilterTypes.And.pFirstFilter = &ObjClassFilter;
    ObjClassFilter.pNextFilter = &HasNcFilter;

    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.AttrTypBlock.attrCount = 0;
    eiSel.AttrTypBlock.pAttr = NULL;
    eiSel.infoTypes = cInfoType;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = pdnSitesContainer;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &AndFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &eiSel;

    InitCommarg( &SearchArg.CommArg );

    *ppSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));

    SearchBody(pTHS, &SearchArg, *ppSearchRes, 0);

    if (*ppSearchRes) {
        (*ppSearchRes)->CommRes.errCode = pTHS->errCode;
        (*ppSearchRes)->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return(pTHS->errCode);
}

DWORD
GetDcsInNcTransacted(
    IN  THSTATE *     pTHS,
    IN  DSNAME *      pdnNC,
    IN  UCHAR         cInfoType,
    OUT SEARCHRES **  ppSearchRes
    )
{
    DWORD             dwRet;
    ULONG             dwException, ulErrorCode, dsid;
    PVOID             dwEA;

    __try {

        // begin read transaction.
        SYNC_TRANS_READ();

        __try {
            // get the data desired.
            dwRet = GetDcsInNc(pTHS, pdnNC, cInfoType, ppSearchRes);
        } __finally {
            // close read transaction.
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }
    } __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                &dwEA, &ulErrorCode, &dsid)) {
        // Just catching the exception.
        dwRet = ERROR_DS_UNAVAILABLE;
    }

    return(dwRet);
}

NTSTATUS
DsGetServersAndSitesForNetLogon(
    IN   WCHAR *         pNCDNS,
    OUT  SERVERSITEPAIR ** ppaRes
    )
{
    THSTATE *                pTHS = NULL;
    SERVERSITEPAIR *         paResult = NULL;
    DWORD                    ulRet = ERROR_SUCCESS;
    DWORD                    dwDirErr;
    SEARCHRES *              pDsaSearchRes = NULL;
    CROSS_REF_LIST *         pCRL;
    ENTINFLIST *             pEntInf = NULL;
    ULONG                    i;
    ULONG                    cbDnsHostName;
    WCHAR *                  wsDnsHostName;
    WCHAR *                  wsSiteName = NULL;
    ULONG                    cbSiteName = 0;
    DWORD                    dwServerClass = CLASS_SERVER;
    ULONG                    dwException, ulErrorCode, dsid;
    PVOID                    dwEA;

    // Assert there is no THSTATE, we're coming from netlogon.
    Assert(!pTHStls);
    Assert(ppaRes);
    pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    if(!pTHS){
        return(ERROR_DS_INTERNAL_FAILURE);
    }
    Assert(VALID_THSTATE(pTHS));

    *ppaRes = NULL;
    pTHS->fDSA = TRUE;

    // Do search
    __try{

            // begin read transaction
            SYNC_TRANS_READ();

        __try{

            // Setup search

            // Find the right NC that we want.
            for(pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR){
                if(DnsNameCompare_W(pNCDNS, pCRL->CR.DnsName) &&
                   !NameMatched(pCRL->CR.pNC, gAnchor.pConfigDN) &&
                   !NameMatched(pCRL->CR.pNC, gAnchor.pDMD) ){
                    break;
                }
            }
            if(!pCRL){
                ulRet = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
                __leave;
            }

            dwDirErr = GetDcsInNc(pTHS, pCRL->CR.pNC,
                                  EN_INFOTYPES_SHORTNAMES,
                                  &pDsaSearchRes);
            if(dwDirErr){
                ulRet = DirErrorToNtStatus(dwDirErr, &pDsaSearchRes->CommRes);
                __leave;
            }

            // Allocate based on count
            paResult = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                            (pDsaSearchRes->count + 1) * sizeof(SERVERSITEPAIR));
            if(paResult == NULL){
                ulRet = STATUS_NO_MEMORY;
                __leave;
            }

            // Walk the results and allocate for each.
            for(i = 0, pEntInf = &(pDsaSearchRes->FirstEntInf);
                i < pDsaSearchRes->count && pEntInf;
                i++, pEntInf = pEntInf->pNextEntInf){

                //
                // First lets get the server name.
                //

                DBFindDNT(pTHS->pDB, *((ULONG*) pEntInf->Entinf.pName->StringName));
                // Trim off one to get the server object
                DBFindDNT(pTHS->pDB, pTHS->pDB->PDNT);
                if (DBGetAttVal(pTHS->pDB, 1, ATT_DNS_HOST_NAME,
                                0,0,
                                &cbDnsHostName, (PUCHAR *)&wsDnsHostName) ) {
                    // Bailing on this paticular server.
                    i--;
                    continue;
                }

                paResult[i].wszDnsServer = LocalAlloc(LMEM_FIXED,
                                                      cbDnsHostName +
                                                      sizeof(WCHAR));
                if(paResult[i].wszDnsServer == NULL){
                    ulRet = STATUS_NO_MEMORY;
                    __leave;
                }
                memcpy(paResult[i].wszDnsServer, wsDnsHostName, cbDnsHostName);
                Assert(cbDnsHostName % sizeof(WCHAR) == 0);
                paResult[i].wszDnsServer[cbDnsHostName/sizeof(WCHAR)] = L'\0';

                //
                // Then lets get the site
                //

                // Trim off one to get the Servers container.
                DBFindDNT(pTHS->pDB, pTHS->pDB->PDNT);
                // Trim off one more to get the specific Site container.
                DBFindDNT(pTHS->pDB, pTHS->pDB->PDNT);
                if (DBGetAttVal(pTHS->pDB, 1, ATT_RDN,
                                0,0,
                                &cbSiteName, (PUCHAR *)&wsSiteName) ) {
                    // Bailing on this paticular server.
                    Assert(paResult[i].wszDnsServer);
                    if(paResult[i].wszDnsServer) {
                        LocalFree(paResult[i].wszDnsServer);
                        paResult[i].wszDnsServer = NULL;
                    }
                    i--;
                    continue;
                }
                paResult[i].wszSite = LocalAlloc(LMEM_FIXED,
                                                 cbSiteName + sizeof(WCHAR));
                if(paResult[i].wszSite == NULL){
                    Assert(paResult[i].wszDnsServer);
                    if(paResult[i].wszDnsServer) {
                        LocalFree(paResult[i].wszDnsServer);
                        paResult[i].wszDnsServer = NULL;
                    }
                    ulRet = STATUS_NO_MEMORY;
                    __leave;
                }
                memcpy(paResult[i].wszSite, wsSiteName, cbSiteName);
                Assert(cbSiteName % sizeof(WCHAR) == 0);
                paResult[i].wszSite[cbSiteName/sizeof(WCHAR)] = L'\0';

            } // End for each server entry.
            Assert(i <= pDsaSearchRes->count);

            // NULL terminate the array.
            paResult[i].wszDnsServer = NULL;
            paResult[i].wszSite = NULL;

        } __finally {
                CLEAN_BEFORE_RETURN( pTHS->errCode);
                THDestroy();
                Assert(!pTHStls);
        }
    } __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                &dwEA, &ulErrorCode, &dsid)) {
        // Just catching the exception, and signaling an error.
        ulRet = STATUS_DS_UNAVAILABLE;
    }

    if(ulRet){
        // There was a problem free the result if there was any.
        if(paResult){
            DsFreeServersAndSitesForNetLogon(paResult);
            paResult = NULL;
        }
        Assert(paResult == NULL);
    }

    *ppaRes = paResult;
    return(ulRet);
}



BOOL
GetConfigurationNamesListNcsCheck(
    THSTATE *               pTHS,
    DWORD                   dwTestFlags,
    DWORD                   fCRFlags,
    BOOL                    bEnabled,
    DSNAME *                pNC
    )
/*++

Description:

    This is a collection point for the logic of implimenting the 
    DSCNL_NCS_* flags.  Nearly every combination of flags is valid.

Arguments:

    pTHS - Thread state, used for a couple DB ops, ruins currency.
    dwTestFlags - See GetConfigurationNamesListNcsCheck() and 
        ntdsa.h:DSCNL_NCS_* for an example of the flags you can use.
    fCRFlags - systemFlags attribute from the crossRef.
    bEnabled - enabled attribute from the crossRef.  A missing 
        enabled attribute means the cross-ref is enabled (i.e. TRUE).
    pNC - The DN of the Naming Context we want to see if it matches
        the user specified flags (dwTestFlags).

Return Values:

    TRUE if this NC matches the user specified flags in dwTestFlags,
    FALSE otherwise.


--*/
{
    NAMING_CONTEXT_LIST *   pNCL;
    BOOL                    fGood = FALSE;
    BOOL                    fLocal = FALSE;
    SYNTAX_INTEGER          it;
    NCL_ENUMERATOR          nclEnum;

    //
    // Do some special case handling of disabled and foriegn CRs/NCs.
    //

    // Can't have locally mastered  non-AD NCs.
    Assert( (dwTestFlags & DSCNL_NCS_REMOTE) || !(dwTestFlags & DSCNL_NCS_ALL_NON_AD_NCS) );

    // We can do these two tests earlier, because they're
    // mutually exclusive with the kinds of NCs below.
    if (dwTestFlags & DSCNL_NCS_REMOTE) {

        // Do they want disabled CRs/NCs?
        if(dwTestFlags & DSCNL_NCS_DISABLED &&
           bEnabled == FALSE){
            // This is a disabled CR and they asked for it, so return it.
            return(TRUE);
        }

        // Do they want foreign CRs/NCs?
        if (dwTestFlags & DSCNL_NCS_FOREIGN &&
             (!(fCRFlags & FLAG_CR_NTDS_NC) &&
              (bEnabled == TRUE)) ){
            // This is a foreign CR and they asked for it, so return it.
            return(TRUE);
        }
    }

    ;
    if (!(fCRFlags & FLAG_CR_NTDS_NC) ||
        !bEnabled) {
        // ISSUE-2002/04/22-BrettSh - So this line would preserve the
        // (unrealized until now) bad behaviour below, where we're 
        // returning as an NDNC a auto created disabled NDNC's crossRef.  
        // This would require a timine issue to show up, so it's 
        // doubtful removing this bad behaviour will cause any bugs,
        // but just in case we'll leave this here til .NET ships.
        //&& (!bEnabled && !(fCRFlags & FLAG_CR_NTDS_NC)) ) { 
        ;
        // Foriegn and disabled CRs can be bailed at this point, because
        // they weren't caught above.
        return(FALSE);
    }

    //
    // From here on down, we will be dealing with enabled AD NCs
    //

    // First is it the right kind of NC { Domain, Schema, Config, or NDNC/Other }
    fGood = FALSE; // presumed innocent until proven guilty.

    if((dwTestFlags & DSCNL_NCS_DOMAINS) &&
         (fCRFlags & FLAG_CR_NTDS_DOMAIN)){
        fGood = TRUE;
    }
    if((dwTestFlags & DSCNL_NCS_CONFIG) &&
         (NameMatched(pNC, gAnchor.pConfigDN))){
        fGood = TRUE;
    }
    if((dwTestFlags & DSCNL_NCS_SCHEMA) &&
         (NameMatched(pNC, gAnchor.pDMD))){
        fGood = TRUE;
    }
    if((dwTestFlags & DSCNL_NCS_NDNCS) &&
         !(fCRFlags & FLAG_CR_NTDS_DOMAIN) &&
         !(NameMatched(pNC, gAnchor.pConfigDN)) &&
         !(NameMatched(pNC, gAnchor.pDMD))){
        fGood = TRUE;
    }
    if((dwTestFlags & DSCNL_NCS_ROOT_DOMAIN) &&
       NameMatched(pNC, gAnchor.pRootDomainDN)){
        fGood = TRUE;
    }

    if(!fGood){
        // Did not pass the right kind of NC test.
        return(FALSE);
    }

    // Second is the NC of the right locality { Master NC, Readonly NC, or Remote NC }
    fGood = FALSE; // presumed innocent until proven guilty.
            
    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, (PVOID)pNC);
    while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
        fLocal = TRUE;
        if(dwTestFlags & DSCNL_NCS_LOCAL_MASTER){
            fGood = TRUE;
            break;
        }
    }
        
    if (!(fLocal && fGood)) {
        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, (PVOID)pNC);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            fLocal = TRUE;
            if(dwTestFlags & DSCNL_NCS_LOCAL_READONLY){
                fGood = TRUE;
                break;
            }
        }
    }

    if (fLocal
        && ((0 != DBFindDSName(pTHS->pDB, pNC))
            || (0 != DBGetSingleValue(pTHS->pDB, ATT_INSTANCE_TYPE,
                                      &it, sizeof(it), NULL))
            || (it & (IT_NC_COMING | IT_NC_GOING)))) {
        // NC is locally instantiated but has not yet replicated in completely
        // or is in the process of being removed from the local DSA -- don't
        // count it.
        fLocal = fGood = FALSE;
    }

    if (!fGood && !fLocal && (dwTestFlags & DSCNL_NCS_REMOTE)) {
        // We didn't find it locally, and that's what we wanted.
        fGood = TRUE;
    }

    return(fGood);
}

NTSTATUS
GetConfigurationNamesListNcs(
    IN      DWORD       dwFlags,
    IN OUT  ULONG *     pcbNames,
    IN OUT  DSNAME **   padsNames   OPTIONAL
    )
/*++

Description:

    This is the worker routine for the DSCONFIGNAMELIST_NCS command in
    the GetConfigurationNamesList() command.  This command usually just
    returns a list of NCs, but we can also return the list of NCs paired
    with thier appropriate CR DNs as well.

Arguments:

    dwFlags - See the flags such as DSCNL_NCS_DOMAINS in ntdsa.h for
        some idea of what you can pass in here to ratify the list of
        NCs you want to get back.  For example:
        
            dwFlags = (DSCNL_NCS_ALL_AD_NCS | DSCNL_NCS_ALL_LOCALITIES)
            
        would give you a list of DNs for all the Naming Contexts (NCs)
        in this AD forest.  While this example:
        
            dwFlags = (DSCNL_NCS_DOMAINS | DSCNL_NCS_ALL_LOCALITIES)
            
        would give you a list of all Naming Contexts that are also 
        Domains in this AD forest.  While this example:
        
            dwFlags = (DSCNL_NCS_ALL_AD_NCS | DSCNL_NCS_LOCAL_MASTER)
            
        would give you a list of all NCs this DC itself is writeable
        for.
        
        DSCNL_NCS_CROSS_REFS_TOO is a special flag that makes this function
        return a list of NCs paired with the DNs for thier associated
        cross-refs as well.  See ntdsa.h:DSCNL_NCS_CROSS_REFS_TOO for
        more info.

    pcbName - On input holds the byte count of the pName buffer.  On
        STATUS_BUFFER_TOO_SMALL error returns the count of bytes required.

    pName - Pointer to user provided output buffer.

Return Values:

    STATUS_SUCCESS on success.
    STATUS_INVALID_PARAMETER on bad parameter.
    STATUS_BUFFER_TOO_SMALL if buffer is too small.
    STATUS_NOT_FOUND if we don't have the name.  Note that this can
        happen if caller is too early in the boot cycle.

--*/
{
    NTSTATUS            ntStatus = STATUS_UNSUCCESSFUL;
    CROSS_REF_LIST *    pCRL = NULL;
    ULONG               cDNs = 0;
    ULONG               cbNeeded = 0;
    ULONG               cbOffset = 0;
    ULONG               iDN;
    THSTATE *           pTHSOld = THSave();
    THSTATE *           pTHS = NULL;
    DSNAME **           ppDNs = NULL;
    DWORD               cDNsTHAlloced = 0;
    ULONG               dwException, ulErrorCode, dsid;
    VOID *              pExceptAddr;

    __try {
        pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
        if (NULL == pTHS) {
            ntStatus = STATUS_NO_MEMORY;
            __leave;
        }
        pTHS->fDSA = TRUE;

        cDNsTHAlloced = 25;
        ppDNs = THAllocEx(pTHS, cDNsTHAlloced * sizeof(DSNAME *));

        SYNC_TRANS_READ();
        __try {
            
            // First lets walk the list of CRs making an in-order list
            // of DNs we want to return to the client.
            for (pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR) {
                // Does this NC match our search criteria.
                if (GetConfigurationNamesListNcsCheck(pTHS,
                                                      dwFlags,
                                                      pCRL->CR.flags,
                                                      pCRL->CR.bEnabled,
                                                      pCRL->CR.pNC)){
                    cbNeeded += PADDEDNAMESIZE(pCRL->CR.pNC);
                    if(dwFlags & DSCNL_NCS_CROSS_REFS_TOO){
                        cbNeeded += PADDEDNAMESIZE(pCRL->CR.pObj);
                    }

                    if (cDNs >= cDNsTHAlloced - 1) {
                        cDNsTHAlloced *= 2;
                        ppDNs = THReAllocEx(pTHS, ppDNs,
                                            cDNsTHAlloced * sizeof(*ppDNs));
                    }

                    ppDNs[cDNs] = pCRL->CR.pNC;
                    cDNs++;
                    if(dwFlags & DSCNL_NCS_CROSS_REFS_TOO){
                        // This flag means that we need room for all the NCs
                        // and their respective CR DNs as well.
                        ppDNs[cDNs] = pCRL->CR.pObj;
                        cDNs++;
                    }
                }
            }
            
            cbOffset = (sizeof(DSNAME *) * (cDNs+1));
            cbNeeded += cbOffset;

            if (*pcbNames < cbNeeded) {
                *pcbNames = cbNeeded;
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                __leave;
            }

            iDN = 0;
            for (iDN = 0; iDN < cDNs; iDN++) {
                Assert(cbOffset + PADDEDNAMESIZE(ppDNs[iDN]) <= *pcbNames);

                padsNames[iDN] = (DSNAME *) (((BYTE *) padsNames) + cbOffset);
                memcpy(padsNames[iDN], ppDNs[iDN], ppDNs[iDN]->structLen);
                cbOffset += PADDEDNAMESIZE(ppDNs[iDN]);
            }

            padsNames[iDN] = NULL;
            Assert(iDN == cDNs);

            ntStatus = STATUS_SUCCESS;
        } __finally {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }
    } __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                &pExceptAddr, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (NULL != pTHS) {
        free_thread_state();
    }

    if (NULL != pTHSOld) {
        THRestore(pTHSOld);
    }

    return ntStatus;
}

NTSTATUS
GetConfigurationNamesList(
    DWORD                    which,
    DWORD                    dwFlags,
    ULONG *                  pcbNames,
    DSNAME **                padsNames
    )

/*++

Description:

    Routine for in-process clients like LSA to learn about various names
    we have cached in gAnchor.

    This routine intentionally does not require a THSTATE or DBPOS.

    EX:

    while(STATUS_BUFFER_TOO_SMALL == (dwRet = GetConfigurationNamesList(
                                            DSCONFIGNAME_NCS,
                                            dwFlags,
                                            &ulCount,
                                            &pBuffer))){
        // ReAllocMoreMem into pBuffer, of size ulCount bytes. EX:
        pBuffer = (DSNAME **) THReAllocEx(pTHS, ulCount);
    }
    // Should this point have a NULL terminated array of DSNAME ptrs
    // in your pBuffer.  Cast it to a DSNAME **, and you should be
    // able to reference them.


Arguments:

    which - Identifies a DSCONFIGNAME* value, this determines which info
        the caller is interested in.

    dwFlags - For the DSCONFIGNAMELIST_* entries you can pass some flags
        that further refine what information you're interested in.  For 
        the given constant of which look at this function's header to 
        see how it handles the optional flags:
        
            DSCONFIGNAMELIST_NCS    ->  GetConfigurationNamesListNcs()
                
            Well, only one so far, but someone could do our site or whatever?
            

    pcbName - On input holds the byte count of the pName buffer.  On
        STATUS_BUFFER_TOO_SMALL error returns the count of bytes required.

    pName - Pointer to user provided output buffer.

Return Values:

    STATUS_SUCCESS on success.
    STATUS_INVALID_PARAMETER on bad parameter.
    STATUS_BUFFER_TOO_SMALL if buffer is too small.
    STATUS_NOT_FOUND if we don't have the name.  Note that this can
        happen if caller is too early in the boot cycle.

--*/

{
    NTSTATUS                 ntStatus;
    ULONG                    cbOffset = 0;

    Assert(pcbNames);

    if ( DsaIsInstalling() ){

        return(STATUS_NOT_FOUND);
    }

    // Check parameters - "which" is validated by switch statement later.
    if ( pcbNames == NULL ){

        return(STATUS_INVALID_PARAMETER);
    }

    if ( (padsNames == NULL) && (*pcbNames != 0)){

        return(STATUS_INVALID_PARAMETER);

    }
    
    // Currently only during the DSCONFIGNAMELIST_NCS command can
    // we sepecify the DSCNL_NCS_CROSS_REFS_TOO flag ...
    Assert( which == DSCONFIGNAMELIST_NCS || 
            !(DSCNL_NCS_CROSS_REFS_TOO & dwFlags) );

    switch ( which ){
    case DSCONFIGNAME_DMD:
    case DSCONFIGNAME_DSA:
    case DSCONFIGNAME_CONFIGURATION:
    case DSCONFIGNAME_ROOT_DOMAIN:
    case DSCONFIGNAME_LDAP_DMD:
    case DSCONFIGNAME_PARTITIONS:
    case DSCONFIGNAME_DS_SVC_CONFIG:

        Assert(dwFlags == 0 && "This is not supported!\n");

        // Threw in support for original types anyway.
        cbOffset = sizeof(DSNAME *) * 2;
        if( cbOffset > *pcbNames){
            // Already too big for buffer, fall through and
            // call GetConfigurationNames anyway, so we've get
            // the size needed there.
            *pcbNames = 0;
        } else {
            padsNames[0] = (DSNAME *) (((BYTE *) padsNames) + cbOffset);
            padsNames[1] = NULL;
            *pcbNames -= cbOffset;
        }

        ntStatus = GetConfigurationName (which,
                                         pcbNames,
                                         padsNames[0]);
        if(ntStatus == STATUS_BUFFER_TOO_SMALL){
            *pcbNames += cbOffset;
        }
        return(ntStatus);

    case DSCONFIGNAME_DOMAIN: // This should just start working in Blackcomb.
        which = DSCONFIGNAMELIST_NCS;
        dwFlags |= (DSCNL_NCS_DOMAINS | DSCNL_NCS_LOCAL_MASTER);
        // Fall through to the NC list creation code below.

    case DSCONFIGNAMELIST_NCS:

        return GetConfigurationNamesListNcs(dwFlags,
                                            pcbNames,
                                            padsNames);


    default:

        return(STATUS_INVALID_PARAMETER);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
GetConfigurationInfo(
    DWORD       which,
    DWORD       *pcbSize,
    VOID        *pBuff)
{
    
   
   VOID *pTmp;
   DWORD expectedSize;
   
   switch ( which )
   {
   case DSCONFIGINFO_FORESTVERSION:

       pTmp = &gAnchor.ForestBehaviorVersion;
       expectedSize = sizeof(gAnchor.ForestBehaviorVersion);
       Assert(gAnchor.ForestBehaviorVersion>=0&&"This function shouldn't be called before gAnchor is ready.");
       break;

   case DSCONFIGINFO_DOMAINVERSION:

       pTmp = &gAnchor.DomainBehaviorVersion;
       expectedSize = sizeof(gAnchor.DomainBehaviorVersion);
       Assert(gAnchor.DomainBehaviorVersion>=0&&"This function shouldn't be called before gAnchor is ready.");
       break;

   default:
       return(STATUS_INVALID_PARAMETER);
   }

   if ( *pcbSize < expectedSize )
   {
       *pcbSize = expectedSize;
       return(STATUS_BUFFER_TOO_SMALL);
   }

   *pcbSize = expectedSize;
   memcpy(pBuff, pTmp, expectedSize);
   return(STATUS_SUCCESS);

}


NTSTATUS
GetConfigurationName(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName)

/*++

Description:

    Routine for in-process clients like LSA to learn about various names
    we have cached in gAnchor.

    This routine intentionally does not require a THSTATE or DBPOS.

Arguments:

    which - Identifies a DSCONFIGNAME value.

    pcbName - On input holds the byte count of the pName buffer.  On
        STATUS_BUFFER_TOO_SMALL error returns the count of bytes required.

    pName - Pointer to user provided output buffer.

Return Values:

    STATUS_SUCCESS on success.
    STATUS_INVALID_PARAMETER on bad parameter.
    STATUS_BUFFER_TOO_SMALL if buffer is too small.
    STATUS_NOT_FOUND if we don't have the name.  Note that this can
        happen if caller is too early in the boot cycle.

--*/

{
    DSNAME *pTmp = NULL;
    CROSS_REF_LIST *pCRL = NULL;

    if ( DsaIsInstalling() )
    {
        return(STATUS_NOT_FOUND);
    }

    // Check parameters - "which" is validated by switch statement later.
    if ( !pcbName )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    switch ( which )
    {
    case DSCONFIGNAME_DMD:

        pTmp = gAnchor.pDMD;
        break;

    case DSCONFIGNAME_DSA:

        pTmp = gAnchor.pDSADN;
        break;

    case DSCONFIGNAME_DOMAIN:

        pTmp = gAnchor.pDomainDN;
        break;

    case DSCONFIGNAME_CONFIGURATION:

        pTmp = gAnchor.pConfigDN;
        break;

    case DSCONFIGNAME_ROOT_DOMAIN:

        pTmp = gAnchor.pRootDomainDN;
        break;

    case DSCONFIGNAME_LDAP_DMD:

        pTmp = gAnchor.pLDAPDMD;
        break;

    case DSCONFIGNAME_PARTITIONS:

        pTmp = gAnchor.pPartitionsDN;
        break;

    case DSCONFIGNAME_DS_SVC_CONFIG:

        pTmp = gAnchor.pDsSvcConfigDN;
        break;

    case DSCONFIGNAMELIST_NCS:
        Assert(!"Must use sibling function GetConfigurationNamesList()\n");
        return(STATUS_INVALID_PARAMETER);
        break;


    case DSCONFIGNAME_DOMAIN_CR:
        //the crossRef object for the current domain

        // we cannot use other functions like FindExactCrossRef cause the
        // use THSTATE which we don't have.
        for ( pCRL = gAnchor.pCRL; NULL != pCRL; pCRL = pCRL->pNextCR )
        {
            if ( NameMatched( (DSNAME*)pCRL->CR.pNC, gAnchor.pDomainDN ) )
            {
                pTmp = (DSNAME*)pCRL->CR.pObj;
                break;
            }
        }
        break;

    case DSCONFIGNAME_ROOT_DOMAIN_CR:
        //the crossRef object for the forest root domain
        
        // we cannot use other functions like FindExactCrossRef cause the
        // use THSTATE which we don't have.
        

        for ( pCRL = gAnchor.pCRL; NULL != pCRL; pCRL = pCRL->pNextCR )
        {
            if ( NameMatched( (DSNAME*)pCRL->CR.pNC, gAnchor.pRootDomainDN ) )
            {
                pTmp = (DSNAME*)pCRL->CR.pObj;
                break;
            }
        }
        break;

    default:

        return(STATUS_INVALID_PARAMETER);
    }

    if ( !pTmp )
    {
        return(STATUS_NOT_FOUND);
    }

    if ( *pcbName < pTmp->structLen )
    {
        *pcbName = pTmp->structLen;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    if ( pName != NULL ) {

        memcpy(pName, pTmp, pTmp->structLen);

    } else {

        return( STATUS_INVALID_PARAMETER );
    }

    return(STATUS_SUCCESS);
}

int
WriteSchemaVersionToReg(
             DBPOS *pDB)

/*++
   Description:
       Takes a DBPOS positioned on the schema container, and writes
       the object-version on the schema contaier out to registry

   Arguments:
      pDB - DBPOS positioned on the chema container

   Return Value:
      0 on success, non-0 on error;
--*/
{

    int version, regVersion;
    int err, herr;
    HKEY hk;

    err = DBGetSingleValue(
                        pDB,
                        ATT_OBJECT_VERSION,
                        &version,
                        sizeof( version ),
                        NULL );

    if (err) {
       // Some error. Check if it is no value, which is perfectly
       // valid

       if (err == DB_ERR_NO_VALUE) {
           // nothing to do
           DPRINT(2,"No object-version value found on schema\n");
           return 0;
       }
       else {
          DPRINT(0,"Error retrieving Object-version value\n");
          return err;
       }
    }

    // Ok, no error, Get version no. from registry if present
    err = GetConfigParam(SCHEMAVERSION, &regVersion, sizeof(regVersion));

    // If err!=0, we will assume that the key is not there
    if ( err || (version != regVersion) ) {
        // Write version to registry
        err = SetConfigParam(SCHEMAVERSION, REG_DWORD, &version, sizeof(version));
        if (err) {
          DPRINT(0,"Error writing schema version to registry\n");
          return err;
        }

    }

    return 0;
}

// initial size for the AllowedDnsSuffixes list (assumed one default value plus NULL)
#define StrList_InitialSize 2
// grow delta for the AllowedDnsSuffixes list (will grow this many entries at a time)
#define StrList_Delta       5

typedef struct _STRING_LIST {
    PWCHAR  *list;
    DWORD   count;
    DWORD   length;
} STRING_LIST, *PSTRING_LIST;

DWORD initStrList(PSTRING_LIST pStrList)
/*
  Description:
    
    initializes a string list, allocates buffer for initial entries
    
  Arguments:
  
    pStrList    - the list
    
  Returns:
  
    0 on success, !0 otherwise
*/
{
    Assert(pStrList && StrList_InitialSize > 0);
    pStrList->list = (PWCHAR*) malloc(StrList_InitialSize * sizeof(PWCHAR));
    if (pStrList->list == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    pStrList->length = StrList_InitialSize;
    pStrList->count = 0;
    return 0;
}

DWORD appendStrToList(PSTRING_LIST pStrList, PWCHAR str)
/*
  Description:
  
    append a string str to a string list list, expanding the list if necessary
    
  Arguments:
  
    pStrList    - the list
    str         - string to add
    
  Returns:
  
    0 on success, !0 otherwise
*/
{
    Assert(pStrList);
    if (pStrList->count >= pStrList->length) {
        // need to expand the list
        PWCHAR* newBuf;
        pStrList->length += StrList_Delta;
        if ((newBuf = (PWCHAR*) realloc(pStrList->list, pStrList->length*sizeof(PWCHAR))) == NULL)
        {
            // restore length (just in case)
            pStrList->length -= StrList_Delta;
            return ERROR_OUTOFMEMORY;
        }
        pStrList->list = newBuf;
    }
    pStrList->list[pStrList->count] = str;
    pStrList->count++;
    return 0;                    
}

// RebuildAnchors() failed; retry in a few minutes
DWORD RebuildAnchorRetrySecs = 5 * 60;

// Free the old data from gAnchor in an hour
DWORD RebuildAnchorDelayedFreeSecs = 3600;

void
RebuildAnchor(void * pv,
              void ** ppvNext,
              DWORD * pcSecsUntilNextIteration )
/*
 * This routine rebuilds fields in the anchor that are left incorrect
 * when cached objects are renamed or modified.
 */
{
    DWORD err;
    __int64 junk;
    DSNAME * pDSADNnew = NULL, *pDSAName = NULL;
    SYNTAX_DISTNAME_STRING *pDSAnew = NULL;
    DWORD *pList = NULL, *pUnDelAncDNTs = NULL, Count, UnDelAncNum;
    DWORD cpapv;
    DWORD_PTR *papv = NULL;
    UCHAR NodeAddr[MAX_ADDRESS_SIZE];
    SYNTAX_ADDRESS *pNodeAddr = (SYNTAX_ADDRESS *)NodeAddr;
    DSNAME * pSiteDN = NULL;
    PSECURITY_DESCRIPTOR pSDTemp, pSDPerm = NULL;
    DWORD cbSD;
    DBPOS *pDB;
    // Avoid the read of the NC head by caching the ATT_SUB_REFS attribute
    // from the NC heads. Used in mdsearch.c
    ATTCACHE *pAC;
    ULONG iVal, i, curIndex;
    DSNAME *pSRTemp = NULL;
    DWORD cbAllocated = 0, cbUsed = 0;
    ULONG cDomainSubrefList = 0;
    PSUBREF_LIST pDomainSubrefList = NULL;
    PSUBREF_LIST pDomainSubref;
    PVOID dwEA;
    ULONG dwException, ulErrorCode, dsid;
    BOOL fAmRootDomainDC;
    ULONG SiteDNT = 0;
    ULONG SiteOptions = 0;
    LARGE_INTEGER LockoutDuration, MaxPasswordAge;
    LONG DomainBehaviorVersion, ForestBehaviorVersion;
    PWCHAR pSuffix = NULL, pTemp;
    STRING_LIST allowedSuffixes;
    PWCHAR *pCurrSuffix;
    
    PDS_NAME_RESULTW serviceName = NULL;
    WCHAR *pNameString[1];
    PWCHAR pDomain;
    extern SCHEMAPTR *CurrSchemaPtr;
    VOID * pSigVecThread = NULL, *pSigVecMalloc = NULL;
    DSNAME *pComputerDNMalloc = NULL;
        
    // Verify that RebuildAnchor is not run out of the taskq during install
    Assert( DsaIsRunning() || gTaskSchedulerTID != GetCurrentThreadId() );

    memset(&allowedSuffixes, 0, sizeof(allowedSuffixes));

    __try {
        if (err = DBGetHiddenRec(&pDSAName, &junk)) {
            __leave;
        }

        if (err = GetNodeAddress(pNodeAddr, sizeof(NodeAddr))){
            DPRINT(2,"Couldn't retrieve computer name for this DSA\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_NODE_ADDRESS,
                     NULL,
                     NULL,
                     NULL);
            __leave;
        }

        pDSAnew =  malloc(DERIVE_NAME_DATA_SIZE(pDSAName, pNodeAddr));
        if (!pDSAnew) {
            err = ERROR_OUTOFMEMORY;
            __leave;
        }

        BUILD_NAME_DATA(pDSAnew, pDSAName, pNodeAddr);

        // We use the DN portion alone often, so make it a separate field
        pDSADNnew = malloc(pDSAName->structLen);
        if (!pDSADNnew) {
            err = ERROR_OUTOFMEMORY;
            __leave;
        }
        memcpy(pDSADNnew, pDSAName, pDSAName->structLen);

        err = MakeProtectedList(pDSAName,
                                &pList,
                                &Count);
        if (err) {
            LogUnhandledError(err);
            __leave;
        }

        err = MakeProtectedAncList( gAnchor.pUnDeletableDNTs,
                                    gAnchor.UnDeletableNum,
                                    &pUnDelAncDNTs,
                                    &UnDelAncNum );
        if (err) {
            __leave;
        }

        // Get site DN.
        err = DeriveSiteDNFromDSADN(pDSAName, &pSiteDN, &SiteDNT, &SiteOptions);
        if (err) {
            __leave;
        }

        // Get the Domain SD, Max Password Age,
        // Lockout Duration, Domain behavior version,
        // and forest behavior version

        DBOpen(&pDB);
        __try {
            // Get the Domain SD
            err = DBFindDNT(pDB, gAnchor.ulDNTDomain);
            if (err) {
                __leave;
            }
            err = DBGetAttVal(pDB,
                              1,
                              ATT_NT_SECURITY_DESCRIPTOR,
                              0,
                              0,
                              &cbSD,
                              (PUCHAR*)&pSDTemp);
            if (err) {
                __leave;
            }
            pSDPerm = malloc(cbSD);
            if (!pSDPerm) {
                err = 1;
                __leave;
            }

            memcpy(pSDPerm, pSDTemp, cbSD);
            THFreeEx(pDB->pTHS, pSDTemp);

            err = DBGetSingleValue(pDB,
                        ATT_LOCKOUT_DURATION,
                        &LockoutDuration,
                        sizeof(LockoutDuration),
                        NULL);
            if (DB_ERR_NO_VALUE == err)
            {
               // This can happen during install
               // cases

               memset(&LockoutDuration, 0, sizeof(LARGE_INTEGER));
               err = 0;

            } else if (err) {

               __leave;
            }

            err = DBGetSingleValue(pDB,
                        ATT_MAX_PWD_AGE,
                        &MaxPasswordAge,
                        sizeof(MaxPasswordAge),
                        NULL);
            if (DB_ERR_NO_VALUE == err)
            {
               // This can happen during install
               // cases

               memset(&MaxPasswordAge, 0, sizeof(LARGE_INTEGER));
               err = 0;

            } else if (err) {

               __leave;
            }

            
            //
            // Optimize GeneratePOQ by caching ATT_SUB_REFS (Used in mdsearch.c)
            //

            // InLine version of DBGetAttVal(). Read the ATT_SUB_REFS.
            iVal = 1;
            pAC = SCGetAttById(pDB->pTHS, ATT_SUB_REFS);
            while (0 == DBGetAttVal_AC(pDB,
                                       iVal,
                                       pAC,
                                       DBGETATTVAL_fREALLOC,
                                       cbAllocated,
                                       &cbUsed,
                                       (UCHAR**)&pSRTemp)) {
                cbAllocated = max(cbAllocated, cbUsed);

                //
                // Found a ATT_SUB_REFS; cache it
                //


                // Allocate a list entry
                pDomainSubref = malloc(sizeof(SUBREF_LIST));
                if (!pDomainSubref) {
                    err = 1;
                    __leave;
                }
                memset(pDomainSubref, 0, sizeof(SUBREF_LIST));
                ++cDomainSubrefList;
                pDomainSubref->pNextSubref = pDomainSubrefList;
                pDomainSubrefList = pDomainSubref;

                // Allocate the DSName
                pDomainSubref->pDSName = malloc(pSRTemp->structLen);
                if (!pDomainSubref->pDSName) {
                    err = 1;
                    __leave;
                }
                memcpy(pDomainSubref->pDSName,
                       pSRTemp,
                       pSRTemp->structLen);

                // Create ancestors
                err = MakeProtectedList(pDomainSubref->pDSName,
                                        &pDomainSubref->pAncestors,
                                        &pDomainSubref->cAncestors);
                if (err) {
                    if (    err == DIRERR_NOT_AN_OBJECT
                         || err == DIRERR_OBJ_NOT_FOUND ) {
                        // the subRefs value does not point to a valid object,
                        // make sure the admin know about the problem,
                        // ntdsutil semantic checker should be able to correct the problem.
                        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_DSA_INVALID_SUBREFS,
                                  szInsertDN(gAnchor.pDomainDN),
                                  szInsertDN(pDomainSubref->pDSName),
                                  szInsertWin32ErrCode(err),
                                  szInsertWin32Msg(err),
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

                    }
                    else {
                        LogUnhandledError(err);

                    }
                      __leave;
                }
                ++iVal;
            }
            
            // free allocated buffer
            if (pSRTemp) {
                THFreeEx(pDB->pTHS, pSRTemp);
            }


            // load allowedDnsSuffixes (see mdupdate:DNSHostNameValueCheck)
            
            if (err = initStrList(&allowedSuffixes)) {
                __leave;
            }
            
            // During normal operation, the DSA's DN is
            // CN=NTDS-Settings,CN=Some Server,CN=Servers,CN=Some Site,CN=Sites, ...
            // During initial install, the DSA lives in CN=BootMachine,O=Boot.
            // So we can easily detect the install case by testing for
            // a DSA name length of two.
            Assert(NULL != gAnchor.pDSADN);
            if (err = CountNameParts(gAnchor.pDSADN, &i)) {
                __leave;
            }
            if (i == 2) {
                // install case - nothing to do
            }
            else {
                // the first allowed suffix is always the current domain name
                // need to crack it just in case...
                pNameString[0] = (WCHAR *)&(gAnchor.pDomainDN->StringName);
                err = DsCrackNamesW((HANDLE) -1,
                                    (DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC |
                                     DS_NAME_FLAG_SYNTACTICAL_ONLY),
                                    DS_FQDN_1779_NAME,
                                    DS_CANONICAL_NAME,
                                    1,
                                    pNameString,
                                    &serviceName);
    
                if (err                                  // error from the call
                    || !(serviceName->cItems)            // no items returned
                    || (serviceName->rItems[0].status)   // DS_NAME_ERROR returned
                    || !(serviceName->rItems[0].pName)   // No name returned
                    ) {
                    if (err == 0) {
                        DsFreeNameResultW(serviceName);
                        err = 1;
                    }
                    __leave;
                }
    
                pSuffix = _wcsdup(serviceName->rItems[0].pDomain);
                DsFreeNameResultW(serviceName);
                if (pSuffix == NULL) {
                    err = ERROR_OUTOFMEMORY;
                    __leave;
                }
                
                if (err = appendStrToList(&allowedSuffixes, pSuffix)) {
                    free(pSuffix);
                    __leave;
                }
                
                // InLine version of DBGetAttVal(). Read the ATT_MS_DS_ALLOWED_DNS_SUFFIXES
                iVal = 1;
                cbUsed = cbAllocated = 0;
                pSuffix = NULL;
    
                pAC = SCGetAttById(pDB->pTHS, ATT_MS_DS_ALLOWED_DNS_SUFFIXES);
                while (0 == (err = DBGetAttVal_AC(pDB,
                                                  iVal,
                                                  pAC,
                                                  DBGETATTVAL_fREALLOC,
                                                  cbAllocated,
                                                  &cbUsed,
                                                 (UCHAR**)&pSuffix))) {
                    cbAllocated = max(cbAllocated, cbUsed);
    
                    // allocate string buffer (plus room for a null)
                    pTemp = malloc(cbUsed + sizeof(WCHAR));
                    if (pTemp == NULL) {
                        err = ERROR_OUTOFMEMORY;
                        __leave;
                    }
                    // copy chars
                    memcpy(pTemp, pSuffix, cbUsed);
                    // add a terminating NULL
                    pTemp[cbUsed/sizeof(WCHAR)] = 0;
    
                    if (err = appendStrToList(&allowedSuffixes, pTemp)) {
                        __leave;
                    }
                    ++iVal;
                }
                if (pSuffix) {
                    THFreeEx(pDB->pTHS, pSuffix);
                }
    
                if (err != DB_ERR_NO_VALUE) {
                    DPRINT1(0, "DBGetAttVal_AC returned 0x%x\n", err);
                    // ?? do we need to blow up here?
                }
            }

            // append final NULL
            if (err = appendStrToList(&allowedSuffixes, NULL)) {
                __leave;
            }
            
            if (!gAnchor.pPartitionsDN) {  
                //This can occur when DCPROMO
                ForestBehaviorVersion = DomainBehaviorVersion = -1; 
            } 
            else{ 
                //normal case
                
                //get domain version number
                err = DBGetSingleValue( pDB,
                                        ATT_MS_DS_BEHAVIOR_VERSION, 
                                        &DomainBehaviorVersion, 
                                        sizeof(DomainBehaviorVersion), 
                                        NULL);


                if (err) {
                   DomainBehaviorVersion = 0;    //default
                }
           
                //get forest version number
                err = DBFindDSName(pDB, gAnchor.pPartitionsDN);
            
                if (err) {
                    __leave;
                }
            
                err = DBGetSingleValue( pDB,
                                        ATT_MS_DS_BEHAVIOR_VERSION,
                                        &ForestBehaviorVersion,
                                        sizeof(ForestBehaviorVersion),
                                        NULL );


                if (err){
                   ForestBehaviorVersion = 0;   //default 
                   err = 0;
                }
            }

            if (!gAnchor.pDSADN) {
                pSigVecMalloc = NULL;
            } else {
                // Position on DSA object
                err = DBFindDSName(pDB, gAnchor.pDSADN);
                if (err) {
                    __leave;
                }
                // Get retired dsa signature list
                pSigVecThread = DraReadRetiredDsaSignatureVector(pDB->pTHS, pDB);
                if (!pSigVecThread) {
                    pSigVecMalloc = NULL;
                } else {
                    DWORD cb;
                    // In-memory structures are at the current version
                    Assert( 1 == ((REPL_DSA_SIGNATURE_VECTOR *)pSigVecThread)->dwVersion );
                    cb = ReplDsaSignatureVecV1Size(((REPL_DSA_SIGNATURE_VECTOR*)pSigVecThread));
                    pSigVecMalloc = malloc(cb);
                    if (pSigVecMalloc == NULL) {
                        err = ERROR_OUTOFMEMORY;
                        __leave;
                    }
                    memcpy( pSigVecMalloc, pSigVecThread, cb );
                    THFreeEx( pDB->pTHS, pSigVecThread );
                    pSigVecThread = NULL;
                }
            }

            // Ignore errors if computer account not created yet
            // Due to timing issues, the computer object may not exist yet if this
            // is the first dc in the domain. The computer account is created async.
            // by SAM.  If we fail to compute the computer dn, simply leave the
            // field in the anchor null.  A subsequent rebuild will fill it in.
            (void) DeriveComputerDN( pDB->pTHS, &pComputerDNMalloc );

           
        }
        __finally {
            DBClose(pDB, !AbnormalTermination() && err == ERROR_SUCCESS);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwEA,
                              &ulErrorCode,
                              &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        err = ulErrorCode;
    }
    if (err) {
        goto exit;
    }

    fAmRootDomainDC = (NULL != gAnchor.pDomainDN)
                      && (NULL != gAnchor.pRootDomainDN)
                      && NameMatched(gAnchor.pDomainDN, gAnchor.pRootDomainDN);


    EnterCriticalSection(&gAnchor.CSUpdate);
    
    cpapv = (gAnchor.cDomainSubrefList * 3) + 7;
    
    // compute how many allowed suffixes were there...
    if (gAnchor.allowedDNSSuffixes != NULL) {
        cpapv++;
        for (pCurrSuffix = gAnchor.allowedDNSSuffixes; *pCurrSuffix != NULL; pCurrSuffix++) {
            cpapv++;
        }
    }

    if (gAnchor.pSigVec) {
        cpapv++;
    }

    if (pComputerDNMalloc && gAnchor.pComputerDN) {
        cpapv++;
    }

    papv = malloc(cpapv*sizeof(void*));
    if (!papv) {
        err = ERROR_OUTOFMEMORY;
        LeaveCriticalSection(&gAnchor.CSUpdate);
        goto exit;
    }

    curIndex = 0;
    papv[curIndex++] = (DWORD_PTR)(cpapv - 1);
    papv[curIndex++] = (DWORD_PTR)gAnchor.pDSADN;
    gAnchor.pDSADN = pDSADNnew;
    pDSADNnew = NULL;
    papv[curIndex++] = (DWORD_PTR)gAnchor.pDSA;
    gAnchor.pDSA = pDSAnew;
    pDSAnew = NULL;
    papv[curIndex++] = (DWORD_PTR)gAnchor.pAncestors;
    papv[curIndex++] = (DWORD_PTR)gAnchor.pUnDelAncDNTs;

    // this is not reduntant. it is like that so as to be thread safe.
    // The problem is that while we serialize updates to the anchor,
    // we do not serialize reads of it.  Specifically, we allow people
    // to read the anchor while it is being updated.  The ancestors
    // list consists of a vector and the size of that vector.
    // We can't replace both at once, so we replace them in the
    // order deemed safest, in case we get interrupted between the
    // two assignments.
    // That order is different if the new list is larger than
    // the old than if it's smaller.
    // Use Interlocked* functions so that the compiler does not 
    // reorder the assignments.
    if (gAnchor.AncestorsNum <= Count) {
        InterlockedExchangePointer(&gAnchor.pAncestors, pList);
        InterlockedExchange((PLONG)&gAnchor.AncestorsNum, (LONG)Count);
    }
    else {
        InterlockedExchange((PLONG)&gAnchor.AncestorsNum, (LONG)Count);
        InterlockedExchangePointer(&gAnchor.pAncestors, pList);
    }
    pList = NULL;

    if (gAnchor.UnDelAncNum <= UnDelAncNum) {
        InterlockedExchangePointer(&gAnchor.pUnDelAncDNTs, pUnDelAncDNTs);
        InterlockedExchange((PLONG)&gAnchor.UnDelAncNum, (LONG)UnDelAncNum);
    }
    else {
        InterlockedExchange((PLONG)&gAnchor.UnDelAncNum, (LONG)UnDelAncNum);
        InterlockedExchangePointer(&gAnchor.pUnDelAncDNTs, pUnDelAncDNTs);
    }
    pUnDelAncDNTs = NULL;

    papv[curIndex++] = (DWORD_PTR)gAnchor.pSiteDN;
    gAnchor.pSiteDN = pSiteDN;
    RegisterActiveContainerByDNT(SiteDNT, ACTIVE_CONTAINER_OUR_SITE);
    gAnchor.SiteOptions = SiteOptions;
    gAnchor.pLocalDRSExtensions->SiteObjGuid = pSiteDN->Guid;
    pSiteDN = NULL;
    papv[curIndex++] = (DWORD_PTR)gAnchor.pDomainSD;
    gAnchor.pDomainSD = pSDPerm;
    pSDPerm = NULL;

    gAnchor.fAmRootDomainDC = fAmRootDomainDC;

    // Delay free the current cache of ATT_SUB_REFS
    for (pDomainSubref = gAnchor.pDomainSubrefList;
        pDomainSubref != NULL;
        pDomainSubref = pDomainSubref->pNextSubref) {
        Assert(curIndex < cpapv);

        // order is immportant; pDomainSubrefEntry last
        papv[curIndex++] = (DWORD_PTR)pDomainSubref->pDSName;
        papv[curIndex++] = (DWORD_PTR)pDomainSubref->pAncestors;
        papv[curIndex++] = (DWORD_PTR)pDomainSubref;
    }

    //
    // The problem is that while we serialize updates to the anchor,
    // we do not serialize reads of it.  Specifically, we allow people
    // to read the anchor while it is being updated.  The ATT_SUB_REFS
    // cache consists of a list and a valid-flag. We can't replace both
    // at once, so we replace them in the order deemed safest, in case
    // we get interrupted between the two assignments.
    //
    // Install new cache of ATT_SUB_REFS
    // Make sure readers (which are not serialized) can never read past the end of the list.
    // Use Interlocked* functions so that the compiler does not reorder the assignments.
    if (cDomainSubrefList > gAnchor.cDomainSubrefList) {
        InterlockedExchangePointer(&gAnchor.pDomainSubrefList, pDomainSubrefList);
        InterlockedExchange((PLONG)&gAnchor.cDomainSubrefList, (LONG)cDomainSubrefList);
    }
    else {
        InterlockedExchange((PLONG)&gAnchor.cDomainSubrefList, (LONG)cDomainSubrefList);
        InterlockedExchangePointer(&gAnchor.pDomainSubrefList, pDomainSubrefList);
    }
    gAnchor.fDomainSubrefList = TRUE;
    pDomainSubrefList = NULL;
    cDomainSubrefList = 0;

    // Update the MaxPasswordAge and LockoutDuration on the anchor
    gAnchor.MaxPasswordAge = MaxPasswordAge;
    gAnchor.LockoutDuration = LockoutDuration;

    //update domain/forest behavior version
    gAnchor.ForestBehaviorVersion = ForestBehaviorVersion;
    gAnchor.DomainBehaviorVersion = DomainBehaviorVersion;

    // add old suffixes...
    if (gAnchor.allowedDNSSuffixes != NULL) {
        for (pCurrSuffix = gAnchor.allowedDNSSuffixes; *pCurrSuffix != NULL; pCurrSuffix++) {
            Assert(curIndex < cpapv);
            papv[curIndex++] = (DWORD_PTR)*pCurrSuffix;
        }
        Assert(curIndex < cpapv);
        papv[curIndex++] = (DWORD_PTR)gAnchor.allowedDNSSuffixes;
    }

    // update allowed DNS suffixes
    gAnchor.allowedDNSSuffixes = allowedSuffixes.list;
    allowedSuffixes.list = NULL;

    // Add signature vector
    if (gAnchor.pSigVec) {
        papv[curIndex++] = (DWORD_PTR)gAnchor.pSigVec;
    }
    gAnchor.pSigVec = pSigVecMalloc;
    pSigVecMalloc = NULL; // don't clean up

    if (pComputerDNMalloc) {
        if (gAnchor.pComputerDN) {
            papv[curIndex++] = (DWORD_PTR)gAnchor.pComputerDN;
        }
        gAnchor.pComputerDN = pComputerDNMalloc;
        pComputerDNMalloc = NULL; // don't clean up
    }

#if defined(DBG)
    gdwLastGlobalKnowledgeOperationTime = GetTickCount();
#endif

    LeaveCriticalSection(&gAnchor.CSUpdate);

    DelayedFreeMemoryEx(papv, RebuildAnchorDelayedFreeSecs);
    papv = NULL;

    //check if the forest/domain behavior versions are out of range
    if (   gAnchor.ForestBehaviorVersion >= 0
        && gAnchor.DomainBehaviorVersion >= 0
        && (    gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_VERSION_MIN
            ||  gAnchor.ForestBehaviorVersion > DS_BEHAVIOR_VERSION_CURRENT
            ||  gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_VERSION_MIN
            ||  gAnchor.DomainBehaviorVersion > DS_BEHAVIOR_VERSION_CURRENT  )    )
    {
        //stop advertising NetLogon

        LogEvent8( DS_EVENT_CAT_INTERNAL_PROCESSING,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_BAD_VERSION_REP_IN,
                   szInsertInt(gAnchor.ForestBehaviorVersion),
                   szInsertInt(gAnchor.DomainBehaviorVersion),
                   szInsertInt(DS_BEHAVIOR_VERSION_MIN),
                   szInsertInt(DS_BEHAVIOR_VERSION_CURRENT),
                   NULL,
                   NULL,
                   NULL,
                   NULL  );

        SetDsaWritability( FALSE, ERROR_DS_INCOMPATIBLE_VERSION );

    }

    // Check if we should enable linked value replication
    if (gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS) {
        DsaEnableLinkedValueReplication( NULL /*noths*/, FALSE /*notfirst */ );
    }

    // Reload the schema cache if the cache was loaded using a different
    // forest version.
    //
    // The schema cache may have been loaded before the forest behavior
    // version was known or a new forest behavior version has replicated
    // since the schema cache was last loaded. Because some features,
    // like the new schema reuse behavior, are triggered off of the
    // forest version, reload the schema cache using the correct
    // version. This call has no effect when the schema reload
    // thread is not running; Eg, during install or mkdit.
    if (CurrSchemaPtr
        && CurrSchemaPtr->ForestBehaviorVersion != gAnchor.ForestBehaviorVersion) {
        SCSignalSchemaUpdateImmediate();
    }

  exit:

    if (err) {
        // We didn't succeed, so try again in a few minutes
        *ppvNext = NULL;
        *pcSecsUntilNextIteration = RebuildAnchorRetrySecs;
    }

    // CLEANUP
    if (pDSAName) {
        free(pDSAName);
    }

    if (pDSAnew) {
        free(pDSAnew);
    }

    if (pDSADNnew) {
        free(pDSADNnew);
    }

    if (pList) {
        free(pList);
    }

    if (pSiteDN) {
        free(pSiteDN);
    }

    if (pSDPerm) {
        free(pSDPerm);
    }

    if (papv) {
        free(papv);
    }

    if (allowedSuffixes.list != NULL) {
        for (i = 0; i < allowedSuffixes.count; i++) {
            if (allowedSuffixes.list[i] != NULL) {
                free(allowedSuffixes.list[i]);
            }
        }
        free(allowedSuffixes.list);
    }

    while (pDomainSubref = pDomainSubrefList) {
        pDomainSubrefList = pDomainSubref->pNextSubref;
        free(pDomainSubref->pAncestors);
        free(pDomainSubref->pDSName);
        free(pDomainSubref);
    }

    if (pSigVecMalloc) {
        free(pSigVecMalloc);
    }

    if (pComputerDNMalloc) {
        free( pComputerDNMalloc );
    }

    return;
}

WCHAR wcDsaRdn[] = L"NTDS Settings";
#define DSA_RDN_LEN ((sizeof(wcDsaRdn)/sizeof(wcDsaRdn[0])) - 1)

void ValidateLocalDsaName(THSTATE *pTHS,
                          DSNAME **ppDSAName)
// This routine makes sure that the object named by ppDSAName has the RDN
// that we expect all DSAs to have.  If it does not, then we rename it so
// that it does.  If any object was already there with that name, we delete it.
//
// Why would we ever need to do this?  Consider the following:  DC0 and DC1
// are in an existing enterprise.  The admin wishes to join DC2 to the
// enterprise.
//
// DCPROMO on DC2 chooses to use DC1 as a replication source (and therefore
// as the DC on which it will create its new ntdsDsa object).  DC2 asks DC1
// to create the object (which it does), and DCPROMO begins to replicate.
// Power fails to DC1.
//
// Power is restored to DC1, and the admin restarts DCPROMO.  This time
// DCPROMO picks to source from DC0.  If DC0 has not yet replicated the
// alread-created ntdsDsa object from DC1, it will create another one.
// Then, when the promo completes and replication has quiesced, there will
// be two ntdsDsa objects for this server, and one or both may have the
// wrong name.  (I.e., the RDN has been munged due to the name conflict.)
{
    WCHAR RDNval[MAX_RDN_SIZE];
    ULONG RDNlen;
    ATTRTYP RDNtype;
    unsigned err;
    DSNAME *pDNdesired, *pDNparent;
    BOOL fDsaSave;
    REMOVEARG RemoveArg;
    REMOVERES *pRemoveRes;
    MODIFYDNARG ModifyDNArg;
    MODIFYDNRES *pModifyDNRes;
    ATTR NameAttr;
    ATTRVAL NameAttrVal;
    USN usnUnused;

    if (DsaIsInstalling()) {
        return;
    }
    Assert(DsaIsRunning());

    // Check the RDN on the DSA object.
    err = GetRDNInfo(pTHS,
                     *ppDSAName,
                     RDNval,
                     &RDNlen,
                     &RDNtype);
    if (err) {
        // Can't validate the name, so ignore it
        LogUnhandledError(err);
        return;
    }

    if (   (RDNlen == DSA_RDN_LEN)
        && (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                RDNval,
                                DSA_RDN_LEN,
                                wcDsaRdn,
                                DSA_RDN_LEN))) {
        // The DSA has the right RDN
        return;
    }

    // If we're here, the DSA has the wrong name.  We need to delete any object
    // that might exist under the name we want, and then rename the DSA to
    // have that name.
    pDNparent = THAllocEx(pTHS, (*ppDSAName)->structLen);
    pDNdesired = THAllocEx(pTHS, (*ppDSAName)->structLen + DSA_RDN_LEN*sizeof(WCHAR));
    TrimDSNameBy(*ppDSAName, 1, pDNparent);
    if ( 0 != AppendRDN(pDNparent,
                        pDNdesired,
                        (*ppDSAName)->structLen + DSA_RDN_LEN*sizeof(WCHAR),
                        wcDsaRdn,
                        DSA_RDN_LEN,
                        ATT_COMMON_NAME))
    {
        // we should not be here
        Assert(!"Failed to Append RDN");
        return;
    }
    THFreeEx(pTHS, pDNparent);

    // pDNdesired is now the DN we want to end up with.  In case some usurper
    // object is already sitting with that name, delete it.

    memset(&RemoveArg, 0, sizeof(RemoveArg));
    RemoveArg.pObject = pDNdesired;
    InitCommarg(&RemoveArg.CommArg);
    fDsaSave = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    DirRemoveEntry(&RemoveArg,
                   &pRemoveRes);

    THClearErrors();

    // We ignore errors because we don't care if the operation failed with
    // a no-such-object.  Now try to rename the DsA from its current name
    // (ppDSAName) to the RDN we want.

    memset(&ModifyDNArg, 0, sizeof(ModifyDNArg));
    ModifyDNArg.pObject = *ppDSAName;
    ModifyDNArg.pNewRDN = &NameAttr;
    NameAttr.attrTyp = ATT_COMMON_NAME;
    NameAttr.AttrVal.valCount = 1;
    NameAttr.AttrVal.pAVal = &NameAttrVal;
    NameAttrVal.valLen = DSA_RDN_LEN * sizeof(WCHAR);
    NameAttrVal.pVal = (UCHAR*)wcDsaRdn;
    InitCommarg(&ModifyDNArg.CommArg);

    DirModifyDN(&ModifyDNArg,
                &pModifyDNRes);

    THClearErrors();

    // Again, we don't have many options in the way of error handling.  If
    // the operation didn't work, well, we'll try again next time we boot.

    pTHS->fDSA = fDsaSave;

    // Now free the DSA name that was passed in, and get the new version.
    free(*ppDSAName);
    DBGetHiddenRec(ppDSAName, &usnUnused);

}

void
ProcessDSAHeuristics (
        DWORD hClient,
        DWORD hServer,
        ENTINF *pEntInf
        )
/*++
  Description:
      Called with an entinf created by reading the DS enterprise config object.
      The ATT_DSA_HEURISTICS is read.  This routine parses that string and sets
      some parameters.

      Param 0: supress First/Last ANR
      Param 1: supress Last/First ANR
      Param 2: Enforce list_object rights if set to 1.  Otherwise this right
               will be ignored.
      Param 3: Force MAPI ResolveNames calls to attempt an exact match against
               the MAPI nickname property ( AKA samAccountName ).  If the match 
               is successful simply return that one entry, otherwise continue 
               with an ANR search returning all entries matched.  Default is to
               only do the ANR search and return all matching entries.
      Param 4: Cause LDAP modify operations to behave as if the permissive
               modify control was passed.  On a normal modify if the client 
               tries to delete an attribute that is not set on an object, or
               add a value that already exists on an attribute, an error will
               be returned.  With the permissive modify control the error is 
               ignored and not passed back to the client.
      Param 5: Controls when DSID's are returned when an operation encounters
               an error.  If this value is '1' then DSID's will be returned
               as long as the error is not a name error where different DSID's
               may reveal the existence of an object that is not visible to the
               client.  If this value is anything but '0' or '1' then DSID's will
               not be returned at all.      
      Param 6: Normally the only ldap requests a non-authenticated user is
               allowed to perform are rootDSE searches and binds.  If this
               parameter is set to '2' then non-authenticated users will be
               allowed to perform any ldap request.
      Param 7: If set to anything but '0' allow anonymous NspiBinds.  This is
               only necessary for certain Mac Outlook clients as far as I know.
               Otherwise we only allow authenticated clients.
      Param 8: If set to anything but '0' enable .NET support of userPassword.
               Otherwise, revert to win2k support of userPassword.
               
      Param 9: RESERVED see ValidateDsHeuristics().
      
      Param 10: If set to anything but '0' enable changing the objectGuid
                attribute.  Otherwise, disallow writes to objectGuid.

      Param 11: If set to anything but '0' then don't standardize (sort) ACEs in 
                security descriptors. This can be useful for backwards compatibility
                if user deploys applications that rely on fixed ACE order.
      
      No other params defined at this time.

      This is called in two ways.  First, called during startup to process the
      values that are on the object during startup.  Second, called by
      notificaiton if the enterprice config object changes.


--*/
{
    DWORD  i;
    DWORD  cchVal = 0;
    WCHAR *pVal = NULL;    //initialized to avoid C4701

    Assert(pTHStls->fDSA);
    Assert(pEntInf->ulFlags & ENTINF_FROM_MASTER);

    if(pEntInf->AttrBlock.attrCount) {
        // OK, some values specified.
        Assert(pEntInf->AttrBlock.attrCount == 1);
        Assert(pEntInf->AttrBlock.pAttr->attrTyp == ATT_DS_HEURISTICS);
        Assert(pEntInf->AttrBlock.pAttr->AttrVal.valCount == 1);

        cchVal =((pEntInf->AttrBlock.pAttr->AttrVal.pAVal->valLen) /
                 sizeof(WCHAR));

        pVal = (WCHAR *)pEntInf->AttrBlock.pAttr->AttrVal.pAVal->pVal;
    }

    if(cchVal > 0 && pVal[0] != L'0') {
        // Suppress first/last ANR
        gfSupressFirstLastANR=TRUE;
    }
    else {
        // Default behavior
        gfSupressFirstLastANR=FALSE;
    }


    if(cchVal > 1 && pVal[1] != L'0') {
        // Supress last/first ANR
        gfSupressLastFirstANR=TRUE;
    }
    else {
        // Default behaviour
        gfSupressLastFirstANR=FALSE;
    }

    if(cchVal > 2 && pVal[2] != L'0') {
        // We don't enforce the list_object rights unless we're told to.
        gbDoListObject = TRUE;
    }
    else {
        // Default behaviour
        gbDoListObject = FALSE;
    }

    if(cchVal > 3 && pVal[3] != L'0') {
        // We don't do nickname resolution unless we're told to.
        gulDoNicknameResolution = TRUE;
    }
    else {
        // Default behaviour
        gulDoNicknameResolution = FALSE;
    }

    if(cchVal > 4 && pVal[4] != L'0') {
        // we don't use fPermissiveModify by default on LDAP requests,
        // unless we are told to do so
        gbLDAPusefPermissiveModify = TRUE;
    }
    else {
        // Default behaviour
        gbLDAPusefPermissiveModify = FALSE;
    }

    if (cchVal > 5 && pVal[5] != L'0') {
	if (L'1' == pVal[5]) {
	    gulHideDSID = DSID_HIDE_ON_NAME_ERR;
	} else {
	    // To be on the safe side, if this isn't zero or one hide all DSID's.
	    gulHideDSID = DSID_HIDE_ALL;
	}
    } else {
	gulHideDSID = DSID_REVEAL_ALL;
    }

    if (cchVal > 6 && pVal[6] == '2') {
        // Allow anonymous operations over LDAP
        gulLdapBlockAnonymousOps = 0;
    }
    else {
        // Default behavior, do not allow anonymous ops over LDAP
        gulLdapBlockAnonymousOps = 1;
    }
    
    if (cchVal > 7 && pVal[7] != '0') {
        // If this Heuristic is set, allow anonymous Nspi binds.
        gbAllowAnonymousNspi = TRUE;
    }
    else {
        // Default behavior, don't allow anonymous Nspi binds.
        gbAllowAnonymousNspi = FALSE;
    }

    if (cchVal > 8 && pVal[8] != '0') {
        // enable userPassword support.
        gfUserPasswordSupport = TRUE;
    } else {
        // Default behavior, win2k userPassword support.
        gfUserPasswordSupport = FALSE;
    }

    //
    // Param 9 RESERVED see ValidateDsHeuristics().
    //

    if (cchVal > 10 && pVal[10] != '0') {
        // Allow clients to change objectGuid as in win2k.
        gbSpecifyGuidOnAddAllowed = TRUE;
    } else {
        // Default behavior, don't allow changes to objectGuid.
        gbSpecifyGuidOnAddAllowed = FALSE;
    }
    
    if (cchVal > 11 && pVal[11] != '0') {
        // If this Heuristic is set, don't standardize SDs.
        gfDontStandardizeSDs = TRUE;
    }
    else {
        // Default behavior, standardize (sort) ACEs in SDs.
        gfDontStandardizeSDs = FALSE;
    }
    
    //
    // Param 19 RESERVED see ValidateDsHeuristics().
    //
    
    return;
}



DWORD
ReadDSAHeuristics (
        THSTATE *pTHS
        )
/*++
  Description:
      Does two things
      1) register for notifications of changes on the DS enterprise config
          object.
      2) Read the heuristics on that object and call off to a parsing routine.

--*/
{
    DBPOS *pDB=NULL;
    DWORD  err;
    BOOL fCommit = FALSE;
    NOTIFYARG NotifyArg;
    NOTIFYRES *pNotifyRes=NULL;
    ATTRVAL    myAttrVal;
    ATTR       myAttr;
    ENTINF     myEntInf;
    ENTINFSEL  mySelection;
    FILTER     myFilter;
    SEARCHARG  mySearchArg;
    ULONG      dscode;

    if (DsaIsInstalling() || gAnchor.pDsSvcConfigDN == NULL) {
        // We don't read these during installation.  Why?  Well, for one,
        // gAnchor.pDsSvcConfigDN isn't set yet.
        // Also, if DS config object is missing, then bail.
        return 0;
    }

    // Set the pointer to the function to prepare to impersonate.
    NotifyArg.pfPrepareForImpersonate = DirPrepareForImpersonate;

    // Set the pointer for the callback to receive data.
    NotifyArg.pfTransmitData = ProcessDSAHeuristics;

    NotifyArg.pfStopImpersonating = DirStopImpersonating;

    // Tell him my ID.
    NotifyArg.hClient = 0;

    memset(&mySearchArg, 0, sizeof(mySearchArg));
    mySearchArg.pObject = gAnchor.pDsSvcConfigDN;
    mySearchArg.choice = SE_CHOICE_BASE_ONLY;
    mySearchArg.pFilter = &myFilter;
    mySearchArg.pSelection = &mySelection;
    InitCommarg(&mySearchArg.CommArg);

    memset (&myFilter, 0, sizeof (myFilter));
    myFilter.pNextFilter = FALSE;
    myFilter.choice = FILTER_CHOICE_ITEM;
    myFilter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    mySelection.attSel=EN_ATTSET_LIST;
    mySelection.AttrTypBlock.attrCount = 1;
    mySelection.AttrTypBlock.pAttr = &myAttr;
    mySelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    myAttr.attrTyp = ATT_DS_HEURISTICS;
    myAttr.AttrVal.valCount = 0;

    // This is a notification search.  Register it as such.
    Assert(!pTHS->pDB);
    dscode =  DirNotifyRegister( &mySearchArg, &NotifyArg, &pNotifyRes);
    // dscode may be non-zero in case ds service config object is absent
    // We have already logged an error for that.

    DBOpen( &pDB );
    Assert(pTHS->fDSA);
    err = DIRERR_INTERNAL_FAILURE;
    __try {
        // First, find the ds service object.
        err = DBFindDSName( pDB, gAnchor.pDsSvcConfigDN);
        if (err) {
            // Object is not there. That's ok. Pretend the dsHeuristics 
            // value is absent and use the default.
            DPRINT1(0, "DS Service object %ws is not found. Using default dsHeuristics value.\n", 
                    gAnchor.pDsSvcConfigDN->StringName);
            err = DB_ERR_NO_VALUE;
        }
        else {
            // Now read the heuristics.
            err = DBGetAttVal(
                    pDB,
                    1,                      // get one value
                    ATT_DS_HEURISTICS,
                    0,
                    0,
                    &myAttrVal.valLen,
                    (PUCHAR *)&myAttrVal.pVal
                    );
        }

        switch (err) {
        case 0:
            // Make an entinf and call the helper routine.
            myEntInf.pName = NULL;
            myEntInf.ulFlags = ENTINF_FROM_MASTER;
            myEntInf.AttrBlock.attrCount = 1;
            myEntInf.AttrBlock.pAttr = &myAttr;
            myAttr.attrTyp = ATT_DS_HEURISTICS;
            myAttr.AttrVal.valCount = 1;
            myAttr.AttrVal.pAVal = &myAttrVal;

            ProcessDSAHeuristics(0, 0, &myEntInf);
            break;

        case DB_ERR_NO_VALUE:
            // No value.  That's ok, it's no error.
            err = 0;
            // Make an entinf with no value and call the helper routine.  This
            // will set the heuristics to default values.
            myEntInf.pName = NULL;
            myEntInf.ulFlags = ENTINF_FROM_MASTER;
            myEntInf.AttrBlock.attrCount = 0;
            myEntInf.AttrBlock.pAttr = NULL;

            ProcessDSAHeuristics(0, 0, &myEntInf);
            break;

        default:
            // Huh? return the error.
            break;
        }
        fCommit = TRUE;
    }
    __finally {
        DBClose( pDB, fCommit );
    }

    return err;
}


void
UpdateAnchorWithInvocationID(
    IN  THSTATE *   pTHS
    )
/*++

Routine Description:

    Replace the invocation ID cached in gAnchor with that from the given
    thread state.

Arguments:

    pTHS (IN)

Return Values:

    None.  Throws exception on catastrophic failure.

--*/
{
    UUID * pNewInvocationID;

    // Allocate memory for the new invocation ID.
    pNewInvocationID = (UUID *) malloc(sizeof(*pNewInvocationID));
    if (NULL == pNewInvocationID) {
        MemoryPanic(sizeof(*pNewInvocationID));
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0, DSID(FILENO, __LINE__),
                       DS_EVENT_SEV_MINIMAL);
    }

    *pNewInvocationID = pTHS->InvocationID;

    // Update the anchor.
    EnterCriticalSection(&gAnchor.CSUpdate);

    if (NULL != gAnchor.pCurrInvocationID) {
        DELAYED_FREE(gAnchor.pCurrInvocationID);
    }

    gAnchor.pCurrInvocationID = pNewInvocationID;
    LeaveCriticalSection(&gAnchor.CSUpdate);
}

// Make a list of the DNTs of the ancestors of the undeletable objects

ULONG
MakeProtectedAncList(
    ULONG *pUnDeletableDNTs,
    unsigned UnDeletableNum,
    DWORD **ppList,
    DWORD *pCount
    )
{
    DBPOS *pDBTmp;
    ULONG err = 0;
    DWORD *pList = NULL, Count = 0, Allocated = 0, i, j;
    DWORD dntNC;

    *ppList = NULL;
    *pCount = 0;

    // If not yet installed, nothing to do.

    if ( DsaIsInstalling() ) {
        return 0;
    }

    // Make a list of all the ancestors of the UnDeletable List
    // Only ancestors within the NC are kept.
    // Order is not important

    DBOpen (&pDBTmp);
    __try
    {
        for( i = 0; i < UnDeletableNum; i++ ) {
            // PREFIX: dereferencing uninitialized pointer 'pDBTmp'
            //         DBOpen returns non-NULL pDBTmp or throws an exception
            if  (err = DBFindDNT (pDBTmp, pUnDeletableDNTs[i])) {
                LogUnhandledError(err);
                __leave;
            }
            dntNC = pDBTmp->NCDNT;

            while (1) {
                BOOL fFound = FALSE;

                // Position on parent
                if  (err = DBFindDNT (pDBTmp, pDBTmp->PDNT)) {
                    LogUnhandledError(err);
                    __leave;
                }

                // We only protect ancestors within the same NC
                // NC heads and their ancestors are protected separately
                if ( (pDBTmp->NCDNT != dntNC) || (pDBTmp->PDNT == ROOTTAG) ) {
                    break;
                }

                // Have we already cached this DNT?
                // PERF: O(n^2)
                for( j = 0; j < Count; j++ ) {
                    if (pList[j] == pDBTmp->DNT) {
                        fFound = TRUE;
                        break;
                    }
                }
                if (!fFound) {
                    if (Count == 0) {
                        Allocated = 32;
                        pList = malloc(Allocated * sizeof(ULONG));
                    } else if (Count == Allocated) {
                        DWORD* pListT;
                        Allocated *= 2;
                        pListT = realloc( pList, Allocated * sizeof(ULONG) );
                        if (!pListT) {
                            free(pList);
                        }
                        pList = pListT;
                    }
                    if (!pList) {
                        MemoryPanic(Allocated * sizeof(ULONG));
                        err = ERROR_NOT_ENOUGH_MEMORY;
                        __leave;
                    }
                    pList[Count++] = pDBTmp->DNT;
                }
            } // while

        } // for
    }
    __finally
    {
        DBClose (pDBTmp, (err == 0));
        if (err) {
            if (pList) {
                free(pList);
            }
        } else {
            *ppList = pList;
            *pCount = Count;
        }
    }

    return err;
}



/* 
   The following function runs as a background thread.  It does
   the following things: 
   1) it compares the ntMixedDomain attribute on the domain DNS 
   object and the one on the corresponding crossref object, and 
   updates the ntMixedDomain on crossref if they are not equal; 
   2) if it is pdc, it compares the forest version with the domain 
   version, and updates the domain version if the forest version
    > domain version.            
   3) if it is pdc, it will keep the domain version on crossRef
   consistent with the domain version on domain-DNS
   4) if it is pdc, and if the domain version is >= Whistler,
   it will make ntMixedDomain=0 on domain DNS.
   
   If there is any error, this thread will come back in 15 mins. */

void
BehaviorVersionUpdate(void * pv,
                      void ** ppvNext,
                      DWORD * pcSecsUntilNextIteration )
{
    THSTATE *pTHS = pTHStls;
    DBPOS * pDB;
    DWORD err;
    DWORD masterMixedDomain, copyMixedDomain, tempMixedDomain;
    DWORD forestVersion, domainVersion, copyDomainVersion;
    CROSS_REF *cr = NULL;
    COMMARG CommArg;
    BOOL fCommit;
    MODIFYARG ModifyArg;
    ATTRVAL Val;
    PVOID dwEA;
    ULONG dwException, ulErrorCode, dsid;


    // from mdmod.c
    DWORD VerifyNoOldDC(THSTATE * pTHS, LONG lNewVersion, BOOL fDomain, PDSNAME *ppDSA);
      
    InitCommarg(&CommArg);
    fCommit = FALSE;
    
    __try{
        
        SYNC_TRANS_WRITE();  //open a transaction
        __try{
            
            //check for PDC
            if (err = CheckRoleOwnership(pTHS, gAnchor.pDomainDN, gAnchor.pDomainDN) )
            {
               if(pTHS->errCode==referralError) {
                    // this DC is not the PDC
                    err = 0;
               }
               dsid = DSID(FILENO, __LINE__);
               __leave;
            }

            // we are DSA, bypass security check
            pTHS->fDSA = TRUE;

            if (err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN))
            {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
    
            // read the ntMixedDomain attribute from domain-DNS
            err = DBGetSingleValue( pTHS->pDB, 
                                    ATT_NT_MIXED_DOMAIN, 
                                    &masterMixedDomain,
                                    sizeof(masterMixedDomain),
                                    NULL );
            
            if (err) {
                // the attribute is expected to be 
                // on domain-DNS object
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }

            // read the domain version on domain-DNS
            err = DBGetSingleValue( pTHS->pDB, 
                                    ATT_MS_DS_BEHAVIOR_VERSION, 
                                    &domainVersion,
                                    sizeof(domainVersion),
                                    NULL );
            
            if (DB_ERR_NO_VALUE == err) {
                err = 0;
                domainVersion = 0;    //default is 0
            }
            else if (err) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }


            cr = FindBestCrossRef(gAnchor.pDomainDN, &CommArg);
            if (!cr) {
                err = ERROR_DS_INTERNAL_FAILURE;
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
    
            if (err = DBFindDSName(pTHS->pDB, cr->pObj))
            {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
            
            // read ntMixedDomain on the cross-ref object
            err = DBGetSingleValue( pTHS->pDB, 
                                    ATT_NT_MIXED_DOMAIN, 
                                    &copyMixedDomain,
                                    sizeof(copyMixedDomain),
                                    NULL );
            
            if (DB_ERR_NO_VALUE == err) {
                err = 0;
                copyMixedDomain = 1;    //default is 1(mixed)
            }
            else if (err) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            
            }
            
            // read domain version on cross-ref
            err = DBGetSingleValue( pTHS->pDB, 
                                    ATT_MS_DS_BEHAVIOR_VERSION, 
                                    &copyDomainVersion,
                                    sizeof(copyDomainVersion),
                                    NULL );

            if (DB_ERR_NO_VALUE == err) {
                err = 0;
                copyDomainVersion = 0;    //default is 0
            }
            else if (err) {
                dsid = DSID(FILENO, __LINE__);
                __leave;

            }

            // get the forest version
            if (err = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN))
            {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
    
            err = DBGetSingleValue( pTHS->pDB, 
                                    ATT_MS_DS_BEHAVIOR_VERSION,
                                    &forestVersion,
                                    sizeof(forestVersion),
                                    NULL );
    
            if (DB_ERR_NO_VALUE == err) {
                forestVersion = 0; //default
                err = 0;
            }
            else if (err) {
                dsid = DSID(FILENO, __LINE__);
                __leave;
            }
    
            
            // if the ntMixedDomain attribute on cross-ref object is 
            // not the same as the master copy, update it.

            if ( masterMixedDomain != copyMixedDomain ) {
                
                // check if all the DC are whistler or greater,
                // don't touch anything on crossRef if not.
                // This is for backward compatibility issue.
                if (VerifyNoOldDC(pTHS,DS_BEHAVIOR_WIN_DOT_NET,FALSE, NULL))
                {
                    err = 0;
                }
                else {
                    memset(&ModifyArg,0,sizeof(MODIFYARG));
                    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
                    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_NT_MIXED_DOMAIN;
                    ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
                    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &Val;
                    Val.valLen = sizeof(masterMixedDomain);
                    Val.pVal = (UCHAR * FAR) &masterMixedDomain;
                    InitCommarg(&(ModifyArg.CommArg));
                    ModifyArg.pObject = cr->pObj;
                    ModifyArg.count = 1;
        
                    if (err = DBFindDSName(pTHS->pDB, cr->pObj))
                    {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
    
                    ModifyArg.pResObj = CreateResObj(pTHS->pDB, ModifyArg.pObject);
        
                    err = LocalModify(pTHS,&ModifyArg);
                    
                    if (err) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                }
            }
                
            // if the one on cross-ref object is not the same
            // as the master copy, update it.
        
            if ( domainVersion != copyDomainVersion ) {

                // check if all the DC are whistler or greater,
                // don't touch anything on crossRef if not.
                // This is for backward compatibility issue..
                if (VerifyNoOldDC(pTHS,DS_BEHAVIOR_WIN_DOT_NET,FALSE, NULL))
                {
                   err = 0;
                }
                else {
                    memset(&ModifyArg,0,sizeof(MODIFYARG));
                    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
                    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_MS_DS_BEHAVIOR_VERSION;
                    ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
                    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &Val;
                    Val.valLen = sizeof(domainVersion);
                    Val.pVal = (UCHAR * FAR) &domainVersion;
                    InitCommarg(&(ModifyArg.CommArg));
                    ModifyArg.pObject = cr->pObj;
                    ModifyArg.count = 1;
            
                    if (err = DBFindDSName(pTHS->pDB, cr->pObj))
                    {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                          
                    ModifyArg.pResObj = CreateResObj(pTHS->pDB, ModifyArg.pObject);
            
                    err = LocalModify(pTHS,&ModifyArg);
                    
                    if (err) {
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
                }
            }
            
        
            // if forest version is higher than domain version
            // let's raise the domain version.
        
            if (forestVersion > domainVersion ) {
                memset(&ModifyArg,0,sizeof(MODIFYARG));
                ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
                ModifyArg.FirstMod.AttrInf.attrTyp = ATT_MS_DS_BEHAVIOR_VERSION;
                ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
                ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &Val;
                Val.valLen = sizeof(forestVersion);
                Val.pVal = (UCHAR * FAR) &forestVersion;
                InitCommarg(&(ModifyArg.CommArg));
                ModifyArg.pObject = gAnchor.pDomainDN;
                ModifyArg.count = 1;
        
                if (err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN))
                {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
        
                ModifyArg.pResObj = CreateResObj(pTHS->pDB, ModifyArg.pObject);
        
                err = LocalModify(pTHS,&ModifyArg);
        
                if (err) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DS_DOMAIN_BEHAVIOR_VERSION_RAISED,
                         szInsertDN(gAnchor.pDomainDN),
                         szInsertUL(domainVersion),
                         szInsertUL(forestVersion) );
        
        
            }
        
        
            // if domain version is already >= Whistler,
            // and the current domain is still in mixed mode.
        
            if ( domainVersion>=DS_BEHAVIOR_WIN_DOT_NET
                 && masterMixedDomain ) {
                tempMixedDomain = 0;
                memset(&ModifyArg,0,sizeof(MODIFYARG));
                ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
                ModifyArg.FirstMod.AttrInf.attrTyp = ATT_NT_MIXED_DOMAIN;
                ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
                ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &Val;
                Val.valLen = sizeof(tempMixedDomain);
                Val.pVal = (UCHAR * FAR) &tempMixedDomain;
                InitCommarg(&(ModifyArg.CommArg));
                ModifyArg.pObject = gAnchor.pDomainDN;
                ModifyArg.count = 1;
        
                if (err = DBFindDSName(pTHS->pDB, gAnchor.pDomainDN))
                {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }

                ModifyArg.pResObj = CreateResObj(pTHS->pDB, ModifyArg.pObject);
        
                err = LocalModify(pTHS,&ModifyArg);
        
                if (err) {
                    dsid = DSID(FILENO, __LINE__);
                    __leave;
                }
        
            }
            
            fCommit = TRUE;
        }

        __finally{
           CLEAN_BEFORE_RETURN(err);

    
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwEA,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        err = ulErrorCode;
    }



    if (err) {
        // an error has occured, 
        // come back in 15 minutes(900 seconds).
        DPRINT2(0,"BehaviorVersionUpdate: An error(%x, DSID=%x) occured, will be back in 15 minutes.\n", err, dsid);

        InsertInTaskQueueDamped(TQ_BehaviorVersionUpdate, 
                                NULL,
                                900,  //15 mins
                                900, 
                                TaskQueueNameMatched, 
                                NULL);
        
    }
    
    

    return;
}


void
ValidateDsaDomain(void * pv,
                  void ** ppvNext,
                  DWORD * pcSecsUntilNextIteration)

/*++

Routine Description:

    Verify that the Dsa object has proper values of attributes.

    Add the MS_DS_HAS_DOMAIN_NCS attribute to the current DSA object
    if it is not already present.  This is set in the dit for new installs, but
    may not be present when upgrading from Whistler Beta 3 and earlier builds.

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    DBPOS *pDBTmp;
    BOOL fCommit = FALSE;
    PVOID dwEA;
    ULONG dwException, dsid;

    // If not yet installed, nothing to do.
    if ( DsaIsInstalling() ) {
        // pcSecsUntilNextIteration is TASKQ_DONT_RESCHEDULE by default.
        return;
    }

    Assert( gAnchor.pDomainDN );
    Assert( gAnchor.pDSADN );

    __try {
        // Populate the msds-hasdomainncs attribute
        // This attribute was added to the schema after Whistler Beta 3.
        // We make this check on every boot to increase our
        // chances of catch old beta's being upgraded.
        //
        DBOpen (&pDBTmp);
        __try
        {
            if (dwErr = DBFindDSName(pDBTmp, gAnchor.pDSADN))
            {
                __leave;
            }

            if (!DBHasValues(pDBTmp, ATT_MS_DS_HAS_DOMAIN_NCS)) {
                if (dwErr = DBAddAttVal(pDBTmp, ATT_MS_DS_HAS_DOMAIN_NCS,
                                        gAnchor.pDomainDN->structLen, gAnchor.pDomainDN))
                {
                    __leave;
                }

                if (dwErr = DBRepl( pDBTmp, FALSE, 0, NULL, META_STANDARD_PROCESSING ))
                {
                    __leave;
                }

                DPRINT1( 0, "Updated local DSA with domain %ws.\n",
                         gAnchor.pDomainDN->StringName );

                fCommit = TRUE;
                Assert( !dwErr );
            }
        }
        __finally
        {
            DBClose (pDBTmp, fCommit);
        }

        Assert( !dwErr || !fCommit );
    }
    __except(GetExceptionData(GetExceptionInformation(),
                              &dwException,
                              &dwEA,
                              &dwErr,
                              &dsid)) {
        if (dwErr == 0) {
            Assert("!Error is not set");
            dwErr = ERROR_DS_UNKNOWN_ERROR;
        }
        HandleDirExceptions(dwException, dwErr, dsid);
    }
    
    if (dwErr != 0) {
        // update failed, retry in 60 seconds
        *pcSecsUntilNextIteration = 60;
    }
    else {
        // success
        *pcSecsUntilNextIteration = TASKQ_DONT_RESCHEDULE;
    }
} /* validateDsaDomain */

VOID
DsStartOrStopNspisInterface( VOID )
/*++

Routine Description:

    If the GC status of the DC is changed, or the exchange config object
    referenced in gAnchor.pExchangeDN is added or deleted, call this function
    to determine whether to start or stop the Nspis interface based on
    the current config.
    
    Only to be called if there is a change of state.  Not at startup.
    
Arguments:

    N/A
    
Return Value:

    N/A
    

--*/
{
    DWORD err;
    BOOL fLoadMapi = GetRegistryOrDefault(MAPI_ON_KEY,
                                          (gAnchor.pExchangeDN && gAnchor.fAmGC),
                                           1);

    if (gbLoadMapi && (!fLoadMapi)) { 

        // The exchange config object has been deleted or this DC is no
        // longer a GC, and there's no registry overide. Shut down NSPI.
        DPRINT(0, "Disable NSPI\n");
        MSRPC_UnregisterEndpoints(nspi_ServerIfHandle);
        gbLoadMapi = FALSE;

    } else if ((!gbLoadMapi) && fLoadMapi) {

        // An Exchange config object has been added, or this DC has become
        // a GC, and there's no registry overide.  Start the NSPI interface.
        DPRINT(0, "Enable NSPI\n");
        gbLoadMapi = TRUE;
        InitRPCInterface(nspi_ServerIfHandle);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdname.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdname.c
//
//--------------------------------------------------------------------------


#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <sddl.h>                       // For SID conversion routines.

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB     "MDNAME:"            // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDNAME


NAMING_CONTEXT * CheckForNCExit(THSTATE *pTHS,
                                NAMING_CONTEXT * pNC,
                                DSNAME * pObj);

ATTRBLOCK RootDNB = {0, NULL};
ATTRBLOCK * gpRootDNB= &RootDNB;


unsigned
GenAutoReferral(THSTATE *pTHS,
                ATTRBLOCK *pTarget,
                WCHAR **ppDNS);

DWORD
DoExtendedNameRes (
        THSTATE  *pTHS,
        ATTCACHE *pAC,
        DSNAME   *pTempDN,
        GUID     *pGuid
        )
/*++
  Description:
      Look through the values of the pAC attribute (which is a distname binary)
      for a value that has the binary portion equal to the guid passed in.  When
      found, get the guid from the name portion and put it in pTemp.

  Parameters:
      pTHS - thread state
      pAC  - attribute to read.  Expect values are ATT_WELL_KNOWN_OBJECTS and
             ATT_OTHER_WELL_KNOWN_OBJECTS.
      pTempDN - DN buffer.  Size is at least DSNameSizeFromLen(0).  On success,
             the found objects GUID is put into this as a GUID only name.
      pGuid - The guid we're looking for.
--*/
{
    SYNTAX_DISTNAME_BINARY *pVal;
    DWORD   iVal;
    DWORD   err2 = 0, len;
    DWORD   fFound = FALSE;
    
    iVal = 0;
    while ( !(err2 || fFound))  {
        iVal++;
        pVal = NULL;
        
        err2 = DBGetAttVal_AC(pTHS->pDB,
                              iVal,
                              pAC,
                              0,
                              0,
                              &len,
                              (UCHAR **) &pVal);
        
        if(!err2 &&
           PAYLOAD_LEN_FROM_STRUCTLEN(DATAPTR(pVal)->structLen) == sizeof(GUID) &&
           !memcmp(pGuid,
                   DATAPTR(pVal)->byteVal,
                   sizeof(GUID)) ) {
            fFound = TRUE;
            memset(pTempDN, 0, DSNameSizeFromLen(0));
            pTempDN->Guid = NAMEPTR(pVal)->Guid;
            pTempDN->structLen = DSNameSizeFromLen(0);
        }
        THFreeEx(pTHS, pVal);
    }

    // Either we found the object with no error, or we didn't find the object
    // and errored out.
    Assert((fFound && !err2) || (!fFound && err2));
    
    if(fFound) {
        __try {
            err2 = DBFindDSName(pTHS->pDB, pTempDN);
        }
        __except (HandleMostExceptions(GetExceptionCode())) {
            err2 = DIRERR_OBJ_NOT_FOUND;
        }
    }
    
    return err2;
}

/*++ DoNameRes - locates an object by name
 *
 * Given the name of a purported DS object, this routine either positions
 * to the object in the local database, returns a referral to another DSA
 * that should have a better chance of locating the object.
 *
 * INPUT:
 *    dwFlags    - values and meanings:
 *        NAME_RES_PHANTOMS_ALLOWED: successful return even if the object
 *                 being resolved exists locally only as a phantom.  Used
 *                 by some flat-search code.
 *        NAME_RES_VACANCY_ALLOWED: This should always succeed, either finding
 *                 a current record or just returning a faked up resobj
 *                 if no such record exists.
 *    queryOnly  - TRUE if a read/only copy of the object is acceptable
 *    childrenNeeded - TRUE if we must resolve to a copy of the object
 *                     where the children of that object are locally available.
 *    pObj       - pointer to DSNAME of purported object
 *    pComArg    - pointer to common arguments
 *    pComRes    - pointer to common results set
 *    ppResObj   - pointer to pointer to be filled in
 * OUTPUT:
 *    *ppResObj filled in with a pointer to a RESOBJ structure that includes
 *    pre-fetched information about the object.  Note that the pObj field of
 *    the ResObj will be filled in with the pObj argument itself, and that
 *    that DSNAME will have its GUID and SID fields filled out completely.
 * RETURN VALUE:
 *    error code, as set in THSTATE
 */
int DoNameRes(THSTATE *pTHS,
              DWORD dwFlags,
              DSNAME *pObj,
              COMMARG *pComArg,
              COMMRES *pComRes,
              RESOBJ **ppResObj)
{
    DWORD err;
    ULONG it, isdel, vallen;
    UCHAR *pVal;
    NAMING_CONTEXT * pNC, *pSubNC;
    CROSS_REF * pCR;
    ATTRBLOCK *pObjB=NULL;
    ATTRTYP msoc;
    BOOL fPresentButInadequate = FALSE;
    BOOL fNDNCObject = FALSE;
    BOOL fUninstantiatedSubref = FALSE;

    /* catch ill-formed DSNAMEs */
    Assert(pObj->NameLen == 0 || pObj->StringName[pObj->NameLen] == L'\0');
    Assert(pObj->NameLen == 0 || pObj->StringName[pObj->NameLen-1] != L'\0');
    Assert(pObj->structLen >= DSNameSizeFromLen(pObj->NameLen));

    __try {
        *ppResObj = NULL;
        err = DBFindDSName(pTHS->pDB, pObj);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    if((err == ERROR_DS_OBJ_NOT_FOUND) && 
       (pObj->NameLen) &&
       (!pObj->SidLen) &&
       (!fNullUuid(&(pObj->Guid)))) {
        // We were given a name with a guid AND a string, but failed to find the
        // object.  In this case, the guid may be a well-known-guid and the
        // string the dn of an object with a wellKnownObjects attribute.
        DSNAME *pTempDN;
        DWORD   err2;
        ATTCACHE *pAC = SCGetAttById(pTHS, ATT_WELL_KNOWN_OBJECTS);
        
        if(pAC) {
            pTempDN = THAllocEx(pTHS, pObj->structLen);
            memcpy(pTempDN, pObj, pObj->structLen);
            memset(&pTempDN->Guid, 0, sizeof(GUID));
            __try{
                err2 = DBFindDSName(pTHS->pDB, pTempDN);
            }
            __except (HandleMostExceptions(GetExceptionCode())) {
                err2 = DIRERR_OBJ_NOT_FOUND;
            }
            
            if(!err2) {
                // Found something by string name.  Now, read the 
                // wellKnownObjects  property, looking for something with the
                // correct GUID.
                if(!DoExtendedNameRes(pTHS, pAC, pTempDN, &pObj->Guid)) {
                    // found an object through indirection.  Use it.
                    Assert(pTempDN->structLen <= pObj->structLen);
                    memcpy(pObj, pTempDN, pTempDN->structLen);
                    err = 0;
                }
                else {
                    pAC = SCGetAttById(pTHS, ATT_OTHER_WELL_KNOWN_OBJECTS);
                    if(pAC && !DoExtendedNameRes(pTHS,
                                                 pAC,
                                                 pTempDN,
                                                 &pObj->Guid)) { 
                        // found an object through indirection. Use it.
                        Assert(pTempDN->structLen <= pObj->structLen);
                        memcpy(pObj, pTempDN, pTempDN->structLen);
                        err = 0;
                    }
                }
            }
            THFreeEx(pTHS, pTempDN);
        }
    }

    if (!err) {
        // found an object, let's see if it's good enough
        DBFillResObj(pTHS->pDB, pObj, &msoc, &it, &isdel);
        
        if(isdel && !pComArg->Svccntl.makeDeletionsAvail) {
            // If we're only looking for live objects and this isn't one,
            // bail out now.
            goto NotFound;
        }

        if (it & IT_UNINSTANT) {
            // The object is not instantiated.  Do the phantom check.
            fUninstantiatedSubref = TRUE;
            if (dwFlags &
                (NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED)) {
                goto DoPhantomCheck;
            }
            else {
                goto NotFound;
            }
        }

        if(pComArg->Svccntl.dontUseCopy &&
           !(it & IT_WRITE))                {
            // it was not writable and they wanted only writable objects.
            fPresentButInadequate = TRUE;
            goto NotFound;
        }

        if(dwFlags & NAME_RES_GC_SEMANTICS){
            // This is a GC port operation, and we want GC port operations
            // to be completely unaware of NDNCs.
            if(gAnchor.pNoGCSearchList &&
               bsearch(((it & IT_NC_HEAD) ?  
                          &pTHS->pDB->DNT :
                          &pTHS->pDB->NCDNT), // The Key to search for.
                       gAnchor.pNoGCSearchList->pList, // sorted array to search.
                       gAnchor.pNoGCSearchList->cNCs, // number of elements in array.
                       sizeof(ULONG), // sizeof each element in array.
                       CompareDNT) ){
                // This was one of the NCs weren't not supposed to
                // operate on objects from.
                fPresentButInadequate = TRUE;
                fNDNCObject = TRUE;
                goto NotFound;
            }
        }

        fPresentButInadequate = FALSE;

        *ppResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        if (dwFlags & NAME_RES_IMPROVE_STRING_NAME) {
       
        err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_OBJ_DIST_NAME,
                              0,
                              0,
                              &vallen,
                              (CHAR **)&((*ppResObj)->pObj));
            if (err) {
                // I don't know what happened, but it isn't good.
                goto NotFound;
            }
        }
        else {
            // input string name (if any) is good enough
            (*ppResObj)->pObj = pObj;
        }
        (*ppResObj)->DNT = pTHS->pDB->DNT;
        (*ppResObj)->PDNT = pTHS->pDB->PDNT;
        (*ppResObj)->NCDNT = (it & IT_NC_HEAD)
                             ? pTHS->pDB->DNT : pTHS->pDB->NCDNT;
        (*ppResObj)->InstanceType = it;
        (*ppResObj)->IsDeleted = isdel;
        (*ppResObj)->MostSpecificObjClass = msoc;

        // Set flags and return
        pComRes->aliasDeref = FALSE;
        return 0;
    }

    if (err == DIRERR_NOT_AN_OBJECT &&
        (dwFlags & NAME_RES_PHANTOMS_ALLOWED)) {

        // Since we didn't call DBFillResObj above, fill in the guid and sid of the
        // phantom here.
        DBFillGuidAndSid( pTHS->pDB, pObj );

        // OK, we found a phantom and they said that phantoms were ok as search
        // roots. Before we go on with this, make sure there is some naming
        // context under this phantom.
    DoPhantomCheck:

        err = DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE);
        if (err) {
            SetNamErrorEx(NA_PROBLEM_BAD_NAME,
                          pObj,
                          DIRERR_BAD_NAME_SYNTAX,
                          err);
            return (pTHS->errCode);
        }
        if (  (dwFlags & NAME_RES_VACANCY_ALLOWED)
            || fHasDescendantNC(pTHS, pObjB, pComArg)) {

            // OK, there is either something under this phantom, or we
            // don't care.  Go for it.
            pComRes->aliasDeref = FALSE;
            // we don't need this anymore...
            FreeBlockName(pObjB);

            *ppResObj = THAllocEx(pTHS, sizeof(RESOBJ));
            (*ppResObj)->pObj = pObj;
            (*ppResObj)->DNT = pTHS->pDB->DNT;
            (*ppResObj)->PDNT = pTHS->pDB->PDNT;
            (*ppResObj)->NCDNT = pTHS->pDB->NCDNT;
            (*ppResObj)->InstanceType = fUninstantiatedSubref ? it : IT_UNINSTANT;
            (*ppResObj)->IsDeleted = !fUninstantiatedSubref;
            (*ppResObj)->MostSpecificObjClass = CLASS_TOP;

            return 0;
        }
    }


 NotFound:

    if (err == ERROR_DS_DUPLICATE_ID_FOUND) {
         // Search failed as there are duplicate unique ids. Don't
         // try to recover; let the caller know there is a problem
         SetNamError(NA_PROBLEM_NO_OBJECT,
                     pObj,
                     err);
         return pTHS->errCode;
    }

    if (dwFlags & NAME_RES_VACANCY_ALLOWED) {
        // There's no object there, but that's ok.
        // Create a null resobj and send it back.
        *ppResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        (*ppResObj)->pObj = pObj;
        (*ppResObj)->DNT = INVALIDDNT;
        (*ppResObj)->PDNT = INVALIDDNT;
        (*ppResObj)->NCDNT = INVALIDDNT;
        (*ppResObj)->InstanceType = IT_UNINSTANT;
        (*ppResObj)->IsDeleted = TRUE;
        (*ppResObj)->MostSpecificObjClass = CLASS_TOP;
        return 0;
    }

    if (pObj->NameLen == 0) {

        // Failed a search for <SID=...>; try to generate a referral
        if(pObj->SidLen && fNullUuid(&pObj->Guid)) {
            DWORD cbDomainSid;
            PSID pDomainSid = NULL;
            CROSS_REF *FindCrossRefBySid(PSID pSID);

            // Extract the domain portion of the SID and locate a crossRef
            cbDomainSid = pObj->SidLen;
            pDomainSid = THAllocEx(pTHS, cbDomainSid);
            if (GetWindowsAccountDomainSid(&pObj->Sid, pDomainSid, &cbDomainSid)
                && (NULL != (pCR = FindCrossRefBySid(pDomainSid)))) {
                THFreeEx(pTHS, pDomainSid);
                return GenCrossRef(pCR, pObj);
            }
            THFreeEx(pTHS, pDomainSid);
        }

        // If we don't have a string name, we're searching only on GUID.
        // We haven't found an object with the requested GUID, but that
        // may or may not tell us much.  If this server is a Global
        // Catalog server then we have an exhaustive list of all objects
        // in the enterprise, so we can state that the object does not
        // exist.  If we're not a GC, though, we need to refer to a GC
        // in order to answer the question, because the GUID could belong
        // to an object in another NC.
        // We also return an error if there was no GUID in the object, because
        // then the DSNAME was that of the root (no name, no guid), and
        // you can't resolve the root as a base object unless you set
        // the PHANTOMS_ALLOWED flag, in which case you would have already
        // succeeded.
        if ((gAnchor.fAmGC && !fPresentButInadequate)
            || fNullUuid(&pObj->Guid)) {
            SetNamError(NA_PROBLEM_NO_OBJECT,
                        NULL,
                        DIRERR_OBJ_NOT_FOUND);
        }
        else {
            // The name has a GUID, and either I'm not a GC and couldn't
            // find it, or I am a GC but not called through the GC port
            // and the copy I found was only partial.
            GenSupRef(pTHS, pObj, gpRootDNB, pComArg, NULL);
        }
        return pTHS->errCode;
    }

    // We might have already blockified the name
    if(!pObjB) {
        err = DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE);
        if (err) {
            SetNamErrorEx(NA_PROBLEM_BAD_NAME,
                          pObj,
                          DIRERR_BAD_NAME_SYNTAX,
                          err);
            return (pTHS->errCode);
        }
    }
    pNC = FindNamingContext(pObjB, pComArg);

    if(pNC && !fNDNCObject && (pSubNC = CheckForNCExit(pTHS, pNC, pObj)) == NULL) {
        // We found the best candidate NC that is held on this server,
        // and found that there was no NC exit point between that candidate
        // NC and the purported object, which means that if the object
        // exists it must be in this NC.  However, we already know that the
        // object does not exist on this server, which means that the object
        // does not exist at all.
        DSNAME *pBestMatch=NULL;

        DBFindBestMatch(pTHS->pDB, pObj, &pBestMatch);

        SetNamError(NA_PROBLEM_NO_OBJECT,
                    pBestMatch,
                    DIRERR_OBJ_NOT_FOUND);

        THFreeEx(pTHS, pBestMatch);
        return (pTHS->errCode);
    }

    if(fNDNCObject){
        // BUGBUG Basically we bail out here pretending we don't have the
        // the object. However the correct thing to do is generate a referral
        // to the NDNC for port 389.
        SetNamError(NA_PROBLEM_NO_OBJECT,
                    NULL,
                    DIRERR_OBJ_NOT_FOUND);
        
    }

    // If we're here it's either because we hold no NC related in any way
    // to the purported object, or we hold an NC above the one in which
    // the purported object would reside.  While we could generate a
    // subref in the latter case, we have decided to only maintain information
    // for cross refs, and to generate those instead of subrefs.

    // can we find a decent cross ref?
    if (pCR = FindCrossRef(pObjB, pComArg)) {
        // yes, so build the thing

        GenCrossRef(pCR, pObj);
    }
    else {
        // no, so wimp out entirely
        GenSupRef(pTHS, pObj, pObjB, pComArg, NULL);
    }

    // we don't need this anymore...
    FreeBlockName(pObjB);

    return (pTHS->errCode);

}

/*++ CreateResObj
 *
 *  This routine creates and fills in a RESOBJ structure for the currently
 *  positioned object.  Used by callers who for some reason need to bypass
 *  DoNameRes but still want to be able to call the LocalFoo routines which
 *  all require a completed ResObj.
 *
 *  INPUT:
 *    pDN    - pointer to DSNAME to be placed in the RESOBJ.  If NULL, a
 *             faked up empty RESOBJ is created (this is expected only
 *             during NC creation).
 *  RETURN VALUE:
 *    pointer to freshly allocated RESOBJ
 */
RESOBJ * CreateResObj(DBPOS *pDB,
                      DSNAME *pDN)
{
    THSTATE *pTHS = pDB->pTHS;
    RESOBJ * pResObj;
    DWORD realDNT;

    if (pDN) {
        pResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        pResObj->DNT = pDB->DNT;
        pResObj->PDNT = pDB->PDNT;
        pResObj->pObj = pDN;

        // We could use DBGetMultipleVals here, but it seems to impose more in
        // memory management overhead than Jet does in individual calls, so
        // we'll instead just invoke the simplest wrapper we can multiple times
        if (DBGetSingleValue(pDB,
                             ATT_INSTANCE_TYPE,
                             &pResObj->InstanceType,
                             sizeof(pResObj->InstanceType),
                             NULL)) {
            pResObj->InstanceType = 0;
        }
        pResObj->NCDNT = (pResObj->InstanceType & IT_NC_HEAD)
                         ? pDB->DNT : pDB->NCDNT;

        if (DBGetSingleValue(pDB,
                             ATT_IS_DELETED,
                             &pResObj->IsDeleted,
                             sizeof(pResObj->IsDeleted),
                             NULL)) {
            pResObj->IsDeleted = 0;
        }
        if (DBGetSingleValue(pDB,
                             ATT_OBJECT_CLASS,
                             &pResObj->MostSpecificObjClass,
                             sizeof(pResObj->MostSpecificObjClass),
                             NULL)) {
            pResObj->MostSpecificObjClass = 0;
        }

        if (fNullUuid(&pDN->Guid)) {
            UCHAR *pb = (UCHAR*)&pDN->Guid;
            ULONG len;
            if (DBGetAttVal(pDB,
                            1,
                            ATT_OBJECT_GUID,
                            DBGETATTVAL_fCONSTANT,
                            sizeof(GUID),
                            &len,
                            &pb)) {
                memset(pb, 0, sizeof(GUID));
            }
        }


#if DBG
        DBGetSingleValue(pDB,
                         FIXED_ATT_DNT,
                         &realDNT,
                         sizeof(realDNT),
                         NULL);
        Assert(realDNT == pResObj->DNT);
#endif
    }
    else {
        // Object doesn't exist, so create a placeholder resobj
        pResObj = THAllocEx(pTHS, sizeof(RESOBJ));
        pResObj->pObj = gpRootDN;
        pResObj->DNT = INVALIDDNT;
        pResObj->PDNT = INVALIDDNT;
        pResObj->NCDNT = INVALIDDNT;
        pResObj->InstanceType = IT_UNINSTANT;
        pResObj->IsDeleted = TRUE;
        pResObj->MostSpecificObjClass = CLASS_TOP;
    }

    return pResObj;
}


/*++ NamePrefix
 *
 * This routine determines if one name is a prefix of another.  If so it
 * returns an indication of how much prefix was matched.  Although this value
 * is intended to indicate how many RDNs were matched, that can't be
 * guaranteed.  The one thing that can be depended on is that, when comparing
 * two prefixes against the same DN, a higher number indicates a larger match.
 * Returns 0 if the purported prefix isn't a prefix.
 *
 * INPUT:
 *   pPrefix - pointer to the (potential) prefix DSNAME
 *   pDN     - pointer to the DN to be evaluated.
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   0       - not a prefix
 *   non-0   - is a prefix (see above)
 *
 * NOTE:
 *   This routine is NOT GUID based, and only works on string names.
 *
 * N.B. This routine is exported to in-process non-module callers
 */
unsigned
NamePrefix(const DSNAME *pPrefix,
           const DSNAME *pDN)
{
    unsigned ip, in;
    WCHAR rdnPrefix[MAX_RDN_SIZE];
    WCHAR rdnMain[MAX_RDN_SIZE];
    ATTRTYP typePrefix, typeMain;
    DWORD ccPrefixVal, ccMainVal;
    DWORD err;
    WCHAR *pKey, *pQVal;
    DWORD ccKey, ccQVal;
    unsigned retval;
    THSTATE *pTHS;

    // we can not just compare NameLen's because the DNs can be escaped.
    if (pPrefix->NameLen == 0) {
        // zero-length prefix is a prefix to anything
        return 1;
    }
    if (pDN->NameLen == 0) {
        // prefix is non-empty, and the name is. Not a prefix.
        return 0;
    }

    ip = pPrefix->NameLen-1;
    in = pDN->NameLen-1;
    retval = 1;

    while (TRUE) {
        if ((pPrefix->StringName[ip] != pDN->StringName[in]) &&
            (towlower(pPrefix->StringName[ip]) !=
             towlower(pDN->StringName[in]))) {
            // Can we put in a smarter test?  Perhaps if we have
            // not seen any spaces or escapes up until now (including this
            // char) then we can reject without the more expensive test.
            // Unfortunately that would miss cases where we're looking at
            // the last character of an escaped character.
            // Perhaps we can reject unless either one of the characters is
            // a space or a hex digit or a quote?
            goto NotExactly;
        }
        if (IsDNSepChar(pPrefix->StringName[ip])) {
            ++retval;
        }
        if (ip == 0) {
            // Ok, we've exhausted the prefix, make sure that we're at
            // a good stopping point in the name
            // We could be inside a quote, which would make this
            // check for a separator character meaningless.  That would imply
            // that the prefix name was invalid, though, because it ends with
            // an open quoted string.  In that case I believe that the bogus
            // name will be caught elsewhere shortly.
            if ((in == 0) ||
                (IsDNSepChar(pDN->StringName[in-1]))) {
                return retval;
            }
            else {
                return 0;
            }
        }
        if (in == 0) {
            // we exhausted the name without exhausting the prefix. Not a prefix.
            return 0;
        }
        --ip;
        --in;
    }

NotExactly:
    
    // While matches of identically escaped or normalized DNs should have
    // been caught above, we need to test here for possible matches of
    // differently escaped names.  We do this by repeatedly extracting
    // and unquoting the components of the two names, top to bottom,
    // and comparing the unquoted values.
    ip = pPrefix->NameLen;
    in = pDN->NameLen;
    retval = 0;
    pTHS=pTHStls;
    while (TRUE) {
        ++retval;

        // Parse out one element of the prefix

        err = GetTopNameComponent(pPrefix->StringName,
                                  ip,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            // The name is unparseable for some reason.  Claim that it's
            // not a prefix;
            return 0;
        }
        if (!pKey) {
            // We've run out of components in the prefix.  Whether or not
            // there are any components left in the DN, we know that the
            // purported prefix truly is one.
            Assert(!pQVal);
            return retval;
        }
        Assert(pQVal);
        typePrefix = KeyToAttrType(pTHS, pKey, ccKey);
        ccPrefixVal = UnquoteRDNValue(pQVal, ccQVal, rdnPrefix);
        if ((0 == ccPrefixVal) || (0 == typePrefix)) {
            // Prefix was not properly parseable.  Return an error
            return 0;
        }
        ip = (unsigned)(pKey - pPrefix->StringName);
        

        // Parse out one element of the DN

        err = GetTopNameComponent(pDN->StringName,
                                  in,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            // The name is unparseable for some reason.  Claim that it's
            // not a prefix;
            return 0;
        }
        if (!pKey) {
            // We've run out of components in the name.  Since we still
            // have a component in the prefix, we know that it is in fact
            // not a prefix
            Assert(!pQVal);
            return 0;
        }
        Assert(pQVal);
        typeMain = KeyToAttrType(pTHS, pKey, ccKey);
        ccMainVal = UnquoteRDNValue(pQVal, ccQVal, rdnMain);
        if ((0 == ccMainVal) || (0 == typeMain)) {
            // Name was not properly parseable.  Return an error
            return 0;
        }
        in = (unsigned)(pKey - pDN->StringName);
        

        // Compare the parsed components

        if ((typePrefix != typeMain) ||
            (ccPrefixVal != ccMainVal) ||
            (CSTR_EQUAL != CompareStringW(
                                 DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 rdnPrefix,
                                 ccPrefixVal,
                                 rdnMain,
                                 ccMainVal))) {
            // The components didn't compare.  Either the types differed or
            // the lengths differed or the strings didn't match.  Not a prefix.
            return 0;
        }
    }
}

/*++ DSNameToBlockName
 *
 * Pull apart a full dsname into an attrblock holding the individual RDNs and a
 * tagarray to go with it. (the AttrBlock holds the name fragments, the
 * tagarray is space for DNTs, and some duplicated information).
 * Assumes the memory for a maximal attrblock has already been allocated and is
 * passed in here.  The value pointers in the attrblock point into the dsname,
 * so don't call this then mess with the dsname.
 *
 * INPUT:
 *   pDSName     - pointer to name, in DSNAME format
 *   ppBlockName - pointer to pointer to fill in with the address of the
 *                 name in block format.
 *   fLowerCase  - change block name to lower case
 * OUTPUT:
 *   ppBlockName - filled in with pointer to name in blockname format
 * RETURN VALUE:
 *   0 - if all went well
 *   a DIRERR error code otherwise
 */
unsigned
DSNameToBlockName (
        THSTATE *pTHS,
        const DSNAME *pDSName,
        ATTRBLOCK ** ppBlockName,
        BOOL fLowerCase
        )
{
    ULONG cAVA=0,len,i;
    unsigned curlen = pDSName->NameLen;
    ATTRBLOCK * pBlockName;
    ATTR * pAVA;
    WCHAR * pKey, *pQVal;
    unsigned ccKey, ccQVal;
    WCHAR rdnbuf[MAX_RDN_SIZE];
    unsigned err;

    Assert(ppBlockName);
    *ppBlockName = NULL;

    err = CountNameParts(pDSName, &cAVA);
    if (err) {
        return err;
    }

    pBlockName = THAllocEx(pTHS, sizeof(ATTRBLOCK));
    pBlockName->attrCount = cAVA;

    if (cAVA == 0) {
        Assert(IsRoot(pDSName));
        *ppBlockName = pBlockName;
        return 0;
    }

    pBlockName->pAttr = THAllocEx(pTHS, cAVA * sizeof(ATTR));
    pAVA = pBlockName->pAttr;

    for (i=0; i<cAVA; i++) {
        Assert(curlen);

        // extract the most significant remaining name component
        err = GetTopNameComponent(pDSName->StringName,
                                  curlen,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            return err;
        }
        if (NULL == pKey) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        // shorten our view of the string name, which removes the
        // name component we got above
        curlen = (unsigned)(pKey - pDSName->StringName);

        // convert the name from string to binary
        pAVA->attrTyp = KeyToAttrType(pTHS, pKey, ccKey);

        len = UnquoteRDNValue(pQVal, ccQVal, rdnbuf);
        if (len == 0 || len > MAX_RDN_SIZE) {
            return DIRERR_NAME_VALUE_TOO_LONG;
        }

        if ( fLowerCase ) {
            // fold the case of the value, to ease future comparisons
            CharLowerBuffW(rdnbuf, len);
        }

        // wrangle the data into proper Attr format
        pAVA->AttrVal.pAVal = THAllocEx(pTHS, sizeof(ATTRVAL) +
                                        len * sizeof(WCHAR));
        pAVA->AttrVal.valCount = 1;
        pAVA->AttrVal.pAVal->valLen = len * sizeof(WCHAR);
        pAVA->AttrVal.pAVal->pVal = (UCHAR*)(pAVA->AttrVal.pAVal + 1);
        memcpy(pAVA->AttrVal.pAVal->pVal, rdnbuf, len * sizeof(WCHAR));

        pAVA++;
    }

    *ppBlockName = pBlockName;
    return 0;
} // DSNameToBlockName


//
// Convert a BLOCKNAME to DSName
//
// INPUT:
//      pBlockName - the blockname to convert to a DSNAME
//
// OUTPUT: 
//      ppName - a DSNAME is all went well
//
// Returns:
//      0 on success
//      1 on failure
//      Throws exception on memory alloc error
//

DWORD BlockNameToDSName (THSTATE *pTHS, ATTRBLOCK * pBlockName, DSNAME **ppName)
{
    DSNAME *pName;
    unsigned len, quotelen;
    ULONG allocLen;       // Count of Unicode Chars allocated for the stringname.
    unsigned i = 0;
    ATTR * pAVA;

    if (pBlockName->attrCount == 0) {
        *ppName = THAllocEx(pTHS, DSNameSizeFromLen(0));
        return 0;
    }
    
    // Allocate enough memory for most names.
    // Note that we will realloc if the amount of free space in the string
    // is less than MAX_RDN_SIZE+MAX_RDN_KEY_SIZE+2. Therefore, we allocate
    // twice as much upfront.
    allocLen = 2*(MAX_RDN_SIZE + MAX_RDN_KEY_SIZE+2);
    pName = THAllocEx(pTHS, DSNameSizeFromLen(allocLen));

    // Pull naming info off of each component, until we're done.

    i = pBlockName->attrCount;
    len = 0;

    do {
        if ((allocLen - len) < (MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2)) {
            // We might not have enough buffer to add another component,
            // so we need to reallocate the buffer up.  We allocate
            // enough for the maximal key, the maximal value, plus two
            // characters more for the comma and equal sign
            allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
            pName = THReAllocEx(pTHS, pName, DSNameSizeFromLen(allocLen));
        }

        // skip the first one
        if (i != pBlockName->attrCount ) {
            pName->StringName[len++] = L',';
        }
        
        pAVA = &pBlockName->pAttr[--i];

        len += AttrTypeToKey(pAVA->attrTyp, &pName->StringName[len]);
        pName->StringName[len++] = L'=';
        quotelen = QuoteRDNValue((WCHAR *)pAVA->AttrVal.pAVal->pVal,
                                 pAVA->AttrVal.pAVal->valLen/sizeof(WCHAR),
                                 &pName->StringName[len],
                                 allocLen - len);

        if (quotelen == 0) {
            THFreeEx (pTHS, pName);
            return 1;
        }

        // not enough size
        while (quotelen > (allocLen - len)) {
            allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
            pName = THReAllocEx(pTHS, pName, DSNameSizeFromLen(allocLen));
            quotelen = QuoteRDNValue((WCHAR *)pAVA->AttrVal.pAVal->pVal,
                                     pAVA->AttrVal.pAVal->valLen/sizeof(WCHAR),
                                     &pName->StringName[len],
                                     allocLen - len);
        }
        len += quotelen;

        // We should not have run out of buffer
        Assert(len < allocLen);
    }
    while (i >= 1);

    pName->StringName[len] =  L'\0';

    pName->NameLen = len;
    pName->structLen = DSNameSizeFromLen(len);

    *ppName = pName;

    return 0;
} // BlockNameToDSName

/*++ FreeBlockName
 *
 * This routine frees a BlockName as created by DSNameToBlockName.  It's
 * here so that callers do not need to to be aware of which parts were
 * put into which heap blocks.  Note that this should not be called on
 * block names that have been made permanent (below), as those are allocated
 * as a single block, and can be freed from the permanent heap directly.
 * For assertion purposes we rely on the code in THFree to assert if given
 * memory off of the wrong heap.
 *
 * INPUT:
 *   pBlockName - pointer to block name
 * RETURN VALUE:
 *   none
 */
void
FreeBlockName (
        ATTRBLOCK * pBlockName
        )
{
    unsigned i;
    ATTR * pAVA;
    THSTATE *pTHS=pTHStls;

    pAVA = pBlockName->pAttr;
    for (i=0; i<pBlockName->attrCount; i++) {
            THFreeEx(pTHS, pAVA->AttrVal.pAVal);
            ++pAVA;
    }
    THFreeEx(pTHS, pBlockName);
}

#define RoundToBlock(x)  (((x) + 7) & ~7)
/*++ MakeBlockNamePermanent
 *
 * This routine takes a BlockName (a DN stored as a AttrBlock) and copies
 * it to a single permanently allocated memory block, so that it can outlive
 * the current transaction.
 *
 * INPUT:
 *   pName - pointer to input name
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   pointer to freshly allocated block, or NULL for memory failure
 */
ATTRBLOCK * MakeBlockNamePermanent(ATTRBLOCK * pName)
{
    unsigned size;
    unsigned i;
    char * pBuf;
    ATTRBLOCK * pRet;

    size = RoundToBlock(sizeof(ATTRBLOCK));
    size += RoundToBlock(pName->attrCount * sizeof(ATTR));
    if (pName->attrCount) {
        Assert(pName->pAttr);
        for (i=0; i<pName->attrCount; i++) {
            size += RoundToBlock(sizeof(ATTRVAL)) +
                RoundToBlock(pName->pAttr[i].AttrVal.pAVal->valLen);
        }
    }

    pBuf = malloc(size);
    if (!pBuf) {
        LogUnhandledError(size);
        return NULL;
    }

    pRet = (ATTRBLOCK *)pBuf;
    pBuf += RoundToBlock(sizeof(ATTRBLOCK));

    pRet->attrCount = pName->attrCount;
    pRet->pAttr = (ATTR*)pBuf;
    pBuf += RoundToBlock(pRet->attrCount * sizeof(ATTR));

    for (i=0; i<pRet->attrCount; i++) {
        pRet->pAttr[i] = pName->pAttr[i];
        pRet->pAttr[i].AttrVal.pAVal = (ATTRVAL*)pBuf;
        pBuf += RoundToBlock(sizeof(ATTRVAL));
        pRet->pAttr[i].AttrVal.pAVal->valLen =
          pName->pAttr[i].AttrVal.pAVal->valLen;
        pRet->pAttr[i].AttrVal.pAVal->pVal = pBuf;
        pBuf += RoundToBlock(pRet->pAttr[i].AttrVal.pAVal->valLen);
        memcpy(pRet->pAttr[i].AttrVal.pAVal->pVal,
               pName->pAttr[i].AttrVal.pAVal->pVal,
               pRet->pAttr[i].AttrVal.pAVal->valLen);
    }

    Assert((pBuf - (char *)pRet) == (int)size);

    return pRet;
}

/*++ BlockNamePrefix
 *
 * This routine determines if one name is a prefix of another.  If so it
 * returns the number of RDNs matched. Returns 0 if the prefix isn't a prefix.
 *
 * INPUT:
 *   pPrefix - pointer to the (potential) prefix name, in ATTR format
 *   pDN     - pointer to the DN to be evaluated.
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   0       - not a prefix
 *   non-0   - is a prefix (see above)
 *
 * NOTE:
 *   This routine is NOT GUID based, and only works on string names.
 *
 */
unsigned
BlockNamePrefix(THSTATE *pTHS,
                const ATTRBLOCK *pPrefix,
                const ATTRBLOCK *pDN)
{
    int i;
    ATTR * pAvaPrefix, *pAvaDN;

    if ( 0 == pPrefix->attrCount )
    {
        // Prefix identifies the root, ergo anything else is a child.
        return(1);
    }

    if (pPrefix->attrCount > pDN->attrCount) {
        return 0;
    }

    pAvaPrefix = pPrefix->pAttr;
    pAvaDN = pDN->pAttr;

    for (i=0; i<(int)(pPrefix->attrCount); i++) {
        if ((pAvaPrefix->attrTyp != pAvaDN->attrTyp) ||
            (pAvaPrefix->AttrVal.pAVal->valLen !=
             pAvaDN->AttrVal.pAVal->valLen)) {
            return 0;
        }

        Assert(pAvaPrefix->AttrVal.valCount == 1);
        Assert(pAvaDN->AttrVal.valCount == 1);

        // use CompareStringW to be consistent with NamePrefix implementation.
        if (CSTR_EQUAL != CompareStringW(
                   DS_DEFAULT_LOCALE,
                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                   (PWCHAR)pAvaPrefix->AttrVal.pAVal->pVal,
                   pAvaPrefix->AttrVal.pAVal->valLen/sizeof(WCHAR),
                   (PWCHAR)pAvaDN->AttrVal.pAVal->pVal,
                   pAvaDN->AttrVal.pAVal->valLen/sizeof(WCHAR))) {
            return 0;
        }

        pAvaPrefix++;
        pAvaDN++;
    }

    return i;

}

/*++ FindNamingContext
 *
 * Given the name of a purported DS object, finds the naming context with
 * an adequate replica existing on this machine that could contain the object.
 * The "adequacy" of the replica is determined by whether or not the caller
 * allows us to use a "copy" of the NC, as opposed to a master copy.  The
 * only case where we would have "copies" in NTDS is for a thin read-only
 * replica on a global catalog server.  Note again that the result is the
 * best NC ON THIS MACHINE.  This means that the caller is responsible for
 * determining whether or not the object would actually lie in the NC.  This
 * can be done either by CheckForNCExit or by using FindBestCrossRef (which
 * will definitively return the best NC known in the enterprise) and comparing
 * the results between that an FindNamingContext.
 *
 * INPUT:
 *    pObj    - name of purported DS object, in blockname format
 *    pComArg - common arguments
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    null    - no NC held on this machine could contain the purported object
 *    non-0   - pointer to name of the NC that is most likely to hold
 *              the purported object (i.e., the NC whose name is the maximal
 *              prefix of the object's name).
 *
*/
NAMING_CONTEXT * FindNamingContext(ATTRBLOCK *pObj,
                                   COMMARG *pComArg)
{
    int iBest = 0, iCur;
    NAMING_CONTEXT *pNCBest = NULL;
    NAMING_CONTEXT_LIST *pNCL;
    THSTATE *pTHS=pTHStls;
    NCL_ENUMERATOR nclEnum;

    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX1, (PVOID)pObj);
    while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
        iCur = nclEnum.matchResult;
        if (iCur > iBest) {
            iBest = iCur;
            pNCBest = pNCL->pNC;
        }
    }

    if (!pComArg->Svccntl.dontUseCopy) {
        // copies are acceptable
        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX1, (PVOID)pObj);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            iCur = nclEnum.matchResult;
            if (iCur > iBest) {
                iBest = iCur;
                pNCBest = pNCL->pNC;
            }
        }
    }

    return pNCBest;
}

/*++ CheckForNCExit
 *
 * Given the name of a purported DS object and the name of a naming context
 * that may contain it, this routine checks to see whether the object would
 * truly fall inside the NC, or whether the object would actually be in a
 * naming context that is beneath the naming context in question.  If it
 * is discovered that the purported object would be in some other NC, the
 * name of that NC is returned.  If the object would be in the specified
 * NC, then a null pointer is returned.
 *
 * INPUT:
 *    pNC   - name of NC to check for inclusion
 *    pObj  - name of purported object
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    null  - purported object would fall in given NC
 *    non-0 - pointer to name of NC that the object would be in.
 */
NAMING_CONTEXT * CheckForNCExit(THSTATE *pTHS,
                                NAMING_CONTEXT * pNC,
                                DSNAME * pObj)
{
    ULONG err;
    ULONG iVal;
    DSNAME *pSR;
    ATTCACHE *pAC;
    ULONG cbMax, cbActual;

    __try {
        err = DBFindDSName(pTHS->pDB, pNC);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    if (!(pAC = SCGetAttById(pTHS, ATT_SUB_REFS))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ATT_SUB_REFS);
    }
    iVal = 1;
    pSR = 0;
    cbMax = 0;
    do {
        err = DBGetAttVal_AC(pTHS->pDB,
                             iVal,
                             pAC,
                             DBGETATTVAL_fREALLOC,
                             cbMax,
                             &cbActual,
                             (UCHAR**)&pSR);
        if (!err) {
            // keep track of buf size
            if (cbActual > cbMax) {
                cbMax = cbActual;
            }
            Assert(cbActual == pSR->structLen);
            // ok, we found a subref.  See if it is a prefix of the
            // purported DN
            if (NamePrefix(pSR, pObj)) {
                // it is, which means that the object is not in this NC
                return pSR;
            }
        }
        iVal++;
    } while (!err);

    if (pSR) {
        THFreeEx(pTHS, pSR);
    }

    return 0;
}

/*++ FindCrossRefInList
 *
 * Given the name of a purported DS object (in blockname format), this
 * routine scans the list of cross refernces held by this DSA and
 * returns the best candidate cross reference (i.e., the cross ref that
 * matches the most components of the name of the purported object.
 *
 * The convoulted test for "better-ness" is really two parts.  We take
 * a CR to be "better" if it matches more of the name than our current
 * champ (the normal part), or if it matches exactly the same amount of
 * the name as our current champ and wins an arbitrary GUID comparison.
 * This latter part is only necessary to give consistent (if arbitrary)
 * results when someone has messed up and added two CRs for the same NC.
 *
 * INPUT:
 *    pObj    - name of the purported object, in blockname format
 *    pCRL    - cr list to search (usually, gAnchor.pCRL)
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    NULL    - no known cross refs could contain the purported object
 *    non-0   - pointer to in-memory structure holding the cached cross
 *              ref that best matches the purported object.
 */
CROSS_REF * FindCrossRefInList(const ATTRBLOCK *pObj, CROSS_REF_LIST* pCRL)
{
    ULONG iCur;
    ULONG iBest = 0;
    CROSS_REF * pCRBest = NULL;
    THSTATE *pTHS=pTHStls;

    while (pCRL) {
        iCur = BlockNamePrefix(pTHS, pCRL->CR.pNCBlock, pObj);
        if ((iCur > iBest) ||
            ((iCur == iBest) &&
             (iCur > 0) &&
             (0 > memcmp(&pCRBest->pObj->Guid,
                         &pCRL->CR.pObj->Guid,
                         sizeof(GUID))))) {
            iBest = iCur;
            pCRBest = &pCRL->CR;
        }
        pCRL = pCRL->pNextCR;
    }

    return pCRBest;
}

/*++ FindBestCrossRef
 *
 * A publicy callable routine that will return the in memory CrossRef
 * that is the best match for the target object.  Currently just a wrapper
 * around FindCrossRef (above) that doesn't require blocknames, but that
 * may change in the future.
 *
 * INPUT
 *   pObj    - DSNAME of object for which cross ref is desired
 *   pComArg - COMMARG
 * RETURN VALUE
 *   null    - no CR could be found
 *   non-null - pointer to CROSS_REF object
 */
CROSS_REF *
FindBestCrossRef(const DSNAME *pObj,
                 const COMMARG *pComArg)
{
    THSTATE *pTHS=pTHStls;
    ATTRBLOCK * pObjB;
    CROSS_REF * pCR;

    if (DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE)) {
        return NULL;
    }
    pCR = FindCrossRef(pObjB, pComArg);
    FreeBlockName(pObjB);

    return pCR;
}

/*++ FindExactCrossRef
 *
 * A publicy callable routine that will return the in memory CrossRef
 * that is a perfect match for the target object (i.e., the target must
 * be the name of an NC, not of an object inside the NC).  Currently just
 * calls FindBestCrossRef, but hopefully this will change, as a search for
 * an exact match could be made more efficient than a search for a prefix.
 *
 * INPUT
 *   pObj    - DSNAME of object for which cross ref is desired
 *   pComArg - COMMARG
 * RETURN VALUE
 *   null    - no CR could be found
 *   non-null - pointer to CROSS_REF object
 */
CROSS_REF *
FindExactCrossRef(const DSNAME *pObj,
                  const COMMARG *pComArg)
{
    THSTATE *pTHS=pTHStls;
    ATTRBLOCK * pObjB;
    CROSS_REF * pCR;

    if (DSNameToBlockName(pTHS, pObj, &pObjB, DN2BN_LOWER_CASE)) {
        return NULL;
    }
    pCR = FindCrossRef(pObjB, pComArg);
    FreeBlockName(pObjB);

    if ( (NULL != pCR) && !NameMatched(pObj, pCR->pNC) ) {
        pCR = NULL;
    }

    return pCR;
}


/*++ FindExactCrossRefForAltNcName
 *
 * Finds the cross ref with the desired naming context
 *
 */
CROSS_REF *
FindExactCrossRefForAltNcName(
    ATTRTYP        attrTyp,
    ULONG          crFlags,
    const WCHAR *  pwszVal // This is implied to be the DNS of the NC.
    )
{
    CROSS_REF_LIST  *pCRL = gAnchor.pCRL;
    CROSS_REF       *pBestCR = NULL;
    LPWSTR          pName;

#if DBG
    DWORD           cFound = 0;
#endif

    Assert(pwszVal);
    Assert((ATT_NETBIOS_NAME == attrTyp) || (ATT_DNS_ROOT == attrTyp) || (ATT_MS_DS_DNSROOTALIAS == attrTyp) );
    Assert((ATT_DNS_ROOT == attrTyp)|| (ATT_MS_DS_DNSROOTALIAS == attrTyp) || (crFlags & FLAG_CR_NTDS_DOMAIN));

    if ((ATT_NETBIOS_NAME != attrTyp) && (ATT_DNS_ROOT != attrTyp) && (ATT_MS_DS_DNSROOTALIAS != attrTyp))
    {
        return(NULL);
    }

    if ( !(crFlags & FLAG_CR_NTDS_DOMAIN) ) {
        if(DsaIsInstalling()){
            Assert(!"Can't call this function for non-domains during install");
            return(NULL);
        }
    }

    while ( pCRL )
    {
        pName = (ATT_NETBIOS_NAME == attrTyp)            
                            ? pCRL->CR.NetbiosName
                            : ( (ATT_MS_DS_DNSROOTALIAS == attrTyp)
                                ? pCRL->CR.DnsAliasName
                                : pCRL->CR.DnsName );

        if (    (crFlags == (pCRL->CR.flags & crFlags))     // correct flags
             && pName                                       // value present
             && (2 == CompareStringW(                      // value matches
                            DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            pName,
                            -1,
                            pwszVal,
                            -1)) 
             && ((crFlags & FLAG_CR_NTDS_DOMAIN) ||
                  (!NameMatched(pCRL->CR.pNC, gAnchor.pConfigDN) &&
                   !NameMatched(pCRL->CR.pNC, gAnchor.pDMD))) ) 
        {
#if DBG
            cFound++;
            pBestCR = &pCRL->CR;
#else
            return(&pCRL->CR);
#endif
        }

        pCRL = pCRL->pNextCR;
    }

#if DBG
    Assert(cFound < 2);
#endif

    return(pBestCR);
}


CROSS_REF *
FindCrossRefByGuid(GUID *pGuid)
{
    CROSS_REF_LIST *pCRL = gAnchor.pCRL;

    while (pCRL) {
        Assert( !fNullUuid( &(pCRL->CR.pNC->Guid) ) );
        if (0 == memcmp( pGuid, &(pCRL->CR.pNC->Guid), sizeof( GUID ) )) {
            return &(pCRL->CR);
        }
        pCRL = pCRL->pNextCR;
    }
    return NULL;
}



BOOL
IsCrossRefProtectedFromDeletion(
    IN DSNAME * pDN
    )
/*++

Routine Description:

    Determine whether the given DN is a cross-ref for a locally writable
    config/schema/domain NC.

Arguments:

    pDN (IN) - DN to check.

Return Values:

    TRUE - pDN is a cross-ref for a locally writable NC.
    FALSE - otherwise.

--*/
{
    CROSS_REF_LIST *      pCRL;
    NAMING_CONTEXT_LIST * pNCL;
    NCL_ENUMERATOR nclEnum;

    for (pCRL = gAnchor.pCRL; NULL != pCRL; pCRL = pCRL->pNextCR) {
        if (NameMatched(pCRL->CR.pObj, pDN)) {
            // pDN is a indeed a cross-ref; do we hold a writable copy of the
            // corresponding NC?
            if (!fIsNDNCCR(&pCRL->CR)) {
                NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
                NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NC, (PVOID)pCRL->CR.pNC);
                if (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
                    // pDN is a cross-ref for a locally writable
                    // config/schema/domain NC.
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


/*++ GenCrossRef
 *
 * This routine takes the name of a cross reference (in its general sense,
 * the name of an object that holds information about the location of
 * one or more replicas of a specific naming context) and produces a
 * referral based on that cross ref.
 *
 * INPUT:
 *     pCR      - pointer to the in-memory cross-ref object
 *     pObj     - name of purported object being sought
 * OUTPUT:
 *     none     - (the referral is placed in the THSTATE)
 * RETURN VALUE:
 *     referralError if all went well, some other error code if we
 *     were unable to generate the referral.
 */
int
GenCrossRef(CROSS_REF *pCR,
            DSNAME *pObj)
{
    THSTATE     *pTHS = pTHStls;
    ULONG       len, nVal;
    WCHAR       *pDNS;
    NAMERESOP   Op;
    DSA_ADDRESS da;

    Op.nameRes = OP_NAMERES_NOT_STARTED; // next server must restart algorithm

    if(!pCR->bEnabled){
        // We don't generate referrals of any kind for disabled 
        // crossRefs.  As far as the directory is concerned we this
        // part of the directory does not exist yet.
        return SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND);
    }

    if(0 == pCR->DnsReferral.valCount) {
        DPRINT(0,"Missing required DNS root for Cross Ref\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_MASTERDSA_MISSING_SUBREF,
                 szInsertDN(pCR->pObj),
                 NULL,
                 NULL);

        return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_MASTERDSA_REQUIRED);
    }

    for (nVal = 0; nVal < pCR->DnsReferral.valCount; ++nVal) {
        len = pCR->DnsReferral.pAVal[nVal].valLen;
        pDNS = THAllocEx(pTHS, len);
        memcpy(pDNS, pCR->DnsReferral.pAVal[nVal].pVal, len);

        da.Length = (unsigned short) len;
        da.MaximumLength = (unsigned short) len;
        da.Buffer = pDNS;

        SetRefError(pObj,
                    0,
                    &Op,
                    0,
                    CH_REFTYPE_CROSS,
                    &da,
                    DIRERR_REFERRAL);
    }

    return pTHS->errCode;
}

/*++ GenSupRef - Generate a referral based on our Superior Reference
 *
 * This routine is the referral generator of last resort.  If all other
 * attempts to refer the caller to a sensible location have failed, we
 * will refer him to the server known to hold the portion of the tree
 * above us, in hopes that it can do better.
 *
 * INPUT:
 *     pObj     - name of purported object being sought
 *     pObjB    - name of purported object being sought, in blockname format
 *     pComArg  - common argument flags
 *     pDA      - (optional) If present, the referred DSA-Address is returned,
 *                and no error is placed in the THSTATE
 * OUTPUT:
 *     none     - (the referral is placed in the THSTATE)
 * RETURN VALUE:
 *     referralError if all went well, some other error code if we
 *     were unable to generate the referral.
 */
int
GenSupRef(THSTATE *pTHS,
          DSNAME *pObj,
          ATTRBLOCK *pObjB,
          const COMMARG *pComArg,
          DSA_ADDRESS *pDA)
{
#define GC_PREAMBLE     L"gc._msdcs."
#define CB_GC_PREAMBLE (sizeof(GC_PREAMBLE) - sizeof(WCHAR))
#define CC_GC_PREAMBLE ((CB_GC_PREAMBLE)/sizeof(WCHAR))
#define GC_PORT        L":3268"
#define GC_SSL_PORT    L":3269"
#define CB_GC_PORTS    (sizeof(GC_PORT) - sizeof(WCHAR))
#define CC_GC_PORTS    ((CB_GC_PORTS)/sizeof(WCHAR))
    ULONG err;
    ULONG cbVal;
    ULONG att;
    WCHAR *pDNS, *pTempDNS;
    DSA_ADDRESS da;
    NAMERESOP Op;
    BOOL fGCReferral;
    CROSS_REF *pCR=NULL;
    DWORD     i, iFirstColon, iSecondColon;

    if(IsRoot(pObj) ||
        // suprefs to the root should generate a referral to the GC.
       (!pObj->NameLen && !fNullUuid(&pObj->Guid))) {
        // suprefs with no string name and a guid get sent to the GC also
        fGCReferral = TRUE;
    }
    else {
        fGCReferral = FALSE;
    }

    Assert(sizeof(GC_PORT) == sizeof(GC_SSL_PORT));

    Op.nameRes = OP_NAMERES_NOT_STARTED; // next server must restart algorithm

    if(!gAnchor.pRootDomainDN ||
       (!(pCR = FindExactCrossRef(gAnchor.pRootDomainDN, pComArg))) ) {
        DPRINT1(0,
                "Missing config info, can't gen referral for '%S'\n",
                pObj->StringName
                );
        return SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                           DIRERR_MISSING_SUPREF);
    }
    else {
        // Now, go to the cross ref
        err = DBFindDSName(pTHS->pDB, pCR->pObj);

        Assert(!err);           // we've gotta have this

        if (err) {
            DPRINT2(0,"Error %d finding object %S for SupRef gen\n",
                    err, gAnchor.pRootDomainDN->StringName);
            return SetSvcError(SV_PROBLEM_INVALID_REFERENCE,
                               DIRERR_MISSING_SUPREF);
        }

        if(fGCReferral) {
            // This is a GC referral, read the ATT_DNS_ROOT
            att = ATT_DNS_ROOT;
        }
        else {
            // A normal sup ref.  Read the ATT_SUP_REF_DNS
            att = ATT_SUPERIOR_DNS_ROOT;
        }

        if( DBGetAttVal(pTHS->pDB,
                        1,
                        att,
                        0,
                        0,
                        &cbVal,
                        (UCHAR **)&pDNS)){

            // Jeez!  We don't have a single known place to send referrals
            // for unknown objects.  Instead we'll try to automatically guess
            // one based on the target DN.
            cbVal = GenAutoReferral(pTHS,
                                    pObjB,
                                    &pDNS);
        }
        else if(fGCReferral) {
            //
            // We are generating a supref for the root.  We will generate a
            // referral the GC.
            //
            // First, adjust the dns string we got back to trim out :'s
            pTempDNS = pDNS;
            i=0;
            while(i<cbVal && *pTempDNS != ':') {
                i += sizeof(WCHAR);
                pTempDNS++;
            }
            // i either == cbVal or i == length through first ':'
            cbVal=i;
            pTempDNS = THAllocEx(pTHS, cbVal + CB_GC_PREAMBLE + CB_GC_PORTS);
            memcpy(pTempDNS, GC_PREAMBLE, CB_GC_PREAMBLE);
            memcpy(&pTempDNS[CC_GC_PREAMBLE],pDNS, cbVal);
            cbVal += CB_GC_PREAMBLE;
            memcpy(&pTempDNS[cbVal/2],GC_PORT,CB_GC_PORTS);
            cbVal += CB_GC_PORTS;
            THFreeEx(pTHS, pDNS);
            pDNS = pTempDNS;

        }
    }

    if (0 == cbVal) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_MISSING_SUPREF,
                 szInsertDN(pObj),
                 NULL,
                 NULL);
        
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_SUPREF);
    }

    da.Length = (unsigned short) cbVal;
    da.MaximumLength = (unsigned short) cbVal;
    da.Buffer = pDNS;

    if (pDA) {
        // The caller didn't want an error set, just the address back
        *pDA = da;
    }
    else {

        // Set the error
        SetRefError(pObj,
                    0,
                    &Op,
                    0,
                    CH_REFTYPE_SUPERIOR,
                    &da,
                    DIRERR_REFERRAL);

    }

    return pTHS->errCode;
}

//-----------------------------------------------------------------------
//
// Function Name:            ConvertX500ToLdapDisplayName
//
// Routine Description:
//
//    Converts an X500 Name to Ldap Convention
//
// Author: RajNath
//
// Arguments:
//
//    WCHAR* szX500Name
//    DWORD cchX500Name            Length of the supplied name in WCHARs, note that for
//                                 internal strings, there is no terminating
//                                 NULL; the strings are sized only.
//    WCHAR* szLdapName            Preallocated Buffer to return the Ldap Name
//    DWORD* pcchLdapName          Returned Name Length in WCHARs
//
// Return Value:
//
//    None
//
//-----------------------------------------------------------------------
VOID
ConvertX500ToLdapDisplayName(
    WCHAR* szX500Name,
    DWORD  cchX500Name,
    WCHAR* szLdapName,
    DWORD* pcchLdapName
)
{
    BOOL    fLastCharWasSpecial = FALSE;
    DWORD   i;

    Assert(cchX500Name > 0);

    *pcchLdapName = 0;

    for ( i = 0; i < cchX500Name; i++ )
    {
        // Skip special characters and flag them.

        if (    (L' ' == szX500Name[i])
             || (L'-' == szX500Name[i])
             || (L'_' == szX500Name[i]) )
        {
            fLastCharWasSpecial = TRUE;
            continue;
        }

        // If we get to here, we're not sitting on a special
        // character.  Change case based on previous character
        // and whether this is the first character at all.

        if ( 0 == *pcchLdapName )
        {
            szLdapName[(*pcchLdapName)++] = towlower(szX500Name[i]);
        }
        else if ( fLastCharWasSpecial )
        {
            szLdapName[(*pcchLdapName)++] = towupper(szX500Name[i]);
        }
        else
        {
            szLdapName[(*pcchLdapName)++] = szX500Name[i];
        }

        fLastCharWasSpecial = FALSE;
    }

    Assert(*pcchLdapName > 0);
    Assert(*pcchLdapName <= cchX500Name);

} // End ConvertX500ToLdapDisplayName

DWORD
FillGuidAndSid (
        IN OUT DSNAME *pDN
        )
/*++

Routine Description:
    Given a DN, fill in the GUID and SID fields.  Note that if the GUID is
    already filled in, the after this routine the GUID and SID will definitely
    be from the same object, but since DBFindDSName preferentially uses the
    GUID, it is possible that the GUID/SID and the StringName don't refer to the
    same object.

    This routine opens it's own DBPOS in order to avoid messing up a prepare rec
    that the caller (like CheckAddSecurity) might be in.

Argumnts:
    pDN - DSName to find and then fill in GUIDs and SIDs.

Return Values:
    0 if all went well, a dblayer error otherwise.

--*/
{
    DBPOS *pDBTmp;
    GUID Guid;
    GUID *pGuid = &Guid;
    NT4SID Sid;
    NT4SID *pSid = &Sid;
    BOOL  fCommit = FALSE;
    DWORD err, SidLen, len;
    DSNAME TempDN;

    DBOpen(&pDBTmp);
    __try {
        // PREFIX: dereferencing uninitialized pointer 'pDBTmp' 
        //         DBOpen returns non-NULL pDBTmp or throws an exception

        // Find the object.
        err = DBFindDSName(pDBTmp, pDN);
        if (!err) {
            // Ok, we're on the object
            err = DBFillGuidAndSid(pDBTmp, &TempDN);
        }

        if(!err) {
            // Only set the values in the DN if everything is OK
            pDN->Guid = TempDN.Guid;
            pDN->Sid = TempDN.Sid;
            pDN->SidLen = TempDN.SidLen;
        }

        fCommit = TRUE;
    }
    __finally {
        DBClose(pDBTmp, fCommit);
    }

    return err;
}

DWORD
UserFriendlyNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        )
/*++

    Take a string name and generate a DSName from it.

    If the string starts with some (or none) whitespace, then "<", we parse out
    an extended string which is either <SID=........>, <GUID=..........>,
    or <WKGUID=.........,~DN~>

--*/
{
    THSTATE *pTHS=pTHStls;
    BYTE  ObjGuid[sizeof(GUID)];
    BYTE  ObjSid[sizeof(NT4SID)];
    DWORD SidLen = 0,j;
    WCHAR acTmp[3];
    BOOL  bDone;
    DWORD dnstructlen;
#define foundGUID   1
#define foundSID    2
#define foundString 3
#define foundWKGUID 4
    DWORD dwContents= foundString;


    memset(ObjGuid, 0, sizeof(GUID));
    memset(ObjSid,0,sizeof(NT4SID));

    if (!ppDN || !pUfn) {
        // Urk. No place to put the answer, or no source to build the answer
        // from
        return 1;
    }

    // Skip leading spaces.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (*pUfn) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            pUfn++;
            ccUfn--;
            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }

    // Now, skip trailing whitespace also.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (pUfn[ccUfn-1]) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            if( (ccUfn > 1) && (pUfn[ccUfn-2] == L'\\') ) {
                //There is a '\\' in front of the space. Need to count the
                // number of consequtive '\\' to determine if ' ' is escaped
                DWORD cc = 1;

                while( (ccUfn > (cc+1)) && (pUfn[ccUfn-cc-2] == L'\\') )
                    cc++;

                if( ! (cc & 0x1) ) //Even number of '\\'. Space is not escaped
                    ccUfn--;

                bDone = TRUE; //Either way, exit the loop.
            }
            else
                ccUfn--;

            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }

    // Let's see if we were given an "extended" DN.  The test we use is for the
    // first non-white space to be a '<' and the last non-whitespace to be a '>'
    if(ccUfn &&
       pUfn[0] == L'<' &&
       pUfn[ccUfn-1] == L'>') {
        // OK, this must be an extended DN.  Skip this leading '<' No whitespace
        // is allowed inside an extended DN.
        pUfn++;
        acTmp[2]=0;

        switch(*pUfn) {
        case L'W':
        case L'w':
            // We might have a well known GUID. Format is
            // <WKGUID=.......,a=b,c=d..>
            // minimal length is 45:
            //   1 for '<'
            //   7 for WKGUID=
            //   32 for the GUID,
            //   1 for ','
            //   3 for at least "a=b"
            //   1 for '>'
            if((ccUfn<45)                            || 
               (_wcsnicmp(pUfn, L"WKGUID=", 7) != 0) ||
               (pUfn[39] != L',')) {
                // Invalidly formatted
                return 1;
            }
            pUfn += 7;
            for(j=0;j<16;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjGuid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }
            pUfn++;
            // Adjust ccUfn to leave only the a=b portion.
            ccUfn -= 42;
            dwContents = foundWKGUID;
            break;
        case L'G':
        case L'g':
            // We have some characters which have to be a guid
            if(((ccUfn!=39) // 1 for < ,5 for GUID= ,32 for the GUID, 1 for >
                && (ccUfn != 43)) // same plus 4 '-'s for formatted guid
               || (_wcsnicmp(pUfn, L"GUID=", 5) != 0)) {
                // Invalidly formatted
                return 1;
            }
            pUfn += 5;
            dwContents = foundGUID;

            if (39 == ccUfn) {
                // Hex digit stream (e.g., 625c1438265ad211b3880000f87a46c8).
                for(j=0;j<16;j++) {
                    acTmp[0] = towlower(pUfn[0]);
                    acTmp[1] = towlower(pUfn[1]);
                    if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                        ObjGuid[j] = (char) wcstol(acTmp, NULL, 16);
                        pUfn+=2;
                    }
                    else {
                        // Invalidly formatted name.
                        return 1;
                    }
                }
            }
            else {
                // Formatted guid (e.g., 38145c62-5a26-11d2-b388-0000f87a46c8).
                WCHAR szGuid[36+1];

                wcsncpy(szGuid, pUfn, 36);
                szGuid[36] = L'\0';

                if (UuidFromStringW(szGuid, (GUID *) ObjGuid)) {
                    // Incorrect format.
                    return 1;
                }
            }
            // We must have correctly parsed out a guid.  No string name left.
            break;

        case L'S':
        case L's':
            if (ccUfn<8) {
                //Must have at least 1 for >, at least 2 for val, 4 for "SID=",1 for >
                return 1;
            }
            //
            // First check for the standard user friendly string form of 
            // the sid.
            //
            if ((ccUfn>8) && // Must have more than just "<SID=S-"
                _wcsnicmp(pUfn, L"SID=S-", 6) == 0) {
                PSID     pSid = NULL;
                PWCHAR   pTmpUfn;
                unsigned ccTmpUfn;

                // Make a copy of the user friendly name so that it can be
                // null terminated appropriately for ConvertStringSidToSid

                ccTmpUfn = ccUfn - 5;  // 2 for <> and 4 for SID= add one for the 
                                       // terminating null

                pTmpUfn = THAllocEx(pTHS, ccTmpUfn * sizeof(*pTmpUfn));
                CopyMemory(pTmpUfn, pUfn + 4, ccTmpUfn * sizeof(*pTmpUfn));
                pTmpUfn[ccTmpUfn - 1] = L'\0';

                if (ConvertStringSidToSidW(pTmpUfn, &pSid)) {
                    SidLen = RtlLengthSid(pSid);
                    if (SidLen > sizeof(ObjSid)) {
                        // user has supplied a SID that is too long. We don't accept SIDs longer
                        // than 6 subauthorities.
                        LocalFree(pSid);
                        THFreeEx(pTHS, pTmpUfn);
                        return 1;
                    }
                    CopyMemory(ObjSid, pSid, SidLen);

                    LocalFree(pSid); pSid = NULL;
                    THFreeEx(pTHS, pTmpUfn);
                    //
                    // Success!
                    //
                    dwContents = foundSID;

                    // We have correctly parsed out a sid.  No string name left.
                    ccUfn=0;

                    break;
                }

                THFreeEx(pTHS, pTmpUfn);
            }

            //
            // It wasn't the the standard user friendly form.  Maybe it's the byte
            // encoded string form.
            //
            SidLen= (ccUfn - 6)/2; // Number of bytes that must be in the SID,
                                   // if this is indeed a Sid. Subtract 6 for
                                   // "<SID=>", leaving only the characters
                                   // which encode the string.  Divide by two
                                   // because each byte is encoded by two
                                   // characters.


            if((ccUfn<8) || //1 for >, at least 2 for val, 4 for "SID=",1 for >
               (ccUfn & 1) || // Must be an even number of characters
               (SidLen > sizeof(NT4SID)) || // Max size for a SID
               (_wcsnicmp(pUfn, L"SID=", 4) != 0)) {
                // Invalidly formatted
                return 1;
            }
            pUfn+=4;
            dwContents = foundSID;
            for(j=0;j<SidLen;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjSid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }

            // We must have correctly parsed out a sid.  No string name left.
            ccUfn=0;
            break;

        default:
            // Invalid character
            return 1;
        }
    }


    // We may have parsed out either a GUID or a SID.  Build the DSNAME
    dnstructlen = DSNameSizeFromLen(ccUfn);
    *ppDN = (DSNAME *)THAllocEx(pTHS, dnstructlen);
    // THAllocEx zero'es the allocated memory
    (*ppDN)->structLen = dnstructlen;

    switch(dwContents) {
    case foundWKGUID:
        // A string name and a GUID.
        Assert(ccUfn);
        // copy the GUID into the DSNAME
        memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
        // Fall through to parse/unescape the string name

    case foundString:
        // Just a string name

        if(ccUfn) {
            WCHAR *pString = (*ppDN)->StringName;   // destination string
            WCHAR *p = pUfn;         // original string
            DWORD cc = ccUfn;        // num chars to process
            BOOL  fDoItFast = TRUE;

            // this loop is a substitute for
            // memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
            // we try to find out whether the DN passed in has an escaped constant
            while (cc > 0) {

                if (*p == L'"' || *p== L'\\') {
                    fDoItFast = FALSE;
                    break;
                }

                *pString++ = *p++;
                cc--;
            }
            
            (*ppDN)->NameLen = ccUfn;
            
            // if we have an escaped constant in the DN
            // we convert it to blockname and back to DN so as to
            // put escaping into a standardized form which will help
            // future comparisons
            //
            if (!fDoItFast) {
                ATTRBLOCK *pAttrBlock = NULL;
                DWORD err;

                memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
                (*ppDN)->StringName[ccUfn] = L'\0';

                err = DSNameToBlockName (pTHS, *ppDN, &pAttrBlock, DN2BN_PRESERVE_CASE);
                THFreeEx (pTHS, *ppDN); *ppDN = NULL;
                if (err) {
                    return err;
                }

                err = BlockNameToDSName (pTHS, pAttrBlock, ppDN);
                FreeBlockName (pAttrBlock);

                if (err == 0 && dwContents == foundWKGUID) {
                    // recopy the GUID into the new DSNAME
                    memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
                }

                return err;
            }
        }
        break;

    case foundGUID:
        // we found a guid
        memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
        break;
        
    case foundSID:
        // we found a sid.
        if(SidLen) {
            // We must have found a SID

            // First validate the SID

            if ((RtlLengthSid(ObjSid) != SidLen) || (!RtlValidSid(ObjSid)))
            {
                return(1);
            }
            memcpy(&(*ppDN)->Sid, ObjSid, SidLen);
            (*ppDN)->SidLen = SidLen;
        }
        break;
    }

    // Null terminate the string if we had one (or just set the string to '\0'
    // if we didn't).
    (*ppDN)->StringName[ccUfn] = L'\0';

    return 0;
}


typedef struct _ScriptMacroDsName {
    LPWSTR macroName;
    DSNAME **ppDSName;
} ScriptMacroDsName;

ScriptMacroDsName scriptmacrodsname[] = 
{
    L"$LocalNTDSSettingsObjectDN$", &gAnchor.pDSADN,
    L"$RootDomainDN$",              &gAnchor.pRootDomainDN,
    L"$DomainDN$",                  &gAnchor.pDomainDN,
    L"$PartitionsObjectDN$",        &gAnchor.pPartitionsDN,
    L"$ConfigNCDN$",                &gAnchor.pConfigDN,
    L"$SchemaNCDN$",                &gAnchor.pDMD,
    L"$SiteDN$",                    &gAnchor.pSiteDN,
    L"$DirectoryServiceConfigDN$",  &gAnchor.pDsSvcConfigDN,
    NULL,                           NULL
};



//
//  DSNameExpandMacro
//
//  Description:
//
//     Take a string name coming from an XML script representing a DSNAME macro 
//     and generate a DSName from it.
//
//     the string can be of the form:
//        $SupportedMacroDSName$
//     or "$CN=abc,$SupportedMacroDSName$", in which case, the first '$' will be 
//     stripped off and $SupportedMacroDSName$ will be replaced with the coresponding
//     DN.
//
//  Arguments:
//
//     pUfn - the string representing the DSNAME
//     ccUfn - the number of characters of the string
//     ppDN (OUT) - where to store the result DSNAME
//
//  Return Value:
//
//     0 on success
//     1 not found
//     2 found but empty
//
DWORD DSNameExpandMacro (
    THSTATE *pTHS,
    WCHAR   *pUfn,
    DWORD    ccUfn,
    DSNAME **ppDN
    )
{
    DWORD i = 0;
    LPWSTR pMacro;
    DSNAME *pDN = NULL;
    WCHAR *pTemp, *pD1, *pD2;
    DWORD ccLen, cBytes;

    Assert(pUfn[0]==L'$' && ccUfn>2);

    pD1 = pUfn;
    pD2 = wcschr(pD1+1,L'$');
    if (!pD2) {
        return 2;
    }

    //find the last pair of '$'
    while ((pTemp=wcschr(pD2+1,L'$')) && pTemp<=pUfn+ccUfn)  {
        pD1 = pD2;
        pD2 = pTemp;
    }

    while (pMacro = scriptmacrodsname[i].macroName) {
        if (_wcsnicmp(pMacro, pD1, (DWORD)(pD2-pD1+1)) == 0) {
            pDN = *(scriptmacrodsname[i].ppDSName);
            if (!pDN) {
                return 2;
            }
            break;
        }
        i++;
    }

    if (pDN) {
        DPRINT1 (0, "Found DSNAME Macro: %ws\n", pDN->StringName);
        ccLen = (DWORD)(pD1-pUfn); 
        
        if (ccLen) {  
            // The string does not start with the macro
            cBytes = DSNameSizeFromLen(ccLen-1+pDN->NameLen);
            *ppDN = (DSNAME *)THAllocEx(pTHS, cBytes);
            (*ppDN)->structLen = cBytes;
            (*ppDN)->NameLen = (ccLen-1)+pDN->NameLen;
            wcsncpy((*ppDN)->StringName, &pUfn[1], ccLen-1);
            wcsncat((*ppDN)->StringName, pDN->StringName, pDN->NameLen);
        }
        else {
            //The whole string is a macro
            *ppDN = (DSNAME *)THAllocEx(pTHS,pDN->structLen);
            memcpy(*ppDN, pDN, pDN->structLen);
        }
        
        return 0;
    }

    DPRINT1 (0, "DSNAME Macro not found: %ws\n", pUfn);

    return 1;
}


//
//  ScriptNameToDSName
//
//  Description:
//
//     Take a string name coming from an XML script and generate a DSName from it.
//
//     the string can be of the form:
//        dn:CN=foo,...DC=com
//        guid:625c1438265ad211b3880000f87a46c8  (Hex digit stream)
//        guid:38145c62-5a26-11d2-b388-0000f87a46c8 (Formatted guid)
//        sid:1517B85159255D7266
//        $SupportedMacroDSName$
//
//  Arguments:
//
//     pUfn - the string representing the DSNAME
//     ccUfn - the number of characters of the string
//     ppDN (OUT) - where to store the result DSNAME
//
//  Return Value:
//
//     0 on success
//
DWORD
ScriptNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        )
{
    THSTATE *pTHS=pTHStls;
    BYTE  ObjGuid[sizeof(GUID)];
    BYTE  ObjSid[sizeof(NT4SID)];
    DWORD SidLen = 0,j;
    WCHAR acTmp[3];
    BOOL  bDone;
    DWORD dnstructlen;
    DWORD dwContents= foundString;

    memset(ObjGuid, 0, sizeof(GUID));
    memset(ObjSid,0,sizeof(NT4SID));

    if (!ppDN || !pUfn) {
        // Urk. No place to put the answer, or no source to build the answer
        // from
        return 1;
    }

    // Skip leading spaces.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (*pUfn) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            pUfn++;
            ccUfn--;
            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }

    // Now, skip trailing whitespace also.
    bDone=FALSE;
    while(ccUfn && !bDone) {
        switch (pUfn[ccUfn-1]) {
        case L' ':
        case L'\n':
        case L'\r':
            // extra whitespace is ok
            if( (ccUfn > 1) && (pUfn[ccUfn-2] == L'\\') ) {
                //There is a '\\' in front of the space. Need to count the
                // number of consequtive '\\' to determine if ' ' is escaped
                DWORD cc = 1;

                while( (ccUfn > (cc+1)) && (pUfn[ccUfn-cc-2] == L'\\') )
                    cc++;

                if( ! (cc & 0x1) ) //Even number of '\\'. Space is not escaped
                    ccUfn--;

                bDone = TRUE; //Either way, exit the loop.
            }
            else
                ccUfn--;

            break;
        default:
            // no more whitespace
            bDone=TRUE;
        }
    }


    if (ccUfn > 3 && _wcsnicmp(pUfn, L"dn:", 3) == 0) {

        ccUfn -=3;
        pUfn += 3;

    }
    else if (ccUfn > 5 && _wcsnicmp(pUfn, L"guid:", 5) == 0) {

        // We have some characters which have to be a guid
        if( (ccUfn!=37)  &&     // 5 for guid: , 32 for the GUID
            (ccUfn != 41)) {    // same plus 4 '-'s for formatted guid
                // Invalidly formatted
                return 1;
        }
        pUfn += 5;
        dwContents = foundGUID;

        if (37 == ccUfn) {
            // Hex digit stream (e.g., 625c1438265ad211b3880000f87a46c8).
            for(j=0;j<16;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjGuid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }
        }
        else {
            // Formatted guid (e.g., 38145c62-5a26-11d2-b388-0000f87a46c8).
            WCHAR szGuid[36+1];

            wcsncpy(szGuid, pUfn, 36);
            szGuid[36] = L'\0';

            if (UuidFromStringW(szGuid, (GUID *) ObjGuid)) {
                // Incorrect format.
                return 1;
            }
        }
        ccUfn = 0;
        // We must have correctly parsed out a guid.  No string name left.

    }
    else if (ccUfn > 4 && _wcsnicmp(pUfn, L"sid:", 4) == 0) {
        //
        // First check for the standard user friendly string form of
        // the sid.
        //
        if ((ccUfn>6) && // Must have more than just "sid:S-"
            _wcsnicmp(pUfn, L"sid:S-", 6) == 0) {
            PSID     pSid = NULL;
            PWCHAR   pTmpUfn;
            unsigned ccTmpUfn;

            // Make a copy of the user friendly name so that it can be
            // null terminated appropriately for ConvertStringSidToSid

            ccTmpUfn = ccUfn - 3;  // 4 for sid: add one for the 
                                   // terminating null

            pTmpUfn = THAllocEx(pTHS, ccTmpUfn * sizeof(*pTmpUfn));
            CopyMemory(pTmpUfn, pUfn + 4, ccTmpUfn * sizeof(*pTmpUfn));
            pTmpUfn[ccTmpUfn - 1] = L'\0';

            if (ConvertStringSidToSidW(pTmpUfn, &pSid)) {
                SidLen = RtlLengthSid(pSid);
                if (SidLen > sizeof(ObjSid)) {
                    // user has supplied a SID that is too long. We don't accept SIDs longer
                    // than 6 subauthorities.
                    LocalFree(pSid);
                    THFreeEx(pTHS, pTmpUfn);
                    return 1;
                }
                CopyMemory(ObjSid, pSid, SidLen);

                LocalFree(pSid); pSid = NULL;
                //
                // Success!
                //
                dwContents = foundSID;
                
                // We have correctly parsed out a sid.  No string name left.
                ccUfn=0;
            }

            THFreeEx(pTHS, pTmpUfn);
        }

        if (dwContents != foundSID) {
            //
            // It wasn't the the standard user friendly form.  Maybe it's the byte
            // encoded string form.
            //
            SidLen= (ccUfn - 4)/2; // Number of bytes that must be in the SID,
                                   // if this is indeed a Sid. Subtract 4 for
                                   // "SID:", leaving only the characters
                                   // which encode the string.  Divide by two
                                   // because each byte is encoded by two
                                   // characters.

            if((ccUfn<6) ||   // at least 2 for val, 4 for "SID:"
                (ccUfn & 1) || // Must be an even number of characters
                (SidLen > sizeof(NT4SID)) ){  // Max size for a SID
                    // Invalidly formatted
                    return 1;
            }
            pUfn+=4;
            dwContents = foundSID;
            for(j=0;j<SidLen;j++) {
                acTmp[0] = towlower(pUfn[0]);
                acTmp[1] = towlower(pUfn[1]);
                if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                    ObjSid[j] = (char) wcstol(acTmp, NULL, 16);
                    pUfn+=2;
                }
                else {
                    // Invalidly formatted name.
                    return 1;
                }
            }

            // We have correctly parsed out a sid.  No string name left.
            ccUfn=0;
        }
    }
    else if ((ccUfn > 2) && 
             (*pUfn == L'$') && 
             (DSNameExpandMacro (pTHS, pUfn, ccUfn, ppDN) == 0) ) {

        return 0;
    }

    // We may have parsed out either a GUID or a SID.  Build the DSNAME
    dnstructlen = DSNameSizeFromLen(ccUfn);
    *ppDN = (DSNAME *)THAllocEx(pTHS, dnstructlen);

    // Null out the DSName
    memset(*ppDN, 0, dnstructlen);

    (*ppDN)->structLen = dnstructlen;

    switch(dwContents) {

    case foundString:
        // Just a string name

        if(ccUfn) {
            WCHAR *pString = (*ppDN)->StringName;   // destination string
            WCHAR *p = pUfn;         // original string
            DWORD cc = ccUfn;        // num chars to process
            BOOL  fDoItFast = TRUE;

            // this loop is a substitute for
            // memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
            // we try to find out whether the DN passed in has an escaped constant
            while (cc > 0) {

                if (*p == L'"' || *p== L'\\') {
                    fDoItFast = FALSE;
                    break;
                }

                *pString++ = *p++;
                cc--;
            }
            
            (*ppDN)->NameLen = ccUfn;
            
            // if we have an escaped constant in the DN
            // we convert it to blockname and back to DN so as to
            // put escaping into a standardized form which will help
            // future comparisons
            //
            if (!fDoItFast) {
                ATTRBLOCK *pAttrBlock = NULL;
                DWORD err;

                memcpy((*ppDN)->StringName, pUfn, ccUfn * sizeof(WCHAR));
                (*ppDN)->StringName[ccUfn] = L'\0';

                err = DSNameToBlockName (pTHS, *ppDN, &pAttrBlock, DN2BN_PRESERVE_CASE);
                THFreeEx (pTHS, *ppDN); *ppDN = NULL;
                if (err) {
                    return err;
                }

                err = BlockNameToDSName (pTHS, pAttrBlock, ppDN);
                FreeBlockName (pAttrBlock);

                return err;
            }
            
        }
        break;

    case foundGUID:
        // we found a guid
        memcpy(&(*ppDN)->Guid, ObjGuid, sizeof(GUID));
        break;
        
    case foundSID:
        // we found a sid.
        if(SidLen) {
            // We must have found a SID

            // First validate the SID

            if ((RtlLengthSid(ObjSid) != SidLen) || (!RtlValidSid(ObjSid)))
            {
                return(1);
            }
            memcpy(&(*ppDN)->Sid, ObjSid, SidLen);
            (*ppDN)->SidLen = SidLen;
        }
        break;
    }

    // Null terminate the string if we had one (or just set the string to '\0'
    // if we didn't).
    (*ppDN)->StringName[ccUfn] = L'\0';

    return 0;
}


/*++ fhasDescendantNC
 *
 * Given the name of a purported DS object (in blockname format), this
 * routine scans the list of cross refernces held by this DSA and
 * returns TRUE if some object is the descendant of the purported DS object.
 *
 * INPUT:
 *    pObj    - name of the purported object, in blockname format
 *    pComArg - common argument flags
 * OUTPUT:
 *    none
 * RETURN VALUE:
 *    TRUE  - there is at least one cross ref that could be a descendant.
 *    FALSE - unable to verify that at least one cross reff could be a
 *            descendant
 *
 */
BOOL
fHasDescendantNC(
        THSTATE *pTHS,
        ATTRBLOCK *pObj,
        COMMARG *pComArg
        )
{
    NCL_ENUMERATOR nclEnum;

    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
    NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX2, pObj);
    if (NCLEnumeratorGetNext(&nclEnum)) {
        return TRUE;
    }

    if (!pComArg->Svccntl.dontUseCopy) {
        // copies are acceptable
        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX2, pObj);
        if (NCLEnumeratorGetNext(&nclEnum)) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
MangleRDN(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    )
/*
 * This is the excepting version of MangleRDN.
 * The base version, MangleRDNWithStatus, lives in parsedn.c
 */

{
    if (MangleRDNWithStatus( eMangleFor, pGuid, pszRDN, pcchRDN )) {
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0,
                       DSID(FILENO, __LINE__),
                       DS_EVENT_SEV_MINIMAL);        
    }
}

BOOL
IsExemptedFromRenameRestriction(THSTATE *pTHS, MODIFYDNARG *pModifyDNArg)
{
    // If the originating rename operation attempts to rename an RDN 
    // mangled due to repl conflict to its original name, then we 
    // would exempt the operation from rename restrictions. Rename restrictions
    // are dictated by the System-Flag setting on the object.
    // This function is used to exempt the rename restrictions on objects with 
    // mangled names due to naming conflicts so that the admin could rename it 
    // to its original name if he chooses after resolving the name conflict.
    // Of course, the assumption here is that the admin has made sure there is
    // no other object with that name when he attempts to rename the mangled-name
    // to the original name.

    WCHAR       RDNVal[MAX_RDN_SIZE];
    ATTRTYP     RDNType;
    ULONG       RDNLen;
    ULONG       PreservedRDNLen;
    ULONG       NewRDNLen;

    // Check if the name is mangled. Note that we don't check for mangle-type here.
    // The caller will have already excluded deleted objects.
    if (pModifyDNArg && pModifyDNArg->pObject && pModifyDNArg->pNewRDN
        && (0 == GetRDNInfo(pTHS, pModifyDNArg->pObject, RDNVal, &RDNLen, &RDNType))
        && (IsMangledRDNExternal( RDNVal, RDNLen, &PreservedRDNLen )))
    {
        // Input params are valid and this is an attempt to rename a Mangled RDN which
        // was mangled due to name conflict. Now we will Exempt this operation from 
        // rename restrictions if and only if the new RDN is same as the RDN of the object 
        // before the name was mangled(if the original name is preserved in the mangled name) or 
        // if the new RDN contains at least the preserved portion of the original name as a 
        // prefix (if the original name was not completely preserved in the mangled name)

        NewRDNLen = pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR);

        if (((NewRDNLen == PreservedRDNLen)
              || ((NewRDNLen > PreservedRDNLen)
                    && (MAX_RDN_SIZE == RDNLen)))
            && (0 == _wcsnicmp(RDNVal, 
                               (WCHAR *) pModifyDNArg->pNewRDN->AttrVal.pAVal->pVal, 
                               PreservedRDNLen)))
        {
            return TRUE;
        }
    }

    // we can't exempt this operation from rename restrictions
    return FALSE;    
}


unsigned
GenAutoReferral(THSTATE *pTHS,
                ATTRBLOCK *pTarget,
                WCHAR **ppDNS)
{
    int i,j;
    unsigned cc, cbVal;
    WCHAR *pDNS, *pDNScur;

    for (i=0; i<(int)(pTarget->attrCount); i++) {
        if (pTarget->pAttr[i].attrTyp != ATT_DOMAIN_COMPONENT) {
            break;
        }
    }

    if (i>0) {
        // Ok, we have (i) components at the top of the DN that are "DC=",
        // which means that we can construct a guess at a DNS name that might
        // map to whatever the guy is trying to read.
        cc = 0;
        for (j=0; j<i; j++) {
            cc += (pTarget->pAttr[j].AttrVal.pAVal[0].valLen / sizeof(WCHAR));
            ++cc;
        }

        // cc is now the count of chars in the new DNS addr we're going to
        // generate, so allocate enough space to hold it.  pDNS is a pointer
        // to the start of this buffer, and pDNScur is a pointer to the next
        // available character as we append.

        pDNS = THAllocEx(pTHS, sizeof(WCHAR)*cc);
        pDNScur = pDNS;

        for (j=i-1; j>=0; j--) {
            memcpy(pDNScur,
                   pTarget->pAttr[j].AttrVal.pAVal[0].pVal,
                   pTarget->pAttr[j].AttrVal.pAVal[0].valLen);
            pDNScur += pTarget->pAttr[j].AttrVal.pAVal[0].valLen / sizeof(WCHAR);
            if (j) {
                // Tack on a dot after everything but the last component
                *pDNScur = L'.';
                ++pDNScur;
            }
        }

        cbVal = ((DWORD)(pDNScur - pDNS))*sizeof(WCHAR);
        *ppDNS = pDNS;
    }
    else {
        cbVal = 0;
    }

    return cbVal;
} // GetAutoReferral

ULONG
ValidateCRDeletion(THSTATE *pTHS,
                   DSNAME  *pDN)
/*
 * This routine checks to see if it's ok if the CR object pDN is deleted.
 * It sets an error in pTHS if not.
 */
{
    DBPOS *pDBTmp;
    ULONG err;
    DWORD sysflags;
    CROSS_REF *pThisCR = NULL;

    DBOpen(&pDBTmp);
    __try {
        // PREFIX: dereferencing uninitialized pointer 'pDBTmp' 
        //         DBOpen returns non-NULL pDBTmp or throws an exception
        err = DBFindDSName(pDBTmp, pDN);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CANT_FIND_EXPECTED_NC,
                          err);
            __leave;
        }

        err = DBGetSingleValue(pDBTmp,
                               ATT_SYSTEM_FLAGS,
                               &sysflags,
                               sizeof(sysflags),
                               NULL);
        if (err) {
            sysflags = 0;
        }

        if ( sysflags & FLAG_CR_NTDS_NC ) {
            // If the CR is for an NC in our forest, we disallow deletion
            // if there exists a child NC.
            ULONG unused;
            DSNAME *pNC;
            CROSS_REF_LIST * pCRL;
            ATTCACHE *pAC;
            DSNAME *pDSA;
            
            err = DBGetAttVal(pDBTmp,
                              1,
                              ATT_NC_NAME,
                              0,
                              0,
                              &unused,
                              (UCHAR**)&pNC);

            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_CANT_FIND_EXPECTED_NC,
                              err);
                __leave;
            }

            pCRL = gAnchor.pCRL;

            // FUTURE-2002/03/14-BrettSh Note: this code could execute incorrectly,
            // and could determine (due to CR cache inconsistency) that we don't have 
            // an NC below the NC/crossRef we're trying to delete, when actually we do.
            // Once the CR cache can be trusted, we'll be OK.
            while (pCRL) {
                if (NamePrefix(pNC, pCRL->CR.pNC)) {
                    if (NameMatched(pNC, pCRL->CR.pNC)) {
                        Assert(NULL == pThisCR);
                        pThisCR = &pCRL->CR;
                    } else {
                        SetUpdError(UP_PROBLEM_CANT_ON_NON_LEAF,
                                    ERROR_DS_CANT_ON_NON_LEAF);
                        __leave;
                    }
                }
                pCRL = pCRL->pNextCR;
            }

            // If CR was found in the database as a deletion candidate, it
            // should have been found in the crossRef cache.
            LooseAssert(pThisCR != NULL && "CR is in the DB, but not in the CR cache", GlobalKnowledgeCommitDelay);

            if (pThisCR == NULL) {
               // Hmmm, we're trying to delete a crossRef that we found the object for, 
               // but couldn't find the crossRef cache entry for.  Seems unlikely, lets
               // return busy and wait for the CR cache to catch up.
               SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
               __leave;
            }

            if (!fIsNDNCCR(pThisCR)) {
                // If the CR is for a domain/config/schema NC which is still
                // mastered by someone, we disallow deletion.  Does this cause
                // complications for legitimate uninstall?  DC demotion only
                // deletes a CR when demoting the last DC in a non-root domain.
                // And in those cases, the NTDS-DSA object is deleted first on
                // the same DC.  Thus the DC hosting the CR deletion truly
                // should have no NTDS-DSA whose msDS-hasMasterNCs point to the 
                // NC in question when the CR deletion is requested during DC
                // demotion.
    
    
                // Seek to NC head.  GC-ness has been verified before
                // we got here, thus we can expect to have a copy of
                // all NCs which are active (modulo replication latency).
                switch ( err = DBFindDSName(pDBTmp, pNC) ) {
                case 0:
                case DIRERR_NOT_AN_OBJECT:
                    // Found an instantiated object or a phantom.
                    // See if the new or old msDS-HasMasteredBy has any values.
                    pAC = SCGetAttById(pTHS, ATT_MS_DS_MASTERED_BY);
                    Assert(NULL != pAC);
                    Assert(FIsBacklink(pAC->ulLinkID));
                    switch ( err = DBGetAttVal_AC(pDBTmp, 1, pAC, 
                                                  0, 0, &unused, 
                                                  (UCHAR **) &pDSA) ) {
                    case DB_success:
                        // Someone masters this NC - reject the delete.
                        THFreeEx(pTHS, pDSA);
                        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_NC_STILL_HAS_DSAS);
                        __leave;
                    case DB_ERR_NO_VALUE:

                        // Maybe a win2k DC uses this NC, check old hasMasteredBy attr
                        pAC = SCGetAttById(pTHS, ATT_MASTERED_BY);
                        Assert(NULL != pAC);
                        Assert(FIsBacklink(pAC->ulLinkID));
                        switch ( err = DBGetAttVal_AC(pDBTmp, 1, pAC, 
                                                      0, 0, &unused, 
                                                      (UCHAR **) &pDSA) ) {
                        case DB_success:
                            // Someone masters this NC - reject the delete.
                            THFreeEx(pTHS, pDSA);
                            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                        ERROR_DS_NC_STILL_HAS_DSAS);
                            __leave;
                        case DB_ERR_NO_VALUE:
                            // No one masters this NC - nothing to object to.
                            break;
                        default:
                            SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                          DIRERR_DATABASE_ERROR, err);
                            __leave;
                        }

                        // No one masters this NC - nothing to object to.
                        break;
                    default:
                        SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                      DIRERR_DATABASE_ERROR, err);
                        __leave;
                    }
                    break;
                case DIRERR_OBJ_NOT_FOUND:
                    // If we have the crossRef we must at least have a phantom
                    // for the ncName.  Is the CR cache incoherent?  Fall
                    // through to return an error.
                default:
                    SetSvcErrorEx(SV_PROBLEM_BUSY, 
                                  DIRERR_DATABASE_ERROR, err);
                    __leave;
                }
            }
        }
    } __finally {
        DBClose(pDBTmp, TRUE);
    }

    return pTHS->errCode;
}

// This routine was not located in parsedn.c because parsedn.c is included in client
// libraries and is a more restricted environment.
void
SpliceDN(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pOriginalDN,
    IN  DSNAME *    pNewParentDN,   OPTIONAL
    IN  WCHAR *     pwchNewRDN,     OPTIONAL
    IN  DWORD       cchNewRDN,      OPTIONAL
    IN  ATTRTYP     NewRDNType,     OPTIONAL
    OUT DSNAME **   ppNewDN
    )
/*++

Routine Description:

    Construct a new DN from the original DN, an optional new parent DN, and an
    optional new RDN.  The resultant DN has the same GUID/SID as the original.

Arguments:

    pTHS (IN) - THSTATE.

    pOriginalDN (IN) - Original DN.

    pNewParentDN (IN, OPTIONAL) - Parent DN to substitute for the original
        parent.  May be NULL, in which case the new parent is the same as the
        original parent.

    pwchNewRDN (IN, OPTIONAL) - RDN to substitute for the original RDN.  May be
        NULL, in which case the new RDN is that same as the original RDN.

    cchNewRDN (IN, OPTIONAL) - Length in characters of pwchNewRDN.  Ignored if
        pwchNewRDN is NULL.

    NewRDNType (IN, OPTIONAL) - Class-specific RDN type (e.g., ATT_COMMON_NAME)
        for the new RDN.  Ignored if pwchNewRDN is NULL.

    ppNewDN (OUT) - On return, holds a pointer to the spliced DN.

Return Values:

    None.  Throws exception on error.

--*/
{
    DWORD cchNewDN;
    BOOL bNewParentDNAllocd = FALSE;
    BOOL bNewRDNAllocd = FALSE;

    Assert(pNewParentDN || pwchNewRDN);
    Assert(!pwchNewRDN || (NewRDNType && (ATT_RDN != NewRDNType)));

    if (NULL == pNewParentDN) {
        // New parent is the same as the old parent.
        pNewParentDN = THAllocEx(pTHS, pOriginalDN->structLen);
        bNewParentDNAllocd = TRUE; // signal that this was alloc'd and should be cleaned up
        if (TrimDSNameBy(pOriginalDN, 1, pNewParentDN)) {
            DRA_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
        }
    }

    if (NULL == pwchNewRDN) {
        // New parent is the same as the old parent.
        // New RDN is the same as the old RDN.
        pwchNewRDN = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * MAX_RDN_SIZE);
        bNewRDNAllocd = TRUE; // signal that this was alloc'd and should be cleaned up
        if (GetRDNInfo(pTHS, pOriginalDN, pwchNewRDN, &cchNewRDN, &NewRDNType)) {
            DRA_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
        }
    }

    // Construct new DN from new parent and new RDN.
    cchNewDN = pNewParentDN->NameLen + cchNewRDN + MAX_RDN_KEY_SIZE + 4;
    *ppNewDN = (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(cchNewDN));

    if (AppendRDN(pNewParentDN,
                  *ppNewDN,
                  DSNameSizeFromLen(cchNewDN),
                  pwchNewRDN,
                  cchNewRDN,
                  NewRDNType)) {
        DRA_EXCEPT(ERROR_DS_INTERNAL_FAILURE, 0);
    }

    Assert((*ppNewDN)->NameLen <= cchNewDN);

    // Copy the GUID & SID from the original DN to the new DN.
    (*ppNewDN)->Guid   = pOriginalDN->Guid;
    (*ppNewDN)->Sid    = pOriginalDN->Sid;
    (*ppNewDN)->SidLen = pOriginalDN->SidLen;

    if(bNewParentDNAllocd && pNewParentDN != NULL) THFreeEx(pTHS, pNewParentDN);
    if(bNewRDNAllocd && pwchNewRDN != NULL) THFreeEx(pTHS, pwchNewRDN);

}


VOID
CheckNCRootNameOwnership(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    )

/*++

Routine Description:

This routine is called in at least three circumstances where we know that a cross-ref
has just been removed.  In all cases we know that ownership the name pointed to by its
ncName attribute is being released.  We want to check if there is another cross-ref which
wants this name. If so, we fix up the other cross-ref to have the name.  The cases are:
1. NC teardown in the KCC (removal of replica)
2. Remove auto subref where the referent was a subref

We don't call this code when the cross-ref is being removed and the ncname referent is a
phantom. The reason is that a phantom reference will not hold a name that causes others to
get conflicts. A phantom will always lose in a conflict resolution, and thus the latest
cross-ref object to use the same name will win and not be conflicted in the first place.

We check the cross reference list for a cross-ref with a conflicted name. If we find one,
we unmangle it and see if it matches the NC we are tearing down. If so, then we unmangle
the name of the new NC head so that it can have the good name. The cross-ref ncName attribute
gets fixed up by virtue of being a reference. We must adjust the cross-ref cache so that it
also uses the correct name. 

We only fix the first cross-ref that we find in this conflicted state.

The caller must commit the transaction.

This routine has no name conflict retry logic. It is assumed that the caller has already
taken care of mangling the old holder of the name.  This is always called after having
disposed of the NCHEAD, and so there shouldn't be anything to conflict with!

Arguments:

    pTHS - Thread state
    pNC - Unmangled name of NC to check for

Return Value:

   Exceptions raised

--*/

{
    ULONG ret = 0;
    CROSS_REF_LIST * pCRL;
    WCHAR wchRDNOld[MAX_RDN_SIZE];
    WCHAR wchRDNTemp[MAX_RDN_SIZE];
    WCHAR wchRDNNew[MAX_RDN_SIZE];
    DWORD cchRDNOld, cchRDNTemp, cchRDNNew;
    ATTRTYP attrtypRDNOld, attrtypRDNTemp;
    ATTRVAL attrvalRDN;
    GUID guidMangled, guidSave;
    MANGLE_FOR eMangleFor;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    DPRINT1( 1, "Enter CheckNCRootNameOwnership nc %ws\n", pNC->StringName );

    if (fNullUuid(&pNC->Guid)) {
        // A guid-less phantom's name is being freed up.
        // A guid-less phantom cannot conflict with another name
        // There is no work to do
        return;
    }

    // Get the Old RDN
    if (GetRDNInfo(pTHS, pNC, wchRDNOld, &cchRDNOld, &attrtypRDNOld)) {
        DRA_EXCEPT(ERROR_DS_DRA_INTERNAL_ERROR, 0);
    }

    // The presented name better not be mangled!
    if (IsMangledRDN( wchRDNOld, cchRDNOld, &guidMangled, &eMangleFor )) {
        // A mangled name is being freed up. These are not useful to us.
        return;
    }

    // The NC we are given should one that has been removed, and the name should
    // be free. Not in use in any way.
    // Null out guid so that search is by StringName

    guidSave = pNC->Guid;
    memset( &(pNC->Guid), 0, sizeof(GUID) );
    __try {
        ret = DBFindDSName( pTHS->pDB, pNC );
    } __finally {
        pNC->Guid = guidSave;
    }
    if ( ret != DIRERR_OBJ_NOT_FOUND ) {
        // Found as either an object or a phantom, or if an error occurred
        // If the name is still in use, we cannot transfer it to anyone else.
        // This can occur when an NC is removed but the cross-ref still exists,
        // such as when a machine is un-GC'd.
        Assert( !"NC Root name is still in use as obj or phantom" );
        return;
    }

    // See if there exists another cross-ref with a mangled version of this name.
    // We do this by mangling the present NC and comparing. We do not try to
    // unmangle the name on the cross-ref, since during unmangling there may be
    // loss of information due to truncation of the name.

    for( pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR ) {
        BOOL fMatch;
        DSNAME *pMatchDN = NULL;

        // See if the CRL is a candidate. Get the RDN.
        if (GetRDNInfo(pTHS, pCRL->CR.pNC, wchRDNTemp, &cchRDNTemp, &attrtypRDNTemp)) {
            DRA_EXCEPT(ERROR_DS_DRA_INTERNAL_ERROR, 0);
        }

        // Only interesting if it is mangled
        if (!IsMangledRDN( wchRDNTemp, cchRDNTemp, &guidMangled, &eMangleFor )) {
            continue;
        }
        // It better have been mangled from a name conflict
        if (eMangleFor != MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT) {
            // It is possible to encounter a delete mangled NCName in the cross-ref
            // cache. This is a transient condition, possibly caused the knowledge of the
            // deletion of the nc head preceeding the knowledge of the removal of the
            // cross-ref itself.
            continue;
        }

        // RDN types must match
        if (attrtypRDNOld != attrtypRDNTemp) {
            Assert( !"unexpected attribute type mismatch" );
            continue;
        }

        DPRINT3( 1, "cross_ref %p name %ws nc %ws is mangled\n",
                 &(pCRL->CR), pCRL->CR.pObj->StringName, pCRL->CR.pNC->StringName );

        // See if the mangled name in the cross-ref matches another mangled name
        // based on the RDN of the presented name.

        wcsncpy( wchRDNNew, wchRDNOld, cchRDNOld );
        cchRDNNew = cchRDNOld;
        MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
                  &guidMangled,
                  (WCHAR *) wchRDNNew,
                  &cchRDNNew);
        
        // Construct the matching name. It has the RDN of the presented name, the guid of the
        // candidate on the cross ref, and the remainder based on the presented name.
        SpliceDN(
            pTHS,
            pNC,            // Original DN
            NULL,           // New parent same as the original
            wchRDNNew,      // New RDN
            cchRDNNew,      // Length in chars of new RDN
            attrtypRDNOld,     // RDN type
            &pMatchDN   // New DN
            );

        DPRINT2( 1, "Checking match: match dn %ws, cr nc dn %ws\n",
                 pMatchDN->StringName, pCRL->CR.pNC->StringName);

        fMatch = NameMatchedStringNameOnly(pMatchDN, pCRL->CR.pNC);

        THFreeEx(pTHS, pMatchDN);

        if ( fMatch ) {
            break;
        }
    }
    if (!pCRL) {
        return;
    }

    DPRINT1( 1, "NC %ws needs to have its name unmangled\n",
             pCRL->CR.pNC->StringName);

    attrvalRDN.valLen = cchRDNOld * sizeof(WCHAR);
    attrvalRDN.pVal = (UCHAR *) wchRDNOld;

    // We need to correct the name on the object referenced by the ncName
    // on the cross-ref. The object is most likely a phantom or a subref.
    // It should not be an instantiated NC head. Position on it.
    ret = DBFindDSName(pTHS->pDB, pCRL->CR.pNC);
    if ( ret && (ret != DIRERR_NOT_AN_OBJECT) ) {
        DPRINT2( 0, "Failed to find mangled object or phantom for %ws, ret = %d\n",
                 pCRL->CR.pNC->StringName, ret );
        LogUnhandledError( ret );
        DRA_EXCEPT(ERROR_DS_DATABASE_ERROR, ret);
    }

    // If it is an object, verify we are on the right one
    if (!ret) {
        DSNAME *pActualDN = NULL;
        DWORD len = 0, it;

        if ( (ret = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0, 0, &len, (UCHAR**)&pActualDN)) ||
             (ret = DBGetSingleValue(pTHS->pDB, ATT_INSTANCE_TYPE, &it, sizeof(it), NULL)) ) {
            // invalid object?
            DRA_EXCEPT( ret, 0 );
        }

        DPRINT2( 1, "%ws is a subref with it %d\n", pActualDN->StringName, it );

        // Make sure we didn't get pointed back at ourself. Guids should be different.
        if (NameMatched(pNC,pActualDN)) {
            DRA_EXCEPT(ERROR_DS_DRA_INTERNAL_ERROR, 0);
        }
        if (it != SUBREF) {
            // Object not what we expected.
            // We are not authoritative to change this object
            Assert( !"Candidate for ncName unmangling has unexpected instance type" );
            return;
        }
        // Make sure object not deleted
        if (DBIsObjDeleted(pTHS->pDB)) {
            DRA_EXCEPT(ERROR_DS_DRA_INTERNAL_ERROR, 0);
        }

        // Make sure the actual object is mangled in a way we expect
        cchRDNTemp = 0;
        if (GetRDNInfo(pTHS, pActualDN, wchRDNTemp, &cchRDNTemp, &attrtypRDNTemp)) {
            DRA_EXCEPT(ERROR_DS_DRA_INTERNAL_ERROR, 0);
        }
        // It better be mangled
        if (!IsMangledRDN( wchRDNTemp, cchRDNTemp, &guidMangled, &eMangleFor )) {
            Assert( !"Candidate for ncName unmangling is not mangled?" );
            return;
        }
        // It better have been mangled from a name conflict
        if (eMangleFor != MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT) {
            DRA_EXCEPT(ERROR_DS_DRA_INTERNAL_ERROR, 0);
        }

        THFreeEx(pTHS, pActualDN);
    }

    // Give the mangled phantom the original name
    ret = DBResetRDN( pTHS->pDB, &attrvalRDN );
    if(!ret) {
        ret = DBUpdateRec(pTHS->pDB);
    }
    if (!ret) {
        // Modify cross-ref object caching
        ModCrossRefCaching( pTHS, &(pCRL->CR) );
    }
    if (ret) {
        DPRINT4( 0, "Failed to reset rdn to '%*.*ws', ret = %d\n",
                 cchRDNOld, cchRDNOld, wchRDNOld, ret );
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_DRA_NCNAME_CONFLICT_RENAME_FAILURE,
                   szInsertDN(pCRL->CR.pObj),
                   szInsertDN(pCRL->CR.pNC),
                   szInsertDN(pNC),
                   szInsertWin32Msg(ret),
                   szInsertWin32ErrCode(ret),
                   NULL, NULL, NULL );
        // Rename failed; bail.
        DRA_EXCEPT( ret, 0 );
    }

    // Assume the caller will commit

    DPRINT2( 0, "Renamed conflicted NC HEAD RDN from %ws to %ws.\n",
             pCRL->CR.pNC->StringName, pNC->StringName );

    LogEvent( DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_MINIMAL,
              DIRLOG_DRA_NCNAME_CONFLICT_RENAME_SUCCESS,
              szInsertDN(pCRL->CR.pObj),
              szInsertDN(pCRL->CR.pNC),
              szInsertDN(pNC) );

    DPRINT( 1, "Exit CheckNCRootNameOwnership\n" );

} /* CheckNCRootNameOwnership */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdmoddn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdmoddn.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains routines for changing an object's DN prefix, a.k.a.
    moving an object. These routines implement DirModifyDN.

    An object can be moved within an NC, across NC boundaries, or across
    domain boundaries (which means moving it across machine boundaries in
    the first version of the product, since there is one DSA per machine).

Author:

    Exchange DS Team

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    04-Jun-97
        Added routines for cross-NC and cross-domain moves.
    ChrisMay    16-May-97
        Changes per code review: changed local-move vs remote-move detection
        logic, added service control flag, clean up, more attribute fix-up
        routines.
    ChrisMay    18-Jun-97
        Changes per code review, enabled inter-domain move if the target DSA
        name is different from DSA originating the move, bug fixes, added the
        proxy-object-name attribute, added routine to free readres memory.
    ChrisMay    07-Oct-97
        Collapsed separate phantom and proxy transactions into one transact-
        ion.

--*/



#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA Headers

#include <ntdsa.h>
#include <scache.h>     // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>       // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>       // needed for output allocation
#include <samsrvp.h>            // to support CLEAN_FOR_RETURN()
#include <drsuapi.h>            // I_DRSInterDomainMove
#include <ntdsctr.h>

// SAM Interoperability Headers

#include <mappings.h>

// Logging Headers
#include <dstrace.h>
#include "dsevent.h"        // header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"        // header for error codes

// Assorted DSA Headers

#include "objids.h"             // Defines for selected atts
#include "anchor.h"
#include "drautil.h"
#include <permit.h>             // permission constants
#include "debug.h"      // standard debugging header
#include "drameta.h"
#include <sdconvrt.h>           // SampGetDefaultSecurityDescriptorForClass
#include <dsjet.h>
#include <dbintrnl.h>
#include <sdprop.h>             // SD Propagator routines
#include <drserr.h>
#include <dsconfig.h>

#include "sspi.h"               // credential handling support
#include "kerberos.h"           // MICROSOFT_KERBEROS_NAME_A
#include "sddl.h"               // Convert*SecurityDescriptor
#include "lmaccess.h"           // UF_* constants
#include <xdommove.h>

#define DEBSUB "MDMODDN:"       // define the subsystem for debugging
#include <fileno.h>
#define  FILENO FILENO_MDMODDN

// Macros And Constants

#define DEBUG_BUF_SIZE          256

// PADDING is added to dynamically allocated DSNAME buffers to accommodate
// any extra bytes that are added during the construction of a DN (such as
// commas, "CN=", etc. by functions such as AppendRDN.

#define PADDING                 32
#define MAX_MACHINE_NAME_LENGTH (MAX_COMPUTERNAME_LENGTH + 3)

// External Functions

extern ULONG AcquireRidFsmoLock(DSNAME *pDomainDN, int msToWait);
extern VOID  ReleaseRidFsmoLock(DSNAME *pDomainDN);
extern BOOL  IsRidFsmoLockHeldByMe();

// Internal Functions

ULONG
DirModifyDNWithinDomain(
    IN MODIFYDNARG*  pModifyDNArg,
    IN MODIFYDNRES** ppModifyDNRes
    );

ULONG
DirModifyDNAcrossDomain(
    IN  MODIFYDNARG* pModifyDNArg,
    OUT MODIFYDNRES** ppModifyDNRes
    );

int
CheckForSchemaRenameAllowed(
    THSTATE *pTHS
    );

extern const GUID INFRASTRUCTURE_OBJECT_GUID;


//============================================================================
//
//                      DN Modification (a.k.a. Move Object)
//
//============================================================================

ULONG
DirModifyDN(
    IN  MODIFYDNARG* pModifyDNArg,
    OUT MODIFYDNRES** ppModifyDNRes
    )

/*++

Routine Description:

    This routine is the server-side entry point for moving an object, a.k.a.
    modify DN.

    If the incoming pModifyDNArg does not specify a destination DSA inside
    the pModifyDNArg parameter (i.e. NULL value), it is assumed that this
    is an intra-NC move, and LocalModifyDN is invoked.  Otherwise it is
    assumed to be a cross domain move.

Arguments:

    pModifyDNArg - Pointer, structure containing the source object name,
        the new parent name, and the object's attributes.

    ppModifyDNRes - Pointer, outcome results, if the move failed for any
        reason, the error information is contained in this structure.

Return Value:

    This routine returns zero if successful, otherwise a DS error code is
    returned.

--*/

{
    if (eServiceShutdown) {
        return(ErrorOnShutdown());
    }

    if ( !pModifyDNArg->pDSAName )
    {
        return(DirModifyDNWithinDomain(pModifyDNArg, ppModifyDNRes));
    }

    return(DirModifyDNAcrossDomain(pModifyDNArg, ppModifyDNRes));
}

//============================================================================
//
//                  DN Modification Across Domain Boundaries
//
//============================================================================

#if DBG

VOID
FpoSanityCheck(
    THSTATE *pTHS,
    ATTR    *pAttr)

/*++

  Routine Description:

    According to MurliS, universal groups may not have FPOs as members.
    We only get here if we're moving a universal group.  Test the claim.

  Arguments:

    pTHS - THSTATE pointer.

    pAttr - ATTR representing the membership.

  Return Values:

    TRUE on success, FALSE otherwise

--*/

{
    DWORD   i;
    DSNAME  *pMember;
    ATTRTYP class;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(ATT_MEMBER == pAttr->attrTyp);

    for ( i = 0; i < pAttr->AttrVal.valCount; i++ )
    {
        pMember = (DSNAME *) pAttr->AttrVal.pAVal[i].pVal;

        if (    !DBFindDSName(pTHS->pDB, pMember)
             && !DBGetSingleValue(pTHS->pDB, ATT_OBJECT_CLASS, &class,
                                  sizeof(class), NULL) )
        {
             Assert(CLASS_FOREIGN_SECURITY_PRINCIPAL != class);
        }
    }
}

#endif

ULONG
VerifyObjectForMove(
    THSTATE     *pTHS,
    READRES     *pReadRes,
    DSNAME      *pNewName,
    DSNAME      **ppSourceNC,
    DSNAME      **ppExpectedTargetNC,
    CLASSCACHE  **ppCC
    )

/*++

Routine Description:

    Verify that an object is a legal cross domain move candidate.

Arguments:

    pReadRes - Pointer to READRES which contains ALL the object's attrs.

    pNewName - Pointer to DSNAME for desired new name in remote domain.

    ppSourceNC - Updated on success with pointer to DSNAME of source object NC.

    ppExpectedTargetNC - Updated on success with pointer to DSNAME of
        expected NC pNewName will go in.  Used to sanity check knowledge
        information with the destination.

        ppCC - Updated on success with pointer to object's CLASSCACHE entry.

Return Value:

    pTHS->errCode

--*/

{
    ULONG                   i, j;
    ATTR                    *pAttr;
    CLASSCACHE              *pCC = NULL;            //initialized to avoid C4701
    DWORD                   dwTmp;
    BOOL                    boolTmp;
    NT4SID                  domSid;
    ULONG                   objectRid;
    ULONG                   primaryGroupRid = 0;    // 0 == invalid RID value
    DWORD                   groupType = 0;
    DWORD                   cMembers = 0;
    ATTR                    *pMembers = NULL;
    NT4SID                  tmpSid;
    DWORD                   tmpRid;
    COMMARG                 commArg;
    CROSS_REF               *pOldCR;
    CROSS_REF               *pNewCR;
    ULONG                   iSamClass;
    BOOL                    fSidFound = FALSE;
    NTSTATUS                status;
    ULONG                   cMemberships;
    PDSNAME                 *rpMemberships;
    ATTCACHE                *pAC;
    ULONG                   len;
    SYNTAX_DISTNAME_BINARY  *puc;
    DWORD                   flagsRequired;
    ULONG                   cNonMembers = 0;

    // SAM reverse membership check requires an open transaction.
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    *ppSourceNC = NULL;
    *ppExpectedTargetNC = NULL;
    *ppCC = NULL;

    // Perform sanity checks against various attributes.

    for ( i = 0; i < pReadRes->entry.AttrBlock.attrCount; i++ )
    {
        pAttr = &pReadRes->entry.AttrBlock.pAttr[i];

        switch ( pAttr->attrTyp )
        {
        case ATT_OBJECT_CLASS:

            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;

            if (   (NULL == (pCC = SCGetClassById(pTHS, dwTmp)))
                 || pCC->bDefunct)
            {
                return(SetUpdError( UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                    DIRERR_OBJ_CLASS_NOT_DEFINED));
            }
            else if ( pCC->bSystemOnly )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_CANT_MOD_SYSTEM_ONLY));
            }

            *ppCC = pCC;

            // Disallow move of selected object classes.  The same object
            // may have failed on another test later on, but this is a
            // convenient and easy place to catch some obvious candidates.

            for ( j = 0; j < pAttr->AttrVal.valCount; j++ )
            {
                Assert(sizeof(DWORD) == pAttr->AttrVal.pAVal[j].valLen);
                switch ( * (DWORD *) pAttr->AttrVal.pAVal[j].pVal )
                {
                // Keep following list alphabetical.
                case CLASS_ADDRESS_BOOK_CONTAINER:
                case CLASS_ATTRIBUTE_SCHEMA:
                case CLASS_BUILTIN_DOMAIN:
                case CLASS_CERTIFICATION_AUTHORITY:         // Trevor Freeman
                case CLASS_CLASS_SCHEMA:
                case CLASS_CONFIGURATION:
                case CLASS_CRL_DISTRIBUTION_POINT:          // Trevor Freeman
                case CLASS_CROSS_REF:
                case CLASS_CROSS_REF_CONTAINER:
                case CLASS_DMD:
                case CLASS_DOMAIN:
                case CLASS_DSA:
                case CLASS_FOREIGN_SECURITY_PRINCIPAL:
                // Following covers phantom update objects as well as
                // proxies for cross domain moves.
                case CLASS_INFRASTRUCTURE_UPDATE:
                case CLASS_LINK_TRACK_OBJECT_MOVE_TABLE:
                case CLASS_LINK_TRACK_OMT_ENTRY:
                case CLASS_LINK_TRACK_VOL_ENTRY:
                case CLASS_LINK_TRACK_VOLUME_TABLE:
                case CLASS_LOST_AND_FOUND:
                case CLASS_NTDS_CONNECTION:
                case CLASS_NTDS_DSA:
                case CLASS_NTDS_SITE_SETTINGS:
                case CLASS_RID_MANAGER:
                case CLASS_RID_SET:
                case CLASS_SAM_DOMAIN:
                case CLASS_SAM_DOMAIN_BASE:
                case CLASS_SAM_SERVER:
                case CLASS_SITE:
                case CLASS_SITE_LINK:
                case CLASS_SITE_LINK_BRIDGE:
                case CLASS_SITES_CONTAINER:
                case CLASS_SUBNET:
                case CLASS_SUBNET_CONTAINER:
                case CLASS_TRUSTED_DOMAIN:

                    return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                        ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
                }
            }

            break;

        case ATT_SYSTEM_FLAGS:

            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;

            if (    (dwTmp & FLAG_DOMAIN_DISALLOW_MOVE)
                 || (dwTmp & FLAG_DISALLOW_DELETE) )
            {
                // Use same error message as for intra-NC case.
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_ILLEGAL_MOD_OPERATION));
            }

            break;

        case ATT_IS_CRITICAL_SYSTEM_OBJECT:

            boolTmp = * (BOOL *) pAttr->AttrVal.pAVal[0].pVal;

            if ( boolTmp )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_ILLEGAL_MOD_OPERATION));
            }

            break;

        case ATT_PRIMARY_GROUP_ID:

            Assert(0 == primaryGroupRid);
            primaryGroupRid = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;
            break;

        case ATT_GROUP_TYPE:

            Assert(0 == groupType);
            groupType = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;
            break;

        case ATT_MEMBER:

            Assert(0 == cMembers);
            pMembers = pAttr;
            cMembers = pAttr->AttrVal.valCount;
            break;

        case ATT_MS_DS_NON_MEMBERS:

            cNonMembers = pAttr->AttrVal.valCount;
            break;

        case ATT_USER_ACCOUNT_CONTROL:

            // Note that the DS persists UF_* values as per lmaccess.h,
            // not USER_* values as per ntsam.h.   Restrict moves of DCs
            // and trust objects.  WKSTA and server can move.


            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;

            if (    (dwTmp & UF_SERVER_TRUST_ACCOUNT)           // DC
                 || (dwTmp & UF_INTERDOMAIN_TRUST_ACCOUNT) )    // SAM trust
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            break;

        case ATT_OBJECT_SID:

            Assert(!fSidFound);
            Assert(pAttr->AttrVal.pAVal[0].valLen <= sizeof(NT4SID));

            SampSplitNT4SID(    (NT4SID *) pAttr->AttrVal.pAVal[0].pVal,
                                &domSid,
                                &objectRid);

            if ( objectRid < SAMP_RESTRICTED_ACCOUNT_COUNT )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            fSidFound = TRUE;
            break;

        case ATT_INSTANCE_TYPE:

            dwTmp = * (DWORD *) pAttr->AttrVal.pAVal[0].pVal;

            if (    !(dwTmp & IT_WRITE)
                 || (dwTmp & IT_NC_HEAD)
                 || (dwTmp & IT_UNINSTANT) )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            break;

        case ATT_IS_DELETED:

            boolTmp = * (BOOL *) pAttr->AttrVal.pAVal[0].pVal;

            if ( boolTmp )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_CANT_MOVE_DELETED_OBJECT));
            }

            break;

        // Add additional ATTRTYP-specific validation cases here ...
        }
    }

    // In theory, there are many cases where it is legal to move groups.
    // For example, account groups which have no members and are not a
    // member of any account groups themselves.  Or resource groups which
    // are themselves not members of other resource groups.  Given that
    // explaining all this to the customer is difficult and that most
    // groups can be converted to universal groups, we boil it down to
    // two simple rules.  We will move any kind of group except a local
    // group if it has no members and we will move universal groups
    // with members.

    if ( GROUP_TYPE_BUILTIN_LOCAL_GROUP & groupType )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
    }
    else if ( (GROUP_TYPE_ACCOUNT_GROUP & groupType) && (cMembers || cNonMembers) )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_CANT_MOVE_ACCOUNT_GROUP));
    }
    else if ( (GROUP_TYPE_RESOURCE_GROUP & groupType) && (cMembers || cNonMembers) )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_CANT_MOVE_RESOURCE_GROUP));
    }
    else if ( (GROUP_TYPE_APP_BASIC_GROUP & groupType) && (cMembers || cNonMembers) )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_CANT_MOVE_APP_BASIC_GROUP));
    }
    else if ( (GROUP_TYPE_APP_QUERY_GROUP & groupType) && (cMembers || cNonMembers))
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_CANT_MOVE_APP_QUERY_GROUP));
    }
    else if ( GROUP_TYPE_UNIVERSAL_GROUP & groupType )
    {
#if DBG
        if ( cMembers && pMembers )
        {
            FpoSanityCheck(pTHS, pMembers);
        }
#endif

    }

    // Disallow moves of security principals which are members of
    // account groups as once the principal is in another domain, the
    // carried forward memberships would be ex-domain, and therefore
    // illegal as per the definition of an account group.

    if ( fSidFound && SampSamClassReferenced(pCC, &iSamClass) )
    {
        // fSidFound ==> SampSamClassReferenced, but not vice versa.
        Assert(fSidFound ? SampSamClassReferenced(pCC, &iSamClass) : TRUE);

        status = SampGetMemberships(
                            &pReadRes->entry.pName,
                            1,
                            gAnchor.pDomainDN,
                            RevMembGlobalGroupsNonTransitive,
                            &cMemberships,
                            &rpMemberships,
                            0,
                            NULL,
                            NULL);

        if ( !NT_SUCCESS(status) )
        {
            return(SetSvcError( SV_PROBLEM_BUSY,
                                RtlNtStatusToDosError(status)));
        }
        else if ( 1 == cMemberships )
        {
            SampSplitNT4SID(&rpMemberships[0]->Sid, &tmpSid, &tmpRid);

            // Bail if the membership SID doesn't represent the user's
            // primary group RID.  We compare the RID and domain SID
            // separately.

            if (    (primaryGroupRid != tmpRid)
                 || !RtlEqualSid(&tmpSid, &domSid) )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS));
            }
        }
        else if ( cMemberships > 1 )
        {
            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS));
        }
    }

    // Verify that this is really a cross domain move.  We could be faked
    // into a cross forest move if someone added cross-refs for the other
    // forest.  So we check for cross-ref existence AND whether its for a
    // domain or not.

    flagsRequired = (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);

    Assert(pReadRes->entry.pName->NameLen && pNewName->NameLen);
    InitCommarg(&commArg);

    if (    !(pOldCR = FindBestCrossRef(pReadRes->entry.pName, &commArg))
         || (flagsRequired != (pOldCR->flags & flagsRequired)) )
    {
        return(SetNamError( NA_PROBLEM_NO_OBJECT,
                            pReadRes->entry.pName,
                            DIRERR_CANT_FIND_EXPECTED_NC));
    }
    else if (    !(pNewCR = FindBestCrossRef(pNewName, &commArg))
              || (flagsRequired != (pNewCR->flags & flagsRequired)) )
    {
        return(SetNamError( NA_PROBLEM_NO_OBJECT,
                            pNewName,
                            DIRERR_CANT_FIND_EXPECTED_NC));
    }
    else if ( NameMatched(pOldCR->pNC, pNewCR->pNC) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewName,
                            ERROR_DS_SRC_AND_DST_NC_IDENTICAL));
    }
    else if (    NameMatched(pOldCR->pNC, gAnchor.pConfigDN)
              || NameMatched(pNewCR->pNC, gAnchor.pConfigDN)
              || NameMatched(pOldCR->pNC, gAnchor.pDMD)
              || NameMatched(pNewCR->pNC, gAnchor.pDMD) )
    {
        return(SetNamError( NA_PROBLEM_NO_OBJECT,
                            pNewName,
                            ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
    }

    *ppSourceNC = pOldCR->pNC;
    *ppExpectedTargetNC = pNewCR->pNC;

    // Disallow move of well known objects.

    Assert(NameMatched(gAnchor.pDomainDN, pOldCR->pNC));    // product 1

    if (    !(pAC = SCGetAttById(pTHS, ATT_WELL_KNOWN_OBJECTS))
         || DBFindDSName(pTHS->pDB, gAnchor.pDomainDN) )
    {
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
    }

    for ( i = 1; TRUE; i++ )
    {
        puc = NULL;
        dwTmp = DBGetAttVal_AC(pTHS->pDB, i, pAC, 0, 0, &len, (UCHAR **) &puc);

        if ( 0 == dwTmp )
        {
            if ( NameMatched(pReadRes->entry.pName, NAMEPTR(puc)) )
            {
                THFreeEx(pTHS, puc);
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
            }

            THFreeEx(pTHS, puc);
        }
        else if ( DB_ERR_NO_VALUE == dwTmp )
        {
            break;      // for loop
        }
        else
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_INTERNAL_FAILURE));
        }
    }

    return(0);
}

ULONG
InterDomainMove(
    WCHAR           *pszDstAddr,
    ENTINF          *pSrcObject,
    DSNAME          *pDestinationDN,
    DSNAME          *pExpectedTargetNC,
    SecBufferDesc   *pClientCreds,
    DSNAME          **ppAddedName
    )
{
    THSTATE             *pTHS = pTHStls;
    DWORD               cb, dwErr, outVersion;
    DRS_MSG_MOVEREQ     moveReq;
    DRS_MSG_MOVEREPLY   moveReply;
    DSNAME              *pDstObject;

    Assert(VALID_THSTATE(pTHS));
    // We're about to go off machine - should not have transaction or locks.
    Assert(!pTHS->transactionlevel && !pTHS->fSamWriteLockHeld);

    *ppAddedName = NULL;

    // Initialize request and reply.

    memset(&moveReply, 0, sizeof(DRS_MSG_MOVEREPLY));
    memset(&moveReq, 0, sizeof(DRS_MSG_MOVEREQ));
    moveReq.V2.pSrcDSA = gAnchor.pDSADN;
    moveReq.V2.pSrcObject = pSrcObject;
    moveReq.V2.pDstName = pDestinationDN;
    moveReq.V2.pExpectedTargetNC = pExpectedTargetNC;
    moveReq.V2.pClientCreds = (DRS_SecBufferDesc *) pClientCreds;
    moveReq.V2.PrefixTable = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
    moveReq.V2.ulFlags = 0;

    dwErr = I_DRSInterDomainMove(pTHS,
                                 pszDstAddr,
                                 2,
                                 &moveReq,
                                 &outVersion,
                                 &moveReply);

    if ( dwErr )
    {
        // We used to distinguish between connect errors and server-side
        // errors.  For connection failures, we used
        // SV_PROBLEM_UNAVAILABLE/RPC_S_SERVER_UNAVAILABLE
        // otherwise
        // SV_PROBLEM_DIR_ERROR/DIRERR_INTERNAL_FAILURE
        // Now, since the rpc api returns win32 errors, use those.
        // If the call fails, we treat them all as unavailable errors:

        return(SetSvcError( SV_PROBLEM_UNAVAILABLE, dwErr ));
    }
    else if ( 2 != outVersion )
    {
        return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                            DIRERR_INTERNAL_FAILURE));
    }
    else if ( moveReply.V2.win32Error )
    {
        return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                            moveReply.V2.win32Error));
    }

    *ppAddedName = moveReply.V2.pAddedName;
    Assert (*ppAddedName);
    return(0);
}

ULONG
PrePhantomizeChildCleanup(
    THSTATE     *pTHS,
    BOOL        fChildrenAllowed
    )
/*++

  Routine Description:

    This routine is now used for general reparenting of orphaned children by both
    replicator and system callers.

    This routine moves the children of an about to be phantomized object to
    the Lost&Found container.  This is required and acceptable for various
    reasons.  The source of a cross domain move disallows move of an object
    with children.  However, this does not guarantee that there are no
    children at the move destination (move destination holds source NC if
    it is a GC).  Replication latency can also result in there being children
    in existence when a replicated-in proxy object is processed.  I.e. While
    replica 1 of some NC sourced a cross domain move of object O, a child of O
    was added at replica 2 of the source NC.

    The mvtree utility exacerbates this problem as follows.  Assume a parent
    object P and a child object C at the move source.  mvtree creates a
    temporary parent P' at the source and moves C under it such that the
    original parent P is now a leaf and can be cross domain moved prior to
    its children.  This insures that all cross domain moves are to their
    "final" location and thus any ex-domain references from the source are
    accurate - modulo further moves in the destination NC of course.  If
    mvtree operations outpace replication (which is likely given that we
    employ a replication notification delay) then the destination ends up
    phantomizing parent P while C is still really its child.

    Now consider the following DNT relationships at the destination.

        RDN     DNT     PDNT    NCDNT
        parent  10      X       1
        child   11      10      1

    Noting that at the destination we don't just phantomize parent P but
    also add it to the destination NC (reusing its DNT), then were we to
    just phantomize P we would end up with the following:


        RDN     DNT     PDNT    NCDNT
        parent  10      X       2
        child   11      10      1

    This is an invalid database state as there is a mismatch between the
    child's NCDNT (1) and the NCDNT of its parent (2) as identified by
    its PDNT (10).

    The remedy is to move the children of the about to be phantomized
    object to their NC's Lost&Found container.  In the case where children
    exist due to the mvtree algorithm, they will most likely move ex-domain
    shortly anyway.  In the replication latency case, they will languish
    in Lost&Found until someone realizes they are missing.

  Arguments:

    pTHS - active THSTATE whose pTHS->pDB is positioned on the parent
        object whose children are to be moved.

    fChildrenAllowed - Flag indicating whether we think its OK if the
        object being phantomized has children or not.

  Return Values:

    pTHS->errCode

--*/
{
    DSNAME                      *pParentDN = NULL;
    RESOBJ                      *pResParent = NULL;
    PDSNAME                     *rpChildren = NULL;
    DWORD                       iLastName = 0;
    DWORD                       cMaxNames = 0;
    BOOL                        fWrapped = FALSE;
    BOOL                        savefDRA;
    ULONG                       len;
    DSNAME                      *pLostAndFoundDN = NULL;
    DWORD                       lostAndFoundDNT;
    MODIFYDNARG                 modifyDnArg;
    MODIFYDNRES                 modifyDnRes;
    DWORD                       cMoved = 0;
    PROPERTY_META_DATA_VECTOR   *pmdVector = NULL;
    DWORD                       i;
    DWORD                       ccRdn;
    ATTRVAL                     rdnAttrVal = { 0, NULL };
    ATTR                        rdnAttr = { 0, { 1, &rdnAttrVal } };
    ATTCACHE                    *pacRDN;
    CLASSCACHE                  *pccChild;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(DBCheckObj(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    savefDRA = pTHS->fDRA;
    // This code requires fDRA in order mangle names,
    // rename arbitrary objects, and merge remote meta data vectors.
    pTHS->fDRA = TRUE;

    __try
    {
        // Grab a RESOBJ for the parent for later use.

        if ( DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                         0, 0, &len, (UCHAR **) &pParentDN) )
        {
            SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
            __leave;
        }

        pResParent = CreateResObj(pTHS->pDB, pParentDN);

        // Take a read lock on the parent.  This will cause escrowed updates
        // (by other transactions) to fail thereby insuring no other thread
        // creates a new child while we're in the process of moving the current
        // set of children.  Then get all first level children.

        DBClaimReadLock(pTHS->pDB);
        if (DBGetDepthFirstChildren(pTHS->pDB, &rpChildren, &iLastName,
                                    &cMaxNames, &fWrapped, TRUE))
        {
            SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
            __leave;
        }

        // If no children are expected/allowed, then DBGetDepthFirstChildren
        // should have returned one element which is the parent itself.
        // This one DSNAME is returned in DBGETATTVAL_fSHORTNAME form.  All
        // others should include a string name.

        Assert(fChildrenAllowed
                    ? TRUE
                    : (    !fWrapped
                        && (1 == iLastName)
                        && !memcmp(&pParentDN->Guid,
                                   &rpChildren[0]->Guid,
                                   sizeof(GUID))) )

        if (    !fWrapped
             && (1 == iLastName)
             && !memcmp(&pParentDN->Guid, &rpChildren[0]->Guid, sizeof(GUID)) )
        {
            // Nothing to do, but position back at parent before returning.
            // DBFindDNT succeeds or excepts.
            DBFindDNT(pTHS->pDB, pResParent->DNT);

            __leave;
        }

        // Find the Lost&Found container's DSNAME.  Although we now
        // support pNCL->LostAndFoundDNT field in the gAnchor lists,
        // the field is uninitialized if the NC was added since the
        // last boot.  I.e. The lost and found container for the NC
        // in question must exist locally when the CR was added to the
        // list - which isn't the case for recently added NCs.  Thus
        // we get the NC's Lost&Found the hard way here.

        if (    DBFindDNT(pTHS->pDB, pResParent->NCDNT)
             || !GetWellKnownDNT(pTHS->pDB,
                                 (GUID *) GUID_LOSTANDFOUND_CONTAINER_BYTE,
                                 &lostAndFoundDNT)
             || (INVALIDDNT == lostAndFoundDNT)
             || DBFindDNT(pTHS->pDB, lostAndFoundDNT)
             || DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0, 0,
                            &len, (UCHAR **) &pLostAndFoundDN) )
        {
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER);
            __leave;
        }

        // Construct a one element metadata vector which is used to insure
        // that any RDN changes we make as we put objects in Lost&Found
        // lose out to other RDN changes from "real" clients.

        pmdVector = (PROPERTY_META_DATA_VECTOR *)
                            THAllocEx(pTHS, sizeof(PROPERTY_META_DATA_VECTOR));
        pmdVector->dwVersion = 1;
        pmdVector->V1.cNumProps = 1;
        pmdVector->V1.rgMetaData[0].attrType = ATT_RDN;
        pmdVector->V1.rgMetaData[0].timeChanged = DBTime();
        pmdVector->V1.rgMetaData[0].uuidDsaOriginating = pTHS->InvocationID;
        pmdVector->V1.rgMetaData[0].usnOriginating = DBGetNewUsn();
        // pmdVector->V1.rgMetaData[0].usnProperty can be left as 0 - it will
        // be overwritten with the local USN at which the change is applied.
        ReplUnderrideMetaData(pTHS, ATT_RDN, &pmdVector, NULL);

        // Build constant parts of MODIFYDNARG.

        memset(&modifyDnArg, 0, sizeof(modifyDnArg));
        modifyDnArg.pNewParent = pLostAndFoundDN;
        InitCommarg(&modifyDnArg.CommArg);
        modifyDnArg.pMetaDataVecRemote = pmdVector;
        modifyDnArg.pResParent = pResParent;
        modifyDnArg.pNewRDN = &rdnAttr;
        rdnAttrVal.pVal = (UCHAR *)
                    THAllocEx(pTHS, sizeof(WCHAR) * MAX_RDN_SIZE);

        // For each child, mangle its RDN so as to guarantee lack of name
        // conflicts in Lost&Found, then do the local rename.  We don't
        // need to do the iLastName down to 0 then cMaxNames down to iLastName
        // iteration algorithm as we don't care which order we process the
        // children in.  Use mark and free to mark so we don't bloat the heap.

        pacRDN = SCGetAttById(pTHS, ATT_RDN);

        do // while ( fWrapped )
        {
            for ( i = 0; i < (fWrapped ? cMaxNames : iLastName); i++ )
            {
                if ( !memcmp(&pParentDN->Guid,
                             &rpChildren[i]->Guid,
                             sizeof(GUID)) )
                {
                    // Skip the parent.
                    continue;
                }

                if (    DBFindDSName(pTHS->pDB, rpChildren[i])
                     || DBGetAttVal_AC(pTHS->pDB, 1, pacRDN,
                                       DBGETATTVAL_fCONSTANT,
                                       sizeof(WCHAR) * MAX_RDN_SIZE,
                                       &len, &rdnAttrVal.pVal) )
                {
                    SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                    __leave;
                }

                modifyDnArg.pResObj = CreateResObj(pTHS->pDB, rpChildren[i]);
                pccChild = SCGetClassById(
                                    pTHS,
                                    modifyDnArg.pResObj->MostSpecificObjClass);
                // Use the object rdnType and not the object's class rdnattid
                // because a superceding class may have a different rdnattid
                // than the superceded class had when this object was created.
                GetObjRdnType(pTHS->pDB, pccChild, &rdnAttr.attrTyp);
                ccRdn = len / sizeof(WCHAR);
                MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
                          &rpChildren[i]->Guid,
                          (WCHAR *) rdnAttrVal.pVal, &ccRdn);
                rdnAttrVal.valLen = ccRdn * sizeof(WCHAR);
                memset(&modifyDnRes, 0, sizeof(modifyDnRes));

                if ( LocalModifyDN(pTHS, &modifyDnArg, &modifyDnRes, FALSE) )
                {
                    UCHAR *pString=NULL;
                    DWORD cbString=0;

                    CreateErrorString(&pString, &cbString);
                    LogEvent8( DS_EVENT_CAT_GARBAGE_COLLECTION,
                               DS_EVENT_SEV_ALWAYS,
                               DIRLOG_DSA_CHILD_CLEANUP_FAILURE,
                               szInsertDN(pParentDN),
                               szInsertDN(rpChildren[i]),
                               szInsertWC2(rdnAttrVal.pVal, ccRdn),
                               szInsertDN(pLostAndFoundDN),
                               szInsertSz(pString?pString:""),
                               NULL, NULL, NULL );
                    if (pString) {
                        THFreeEx(pTHS,pString);
                    }
                    __leave;
                }

                THFreeEx(pTHS, modifyDnArg.pResObj);
                THFreeEx(pTHS, modifyDnArg.pResParent);
            }

            for ( i = 0; i < (fWrapped ? cMaxNames : iLastName); i++ )
            {
                THFreeEx(pTHS, rpChildren[i]);
            }

            THFreeEx(pTHS, rpChildren);
            rpChildren = NULL;

            // Position back at parent.  Need this if fWrapped or if
            // we are returning to caller.

            if ( DBFindDNT(pTHS->pDB, pResParent->DNT) )
            {
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                __leave;
            }

            if (    fWrapped
                 && DBGetDepthFirstChildren(pTHS->pDB, &rpChildren, &iLastName,
                                            &cMaxNames, &fWrapped, TRUE) )
            {
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                __leave;
            }

        } while ( fWrapped );
    }
    __finally
    {
        pTHS->fDRA = savefDRA;
    }

    if ( pParentDN ) THFreeEx(pTHS, pParentDN);
    if ( pResParent ) THFreeEx(pTHS, pResParent);
    if ( pLostAndFoundDN ) THFreeEx(pTHS, pLostAndFoundDN);
    if ( pmdVector ) THFreeEx(pTHS, pmdVector);
    if ( rdnAttrVal.pVal ) THFreeEx(pTHS, rdnAttrVal.pVal);

    return(pTHS->errCode);
}

ULONG
PhantomizeObject(
    DSNAME  *pOldDN,
    DSNAME  *pNewDN,
    BOOL    fChildrenAllowed
    )
/*++

Routine Description:

    This routine converts an object into a phantom so that group-membership
    references (via DNT) are maintained.  If pOldDN is a phantom, then it
    merely renames the phantom (or insures it has the same name).

Arguments:

    pOldDn - Pointer to DSNAME to phantomize.  This DSNAME must have the
        current string name of the object.

    pNewDN - Pointer to DSNAME of resulting phantom.  This DSNAME
        must have a string name.

    fChildrenAllowed - Flag indicating whether we think its OK if the
        object being phantomized has children or not.

Return Value:

    pTHStls->errCode

--*/

{
    THSTATE                     *pTHS;
    DWORD                       dwErr;
    WCHAR                       oldRdnVal[MAX_RDN_SIZE];
    WCHAR                       newRdnVal[MAX_RDN_SIZE];
    ATTRTYP                     oldRdnTyp;
    ATTRTYP                     newRdnTyp;
    ULONG                       oldRdnLen;
    ULONG                       newRdnLen;
    DSNAME                      *pParentDN = NULL;
    BOOL                        fRealObject = FALSE;
    BOOL                        fChangedRdn = FALSE;
    ATTRVAL                     attrVal = { 0, (UCHAR *) newRdnVal };
    ATTCACHE                    *pAC;
    ULONG                       len;
    SYNTAX_DISTNAME_BINARY      *pOldProxy = NULL;
    DSNAME                      *pTmpDN;
    GUID                        guid;
    GUID                        *pGuid = &guid;
    DWORD                       ccRdn;
    DWORD                       objectStatus;
    PROPERTY_META_DATA_VECTOR   *pMetaDataVec;
    PROPERTY_META_DATA          *pMetaData;
    BOOL                        fMangledRealObjectName = FALSE;
#if DBG
    DSNAME                      *pDbgDN;
#endif

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(pOldDN->NameLen > 0);
    Assert(pNewDN->NameLen > 0);

    // Pave the way for the new name in case it is in use.
    // If old and new string names are the same, then we won't have
    // a name conflict as new name will promote existing phantom with
    // the same name - so we can bypass this check.

    if ( NameMatchedStringNameOnly(pOldDN, pNewDN) )
    {
        goto Phantomize;
    }

    pTmpDN = (DSNAME *) THAllocEx(pTHS, pNewDN->structLen);
    pTmpDN->structLen = pNewDN->structLen;
    pTmpDN->NameLen = pNewDN->NameLen;
    memcpy(pTmpDN->StringName,
           pNewDN->StringName,
           sizeof(WCHAR) * pNewDN->NameLen);

    objectStatus = dwErr = DBFindDSName(pTHS->pDB, pTmpDN);

    switch ( dwErr )
    {
    case 0:
    case DIRERR_NOT_AN_OBJECT:

        // The target name is in use - duplicate key errors will occur in
        // the PDNT-RDN index unless we mangle one of the names - which one?
        // We can get here two ways - either we're the source of a cross
        // domain move doing post remote add cleanup, or we're the replicator
        // processing a proxy object for its side effect.  Even if we're a
        // GC, in neither case are we authoritative for the new DN's NC and
        // know that the machines which are authoritative for the new DN's
        // NC will eventually resolve any name conflict.  So we unilaterally
        // mangle the DN of the conflicting entry.  If it is a phantom to
        // begin with the stale phantom daemon will ultimately make it right.
        // If it is a real object we whack its metadata to lose name conflicts,
        // thus any better name as decided upon by the authoritative replicas
        // will take effect when they get here.

        if (    (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID,
                                     DBGETATTVAL_fCONSTANT, sizeof(GUID),
                                     &len, (UCHAR **) &pGuid))
             || (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_RDN,
                                     DBGETATTVAL_fCONSTANT,
                                     MAX_RDN_SIZE * sizeof(WCHAR),
                                     &len, (UCHAR **) &attrVal.pVal))
             || (ccRdn = len / sizeof(WCHAR),
                 MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT, pGuid,
                           (WCHAR *) attrVal.pVal, &ccRdn),
                 attrVal.valLen = sizeof(WCHAR) * ccRdn,
                 dwErr = DBResetRDN(pTHS->pDB, &attrVal)) )
        {
            return(SetSvcErrorEx(SV_PROBLEM_BUSY,
                                 DIRERR_DATABASE_ERROR,
                                 dwErr));
        }

        if ( 0 == objectStatus )
        {
            fMangledRealObjectName = TRUE;

            if (    (dwErr = DBGetAttVal(pTHS->pDB, 1,
                                         ATT_REPL_PROPERTY_META_DATA,
                                         0, 0, &len, (UCHAR **) &pMetaDataVec))
                 || (ReplUnderrideMetaData(pTHS, ATT_RDN, &pMetaDataVec, &len),
                     dwErr = DBReplaceAttVal(pTHS->pDB, 1,
                                             ATT_REPL_PROPERTY_META_DATA,
                                             len, pMetaDataVec)) )
            {
                return(SetSvcErrorEx(SV_PROBLEM_BUSY,
                                     DIRERR_DATABASE_ERROR,
                                     dwErr));
            }

            THFreeEx(pTHS, pMetaDataVec);
        }

        if ( dwErr = DBUpdateRec(pTHS->pDB) )
        {
                return(SetSvcErrorEx(SV_PROBLEM_BUSY,
                                     DIRERR_DATABASE_ERROR,
                                     dwErr));
        }

        break;

    case DIRERR_OBJ_NOT_FOUND:

        // No such object - no name conflict.
        break;

    default:

        // Random database error.
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

Phantomize:

    // Phantomize old object.

    dwErr = DBFindDSName(pTHS->pDB, pOldDN);

    switch ( dwErr )
    {
    case 0:

        // Found real object.
        fRealObject = TRUE;

        // Check if callers are providing current string name - but only
        // if we didn't just mangle it ourselves.

        Assert( fMangledRealObjectName
                    ? TRUE
                    : (    !DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                        0, 0, &len, (UCHAR **) &pDbgDN)
                        && NameMatchedStringNameOnly(pOldDN, pDbgDN)) );

        // Move children to Lost&Found to avoid PDNT/NCDNT mismatch when
        // parent is moved to new NC but children still point to parent.

        if ( PrePhantomizeChildCleanup(pTHS, fChildrenAllowed) )
        {
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }

        break;

    case DIRERR_NOT_AN_OBJECT:

        // Found phantom.
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // No such object.
        return(SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND));

    default:

        // Random database error.
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

    // DBResetParent requires a DSNAME with a string name.
    Assert(pNewDN->NameLen);

    // Derive parent and RDN info for subsequent DBReset* calls.

    pParentDN = (DSNAME *) THAllocEx(pTHS, pNewDN->structLen);

    if (    GetRDNInfo(pTHS, pOldDN, oldRdnVal, &oldRdnLen, &oldRdnTyp)
         || GetRDNInfo(pTHS, pNewDN, newRdnVal, &newRdnLen, &newRdnTyp)
         || (oldRdnTyp != newRdnTyp)
         || TrimDSNameBy(pNewDN, 1, pParentDN) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    attrVal.valLen = sizeof(WCHAR) * newRdnLen;
    fChangedRdn = (    (oldRdnLen != newRdnLen)
                    || (CSTR_EQUAL != CompareStringW(DS_DEFAULT_LOCALE,
                                                     DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                                     oldRdnVal, oldRdnLen,
                                                     newRdnVal, newRdnLen)) );

    // Remove ATT_PROXIED_OBJECT property if it exists.  This is so that
    // if the object is moved back, and the phantom promoted to a real
    // object again, that the new object doesn't get the old object's
    // property value.  See logic in IDL_DRSRemoteAdd which adds the
    // value we really want.

    pAC = SCGetAttById(pTHS, ATT_PROXIED_OBJECT_NAME);
    switch ( dwErr = DBGetAttVal_AC(pTHS->pDB, 1, pAC, 0, 0,
                                    &len, (UCHAR **) &pOldProxy) )
    {
    case DB_ERR_NO_VALUE:   pOldProxy = NULL; break;
    case 0:                 Assert(len && pOldProxy); break;
    default:                return(SetSvcErrorEx(SV_PROBLEM_BUSY,
                                                 DIRERR_DATABASE_ERROR,
                                                 dwErr));
    }

    // If real object, use DBPhysDel to convert it into a phantom yet
    // leave all links to it intact.  The object won't really be physically
    // deleted as it still has a ref count for itself.  Reset parentage and
    // RDN for both object and phantom cases.  Specify flag that says it
    // is OK to create the new parent as another phantom if required.
    // Remove NCDNT if this was a real object as phantoms don't have one.
    // Normally DBPhysDel removes ATT_PROXIED_OBJECT_NAME so only do it
    // if we're not calling DBPhysDel AND the property exists.


    if (    (dwErr = (fRealObject
                            ? DBPhysDel(pTHS->pDB, TRUE, NULL)
                            : 0))
         || (dwErr = DBResetParent(pTHS->pDB, pParentDN,
                                   (DBRESETPARENT_CreatePhantomParent |
                                    (fRealObject ?
                                     DBRESETPARENT_SetNullNCDNT :
                                     0))))
         || (dwErr = (fChangedRdn
                            ? DBResetRDN(pTHS->pDB, &attrVal)
                            : 0))
         || (dwErr = ((!fRealObject && pOldProxy)
                            ? DBRemAttVal_AC(pTHS->pDB, pAC, len, pOldProxy)
                            : 0))
         || (dwErr = DBUpdateRec(pTHS->pDB)) )
    {
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr);
    }

    THFreeEx(pTHS, pParentDN);

    return(pTHS->errCode);
}

ULONG
CreateProxyObject(
    DSNAME                  *pProxyObjectName,
    DSNAME                  *pProxiedObjectName,
    SYNTAX_DISTNAME_BINARY  *pOldProxyVal
    )
/*++

  Routine Description:

    Create an "infrastructure" object with the desired ATT_PROXIED_OBJECT_NAME.
    Then delete it so it propagates as a tombstone and eventually disappears.

  Parameters:

    pProxyObjectName - DSNAME of proxy object to create.

    pProxiedObjectName - DSNAME of object which is to be proxied.

    pOldProxyVal - NULL or pointer to moved object's ATT_PROXIED_OBJECT_NAME.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE                 *pTHS = pTHStls;
    DWORD                   winErr;
    DWORD                   objectClass = CLASS_INFRASTRUCTURE_UPDATE;
    // Set various system flags to insure proxy objects stay in the
    // Infrastructure container so that unseen proxies move with the
    // RID FSMO - see GetProxyObjects().
    DWORD                   systemFlags = (   FLAG_DOMAIN_DISALLOW_RENAME
                                            | FLAG_DISALLOW_MOVE_ON_DELETE
                                            | FLAG_DOMAIN_DISALLOW_MOVE );
    ATTRVAL                 classVal =  { sizeof(DWORD),
                                          (UCHAR *) &objectClass };
    ATTRVAL                 nameVal =   { 0, NULL };
    ATTRVAL                 flagsVal =  { sizeof(DWORD),
                                          (UCHAR *) &systemFlags };
    ATTR                    attrs[3] =
        {
            { ATT_OBJECT_CLASS,           { 1, &classVal } },
            { ATT_PROXIED_OBJECT_NAME,    { 1, &nameVal } },
            { ATT_SYSTEM_FLAGS,           { 1, &flagsVal } },
        };
    ADDARG                  addArg;
    REMOVEARG               remArg;
    SYNTAX_ADDRESS          blob;
    DSNAME                  *pParentObj = NULL;

    // Assert good environment and correctness of names.

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel > 0);
    Assert(fNullUuid(&pProxyObjectName->Guid));
    Assert(!fNullUuid(&pProxiedObjectName->Guid));
    Assert(pProxyObjectName->NameLen);
    Assert(pProxiedObjectName->NameLen);

    // Construct SYNTAX_DISTNAME_BINARY property value.
    // Proxy object's ATT_PROXIED_OBJECT_NAME holds the epoch number of
    // the proxied object prior to move.

    MakeProxy(  pTHS,
                pProxiedObjectName,
                PROXY_TYPE_PROXY,
                pOldProxyVal
                    ? GetProxyEpoch(pOldProxyVal)
                    : 0,
                &nameVal.valLen,
                (SYNTAX_DISTNAME_BINARY **) &nameVal.pVal);

    memset(&addArg, 0, sizeof(addArg));
    addArg.pObject = pProxyObjectName;
    addArg.AttrBlock.attrCount = 3;
    // addArg.AttrBlock.pAttr needs to be THAlloc'd so that lower layers
    // can realloc it in due course.
    addArg.AttrBlock.pAttr = (ATTR *) THAllocEx(pTHS, sizeof(attrs));
    memcpy(addArg.AttrBlock.pAttr, attrs, sizeof(attrs));
    InitCommarg(&addArg.CommArg);

    // Contruct parent RESOBJ.

    pParentObj = (DSNAME *) THAllocEx(pTHS, pProxyObjectName->structLen);
    if (    TrimDSNameBy(pProxyObjectName, 1, pParentObj)
         || DBFindDSName(pTHS->pDB, pParentObj) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pProxyObjectName,
                            DIRERR_BAD_NAME_SYNTAX));
    }
    addArg.pResParent = CreateResObj(pTHS->pDB, pParentObj);

    // Set/clear fCrossDomainMove so VerifyDsnameAtts accepts a value
    // for ATT_PROXIED_OBJECT_NAME.
    pTHS->fCrossDomainMove = TRUE;

    // pTHS->fDSA should have been set by caller.
    Assert(pTHS->fDSA);

    _try
    {
        if ( 0 == LocalAdd(pTHS, &addArg, FALSE) )
        {
            memset(&remArg, 0, sizeof(REMOVEARG));
            remArg.pObject = pProxyObjectName;
            InitCommarg(&remArg.CommArg);
            remArg.pResObj = CreateResObj(pTHS->pDB, pProxyObjectName);
            LocalRemove(pTHS, &remArg);

            // N.B. Since the object was added and removed in the same
            // transaction the replicator can not pick this object up between
            // the add and remove.  It will replicate the final, deleted
            // state of the object only.  Furthermore, since ATT_OBJECT_CLASS
            // and ATT_PROXIED_OBJECT_NAME are not removed during deletion
            // (see SetDelAtt), therefore we are guaranteed that replicas
            // receiving this proxy object will have ATT_OBJECT_CLASS,
            // ATT_IS_DELETED, and ATT_PROXIED_OBJECT_NAME available in
            // the replicated data and can use this to unambiguously identify
            // the object as a valid proxy for processing.
        }
    }
    _finally
    {
        pTHS->fCrossDomainMove = FALSE;
    }

    return(pTHS->errCode);
}

VOID
FreeRemoteAddCredentials(
    SecBufferDesc   *pSecBufferDesc
    )
/*++

  Routine Description:

    Free the credentials blob returned by GetRemoteAddCredentials.

  Parameters:

    pSecBufferDesc - Pointer to struct filled by GetRemoteAddCredentials.

  Return Values:

    None

--*/
{
    ULONG i;

    if ( pSecBufferDesc )
    {
        for ( i = 0; i < pSecBufferDesc->cBuffers; i++ )
        {
            FreeContextBuffer(pSecBufferDesc->pBuffers[i].pvBuffer);
        }
    }
}

ULONG
GetRemoteAddCredentials(
    THSTATE         *pTHS,
    WCHAR           *pDstDSA,
    SecBufferDesc   *pSecBufferDesc
    )
/*++

  Routine Description:

    Impersonate client and get security blob which represents their
    credentials which will be used for the actual DirAddEntry call at
    the destination.  See comments in IDL_DRSRemoteAdd for the remote
    add security model.

  Parameters:

    pDstDSA - Name of destination DSA we will bind to.

    pSecBufferDesc - Pointer to credentials struct to fill in.

  Return Values:

    pTHStls->errCode

--*/
{
    SECURITY_STATUS         secErr = SEC_E_OK;
    ULONG                   winErr;
    CredHandle              hClient;
    TimeStamp               ts;
    CtxtHandle              hNewContext;
    ULONG                   clientAttrs;
    LPWSTR                  pszServerPrincName = NULL;
    LPWSTR                  pszLogFailingFunc = NULL; // Must log events outside of an Impersonate context.
    ULONG                   dwLogErr = 0;

    __try {
        if ( winErr = DRSMakeMutualAuthSpn(pTHS, pDstDSA, NULL,
                                           &pszServerPrincName) )
        {
            SetSvcError(SV_PROBLEM_UNAVAILABLE, winErr);
            __leave;
        }

        if ( winErr = ImpersonateAnyClient() )
        {
            // Set pszFailingFunc, so we'll log an event
            pszLogFailingFunc = L"ImpersonateAnyClient";
            dwLogErr = winErr;
            SetSecError(SE_PROBLEM_INAPPROPRIATE_AUTH,
                        winErr);
            __leave;
        }

        secErr = AcquireCredentialsHandleA(
                                NULL,                       // pszPrincipal
                                MICROSOFT_KERBEROS_NAME_A,  // pszPackage
                                SECPKG_CRED_OUTBOUND,       // fCredentialUse
                                NULL,                       // pvLogonId
                                NULL,                       // pAuthData
                                NULL,                       // pGetKeyFn
                                NULL,                       // pvGetKeyArgument
                                &hClient,                   // phCredential
                                &ts);                       // ptsExpiry

        if ( SEC_E_OK != secErr )
        {
            // Set pszFailingFunc, so we'll log an event
            pszLogFailingFunc = L"AcquireCredentialsHandleA";
            dwLogErr = secErr;
            SetSecError(SE_PROBLEM_INAPPROPRIATE_AUTH, secErr);
        }
        else
        {
            secErr = InitializeSecurityContext(
                                &hClient,                   // phCredential
                                NULL,                       // phContext
                                pszServerPrincName,         // pszTargetName
                                ISC_REQ_ALLOCATE_MEMORY,    // fContextReq
                                0,                          // Reserved1
                                SECURITY_NATIVE_DREP,       // TargetRep
                                NULL,                       // pInput
                                0,                          // Reserved2
                                &hNewContext,               // phNewContext
                                pSecBufferDesc,             // pOutput
                                &clientAttrs,               // pfContextAttributes
                                &ts);                       // ptsExpiry

            if ( SEC_E_OK == secErr )
            {
                DeleteSecurityContext(&hNewContext);
            }
            else
            {
                // SecBufferDesc may hold error information.
                // Set pszFailingFunc, so we'll log an event
                pszLogFailingFunc = L"InitializeSecurityContext";
                dwLogErr = secErr;
                SetSecError(SE_PROBLEM_INAPPROPRIATE_AUTH, secErr);
            }

            FreeCredentialsHandle(&hClient);
        }

        UnImpersonateAnyClient();

    } __finally {
        if (NULL != pszServerPrincName) {
            free(pszServerPrincName);
        }
    }


    // Must log events outside of an Impersonate context, because this macro
    // does an Impersonate to get the user's SID.
    if (pszLogFailingFunc) {
        // A function failed, please log an event.
#if DBG
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GET_REMOTE_CREDENTIALS_FAILURE,
                 szInsertWC(pDstDSA),
                 szInsertWin32Msg(dwLogErr),
                 szInsertWC(pszLogFailingFunc));
#else
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_GET_REMOTE_CREDENTIALS_FAILURE,
                 szInsertWC(pDstDSA),
                 szInsertWin32Msg(dwLogErr),
                 szInsertWC(pszLogFailingFunc));
#endif
    }

    return pTHS->errCode;
}

ULONG
ReadAllAttrsForMove(
    DSNAME                  *pObject,
    RESOBJ                  *pResObj,
    READRES                 **ppReadRes,
    SYNTAX_DISTNAME_BINARY  **ppOldProxyVal
    )
/*++

  Routine Description:

    Reads all attributes off an object for shipment to another domain
    for cross domain move.

  Parameters:

    pObject - Pointer to DSNAME of object to be read.

    pResObj - RESOBJ of the object to read.

    ppReadRes - Address of READRES pointer which receives DirRead result.

    ppOldProxyVal - Address of SYNTAX_DISTNAME_BINARY which receives the
        object's ATT_PROXIED_OBJECT_NAME property if present.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE     *pTHS = pTHStls;
    DWORD       dwErr;
    READARG     readArg;
    ENTINFSEL   entInfSel;
    BOOL        fDsaSave;
    // Move some operational attributes, too
    ATTR        attrs[2] = { { ATT_NT_SECURITY_DESCRIPTOR,  { 0, NULL } },
                             { ATT_REPL_PROPERTY_META_DATA, { 0, NULL } } };
    ULONG       i;
    ATTR        *pAttr;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    *ppOldProxyVal = NULL;

    // Set up args to read every possible attribute - metadata, SD, etc.

    memset(&entInfSel, 0, sizeof(ENTINFSEL));
    memset(&readArg, 0, sizeof(READARG));
    InitCommarg(&readArg.CommArg);
    readArg.CommArg.Svccntl.SecurityDescriptorFlags =
            (   SACL_SECURITY_INFORMATION
              | OWNER_SECURITY_INFORMATION
              | GROUP_SECURITY_INFORMATION
              | DACL_SECURITY_INFORMATION );
    // we can require a writeable copy here, since VerifyObjectForMove will check for it later anyway.
    readArg.CommArg.Svccntl.dontUseCopy = TRUE;
    readArg.pObject = pObject;
    readArg.pResObj = pResObj;
    readArg.pSel = &entInfSel;
    readArg.pSel->attSel = EN_ATTSET_ALL_WITH_LIST;
    readArg.pSel->infoTypes = EN_INFOTYPES_TYPES_VALS;
    readArg.pSel->AttrTypBlock.attrCount = 2;
    readArg.pSel->AttrTypBlock.pAttr = attrs;
    *ppReadRes = THAllocEx(pTHS, sizeof(READRES));

    // Perform read as fDSA so as to bypass access checking.
    fDsaSave = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    _try
    {
        // we must be positioned on the right object
        Assert(pTHS->pDB->DNT == pResObj->DNT);

        if ( 0 == (dwErr = LocalRead(   pTHS,
                                        &readArg,
                                        *ppReadRes) ) )
        {
            // Extract the ATT_PROXIED_OBJECT_NAME property if it exists.

            for ( i = 0, pAttr = (*ppReadRes)->entry.AttrBlock.pAttr;
                  i < (*ppReadRes)->entry.AttrBlock.attrCount;
                  i++, pAttr++ )
            {
                if ( ATT_PROXIED_OBJECT_NAME == pAttr->attrTyp )
                {
                    Assert(1 == pAttr->AttrVal.valCount);
                    Assert(PROXY_TYPE_MOVED_OBJECT ==
                                GetProxyType((SYNTAX_DISTNAME_BINARY *)
                                            pAttr->AttrVal.pAVal->pVal));
                    *ppOldProxyVal = (SYNTAX_DISTNAME_BINARY *)
                                            pAttr->AttrVal.pAVal->pVal;
                    break;
                }
            }
        }
    }
    _finally
    {
        pTHS->fDSA = fDsaSave;
    }

    Assert(pTHS->errCode == dwErr);
    return(dwErr);
}


DWORD
ReReadObjectName (
    THSTATE *pTHS,
    DSNAME  *pOldDN,
    DSNAME  **ppNewObjectName
    )
/*++

  Routine Description:

    Re-read an object form the database.

  Parameters:

    pOldDN - Pointer to DSNAME to re-read.
    ppNewObjectName - New Object Name

  Return Values:

    Error Code or 0 for success

--*/
{
    DWORD       dwErr;
    ULONG       len;

    dwErr = DBFindDSName(pTHS->pDB, pOldDN);

    switch ( dwErr )
    {
    case 0:
        if (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0, 0, &len, (UCHAR **) ppNewObjectName)) {
                return(SetSvcErrorEx(SV_PROBLEM_BUSY,
                                 DIRERR_DATABASE_ERROR,
                                 dwErr));
        }

        #if DBG
            Assert (" Ignorable Assertion. Object changed name while moving" && NameMatchedStringNameOnly(pOldDN, *ppNewObjectName));
        #endif

        break;

    case DIRERR_NOT_AN_OBJECT:
        // out object already became a Phantom

        *ppNewObjectName = pOldDN;
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // No such object.
        return(SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND));

    default:

        // Random database error.
        return(SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dwErr));
    }

    return 0;
}


ULONG
LockDNForRemoteOperation(
    DSNAME  *pDN
    )
/*++

  Routine Description:

    Locks a DN for the duration of a cross domain move w/o holding a
    transaction open for the duration.  Lock should be freed via
    DBUnlockStickyDN().

  Parameters:

    pDN - Pointer to DSNAME to lock.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE     *pTHS = pTHStls;
    DWORD       flags = (DB_LOCK_DN_WHOLE_TREE | DB_LOCK_DN_STICKY);

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    if ( DBLockDN(pTHS->pDB, flags, pDN) )
    {
        return(SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY));
    }

    return(pTHS->errCode);
}

ULONG
MakeNamesForRemoteAdd(
    DSNAME  *pOriginalDN,
    DSNAME  *pNewParentDN,
    ATTR    *pNewRdn,
    DSNAME  **ppDestinationDN,
    DSNAME  **ppProxyDN
    )
/*++

  Routine Description:

    Construct all the names we're going to need for cross domain move.

  Parameters:

    pObject - Full name of original object AFTER name resolution.
        I.e. GUID, SID, etc are correct.

    pNewParentDN - DSNAME of new parent after move.

    pNewRdn - RDN of moved object.

    ppDestinationDN - Pointer to DSNAME which receives destination DN.
        I.e. Has same GUID as pObject, but no SID, new string name.

    ppProxyDN - Pointer to DSNAME which receives name of local proxy object.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD   cChar;
    WCHAR   pwszGuid[40];
    GUID    guid;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!fNullUuid(&pOriginalDN->Guid));

    // Construct destination DN.  New parent must have a string name.
    // New RDN must have a value.
    if ( !pNewParentDN->NameLen || pNewRdn->AttrVal.valCount == 0 )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewParentDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    cChar =   // parent string name
              pNewParentDN->NameLen
              // new RDN
            + (pNewRdn->AttrVal.pAVal[0].valLen / sizeof(WCHAR))
              // tag and delimiters
            + MAX_RDN_KEY_SIZE;

    *ppDestinationDN = (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(cChar));

    if ( AppendRDN(pNewParentDN,
                   *ppDestinationDN,
                   DSNameSizeFromLen(cChar),
                   (WCHAR *) &pNewRdn->AttrVal.pAVal[0].pVal[0],
                   pNewRdn->AttrVal.pAVal[0].valLen / sizeof(WCHAR),
                   pNewRdn->attrTyp) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            pNewParentDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    // Destination DN should have no SID (will be assigned by destination
    // if required) and same GUID as original object.

    (*ppDestinationDN)->SidLen = 0;
    memset(&(*ppDestinationDN)->Sid, 0, sizeof(NT4SID));
    memcpy(&(*ppDestinationDN)->Guid, &pOriginalDN->Guid, sizeof(GUID));

    // Construct proxy DN.  It is an object in the "infrastructure" container
    // whose RDN is a string-ized GUID.

    if ( !gAnchor.pInfraStructureDN )
    {
        return(SetSvcError(SV_PROBLEM_DIR_ERROR,
                           ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER));
    }

    DsUuidCreate(&guid);
    swprintf(   pwszGuid,
                L"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x",
                guid.Data1,     guid.Data2,     guid.Data3,     guid.Data4[0],
                guid.Data4[1],  guid.Data4[2],  guid.Data4[3],  guid.Data4[4],
                guid.Data4[5],  guid.Data4[6],  guid.Data4[7]);
    cChar =   gAnchor.pInfraStructureDN->NameLen    // parent string name
            + 32                                    // new RDN
            + 10;                                   // tag and delimiters
    *ppProxyDN = (DSNAME *) THAllocEx(pTHS, DSNameSizeFromLen(cChar));

    if ( AppendRDN(gAnchor.pInfraStructureDN,
                   *ppProxyDN,
                   DSNameSizeFromLen(cChar),
                   pwszGuid,
                   32,
                   ATT_COMMON_NAME) )
    {
        return(SetNamError( NA_PROBLEM_BAD_NAME,
                            gAnchor.pInfraStructureDN,
                            DIRERR_BAD_NAME_SYNTAX));
    }

    // Clear out GUID and SID.

    (*ppProxyDN)->SidLen = 0;
    memset(&(*ppProxyDN)->Sid, 0, sizeof(NT4SID));
    memset(&(*ppProxyDN)->Guid, 0, sizeof(GUID));

    return(pTHS->errCode);
}

ULONG
CheckRidOwnership(
    DSNAME  *pDomainDN)
/*++

  Routine Description:

    Insures that we really are the RID FSMO role owner for this move.
    This is required to insure that no two replicas of the source domain
    move their copy of an object to two different domains concurrently.
    This is prevented by:

        1) A RID lock is held while performing the move - specifically
           while transitioning from a real object to a phantom.

        2) All proxy objects are created in the infrastructure container.
           This makes them easy to find for step (3).

        3) All proxy objects move with the RID FSMO.  Since the destination
           of the FSMO transfer must apply all the changes that came with the
           FSMO before claiming FSMO ownership, it will end up phantomizing
           any object which has already been moved of the prior FSMO role
           owner.  Thus there is no local object to move anymore and the
           problem is prevented.  See logic in ProcessProxyObject in ..\dra
           for how we deal with objects that are moved out and then back
           in to the same domain.

  Parameters:

    pDomainDN - pointer to DSNAME of domain whose RID is to be locked.

  Return Values:

    pTHStls->errCode

--*/
{
    THSTATE *pTHS = pTHStls;
    DSNAME  *pRidManager;
    DSNAME  *pRidRoleOwner;
    ULONG   len;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(NameMatched(pDomainDN, gAnchor.pDomainDN));  // product 1

    if (    DBFindDSName(pTHS->pDB, pDomainDN)
         || DBGetAttVal(pTHS->pDB, 1, ATT_RID_MANAGER_REFERENCE,
                        0, 0, &len, (UCHAR **) &pRidManager)
         || DBFindDSName(pTHS->pDB, pRidManager)
         || DBGetAttVal(pTHS->pDB, 1, ATT_FSMO_ROLE_OWNER,
                        0, 0, &len, (UCHAR **) &pRidRoleOwner) )
    {
        SetSvcError(SV_PROBLEM_DIR_ERROR,
                    DIRERR_INTERNAL_FAILURE);
    }
    else if ( !NameMatched(pRidRoleOwner, gAnchor.pDSADN) )
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_INCORRECT_ROLE_OWNER);
    }

    return(pTHS->errCode);
}

ULONG
EncryptSecretData(
    THSTATE *pTHS,
    ENTINF  *pEntinf
    )
/*++

  Description:

    This routine is called from within I_DRSInterDomainMove between the
    bind which sets up RPC session keys between source and destination and
    the actual _IDL_DRSInterDomainMove call.  In other words, we acquire
    encryption keys on the bind, then call back here to encrypt secret data,
    then ship the secret data.  There is a performance penalty in this
    approach as we read secret attributes twice.  However, this is a much
    safer approach for now (10/22/98) rather than restructure the entire
    inter domain move code to bind first, then do all checks locally, monkey
    tranactions, etc.  Besides, not all objects have secret data and those
    that do may not have all secret attributes, so its doubtful that given
    the entire cost of moving the object to another machine that these extra
    reads are the performance killers.

  Arguments:

    pTHS - Active THSTATE.

    pEntinf - ENTINF pointer whose secret properties need to be re-read
        as fDRA so that session encryption occurs.

  Return Values:

    Win32 error code - pTHS->errCode is not set.  The call stack looks as
    follows:

        DirModifyDNAcrossDomain
            InterDomainMove
                I_DRSInterDomainMove
                    EncryptSecretData

    InterDomainMove sets pTHS->errCode as required.

--*/
{
    ULONG   i, j, inLen;
    ULONG   ret = ERROR_DS_DRA_INTERNAL_ERROR;
    ATTR    *pAttr;

    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->transactionlevel);
    Assert(!pTHS->pDB);
    Assert(pEntinf && pEntinf->pName && pEntinf->AttrBlock.attrCount);

    // First check if there even are any secret attributes thereby saving
    // the cost of a useless DBOpen.

    for ( i = 0; i < pEntinf->AttrBlock.attrCount; i++ )
    {
        if ( DBIsSecretData(pEntinf->AttrBlock.pAttr[i].attrTyp) )
        {
            break;
        }
    }

    if ( i >= pEntinf->AttrBlock.attrCount )
    {
        return(0);
    }

    DBOpen2(TRUE, &pTHS->pDB);
    pTHS->fDRA = TRUE;              // required to enable session encryption

    __try
    {
        if ( ret = DBFindDSName(pTHS->pDB, pEntinf->pName) )
        {
            __leave;
        }

        for ( i = 0; i < pEntinf->AttrBlock.attrCount; i++ )
        {
            pAttr = &pEntinf->AttrBlock.pAttr[i];

            if ( DBIsSecretData(pAttr->attrTyp) )
            {
                for ( j = 0; j < pAttr->AttrVal.valCount; j++ )
                {
                    inLen = pAttr->AttrVal.pAVal[j].valLen;

                    if ( ret = DBGetAttVal(pTHS->pDB,
                                           j + 1,
                                           pAttr->attrTyp,
                                           DBGETATTVAL_fREALLOC,
                                           inLen,
                                           &pAttr->AttrVal.pAVal[j].valLen,
                                           &pAttr->AttrVal.pAVal[j].pVal) )
                    {
                        __leave;
                    }
                }
            }
        }
    }
    __finally
    {
        pTHS->fDRA = FALSE;
        DBClose(pTHS->pDB, TRUE);
    }

    return(ret);
}

ULONG
NotifyNetlogonOfMove(
    THSTATE     *pTHS,
    DSNAME      *pObj,
    CLASSCACHE  *pCC
    )
/*++

  Description:

    Notify Netlogon of the fact that an object has left the domain.  This is
    not a synchronous notification.  Instead, data is hung off the thread
    state such that if the enclosing transaction commits, then Netlogon will
    be notified.

  Arguments:

    pTHS - Valid THSTATE pointer.

    pObj - DSNAME of object being removed.

    pCC - CLASSCACHE for object being removed.

  Return Values:

    pTHS->errCode

--*/
{
    ULONG   iSamClass;
    ULONG   iLsaClass;
    ATTRTYP lsaAttr = ATT_USER_ACCOUNT_CONTROL;

    Assert(VALID_THSTATE(pTHS));

    // Set DB position.

    if ( DBFindDSName(pTHS->pDB, pObj) )
    {
        return(SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR));
    }

    // Notifications use DomainServerRoleBackup as a place holder value
    // which is ignored since the role transfer parameter is FALSE.

    if ( SampSamClassReferenced(pCC, &iSamClass) )
    {
        if (SampQueueNotifications(pObj, iSamClass, 0,
                                   SecurityDbDelete, FALSE, FALSE,
                                   DomainServerRoleBackup, 0, NULL))
        {
            //
            // the above routine failed
            //
            return (pTHS->errCode);
        }
    }

    if ( SampIsClassIdLsaClassId(pTHS, pCC->ClassId, 1, &lsaAttr, &iLsaClass) )
    {
         if (SampQueueNotifications(pObj, iSamClass, iLsaClass,
                                    SecurityDbDelete, FALSE, FALSE,
                                    DomainServerRoleBackup, 0, NULL))
         {
             //
             // the above routine failed
             //
             return (pTHS->errCode);
         }
    }

    return(pTHS->errCode);
}

VOID
LogCrossDomainMoveStatus(
    IN DWORD Severity,
    IN DWORD Mid,
    IN PWCHAR String1,
    IN PWCHAR String2,
    IN DWORD  ErrCode
    )
{
    LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
             Severity,
             Mid,
             szInsertWC(String1),
             szInsertWC(String2),
             (ErrCode == 0) ? NULL : szInsertInt(ErrCode),
             (ErrCode == 0) ? NULL : szInsertWin32Msg(ErrCode),
             NULL,
             NULL,
             NULL,
             NULL
             );
}

DWORD
CheckCrossDomainRemoveSecurity(
    THSTATE     *pTHS,
    CLASSCACHE  *pCC,
    RESOBJ      *pResObj
    )
{
    // CheckRemoveSecurity sets the pTHS error code and checks for
    // object disclosure.
    return CheckRemoveSecurity(FALSE, pCC, pResObj);

}

ULONG
DirModifyDNAcrossDomain(
    IN  MODIFYDNARG     *pModifyDNArg,
    OUT MODIFYDNRES     **ppModifyDNRes
    )
{
    THSTATE                 *pTHS = pTHStls;
    DWORD                   i, dwErr = 0;
    READRES                 *pReadRes = NULL;
    SecBuffer               secBuffer = { 0, SECBUFFER_TOKEN, NULL };
    SecBufferDesc           clientCreds = { SECBUFFER_VERSION, 1, &secBuffer };
    DWORD                   lockDnFlags = (DB_LOCK_DN_WHOLE_TREE
                                                | DB_LOCK_DN_STICKY);
    DWORD                   lockDnErr = 1;
    DWORD                   lockRidErr = 1;
    DWORD                   credErr = 1;
    DSNAME                  *pDestinationDN;
    DSNAME                  *pProxyDN;
    DSNAME                  *pCaseCorrectRemoteName;
    DSNAME                  *pSourceNC;
    DSNAME                  *pExpectedTargetNC;
    DSNAME                  *pMovedObjectName;
    ULONG                   dwException = 0, ulErrorCode, dsid;
    PVOID                   dwEA;
    BOOL                    fDone = FALSE;
    DBPOS                   *pDB;
    SYNTAX_DISTNAME_BINARY  *pOldProxyVal = NULL;
    DWORD                   errCleanBeforeReturn;
    CLASSCACHE              *pCC;
    BOOL                    fChecksOnly = FALSE;
    DWORD                   nRetries = 0;

    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors

    __try   // outer try/except
    {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppModifyDNRes = THAllocEx(pTHS, sizeof(MODIFYDNRES));
        if (pTHS->errCode) {
            __leave;
        }

        // This operation should not be performed on read-only objects.
        pModifyDNArg->CommArg.Svccntl.dontUseCopy = TRUE;

        Assert(pModifyDNArg->pDSAName);

        if (   (0 == pModifyDNArg->pObject->NameLen)
            || (NULL == pModifyDNArg->pNewParent)
            || (0 == pModifyDNArg->pNewParent->NameLen)) {
            // Demand that the caller give us string names, though they
            // may be stale and thus log entries are misleading.

            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION);
            __leave;
        }

        DPRINT2(1,"DirModifyDNAcrossDomain(%ws->%ws) entered\n",
                pModifyDNArg->pObject->StringName,
                pModifyDNArg->pNewParent->StringName);

        __try   // outer try/finally
        {
            // Empty string means to perform checks only but not
            // the actual move.

            if ( 0 == wcslen(pModifyDNArg->pDSAName) )
            {
                fChecksOnly = TRUE;
            }

            // Acquire the RID FSMO lock before opening a transaction to
            // insure that the value doesn't change out from under us.
            // Can assume gAnchor.pDomainDN for product 1.

            if ( AcquireRidFsmoLock(gAnchor.pDomainDN, 3000) )
            {
                SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
                __leave;    // outer try/finally
            }
            lockRidErr = 0;

            // Note that we hold the RID FSMO lock while we are off
            // machine, but not a transaction.  It is deemed acceptable
            // to block RID FSMO operations till the remote add returns.

            Assert(0 == pTHS->transactionlevel);
            errCleanBeforeReturn = 1;
            SYNC_TRANS_READ();
            __try   // read transaction try/finally
            {
                if (dwErr = DoNameRes(
                                pTHS,
                                NAME_RES_QUERY_ONLY,
                                pModifyDNArg->pObject,
                                &pModifyDNArg->CommArg,
                                &(*ppModifyDNRes)->CommRes,
                                &pModifyDNArg->pResObj))
                {
                    __leave;
                }

                // Determine the object's class.
                if(!(pCC = SCGetClassById(pTHS,
                              pModifyDNArg->pResObj->MostSpecificObjClass))) {

                    SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                        DIRERR_OBJECT_CLASS_REQUIRED);
                    __leave;
                }

                // Verify delete rights prior to reading all attributes.
                if(dwErr = CheckCrossDomainRemoveSecurity(
                                                 pTHS,
                                                 pCC,
                                                 pModifyDNArg->pResObj)) {
                    __leave;
                }

                // Read the object in all its glory and verify that it is a
                // legal cross domain move candidate.  All pre-remote-add
                // activities are done in a single transaction for efficiency.
                // All post-remote-add activities are done in a single
                // transaction for atomicity.  If the remote add succeeds
                // and local cleanup fails, then we will have an object with
                // the same GUID on both sides.

                if (    // Read all attrs.
                        (dwErr = ReadAllAttrsForMove(
                                        pModifyDNArg->pObject,
                                        pModifyDNArg->pResObj,
                                        &pReadRes,
                                        &pOldProxyVal))) {
                    __leave;
                }

                // Construct all the names we are going to need.
                if( (dwErr = MakeNamesForRemoteAdd(
                                            pReadRes->entry.pName,
                                            pModifyDNArg->pNewParent,
                                            pModifyDNArg->pNewRDN,
                                            &pDestinationDN,
                                            &pProxyDN))

                        // We issue a JetLock on the object, since
                        // there is a possibility that before we take this lock,
                        // and after this trans is opened, the object can be changed
                     || DBClaimReadLock(pTHS->pDB)
                        // Lock the string name w/o holding a transaction open.
                     || (dwErr = lockDnErr = LockDNForRemoteOperation(
                                        pReadRes->entry.pName))
                        // Check if object can be legally moved.
                     || (dwErr = VerifyObjectForMove(
                                        pTHS,
                                        pReadRes,
                                        pDestinationDN,
                                        &pSourceNC,
                                        &pExpectedTargetNC,
                                        &pCC))
                        // Another check if object can be legally moved.
                     || (dwErr = NoDelCriticalObjects(pModifyDNArg->pResObj->pObj,
                                                      pModifyDNArg->pResObj->DNT))
                        // Make sure object is childless.
                     || (dwErr = (fChecksOnly
                                    ? 0
                                    : NoChildrenExist(pTHS, pModifyDNArg->pResObj)))
                     || (dwErr = CheckRidOwnership(pSourceNC)) )
                {
                    __leave; // read transaction try/finally
                }

                errCleanBeforeReturn = 0;
            }
            __finally   // read transaction try/finally
            {
                CLEAN_BEFORE_RETURN(errCleanBeforeReturn);
            }

            if ( errCleanBeforeReturn || pTHS->errCode )
            {
                if ( !pTHS->errCode )
                {
                    SetSvcError(SV_PROBLEM_DIR_ERROR,
                                DIRERR_INTERNAL_FAILURE);
                }

                __leave; // outer try/finally
            }

            // Bail now if we were only to check whether object can be moved.

            if ( fChecksOnly )
            {
                fDone = TRUE;
                __leave;    // outer try/finally
            }

            // GetRemoteAddCredentials and DRSRemoteAdd go off machine,
            // therefore verify there is no transaction open.
            Assert(0 == pTHS->transactionlevel);

TryAgain:
            if (    // Get client creds for delegation at destination.
                    (dwErr = credErr = GetRemoteAddCredentials(
                                            pTHS,
                                            pModifyDNArg->pDSAName,
                                            &clientCreds))
                // Ask remote side to add object with same GUID and new name.
                || (dwErr = InterDomainMove(pModifyDNArg->pDSAName,
                                            &pReadRes->entry,
                                            pDestinationDN,
                                            pExpectedTargetNC,
                                            &clientCreds,
                                            &pCaseCorrectRemoteName)) )
            {
                Assert(dwErr == pTHS->errCode);
                if (credErr == 0 &&
                    dwErr == serviceError &&
                    pTHS->pErrInfo->SvcErr.extendedErr == DRAERR_Busy &&
                    nRetries < 5)
                {
                    // retry 5 times
                    nRetries++;
                    THClearErrors();
                    // remote credentials can only be used once. We'll make
                    // another one on the next iteration.
                    FreeRemoteAddCredentials(&clientCreds);

                    // wait a bit and then retry.
                    Sleep(1000);
                    goto TryAgain;
                }

                __leave; // outer try/finally
            }

            // Remote add went OK - do local cleanup in one transaction.
            // We know that failure to perform local cleanup results in
            // the same object in both source and destination domain.
            // xdommove.doc documents how the admin should clean this
            // up - delete src object.  But in the hopes that this is
            // strictly a transient resource error, we try 3 times
            // at one second intervals.

            Assert(!pTHS->errCode && !dwErr);

            for ( i = 0; i < 3; i++ )
            {
                if ( i )
                {
                    Sleep(1000);    // delay on all but first attempt
                }

                dwErr = 0;
                THClearErrors();

                // We need to handle our own exceptions here, not just
                // clean up in a __finally.  This is so that we are guaranteed
                // to reach the error mapping code which sets the distinguished
                // ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD error code.  Otherwise
                // we would blow out to the outer __except and end up failing
                // to inform the caller that cleanup is required.

                __try   // catch exceptions
                {
                    errCleanBeforeReturn = 1;
                    SYNC_TRANS_WRITE();
                    __try   // write transaction try/finally
                    {
                        // Do all cleanup as fDSA so as to avoid access checks.

                        pTHS->fDSA = TRUE;

                        // First notify Netlogon of the deletion.  This just
                        // adds a notification struct to the THSTATE and needs
                        // to happen before phantomization while the object
                        // still has properties left to read.

                        // Second cleanup item is to phantomize the old object.
                        // We do this even if we're a GC as the add in the dst
                        // domain will get back to us eventually and thus we
                        // don't need to fiddle with partial attribute sets,
                        // etc.

                        // Third cleanup item is to create a proxy object.
                        // CreateProxyObject requires a NULL guid in the
                        // DSNAME.  If we're in the retry case, then the
                        // prior DirAddEntry filled it in, so clear it always.


                        // by now the original object might have changed name
                        // this can happen if somebody renames the parent of this
                        // object. we have better re-read the object from
                        // the database

                        memset(&pProxyDN->Guid, 0, sizeof(GUID));

                        if (    (dwErr = ReReadObjectName (
                                            pTHS,
                                            pReadRes->entry.pName,
                                            &pMovedObjectName))
                             || (dwErr = NotifyNetlogonOfMove(
                                            pTHS, pMovedObjectName, pCC))
                             || (dwErr = PhantomizeObject(
                                            pMovedObjectName,
                                            pCaseCorrectRemoteName,
                                            FALSE))
                             || (dwErr = CreateProxyObject(
                                            pProxyDN,
                                            pDestinationDN,
                                            pOldProxyVal)) )
                        {
                            __leave; // write transaction try/finally
                        }

                        errCleanBeforeReturn = 0;
                    }
                    __finally   // write transaction try/finally
                    {
                        pTHS->fDSA = FALSE;
                        CLEAN_BEFORE_RETURN(errCleanBeforeReturn);
                    }
                }
                __except(GetExceptionData(GetExceptionInformation(),
                                          &dwException, &dwEA,
                                          &ulErrorCode, &dsid))
                {
                    HandleDirExceptions(dwException, ulErrorCode, dsid);
                }

                if ( !errCleanBeforeReturn && !pTHS->errCode )
                {
                    break;      // success case!
                }
            }

            if ( errCleanBeforeReturn || pTHS->errCode )
            {
                // Know we have string names in args, thus can log them.

                LogCrossDomainMoveStatus(
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_CROSS_DOMAIN_MOVE_CLEANUP_REQUIRED,
                         pModifyDNArg->pObject->StringName,
                         pModifyDNArg->pNewParent->StringName,
                         pTHS->errCode ? Win32ErrorFromPTHS(pTHS)
                             : ERROR_DS_INTERNAL_FAILURE);

                // Map error to a distinct "administrative cleanup required"
                // error code.  Make sure not to use SV_PROBLEM_BUSY else
                // LDAP head will retry the DirModifyDN call without the
                // caller knowing it.  This second DirModifyDN will
                // get all the way to the destination, the destination (who
                // already has the object since the remote add succeeded the
                // first time around) will return a duplicate object error,
                // this is returned back to the client, and now the client
                // does not realize that the first call failed and cleanup
                // is required!  We'll have the same problem should wldap32.dll
                // ever retry on LDAP_BUSY errors.

                THClearErrors();
                dwErr = SetSvcError(SV_PROBLEM_DIR_ERROR,
                                    ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD);
                __leave;    // outer try/finally
            }

            Assert(!dwErr && !pTHS->errCode);
            fDone = TRUE;
        }
        __finally   // outer try/finally
        {
            if ( !lockDnErr ) {
                DBUnlockStickyDN(pModifyDNArg->pObject);
            }

            if ( !lockRidErr ) {
                ReleaseRidFsmoLock(gAnchor.pDomainDN);
            }

            if ( !credErr ) {
                FreeRemoteAddCredentials(&clientCreds);
            }

            // Know we have string names in args, thus can log them.

            if ( pTHS->errCode || AbnormalTermination() )
            {
                LogCrossDomainMoveStatus(
                         DS_EVENT_SEV_EXTENSIVE,
                         DIRLOG_CROSS_DOMAIN_MOVE_FAILED,
                         pModifyDNArg->pObject->StringName,
                         pModifyDNArg->pNewParent->StringName,
                         Win32ErrorFromPTHS(pTHS));
            }
            else if ( !fChecksOnly )
            {
                LogCrossDomainMoveStatus(
                         DS_EVENT_SEV_INTERNAL,
                         DIRLOG_CROSS_DOMAIN_MOVE_SUCCEEDED,
                         pModifyDNArg->pObject->StringName,
                         pModifyDNArg->pNewParent->StringName,
                         0);
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid))
    {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if ( *ppModifyDNRes )
    {
        (*ppModifyDNRes)->CommRes.errCode = pTHS->errCode;
        (*ppModifyDNRes)->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    Assert(pTHS->errCode ? !fDone : fDone);
    return(pTHS->errCode);
}

//============================================================================
//
//                      DN Modification Within the Same Domain
//
//============================================================================

ULONG
DirModifyDNWithinDomain (
    MODIFYDNARG*  pModifyDNArg,
    MODIFYDNRES** ppModifyDNRes
        )
{
    THSTATE*       pTHS;
    MODIFYDNRES  * pModifyDNRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;


    DPRINT2(1,"DirModifyDNWithinNC(%ws->%ws) entered\n",
        pModifyDNArg->pObject->StringName,
        pModifyDNArg->pNewParent->StringName);


    // This operation should not be performed on read-only objects.
    pModifyDNArg->CommArg.Svccntl.dontUseCopy = TRUE;

    // Initialize the THSTATE anchor and set a write sync-point.  This sequence
    // is required on every API transaction.  First the state DS is initialized
    // and then either a read or a write sync point is established.

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppModifyDNRes = pModifyDNRes = THAllocEx(pTHS, sizeof(MODIFYDNRES));
        if (pTHS->errCode) {
            __leave;
        }
        SYNC_TRANS_WRITE();                   // Set Sync point
        __try {

            // Inhibit update operations if the schema hasen't been loaded yet
            // or if we had a problem loading.

            if (!gUpdatesEnabled){
                DPRINT(2, "Returning BUSY because updates are not enabled yet\n");
                SetSvcError(SV_PROBLEM_BUSY, DIRERR_SCHEMA_NOT_LOADED);
                goto ExitTry;
            }

            // Perform name resolution to locate object.  If it fails, just
            // return an error, which may be a referral.  Note that we must
            // demand a writable copy of the object.
            pModifyDNArg->CommArg.Svccntl.dontUseCopy = TRUE;

            if (0 == DoNameRes(pTHS,
                               NAME_RES_IMPROVE_STRING_NAME,
                               pModifyDNArg->pObject,
                               &pModifyDNArg->CommArg,
                               &pModifyDNRes->CommRes,
                               &pModifyDNArg->pResObj)){

                // DoNameRes should have left us with a valid stringname
                Assert(pModifyDNArg->pResObj->pObj->NameLen);

                // Local Modify operation

                LocalModifyDN(pTHS,
                              pModifyDNArg,
                              pModifyDNRes,
                              FALSE);
            }

            ExitTry:;
        }
        __finally {
            if (pTHS->errCode != securityError) {
                // Security errors are logged separately
                BOOL fFailed = (BOOL)(pTHS->errCode || AbnormalTermination());

                LogEventWithFileNo(
                         DS_EVENT_CAT_DIRECTORY_ACCESS,
                         fFailed ?
                           DS_EVENT_SEV_EXTENSIVE :
                            DS_EVENT_SEV_INTERNAL,
                         fFailed ?
                            DIRLOG_PRIVILEGED_OPERATION_FAILED :
                            DIRLOG_PRIVILEGED_OPERATION_PERFORMED,
                         szInsertSz(""),
                         szInsertDN(pModifyDNArg->pObject),
                         NULL,
                         FILENO);
            }

            CLEAN_BEFORE_RETURN (pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                  &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pModifyDNRes) {
        pModifyDNRes->CommRes.errCode = pTHS->errCode;
        pModifyDNRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

} // DirModifyDN*/


int
CheckNameForRename(
        IN  THSTATE    *pTHS,
        IN  RESOBJ     *pResParent,
        IN  WCHAR      *pRDN,
        IN  DWORD       cchRDN,
        IN  DSNAME     *pDN
        )
/*++

Routine Description:

    Verify the given DSNAME is a valid name for an object to be renamed to;
    i.e., that it does not conflict with those of existing objects.

    NOTE: If you change this function, you may also want to change its sister
    function, CheckNameForAdd().

Arguments:

    pTHS - thread state
    pResParent - resobj for the proposed new (or existing, if just a rename, not
           a move) parent.
    pRDN - the RDN of the new name for the object.
    cchRDN - characters in pRDN.
    pDN (IN) - the proposed new name for an object.  Just used for error
             reporting. Should be the DN of pResParent + the RDN in pRDN.

Return Values:

    Thread state error code.

--*/
{
    DBPOS *     pDB = pTHS->pDB;
    ULONG       dbError;
    GUID        PhantomGuid;


    // Now, get the type from the name
    dbError = DBFindChildAnyRDNType(pTHS->pDB, pResParent->DNT, pRDN, cchRDN);

    switch ( dbError ) {
    case 0:
        // Local object with this name (dead or alive) already
        // exists.
        SetUpdError(UP_PROBLEM_ENTRY_EXISTS, DIRERR_OBJ_STRING_NAME_EXISTS);
        break;

    case ERROR_DS_KEY_NOT_UNIQUE:
        // No local object with this name (dead or alive) already
        // exists, but one with the same key in the PDNT-RDN table exists.  In
        // that case, we don't allow the add (since the DB would bounce this
        // later anyway).
        SetUpdError(UP_PROBLEM_NAME_VIOLATION, ERROR_DS_KEY_NOT_UNIQUE);
        break;

    case DIRERR_OBJ_NOT_FOUND:
        // New name is locally unique.
        break;

    case DIRERR_NOT_AN_OBJECT:
        DPRINT2(1,
                "Found phantom for \"%ls\" @ DNT %u when searching by string name.\n",
                pDN->StringName, pDB->DNT);

        // Found a phantom with this name; get its GUID (if any).
        dbError = DBGetSingleValue(pDB, ATT_OBJECT_GUID, &PhantomGuid,
                                   sizeof(PhantomGuid), NULL);

        // Note that regardless of type, we're going to mangle the RDN value of
        // the existing phantom
        switch (dbError) {
        case DB_ERR_NO_VALUE:
            // Phantom has no guid; make one up.

            // In this case we could subsume the phantom by changing
            // all references to it to point to the DNT of the object we're
            // renaming then destroying the phantom, but for now we'll
            // simply rename it like we would a guided phantom.  If we ever
            // change to subsume, we need to add code here to check types.

            DsUuidCreate(&PhantomGuid);
            // Fall through...

        case 0:
            // The phantom either has no guid or has a guid that is
            // different from that of the object we're renaming.

            // Allow the object we're renaming to take ownership of the
            // name -- rename the phantom to avoid a name conflict, then
            // allow the rename to proceed.

            if ((dbError = DBMangleRDNforPhantom(pDB, MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
                                                 &PhantomGuid)) ||
                (dbError = DBUpdateRec(pDB))) {
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, dbError);
            }
            break;

        default:
            // Unforeseen error return from DBGetSingleValue()
            // while trying to retrieve the phantom's GUID.
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, dbError);
            break;
        }
        break;

    case DIRERR_BAD_NAME_SYNTAX:
    case DIRERR_NAME_TOO_MANY_PARTS:
    case DIRERR_NAME_TOO_LONG:
    case DIRERR_NAME_VALUE_TOO_LONG:
    case DIRERR_NAME_UNPARSEABLE:
    case DIRERR_NAME_TYPE_UNKNOWN:
    default:
        // Bad object name.
        SetNamError(NA_PROBLEM_BAD_ATT_SYNTAX, pDN, DIRERR_BAD_NAME_SYNTAX);
        break;
    }

    return pTHS->errCode;
}


//============================================================================
//
//                      DN Modification - Common Helper Routine
//
//============================================================================

// Find the object, check that the new name is ok, then change the object's
// name.

int
LocalModifyDN (THSTATE *pTHS,
               MODIFYDNARG *pModifyDNArg,
               MODIFYDNRES *pModifyDNRes,
               BOOL fIsUndelete
               )
{
    CLASSCACHE     *pCC;
    DSNAME         *pParentName = NULL;
    DSNAME         *pNewerName = NULL;
    DWORD          InstanceType;
    DWORD          ulNCDNT, ulNewerNCDNT;
    DWORD          err;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    ULONG          cbNTSD, ulLen, cAVA, LsaClass;
    BOOL           fMove, fRename, fSameName, fDefunct;
    BOOL           fSDIsGlobalSDRef;
    DWORD          ActiveContainerID;
    unsigned       i;
    DSNAME         *pObjName = pModifyDNArg->pResObj->pObj;
    WCHAR          *pwNewRDNVal=NULL;
    DWORD           cchNewRDNVallen;
    BOOL           fFreeParentName = FALSE;
    BOOL           fNtdsaAncestorWasProtected;
    DWORD          dwNameResFlags;
    DWORD          dwNewParentNameResError;

    DPRINT2(1,"LocalModifyDN(%ws->%ws) entered\n",
            pObjName->StringName,
            pModifyDNArg->pNewParent->StringName);

    PERFINC(pcTotalWrites);
    INC_WRITES_BY_CALLERTYPE( pTHS->CallerType );

    // Callers guarantee that we have a resobj.  Furthermore, the pObj in the
    // resobj is guaranteed to have a string DN, pModifyDNArg->pObject is not
    // guaranteed to have the string name.  Therefore, we use
    // pModifyDNArg->pResObj->pObj exclusively in this routine.
    Assert(pModifyDNArg->pResObj);
    Assert(pObjName->NameLen);

    // These are for maintainance convenience, it's easier to read.
    pwNewRDNVal = (WCHAR *)pModifyDNArg->pNewRDN->AttrVal.pAVal->pVal;
    cchNewRDNVallen = (pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen/
                       sizeof(WCHAR));
    //
    // Log Event for tracing
    //

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_MODIFYDN,
                     EVENT_TRACE_TYPE_START,
                     DsGuidModDN,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertDN(pObjName),
                     ((pModifyDNArg->pNewParent != NULL) ?
                      szInsertDN(pModifyDNArg->pNewParent) :
                      szInsertSz("")),
                     szInsertWC2(pwNewRDNVal, cchNewRDNVallen),
                     NULL, NULL, NULL, NULL);

    // Check arguments before doing any DB operations
    if(!pModifyDNArg->pNewRDN ||
       !pModifyDNArg->pNewRDN->AttrVal.pAVal ||
       !pModifyDNArg->pNewRDN->AttrVal.pAVal->pVal ||
       !pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen ||
       pModifyDNArg->pNewRDN->AttrVal.pAVal->valLen > ( MAX_RDN_SIZE *
                                                       sizeof(WCHAR)))  {
        // What? No RDN?  Hey, ya gotta give me an RDN, even if it is the same
        // as the current RDN.
        // Or, Hey! I don't take 0 length RDNs!
        // Or, Hey! That RDN is too long!
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
            DIRERR_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // First, get the security descriptor for this object.
    if (err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pModifyDNArg->pResObj->DNT,
                    &cbNTSD,
                    &pNTSD,
                    NULL,
                    NULL,
                    NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef)) {
        // failed to get the SD off the current object
        SetUpdErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err);
        return CheckObjDisclosure(pTHS, pModifyDNArg->pResObj, FALSE);
    }

    if (cbNTSD == 0) {
        // Every object EXCEPT AUTO SUBREFS should have an SD, and those should
        // be renamed only by replication.
        Assert(pTHS->fSingleUserModeThread || DBCheckObj(pTHS->pDB));
        Assert(pTHS->fDRA || pTHS->fSingleUserModeThread);
        Assert(CLASS_TOP == pModifyDNArg->pResObj->MostSpecificObjClass);
    }

    // Determine the object's class.
    if(!(pCC = SCGetClassById(pTHS,
                              pModifyDNArg->pResObj->MostSpecificObjClass))) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                    DIRERR_OBJECT_CLASS_REQUIRED);
        goto exit;
    }

    if (pTHS->fDRA) {
        // The replicator can move things under deleted objects
        pModifyDNArg->CommArg.Svccntl.makeDeletionsAvail = TRUE;
    }

    // Compute the current parent's name
    pParentName = (DSNAME *)THAllocEx(pTHS,
                                      pObjName->structLen);
    fFreeParentName = TRUE;
    TrimDSNameBy(pObjName, 1, pParentName);

    if (pModifyDNArg->pNewParent) {
        // We are moving the object to a new parent.
        // Try to look it up and improve the name so that our DN locking logic works.
        dwNameResFlags = NAME_RES_IMPROVE_STRING_NAME;
        if (pModifyDNArg->fAllowPhantomParent) {
            dwNameResFlags |= NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED;
        }
        dwNewParentNameResError = DoNameRes(pTHS,
                                            dwNameResFlags,
                                            pModifyDNArg->pNewParent,
                                            &pModifyDNArg->CommArg,
                                            &pModifyDNRes->CommRes,
                                            &pModifyDNArg->pResParent);
        if (dwNewParentNameResError == ERROR_SUCCESS) {
            // Now that we have an improved new parent name, we can figure out
            // if this is a move operation or just a rename.
            // pParentName is the string name of current parent.
            fMove = !NameMatchedStringNameOnly(pParentName, pModifyDNArg->pResParent->pObj);

            // Now, set up a pointer to the parents name.
            THFreeEx(pTHS, pParentName);
            fFreeParentName = FALSE;
            pParentName = pModifyDNArg->pResParent->pObj;
        }
        else {
            THClearErrors();
            // Remember the error, but don't fail quite yet. First, we need to make
            // sure we can disclose the existence of the source object.
            // We are going to fail afterwards. But for consistency sake, let's
            // set fMove. We are sure it is indeed an attempted move because
            // we failed to find the new parent (and our current parent does exist).
            fMove = TRUE;
        }
        // position back on the source object
        DBFindDNT(pTHS->pDB, pModifyDNArg->pResObj->DNT);
    }
    else {
        // No new parent has been specified.
        fMove = FALSE;
    }

    // Get the name of the new object by appending the new RDN to the
    // (potentially new) parent name.
    // First allocate memory for pNewerName. Allocate more than enough space
    pNewerName = (DSNAME *)THAllocEx(pTHS,pParentName->structLen +
                              (4+MAX_RDN_SIZE + MAX_RDN_KEY_SIZE)*(sizeof(WCHAR)) );
    AppendRDN(pParentName,
              pNewerName,
              pParentName->structLen
                + (4+MAX_RDN_SIZE + MAX_RDN_KEY_SIZE)*(sizeof(WCHAR)),
              pwNewRDNVal,
              cchNewRDNVallen,
              pModifyDNArg->pNewRDN->attrTyp);

    // Make sure we have appropriate rights to change the name of the object.
    err = CheckRenameSecurity(pTHS, 
                              pNTSD, 
                              pObjName,                      // current object DN
                              pNewerName->StringName,        // new DN (for auditing only)
                              fMove && dwNewParentNameResError == ERROR_SUCCESS ? // GUID of the new parent (for move, if exists)
                                    &pModifyDNArg->pResParent->pObj->Guid : NULL,
                              pCC,
                              pModifyDNArg->pResObj,
                              pModifyDNArg->pNewRDN->attrTyp,
                              fMove,
                              fIsUndelete);
    // we don't need pNTSD anymore
    if (pNTSD && !fSDIsGlobalSDRef) {
        THFreeEx(pTHS, pNTSD);
    }
    pNTSD = NULL;
    if (err) {
        goto exit;
    }
    // From here on out we no longer need to worry about revealing the existence of of the
    // object being renamed.  However, it's still important to protect the existence of any
    // destination parent.

    // Look up the new parent
    if (pModifyDNArg->pNewParent) {
        // we have already attempted a DoNameRes on the parent.
        if (dwNewParentNameResError == ERROR_SUCCESS) {
            // There was no error. Just position on the parent so that we can check security.
            DBFindDNT(pTHS->pDB, pModifyDNArg->pResParent->DNT);
        }
    }
    else {
        // We have not found the parent yet. Do it now.
        dwNewParentNameResError = DoNameRes(pTHS,
                                            pModifyDNArg->fAllowPhantomParent ?
                                                (NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED) : 0,
                                            pParentName,
                                            &pModifyDNArg->CommArg,
                                            &pModifyDNRes->CommRes,
                                            &pModifyDNArg->pResParent);
    }
    if (dwNewParentNameResError) {
        THClearErrors();
        //
        // If you change this error, you must also change the error returned
        // below in the case that CheckParentSecurity fails and the parent
        // object is not visible by the client.  Otherwise clients
        // that wouldn't normally know of the existence of the parent
        // object of this rename could find out through the error path
        // below.  Search for
        // ***ObjDisclosure***
        SetUpdErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_NO_PARENT_OBJECT, dwNewParentNameResError);
        goto exit;
    }

    // Verify that the object can be moved to the new location and that
    // all the schema validation checks out.
    if (!pTHS->fSingleUserModeThread) {
        err = CheckParentSecurity(pModifyDNArg->pResParent,
                                  pCC,
                                  FALSE,
                                  NULL,
                                  fMove ? &pNTSD : NULL,
                                  &cbNTSD,
                                  &fSDIsGlobalSDRef);
        if (pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pNTSD);
        }
        if (err) {
            // !!! looking at CheckParentSecurity, seems like err == pTHS->errCode
            Assert(err == pTHS->errCode);

            //
            // Be sure not to reveal the existence of this object if the client
            // cannot already see it.
            //
            if (!IsObjVisibleBySecurity(pTHS, FALSE)) {
                THClearErrors();
                //
                // This must be the same error that gets set if we fail to
                // find the new parent object of a move otherwise we reveal
                // the existence of an object that the client isn't allowed
                // to see.
                // ***ObjDisclosure***
                err = SetUpdErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_NO_PARENT_OBJECT, nameError);
            }
            goto exit;
        }
    }
    // At this point the client is cleared to know of the existence of both the original object and any
    // destination parent.

    //
    // Go back to being positioned on the object being moved.
    //
    DBFindDNT(pTHS->pDB, pModifyDNArg->pResObj->DNT);

    // Check to see if this is an update in an active container
    CheckActiveContainer(pModifyDNArg->pResObj->PDNT, &ActiveContainerID);

    if(ActiveContainerID) {
        if(PreProcessActiveContainer(pTHS,
                                     ACTIVE_CONTAINER_FROM_MODDN,
                                     pObjName,
                                     pCC,
                                     ActiveContainerID)) {
            goto exit;
        }
    }

    // move an object into or out of system container is forbidden,
    // unless the "Unlock System Subtree" registry key is set.

    if ( !pTHS->fDSA && !pTHS->fDRA && !fIsUndelete && !gulUnlockSystemSubtree ){
        BOOL bFrom, bTo;

        bFrom = IsUnderSystemContainer(pTHS, pModifyDNArg->pResObj->DNT);
        bTo   = IsUnderSystemContainer(pTHS, pModifyDNArg->pResParent->DNT);

        if (bFrom != bTo) {
            SetUpdError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER);
            goto exit;
        }
    }

    // Check if the class is defunct,
    // We do not allow any modifications on instances of defunct classes.
    // return same error as if the object class is not found

    // DSA and DRA threads are exempt from this

    if ( pCC->bDefunct && !pTHS->fDSA && !pTHS->fDRA ) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                    DIRERR_OBJECT_CLASS_REQUIRED);
        goto exit;
    }

    // Check if it is a schema object rename. If it is, we need to
    // check that (1) we are not trying to rename a base schema object and
    // (2) we are not trying to rename a defunct class/attribute.
    // If so, return appropriate error
    // (Again, DSA and DRA threads are allowed to do this
    // or if we have the special registry key set (the function checks that)

    if ( (pCC->ClassId == CLASS_ATTRIBUTE_SCHEMA) ||
           (pCC->ClassId == CLASS_CLASS_SCHEMA) ) {

         err = 0;
         err = CheckForSchemaRenameAllowed(pTHS);
         if (err) {
            // not allowed. error code is already set in thread state
            goto exit;
         }

        // Signal a urgent replication. We want schema changes to
        // replicate out immediately to reduce the chance of a schema
        // change not replicating out before the Dc where the change is
        // made crashes

        pModifyDNArg->CommArg.Svccntl.fUrgentReplication = TRUE;
    }

    // only LSA can modify TrustedDomainObject and Secret Object
    if (!SampIsClassIdAllowedByLsa(pTHS, pCC->ClassId))
    {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // Don't allow renames/moves of tombstones, except if caller is the
    // replicator.
    if (pModifyDNArg->pResObj->IsDeleted && !pTHS->fDRA && !pTHS->fSingleUserModeThread) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_ILLEGAL_MOD_OPERATION);
    }

    // So it is either not a schema object at all, or a rename is allowed
    // Proceed as usual

    // Get the NCDNT of the current object.
    ulNCDNT = pModifyDNArg->pResObj->NCDNT;

    // Use the object rdnType and not the object's class rdnattid
    // because a superceding class may have a different rdnattid
    // than the superceded class had when this object was created.
    if (!pTHS->fDRA && !pTHS->fSingleUserModeThread) {
        ATTRTYP OldAttrTyp;
        extern int GetRdnTypeForDeleteOrRename (IN THSTATE  *pTHS,
                                                IN DSNAME   *pObj,
                                                OUT ATTRTYP *pRdnType);

         if (GetRdnTypeForDeleteOrRename(pTHS,
                                         pModifyDNArg->pResObj->pObj,
                                         &OldAttrTyp)) {
             goto exit;
         }
        // Wrong attribute for RDN
        if (OldAttrTyp != pModifyDNArg->pNewRDN->attrTyp) {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION);
            goto exit;
        }
    }

    // Make sure the RDN is well formed.
    // Replication excluded so that we can have BAD_NAME_CHAR in RDN of
    // morphed names
    if (    !pTHS->fDRA
            && fVerifyRDN(pwNewRDNVal,cchNewRDNVallen) ) {
        SetNamError(NA_PROBLEM_NAMING_VIOLATION, pNewerName, DIRERR_BAD_ATT_SYNTAX);
        goto exit;
    }

    // For the sake of future simplicity, figure out now whether or not
    // the user is requesting that the RDN be changed
    {
        WCHAR RDNold[MAX_RDN_SIZE];
        ATTRTYP oldtype;
        ULONG oldlen;

        GetRDNInfo(pTHS,
            pObjName,
            RDNold,
            &oldlen,
            &oldtype);
        oldlen *= sizeof(WCHAR);

        if (   (oldlen != (cchNewRDNVallen * sizeof(WCHAR)))
            || memcmp(RDNold,
                      pwNewRDNVal,
                      oldlen)) {
            fRename = TRUE;
        }
        else {
            fRename = FALSE;
        }
    }

    // Is the new name the same as the old name (case-insensitive)?
    fSameName = NameMatched(pObjName, pNewerName);

    // Make sure new object name is not a descendant of the original object.
    if (!fSameName && NamePrefix(pObjName,pNewerName)) {
        // Yep, trying to move an object to be its own descendant.  Can't let
        // you do that.
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION);
        goto exit;
    }

    // lock the DN against multiple simultaneous insertions
    if (!fSameName
         && (pNewerName->NameLen > 2)
         && DBLockDN(pTHS->pDB, 0, pNewerName)) {
        // Someone's trying to use the new name.
        SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
        goto exit;
    }

    // If we are reparenting, tree-lock the original object to avoid someone
    // moving an ancestor of the new name to be a descendant of the original
    // object, thus creating a disconnected cycle in the DIT.
    if((pObjName->NameLen > 2)
        && DBLockDN(pTHS->pDB, DB_LOCK_DN_WHOLE_TREE,
                    pObjName)) {
        // Can't tree lock the object.  Oh, well, go home, since the
        // move can't be guaranteed to be safe.
        SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
        goto exit;
    }

    // Read lock each ancestor of the new parent (up to but not including its
    // NC head) so that we do not suffer from write skew caused by another
    // concurrent move of a parent of our new parent underneath our object to
    // move.  this write skew cannot be avoided by locking the DNs because
    // these locks are relinquished on commit of the other transactions whereas
    // the write skew hazard will exist until we commit our transaction
    // Don't bother locking if the new parent is a phantom, which might be the 
    // case for domain rename. This is because phantoms don't have NCDNT.
    if (!(pModifyDNArg->pResParent->InstanceType & IT_UNINSTANT)) {
        DBFindDNT(pTHS->pDB, pModifyDNArg->pResParent->DNT);
        while (pTHS->pDB->DNT != pModifyDNArg->pResParent->NCDNT) {
            DBClaimReadLock(pTHS->pDB);
            DBFindDNT(pTHS->pDB, pTHS->pDB->PDNT);
        }
        DBFindDNT(pTHS->pDB, pModifyDNArg->pResObj->DNT);
    }

    // Get instance type since it is needed in both the DsaIsRunning and
    // DsaIsInstalling cases.
    InstanceType = pModifyDNArg->pResObj->InstanceType;

    if ( DsaIsRunning() && !pTHS->fSingleUserModeThread) {
        // Some extra checks that we don't bother doing when we are installing,
        // therefore allowing the install phase to violate some rules.
        // Single User Mode can also violate these checks

        // See if the instance type of the object will allow a rename

        if (    ( (InstanceType & IT_NC_HEAD) && (fMove || !pTHS->fDRA) )
             || ( !(InstanceType & IT_WRITE) && !pTHS->fDRA )
           )
        {
            // DRA can change the case of an NC head and rename and/or move
            // read-only objects.  Otherwise operations on NC heads and
            // read-only objects are disallowed.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE);
            goto exit;
        }

        // Check for various restrictions on moves and renames in
        // sensitive portions of the tree
        if (pTHS->fDRA) {
            // Don't argue with the replicator, let him pass.
            ;
        }
        else if (ulNCDNT == gAnchor.ulDNTDMD && fMove) {
                // Can't move objects in schema NC, but renames are ok
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC);
                goto exit;
        }
        else if (ulNCDNT == gAnchor.ulDNTConfig) {
            // Sigh.  The config NC is more complicated.  We allow moves
            // and renames only if certain bits are set on the object.
            ULONG ulSysFlags;

            err = DBGetSingleValue(pTHS->pDB,
                   ATT_SYSTEM_FLAGS,
                   &ulSysFlags,
                   sizeof(ulSysFlags),
                   NULL);
            if (err) {
                // An error means no value, which is flags of 0.
                ulSysFlags = 0;
            }

            if ((fMove && !(ulSysFlags &
                            (FLAG_CONFIG_ALLOW_MOVE |
                             FLAG_CONFIG_ALLOW_LIMITED_MOVE))) ||
                (fRename && !(ulSysFlags & FLAG_CONFIG_ALLOW_RENAME)
                 && !IsExemptedFromRenameRestriction(pTHS, pModifyDNArg))) {
                // If the object had no flags set (and is not an exempted
                // rename), or we want to move and the move-allowed bit isn't
                // set, or we want to rename and the rename allowed bit isn't
                // set & the rename operation is not exempted from rename
                // restrictions, fail the op.

                SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                              ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG,
                              ulSysFlags);
                goto exit;
            }

            if (fMove && !(ulSysFlags & FLAG_CONFIG_ALLOW_MOVE)) {
                // Ok, one last test.  We want to move the object, and
                // moves are not forbidden on this object, but we restrict
                // moves on this object to only being to sibling containers.
                // That is, although we allow the object to change parent
                // containers, we do not allow it to change grandparent
                // containers.  Even further confusion has dorked around
                // with exactly what level of ancestor we demand to have
                // in common, so this is now controlled with a single define,
                // where 1 would be parent, 2 grandparent, 3 great-grandparent,
                // etc.
                // Yes, this is an ad hoc (some might say "ad hack") mechanism
                // to solve a nagging problem of how to control structure
                // in the DS, but, well, I couldn't think of anything better.
                #define ANCESTOR_LEVEL 3
                unsigned cNPold, cNPnew;
                DSNAME *pGrandParentOld, *pGrandParentNew;

                Assert(ulSysFlags & FLAG_CONFIG_ALLOW_LIMITED_MOVE);

                if (CountNameParts(pObjName, &cNPold) ||
                    CountNameParts(pNewerName, &cNPnew) ||
                    (cNPold != cNPnew) ||
                    (cNPold < ANCESTOR_LEVEL)) {
                    // Either we couldn't parse one of the names, or
                    // the new and old names are at different levels,
                    // or we're too close to the root.
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_MODIFYDN_WRONG_GRANDPARENT);
                    goto exit;
                }

                // We now know we're trying to move to an equal depth,
                // so we just have to test if it's the same grandparent
                pGrandParentOld =
                        THAllocEx(pTHS, pObjName->structLen);

                pGrandParentNew =
                        THAllocEx(pTHS, pParentName->structLen);

                TrimDSNameBy(pObjName,
                         ANCESTOR_LEVEL,
                         pGrandParentOld);
                TrimDSNameBy(pParentName,
                         ANCESTOR_LEVEL - 1,
                         pGrandParentNew);
                if (!NameMatched(pGrandParentOld, pGrandParentNew)) {
                    SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_MODIFYDN_WRONG_GRANDPARENT);
                }
                THFreeEx(pTHS, pGrandParentOld);
                THFreeEx(pTHS, pGrandParentNew);
                if (pTHS->errCode) {
                    goto exit;
                }
                #undef ANCESTOR_LEVEL
            }
        }
        else {
            // For any other container, we check for some other bits that
            // control whether we allow renames (the default behaviour is
            // reversed from the behaviour of the ConfigNC).  That is,
            // we disallow moves and renames only if certain bits are set on the
            // object.
            ULONG ulSysFlags;

            err = DBGetSingleValue(pTHS->pDB,
                       ATT_SYSTEM_FLAGS,
                       &ulSysFlags,
                       sizeof(ulSysFlags),
                       NULL);
            if (!err) {
                // We have system flags.
                if(fRename && (ulSysFlags & FLAG_DOMAIN_DISALLOW_RENAME)
                    && !IsExemptedFromRenameRestriction(pTHS, pModifyDNArg)) {
                        // We're trying to rename, but the rename flag is set and
                        // the current rename operation is not exempted from rename
                        // restrictions, which
                        // means we aren't allowed to do this.

                        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                      ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG,
                                      ulSysFlags);
                        goto exit;
                }

                if (fMove && (ulSysFlags & FLAG_DOMAIN_DISALLOW_MOVE)) {
                    // Moves are restricted, return an error.
                    SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                  ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG,
                                  ulSysFlags);
                    goto exit;
                }
            }
        }
    }

    // Make sure that the object doesn't already exist
    if (!fSameName &&
        CheckNameForRename(pTHS,
                           pModifyDNArg->pResParent,
                           pwNewRDNVal,
                           cchNewRDNVallen,
                           pNewerName)) {
        Assert(pTHS->errCode);
        goto exit;
    }


    // CheckParentSecurity has ensured that the parent exists and is alive.

    // What's the appropriate NCDNT for the object if we rename it?
    // NOTE: Ok to ALLOW_DELETED_PARENT in subsequent call as if we are not
    // fDRA, then prior CheckParentSecurity would have returned an error.

    if (!pTHS->fSingleUserModeThread) {
        if ( InstanceType & IT_NC_HEAD )
        {
            // Only replication is allowed to perform renames of NC heads, and
            // moves are disallowed even for replication.
            Assert( pTHS->fDRA || pTHS->fSingleUserModeThread);
            Assert( !fMove || pTHS->fSingleUserModeThread);

            ulNewerNCDNT = ulNCDNT;
        }
        else {
            if ( FindNcdntFromParent(pModifyDNArg->pResParent,
                                     FINDNCDNT_ALLOW_DELETED_PARENT,
                                     &ulNewerNCDNT
                                     )
                ){
                // Failed to derive NCDNT for the new name.
                // This should never happen, as above we verified that a qualified
                // parent exists, and that should be the only reason we could fail.
                Assert( !"Failed to derive NCDNT for new name!" );
                goto exit;
            }

            if((ulNCDNT != ulNewerNCDNT) &&
               (!pTHS->fDSA || DsaIsRunning())) {
                // The move is outside the NC and we are not the DSA or we are the
                // dsa but we are installed.  In that case, you can't move the
                // object as requested.

                // BUG: Reset the service error to cross-NC specific code for
                // subsequent cross-domain move.

                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_ILLEGAL_MOD_OPERATION);
                goto exit;
            }
        }
    }

    // CheckNameForRename moved us, but we're done there,
    // so move back
    DBFindDNT(pTHS->pDB,pModifyDNArg->pResObj->DNT);

    // Update the RDN
    if(ReSetNamingAtts(pTHS,
                       pModifyDNArg->pResObj,
                       fMove ? pModifyDNArg->pNewParent : NULL,
                       pModifyDNArg->pNewRDN,
                       TRUE,
                       pModifyDNArg->fAllowPhantomParent,
                       pCC)
       ||
       // Insert the object into the database for real.
       InsertObj(pTHS,
                 pObjName,
                 pModifyDNArg->pMetaDataVecRemote,
                 TRUE,
                 META_STANDARD_PROCESSING)) {
        goto exit;
    }

    // Only notify replicas if this is not the DRA thread. If it is, then
    // we will notify replicas near the end of DRA_replicasync. We can't
    // do it now as NC prefix is in inconsistent state

    if (!pTHS->fDRA && DsaIsRunning()) {
        // Currency of DBPOS must be at the target object
        DBNotifyReplicasCurrDbObj(pTHS->pDB,
                           pModifyDNArg->CommArg.Svccntl.fUrgentReplication );
    }

    // If this changed anything in the ancestry of the DSA object, we
    // need to recache junk onto the anchor, check for change of site, etc.
    // If an undeletable object changes its parentage, or one of the ancestors
    // of an undeletable object changes its parentage, rebuild the anchor
    // so that the list of undeletable's ancestors is updated
    // We need to rebuild the anchor even if it was not a move, but just a rename
    // (i.e. fMove==FALSE). If the Default-First-Site-Name is changed to something
    // else, then the DSADN string name changed. Thus, we need to rebuild the anchor.
    if (fDNTInProtectedList( pModifyDNArg->pResObj->DNT,
                             &fNtdsaAncestorWasProtected )) {
        if (fNtdsaAncestorWasProtected) {
            pTHS->fNlSiteNotify = TRUE;
        }
        pTHS->fAnchorInvalidated = TRUE;
    }

    // check to see if we are messing with an NC head for domain rename
    // There are two kinds of partition heads we need to deal with: instantiated and
    // uninstantiated. An uninstantiated partition head always looks like:
    // #define SUBREF ((SYNTAX_INTEGER) (IT_UNINSTANT | IT_NC_HEAD | IT_NC_ABOVE))
    // If a pure subref no longer needs its ABOVE flag, the whole thing is deleted.
    // Please note that this code depends on the fact that parents are renamed before
    // children, so that the parent's correct instance type is available.
    //
    if ((InstanceType & IT_NC_HEAD) && pTHS->fSingleUserModeThread) {
        DWORD  oldInstanceType = InstanceType;
        DWORD  oldNCDNT, newNCDNT, cb;

        Assert (pTHS->fSingleUserModeThread);
        DPRINT1 (0, "LocalModifyDn messing up with an NC head: %x\n", InstanceType);

        if (FPrefixIt(pModifyDNArg->pResParent->InstanceType)) {

            // our parent is an instantiated NC_HEAD, so we should have IT_NC_ABOVE set
            //
            if ( !(InstanceType & IT_NC_ABOVE) ) {
                InstanceType |= IT_NC_ABOVE;
            }
        }
        // our parent is not a NC head, so we should not have the NC_ABOVE set
        else if (InstanceType & IT_NC_ABOVE) {
            InstanceType ^= IT_NC_ABOVE;
        }


        if (InstanceType == (SUBREF ^ IT_NC_ABOVE)) {
            // We have a pure subref that is no longer necessary. delete it
            REMOVEARG remArg;

            DPRINT1( 0, "Removing unnecessary SUBREF for %ws\n", pNewerName->StringName );
            memset(&remArg, 0, sizeof(REMOVEARG));
            remArg.pObject = pNewerName;
            InitCommarg(&remArg.CommArg);
            remArg.pResObj = pModifyDNArg->pResObj;
            remArg.fGarbCollectASAP = TRUE;
            remArg.fPreserveRDN = TRUE;

            if (LocalRemove(pTHS, &remArg)) {
                Assert(!"Failed to remove SUBREF");
                Assert(0 != pTHS->errCode);
                return pTHS->errCode;
            }

        } else {
            // Derive the NCDNT.
            if ( FindNcdntSlowly(
                     pNewerName,
                     FINDNCDNT_DISALLOW_DELETED_PARENT,
                     FINDNCDNT_ALLOW_PHANTOM_PARENT,
                     &newNCDNT
                     )
                )
            {
                // Failed to derive NCDNT.
                Assert(!"Failed to derive NCDNT");
                Assert(0 != pTHS->errCode);
                return pTHS->errCode;
            }


            // move to the object
            DBFindDNT(pTHS->pDB, pModifyDNArg->pResObj->DNT);

            err = DBGetSingleValue (pTHS->pDB, FIXED_ATT_NCDNT, &oldNCDNT, sizeof (oldNCDNT), &cb);
            if (err) {
                Assert (FALSE);
                SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
                goto exit;
            }

            if (oldInstanceType != InstanceType) {

                DPRINT1 (0, "New Instancetype: %x\n", InstanceType);
                Assert (ISVALIDINSTANCETYPE (InstanceType));

                err = DBReplaceAttVal(pTHS->pDB, 1, ATT_INSTANCE_TYPE, sizeof (InstanceType), &InstanceType);

                switch(err) {
                case 0:
                    // nothing to do.
                    break;
                default:
                    Assert (FALSE);
                    SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
                    goto exit;
                    break;
                }

                DBUpdateRec(pTHS->pDB);

                // this is similar to ModCheckCatalog
                // the difference is in the order of Dns passed.
                // we need the old one for the delete and the new one for the add
                // otherwise it fails with object not found

                if (err = DelCatalogInfo(pTHS, pModifyDNArg->pResObj->pObj, oldInstanceType)){
                    DPRINT1(0,"Error while deleting global object info\n", err);
                    goto exit;
                }

                if (err = AddCatalogInfo(pTHS, pNewerName)) {
                    DPRINT1(0,"Error while adding global object info\n", err);
                    goto exit;
                }
            }

            if (newNCDNT != oldNCDNT) {

                DPRINT2 (0, "Updating NCDNT for object: old/new NCDNT: %d / %d \n", oldNCDNT, newNCDNT );

                DBResetAtt(
                    pTHS->pDB,
                    FIXED_ATT_NCDNT,
                    sizeof( newNCDNT ),
                    &newNCDNT,
                    SYNTAX_INTEGER_TYPE
                    );

                DBUpdateRec(pTHS->pDB);
            }
        }
    } else if ( (pTHS->fSingleUserModeThread) &&
                (fMove) &&
                (RESOBJ_IS_PHANTOM( pModifyDNArg->pResObj )) ) {
        // We are reparenting a phantom in single user mode

        // Is this the exact name of an NC in the forest?
        // Is the parent an instantiated NC?
        if ( (FPrefixIt(pModifyDNArg->pResParent->InstanceType)) &&
             (SearchExactCrossRef( pTHS, pNewerName )) ) {
            BOOL fSkipSave = pTHS->pDB->fSkipMetadataUpdate;
            // Subref does not exist and one is needed
            DPRINT1( 0, "Adding necessary SUBREF for %ws\n", pNewerName->StringName );

            pNewerName->Guid = pModifyDNArg->pResObj->pObj->Guid;
            pNewerName->Sid = pModifyDNArg->pResObj->pObj->Sid;
            pNewerName->SidLen = pModifyDNArg->pResObj->pObj->SidLen;

            Assert( !fNullUuid(&pNewerName->Guid) );

            // Allow this object to be created with metadata, even though we are
            // in single user mode
            pTHS->pDB->fSkipMetadataUpdate = FALSE;
            __try {
                err = AddPlaceholderNC(pTHS->pDB, pNewerName, SUBREF);
            } __finally {
                pTHS->pDB->fSkipMetadataUpdate = fSkipSave;
            }
            if (err) {
                Assert(!"Failed to add SUBREF");
                Assert(0 != pTHS->errCode);
                return pTHS->errCode;
            }
        }
    }


exit:
    if (fFreeParentName) {
        THFreeEx(pTHS, pParentName);
    }

    THFreeEx(pTHS, pNewerName);
    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_MODIFYDN,
                     EVENT_TRACE_TYPE_END,
                     DsGuidModDN,
                     szInsertUL(pTHS->errCode),
                     NULL, NULL,
                     NULL, NULL, NULL, NULL, NULL);

    return pTHS->errCode;            // incase we have an attribute error

} /*LocalModifyDN*/


int
CheckForSchemaRenameAllowed(
    THSTATE *pTHS
    )

/*++
   Routine Description:
      Checks if the schema object is either a base schema object, or if it is
      defunct. Rename is not allowed in either case.
      fDSA, fDRA, and if the special registry key is set, are exempt

   Arguments:
      pTHS -- pointer to thread state

   Return Value:
      The error code set in the thread state
--*/

{
    BOOL fDefunct, fBaseSchemaObj;
    ULONG sysFlags, err = 0;

    // All is allowed if fDSA or fDRA is set, or if the special registry flag
    // to allow all changes is set

    if (pTHS->fDSA || pTHS->fDRA || gAnchor.fSchemaUpgradeInProgress) {
       return 0;
    }

    // Check if it is a base schema object
    // Find the systemFlag value on the object, if any
    // to determine is this is a base schema object

    err = DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, &sysFlags,
                           sizeof(sysFlags), NULL);

    switch (err) {
          case DB_ERR_NO_VALUE:
             // Value does not exist. Not a base schema object
             fBaseSchemaObj = FALSE;
             break;
          case 0:
             // Value exists. Check the bit
             if (sysFlags & FLAG_SCHEMA_BASE_OBJECT) {
                fBaseSchemaObj = TRUE;
             }
             else {
                fBaseSchemaObj = FALSE;
             }
             break;
          default:
               // some other error. return
              SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
              return (pTHS->errCode);
    } /* switch */

    if (fBaseSchemaObj) {
        // no rename of base schema objs are allowed
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD);
        return (pTHS->errCode);
    }

    // allow renaming defunct classes/attrs after schema-reuse is enabled
    if (!ALLOW_SCHEMA_REUSE_FEATURE(pTHS->CurrSchemaPtr)) {
        // not a base schema obj. Check if the object's IS_DEFUNCT attribute is set or not
        err = DBGetSingleValue(pTHS->pDB, ATT_IS_DEFUNCT, &fDefunct,
                               sizeof(fDefunct), NULL);

        switch (err) {
              case DB_ERR_NO_VALUE:
                 // Value does not exist. Not defunct
                 fDefunct = FALSE;
                 break;
              case 0:
                 // Value exists and is already in fDefunct
                 break;
              default:
                   // some other error. return
                  SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, err);
                  return (pTHS->errCode);
        } /* switch */

        if (fDefunct) {
            // Return object-not-found error
            SetNamError(NA_PROBLEM_NO_OBJECT, NULL, DIRERR_OBJ_NOT_FOUND);
        }
    }
    return (pTHS->errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdndnc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 2000
//
//  File:       mdndnc.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the functions necessary for the maintance of Non-Domain 
    Naming Contexts.

*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <attids.h>
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <prefix.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <sddl.h>
#include <sddlp.h>                      // needed for special SD conversion: ConvertStringSDToSDDomainW()
#include <ntdsapi.h>
#include <windns.h>

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "dsexcept.h"
#include "permit.h"
#include "drautil.h"
#include "debug.h"                      // standard debugging header
#include "usn.h"
#include "drserr.h"
#include "drameta.h"
#include "drancrep.h"                   // for ReplicateObjectsFromSingleNc().
#include "ntdsadef.h"
#include "sdprop.h"
#include "dsaapi.h"                     // For DirReplicaAdd & DirReplicaSynchronize

#define DEBSUB "MDNDNC:"                // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDNDNC

#include <ntdsadef.h>
  
DSNAME *
DeepCopyDSNAME(
    THSTATE *                      pTHS,
    DSNAME *                       pDsNameOrig,
    DSNAME *                       pPreAllocCopy
    )
{
    DSNAME *                       pDsNameCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pDsNameOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pDsNameCopy = pPreAllocCopy;
        Assert(!"If someone runs into this, then they can take it out, but it "
               "is suspicious you are pre-allocating this structure.\n");
        Assert(pDsNameCopy->structLen == pDsNameOrig->structLen && "It would "
               "be a good idea if these equaled each other to prove the called "
               "knows what he is doing");
        Assert(!IsBadWritePtr(pDsNameCopy, pDsNameOrig->structLen) && "This is "
               "bad, this means this call of DeepCopyDSNAME needs to not have "
               "the parameter preallocated, because the caller doesn't know "
               "how to allocate the right size struct\n");
    } else {
        // Means we need to THAlloc the structure and then fill it in.
        pDsNameCopy = THAllocEx(pTHS, pDsNameOrig->structLen);
    }

    Assert(!IsBadReadPtr(pDsNameOrig, sizeof(pDsNameOrig->structLen)));
    Assert(!IsBadWritePtr(pDsNameCopy, 1));
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    memcpy(pDsNameCopy, pDsNameOrig, pDsNameOrig->structLen);

    return(pDsNameCopy);
}

ATTRVAL *
DeepCopyATTRVAL(
    THSTATE *                       pTHS,
    ATTRVAL *                       pAttrValOrig,
    ATTRVAL *                       pPreAllocCopy
    )
{
    ATTRVAL *                       pAttrValCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...


    // This ensures this static definition doesn't change/expand on us.
    Assert(sizeof(ATTRVAL) == sizeof( struct { ULONG u; UCHAR * p; } ) &&
           "There've been changes to ATTRVAL's definition, please update "
           "function: DeepCopyATTRVAL()\n");
 
    Assert(pPreAllocCopy);
    pAttrValCopy = pPreAllocCopy;

    Assert(!IsBadReadPtr(pAttrValOrig, sizeof(ATTRVAL)));
    Assert(!IsBadWritePtr(pAttrValCopy, sizeof(ATTRVAL)));
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrValCopy->valLen = pAttrValOrig->valLen;
    pAttrValCopy->pVal = THAllocEx(pTHS, sizeof(UCHAR) * pAttrValOrig->valLen);
    memcpy(pAttrValCopy->pVal, pAttrValOrig->pVal, pAttrValOrig->valLen);

    return(pAttrValCopy);
}

ATTRVALBLOCK *
DeepCopyATTRVALBLOCK(
    THSTATE *                      pTHS,
    ATTRVALBLOCK *                 pAttrValBlockOrig,
    ATTRVALBLOCK *                 pPreAllocCopy
    )
{
    ATTRVALBLOCK *                 pAttrValBlockCopy = NULL;
    ULONG                          i;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    
    // This ensures this static definition doesn't change/expand on us.
    Assert( sizeof(ATTRVALBLOCK) == sizeof( struct { ULONG u; ATTRVAL * p; } ) &&
            "There've been changes to ATTRVALBLOCK's definition, please update "
            "function: DeepCopyATTRVALBLOCK()\n");

    Assert(pPreAllocCopy);    
    pAttrValBlockCopy = pPreAllocCopy;

    Assert(!IsBadReadPtr(pAttrValBlockOrig, sizeof(ATTRVALBLOCK)));
    Assert(!IsBadWritePtr(pAttrValBlockCopy, sizeof(ATTRVALBLOCK)));
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrValBlockCopy->valCount = pAttrValBlockOrig->valCount;
    pAttrValBlockCopy->pAVal = THAllocEx(pTHS, sizeof(ATTRVAL) * pAttrValBlockOrig->valCount);
    for(i = 0; i < pAttrValBlockCopy->valCount; i++){
        DeepCopyATTRVAL(pTHS, &(pAttrValBlockOrig->pAVal[i]), &(pAttrValBlockCopy->pAVal[i]));
    }

    return(pAttrValBlockCopy);
}


ATTR *
DeepCopyATTR(
    THSTATE *                      pTHS,
    ATTR *                         pAttrOrig,
    ATTR *                         pPreAllocCopy
    )
{
    ATTR *                         pAttrCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...

    // This ensures this static definition doesn't change/expand on us.
    Assert(sizeof(ATTR) == sizeof(struct { ATTRTYP a; ATTRVALBLOCK ab; } ) && 
           "There've been changes to the definition of ATTR, please update "
           "function: DeepCopyATTR()\n");

    Assert(pPreAllocCopy);    
    pAttrCopy = pPreAllocCopy;

    Assert(!IsBadReadPtr(pAttrOrig, sizeof(ATTR)));
    Assert(!IsBadWritePtr(pAttrCopy, sizeof(ATTR)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrCopy->attrTyp = pAttrOrig->attrTyp;
    DeepCopyATTRVALBLOCK(pTHS, &(pAttrOrig->AttrVal), &(pAttrCopy->AttrVal));

    return(pAttrCopy);
}

ATTRBLOCK *
DeepCopyATTRBLOCK(
    THSTATE *                      pTHS,
    ATTRBLOCK *                    pAttrBlockOrig,
    ATTRBLOCK *                    pPreAllocCopy
    )
{
    ATTRBLOCK *                    pAttrBlockCopy = NULL;
    ULONG                          i;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);
    Assert(sizeof(ATTRBLOCK) == sizeof( struct { ULONG u; ATTR * p; } ) &&
           "There've been changes to ATTRBLOCK's definition, please update "
           "funtion: DeepCopyATTRBLOCK()\n");
    
    if(pAttrBlockOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pAttrBlockCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own ATTRBLOCK.
        pAttrBlockCopy = THAllocEx(pTHS, sizeof(ATTRBLOCK));
    }

    Assert(!IsBadReadPtr(pAttrBlockOrig, sizeof(ATTRBLOCK)));
    Assert(!IsBadWritePtr(pAttrBlockCopy, sizeof(ATTRBLOCK)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAttrBlockCopy->attrCount = pAttrBlockOrig->attrCount;
    pAttrBlockCopy->pAttr = THAllocEx(pTHS, sizeof(ATTR) * pAttrBlockOrig->attrCount);
    for(i = 0; i < pAttrBlockCopy->attrCount; i++){
        DeepCopyATTR(pTHS, &(pAttrBlockOrig->pAttr[i]), &(pAttrBlockCopy->pAttr[i]));
    }

    return(pAttrBlockCopy);    
}
 
PROPERTY_META_DATA_VECTOR *
DeepCopyPROPERTY_META_DATA_VECTOR(
    THSTATE *                      pTHS,
    PROPERTY_META_DATA_VECTOR *    pMetaDataVecOrig,
    PROPERTY_META_DATA_VECTOR *    pPreAllocCopy
    )
{

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    if(pMetaDataVecOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }
    
    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    
    // If this needs to be filled in, use DeepCopyADDARG as an example.
    Assert(pMetaDataVecOrig == NULL && "Assumed this function then "
           "is not called in a replication thread (!fDRA), but if it does, "
           "someone should create the appropriate "
           "DeepCopyPROPERTY_META_DATA_VECTOR(...) function.");
    // Suggest you use DeepCopyADDARG() as an example function.
    return(NULL);
}

COMMARG *
DeepCopyCOMMARG(
    THSTATE *                      pTHS,
    COMMARG *                      pCommArgOrig,
    COMMARG *                      pPreAllocCopy
    )
{
    COMMARG *                      pCommArgCopy = NULL;
    
    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pCommArgOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pCommArgCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own COMMARG 
        pCommArgCopy = THAllocEx(pTHS, sizeof(COMMARG));
    }

    Assert(!IsBadReadPtr(pCommArgOrig, sizeof(COMMARG)));
    Assert(!IsBadWritePtr(pCommArgCopy, sizeof(COMMARG)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    // Note: Comm args are shallow structures so easy to fill in.
    *pCommArgCopy = *pCommArgOrig;

    return(pCommArgCopy);
}

RESOBJ *
DeepCopyRESOBJ(
    THSTATE *                      pTHS,
    RESOBJ *                       pResObjOrig,
    RESOBJ *                       pPreAllocCopy
    )
{
    RESOBJ *                       pResObjCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pResObjOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pResObjCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own COMMARG 
        pResObjCopy = THAllocEx(pTHS, sizeof(RESOBJ));
    }

    Assert(!IsBadReadPtr(pResObjOrig, sizeof(RESOBJ)));
    Assert(!IsBadWritePtr(pResObjCopy, sizeof(RESOBJ)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    *pResObjCopy = *pResObjOrig;
    pResObjOrig->pObj = DeepCopyDSNAME(pTHS, pResObjOrig->pObj, NULL);
        
    return(pResObjCopy);
}

CREATENCINFO *
DeepCopyCREATENCINFO(
    THSTATE *                      pTHS,
    CREATENCINFO *                 pCreateNCOrig,
    CREATENCINFO *                 pPreAllocCopy
    )
{
    CREATENCINFO *                 pCreateNCCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);

    if(pCreateNCOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller
        pCreateNCCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc our own COMMARG 
        pCreateNCCopy = THAllocEx(pTHS, sizeof(CREATENCINFO));
    }

    Assert(!IsBadReadPtr(pCreateNCOrig, sizeof(CREATENCINFO)));
    Assert(!IsBadWritePtr(pCreateNCCopy, sizeof(CREATENCINFO)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    *pCreateNCCopy = *pCreateNCOrig;
    Assert(pCreateNCCopy->pSDRefDomCR == NULL);
        
    return(pCreateNCCopy);
}

ADDARG *
DeepCopyADDARG(
    THSTATE * pTHS,
    ADDARG * pAddArgOrig,
    ADDARG * pPreAllocCopy
    )
{
    ADDARG *   pAddArgCopy = NULL;

    // --------------------------------------------------------------------------
    // Check for boundary cases and validate parameters ...
    Assert(pTHS);
    
    if(pAddArgOrig == NULL){
        Assert(pPreAllocCopy == NULL);
        return(NULL);
    }

    if(pPreAllocCopy != NULL){
        // Means the structure was Pre-Allocated by the caller, and
        pAddArgCopy = pPreAllocCopy;
    } else {
        // Means we need to THAlloc the structure and then fill it in.
        pAddArgCopy = THAllocEx(pTHS, sizeof(ADDARG));
    }

    Assert(!IsBadReadPtr(pAddArgOrig, sizeof(ADDARG)));
    Assert(!IsBadWritePtr(pAddArgCopy, sizeof(ADDARG)));

    // --------------------------------------------------------------------------
    // We have an original and a copy buffer now fill in each component ...
    pAddArgCopy->pObject = DeepCopyDSNAME(pTHS, pAddArgOrig->pObject, NULL);
    DeepCopyATTRBLOCK(pTHS, &(pAddArgOrig->AttrBlock), &(pAddArgCopy->AttrBlock));
    pAddArgCopy->pMetaDataVecRemote = DeepCopyPROPERTY_META_DATA_VECTOR(pTHS, pAddArgOrig->pMetaDataVecRemote, NULL);
    DeepCopyCOMMARG(pTHS, &(pAddArgOrig->CommArg), &(pAddArgCopy->CommArg));
    pAddArgCopy->pResParent = DeepCopyRESOBJ(pTHS, pAddArgOrig->pResParent, NULL);
    pAddArgCopy->pCreateNC = DeepCopyCREATENCINFO(pTHS, pAddArgOrig->pCreateNC, NULL);

    return (pAddArgCopy);
}

DWORD
AddNDNCHeadCheck(
    THSTATE *       pTHS,
    CROSS_REF *     pCR
    )
{
    DBPOS *         pDB = NULL;
    WCHAR *         wszDnsTemp = NULL;
    ULONG           ulTemp = 0;
    BOOL            fCreatorGood = FALSE;
    BOOL            fEnabled = TRUE;
    ULONG           i, dwErr;
    ATTCACHE *      pAC;


    // This routine checks that this is a valid NC Head creation,
    //  checks that the Cross-Ref is in a disabled state, checks
    //  that the current DC is the DC in the dnsRoot attribute.
    //  Note that we're overloading this attribute just before
    //  NC head creation.  After the NC Head is created the 
    //  attribute will be the appropriate DNS name of the 
    //  domain, not just this DC.

    // Make sure we've a clear error state.
    Assert(!pTHS->errCode);

    DBOpen(&pDB);
    __try {

        dwErr = DBFindDSName(pDB, pCR->pObj);
        if(dwErr){
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_UNKNOWN_ERROR,
                          dwErr);
            __leave;
        }
               
        // ----------------------------------------------------
        //
        // Check that the cross-ref is disabled.
        //

        dwErr = DBGetSingleValue(pDB,
                                 ATT_ENABLED,
                                 &fEnabled,
                                 sizeof(fEnabled),
                                 NULL);

        if(dwErr == DB_ERR_NO_VALUE){
            // Deal w/ no value seperately, because, no value means TRUE in
            // this context.
            fEnabled = TRUE;
        } else if (dwErr){
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_UNKNOWN_ERROR,
                          dwErr);
            __leave;
        } 
        
        if(fEnabled){
            SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                        DIRERR_CROSS_REF_EXISTS);
            __leave;
        }

        // ----------------------------------------------------
        //
        // Check the dNSRoot attribute matches the
        // current DSA pwszHostDnsName.
        //
        pAC = SCGetAttById(pTHS, ATT_DNS_ROOT);
        dwErr = DBGetAttVal_AC(pDB, 1, pAC, 0, 0, 
                               &ulTemp, (UCHAR **) &wszDnsTemp);
        Assert(ulTemp > 0);
        if(dwErr == DB_ERR_NO_VALUE){
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_MISSING_REQUIRED_ATT,
                          dwErr);
            __leave;
        } else if (dwErr) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          DIRERR_UNKNOWN_ERROR,
                          dwErr);
            __leave;
        }

        wszDnsTemp = THReAllocEx(pTHS, wszDnsTemp, ulTemp + sizeof(WCHAR));
        wszDnsTemp[ulTemp/sizeof(WCHAR)] = L'\0';

        if( DnsNameCompare_W(wszDnsTemp, gAnchor.pwszHostDnsName) ){
            // keep going and check other stuff.
        } else {
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        DIRERR_MASTERDSA_REQUIRED);
            __leave;
        }

        // We're golden ... 
        Assert(!pTHS->errCode);

    } __finally {

        if (wszDnsTemp) { THFreeEx(pTHS, wszDnsTemp); }
        DBClose(pDB, FALSE);
    
    }

    return(pTHS->errCode);
}


VOID
SometimesLogEvent(
    DWORD        dwEvent,
    BOOL         fAlways,
    DSNAME *     pdnNC
    )
{
    static DWORD  s_ulLastTickNoRefDomSet     = 0;
    const  DWORD  ulNoLogPeriod               = 300*1000; // 5 minutes
           DWORD  ulCurrentTick               = GetTickCount();
    
    if(((ulCurrentTick - s_ulLastTickNoRefDomSet) > ulNoLogPeriod) || fAlways){
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_NDNC_NO_REFERENCE_DOMAIN_SET, 
                 szInsertDN(pdnNC),
                 NULL, NULL);
        s_ulLastTickNoRefDomSet = ulCurrentTick;
    }

}

CROSS_REF *
GetDefaultSDRefDomCR(
    DSNAME *       pdnNC
    )
{
    CROSS_REF *    pCR = NULL;
    CROSS_REF *    pSDRefDomCR = NULL;
    COMMARG        CommArg;
    DSNAME *       pdnParentNC = NULL;

    Assert(DsaIsRunning());
    Assert(!DsaIsInstalling());
    Assert(pTHStls);

    // Trim one DN off the NC to get the parent NC
    pdnParentNC = (DSNAME*)THAllocEx(pTHStls, pdnNC->structLen);
    TrimDSNameBy(pdnNC, 1, pdnParentNC);

    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    // ISSUE-2002/03/14-BrettSh So FindExactCrossRef() is not guaranteed 
    // to "work", so we have a problem here.  We should use 
    // EnumerateCrossRefs() to guarantee if there is a parent crossRef 
    // that we get it, because otherwise if crossRef cache inconsistency
    // happens, we'll end up using the root crossRef rather than the 
    // parent.
    pCR = FindExactCrossRef(pdnParentNC, &CommArg);

    if(pCR){
        
        // Use the domain or SDRefDom of the parent.

        // We can't have the parent be a config/schema NC.
        Assert(!NameMatched(pCR->pNC, gAnchor.pConfigDN) &&
               !NameMatched(pCR->pNC, gAnchor.pDMD));

        if(pCR->flags & FLAG_CR_NTDS_DOMAIN){

            // This is the 1st (of 3) successful exit paths.
            return(pCR);

        } else {

            if(pCR->pdnSDRefDom){

                InitCommarg(&CommArg);
                CommArg.Svccntl.dontUseCopy = FALSE;
                pSDRefDomCR = FindExactCrossRef(pCR->pdnSDRefDom, &CommArg);
                
                if(pSDRefDomCR){

                    // This is the 2nd successful potential exit path.
                    return(pSDRefDomCR);

                }

            }

            // Failure exit point
            // else just log an event and return NULL.
            SometimesLogEvent(DIRLOG_NDNC_NO_REFERENCE_DOMAIN_SET, TRUE,
                              pCR->pNC);
            return(NULL);

        }

    }

    // 3rd and final successful exit point
    //
    // Presume NDNC is it's own rooted tree, use the root domain.
    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(gAnchor.pRootDomainDN, &CommArg);
    Assert(pCR); // Huh!  We can't even find the root domain crossref.
    return(pCR); 

}

PSID
GetSDRefDomSid(
    CROSS_REF *    pCR
    )
{
    PSID           pSid = NULL;
    CROSS_REF *    pSDRefDomCR = NULL;
    COMMARG        CommArg;

    Assert(pCR);    
    Assert(pCR->flags & FLAG_CR_NTDS_NC); // Don't add object not in our NCs.
 
    // This code does not yet handle non-NDNC queries.  In Blackcomb, this
    // function could be made to hand back the SID of the domain to 
    // implement multiple domains.
    if(!fIsNDNCCR(pCR)){
        Assert(!"This func wasn't intended to be used for domains/config/schema NCs.");
        SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
        return(NULL);
    }

    // This line is very important due to the semantics of how this variable
    // can be erased at any moment, though the data will remain valid for an
    // hour.
    pSid = pCR->pSDRefDomSid;

    if(pSid){
        // Yeah!!! The SID is cached, nothing to do but return it.
        Assert(IsValidSid(pSid));
        return(pSid);
    }

    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {
        pSid = pCR->pSDRefDomSid;
        if(pSid){
            Assert(IsValidSid(pSid));
            // WOW, this varibale got updated in a very narrow window.
            __leave; // Our work here is done.
        }

        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        
        if(pCR->pdnSDRefDom &&
           (NULL != (pSDRefDomCR = FindExactCrossRef(pCR->pdnSDRefDom, &CommArg))) &&
           pSDRefDomCR->pNC->SidLen > 0){
            
            // Update the cache.
            pCR->pSDRefDomSid = &pSDRefDomCR->pNC->Sid;
            pSid = pCR->pSDRefDomSid;
            Assert(pSid && IsValidSid(pSid));

        } else {

            // No valid reference domain, log event and fall through and
            // fail below.
            SometimesLogEvent(DIRLOG_NDNC_NO_REFERENCE_DOMAIN_SET, FALSE,
                              pCR->pNC);

        }
    
    } __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }
    
    if(!pSid){

        // If we got here, then there was an error above, and the administrator
        // will need to either to retry because the cache was out of sync, or
        // reset the SD reference domain to a valid value.
        LooseAssert(!"This could happen legitimately, but it's very very unlikely, so "
                     "check with DsRepl.", GlobalKnowledgeCommitDelay);
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    ERROR_DS_NO_REF_DOMAIN);
        return(NULL);

    }

    Assert(pSid && IsValidSid(pSid));
    return(pSid);
}





#define DEFAULT_DELETED_OBJECTS_RDN    L"Deleted Objects"
#define DEFAULT_LOSTANDFOUND_RDN    L"LostAndFound"
#define DEFAULT_INFRASTRUCTURE_RDN    L"Infrastructure"
#define DEFAULT_NTDS_QUOTAS_RDN       L"NTDS Quotas"


VOID    
SetAttSecurityDescriptor(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    PSID                  pDomainSid,
    WCHAR *               wcszStrSD
    )
{
    BOOL                  bRet;
    ULONG                 ulErr;
    SECURITY_DESCRIPTOR * pSD = 0;
    ULONG                 cSD = 0;

    // This is a special version of ConvertStringSDToSD() that takes a domain
    // argument too.
    bRet = ConvertStringSDToSDDomainW(pDomainSid,
                                      NULL,
                                      wcszStrSD,
                                      SDDL_REVISION_1,
                                      &pSD,
                                      &cSD);
    
    if(!bRet){
        // Two options, the programmer supplied arguments were bad, or 
        // there was an allocation error, we'll presume the later and 
        // raise an exception
#if DBG
        ulErr = GetLastError();
        if(ulErr != ERROR_NOT_ENOUGH_MEMORY){
            DPRINT1(0, "ConvertStringSecurityDescriptorToSecurityDescriptorW() failed with %d\n", ulErr);
            Assert(!"Note this assert should ONLY fire if there is no more memory. "
                    " This function is not meant for user specified SD strings, only "
                    "programmer (and thus flawless ;) SD strings.");
        }
#endif
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0, 0, 
                       ((FILENO << 16) | __LINE__), 
                       DS_EVENT_SEV_MINIMAL);
    }
    
    Assert(pSD);
    Assert(cSD);

    // Note: we reallocate the pSD into thread allocated memory, because 
    // CheckAddSecurity or someone under it assumes that it's THAlloc'd
    pAttr->attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = cSD;
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, cSD);
    memcpy (pAttr->AttrVal.pAVal[0].pVal, pSD, cSD);
    (*piAttr)++;

    LocalFree(pSD);
}

VOID
SetAttSingleValueUlong(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    ULONG                 ulAttData
    )
{
    pAttr->attrTyp = ulAttType;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, sizeof(ULONG));
    *((ULONG *)pAttr->AttrVal.pAVal[0].pVal) = ulAttData;
    (*piAttr)++;
}

VOID
SetAttSingleValueDsname(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    DSNAME *              pDsname
    )
{
    pAttr->attrTyp = ulAttType;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = pDsname->structLen;
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, pAttr->AttrVal.pAVal[0].valLen);
    memcpy((WCHAR *) pAttr->AttrVal.pAVal[0].pVal, pDsname, pDsname->structLen);
    (*piAttr)++;

}

VOID
SetAttSingleValueString(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    WCHAR *               wcszAttData
    )
{
    // Note that strings are stored w/o NULLs in the directory.
    pAttr->attrTyp = ulAttType;
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = THAllocEx(pTHS, pAttr->AttrVal.valCount * sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = wcslen(wcszAttData) * sizeof(WCHAR);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, pAttr->AttrVal.pAVal[0].valLen);
    memcpy((WCHAR *) pAttr->AttrVal.pAVal[0].pVal, 
           wcszAttData, 
           pAttr->AttrVal.pAVal[0].valLen);
    (*piAttr)++;

}

VOID
SetCommonThreeAttrs(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulClassId
    )
{

    // Set the objectClass attribute.
    SetAttSingleValueUlong(pTHS,
                           &(pAttr[*piAttr]),
                           piAttr,
                           ATT_OBJECT_CLASS,
                           ulClassId);

    // Set the isCriticalSystemObject attribute
    SetAttSingleValueUlong(pTHS,
                           &(pAttr[*piAttr]),
                           piAttr,
                           ATT_IS_CRITICAL_SYSTEM_OBJECT,
                           TRUE);
    
    // Set the systemFlags attribute
    SetAttSingleValueUlong(pTHS,
                           &(pAttr[*piAttr]),
                           piAttr,
                           ATT_SYSTEM_FLAGS,
                           (FLAG_DOMAIN_DISALLOW_RENAME |
                            FLAG_DOMAIN_DISALLOW_MOVE |
                            FLAG_DISALLOW_DELETE));
}

VOID
FillDeletedObjectsAttrArray(
    THSTATE *               pTHS,
    ATTRBLOCK *             pAttrBlock,
    PSID                    pDomainSid
    )
{
    ULONG                   iAttr = 0;

    // [Deleted Objects]
    // ; NOTE: This section is used for three objects, the Deleted Objects container
    // ; in Root Domain NC and the deleted objects container in the Config NC.
    // nTSecurityDescriptor=O:SYG:SYD:P(A;;RPWPCCDCLCSWRCWDWOSD;;;SY)(A;;RPLC;;;BA)S:P(AU;SAFA;RPWPCCDCLCSWRCWDWOSD;;;WD) 
    // objectClass =container
    // ObjectCategory =container
    // description=Default container for deleted objects
    // showInAdvancedViewOnly=True
    // isDeleted=True
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000
    
    pAttrBlock->attrCount = 6;
    pAttrBlock->pAttr = THAllocEx(pTHS, 
                 pAttrBlock->attrCount * sizeof(ATTR));

        // --------------------------
        SetCommonThreeAttrs(pTHS,
                    &(pAttrBlock->pAttr[iAttr]),
                    &iAttr,
                    CLASS_CONTAINER);
        SetAttSingleValueString(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_COMMON_NAME,
                                DEFAULT_DELETED_OBJECTS_RDN);
        SetAttSecurityDescriptor(pTHS,
                                 &(pAttrBlock->pAttr[iAttr]),
                                 &iAttr,
                                 pDomainSid,
                                 L"O:SYG:SYD:P(A;;RPWPCCDCLCSWRCWDWOSD;;;SY)(A;;RPLC;;;BA)S:P(AU;SAFA;RPWPCCDCLCSWRCWDWOSD;;;WD)");
        SetAttSingleValueUlong(pTHS,
                               &(pAttrBlock->pAttr[iAttr]),
                               &iAttr,
                               ATT_IS_DELETED,
                               TRUE);

    Assert(iAttr == pAttrBlock->attrCount);
}

VOID
FillLostAndFoundAttrArray(
    THSTATE *             pTHS,
    ATTRBLOCK *           pAttrBlock,
    PSID                  pDomainSid
    )
{
    ULONG                   iAttr = 0;

    // [LostAndFound]
    // nTSecurityDescriptor=O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)
    // objectClass =lostAndFound
    // ObjectCategory =Lost-And-Found
    // description=Default container for orphaned objects
    // showInAdvancedViewOnly=True
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000

    pAttrBlock->attrCount = 5;
    pAttrBlock->pAttr = THAllocEx(pTHS, 
                 pAttrBlock->attrCount * sizeof(ATTR));
    
        // --------------------------
        SetCommonThreeAttrs(pTHS,
                            &(pAttrBlock->pAttr[iAttr]),
                            &iAttr,
                            CLASS_LOST_AND_FOUND);
        SetAttSingleValueString(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_COMMON_NAME,
                                DEFAULT_LOSTANDFOUND_RDN);
        SetAttSecurityDescriptor(pTHS,
                         &(pAttrBlock->pAttr[iAttr]),
                         &iAttr,
                         pDomainSid,
                         L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)");



    Assert(iAttr == pAttrBlock->attrCount);

}

VOID
FillInfrastructureAttrArray(
    THSTATE *             pTHS,
    ATTRBLOCK *           pAttrBlock,
    DSNAME *              pdsFsmo,
    PSID                  pDomainSid
    )
{
    ULONG                 iAttr = 0;
    
    // This is the Attr Block we are trying to achieve.
    // [Infrastructure]
    // nTSecurityDescriptor=O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)
    // objectClass =infrastructureUpdate
    // ObjectCategory =Infrastructure-Update
    // ShowInAdvancedViewOnly=True
    // fSMORoleOwner=$REGISTRY=Machine DN Name
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000

    // ---------------------------------
    pAttrBlock->attrCount = 6;
    pAttrBlock->pAttr = THAllocEx(pTHS, 
                 pAttrBlock->attrCount * sizeof(ATTR));
    
        // --------------------------
        SetCommonThreeAttrs(pTHS,
                            &(pAttrBlock->pAttr[iAttr]),
                            &iAttr,
                            CLASS_INFRASTRUCTURE_UPDATE);
        SetAttSingleValueString(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_COMMON_NAME,
                                DEFAULT_INFRASTRUCTURE_RDN);
        SetAttSingleValueDsname(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_FSMO_ROLE_OWNER,
                                pdsFsmo);
        SetAttSecurityDescriptor(pTHS,
                         &(pAttrBlock->pAttr[iAttr]),
                         &iAttr,
                         pDomainSid,
                         L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)");

    Assert(iAttr == pAttrBlock->attrCount);
}

VOID
FillQuotasAttrArray(
    THSTATE *             pTHS,
    ATTRBLOCK *           pAttrBlock,
    DSNAME *              pds,
    PSID                  pDomainSid
    )
{
    ULONG                 iAttr = 0;
    
    // This is the Attr Block we are trying to achieve.
    // [Quotas]
    // nTSecurityDescriptor=O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)
    // objectClass =quotas
    // ObjectCategory =Quotas
    // ShowInAdvancedViewOnly=True
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000

    // ---------------------------------
    pAttrBlock->attrCount = 5;
    pAttrBlock->pAttr = THAllocEx( pTHS, pAttrBlock->attrCount * sizeof(ATTR) );
   
        // --------------------------
        SetCommonThreeAttrs(pTHS,
                            &(pAttrBlock->pAttr[iAttr]),
                            &iAttr,
                            CLASS_MS_DS_QUOTA_CONTAINER);
        SetAttSingleValueString(pTHS,
                                &(pAttrBlock->pAttr[iAttr]),
                                &iAttr,
                                ATT_COMMON_NAME,
                                DEFAULT_NTDS_QUOTAS_RDN);
        SetAttSecurityDescriptor(pTHS,
                         &(pAttrBlock->pAttr[iAttr]),
                         &iAttr,
                         pDomainSid,
                         L"O:DAG:DAD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPLCLORC;;;BA)(OA;;CR;4ecc03fe-ffc0-4947-b630-eb672a8a9dbc;;WD)S:(AU;CISA;WDWOSDDTWPCRCCDCSW;;;WD)");

    Assert(iAttr == pAttrBlock->attrCount);
}

ULONG
AddSpecialNCContainers(
    THSTATE *               pTHS,
    DSNAME *                pDN,
    CROSS_REF *             pSDRefDomCR
    )
{
    ADDARG                  AddArg;
    ADDRES                  AddRes;
    DSNAME *                pContainerDN = NULL;
    DWORD                   dwFlags = ( NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED );
    INT                     iRetLen;
    BOOL                    fDSASaved;
    DWORD                   dwRet;

    // Given the pDN we will call LocalAdd() to add each of the 4 special 
    // containers: Deleted Objects, LostAndFound, Infrastructure, and NTDS Quotas.
          
    // [DEFAULTROOTDOMAIN]
    // objectClass = DomainDNS
    // objectCategory = Domain-DNS
    // NTSecurityDescriptor=O:DAG:DAD:(A;;RP;;;WD)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;BA)(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;CI;RPWPCRLCLOCCRCWDWOSDSW;;;BA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;EA)(A;CI;LC;;;RU)(OA;CIIO;RP;037088f8-0ae1-11d2-b422-00a0c968f939;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;4c164200-20c0-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RPLCLORC;;bf967a9c-0de6-11d0-a285-00aa003049e2;RU)(A;;RC;;;RU)(OA;CIIO;RPLCLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)S:(AU;CISAFA;WDWOSDDTWPCRCCDCSW;;;WD)
    // auditingPolicy=\x0001
    // nTMixedDomain=1
    // ;Its a NC ROOT
    // instanceType=5
    // ;Its the PDC, set FSMO role owner
    // fSMORoleOwner=$REGISTRY=Machine DN Name
    // wellKnownObjects=$EMBEDDED:32:ab8153b7768811d1aded00c04fd8d5cd:cn=LostAndFound,<Root Domain
    // wellKnownObjects=$EMBEDDED:32:2fbac1870ade11d297c400c04fd8d5cd:cn=Infrastructure,<Root Domain
    // wellKnownObjects=$EMBEDDED:32:18e2ea80684f11d2b9aa00c04f79f805:cn=Deleted Objects,<Root Domain
    // wellKnownObjects=$EMBEDDED:32:6227f0af1fc2410d8e3bb10615bb5b0f:CN=NTDS Quotas,<Root Domain
    // gPLink=$REGISTRY=GPODomainLink
    // mS-DS-MachineAccountQuota=10
    // isCriticalSystemObject=True
    // ;systemFlags=FLAG_CONFIG_DISALLOW_RENAME        |
    // ;             FLAG_CONFIG_DISALLOW_MOVE         |
    // ;             FLAG_DISALLOW_DELETE
    // systemFlags=0x8C000000
    
    Assert(pTHS->errCode == ERROR_SUCCESS);
    Assert(pSDRefDomCR && pSDRefDomCR->pNC);
    Assert(pSDRefDomCR->pNC->SidLen > 0 && IsValidSid(&pSDRefDomCR->pNC->Sid));

    fDSASaved = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    __try {
        // ----------------------------------------------
        // Create AddArg for "Deleted Objects" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        iRetLen = pDN->structLen + wcslen(DEFAULT_DELETED_OBJECTS_RDN) * sizeof(WCHAR) + 50;
        AddArg.pObject = THAllocEx(pTHS, iRetLen);
        iRetLen = AppendRDN(pDN, AddArg.pObject, iRetLen, DEFAULT_DELETED_OBJECTS_RDN, 0, ATT_COMMON_NAME);
        Assert(iRetLen == 0);
        // Set AttrBlock
        FillDeletedObjectsAttrArray(pTHS, &(AddArg.AttrBlock), &pSDRefDomCR->pNC->Sid );
        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        // Do the Add object.
        if(DoNameRes(pTHS, dwFlags, pDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent) ){
            Assert(pTHS->errCode);
            __leave;
        }

        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            __leave;
        }

        // One more thing to do, set the delete time _way_ in the future.
        dwRet = DBMoveObjectDeletionTimeToInfinite(AddArg.pObject);
        if(dwRet){
            SetSvcError(SV_PROBLEM_UNAVAILABLE, dwRet);
        }
         
        // ----------------------------------------------
        // Create AddArg for "LostAndFound" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        iRetLen = pDN->structLen + wcslen(DEFAULT_LOSTANDFOUND_RDN) * sizeof(WCHAR) + 50;
        AddArg.pObject = THAllocEx(pTHS, iRetLen);
        iRetLen = AppendRDN(pDN, AddArg.pObject, iRetLen, DEFAULT_LOSTANDFOUND_RDN, 0, ATT_COMMON_NAME);
        Assert(iRetLen == 0);
        // Set AttrBlock
        FillLostAndFoundAttrArray(pTHS, &(AddArg.AttrBlock), &pSDRefDomCR->pNC->Sid);
        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        // Do the Add object.
        if(DoNameRes(pTHS, dwFlags, pDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent)){
            Assert(pTHS->errCode);
            __leave;
        }
        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            __leave;
        }

        // ----------------------------------------------
        // Create AddArg for "Infrastructure" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        iRetLen = pDN->structLen + wcslen(DEFAULT_INFRASTRUCTURE_RDN) * sizeof(WCHAR) + 50;
        AddArg.pObject = THAllocEx(pTHS, iRetLen);
        iRetLen = AppendRDN(pDN, AddArg.pObject, iRetLen, DEFAULT_INFRASTRUCTURE_RDN, 0, ATT_COMMON_NAME);
        Assert(iRetLen == 0);
        // Set AttrBlock
        FillInfrastructureAttrArray(pTHS, &(AddArg.AttrBlock), gAnchor.pDSADN, &pSDRefDomCR->pNC->Sid);
        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        // Do the Add object.
        if(DoNameRes(pTHS, dwFlags, pDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent)){
            Assert(pTHS->errCode);
            __leave;
        }
        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            __leave;
        }


        // ----------------------------------------------
        // Create AddArg for "NTDS Quotas" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        iRetLen = pDN->structLen + wcslen(DEFAULT_NTDS_QUOTAS_RDN) * sizeof(WCHAR) + 50;
        AddArg.pObject = THAllocEx(pTHS, iRetLen);
        iRetLen = AppendRDN(pDN, AddArg.pObject, iRetLen, DEFAULT_NTDS_QUOTAS_RDN, 0, ATT_COMMON_NAME);
        Assert(iRetLen == 0);
        // Set AttrBlock
        FillQuotasAttrArray( pTHS, &(AddArg.AttrBlock), gAnchor.pDSADN, &pSDRefDomCR->pNC->Sid );

        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        // Do the Add object.
        if(DoNameRes(pTHS, dwFlags, pDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent)){
            Assert(pTHS->errCode);
            __leave;
        }
        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            __leave;
        }
 

    } __finally {

        pTHS->fDSA = fDSASaved;

    }
    
    return(pTHS->errCode);
}

BOOL
AddNCWellKnownObjectsAtt(
    THSTATE *       pTHS,
    ADDARG *        pAddArg
    )
{
    ULONG           i;
    ULONG           cAttr, cAttrVal;
    ATTRVAL *       pNewAttrVal;
    INT             cRetLen;
    ULONG           cLen;
    SYNTAX_DISTNAME_BINARY *  pSynDistName;
    DSNAME *                  pDN = NULL;
    GUID                      guid = {0, 0, 0, 0};
    SYNTAX_ADDRESS *          pSynAddr;
    
    MODIFYARG                 ModArg;
    ATTRVAL                   AttrVals[4];
    COMMRES                   CommRes;
    ULONG                     ulRet;
    BOOL                      fDSASaved;

    // Need to massage add args to have additional containers for NC heads.
    
    Assert(pAddArg->pCreateNC);
    Assert(fISADDNDNC(pAddArg->pCreateNC)); // This may need
    // to be taken out if we do the special containers for other NCs here.

    memset(&ModArg, 0, sizeof(ModArg));
    ModArg.pObject = pAddArg->pObject;
    ModArg.count = 1;
    InitCommarg(&ModArg.CommArg);
    ModArg.FirstMod.choice = AT_CHOICE_ADD_ATT;
    ModArg.FirstMod.AttrInf.attrTyp = ATT_WELL_KNOWN_OBJECTS;
    ModArg.FirstMod.AttrInf.AttrVal.valCount = 4;
    ModArg.FirstMod.AttrInf.AttrVal.pAVal = AttrVals;
    ModArg.FirstMod.pNextMod = NULL;
    
    cAttrVal = 0;

    // ----------------------------------------------
    // Constructe WellKnownLink for deleted Objects
    // Get DN
    cRetLen = pAddArg->pObject->structLen + wcslen(DEFAULT_DELETED_OBJECTS_RDN) + 50;
    pDN = THAllocEx(pTHS, cRetLen);
    cRetLen = AppendRDN(pAddArg->pObject, pDN, cRetLen, DEFAULT_DELETED_OBJECTS_RDN, 0, ATT_COMMON_NAME);
    Assert(cRetLen == 0);
    
    // Get binary GUID
    pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
    pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
    memcpy(pSynAddr->byteVal, GUID_DELETED_OBJECTS_CONTAINER_BYTE, sizeof(GUID));

    // Set up the Syntax DistName Binary attribute.
    pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
    BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);

    // Free Temp variables
    THFree(pDN);
    pDN = NULL;
    THFree(pSynAddr);
    pSynAddr = NULL;

    // Put the syntax distname in the attribute value block.
    AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
    AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;
    
    cAttrVal++;

    // ----------------------------------------------
    // Constructe WellKnownLink for LostAndFound
    // Get DN
    cRetLen = pAddArg->pObject->structLen + wcslen(DEFAULT_LOSTANDFOUND_RDN) + 50;
    pDN = THAllocEx(pTHS, cRetLen);
    cRetLen = AppendRDN(pAddArg->pObject, pDN, cRetLen, DEFAULT_LOSTANDFOUND_RDN, 0, ATT_COMMON_NAME);
    Assert(cRetLen == 0);
    
    // Get binary GUID
    pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
    pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
    memcpy(pSynAddr->byteVal, GUID_LOSTANDFOUND_CONTAINER_BYTE, sizeof(GUID));

    // Set up the Syntax DistName Binary attribute.
    pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
    BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);

    // Free Temp variables
    THFree(pDN);
    pDN = NULL;
    THFree(pSynAddr);
    pSynAddr = NULL;

    AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
    AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;

    cAttrVal++;

    // ----------------------------------------------
    // Constructe WellKnownLink for Infrastructure Objects
    // Get DN
    cRetLen = pAddArg->pObject->structLen + wcslen(DEFAULT_INFRASTRUCTURE_RDN) + 50;
    pDN = THAllocEx(pTHS, cRetLen);
    cRetLen = AppendRDN(pAddArg->pObject, pDN, cRetLen, DEFAULT_INFRASTRUCTURE_RDN, 0, ATT_COMMON_NAME);
    Assert(cRetLen == 0);
    
    // Get binary GUID
    pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
    pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
    memcpy(pSynAddr->byteVal, GUID_INFRASTRUCTURE_CONTAINER_BYTE, sizeof(GUID));

    // Set up the Syntax DistName Binary attribute.
    pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
    BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);

    // Free Temp variables
    THFree(pDN);
    pDN = NULL;
    THFree(pSynAddr);
    pSynAddr = NULL;

    // Put the syntax distname in the attribute value block.
    AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
    AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;

    cAttrVal++;

    // ----------------------------------------------
    // Constructe WellKnownLink for NTDS quotas Objects
    // Get DN
    cRetLen = pAddArg->pObject->structLen + wcslen(DEFAULT_NTDS_QUOTAS_RDN) + 50;
    pDN = THAllocEx(pTHS, cRetLen);
    cRetLen = AppendRDN(pAddArg->pObject, pDN, cRetLen, DEFAULT_NTDS_QUOTAS_RDN, 0, ATT_COMMON_NAME);
    Assert(cRetLen == 0);
    
    // Get binary GUID
    pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
    pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
    memcpy(pSynAddr->byteVal, GUID_NTDS_QUOTAS_CONTAINER_BYTE, sizeof(GUID));

    // Set up the Syntax DistName Binary attribute.
    pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
    BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);

    // Free Temp variables
    THFree(pDN);
    pDN = NULL;
    THFree(pSynAddr);
    pSynAddr = NULL;

    // Put the syntax distname in the attribute value block.
    AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
    AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;

    cAttrVal++;


    ulRet = DoNameRes(pTHS, 0, ModArg.pObject, &ModArg.CommArg, &CommRes, &ModArg.pResObj);
    if(ulRet){
        return(ulRet);
    }
 
    __try{
        fDSASaved = pTHS->fDSA;
        pTHS->fDSA = TRUE;
        LocalModify(pTHS, &ModArg);
    } __finally {
        pTHS->fDSA = fDSASaved;
    }
    
    return(pTHS->errCode);
}

VOID
TestNDNCLocalAdd(
    THSTATE *       pTHS,
    ADDARG *        pAddArg,
    ADDRES *        pAddRes
    )
{
    return;
}

DSNAME *
GetPartitionsDn(
    THSTATE *         pTHS
    )
{
    ULONG             cbPDN = 0;
    DSNAME *          pdnPartitions = NULL;

    // Caller must have a valid THSTATE.
    Assert(pTHS); 
    Assert(gAnchor.pConfigDN);

    // First do a fake AppendRDN() to get the size.
    cbPDN = AppendRDN(gAnchor.pConfigDN, NULL, 0, 
                      L"Partitions", wcslen(L"Partitions"), ATT_COMMON_NAME);
    Assert(cbPDN != -1);

    // Now actually do the AppendRDN().
    pdnPartitions = THAllocEx(pTHS, cbPDN);
    cbPDN = AppendRDN(gAnchor.pConfigDN, pdnPartitions, cbPDN, 
                      L"Partitions", wcslen(L"Partitions"), ATT_COMMON_NAME);

    Assert(cbPDN == 0);

    Assert(pdnPartitions);
    return(pdnPartitions);
}

DWORD
GetCrossRefDn(
    THSTATE *         pTHS,
    PDSNAME           pdnNC,
    PDSNAME *         ppdnCR
    )
{
    DSNAME *          pdnPartitions = NULL;
    GUID              CrossRefGuid = { 0, 0, 0, 0 };
    WCHAR *           wszCrossRefGuid = NULL;
    DWORD             dwRet;
    ULONG             cbCR;



    __try{
        // Step 1: Get Partition's container DN.
        pdnPartitions = GetPartitionsDn(pTHS);

        // ----------------------------------------
        // Step 1: Need Guid.
        dwRet = UuidCreate(&CrossRefGuid);
        if(dwRet != RPC_S_OK){
            __leave;
        }

        // Step 2: Convert GUID to String.
        dwRet = UuidToStringW(&CrossRefGuid, &wszCrossRefGuid);
        if(dwRet != RPC_S_OK){
            __leave;
        }
        Assert(wszCrossRefGuid);

        // Step 3: Allocate space for the cross ref DN.
        cbCR = AppendRDN(pdnPartitions,          // Base
                         NULL, 0,                // New
                         wszCrossRefGuid, 0, ATT_COMMON_NAME);  // RDN
        Assert(cbCR != -1);
        *ppdnCR = THAllocEx(pTHS, cbCR);

        // Step 4: Append the Guid RDN to the Partitions DN.
        dwRet = AppendRDN(pdnPartitions,   // base
                          *ppdnCR, cbCR,      // new
                          wszCrossRefGuid, 0, ATT_COMMON_NAME);  // RDN

        Assert(dwRet == 0);

    } __finally {

        if(wszCrossRefGuid){ RpcStringFreeW(&wszCrossRefGuid); }
        if(pdnPartitions){ THFreeEx(pTHS, pdnPartitions); }

    }

    return(dwRet);
}

DWORD
CreateCrossRefForNDNC(
    THSTATE *         pTHS,
    DSNAME *          pdnNC,
    ENTINF *          peiCR
    )
{
    DWORD             ulRet = ERROR_SUCCESS;
    ULONG             iAttr = 0;
    WCHAR *           pwszArrStr[1];
    DS_NAME_RESULTW * pdsrDnsName = NULL;
    WCHAR *           wszDnsName = NULL;
    DSNAME *          pdnCrossRef;
                                
    Assert(peiCR); // Caller must supply memory for ENTINF, because
    // the first ENTINF is usually embedded in the ENTINFLIST ... but
    // we'll allocate everything else :)

    memset(peiCR, 0, sizeof(ENTINF));

    ulRet = GetCrossRefDn(pTHS, pdnNC, &pdnCrossRef);
    if(ulRet){
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ulRet);
        return(pTHS->errCode);
    }
    peiCR->pName = pdnCrossRef;
    peiCR->AttrBlock.attrCount = 5;
    peiCR->AttrBlock.pAttr = THAllocEx(pTHS, 
              peiCR->AttrBlock.attrCount * sizeof(ATTR));
    
    // Set the objectClass to crossRef.
    SetAttSingleValueUlong(pTHS,
                           &(peiCR->AttrBlock.pAttr[iAttr]), 
                           &iAttr, 
                           ATT_OBJECT_CLASS,
                           CLASS_CROSS_REF);
    // Disable the Cross-Ref, the creation of the NC Head will enable it.
    SetAttSingleValueUlong(pTHS, 
                           &(peiCR->AttrBlock.pAttr[iAttr]), 
                           &iAttr, 
                           ATT_ENABLED, 
                           FALSE);
    // Set the DNS Root attribute to this DSA's DNS name
    SetAttSingleValueString(pTHS, 
                            &(peiCR->AttrBlock.pAttr[iAttr]),
                            &iAttr, 
                            ATT_DNS_ROOT, 
                            gAnchor.pwszHostDnsName);
    // Set nCName to the NC Head DN.
    SetAttSingleValueDsname(pTHS,
                            &(peiCR->AttrBlock.pAttr[iAttr]),
                            &iAttr,
                            ATT_NC_NAME,
                            pdnNC);
    // Set the systemFlags.
    SetAttSingleValueUlong(pTHS,
                           &(peiCR->AttrBlock.pAttr[iAttr]),
                           &iAttr,
                           ATT_SYSTEM_FLAGS,
                           FLAG_CR_NTDS_NC | FLAG_CR_NTDS_NOT_GC_REPLICATED);

    // This is no longer needed, but we're going to do it anyway because
    // it does advanced error checking, because it's better to fail now
    // then after creating the crossRef.
    pwszArrStr[0] = pdnNC->StringName;
    ulRet = DsCrackNamesW(NULL,
                          DS_NAME_FLAG_SYNTACTICAL_ONLY,
                          DS_FQDN_1779_NAME,
                          DS_CANONICAL_NAME,
                          1,
                          pwszArrStr,
                          &pdsrDnsName);
    Assert(ulRet != ERROR_INVALID_PARAMETER || pdnNC->NameLen == 0);
    if(ulRet){     
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ulRet);
        return(pTHS->errCode);
    }
    __try {
        Assert(pdsrDnsName);
        Assert(pdsrDnsName->cItems == 1);
        Assert(pdsrDnsName->rItems != NULL);
        if(pdsrDnsName->rItems[0].status != DS_NAME_NO_ERROR){
            SetNamError(NA_PROBLEM_BAD_NAME,
                        pdnNC,
                        DIRERR_BAD_NAME_SYNTAX);
            __leave;
        }
        Assert(pdsrDnsName->rItems[0].pDomain);
    } __finally {
          DsFreeNameResultW(pdsrDnsName);
    }

    Assert(pTHS->errCode != 0 || iAttr == peiCR->AttrBlock.attrCount);

    return(pTHS->errCode);
}

DWORD
GetFsmoNtdsa(
    IN     THSTATE *           pTHS,
    IN     DSNAME *            pdnFsmoContainer,
    OUT    DSNAME **           pdnFsmoNtdsa,
    OUT    BOOL *              pfRemoteFsmo
    )

// This needs to work for install too.  In theory though not tested, this
// should work for any FSMO holder if you just pass the right pdnFsmoContainer.

{
    READARG           ReadArg;
    READRES *         pReadRes;
    ENTINFSEL         EIS;
    ATTR              Attr;
    ULONG             i;
    DSNAME *          pMasterDN = NULL;
    DWORD             dwRet;

    Assert(pdnFsmoNtdsa || pfRemoteFsmo);

    memset(&ReadArg, 0, sizeof(READARG));
    ReadArg.pObject = pdnFsmoContainer;
    ReadArg.pSel = &EIS;
    InitCommarg(&ReadArg.CommArg);
    ReadArg.CommArg.Svccntl.dontUseCopy = FALSE;
    EIS.attSel = EN_ATTSET_LIST;
    EIS.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EIS.AttrTypBlock.attrCount = 1;
    EIS.AttrTypBlock.pAttr = &Attr;
    Attr.attrTyp = ATT_FSMO_ROLE_OWNER;
    Attr.AttrVal.valCount = 0;
    Attr.AttrVal.pAVal = NULL;

    dwRet = DirRead(&ReadArg, &pReadRes);
    
    if(dwRet){
        DPRINT1(3, "DirRead returned unexpected error %d.\n", dwRet);
        return(dwRet);
    }

    for (i=0; i < pReadRes->entry.AttrBlock.attrCount; i++) {
        if (ATT_FSMO_ROLE_OWNER ==
            pReadRes->entry.AttrBlock.pAttr[i].attrTyp) {
            pMasterDN =
              (DSNAME*) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
            break;
        }
    }

    Assert(pMasterDN);
    Assert(gAnchor.pDSADN);
    if(pfRemoteFsmo){
        *pfRemoteFsmo = !NameMatched(pMasterDN, gAnchor.pDSADN);
    }

    if(!pdnFsmoNtdsa){
        // The caller only wanted to know whether the FSMO was local or remote.
        return(ERROR_SUCCESS);
    }

    *pdnFsmoNtdsa = pMasterDN;

    return(ERROR_SUCCESS);
}

void
LogRemoteAdd(
    BOOL        fRemoteDc,
    LPWSTR      wszDcDns,
    DSNAME *    pdnObjDn,
    THSTATE *   pTHS,
    GUID *      pObjGuid,
    DWORD       dwDSID
    )
/*

Description:
    
    This logs an event for the all new NC creation code, for
    the result of a RemoteAddObjectSimply() call.
    
Arguments:

    fRemoteDc (IN) - Whether the Domain Naming FSMO was local or remote.
    wszDcDns (IN) - DNS of the remote DC/Domain Naming FSMO.
    pdnObjDn (IN) - DN of the first object we tried to add, note
        you can add multiple objects, but we don't bother logging
        those.
    pTHS (IN) - Just used to crack the Thread state error errCode/pErrInfo
    pObjGuid (IN) - Returned GUID of the object we created for the success case.
    dwDSID (IN) - Tells us where we logged this event from.

*/
{
    GUID   Dummy = {0, 0, 0, 0};

    Assert(wszDcDns);

    if (pObjGuid == NULL) {
        pObjGuid = &Dummy;
    }

    if (!fRemoteDc) {
        wszDcDns = L"";
    }

    if (pTHS->errCode == 0) {
        // Success log level 3

        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_EXTENSIVE,
                  DIRLOG_REMOTE_ADD_SUCCESS_INFO,
                  szInsertUL(fRemoteDc),
                  szInsertSz(wszDcDns),
                  szInsertDN(pdnObjDn),
                  szInsertUUID(pObjGuid),
                  szInsertDSID(dwDSID),
                  NULL, NULL, NULL);

    } else {
        // Some kind of error log level 0

        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_REMOTE_ADD_FAILURE_INFO,
                  szInsertSz(wszDcDns),
                  szInsertDN(pdnObjDn),
                  szInsertUUID(pObjGuid),
                  szInsertUL(pTHS->errCode),
                  szInsertWin32Msg(Win32ErrorFromPTHS(pTHS)),
                  szInsertUL(GetTHErrorExtData(pTHS)),
                  szInsertDSID(GetTHErrorDSID(pTHS)),
                  szInsertDSID(dwDSID));

    }

}


DWORD
GetCrossRefForNDNC(
    THSTATE *      pTHS,
    DSNAME *       pNCDN
    )
//
// Create Cross-Ref object corresponding to the domain we're now adding to the
// pre-existing DS enterprise.  Presumed to happen outside of a transaction.
//
{
    DSNAME *                pdnPartitions = NULL;
    DSNAME *                pdnGuidOnlyCrossRef = NULL;
    ULONG                   cbSize;
    DWORD                   ulRet = ERROR_SUCCESS;
    ENTINFLIST              entinflistCrossRef;
    ADDENTRY_REPLY_INFO *   infoList = NULL;
    DSNAME *                pdnFsmoNtdsa = NULL;
    WCHAR *                 wszNamingFsmoDns = NULL;
    SecBuffer               secBuffer = { 0, SECBUFFER_TOKEN, NULL };
    SecBufferDesc           clientCreds = { SECBUFFER_VERSION, 1, &secBuffer };
    BOOL                    fRemoteNamingFsmo = TRUE;
    ULONG                   cReferralTries = 0;

   
    // This is the remote CR creation code.
                                            
    Assert(fNullUuid(&pNCDN->Guid));

    //
    // Create CR EntInf
    //
                                            
    ulRet = CreateCrossRefForNDNC(pTHS, 
                                  pNCDN, 
                                  &(entinflistCrossRef.Entinf));
    entinflistCrossRef.pNextEntInf = NULL;
    if(ulRet){
        Assert(pTHS->errCode);
        return(ulRet);
    }

    //
    // Get Naming FSMO NTDSA DN & DNS address.
    //
    
    pdnPartitions = (DSNAME*)THAllocEx(pTHS,
                                entinflistCrossRef.Entinf.pName->structLen);
    TrimDSNameBy(entinflistCrossRef.Entinf.pName, 1, pdnPartitions);

    ulRet = GetFsmoNtdsa(pTHS, 
                         pdnPartitions,
                         &pdnFsmoNtdsa,
                         &fRemoteNamingFsmo);
    if(ulRet){
        Assert(pTHS->errCode);
        return(ulRet);
    }

    wszNamingFsmoDns = GuidBasedDNSNameFromDSName(pdnFsmoNtdsa);
    if (wszNamingFsmoDns == NULL) {
        // Most likely there is no memory.
        SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE, DS_ERR_DRA_INTERNAL_ERROR, ERROR_NOT_ENOUGH_MEMORY);
        return(pTHS->errCode);
    }


    //
    // Add remotely.
    //

  retry:

    // If this DC is in the middle of being demoted, we don't allow
    // crossRefs to be created.
    if (!gUpdatesEnabled) {
        return(SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN));
    }

    // First package up the credentials of this client.
    ulRet = GetRemoteAddCredentials(pTHStls,
                                    wszNamingFsmoDns,
                                    &clientCreds);
    if(ulRet){
        Assert(pTHS->errCode);
        return(ulRet);
    }

    ulRet = RemoteAddOneObjectSimply(wszNamingFsmoDns, 
                                     &clientCreds,
                                     &entinflistCrossRef,
                                     &infoList );

    LogRemoteAdd(fRemoteNamingFsmo,
                 wszNamingFsmoDns,
                 entinflistCrossRef.Entinf.pName,
                 pTHS, // Error state
                 (infoList) ? &(infoList[0].objGuid) : NULL,
                 DSID(FILENO, __LINE__));

    if(ulRet || pTHS->errCode){
        
        // We'll have the thread error (pTHS->errCode & pTHS->pErrInfo)
        // set from the RemoteAddOneObjectSimply() function
        Assert(pTHS->errCode == ulRet);
        Assert(pTHS->pErrInfo);

        if(infoList && 
           !fNullUuid(&(infoList[0].objGuid)) &&
           pTHS->errCode == serviceError &&
           pTHS->pErrInfo->SvcErr.extendedErr == ERROR_DS_REMOTE_CROSSREF_OP_FAILED &&
           (pTHS->pErrInfo->SvcErr.extendedData == ERROR_DUP_DOMAINNAME ||
            pTHS->pErrInfo->SvcErr.extendedData == ERROR_DS_CROSS_REF_EXISTS)
           ){

            // This means the cross-ref that we tried to create, conflicted
            // with an existing pre-created (as opposed to auto-created)
            // crossref, that hasn't yet replicated to this machine yet.  So
            // we'll clear the errors and pretend that we auto created the 
            // cross-ref and replicate it in.

            // Must construct a GUID only DN for replicating the found
            // GUID back.
            cbSize = DSNameSizeFromLen(0);
            pdnGuidOnlyCrossRef = THAllocEx(pTHS, cbSize);
            pdnGuidOnlyCrossRef->structLen = cbSize;
            pdnGuidOnlyCrossRef->Guid = infoList[0].objGuid;
            ulRet = 0;
            THClearErrors();

        } else if (pTHS->errCode == referralError){

            // No path here leads down to then end of this if/else, so free
            // the creds buffers now.
            FreeRemoteAddCredentials(&clientCreds);
            
            // We've got a referral, so we can pretend we knew the right DC
            // to goto anyway, and just go to that DC now.
            if (pTHS->pErrInfo && 
                pTHS->pErrInfo->RefErr.Refer.pDAL &&
                pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Buffer) {

                // FSMO chasing code
                wszNamingFsmoDns = THAllocEx(pTHS, 
                        pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Length + sizeof(WCHAR));
                memcpy(wszNamingFsmoDns,
                       pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Buffer,
                       pTHS->pErrInfo->RefErr.Refer.pDAL->Address.Length);

                // Now we need to reverse this, and get the NTDSA object
                // from a GUID based server DNS name.
                THFreeEx(pTHS, pdnFsmoNtdsa);
                pdnFsmoNtdsa = NULL;
                pdnFsmoNtdsa = DSNameFromAddr(pTHS, wszNamingFsmoDns);
                // I put in a single debugger print, because this code is 
                // called so infrequently and if I ever have to debug this
                // scenario, I want to know it was callled and how it did.
                DPRINT2(0, "FSMO Chasing code invoked: DNS: %ws DSA: %ws\n",
                        wszNamingFsmoDns, (pdnFsmoNtdsa) ? 
                                                pdnFsmoNtdsa->StringName :
                                                L"not returned");
                if (pdnFsmoNtdsa != NULL) {
                    // Make sure the DS didn't decide to shutdown on us while we were,
                    // gone, and if not continue on a retry against the new FSMO.
                    if (eServiceShutdown) {
                        return(ErrorOnShutdown());
                    }
                    // Don't know if we've got a remote naming FSMO, but just to
                    // be safe, we'll specify to pretend it's remote.
                    fRemoteNamingFsmo = TRUE;
                    // FUTURE-2002/03/28-BrettSh Occured to me that this 
                    // NameMatched(pdnFsmoNtdsa, gAnchor.pDSADN) should tell us
                    // whether we have a remote naming fsmo or not!  Lets leave
                    // it safe for now.  Who cares if we really sync with 
                    // ourselves.
                    THClearErrors();
                    cReferralTries++;
                    if (cReferralTries > 4) {
                        Assert(!"Wow, really!?  This means that we've tried this operation"
                               ", and been referred 4 times to a different source.  This "
                               "seems unlikely, unless you're running FSMO stress.");
                        SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
                        return(pTHS->errCode);
                    }
                    goto retry;
                }

                // Couldn't get the new FSMO's NTDSA object, must bail
                // with existing error.

                DPRINT(2, "FSMO Chasing code failure from DSNameFromAddr\n");

                Assert(pTHS->errCode);
                return(pTHS->errCode);

            } else {

                Assert(!"Something wrong with the thread referral error state.");
                Assert(pTHS->errCode);
                // Don't THClearErrors(), the thread error state is invalid 
                // anyway, this means there is a bug in RemoteAddOneObjectSimply()
                // or IDL_DRSAddEntry() or one of the thread error setting
                // routines called by those functions.  Anyway, to recover
                // just set a fresh error, which will whack the existing thread
                // error and replace it.
                SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
                return(pTHS->errCode);
            }
            Assert(!"Never here! Otherwise, we'll double free clientCreds.");
            
        } else {

            // We've got a real error, so lets make sure an error is set
            // or set one and bail.

            if(!pTHS->errCode){
                Assert(!"If the RemoteAddOneObjectSimply() returned w/o setting the thread state error, that should be fixed.");
                SetSvcErrorEx(SV_PROBLEM_UNAVAILABLE, 
                              DS_ERR_DRA_INTERNAL_ERROR, 
                              ulRet);
            }

            FreeRemoteAddCredentials(&clientCreds);
            Assert(pTHS->errCode);
            return(pTHS->errCode);

        }
    }

    // Success adding the crossRef, or at least finding the right crossRef.
    
    // Don't need these anymore.
    FreeRemoteAddCredentials(&clientCreds);

    // Make sure the DS didn't decide to shutdown on us while we were gone.
    if (eServiceShutdown) {
        return(ErrorOnShutdown());
    }
    // If this DC is in the middle of being demoted, we don't allow
    // crossRefs to be created.
    if (!gUpdatesEnabled) {
        return(SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN));
    }

    //
    // Replicate the Cross-Ref back to this server.
    //
     
    if(fRemoteNamingFsmo){
        // Only need to replicate if we aren't the Naming FSMO.
        //
        // ISSUE-2002/03/28-BrettSh
        // Technically, we aren't going to check for permissions to see this user
        // can do this operation, but I'll maintain that if they have permissions
        // to create a crossRef we'll let them initiate a sync.  Or if the person
        // specified a crossRef that already existed, but hasn't replicated, then
        // we're allowing this person to unauthenticated initiate a sync, but only
        // this once.  Actully, this may or may not be true, depending on how
        // IDL_DRSAddEntry() handles someone w/o enough permissions.
        ulRet = ReplicateObjectsFromSingleNc(pdnFsmoNtdsa,
                                             1,
                                             (pdnGuidOnlyCrossRef) ? 
                                                 &(pdnGuidOnlyCrossRef) : 
                                                 &(entinflistCrossRef.Entinf.pName), 
                                             gAnchor.pConfigDN);
        if(ulRet){
            // ReplicateObjectsFromSingleNc() doesn't set the thread error.
            SetSvcError(SV_PROBLEM_UNAVAILABLE,
                        ulRet);
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }
        
        // Make sure the DS didn't decide to shutdown on us while we were gone.
        if (eServiceShutdown) {
            return(ErrorOnShutdown());
        }
    }

    return(pTHS->errCode);
}

DWORD
ValidateDomainDnsNameComponent(
    THSTATE*    pTHS, 
    PWCHAR      szVal,
    DWORD       cbVal
    ) 
/**++
Description:
    Validates a name component to be a valid dns name label. 
    
++**/    
{
    PWCHAR szNameComponent;
    DWORD  dwErr;
    
    // copy the name component to a null-terminated string
    szNameComponent = (PWCHAR)THAllocEx(pTHS, cbVal + sizeof(WCHAR));
    memcpy(szNameComponent, szVal, cbVal);
    szNameComponent[cbVal/sizeof(WCHAR)] = L'\0';
    
    // validate the name component (so that it does not contain a dot
    // or some other dns-forbidden character)
    dwErr = DnsValidateName(szNameComponent, DnsNameDomainLabel);
    if (dwErr == DNS_ERROR_NON_RFC_NAME) {
        // This is a warning: name contains non-unicode chars.
        // According to LevonE, we can ignore it (would be nice
        // to return a warning, but we can't in LDAP).
        dwErr = ERROR_SUCCESS;
    }

    THFreeEx(pTHS, szNameComponent);

    // DNS_ERROR_NUMERIC_NAME should never be returned for DnsNameDomainLabel
    Assert(dwErr != DNS_ERROR_NUMERIC_NAME);

    return dwErr;
}


DWORD
ValidateDomainDnsName(
    THSTATE *       pTHS,
    DSNAME *        pdnName
    )
{                    
    ATTRBLOCK *     pObjB;
    ULONG           i; 
    ULONG           ulErr;


    Assert(pdnName);
    Assert(pTHS && pTHS->errCode == ERROR_SUCCESS);

    ulErr = DSNameToBlockName(pTHS, pdnName, &pObjB, DN2BN_LOWER_CASE);
    if(ulErr){
        return(SetNamError(NA_PROBLEM_NAMING_VIOLATION, pdnName, ulErr));
    }

    for(i = 0; i < pObjB->attrCount; i++){
        if(pObjB->pAttr[i].attrTyp != ATT_DOMAIN_COMPONENT) {
            SetNamError(NA_PROBLEM_NAMING_VIOLATION, pdnName, DIRERR_BAD_ATT_SYNTAX);
            break;
        }
        ulErr = ValidateDomainDnsNameComponent(
                    pTHS, 
                    (PWCHAR)pObjB->pAttr[i].AttrVal.pAVal[0].pVal, 
                    pObjB->pAttr[i].AttrVal.pAVal[0].valLen);
        if (ulErr) {
            SetNamError(NA_PROBLEM_NAMING_VIOLATION, pdnName, ulErr);
            break;
        }
    }
    FreeBlockName(pObjB);

    return(pTHS->errCode);
}

DWORD
AddNCPreProcess(
    THSTATE *       pTHS,
    ADDARG *        pAddArg,
    ADDRES *        pAddRes
    )
{
    SYNTAX_INTEGER  iType;
    ATTR *          pAttrs = pAddArg->AttrBlock.pAttr; // Speed hack.
    ULONG           i, j;
    CLASSCACHE *    pCC;
    ULONG           oclass;
    ATTR *          pObjectClass = NULL;

    ADDARG *        pAddArgCopy = NULL;
    THSTATE *       pSaveTHS;
    ADDRES *        pSpareAddRes; // spare add res.
    COMMARG         CommArg; // Need this for the FindExactCrossRef() func.
    GUID            NcGuid = {0,0,0,0};
    CROSS_REF *     pCR = NULL;
    DWORD           dwErr = ERROR_SUCCESS;
    VOID *          pBuf = NULL;
    DWORD           dwSavedErrCode = 0;
    DIRERR *        pSavedErrInfo = NULL;


    DPRINT(2,"AddNCPreProcess() entered\n");

    Assert(VALID_THSTATE(pTHS));
    Assert(pAddArg);
    Assert(pAddRes);

    //
    // First, determine if this is an NC Head at all.
    //

    Assert(!pAddArg->pCreateNC);

    for(i=0; i< pAddArg->AttrBlock.attrCount; i++) {

        switch(pAttrs[i].attrTyp){
        
        case ATT_INSTANCE_TYPE:
            if(pAttrs[i].AttrVal.valCount == 1 &&
               pAttrs[i].AttrVal.pAVal->valLen == sizeof(SYNTAX_INTEGER) &&
               !(pAddArg->pCreateNC)){
               iType = * (SYNTAX_INTEGER *) pAttrs[i].AttrVal.pAVal->pVal;
               if(iType & IT_NC_HEAD) {
                   if(pTHS->fDRA || (iType & IT_WRITE)) {
                       if (!DsaIsInstalling() && !pTHS->fDRA && (iType & (~(IT_NC_HEAD | IT_WRITE))) ) {
                           // Hmmm, there are some other instanceType bits set, that sounds 
                           // like a good tester, but doesn't sound like a good user!
                           Assert(!"bad instance type!");
                           SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                       ERROR_DS_BAD_INSTANCE_TYPE);
                           return(pTHS->errCode);
                       }
                       // Looks like a good NC head creation.
                       pAddArg->pCreateNC = THAllocEx(pTHS, sizeof(CREATENCINFO));
                       break;
                   } else {
                       SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                                     ERROR_DS_ADD_REPLICA_INHIBITED,
                                     iType);
                       Assert(pTHS->errCode);
                       return(pTHS->errCode);
                   }
               } else {  
                   // Not an NC, no more processing needed.
                   if (!DsaIsInstalling() && !pTHS->fDRA && 
                       (iType != 0 && iType != 4) ) { 
                       // For internal nodes. only instaceType of 0 is acceptable
                       SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                   ERROR_DS_BAD_INSTANCE_TYPE);
                       return(pTHS->errCode);
                   }
                   DPRINT(2,"AddNCPreProcess() is not processing a NC head, returning early.\n");
                   Assert(pTHS->errCode == 0);
                   return(pTHS->errCode);
               } 
            } else {
                Assert(!"This probably can only be hit one way, if someone tries to add the instanceType attr twice!");
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_BAD_INSTANCE_TYPE);
                return(pTHS->errCode);
            }
            break;

        case ATT_OBJECT_CLASS:
            pObjectClass = &pAttrs[i];
            break;

        default:
            // Do nothing.
            break;

        } // End switch attribute type.

    } // End for each attribute.
    
    if(pAddArg->pCreateNC == NULL){
        // Instance type found to be a the usual case (internal ref), so bail out
        // now.
        DPRINT(2,"AddNCPreProcess() is not processing a NC head, returning early.\n");
        return(ERROR_SUCCESS);
    }

    //
    // We're adding an NC Head, setup the NcHeadInfo struct.
    //
    
    DPRINT(2, "AddNCPreProcess() is processing an NC Head add.\n");

    // else we have an NC Head of some sort, do further processing to
    // build up the CREATENCINFO structure in pAddArg.

    if(!pObjectClass){    
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                    DIRERR_OBJECT_CLASS_REQUIRED);
        Assert(pTHS->errCode);
        return(pTHS->errCode);
    }

    
    for(i=0;i < pObjectClass->AttrVal.valCount; i++){
        Assert(sizeof(SYNTAX_INTEGER) == pObjectClass->AttrVal.pAVal[i].valLen);
        
        // Until each NC is standardized, we must change the behaviour of create
        // NC based on each type of NC we're creating.  A regular Non-Domain
        // Naming Context, a regular Domain Naming Context, or the special
        // Schema Naming Context, or the special Configuration Naming Context.
        switch(*(SYNTAX_INTEGER *)pObjectClass->AttrVal.pAVal[i].pVal){
        
        case CLASS_CONFIGURATION:
            // Creating a configuration NC.
            Assert(pAddArg->pCreateNC && pAddArg->pCreateNC->iKind == 0);
            pAddArg->pCreateNC->iKind = CREATE_CONFIGURATION_NC;
            break;

        case CLASS_DMD:
            // Creating a schema NC.
            Assert(pAddArg->pCreateNC && pAddArg->pCreateNC->iKind == 0);
            pAddArg->pCreateNC->iKind = CREATE_SCHEMA_NC;
            break;

        case CLASS_DOMAIN_DNS:
            // this is either a NDNC or a Domain.
            Assert(pAddArg->pCreateNC && pAddArg->pCreateNC->iKind == 0);

            if(DsaIsInstalling()){
                pAddArg->pCreateNC->iKind = CREATE_DOMAIN_NC;
            } else {
                pAddArg->pCreateNC->iKind = CREATE_NONDOMAIN_NC;
            }
            break;
        case CLASS_ORGANIZATION:
            // mkdit.exe is creating the shipped dit (ntds.dit)
            if(DsaIsInstalling()){
                pAddArg->pCreateNC->iKind = CREATE_DOMAIN_NC;
            } else {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            ERROR_DS_BAD_INSTANCE_TYPE);
                Assert(pTHS->errCode);
                return(pTHS->errCode);
            }
            break;

        default:
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_BAD_INSTANCE_TYPE);
            Assert(pTHS->errCode);
            return(pTHS->errCode);
            break;
        } // end switch on type of class
    } // end for each value

    Assert(VALID_CREATENCINFO(pAddArg->pCreateNC) && 
           "More than one NC Head type objectClass was defined!!\n");

    if(!fISADDNDNC(pAddArg->pCreateNC) ||
       !VALID_CREATENCINFO(pAddArg->pCreateNC)){
        // For now the rest of this function only handles NDNCs, but the 
        // automatic cross-ref creation could be made to happen for the 
        // dcpromo code as well.
        if (DsaIsInstalling()) {
            // If we're installing, we're done here.
            Assert(pTHS->errCode == 0);
            return(pTHS->errCode);
        } else {
            // If we've gotten this far, and we're not installing, AND
            // we're not adding an NDNC ... then someone is trying to
            // make some sort of NC we don't allow, like config/schema
            // or domain.  So whatever class they're doing it for,
            // there specifying an instance type we won't allow for this
            // class.
            SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                        ERROR_DS_BAD_INSTANCE_TYPE); 
            return(pTHS->errCode);
        }
    }
                 
    if(ValidateDomainDnsName(pTHS, pAddArg->pObject)){
        Assert(pTHS->errCode);
        return(pTHS->errCode);
    }

    // See if we have the CrossRef for this NC?
    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pAddArg->pObject, &CommArg);
    
    if(!pCR){

        // Darn, now we've got our work cut out for us, we'll have to
        //    
        //    1. Save and duplicate the Add/Res Args.
        //    2. Try a TestNDNCLocalAdd() to see if we should add the CR or not.
        //    3. If ( unexpected error in the LocalAdd )
        //    3a       error out,
        //    4. Remotely create the NC's CR object.
        //    5. Replicate it back to this server.
        //    6. FindExactCrossRef() again.
        //    7. Fall out and continue with the NC Head add operation.

        if(pTHS->transControl != TRANSACT_BEGIN_END){
            SetUpdError(UP_PROBLEM_AFFECTS_MULT_DSAS, 
                        DS_ERR_NO_CROSSREF_FOR_NC);
            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }

        // Step 1.
        pSpareAddRes = THAllocEx(pTHS, sizeof(ADDRES));
        pAddArgCopy = DeepCopyADDARG(pTHS, pAddArg, NULL);
        pAddArgCopy->pCreateNC->fTestAdd = TRUE;

        // Step 2 & 3 are skipped for now.  These steps are only used
        // to ensure we don't create a CR where we would've known that
        // the LocalAdd() of the NC would've failed.  In practice it's
        // much more likely that this operation will fail during remote
        // cross-ref creation and retrieval.  Further the operation is
        // imdepotent, so if you create the crossRef for your NDNC, then
        // you can figure out what you did wrong locally and retry, and
        // we'll use the crossRef you created on your first attempt.
        ;

        // FUTURE-2002/03/14-BrettSh Add test of LocalAdd() of NC head. (Steps 2 & 3 abouve)
        
        // Step 4 & 5
        dwErr = GetCrossRefForNDNC(pTHS, pAddArg->pObject);
        
        // Sanity 
        Assert(dwErr == pTHS->errCode);
        if (dwErr) {
            return(pTHS->errCode);
        }

        // Step 6.
        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        // FUTURE-2002/03/14-BrettSh It'd be nice to use DmitriG's
        // EnumerateCrossRefs() function so that we're guaranteed a crossRef.
        // Further it'd be good idea to cache this crossRef in the 
        // pAddArg->pCreateNC info for further use during this NC head 
        // creation.  This would both speed up the process of NC Head creation
        // and ensure we don't fail due to crossRef cache inconsistency.
        pCR = FindExactCrossRef(pAddArg->pObject, &CommArg);
        
        if(!pCR){

            // What the heck we should never be here, this means
            // that an error in creating and retrieving/replicating
            // back the cross ref didn't get percolated up
            
            // This assert can be re-enabled when the ReplicateObjectsFromSingleNc()
            // code is fixed up to replicate via the guid based DNS name.
            ;
            // FUTURE-2002/03/14-BrettSh If we could rely on the crossRef
            // cache, or we used EnumerateCrossRefs() we could reenable this assert
            // Assert(!"We should never get to this state!\n");
            SetSvcError(SV_PROBLEM_BUSY, ERROR_DS_BUSY);
            LooseAssert(pTHS->errCode, SubrefReplicationDelay);
            return(pTHS->errCode);
        
        }

    }

    // Step 7.
    // Now we should have the following:
    //    1) A Valid corresponding crossRef
    Assert(pCR);
    
    // Now, we cache the cross-ref for later ... this ensures two things:
    //   A) Increases performance, so we don't have to walk the horrible
    //      linked list of cross-refs so much for an NDNC head add.
    //   B) Increases robustness, so that if the cross-ref cache temporarily
    //      deletes the cross-ref from the cache, we still have the original
    //      cross-ref cache entry to use.
    pAddArg->pCreateNC->pCR = pCR;

    Assert(pTHS->errCode == 0);
    return(pTHS->errCode);
}


DWORD
AddNDNCInitAndValidate(
    THSTATE *       pTHS,
    DSNAME *        pNC,
    CREATENCINFO *  pCreateNC
    )
/*++

Description:

    This validates that this DC is the right DC to create this NC (pNC),
    and then fills in the pNC->Guid and SD Ref Dom params for later use
    in the NDNC creation operation.

Parameters:

    pTHS -
    pNC (IN/OUT) - The DN of the NDNC to create, we fill the GUID.
    pCreateNC (IN/OUT) - The freshly created CREATENCINFO structure, 
        with the NC type being NDNC.  We use the the pCR off this
        parameter too.

Return Value:

    returns pTHS->errCode 

--*/
{
    COMMARG         CommArg; // Need this for the FindExactCrossRef() func.
    CROSS_REF * pCR = NULL;
    
    // First we want to take the ATT_MS_DS_SD_REFERENCE_DOMAIN
    // off the crossRef, and add it to the ????
    Assert(pNC && pCreateNC && pCreateNC->pCR && fISADDNDNC(pCreateNC));
    
    pCR = pCreateNC->pCR;

    if(AddNDNCHeadCheck(pTHS, pCR)){
        // Error should have been set by AddNDNCHeadCheck()
        Assert(pTHS->errCode);
        return(pTHS->errCode);
    }

    // First we want to take the ATT_MS_DS_SD_REFERENCE_DOMAIN
    // off the crossRef, and add it to the cached info for pCreateNC.

    if(pCR->pdnSDRefDom){
        // We've got a reference domain pre-set by the user, use that.
        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;
        pCreateNC->pSDRefDomCR = FindExactCrossRef(pCR->pdnSDRefDom, &CommArg);
        pCreateNC->fSetRefDom = FALSE;
    } else {
        // Try to use a logical default for the reference domain.
        pCreateNC->pSDRefDomCR = GetDefaultSDRefDomCR(pNC);
        pCreateNC->fSetRefDom = TRUE;
    }

    if(pCreateNC->pSDRefDomCR == NULL ||
       pCreateNC->pSDRefDomCR->pNC->SidLen == 0){
        SetAttError(pNC, 
                    ATT_MS_DS_SD_REFERENCE_DOMAIN,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, 
                    NULL,
                    ERROR_DS_NO_REF_DOMAIN);
        return(pTHS->errCode);
    }

    Assert(pCreateNC->pSDRefDomCR);
    Assert(IsValidSid(&pCreateNC->pSDRefDomCR->pNC->Sid));

    // Put the NcGuid in the NC Head object ... this may or may not
    // be NULL.  If it is NULL, we'll get a GUID later for this object.
    pNC->Guid = pCR->pNC->Guid;
    if(fNullUuid(&pCR->pNC->Guid)){
        // Once we no longer need to maintain Win2k compatibility, we can assert
        // and error here, saying the crossRef is an old Win2k crossRef.
        pCreateNC->fNullNcGuid = TRUE;
    }
    
    return(ERROR_SUCCESS);
}


BOOL
fIsNDNC(
    DSNAME *        pNC
    )
// NOTE: This function is inefficient, try to use a cached crossRef, and
// the fIsNDNCCR() function.
{
    CROSS_REF_LIST *pCRL = NULL;

    // gAnchor.pConfigDN & gAnchor.pDMD not defined during install, but we never
    // deal with NDNCs at install time.  Confusingly enough, config and schema
    // are not "NDNCs," although they're not domain NCs either.
    if(DsaIsInstalling() ||
       NameMatched(gAnchor.pConfigDN, pNC) ||
       NameMatched(gAnchor.pDMD, pNC)){
        return(FALSE);
    }
    
    for(pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR){
        if(NameMatched(pCRL->CR.pNC, pNC)){
            return fIsNDNCCR(&pCRL->CR);
        }
    }

    DPRINT1(0, "Failed to find CR for NC %ls.\n", pNC->StringName);

    return(FALSE);
}

BOOL
fIsNDNCCR(
    IN CROSS_REF * pCR
    )
{
    return // gAnchor.pConfigDN & gAnchor.pDMD not defined during install, but
           // we never deal with NDNCs at install time.
           !DsaIsInstalling()
           // Confusingly enough, config and schema are not "NDNCs," although
           // they're not domain NCs either.
           && !NameMatched(gAnchor.pConfigDN, pCR->pNC)
           && !NameMatched(gAnchor.pDMD, pCR->pNC)
           // But any other NTDS NC that is not a domain NC is an NDNC.
           && (pCR->flags & FLAG_CR_NTDS_NC)
           && !(pCR->flags & FLAG_CR_NTDS_DOMAIN);
}

ULONG 
ModifyCRForNDNC(
    THSTATE *       pTHS,
    DSNAME *        pDN,
    CREATENCINFO *  pCreateNC
    )
{
    MODIFYARG       ModArg;
    MODIFYRES       ModRes;
    ATTRVAL         pAttrVal[5];
    ATTRMODLIST     OtherMod[5];
    DWORD           dwCRFlags = 0;
    COMMARG         CommArg;
    CROSS_REF *     pCR;
    DSNAME *        pCRDN;
    BOOL            fDSASaved;
    WCHAR *         pwszArrStr[1];
    DS_NAME_RESULTW * pdsrDnsName = NULL;
    ULONG           ulRet;
    WCHAR *         wszDnsName = NULL;

    // Our modifications to the crossRef has to happen in two phases:
    //   A) first we'll do a straight modify to the crossRef to ENABLE 
    //      it, and get it all setup (set systemFlags, and Replicas).
    //   B) Then if necessary, we'll also post (add and delete) an 
    //      infrastructure update to update the GUID of the NCs.
    // Step (B) will become unnecessary, once we start failing to
    // create NCs for crossRefs where the nCName DN has no GUID.
    // This will happen, once we no longer require Win2k 
    // compatibility.

    pCR = pCreateNC->pCR;
    if(!pCR){                           
        Assert(!"Shouldn't happen anymore, we cache the crossRef from the initial get go now");
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, ERROR_DS_INTERNAL_FAILURE));
    }

    // Modification 1
    // Make sure that the value of systemFlags is set correctly.
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    ModArg.FirstMod.AttrInf.attrTyp = ATT_SYSTEM_FLAGS;
    ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
    ModArg.FirstMod.AttrInf.AttrVal.pAVal = &pAttrVal[0];
    ModArg.FirstMod.AttrInf.AttrVal.pAVal[0].valLen = sizeof(dwCRFlags);
    ModArg.FirstMod.AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) &dwCRFlags;
    ModArg.FirstMod.pNextMod = &OtherMod[0];
    // The actual value of dwCRFlags is set below right after we get
    // the old value of the system flags and merge in the new stuff.
    
    // Modification 2
    // Remove the ENABLED = FALSE attribute.
    memset(&OtherMod, 0, sizeof(OtherMod));
    OtherMod[0].choice = AT_CHOICE_REMOVE_ATT;
    OtherMod[0].AttrInf.attrTyp = ATT_ENABLED;
    OtherMod[0].AttrInf.AttrVal.valCount = 0;
    OtherMod[0].pNextMod = &OtherMod[1]; 
    
    // Modification 3
    // Make this DSA a replica of the mSDS-NC-Replica-Locations attribute.
    OtherMod[1].choice = AT_CHOICE_ADD_ATT;
    OtherMod[1].AttrInf.attrTyp = ATT_MS_DS_NC_REPLICA_LOCATIONS;
    OtherMod[1].AttrInf.AttrVal.valCount = 1;
    OtherMod[1].AttrInf.AttrVal.pAVal = &pAttrVal[1];
    // Should make copy in the DSA DN.
    OtherMod[1].AttrInf.AttrVal.pAVal[0].valLen = gAnchor.pDSADN->structLen;
    OtherMod[1].AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) THAllocEx(pTHS,
                                                                    gAnchor.pDSADN->structLen);
    memcpy(OtherMod[1].AttrInf.AttrVal.pAVal[0].pVal, 
           gAnchor.pDSADN, 
           gAnchor.pDSADN->structLen);
    OtherMod[1].pNextMod = &OtherMod[2];
    
    // Modification 4
    // Set the dNSRoot properly.
    pwszArrStr[0] = pDN->StringName;
    ulRet = DsCrackNamesW(NULL,
                          DS_NAME_FLAG_SYNTACTICAL_ONLY,
                          DS_FQDN_1779_NAME,
                          DS_CANONICAL_NAME,
                          1,
                          pwszArrStr,
                          &pdsrDnsName);
    Assert(ulRet != ERROR_INVALID_PARAMETER);
    if(ulRet){
        Assert(ulRet == ERROR_NOT_ENOUGH_MEMORY || "I really don't see how this could fail, because pDN->StringName should've been validated long ago");
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, ulRet);
        return(pTHS->errCode);
    }
    __try {
        Assert(pdsrDnsName);
        Assert(pdsrDnsName->cItems == 1);
        Assert(pdsrDnsName->rItems != NULL);
        if(pdsrDnsName->rItems[0].status != DS_NAME_NO_ERROR){
            Assert(ulRet == ERROR_NOT_ENOUGH_MEMORY || "I really don't see how this could fail, because pDN->StringName should've been validated long ago");
            SetNamError(NA_PROBLEM_BAD_NAME,
                        pDN,
                        DIRERR_BAD_NAME_SYNTAX);
            __leave;
        }
        Assert(pdsrDnsName->rItems[0].pDomain);

        wszDnsName = THAllocEx(pTHS, (wcslen(pdsrDnsName->rItems[0].pDomain) + 1) * 
                               sizeof(WCHAR));
        wcscpy(wszDnsName, pdsrDnsName->rItems[0].pDomain);
        OtherMod[2].choice = AT_CHOICE_REPLACE_ATT;
        OtherMod[2].AttrInf.attrTyp = ATT_DNS_ROOT;
        OtherMod[2].AttrInf.AttrVal.valCount = 1;
        OtherMod[2].AttrInf.AttrVal.pAVal = &pAttrVal[2];
        OtherMod[2].AttrInf.AttrVal.pAVal[0].valLen = wcslen(wszDnsName) * sizeof(WCHAR);
        OtherMod[2].AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) wszDnsName;
        OtherMod[2].pNextMod = NULL;

    } __finally {
        DsFreeNameResultW(pdsrDnsName);
    }
        
    ModArg.count = 4;

    if(pCreateNC->fSetRefDom){
        Assert(pCreateNC->pSDRefDomCR);

        OtherMod[2].pNextMod = &OtherMod[3];

        // Modification 5
        // Set up the mS-DS-SD-Reference-Domain, if unspecified on the CR.
        OtherMod[3].choice = AT_CHOICE_ADD_ATT;
        OtherMod[3].AttrInf.attrTyp = ATT_MS_DS_SD_REFERENCE_DOMAIN;
        OtherMod[3].AttrInf.AttrVal.valCount = 1;
        OtherMod[3].AttrInf.AttrVal.pAVal = &pAttrVal[3];
        // Must copy in the DN, otherwise under just the right conditions we can 
        // corrupte the in memory cache.
        OtherMod[3].AttrInf.AttrVal.pAVal[0].valLen = pCreateNC->pSDRefDomCR->pNC->structLen;
        OtherMod[3].AttrInf.AttrVal.pAVal[0].pVal = (UCHAR *) THAllocEx(pTHS, 
                                                                        pCreateNC->pSDRefDomCR->pNC->structLen);
        memcpy(OtherMod[3].AttrInf.AttrVal.pAVal[0].pVal, 
               pCreateNC->pSDRefDomCR->pNC, 
               pCreateNC->pSDRefDomCR->pNC->structLen);
        OtherMod[3].pNextMod = NULL;
        
        ModArg.count = 5;
    }

    ModArg.pMetaDataVecRemote = NULL;
    pCRDN = THAllocEx(pTHS, pCR->pObj->structLen);
    memcpy(pCRDN, pCR->pObj, pCR->pObj->structLen);
    ModArg.pObject = pCRDN;
    InitCommarg(&ModArg.CommArg);
    
    fDSASaved = pTHS->fDSA;
    __try {
        
        
        if (DoNameRes(pTHS, 0, ModArg.pObject, &ModArg.CommArg,
                                   &ModRes.CommRes, &ModArg.pResObj)){
            // trouble we should never be here, there should have been a CR.
            Assert(!"The CR, should have already been checked for.\n");
            Assert(pTHS->errCode);
            __leave;
        }                                                             

            
        // If there was a Cross-Ref created, then security was not checked,
        // so now we will check if this paticular someone has permission to
        // modify the Cross-Ref object, if not the operation will fail as
        // a security error.
        pTHS->fDSA = FALSE;

        if(CheckModifySecurity(pTHS, &ModArg, NULL, NULL, NULL, FALSE)){
            // There was a problem with security for modifying this object, we 
            // don't have permissions to complete this operation.

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CROSS_REF_MODIFY_SECURITY_FAILURE,
                     szInsertDN(pDN), szInsertDN(pCRDN), NULL);

            Assert(pTHS->errCode);
            return(pTHS->errCode);
        }

        // Now that we've checked that we've permission to modify the
        // Cross-Ref, lets actually patch up the Cross-Ref locally, to
        // represent that this NC is instantiated and that this DC is
        // one of it's replicas.
        pTHS->fDSA = TRUE;

        if (DBGetSingleValue(pTHS->pDB, ATT_SYSTEM_FLAGS, &dwCRFlags,
                             sizeof(dwCRFlags), NULL)) {
            dwCRFlags = 0;
        }

        Assert(!(dwCRFlags & FLAG_CR_NTDS_DOMAIN));
        dwCRFlags |= FLAG_CR_NTDS_NC | FLAG_CR_NTDS_NOT_GC_REPLICATED;
        LocalModify(pTHS, &ModArg);
        if(pTHS->errCode){
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_CROSS_REF_MODIFY_FAILURE,
                      szInsertDN(pDN), 
                      szInsertDN(pCRDN),
                      Win32ErrorFromPTHS(pTHS),
                      GetTHErrorDSID(pTHS),
                      NULL, NULL, NULL, NULL);
            __leave;
        }

        // Step (B) from above.
        // There is one final step, since the Domain Naming FSMO at the time
        // it created the CrossRef may not have know the GUID of the NC, we 
        // need to make an infrastructureUpdate that will update the nCName
        // attribute on the crossRef.
        if(pCreateNC->fNullNcGuid){
            Assert(!fNullUuid(&pDN->Guid));
            ForceChangeToCrossRef(pCRDN, pDN->StringName, &pDN->Guid, 0, NULL);
        }

    } __finally {
        pTHS->fDSA = fDSASaved;
    }


    return(pTHS->errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdread.c
//
//--------------------------------------------------------------------------

/*

Description:

    Implements the DirRead API.

    DSA_DirRead() is the main function exported from this module.

*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>         // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <anchor.h>
#include <ntdsctr.h>

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"         // Defines for selected classes and atts
#include "debug.h"          // standard debugging header
#define DEBSUB     "MDREAD:"            // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDREAD

// Internal functions

int LocalRead(THSTATE *pTHS, READARG *pReadArg, READRES *pReadRes);

VOID
RemoveDuplicatesFromAttCache(
    IN ATTCACHE **AttCache,
    IN DWORD nAtts
    );



ULONG
DirRead(
        READARG*    pReadArg,
    READRES **  ppReadRes
        )
/*++
  pReadArg is the read argument
  ppOutBuf is the Result or Error output buffer addr.
--*/
{
    THSTATE*     pTHS;
    READRES *pReadRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT(1,"DirRead entered\n");

    /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
    is required on every API transaction.  First the state DS is initialized
    and then either a read or a write sync point is established.
    */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppReadRes = pReadRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppReadRes = pReadRes = THAllocEx(pTHS, sizeof(READRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if ((eServiceShutdown >= eSecuringDatabase) ||
                ((eServiceShutdown >= eRemovingClients) && !pTHS->fDSA)) {
                ErrorOnShutdown();
                __leave;
            }
        }
    SYNC_TRANS_READ();   /*Identify a reader trans*/
    __try {
        /* Perform name resolution to locate object.  If it fails,
         * just return an error, which may be a referral.
         */

        if (0 == DoNameRes(pTHS,
                               NAME_RES_QUERY_ONLY,
                   pReadArg->pObject,
                   &pReadArg->CommArg,
                   &pReadRes->CommRes,
                               &pReadArg->pResObj)){

        /* Local read operation */

        LocalRead(pTHS, pReadArg, pReadRes);
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN (pTHS->errCode);
    }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                  &dwEA, &ulErrorCode, &dsid)) {
    HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pReadRes) {
    pReadRes->CommRes.errCode = pTHS->errCode;
    pReadRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }
    return pTHS->errCode;
}  // DSA_DirRead


/*++ CmpACByAttType
 *
 * A simple function to be used with qsort and bsearch.  Compares ATTCACHE's
 * base on attrtyp.
 *
 ++*/
int __cdecl
CmpACByAttType(const void * keyval, const void * datum)
{
    ATTCACHE **ppACkey = (ATTCACHE **)keyval;
    ATTCACHE **ppACdatum = (ATTCACHE **)datum;

    return ((*ppACkey)->id - (*ppACdatum)->id);
}

/*++ CmpIndexedACByAttType
 *
 * A simple helper function for use in qsorting arrays of Indexed pACs by their
 * attrtyp's.  We do this so that we can remove duplicates from a user supplied
 * list of attributes without changing the ordering of the returned att's.
 */
int __cdecl
CmpIndexedACByAttType(const void * keyval, const void * datum)
{
    PINDEXED_AC pACkey = (PINDEXED_AC)keyval;
    PINDEXED_AC pACdatum = (PINDEXED_AC)datum;

    return (pACkey->AttCache->id - pACdatum->AttCache->id);
}


INT
GetAttrFromSel(
    IN THSTATE *pTHS,
    IN ENTINFSEL *Sel,
    IN ENTINF *Ent,
    IN ATTCACHE **AttCache,
    IN PDWORD pnAtts,
    IN BOOL fIgnoreError
    )
/*++

Function Description:
       Convert ENTINFSEL entries into ATTCACHE entries.

Arguments:
       Sel - describes what attributes to read.
       Ent - returns the read attributes.
       AttCache - where to put the converted entries
       fIgnoreError - ignore conversion error.  used for the ALL with List
        case.

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{

    DWORD i;
    DWORD nNext = 0;

    for(i=0 ; i < Sel->AttrTypBlock.attrCount ; i++) {

        if(Sel->AttrTypBlock.pAttr[i].attrTyp == INVALID_ATT) {

            continue;

        } else if (!(AttCache[nNext] =
                     SCGetAttById(pTHS,
                                  Sel->AttrTypBlock.pAttr[i].attrTyp))) {

            if ( !fIgnoreError ) {
                return SetAttError(Ent->pName,
                    Sel->AttrTypBlock.pAttr[i].attrTyp,
                    PR_PROBLEM_UNDEFINED_ATT_TYPE,
                    NULL,
                    DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }

            continue;

        } else {

            nNext++;
        }
    }

    *pnAtts = nNext;
    return 0;
} // GetAttrFromSel


INT
AppendAttrFromSel(
    IN THSTATE *pTHS,
    IN ENTINFSEL *Sel,
    IN ENTINF *Ent,
    IN ATTCACHE **AttCache,
    IN DWORD cAttCache,
    IN BOOL fIgnoreError,
    IN BOOL fIgnoreDups
    )
/*++

Function Description:
       Convert ENTINFSEL entries into ATTCACHE entries and append to an array
       of attcache's if there will be no duplicates after.

Arguments:
       Sel - describes what attributes to read.
       Ent - returns the read attributes.
       AttCache - where to put the converted entries
       fIgnoreError - ignore conversion error.  used for the ALL with List
        case.
       pCC - the CLASSCACHE these entries belong to

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{

    unsigned i,k;
    unsigned j = cAttCache;
    unsigned cNewAtts, ListLength;
    BOOL     fFound = FALSE;
    ATTCACHE *pAC;


    for(i=0 ; i < Sel->AttrTypBlock.attrCount ; i++) {

        if(Sel->AttrTypBlock.pAttr[i].attrTyp == INVALID_ATT) {

            continue;

        } else if (!(pAC = SCGetAttById(pTHS,
                                  Sel->AttrTypBlock.pAttr[i].attrTyp))) {

            if ( !fIgnoreError ) {
                return SetAttError(Ent->pName,
                    Sel->AttrTypBlock.pAttr[i].attrTyp,
                    PR_PROBLEM_UNDEFINED_ATT_TYPE,
                    NULL,
                    DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            }

            continue;

        } else if (!fIgnoreDups) {
            // append attribute if it's not already in the list
            if (j < 6) {
                // not worth doing bsearch
                for (k = 0; k < j; k++) {
                    if (pAC->id == AttCache[k]->id) {
                        fFound = TRUE;
                    }
                }
                if (!fFound) {
                    AttCache[j++] = pAC;
                } else {
                    fFound = FALSE;
                }
            } else {
                if (!bsearch(&pAC, AttCache, cAttCache, sizeof(AttCache[0]), CmpACByAttType)) {
                    AttCache[j++] = pAC;
                }
            }
        } else {
            AttCache[j++] = pAC;
        }
    }

    if (j > (cAttCache + 1) && !fIgnoreDups) {
        //
        // We know that none of the atts that came in the EntInfSel are dups of atts
        // already in the attcache list, now make certain there were no dupes in the
        // EntInfSel.  Just sort the newly added atts and remove the duplicates.
        //
        cNewAtts = j - cAttCache;
        if (!IsACListSorted(&AttCache[cAttCache], cNewAtts)) {
            qsort(&AttCache[cAttCache], cNewAtts, sizeof(AttCache[0]), CmpACByAttType);
        }

        RemoveDuplicatesFromAttCache(&AttCache[cAttCache], cNewAtts);

    }

    return 0;
} // InsertAttrFromSel


VOID
RemoveDuplicatesFromAttCache(
    IN ATTCACHE **AttCache,
    IN DWORD nAtts
    )
/*++

    Function Description:
       Remove duplicate attributes

    Arguments:
       AttCache - Array of ATTCACHE pointers
       nAtts - number of items in array

    Return Value.
       None

--*/
{
    DWORD i, j;

    //
    // Do a linear search and NULL out all duplicates
    //

    for ( i=0; i < nAtts; i++ ) {

        if ( AttCache[i] != NULL ) {

            for (j=i+1; j < nAtts; j++ ) {

                if (AttCache[i] == AttCache[j] ) {

                    AttCache[j] = NULL;
                } else if (AttCache[j] != NULL) {
                    i = j - 1;
                    break;
                }
            }
        }
    }
} // RemoveDuplicatesFromAttCache


INT
GetEntInf2(
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pSelRange,
    IN ENTINF *pEnt,
    IN RANGEINF *pRange,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN OUT PCACHED_AC CachedAC OPTIONAL,
    IN OPTIONAL RESOBJ *pResObj,
    IN OPTIONAL PSID psidQuotaTrustee
    )
/*++

Function Description:
       Retrieve attribute data from the positioned object.  First some object
       header information is retrieved (DN and master or copy flag), then either
       some or all of the attributes are visited and data is returned.

Arguments:
       pDB - Database position to be used. Note that pDB != pDB->pTHS->pDB.
             We may be passing in a temporary pDB so that the primary pDB
             is not disturbed.
       pSel - describes what attributes to read.
       pEnt - returns the read attributes.
       CachedAC - Enables the caller to request and send a preformatted/sorted
            ATTCACHE array.
            if NULL, caller does not wish the array to be returned
            if not NULL and CacheAC->AC is NULL, caller is requesting that the array
                be returned
            if not NULL and CacheAC->AC is not NULL, caller is supplying the array
       pResObj - if present, used instead of fetching the object name

       pSecurity - the security descriptor of the object we are positioned on
                   this will be used to check read security of the object.
                   NOTE: it is required that this security descriptor is
                   the one of the object that we are positioned on.
                
       Flags - One of the following:
               GETENTINF_FLAG_CAN_REORDER    - Don't need to preserve the order
                                               of the attributes specified by 
                                               the caller.
               GETENTINF_FLAG_DONT_OPTIMIZE  - ?
               GETENTINF_GC_ATTRS_ONLY       - Return only GC attributes.
               GETENTINF_IGNORE_DUPS         - Don't waste time removing duplicates
                                               attributes.
               GETENTINF_NO_SECURITY         - Don't apply security.

Return Value.
       Returns 0 on success, an error code otherwise.

--*/
{
    THSTATE             *pTHS = pDB->pTHS;
    ATTRBLOCK           AttrBlock;
    ULONG               i, k, cInAtts, attrCount, vallen;
    ATTCACHE            **rgpAC = NULL, **fullACList = NULL, **attList = NULL;
    ATTCACHE            **rgpACTemp = NULL;
    DWORD               fFlags, fNameFlags;
    DWORD               iType;
    DWORD               *piType=&iType;
    CLASSCACHE          *pCC = NULL;
    ATTCACHE            *pObjclassAC = NULL;
    ATTRTYP             *pObjClasses = NULL;
    CLASSCACHE          **ppObjClassesCC = NULL, *pTempCC;
    DWORD               cObjClasses, cObjClasses_alloced;
    BOOL                fDoSecCheck;
    DWORD               nSelAttrs = 0;
    BOOL                fGetAll = FALSE;
    BOOL                fGetAllWithList = FALSE;
    BOOL                fMaintainOrder = FALSE;
    BOOL                fGcAttsOnly = FALSE;
    BOOL                fHaveAuxClass = FALSE;
    BOOL                fIgnoreDups;
    PDWORD              pOrderIndex = NULL;
    DWORD               classid = INVALID_ATT;
    DWORD               err;
    DSTIME              TimeToDie;
    PINDEXED_AC         pIndexAC = NULL;


    if(pTHS->fDSA ||
       pTHS->fDRA ||
       Flags & GETENTINF_NO_SECURITY) {
        fDoSecCheck = FALSE;
    }
    else {
        fDoSecCheck = TRUE;
    }

    //
    // See if we should ignore nonGC attributes
    //

    fGcAttsOnly = (BOOL)(Flags & GETENTINF_GC_ATTRS_ONLY);
    fIgnoreDups = (BOOL)(Flags & GETENTINF_IGNORE_DUPS);

    // First, decide what form of values we want.
    fNameFlags = 0;

    if( pSel == NULL ) {
        fFlags = DBGETMULTIPLEATTS_fEXTERNAL;
        fGetAll = TRUE;

    } else {
        switch(pSel->infoTypes) {
          case EN_INFOTYPES_TYPES_MAPI:
            // Return no values, just type information, and return the obj name
            // in MAPI format
            fNameFlags |= DBGETATTVAL_fMAPINAME;
            fFlags = 0;
            SecurityDescriptorFlags = 0;
            break;

          case EN_INFOTYPES_TYPES_ONLY:
            // Return no values, just type information
            fFlags = 0;

            // we don't care for SD flags, since we are not getting back any data
            // this prevents assert firing in DBGetMultipleAtts
            SecurityDescriptorFlags = 0;  
            break;

          case EN_INFOTYPES_SHORTNAMES:
            // Return values in internal format.
            fFlags = DBGETMULTIPLEATTS_fSHORTNAMES | DBGETMULTIPLEATTS_fEXTERNAL;
            fNameFlags |= DBGETATTVAL_fSHORTNAME;
            break;

          case EN_INFOTYPES_MAPINAMES:
            // Return values in internal format.
            fFlags = DBGETMULTIPLEATTS_fMAPINAMES | DBGETMULTIPLEATTS_fEXTERNAL;
            fNameFlags |= DBGETATTVAL_fMAPINAME;
            break;

          default:
            // Return values in normal external format.
            fFlags = DBGETMULTIPLEATTS_fEXTERNAL;
        }

        // If we are the DRA and we are asking for certain selections, we need to
        // tell the DBLayer that we dont want to get all ATTS.  The DBLayer knows
        // which ones to trim.

        switch ( pSel->attSel ) {

        case EN_ATTSET_ALL:
            fGetAll = TRUE;
            break;
        case EN_ATTSET_ALL_WITH_LIST:
            fGetAll = TRUE;
            fGetAllWithList = TRUE;
            nSelAttrs = pSel->AttrTypBlock.attrCount;
            break;

        case EN_ATTSET_ALL_DRA:     // fall through
        case EN_ATTSET_ALL_DRA_EXT:     // fall through
            fGetAll = TRUE;

        case EN_ATTSET_LIST_DRA:
        case EN_ATTSET_LIST_DRA_EXT:
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION;
            break;

        case EN_ATTSET_ALL_DRA_PUBLIC:     // fall through
            fGetAll = TRUE;

        case EN_ATTSET_LIST_DRA_PUBLIC:
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION;
            fFlags |= DBGETMULTIPLEATTS_fREPLICATION_PUBLIC;
            break;

        case EN_ATTSET_LIST:
            // intentionally do nothing
            break;

        default:
            Assert (!"Passed wrong value for pSel->attSel");
            break;
        }
    }

    if (NULL == pResObj) {
        // Get and set the DN
        if (i=DBGetAttVal(pDB,
                              1,
                              ATT_OBJ_DIST_NAME,
                              fNameFlags,
                              0,
                              &vallen,
                              (CHAR **)&pEnt->pName)) {
            DPRINT(2,"Problem retrieving DN attribute\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_DN,
                     szInsertSz(""),
                     szInsertUL(i),
                     NULL);

            return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_DN);
        }

        // instance type
        if(i=DBGetSingleValue(pDB,
                              ATT_INSTANCE_TYPE,
                              &iType,
                              sizeof(iType),
                              NULL)) {
            DPRINT(2, "Can't retrieve instance type\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_INSTANCE,
                     szInsertDN(pEnt->pName),
                     szInsertUL(i),
                     szInsertHex(DSID(FILENO, __LINE__)));

            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_CANT_RETRIEVE_INSTANCE);
        }
    }
    else {
        pEnt->pName = THAllocEx(pTHS, pResObj->pObj->structLen);
        memcpy(pEnt->pName,
               pResObj->pObj,
               pResObj->pObj->structLen);
        iType = pResObj->InstanceType;
    }

    pEnt->ulFlags = 0;
    if(iType & IT_WRITE) {
        pEnt->ulFlags |= ENTINF_FROM_MASTER;
    }
    // For performance, this feature only available to the replicator.
    // You can remove the fDRA check when you need this flag.
    if ( (pTHS->fDRA) &&
         (DBGetSingleValue(pDB,
                           ATT_MS_DS_ENTRY_TIME_TO_DIE,
                           &TimeToDie,
                           sizeof(TimeToDie),
                           NULL) == 0) ) {
        pEnt->ulFlags |= ENTINF_DYNAMIC_OBJECT;
    }

    if (fGetAll) { // also fGetAllWithList

        // we have to read all the attributes available on the object
        // this might include attributes contributed by the possible
        // auxClasses attached to the object
        // we will propably use these attributes later to do a security check
        // if fDoSecCheck is set

        // get the needed information for the objectClass on this object
        if (! (pObjclassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS)) ) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get auxClass .
        }

        cObjClasses_alloced = 0;

        if (ReadClassInfoAttribute (pDB,
                                    pObjclassAC,
                                    &pObjClasses,
                                    &cObjClasses_alloced,
                                    &cObjClasses,
                                    &ppObjClassesCC) ) {
            return pTHS->errCode;
        }

        if (!cObjClasses) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
            // Bad error, couldn't get class data.
        }

        classid = pObjClasses[0];
        pCC = ppObjClassesCC[0];

        // we had an auxClass. leave only the most specific classes
        if (cObjClasses > pCC->SubClassCount + 1) {

            fHaveAuxClass = TRUE;

            // NOTICE-2002/04/05-andygo:  order of class ids in objectClass and aux classes
            // REVIEW:  the multivalues in objectClass are arranged as follows:
            // REVIEW:  first is the most specific object class followed by its sub
            // REVIEW:  classes (but not including top);  next comes any aux classes
            // REVIEW:  that have been added to this object;  finally comes top.  so
            // REVIEW:  in order to walk the aux classes, you must skip
            // REVIEW:  1 + (pCC->SubClassCount - 1) classes and then walk every
            // REVIEW:  class except for top (up to cObjClasses - 1).  Note that the
            // REVIEW:  order of the attributes is somehow reversed by the time they
            // REVIEW:  are displayed in LDP so don't let this confuse you.  They
            // REVIEW:  are definitely in this order in the database
            for (i=pCC->SubClassCount; i<cObjClasses-1; i++) {

                if (ppObjClassesCC[i]==NULL)
                    continue;

                for (k=pCC->SubClassCount; k<cObjClasses-1; k++) {
                    if ((i==k) || (ppObjClassesCC[k]==NULL)) {
                        continue;
                    }

                    if (pTempCC = FindMoreSpecificClass(ppObjClassesCC[i], ppObjClassesCC[k])) {
                        if (pTempCC == ppObjClassesCC[i]) {
                            ppObjClassesCC[k] = NULL;
                        }
                        else {
                            ppObjClassesCC[i] = NULL;
                            break;
                        }
                    }
                }
            }

            // we might have gaps in the ppAuxClassesCC, but we don't care

            // we are not interested in preserving the cache
            // since we are using auxClasses
            CachedAC = NULL;
        }
    }
    else if ( fDoSecCheck ) {

        // They are applying a security check (without specifying all, all+list) 
        // We don't have to generate the full list of attributes contributed 
        // by auxClasses and the list of attributes from the structural class
        // is enough.  So we need to get the class of  the object we are on.

        if (pResObj) {
            classid = pResObj->MostSpecificObjClass;
        } else if (DBGetSingleValue(pDB,
                            ATT_OBJECT_CLASS,
                            &classid, sizeof(classid),
                            NULL)) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
        }
        if (!(pCC = SCGetClassById(pTHS, classid))) {
            return SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_MISSING_EXPECTED_ATT);
        }
    }

    // Do this now, since we might bail out in the next if statement.
    pEnt->AttrBlock.attrCount = 0;

    //
    // If the caller passed us an attribute array, use it. Copy the saved copy to
    // the scratch copy.  The scratch copy may be changed by CheckReadSecurity()
    //

    if ( (CachedAC != NULL) && (CachedAC->AC != NULL) ) {

        if ( CachedAC->classId == classid ) {

            cInAtts = CachedAC->nAtts;
            rgpAC = (ATTCACHE**)((PCHAR)CachedAC->AC + cInAtts * sizeof(ATTCACHE*));

            CopyMemory(rgpAC, CachedAC->AC, cInAtts * sizeof(ATTCACHE*));

            pOrderIndex = CachedAC->pOrderIndex;
            goto have_array;
        } else {

            if (CachedAC->pOrderIndex) {
                THFreeEx(pTHS, (PINDEXED_AC)CachedAC->pOrderIndex - CachedAC->nAtts);
            }
            THFreeEx(pTHS,CachedAC->AC);
            CachedAC->AC = NULL;
        }
    }

    // Set up the the pInCols based on the pSel
    // first determine if we need to retrieve all attributes or a selection

    if ( fGetAll ) {

        DWORD ourCount;
        DWORD sizeAlloc;
        DWORD auxCount = 0;

        // Client did not provide an entifsel with explicitly listed atts.
        // or provided a list in addition to specifying all

        // Retrieve all attributes

        if ( fDoSecCheck || fGetAllWithList ) {

            ULONG j=0;

            Assert(pCC != NULL);

            // We need to apply security, so instead of sending a null list
            // of attcache pointers to DBGetMultipleAtts, read the class of the
            // current object, get the classcache object describing it, then
            // build the attcache array for all possible attributes.

            if (fHaveAuxClass) {

                for (i=pCC->SubClassCount; i<cObjClasses-1; i++) {
                    if (ppObjClassesCC[i]) {
                        auxCount += ppObjClassesCC[i]->MayCount + ppObjClassesCC[i]->MustCount;
                        DPRINT2 (1, "AuxClasses[%d]: %s\n", i, ppObjClassesCC[i]->name);
                    }
                }
            }

            sizeAlloc = (pCC->MayCount + pCC->MustCount + nSelAttrs + auxCount) * sizeof(ATTCACHE *);

            if ( CachedAC != NULL ) {
                //
                // Allocate a scratch and a copy buffer.
                //

                sizeAlloc *= 2;
            }

            rgpAC = (ATTCACHE **) THAllocEx(pTHS,sizeAlloc);
            
            // Do we have an auxClass ?
            //

            if (!fHaveAuxClass) {

                attList = SCGetTypeOrderedList (pTHS, pCC);

                if (!attList) {
                    // NTRAID#NTRAID-596530-2002/04/05-andygo:  GetEntInf has misc minor memory leaks
                    // REVIEW:  rgpAC is leaked on error return
                    return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR);
                }

                // maximum count of attributes for this class
                ourCount = pCC->MayCount + pCC->MustCount;

                j = 0;

                for(i=0;i<ourCount;i++) {

                    // defunct attributes are not returned
                    if (!attList[i]) {
                        continue;
                    }

                    if(attList[i]->bIsOperational) {
                        // These attributes are not returned unless explicitly asked
                        // for.  In this branch of the code, we know that an
                        // explicit list was not supplied.
                        continue;
                    }

                    // Check:
                    // If request came in through GC port make sure
                    // this is in the GC partial attribute list.
                    // Since j is already incremented, the attcache of
                    // of interest is pointed to by j-1

                    else if ( (attList[i]->bIsConstructed ) ||
                         (fGcAttsOnly && !IS_GC_ATTRIBUTE(attList[i])) ) {
                        
                        // GCport and not GC attribute. 
                        // Should not be passed down

                        continue;
                    }

                    else {
                        rgpAC[j] = attList[i];
                        j++;
                    }
                }

                cInAtts = j;

                //
                // Did the caller piggy backed a list?
                //

                if (nSelAttrs != 0) {

                    DWORD ret;

                    Assert(nSelAttrs == pSel->AttrTypBlock.attrCount);

                    if ( (ret = AppendAttrFromSel(pTHS,
                                                  pSel,
                                                  pEnt,
                                                  rgpAC,
                                                  cInAtts,
                                                  TRUE,
                                                  fIgnoreDups)) != 0 ) {

                        THFreeEx(pTHS,rgpAC);
                        return ret;
                    }

                    // Count up the atts
                    for (j = 0; rgpAC[j] != NULL; j++);

                    cInAtts = j;
                }

                Assert(cInAtts <= (pCC->MayCount + pCC->MustCount + nSelAttrs));
            }
            else {
                //
                // Did the caller piggy backed a list?
                //

                if (nSelAttrs != 0) {
                    // Populate the ATTCACHE list from the Sel list
                    //
                    cInAtts = pSel->AttrTypBlock.attrCount;

                    if ( (err = GetAttrFromSel(pTHS, pSel, pEnt, rgpAC, &cInAtts, FALSE)) != 0 ) {

                        THFreeEx(pTHS,rgpAC);
                        return err;
                    }

                    if (!IsACListSorted(rgpAC, cInAtts)) {
                        qsort(rgpAC, cInAtts, sizeof(rgpAC[0]), CmpACByAttType);
                    }
                }
                else {
                    cInAtts = 0;
                }

                // start the loop with using the current class
                pTempCC = pCC;
                k = pCC->SubClassCount;    // loop counter for auxClasses

                rgpACTemp = THAllocEx(pTHS, sizeAlloc);

                while (pTempCC != NULL) {
                    j = cInAtts;

                    attList = SCGetTypeOrderedList (pTHS, pTempCC);

                    if (!attList) {
                        THFreeEx(pTHS,rgpAC);
                        // NTRAID#NTRAID-596530-2002/04/05-andygo:  GetEntInf has misc minor memory leaks
                        // REVIEW:  rgpACTemp is leaked on error return
                        return SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR);
                    }

                    // maximum count of attributes for this class
                    ourCount = pTempCC->MayCount + pTempCC->MustCount;

                    for(i=0;i<ourCount;i++) {

                        // defunct attributes are not returned
                        if (!attList[i]) {
                            continue;
                        }

                        if(attList[i]->bIsOperational) {
                            // These attributes are not returned unless explicitly asked
                            // for.  In this branch of the code, we know that an
                            // explicit list was not supplied.
                            continue;
                        }

                        // Check:
                        // If request came in through GC port make sure
                        // this is in the GC partial attribute list.
                        // Since j is already incremented, the attcache of
                        // of interest is pointed to by j-1

                        else if ( (attList[i]->bIsConstructed ) ||
                             (fGcAttsOnly && !IS_GC_ATTRIBUTE(attList[i])) ) {

                            // GCport and not GC attribute. 
                            // Should not be passed down

                            continue;
                        }

                        else {
                            // if client has piggy backed a list, we are goint to insert them
                            // to this array later, otherwise we can finish up now.
                            rgpAC[j] = attList[i];
                            j++;
                        }
                    }

                    if (cInAtts == 0) {
                        cInAtts = j;
                    }
                    if (!fIgnoreDups && (0 != (j - cInAtts))) {
                        ATTCACHE **tmp;
                        MergeSortedACLists(pTHS,
                                           rgpAC,
                                           cInAtts,
                                           rgpAC + cInAtts,
                                           j - cInAtts,
                                           rgpACTemp,
                                           &cInAtts
                                           );
                        //
                        // swap the temp and the working copy of the AC list.
                        //
                        tmp = rgpAC; rgpAC = rgpACTemp; rgpACTemp = tmp;
                    }
                    
                    // find the next auxClass to use
                    if (k < cObjClasses-1) {
                        while (k<cObjClasses-1) {
                            if (pTempCC = ppObjClassesCC[k++]) {
                                break;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }


                if (!fIgnoreDups) {
                    RemoveDuplicatesFromAttCache(rgpAC, cInAtts);
                }
                THFreeEx(pTHS, rgpACTemp); rgpACTemp = NULL;
            }
        }
        else {
            // We are not applying any security, just send a null list of
            // attcache pointers.
            cInAtts = 0;
        }
    }
    else {
        // Client provided an entifsel with explicitly listed atts.

        // allocate ATTCACHE structures for all selected attributes  and
        // get schema cache entry for attribute

        DWORD ret;
        DWORD sizeAlloc = pSel->AttrTypBlock.attrCount * sizeof(ATTCACHE*);
        PVOID buffer;

        if ( CachedAC != NULL ) {
            //
            // Allocate for the saved and scratch
            //

            sizeAlloc *= 2;
        }

        rgpAC = (ATTCACHE**)THAllocEx(pTHS,sizeAlloc);
        
        cInAtts = pSel->AttrTypBlock.attrCount;

        //
        // Populate the ATTCACHE list from the Sel list
        //

        if ( (ret = GetAttrFromSel(pTHS, pSel, pEnt, rgpAC, &cInAtts, FALSE)) != 0 ) {
            THFreeEx(pTHS,rgpAC);
            return ret;
        }

        if(cInAtts == 0) {
            // We're not looking for anything, we might as well bail out.
            THFreeEx(pTHS,rgpAC);
            return 0;
        }
        //
        // Sort it
        //

        if ( cInAtts > 1 && !fIgnoreDups) {

            //
            // if CAN_REORDER flag is set, then forget about creating an index.
            //

            if (Flags & GETENTINF_FLAG_CAN_REORDER) {

                qsort(rgpAC, cInAtts, sizeof(rgpAC[0]), CmpACByAttType);
            } else if ( (Flags & GETENTINF_FLAG_DONT_OPTIMIZE) == 0) {

                //
                // The caller wants the index preserved, we need to allocate an
                // index array that will help us reorder the results back.
                //

                pIndexAC = (PINDEXED_AC)THAllocEx(pTHS,
                        cInAtts * (sizeof(DWORD) + sizeof(INDEXED_AC)));

                pOrderIndex =
                    (PDWORD)((PCHAR)pIndexAC + cInAtts * sizeof(INDEXED_AC));

                //
                // Copy the attcache array to a temp buffer for sorting. This
                // enables us to sort both array and index at the same time.
                // we use the index to reorder the result to the original order.
                //

                for (i=0;i < cInAtts; i++) {

                    pIndexAC[i].Index = i;
                    pIndexAC[i].AttCache = rgpAC[i];
                }

                qsort(pIndexAC, cInAtts, sizeof(INDEXED_AC), CmpIndexedACByAttType);

                //
                // ok, copy the index to return to the user
                //

                for (i=0;i < cInAtts; i++) {
                    pOrderIndex[i] = pIndexAC[i].Index;
                    rgpAC[i] = pIndexAC[i].AttCache;
                }
            }
            RemoveDuplicatesFromAttCache(rgpAC, cInAtts);
        }
    }

    //
    // Send this back to the caller so they can use it to call us again
    // Make a saved copy since CheckReadSecurity() might modify the array.
    //

    if ( (CachedAC != NULL) && (cInAtts > 0) ) {
        Assert(CachedAC->AC == NULL);
        CachedAC->AC = rgpAC;
        CachedAC->classId = classid;
        rgpAC = (ATTCACHE**)((PCHAR)CachedAC->AC + cInAtts * sizeof(ATTCACHE*));
        CopyMemory(rgpAC, CachedAC->AC, cInAtts * sizeof(ATTCACHE*));
        CachedAC->nAtts = cInAtts;
        CachedAC->pOrderIndex = pOrderIndex;
    }

have_array:

    // now read all the relevant columns from the record

    if ( fDoSecCheck ) {
        // We need to trim the atts we are asking for based on security
        CheckReadSecurity(pTHS,
                          SecurityDescriptorFlags,
                          pSecurity,
                          pEnt->pName,
                          pCC,
                          psidQuotaTrustee,
                          &cInAtts,
                          rgpAC);
    }

    if (i=DBGetMultipleAtts2(pDB,
                            cInAtts,
                            rgpAC,
                            pSelRange,
                            pRange,
                            &AttrBlock.attrCount,
                            &AttrBlock.pAttr,
                            fFlags,
                            SecurityDescriptorFlags,
                            psidQuotaTrustee)) {

        DPRINT(1,"GetEntInf: Error in GetMultipleAtts\n");
        if (!CachedAC) THFreeEx(pTHS,rgpAC);
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_CANT_RETRIEVE_ATTS, i);
    }

    //
    // Do we need to reorder the result?
    //

    if ( (pOrderIndex != NULL) &&
         (AttrBlock.attrCount > 1) ) {

        DWORD j;
        ATTR * pTmpAttr = THAllocEx(pTHS,cInAtts * sizeof(ATTR));

        Assert(AttrBlock.attrCount <= cInAtts);
        FillMemory(pTmpAttr, cInAtts * sizeof(ATTR), 0xFF);

        for (i=0, j=0; (i < cInAtts) && (j < AttrBlock.attrCount) ; i++) {

            if ( (rgpAC[i] != NULL) &&
                 (rgpAC[i]->id == AttrBlock.pAttr[j].attrTyp) ) {

                CopyMemory(&pTmpAttr[pOrderIndex[i]],
                           &AttrBlock.pAttr[j],
                           sizeof(ATTR));

                j++;
            }
        }

        //
        // ok, copy the entries from the tmp array back to the AttrBlock buffer
        //

        for (i=0,j=0;i<cInAtts;i++) {

            if ( pTmpAttr[i].attrTyp != 0xFFFFFFFF ) {
                CopyMemory(
                       &AttrBlock.pAttr[j],
                       &pTmpAttr[i],
                       sizeof(ATTR));

                Assert(j < AttrBlock.attrCount);
                j++;
            }
        }
        Assert(j == AttrBlock.attrCount);
        THFreeEx(pTHS,pTmpAttr);
    }

    // initialize the entinf
    pEnt->AttrBlock = AttrBlock;
    if (!CachedAC) {
        THFreeEx(pTHS, rgpAC);
        THFreeEx(pTHS, pIndexAC);
    }
    return 0;
} /*GetIntInf*/

int
LocalRead (
        THSTATE *pTHS,
        READARG *pReadArg,
        READRES *pReadRes
        )
     /*++
       Get the selected attributes and optionally, their values from the current
       object.  If no attributes were found, return an error.
       --*/
{
    ULONG ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD       getEntInfFlags = 0;
    RESOBJ      *pResObj;
    DWORD err;
    BOOL        fSDIsGlobalSDRef;

    PERFINC( pcTotalReads );
    INC_READS_BY_CALLERTYPE( pTHS->CallerType );

    // First, get the security descriptor for this object.
    // Don't bother if this is an internal read
    if (!(pTHS->fDSA || pTHS->fDRA)) {
        DBPOS* pDB = pTHS->pDB;
        char objFlag;
        err = DBGetObjectSecurityInfo(
                pDB,
                pDB->DNT,
                &ulLen,
                &pSec,
                NULL,
                NULL,
                &objFlag,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                &fSDIsGlobalSDRef
            );

        if (err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        // Every object should have an SD.
        Assert(objFlag == 0 || ulLen > 0);
    }

    //
    // Can we reorder entries
    //

    SvccntlFlagsToGetEntInfFlags(&pReadArg->CommArg.Svccntl,&getEntInfFlags);

    if ((pReadArg->pResObj->pObj->NameLen)
        || (pReadArg->pSel->infoTypes  == EN_INFOTYPES_SHORTNAMES)) {
        // If we already have a good enough object name, don't fetch another
        pResObj = pReadArg->pResObj;
    }
    else {
        pResObj = NULL;
    }

    if (GetEntInf(pTHS->pDB,
                  pReadArg->pSel,
                  pReadArg->pSelRange,
                  &pReadRes->entry,
                  &pReadRes->range,
                  pReadArg->CommArg.Svccntl.SecurityDescriptorFlags,
                  pSec,
                  getEntInfFlags,
                  NULL,
                  pResObj)) {
        if (!fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pSec);
        }
        return (pTHS->errCode);
    }

    // it is an error if the user requested a list of attributes and none
    // where found. If a 0 list was requested, this is an O.K. existance test

    if (!fSDIsGlobalSDRef) {
        THFreeEx(pTHS, pSec);
    }

    if (pReadRes->entry.AttrBlock.attrCount == 0 && pReadArg->pSel &&
        pReadArg->pSel->AttrTypBlock.attrCount > 0){
        ULONG u;

        DPRINT(2,"No user sel atts found .PR_PROBLEM_NO_ATTRIBUTE_OR_VAL\n");

        for (u = 0; u < pReadArg->pSel->AttrTypBlock.attrCount; u++) {
            SetAttError(pReadArg->pObject,
                pReadArg->pSel->AttrTypBlock.pAttr[u].attrTyp,
                PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                NULL,
                DIRERR_NO_REQUESTED_ATTS_FOUND);
        }
    }

    return pTHS->errCode;

}/*LocalRead*/


VOID
SvccntlFlagsToGetEntInfFlags(
    IN  SVCCNTL* Svccntl,
    OUT PDWORD Flags
    )
{
    if ( !Svccntl->fMaintainSelOrder ) {
        *Flags = GETENTINF_FLAG_CAN_REORDER;
    } else if (Svccntl->fDontOptimizeSel) {
        *Flags = GETENTINF_FLAG_DONT_OPTIMIZE;
    }

    //
    // if request came in through GC port, get only GC attributes
    //

    if (Svccntl->fGcAttsOnly) {
        *Flags |= GETENTINF_GC_ATTRS_ONLY;
    }

    return;
} // SvccntlFlagsToGetEntInfFlags


BOOL
IsACListSorted(
    IN ATTCACHE  **rgpAC,
    IN DWORD       cAtts
    )
/*++

Function Description:
       Checks a list of ATTCACHE pointers to see if it is already sorted.
       
Arguments:
       rgpAC - The list of ATTCACHE pointers to be checked.
       
       cAtts - A count of the ATTCACHE pointers in rgpAC
       
Return Value.
       Returns TRUE if the list is sorted, FALSE if not.
       
--*/
{
    unsigned i;

    for (i = 0; i<cAtts - 1; i++) {
        if (rgpAC[i]->id > rgpAC[i+1]->id) {
            return FALSE;
        }
    }
    return TRUE;
}


VOID
MergeSortedACLists(
    IN  THSTATE    *pTHS,
    IN  ATTCACHE  **rgpAC1,
    IN  DWORD       cAtts1,
    IN  ATTCACHE  **rgpAC2,
    IN  DWORD       cAtts2,
    IN OUT ATTCACHE **rgpACOut,
    OUT DWORD      *pcAttsOut
    )
/*++

Function Description:
       Merges to sorted lists of ATTCACHE arrays.
              
Arguments:
       rgpAC1, rgpAC2 - The lists of ATTCACHE pointers to be merged.
       
       cAtts1, cAtts2 - A count of the ATTCACHE pointers in the respective list.
       
       rgpACOut - A buffer that must be larger enough to hold both input lists.
                  This is where the merged list will be placed.
                  
       pcOutAtts - Where the size of the merged list is returned.
       
Return Value.

       n/a       
--*/
{
    ATTCACHE   **rgpACIndirect = NULL;
    unsigned   pos1 = 0, pos2 = 0, outPos = 0;
    int        cmp;

    *pcAttsOut = 0;

    for (;;) {
        cmp = CmpACByAttType(&rgpAC1[pos1], &rgpAC2[pos2]);
        if (cmp > 0) {
            rgpACOut[outPos++] = rgpAC2[pos2++];
            if (pos2 == cAtts2) {
                break;
            }
        } else if (cmp < 0) {
            rgpACOut[outPos++] = rgpAC1[pos1++];
            if (pos1 == cAtts1) {
                break;
            }
        } else {
            rgpACOut[outPos++] = rgpAC2[pos2++];
            pos1++;
            if (pos1 == cAtts1 || pos2 == cAtts2) {
                break;
            }
        }
    }

    //
    // One of the input lists has run out of elements.  Copy the rest
    // of the other list over.
    //
    if (pos1 == cAtts1) {
        rgpACIndirect = rgpAC2;
        pos1 = pos2;
        cAtts1 = cAtts2;
    } else {
        rgpACIndirect = rgpAC1;
    }
    while (pos1 < cAtts1) {
        rgpACOut[outPos++] = rgpACIndirect[pos1++];
    }

    *pcAttsOut = outPos;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdnotify.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdnotify.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsctr.h>

// Core DSA headers.
#include <ntdsa.h>
#include <filtypes.h>
#include <scache.h>               // schema cache
#include <dbglobal.h>             // The header for the directory database
#include <mdglobal.h>             // MD global definition header
#include <mdlocal.h>              // MD local definition header
#include <dsatools.h>             // needed for output allocation
#include <samsrvp.h>              // to support CLEAN_FOR_RETURN()
#include <lht.h>                  // hash table
#include <sync.h>                 // sync library

// Logging headers.
#include "dsevent.h"              // header Audit\Alert logging
#include "mdcodes.h"              // header for error codes

// Assorted DSA headers.
#include "objids.h"               // Defines for selected classes and atts
#include "anchor.h"
#include "drautil.h"
#include "drserr.h"
#include "dsaapi.h"
#include "dsexcept.h"
#include "drsuapi.h"
#include "debug.h"                // standard debugging header
#include "dsconfig.h"             // Needed for default replication delays
#define DEBSUB "MDNOTIFY:"        // define the subsystem for debugging

#include <drancrep.h>
#include <fileno.h>
#define  FILENO FILENO_MDNOTIFY
#include <dsutil.h>                     // Tick time routines

extern SCHEMAPTR *CurrSchemaPtr;

/*
 * Data for DirNotify support
 */
// The source of hServer handles, only to be updated when a write lock is
// held on the MonitorList
ULONG ghDirWaitCur = 0;

// A reader/writer lock to control access to the Monitor List
SYNC_RW_LOCK rwlDirNotify;

// Hash table that contains the Monitor List
PLHT plhtMon = NULL;

// The head of the global Notify Queue
DirNotifyItem * gpDirNotifyQueue = NULL;

// A critical section serializing all access to the Notify Queue.  Holders
// of the monitor list resource may claim this critical section, but not
// vice versa
CRITICAL_SECTION csDirNotifyQueue;

// An event that is triggered whenever new items are inserted into the
// notify queue
HANDLE hevDirNotifyQueue;

// A pair of variables used for serialization of removal of items from the
// monitor list, which also implies purging references from the notify queue.
// gpInUseWait points to the WaitList item that is currently being processed
// by the notify thread.  gfDeleteInUseWait is set by deregistration code to
// indicate to the notify thread that when it is done processing its current
// item (i.e., *gpInUseWait), it should free that item.  Both of these
// variables may only be written or read when csDirNotifyQueue is held.
DirWaitItem * volatile gpInUseWait = NULL;
volatile BOOL gfDeleteInUseWait = FALSE;
/*
 * end of DirNotify support
 */


/* PAUSE_FOR_BURST - wait this many seconds after noting a change in an NC
        before informing DSAs with replicas. We do this so that a
        burst of changes at the master will not cause a flood of update
        notifications. This value is set from the registry at startup
*/

int giDCFirstDsaNotifyOverride = -1;

/* PAUSE_FOR_REPL - wait this many seconds after notifying a DSA of a change
        in an NC before notifying another. We do this to give the first DSA a
        chance to get the changes before the next DSA attempts to do the same.
        This value is set from the registry at startup
*/

int giDCSubsequentDsaNotifyOverride = -1;

// Notify element.
// This list is shared between the ReplicaNotify API and the ReplNotifyThread.
// The elements on this list are fixed size.
// NC's to be notified are identified by NCDNT

typedef struct _ne {
    struct _ne *pneNext;
    ULONG ulNcdnt;          // NCDNT to notify
    DWORD dwNotifyTime;     // Time to send notification
    BOOL fUrgent;           // Notification was queued urgently
} NE;

/* pneHead - points to head of notification list.
*/
NE *pneHead = NULL;

// Internal list of DSA's to notify
// These elements are variable length.
// Appended are a number of MTX elements in one contiguous chunk.

typedef struct _mtxe {
        LIST_ENTRY  ListEntry;
        BOOL urgent;
        BOOL writeable;
        UUID uuidDSA;
        MTX_ADDR mtxDSA;          // this must be the last field
                                  // this field is variable length
        } MTXE;

#define MTXE_SIZE( a ) FIELD_OFFSET( MTXE, mtxDSA )

/* csNotifyList - guards access to the notification list and to
   hReplNotifyThread. Only two routines access the notification list:

                NotifyReplicas - adds new entries to the list.

                ReplNotifyThread - removes items from the list and performs the
                        actual notification.

        this semaphore ensures they do not access the list at the same time.
*/
CRITICAL_SECTION csNotifyList;

/* hevEntriesInList - lets us know if there are entries in the list
   (signalled state) or if the list is empty (not-signalled state).
   It is atomatically reset whenever ReplNotifyThread falls through the
   WaitForSingleObject call, and set by NotifyReplicas (whenever it
   adds an entry to the notification list).
*/
HANDLE hevEntriesInList = 0;

/* hReplNotifyThread - Lets us know if the (one and only) ReplNotifyThread
   has been started yet. Once started the thread continues until shutdown,
   or at least it's supposed to.  If the value is NULL the thread hasn't
   been started.  If it's non-NULL then it's supposed to be a valid handle
   to the correct thread.  Its friend tidReplNotifyThread is filled in with
   the thread id at thread create time but is otherwise unused.  It's left
   as a global solely to help ease debugging.
   */
HANDLE  hReplNotifyThread = NULL;
DWORD   tidReplNotifyThread = 0;

#ifndef ARRAY_SIZE
#   define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif

void
ProcessNotifyEntry(
    IN NE * pne
    );

/* ReplNotifyThread - Waits for entries to appear in the notify list and then
*  sends notification messages to appropriate DSAs at appropriate time.
*
*  There is one notification thread in the DSA. It is created the first
*  time something is added to the notification list (by NotifyReplicas).
*/
unsigned __stdcall ReplNotifyThread(void * parm)
{
    ULONG   time;
    ULONG   ret;
    HANDLE  rgWaitHandles[] = {hevEntriesInList, hServDoneEvent};
    NE *    pne;

    // Users should not have to wait for this.  Even more, if we're so
    // busy that we can't spring a few cycles for this thread to run,
    // we don't *want* it to run, because all it's going to do is attract
    // more servers into bugging us for updates.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);

    time = (ULONG) INFINITE;     // Initially wait indefinitely

    while (!eServiceShutdown && !DsaIsSingleUserMode()) {
        __try {   // Exception handler
            // Wait until there are new entries in the notification list, the
            // items in the list already are ready, or shutdown has been
            // initiated.
            WaitForMultipleObjects(ARRAY_SIZE(rgWaitHandles), rgWaitHandles,
                                   FALSE, time);
            if (eServiceShutdown || DsaIsSingleUserMode()) {
                __leave;
            }

            // Is it time to generate a notification?
            EnterCriticalSection(&csNotifyList);
            __try {
                pne = pneHead;

                if ((NULL != pneHead)
                    && (CompareTickTime( pneHead->dwNotifyTime,GetTickCount()) != 1)) {
                    // Dequeue this entry for processing.
                    pne = pneHead;
                    pneHead = pneHead->pneNext;
                }
                else {
                    // No entry to process now.
                    pne = NULL;
                }
            }
            __finally {
                LeaveCriticalSection(&csNotifyList);
            }

            if (eServiceShutdown) {
                __leave;
            }

            if (NULL != pne) {
                ProcessNotifyEntry(pne);
                free(pne);
            }

            if (eServiceShutdown) {
                __leave;
            }

            // Set time to wait, either indefinitely if list is empty,
            // or until next item will be ready if list is non-empty.
            time = (ULONG) INFINITE;

            EnterCriticalSection(&csNotifyList);
            __try {
                if (pneHead != NULL) {
                    DWORD timeNow = GetTickCount();

                    if (CompareTickTime(pneHead->dwNotifyTime,timeNow) == 1) {
                        time = DifferenceTickTime( pneHead->dwNotifyTime,timeNow);
                    }
                    else {
                        time = 0;       // Ready now, so wait no longer
                    }

                    // Time is in milliseconds
                }
            }
            __finally {
                LeaveCriticalSection(&csNotifyList);
            }
        }
        __except (GetDraException((GetExceptionInformation()), &ret)) {
            // Exception handler just protects thread.
            ;
        }
    } /* while (!eServiceShutdown) */

    return 0;
}

DWORD
ResolveReplNotifyDelay(
     // this should change to an enum if we ever get more repl vals.
    BOOL             fFirstNotify,
    DWORD *          pdwDBVal
    )
{
    DWORD            dwReplNotifyDelay;

    // First the repl delay is given the default value, depending on its type.
    if(fFirstNotify){
        dwReplNotifyDelay = DEFAULT_DRA_START_PAUSE;
    } else {
        dwReplNotifyDelay = DEFAULT_DRA_INTERDSA_PAUSE;
    }

    // Next if a DB value existed, then we use the DB value instead.
    if(pdwDBVal){
        dwReplNotifyDelay = *pdwDBVal;
    }

    // Finally check the registry, for a machine specific override.
    if(fFirstNotify){
        if(giDCFirstDsaNotifyOverride != INVALID_REPL_NOTIFY_VALUE){
            dwReplNotifyDelay = giDCFirstDsaNotifyOverride;
        }
    } else {
        if(giDCSubsequentDsaNotifyOverride != INVALID_REPL_NOTIFY_VALUE){
            dwReplNotifyDelay = giDCSubsequentDsaNotifyOverride;
        }
    }

    return(dwReplNotifyDelay);
}

DWORD
GetReplNotifyDelayByNC(
    BOOL                 fFirstNotify,
    NAMING_CONTEXT *     pNC
    )
{
    CROSS_REF_LIST *     pCRL;

    // BUGBUG PERFORMANCE it would be faster to get these variables were
    // intersted in, onto gAnchor.pMasterNC variables, so we'd walk the
    // master NC list instead of the crossref list.
    for(pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR){
        if(NameMatched(pCRL->CR.pNC, pNC)){
            if(fFirstNotify){
                return(pCRL->CR.dwFirstNotifyDelay);
            } else {
                return(pCRL->CR.dwSubsequentNotifyDelay);
            }
        }
    }

    // Uh-oh we don't have a CR for this NC, this is must be for a CR of
    // a domain that was removed, and hasn't been removed on a GC yet.
    if(fFirstNotify){
        return(DEFAULT_DRA_START_PAUSE);
    } else {
        return(DEFAULT_DRA_INTERDSA_PAUSE);
    }
}

DWORD
GetFirstDelayByNCDNT(
    ULONG                  NCDNT
    )
{
    NAMING_CONTEXT_LIST *  pNCL;

    pNCL = FindNCLFromNCDNT(NCDNT, FALSE);

    if (pNCL != NULL) {
        return(GetReplNotifyDelayByNC(TRUE, pNCL->pNC));
    }

    Assert(!"Uh oh we don't have a NC for the provided DNT!!!\n");
    return(DEFAULT_DRA_START_PAUSE);
}

void
ProcessNotifyEntry(
    IN NE * pne
    )
/*++

Routine Description:

    Notify DSAs that replicate from us via RPC of changes in a given NC.

Arguments:

    pne (IN) - Describes NC, urgency, etc. associated with this notification.

Return Values:

    None.

--*/
{
    THSTATE *       pTHS;
    DSNAME *        pNC;
    REPLICA_LINK *  pDSARepsTo;
    DBPOS *         pDB;
    ULONG           len;
    ULONG           cbmtxe;
    LIST_ENTRY      MtxList, *pEntry;
    MTXE *          pmtxe;
    BOOL            fCommit;
    ULONG           bufSize=0;
    ATTCACHE *      pAttRepsTo;
    ATTCACHE *      pAttObjDistName;
    ULONG           ret;
    ULONG           ulSubseqReplNotifyPause;
    ULONG           RepsToIndex = 0;

    pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    if (!pTHS) {
        RaiseDsaExcept(DSA_MEM_EXCEPTION, 0,0,
                       DSID(FILENO, __LINE__),
                       DS_EVENT_SEV_MINIMAL);
        //
        // PREFIX: This return will never be executed.  It is only here
        // to make PREFIX happy.
        //
        return;
    }
    pTHS->fIsValidLongRunningTask = TRUE;

    InterlockedIncrement((ULONG *)&ulcActiveReplicationThreads);

    __try {
        pAttRepsTo = SCGetAttById(pTHS, ATT_REPS_TO);
        pAttObjDistName = SCGetAttById(pTHS, ATT_OBJ_DIST_NAME);

        InitializeListHead(&MtxList);

        DBOpen(&pDB);
        __try {
            // Notify each of the DSAs keeping a replica. We
            // pause between each notification so we dont get
            // swamped by incoming replication requests.

            // Look at the repsto attribute on the NC prefix and notify
            // each DSA that has a replica.

            if (DBFindDNT(pDB, pne->ulNcdnt) ||
                !DBHasValues_AC(pDB, pAttRepsTo)) {
                __leave;
            }

            // Reconstruct DSNAME given NCDNT
            // Note, memory for pNC gets freed at end of loop
            if (ret = DBGetAttVal_AC(pDB, 1,
                                     pAttObjDistName,
                                     0, // alloc semantics
                                     0, &len,
                                     (UCHAR **)&pNC)) {
                DsaExcept(DSA_DB_EXCEPTION, ret, 0);
            }
            DPRINT2(2, "ReplNotifyThread: syncing DNT=0x%x, DS='%ws'!\n",
                    pne->ulNcdnt, pNC->StringName);

            // We can't just evaluate all the DSAs holding replicas
            // as we notify each, because we'd have the DB open too
            // long, so we build a list of the DSAs to notify.
            while (!DBGetAttVal_AC(pDB, ++RepsToIndex,
                                   pAttRepsTo,
                                   DBGETATTVAL_fREALLOC,
                                   bufSize, &len,
                                   (UCHAR **)&pDSARepsTo)) {
                bufSize = max(bufSize,len);

                VALIDATE_REPLICA_LINK_VERSION(pDSARepsTo);

                cbmtxe = MTXE_SIZE(pmtxe)
                         + MTX_TSIZE(RL_POTHERDRA(pDSARepsTo));

                // allocate memory for mtxe and save ptr in list
                pmtxe = THAllocEx(pTHS, cbmtxe);

                // copy in mtx
                memcpy(&(pmtxe->mtxDSA),
                       RL_POTHERDRA(pDSARepsTo),
                       pDSARepsTo->V1.cbOtherDra);
                pmtxe->writeable = pDSARepsTo->V1.ulReplicaFlags & DRS_WRIT_REP;
                pmtxe->urgent = pne->fUrgent;
                pmtxe->uuidDSA = pDSARepsTo->V1.uuidDsaObj;
                // Note that the last failure information is available in the reps-to
                // if we wanted to implement a retry backoff scheme

                // Put the writeable replicas at the head of the list so that they are
                // notified first. This helps reduce the chance that, if a system fails
                // permanently or is restored, a change only replicates to a GC and is
                // orphaned there.
                if (pmtxe->writeable) {
                    InsertHeadList(&MtxList, &pmtxe->ListEntry);
                } else {
                    InsertTailList(&MtxList, &pmtxe->ListEntry);
                }
            }

            if (bufSize) {
                THFreeEx(pTHS, pDSARepsTo);
                bufSize = 0;
            }

            //
            // Filter out DSAs whose ntdsDsa object doesn't exist
            // in the config container.
            // This is since otherwise I_DRSReplicaSync will fail & event will be logged
            // due to "No mutual auth."
            // Note: The KCC will remove an reps-to that is in the failure state for
            // more than 24 hours. See KCC::UpdateRepsToReferences.
            //
            for (pEntry = MtxList.Flink;
                 !eServiceShutdown && (pEntry != &MtxList);
                 pEntry = pEntry->Flink) {

                DSNAME  dsa;

                // reference entry
                pmtxe = CONTAINING_RECORD(pEntry, MTXE, ListEntry);

                // set dsname of dsa
                ZeroMemory(&dsa, sizeof(DSNAME));
                dsa.structLen = DSNameSizeFromLen(0);
                dsa.Guid = pmtxe->uuidDSA;

                Assert(!fNullUuid(&dsa.Guid));
                // try to find it
                ret = DBFindDSName(pDB, &dsa);

                if ( ret ) {
                    // didn't find it, rm from list & free.
                    pEntry = pEntry->Blink;
                    RemoveEntryList(&pmtxe->ListEntry);

                    // delete this one.
                    THFreeEx(pTHS, pmtxe);
                }
            }
        }
        __finally {
            DBClose(pDB, TRUE);
        }

        if (!IsListEmpty(&MtxList)) {
            // Having found all the DSAs, go through and notify them all

            ulSubseqReplNotifyPause = GetReplNotifyDelayByNC(FALSE, pNC);

            for (pEntry = MtxList.Flink;
                 !eServiceShutdown && (pEntry != &MtxList);
                 pEntry = pEntry->Flink) {

                LPWSTR pszServerName;

                // reference entry
                pmtxe = CONTAINING_RECORD(pEntry, MTXE, ListEntry);

                // get server name
                pszServerName = TransportAddrFromMtxAddrEx(&pmtxe->mtxDSA);

                DPRINT2( 3, "Notifying server %ws NC %ws.\n", pszServerName, pNC->StringName );

                ret = I_DRSReplicaSync(
                            pTHS,
                            pszServerName,
                            pNC,
                            NULL,
                            &gAnchor.pDSADN->Guid,
                            (   DRS_ASYNC_OP
                                | DRS_UPDATE_NOTIFICATION
                                | ( pmtxe->writeable ? DRS_WRIT_REP : 0 )
                                | ( pmtxe->urgent ? DRS_SYNC_URGENT : 0 )
                            ) );
                DPRINT1(3,"I_DRSReplicaSync ret=0x%x\n", ret);

                if (eServiceShutdown) {
                    break;
                }

                if ((DRAERR_NoReplica == ret) || (DRAERR_BadNC == ret)) {
                    // The notified DSA does not source this NC from us;
                    // remove our Reps-To.
                    DirReplicaReferenceUpdate(
                        pNC,
                        pszServerName,
                        &pmtxe->uuidDSA,
                        DRS_ASYNC_OP | DRS_DEL_REF );
                } else {
                    if (ret) {
                        // Log notification failure.
                        LogEvent8(DS_EVENT_CAT_REPLICATION,
                                  DS_EVENT_SEV_BASIC,
                                  DIRLOG_DRA_NOTIFY_FAILED,
                                  szInsertSz(pmtxe->mtxDSA.mtx_name),
                                  szInsertWC(pNC->StringName),
                                  szInsertWin32Msg( ret ),
                                  szInsertWin32ErrCode( ret ),
                                  NULL, NULL, NULL, NULL);
                    }

                    // Update the statistics fields of the repsTo.
                    // The KCC uses this error info to remove bad reps-to's
                    UpdateRepsTo(
                        pTHS,
                        pNC,
                        &pmtxe->uuidDSA,
                        &pmtxe->mtxDSA,
                        ret);
                }

                pEntry = pEntry->Blink;
                RemoveEntryList(&pmtxe->ListEntry);
                THFreeEx(pTHS, pmtxe);
                THFreeEx(pTHS, pszServerName);

                WaitForSingleObject(hServDoneEvent,
                                    ulSubseqReplNotifyPause*1000);
            }

            THFreeEx(pTHS, pNC);
        }
    }
    __finally {
        InterlockedDecrement((ULONG *)&ulcActiveReplicationThreads);
        free_thread_state();
    }
}

/*
 Description:

    NotifyReplicas - The object ulNcdnt has been modified, decided if any replicas
    must be notified. We search for the objects NC prefix, and look to see
    if there are any replicas  and if there are we add the name of the
    NC prefix to the notification list.

    Note that this routine is no longer called directly.  Instead it is called by
    dbTransOut when a transaction has committed.

    pneHead points to a list of notification entries, sorted by increasing entry time.

 Arguments:

    ulNcdnt - NCDNT to be notified
    fUrgent - urgent replication requested

 Return Values:

*/
void APIENTRY NotifyReplicas(
                             ULONG ulNcdnt,
                             BOOL fUrgent
                             )
{
    DBPOS *pDB;
    UCHAR syntax;
    BOOL fFound;
    NE *pne, *pnePrev;
    USHORT cAVA;
    ATTCACHE *pAC;
    THSTATE *pTHS;

    DPRINT2(1,"Notifyreplicas, Ncdnt=0x%x, Urgent Flag = %d\n", ulNcdnt, fUrgent);

    DBOpen2(FALSE, &pDB);
    pAC = SCGetAttById(pDB->pTHS, ATT_REPS_TO);
    __try
    {
        if (DBFindDNT(pDB, ulNcdnt) ||
            !DBHasValues_AC(pDB, pAC)) {
            // Ok, NC has no replicas
            __leave;
        }

        // Insert entry in the list, if it is not already present
        // List is sorted by notifytime, but keyed uniquely on NCDNT
        // An item may be marked urgent or not
        // When promoting an existing non-urgent item, delete the item
        // and reinsert it at its new time.

        DPRINT(4, "Entering csNotifyList\n");
        EnterCriticalSection(&csNotifyList);

        __try {

            // Pass 1: look for existing entry.

            pnePrev = NULL;
            pne = pneHead;
            fFound=FALSE;
            while (pne != NULL) {
                if (pne->ulNcdnt == ulNcdnt) {
                    if ( (fUrgent) && (!pne->fUrgent) ) {
                        // Found non-urgent entry, delete it
                        if (pnePrev == NULL) {
                            pneHead = pne->pneNext;
                        } else {
                            pnePrev->pneNext = pne->pneNext;
                        }
                        free(pne);
                        // entry is not found and will be readded
                    } else {
                        fFound = TRUE;
                    }
                    break;
                }
                pnePrev = pne;
                pne = pne->pneNext;
            }

            // Pass 2: Insert new entry in the ordered list (if not found)

            if (!fFound) {

                DWORD newNotifyTime;       // Time to send notification
                NE *pneNew;

                if (fUrgent) {
                    newNotifyTime = GetTickCount();  // now
                } else {
                    newNotifyTime = CalculateFutureTickTime( GetFirstDelayByNCDNT(ulNcdnt) * 1000 ); // convert to ms
                }

                // Find proper location in list
                // We are guaranteed an item with the ncdnt does not exist

                pnePrev = NULL;
                pne = pneHead;
                while (pne != NULL) {
                    if (CompareTickTime( newNotifyTime, pne->dwNotifyTime) == -1) {
                        break;
                    }
                    pnePrev = pne;
                    pne = pne->pneNext;
                }

                /* Allocate the Notify Element */

                pneNew = malloc(sizeof(NE));
		if (!pneNew) {
		    DRA_EXCEPT (DRAERR_OutOfMem, 0);
		}

                /* Set up fixed part of NE */
                pneNew->pneNext = pne;
                pneNew->ulNcdnt = ulNcdnt;
                pneNew->dwNotifyTime = newNotifyTime;
                pneNew->fUrgent = fUrgent;

                // Insert item at proper point

                if (pnePrev == NULL) {
                    pneHead = pneNew;
                } else {
                    pnePrev->pneNext = pneNew;
                }

                // A new entry is present

                SetEvent(hevEntriesInList);

                if (NULL == hReplNotifyThread) {

                    // Start notify thread

                    hReplNotifyThread = (HANDLE)
                      _beginthreadex(NULL,
                                     0,
                                     ReplNotifyThread,
                                     NULL,
                                     0,
                                     &tidReplNotifyThread);
                }

            } // if (!fFound)
            DPRINT(4, "Leaving csNotifyList\n");
       }
       __finally {
            LeaveCriticalSection(&csNotifyList);
       }
    }
    __finally
    {
       DBClose(pDB, TRUE);
    }
}

/* MonitorList: Theory and Practice
 *
 * The data structure referred to as the Monitor List is, conceptually, an
 * unordered list of object notification requests.  Each (successful) call
 * to DirNotifyRegister adds an entry to the Monitor List, and each call to
 * DirNotifyUnRegister removes an entry.  We need to have the ability to
 * quickly find all ML items that refer to a specific DNT or PDNT, so
 * instead of a simple list we use a linear hash table keyed on DNT, choice
 * and containing a list of DirWaitItems.
 */

SIZE_T
HashDirWaitKey(
    IN      DirWaitKey*     pKey
    )
{
    return pKey->DNT + pKey->choice;
}

BOOLEAN
DirWaitEntryMatchesDirWaitKey(
    IN      DirWaitEntry*   pEntry,
    IN      DirWaitKey*     pKey
    )
{
    if (pEntry->key.DNT == pKey->DNT &&
        pEntry->key.choice == pKey->choice) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*++ AddToMonitorList
 *
 * INPUT:
 *   pItem    - pointer to a filled out monitor list item
 *   choice   - the choice argument from the register request
 * OUTPUT:
 *   phServer - filled in with an opaque handle that can later be used
 *              to remove the item from the monitor list
 * RETURN VALUE:
 *   0        - success
 *   non-0    - failure, with pTHStls->errCode set.
 */
ULONG
AddToMonitorList(DirWaitItem *pItem,
                 DWORD *phServer)
{
    LHT_ERR         errLHT;
    DirWaitEntry    entry;
    LHT_POS         posLHT;

    Assert(!OWN_CRIT_SEC(csDirNotifyQueue));

    /* Obtain a write lock on the monitor list */
    SyncEnterRWLockAsWriter(&rwlDirNotify);
    __try {

        /* If the monitor hash doesn't exist yet then create it */
        if (!plhtMon) {
            errLHT = LhtCreate(sizeof( DirWaitEntry ),
                                (LHT_PFNHASHKEY)HashDirWaitKey,
                                (LHT_PFNHASHENTRY)HashDirWaitKey,
                                (LHT_PFNENTRYMATCHESKEY)DirWaitEntryMatchesDirWaitKey,
                                NULL,
                                0,
                                0,
                                NULL,
                                NULL,
                                0,
                                &plhtMon);
            if (errLHT != LHT_errSuccess) {
                Assert(errLHT == LHT_errOutOfMemory);
                SetSysError(ENOMEM, ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }
        }

        switch (pItem->choice) {
          case SE_CHOICE_BASE_ONLY:
            break;

          case SE_CHOICE_IMMED_CHLDRN:
            break;

          case SE_CHOICE_WHOLE_SUBTREE:
            break;

          default:
            SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,
                          DIRERR_UNKNOWN_OPERATION,
                          pItem->choice);
            __leave;
        }

        /* fetch the entry for this DNT and choice, if it exists
         */
        entry.key.DNT       = pItem->DNT;
        entry.key.choice    = pItem->choice;
        entry.pList         = NULL;
        
        (void)LhtFindEntry(plhtMon, &entry.key, &posLHT);
        errLHT = LhtRetrieveEntry(&posLHT, &entry);

        /* add this item to the list in the entry
         */
        Assert(entry.key.DNT == pItem->DNT);
        Assert(entry.key.choice == pItem->choice);
        
        pItem->pNextItem = entry.pList;
        entry.pList = pItem;

        /* update the entry
         */
        if (errLHT == LHT_errNoCurrentEntry) {
            errLHT = LhtInsertEntry(&posLHT, &entry);
        } else {
            errLHT = LhtReplaceEntry(&posLHT, &entry);
        }

        if (errLHT != LHT_errSuccess) {
            Assert(errLHT == LHT_errOutOfMemory);
            SetSysError(ENOMEM, ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        /* Allocate a new server operation handle
         * CONSIDER:  make this "allocation" more sophisticated
         */
        *phServer = pItem->hServer = ++ghDirWaitCur;

        INC(pcMonListSize);
        DPRINT2(2,
                "Registered type %d notification for object with DNT=0x%x\n",
                pItem->choice,
                pItem->DNT);
    }
    __finally {
        SyncLeaveRWLockAsWriter(&rwlDirNotify);
    }
    return pTHStls->errCode;
}

/*++ FreeWaitItem
 *
 * Takes a pointer to a filled in WaitItem and frees it and all subsidiary
 * data structures.  Simply here for convenience sake to keep callers
 * from having to remember which fields must be freed separately.
 *
 * INPUT:
 *   pWaitItem - pointer to item to be freed
 */
void FreeWaitItem(DirWaitItem * pWaitItem)
{
    if (pWaitItem->pSel->AttrTypBlock.attrCount) {
        Assert(pWaitItem->pSel->AttrTypBlock.pAttr);
        free(pWaitItem->pSel->AttrTypBlock.pAttr);
    }
    free(pWaitItem->pSel);
    free(pWaitItem);
}

/*++ PurgeWaitItemFromNotifyQueue
 *
 * This routine walks the notify queue and removes all elements that
 * refer to the specified wait item.
 *
 * INPUT:
 *  pWaitItem - pointer to the item to be purged
 * RETURN VALUE:
 *  none
 */
void PurgeWaitItemFromNotifyQueue(DirWaitItem * pWaitItem)
{
    DirNotifyItem * pList, **ppList;

    EnterCriticalSection(&csDirNotifyQueue);

    ppList = &gpDirNotifyQueue;
    pList = gpDirNotifyQueue;
    while (pList) {
        if (pList->pWaitItem == pWaitItem) {
            /* This notify queue element refers to our wait item.  Kill it */
            *ppList = pList->pNext;
            free(pList);
            pList = *ppList;
            DEC(pcNotifyQSize);
        }
        else {
            /* Not the droids we're looking for.  Move on. */
            ppList = &pList->pNext;
            pList = pList->pNext;
        }
    }

    /*
     * We've now removed all traces of the wait item from the notify queue.
     * Before we can free the wait item, though, we have to check to see if
     * is in use by a notification that is currently being processed.  If so,
     * leave a polite reminder to the notify thread to free the item for us.
     * If not, free it ourselves.
     */
    if (gpInUseWait == pWaitItem) {
        /* The wait item is in use.  Request that it be killed. */
        gfDeleteInUseWait = TRUE;
    }
    else {
        /* No one else refers to the item.  Kill it. */
        FreeWaitItem(pWaitItem);
    }

    LeaveCriticalSection(&csDirNotifyQueue);
}

/*++ RemoveFromMonitorList
 *
 * This routine removes a monitor list entry, identified by hServer,
 * from the monitor list.
 *
 * INPUT:
 *   hServer - handle of item to be removed
 * RETURN VALUE:
 *   0       - success
 *   non-0   - item was not found
 */
ULONG
RemoveFromMonitorList(DWORD hServer)
/*
 * returns TRUE if item not found
 */
{
    LHT_ERR         errLHT;
    DirWaitEntry    entry;
    LHT_POS         posLHT;
    DirWaitItem**   ppItem;
    DirWaitItem*    pItem;

    Assert(!OWN_CRIT_SEC(csDirNotifyQueue));
    SyncEnterRWLockAsWriter(&rwlDirNotify);

    /* If the monitor hash doesn't exist yet then the item is not found */
    if (!plhtMon) {
        SyncLeaveRWLockAsWriter(&rwlDirNotify);
        return 1;
    }

    /* Search the entire monitor table for this handle
     */
    LhtMoveBeforeFirst(plhtMon, &posLHT);
    while ((errLHT = LhtMoveNext(&posLHT)) == LHT_errSuccess) {
        
        errLHT = LhtRetrieveEntry(&posLHT, &entry);
        Assert(errLHT == LHT_errSuccess);

        ppItem = &entry.pList;
        while (*ppItem) {

            if ((*ppItem)->hServer == hServer) {

                /* remove its item from the table
                 */
                pItem = *ppItem;
                *ppItem = (*ppItem)->pNextItem;

                if (!entry.pList) {
                    errLHT = LhtDeleteEntry(&posLHT);
                    Assert(errLHT == LHT_errSuccess);
                } else {
                    errLHT = LhtReplaceEntry(&posLHT, &entry);
                    Assert(errLHT == LHT_errSuccess);
                }

                DEC(pcMonListSize);

                /* purge the item from the notify queue
                 */
                PurgeWaitItemFromNotifyQueue(pItem);
                SyncLeaveRWLockAsWriter(&rwlDirNotify);
                return 0;
            }

            ppItem = &(*ppItem)->pNextItem;
        }
    }

    /* we didn't find it
     */
    SyncLeaveRWLockAsWriter(&rwlDirNotify);
    return 1;
}

/*++ DirNotifyRegister
 *
 * Exported API that allows a caller to register for notifications on an
 * object (or to its children).  Notifications will be sent whenever the
 * object(s) are modified until a matched DirNotifyUnRegister call is made.
 *
 * INPUT:
 *   pSearchArg - details about the object(s) to be monitored
 *   pNotifyArg - details about how the notification is to be done
 * OUTPUT:
 *   ppNotifyRes - filled in with result details.
 * RETURN VALUE:
 *   0           - success
 *   non-0       - failure, details in pTHStls->errCode
 */
ULONG
DirNotifyRegister(
                  SEARCHARG *pSearchArg,
                  NOTIFYARG *pNotifyArg,
                  NOTIFYRES **ppNotifyRes
)
{
    THSTATE*     pTHS = pTHStls;
    NOTIFYRES   *pNotifyRes;
    ULONG        dwException, ulErrorCode, dsid;
    DWORD        dwNameResFlags = NAME_RES_QUERY_ONLY;
    PVOID        dwEA;
    DWORD        dnt;
    ULONG        err;
    ENTINFSEL   *pPermSel;
    DirWaitItem *pItem;
    PFILTER      pInternalFilter = NULL;
    DWORD        it;

    Assert(VALID_THSTATE(pTHS));
    Assert(!(pTHS->errCode));

    if (pTHS->errCode) {
        return pTHS->errCode;
    }

    __try {
        SYNC_TRANS_READ();   /*Identify a reader trans*/
        __try {

            /* Allocate the results buffer. */
            *ppNotifyRes = pNotifyRes = THAllocEx(pTHS, sizeof(NOTIFYRES));

            // Turn the external filter into an internal one.  This also
            // simplifies the filter, so a TRUE filter will end up
            // looking TRUE, even if they did (!(!(objectclass=*)))
            // internalize and register the filter with the DBlayer

            if ((err = DBMakeFilterInternal(pTHS->pDB,
                                 pSearchArg->pFilter,
                                 &pInternalFilter,
                                 NULL)) != ERROR_SUCCESS)
            {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, err);
                __leave;
            }

            /* The resultant filter better be trivial. */
            if (pInternalFilter &&
                (pInternalFilter->pNextFilter ||
                 (pInternalFilter->choice != FILTER_CHOICE_ITEM) ||
                 (pInternalFilter->FilterTypes.Item.choice !=
                  FI_CHOICE_TRUE))) {
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_NOTIFY_FILTER_TOO_COMPLEX);
                __leave;
            }

            if(pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
                dwNameResFlags |= NAME_RES_CHILDREN_NEEDED;
            }

            err = DoNameRes(pTHS,
                            dwNameResFlags,
                            pSearchArg->pObject,
                            &pSearchArg->CommArg,
                            &pNotifyRes->CommRes,
                            &pSearchArg->pResObj);
            if (err) {
                __leave;
            }

            /* we've found the object, snag its DNT */
            dnt = pTHS->pDB->DNT;

            if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
                // Object is not visible to this client.
                __leave;
            }

            /* make a permanent heap copy of the selection */
            pPermSel = malloc(sizeof(ENTINFSEL));
            if (!pPermSel) {
                SetSysErrorEx(ENOMEM, ERROR_NOT_ENOUGH_MEMORY,
                              sizeof(ENTINFSEL));
                __leave;
            }
            *pPermSel = *(pSearchArg->pSelection);
            if (pPermSel->AttrTypBlock.attrCount) {
                Assert(pPermSel->AttrTypBlock.pAttr);
                Assert(pPermSel->attSel != EN_ATTSET_ALL);
                pPermSel->AttrTypBlock.pAttr =
                  malloc(pPermSel->AttrTypBlock.attrCount * sizeof(ATTR));
                if (!pPermSel->AttrTypBlock.pAttr) {
                    SetSysErrorEx(
                            ENOMEM, ERROR_NOT_ENOUGH_MEMORY,
                            (pPermSel->AttrTypBlock.attrCount * sizeof(ATTR)));
                    free(pPermSel);
                    __leave;
                }
                memcpy(pPermSel->AttrTypBlock.pAttr,
                       pSearchArg->pSelection->AttrTypBlock.pAttr,
                       pPermSel->AttrTypBlock.attrCount * sizeof(ATTR));
            }
            else {
                pPermSel->AttrTypBlock.pAttr = NULL;
            }
        
            /* create a wait item... */
            pItem = malloc(sizeof(DirWaitItem));
            if (!pItem) {
                if (pPermSel->AttrTypBlock.pAttr) {
                    free(pPermSel->AttrTypBlock.pAttr);
                }
                free(pPermSel);
                SetSysErrorEx(ENOMEM, ERROR_NOT_ENOUGH_MEMORY,
                              sizeof(DirWaitItem));
                __leave;
            }
            pItem->hClient = pNotifyArg->hClient;
            pItem->pfPrepareForImpersonate = pNotifyArg->pfPrepareForImpersonate;
            pItem->pfTransmitData = pNotifyArg->pfTransmitData;
            pItem->pfStopImpersonating = pNotifyArg->pfStopImpersonating;
            pItem->DNT = dnt;
            pItem->choice = pSearchArg->choice;
            pItem->pSel = pPermSel;
            pItem->Svccntl = pSearchArg->CommArg.Svccntl;
            pItem->bOneNC = pSearchArg->bOneNC;

            /* ...and add it to the monitor list */
            if (AddToMonitorList(pItem,
                                 &pNotifyRes->hServer)) {
                /* it didn't work */
                Assert(pTHS->errCode);
                FreeWaitItem(pItem);
                __leave;
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN( pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    if (pNotifyRes) {
        pNotifyRes->CommRes.errCode = pTHS->errCode;
        pNotifyRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }

    return pTHS->errCode;

}

/*++ DirNotifyUnregister
 *
 * Requests that no more notifications be sent for a given monitor item
 *
 * INPUT:
 *   hServer - handle to the monitor item (originally returned in the
 *             NOTIFYRES passed back from the DirNotifyRegister call)
 * OUTPUT:
 *   ppNotifyRes - filled in with result details.
 * RETURN VALUE:
 *   0           - success
 *   non-0       - failure, details in pTHStls->errCode
 */
ULONG
DirNotifyUnRegister(
                    DWORD hServer,
                    NOTIFYRES **ppNotifyRes
)
{
    Assert(VALID_THSTATE(pTHStls));

    if (RemoveFromMonitorList(hServer)) {
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                    DIRERR_UNKNOWN_OPERATION);
    }
    return pTHStls->errCode;
}

/*++ GetMonitorList
 *
 * Returns the list of monitor items for a specific DNT, from a single hash
 *
 * INPUT:
 *   DNT       - the DNT to search for
 *   choice    - the choice to search for
 * RETURN VALUE
 *   NULL      - nothing found
 *   non-NULL  - a pointer to the head of a linked list of wait items
 */
DirWaitItem *
GetMonitorList(ULONG DNT,
               UCHAR choice)
{
    DirWaitEntry    entry;
    LHT_POS         posLHT;

    entry.key.DNT       = DNT;
    entry.key.choice    = choice;
    entry.pList         = NULL;

    if (plhtMon) {
        (void)LhtFindEntry(plhtMon, &entry.key, &posLHT);
        (void)LhtRetrieveEntry(&posLHT, &entry);
    }

    return entry.pList;
}

/*++ AddToNotifyQueue
 *
 * This routine creates notify item from its arguments and inserts it
 * at the end of the notify queue.  Note that while we could have kept
 * a pointer to the last element in the queue and tacked on the entry
 * there, instead we walk the entire queue searching for duplicates
 * (entries for the same DNT and for the same wait item).  If a duplicate
 * is found, we junk the item we're adding, since it's already there.
 * The reasoning behind this is that there are two possiblities for
 * when the system is running, either the queue is short, and hence the
 * list traversal is cheap, or the queue is long, in which case the
 * duplicate removal is vital, to keep the notifier from becoming even
 * more backed up.
 *
 * INPUT:
 *   pWaitItem - pointer to the wait item to be added
 *   DNT       - DNT of the item being added
 * RETURN VALUE:
 *   none
 */
void
AddToNotifyQueue(DirWaitItem *pWaitItem,
                ULONG DNT
)
{
    DirNotifyItem * pNotifyItem;
    DirNotifyItem * pList, **ppList;

    /* Build the notify item */
    pNotifyItem = malloc(sizeof(DirNotifyItem));
    if (!pNotifyItem) {
        return;
    }
    pNotifyItem->pWaitItem = pWaitItem;
    pNotifyItem->DNT = DNT;
    pNotifyItem->pNext = NULL;

    EnterCriticalSection(&csDirNotifyQueue);
    __try {
        ppList = &gpDirNotifyQueue;
        pList = gpDirNotifyQueue;
        while (pList) {
            if ((pList->DNT == DNT) &&
                (pList->pWaitItem == pWaitItem)) {
                /* An identical entry is already in the (badly backed up!)
                 * queue, so just throw this one away.
                 */
                DPRINT1(3,"Discarding redundant notify for object 0x%x\n",DNT);
                free(pNotifyItem);
                __leave;
            }
            ppList = &(pList->pNext);
            pList = pList->pNext;
        }

        /* We got to the end of the queue without finding a duplicate,
         * so add this item to the end of the queue.  As always when
         * adding a new entry, signal the queue event.
         */
        *ppList = pNotifyItem;
        INC(pcNotifyQSize);
        SetEvent(hevDirNotifyQueue);
    }
    __finally {
        LeaveCriticalSection(&csDirNotifyQueue);
    }
}

void
NotifyWaitersPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
/*++
    Called by the code that tracks modified objects when committing to
    transaction level 0.  We now walk that list and, for each object
    on it, see if anyone is monitoring updates.  If so, we add the appropriate
    entry(ies) to the notify queue.

    NOTE:  This code MUST NEVER CAUSE an exception.  We are called after we have
    committed to the DB, so if we can't manage to notify waiters, then they
    don't get notified.  But, there are other X...Y..PostProcess calls that MUST
    be called, so we can't cause an exception which would prevent them from
    being called.   Of course, it would be best if in addition to not excepting,
    we never fail.

    RETURN VALUE:
       none
--*/
{
    MODIFIED_OBJ_INFO *pTemp;
    unsigned     i;
    int          j;
    DirWaitItem *pItem;
    DWORD ThisDNT;

    if (eServiceShutdown) {
        return;
    }

    Assert(VALID_THSTATE(pTHS));

    if(!pTHS->JetCache.dataPtr->pModifiedObjects ||
       !fCommitted ||
       pTHS->transactionlevel > 0 ) {
        // Nothing changed, or not committing or committing to a non zero
        // transaction level.  Nothing to do.
        return;
    }

    // OK, we're committing to transaction level 0.  Go through all the DNTs
    // we've saved up for this transaction and notify the appropriate waiters.


    /* get a read lock on the monitor list */
    Assert(!OWN_CRIT_SEC(csDirNotifyQueue));
    SyncEnterRWLockAsReader(&rwlDirNotify);
    for(pTemp = pTHS->JetCache.dataPtr->pModifiedObjects;
        pTemp;
        pTemp = pTemp->pNext) {

        for(i=0;
            i<pTemp->cItems;
            i++) {

            if(!pTemp->Objects[i].fNotifyWaiters) {
                // Although this object changed, we were told to ignore it.
                continue;
            }

            ThisDNT = pTemp->Objects[i].pAncestors[pTemp->Objects[i].cAncestors-1];
            DPRINT3(5,
                    "Checking for clients monitoring DNT 0x%x, "
                    "NCDNT 0x%x.  Change type %d\n",
                    ThisDNT,
                    pTemp->Objects[i].ulNCDNT,
                    pTemp->Objects[i].fChangeType);

            if(pTemp->Objects[i].fChangeType != MODIFIED_OBJ_intrasite_move) {
                /* Get the list of people monitoring this object */
                // Note we don't do this for intrasite moves, just modifies.
                // For moves within a single NC, there will be two elements in
                // this linked list.  1 will be of type _modified, the other
                // will be for type _intrasite_move.  Lets not trigger two
                // notifications for the object if someone is monitoring the
                // DNT.
                // For moves out of this NC, there will only be one element in
                // the linked list.  It will be of type _intersite_move.  Thus
                // we will only do one notification for this if someone is
                // tracking the DNT.
                pItem = GetMonitorList(ThisDNT,
                                       SE_CHOICE_BASE_ONLY);
                /* Add each of them to the notify queue */
                while (pItem) {
                    DPRINT1(3,"Enqueueing notify for object 0x%x\n",
                            ThisDNT);
                    AddToNotifyQueue(pItem, ThisDNT);
                    pItem = pItem->pNextItem;
                }
            }


            // Get the list of people monitoring this object's parent's children
            // Note we do this regardless of the change type
            pItem = GetMonitorList(pTemp->Objects[i].pAncestors[pTemp->Objects[i].cAncestors-2],
                                   SE_CHOICE_IMMED_CHLDRN);
            /* Add each of them to the notify queue */
            while (pItem) {
                DPRINT2(3,"Enqueueing notify for object 0x%x, PDNT 0x%x\n",
                        ThisDNT,
                        pTemp->Objects[i].pAncestors[pTemp->Objects[i].cAncestors-2]);
                AddToNotifyQueue(pItem, ThisDNT);
                pItem = pItem->pNextItem;
            }

            if(pTemp->Objects[i].fChangeType !=  MODIFIED_OBJ_intrasite_move) {
                // Get the list of people monitoring this object's naming
                // context.
                // Note we only do this for changes that are NOT moves within a
                // single NC.  This is because moves within a single NC result
                // in two elements in the linked list, one of type
                // intrasite_move, one of type _modified.  Let's not trigger two
                // notificiations in such cases.  Normal (non-move)
                // modifications result in only one element in the list of type
                // _modified.  Moves outside an NC result in only one element in
                // the list, and it is of type _intersite_move
                //
                j=pTemp->Objects[i].cAncestors;
                do {
                    --j;
                    pItem = GetMonitorList(pTemp->Objects[i].pAncestors[j],
                                           SE_CHOICE_WHOLE_SUBTREE);
                    /* Add each of them to the notify queue */
                    while (pItem) {
                        DPRINT2(3,"Enqueueing notify for object 0x%x, subtree 0x%x\n",
                                ThisDNT,
                                pTemp->Objects[i].pAncestors[j]);
                        AddToNotifyQueue(pItem, ThisDNT);
                        pItem = pItem->pNextItem;
                    }
                } while ((j > 1) &&
                         (pTemp->Objects[i].pAncestors[j] !=
                          pTemp->Objects[i].ulNCDNT));
            }
        }
    }
    SyncLeaveRWLockAsReader(&rwlDirNotify);
}

/*++ ProcessNotifyItem
 *
 * THis routine is called by the DirNotifyThread to process a single
 * NotifyQueue element.  The basic procedure is to find the object in
 * question, use a callback into head code to impersonate the client,
 * read the object, use another callback to transmit the results to
 * the client, and then use a third callback to de-impersontate.
 *
 * PERFHINT: This cries out for reuse of thread states.
 *
 * INPUT:
 *   pNotifyItem - the notify queue element to be processed
 */
void
ProcessNotifyItem(DirNotifyItem * pNotifyItem)
{
    THSTATE * pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    DirWaitItem * pWaitItem = pNotifyItem->pWaitItem;
    void * pClientStuff = NULL;
    DWORD err;
    ENTINF entinf;
    ULONG ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    ULONG it;

    if (!pTHS) {
        return;
    }
    __try {
        SYNC_TRANS_READ();
        __try {
            /* Find the object */
            err = DBFindDNT(pTHS->pDB, pNotifyItem->DNT);
            if (err) {
                // If we were triggered because of an intersite_move (i.e.
                // moving an object to another NC), the DBFindDNT will
                // fail because the process of moving the object has left it
                // temporarily (on a GC) or permanantly (on non-GCs) a phantom.
                // There's not much we can do in this case, because the object
                // no longer exists on this server (not even as a tombstone!)
                // and we can't read it to send back a notification.  There
                // is no mechanism defined to allow us to chain to a DC in
                // another domain to read the object and return data from there,
                // so the unfortunate outcome is that interdomain moves cause
                // objects to vanish silently, with no notification.
                LogUnhandledErrorAnonymous(err);
                __leave;
            }

            if (pNotifyItem->pWaitItem->bOneNC &&
                pNotifyItem->DNT != pNotifyItem->pWaitItem->DNT) {
                /* We're doing a single NC wait, and the item that triggered
                 * is not the same as the item being waited on, which means
                 * that we're doing a subtree search of somesort.  We need
                 * to verify that the triggering object is in the same NC
                 * as the base object.  Since we only support base and
                 * immediate children notifies right now, the only way this
                 * could not be is if the triggering item is an NC head.
                 */
                if (DBGetSingleValue(pTHS->pDB,
                                     ATT_INSTANCE_TYPE,
                                     &it,
                                     sizeof(it),
                                     NULL)
                    || (it & IT_NC_HEAD)) {
                    /* Either we can't read the instance type or it
                     * says that this is an NC head, and therefore not
                     * in the NC we want.
                     */
                    err = DSID(FILENO, __LINE__);
                    __leave;
                }
            }

            if (!((*pWaitItem->pfPrepareForImpersonate)(pWaitItem->hClient,
                                                        pWaitItem->hServer,
                                                        &pClientStuff))) {
                /* The impersonation setup failed, we have nothing to do */
                err = DSID(FILENO, __LINE__);
                __leave;
            }

            if(IsObjVisibleBySecurity(pTHS, FALSE)) {
                /* Get the SD off the object (needed for GetEntInf) */
                if (DBGetAttVal(pTHS->pDB,
                                1,
                                ATT_NT_SECURITY_DESCRIPTOR,
                                0,
                                0,
                                &ulLen,
                                (PUCHAR *)&pSec))
                    {
                        // Every object should have an SD.
                        Assert(!DBCheckObj(pTHS->pDB));
                        ulLen = 0;
                        pSec = NULL;
                    }

                /* Get the data, using the client's security context */
                err = GetEntInf(pTHS->pDB,
                                pWaitItem->pSel,
                                NULL,
                                &entinf,
                                NULL,
                                pWaitItem->Svccntl.SecurityDescriptorFlags,
                                pSec,
                                0,          // flags
                                NULL,
                                NULL);
            }
            else {
                err = DSID(FILENO, __LINE__);
            }
        }
        __finally {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }

        /* If we got something, send it away */
        if ((0 == err) && (!eServiceShutdown)) {
            DPRINT3(4,"Transmitting notify for (%x,%x) %S\n",
                    pWaitItem->hClient,
                    pWaitItem->hServer,
                    entinf.pName->StringName);
            (*pWaitItem->pfTransmitData)(pWaitItem->hClient,
                                         pWaitItem->hServer,
                                         &entinf);
        }

        /* Go back to being ourself */
        (*pWaitItem->pfStopImpersonating)(pWaitItem->hClient,
                                          pWaitItem->hServer,
                                          pClientStuff);
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
    free_thread_state();
}

/*++ DirNotifyThread
 *
 * This routine is a long-lived thread in the DSA.  It loops forever,
 * pulling the first item off of the Notify Queue and processing it.
 * If no more items are available it sleeps, waiting for some to appear
 * or for the process to shut down.
 */
ULONG DirNotifyThread(void * parm)
{
    HANDLE ahEvents[2];
    DirNotifyItem * pNotifyItem;

    ahEvents[0] = hevDirNotifyQueue;
    ahEvents[1] = hServDoneEvent;

    // Users should not have to wait for this.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    do {
        EnterCriticalSection(&csDirNotifyQueue);
      PluckNextFromQueue:
        pNotifyItem = gpDirNotifyQueue;
        if (gpDirNotifyQueue) {
            /* Advance the queue one step */
            gpDirNotifyQueue = gpDirNotifyQueue->pNext;
            /* Mark the item we're processing */
            gpInUseWait = pNotifyItem->pWaitItem;
            DEC(pcNotifyQSize);
        }
        LeaveCriticalSection(&csDirNotifyQueue);

        // exit the loop if we are shutting down or going into single user mode
        if (eServiceShutdown || DsaIsSingleUserMode()) {
            break;
        }

        if (!pNotifyItem) {
            /* nothing to process */
            goto Sleep;
        }

        ProcessNotifyItem(pNotifyItem);

        if (eServiceShutdown) {
            continue;
        }

        free(pNotifyItem);

        EnterCriticalSection(&csDirNotifyQueue);
        if (gfDeleteInUseWait) {
            /* the wait item we were using has been removed from the wait
             * lists and should be deleted now that we're done with it
             */
            FreeWaitItem(gpInUseWait);
            gfDeleteInUseWait = FALSE;
        }
        gpInUseWait = NULL;
        goto PluckNextFromQueue;

      Sleep:
        if (!eServiceShutdown) {
            WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE);
        }
    } while (!eServiceShutdown);

    return 0;
}

/*++ DirPrepareForImpersonate
 *
 * Helper routine for threads beginning the processing a a notification.
 * It sets fDSA and keeps track of its previous value in malloc'ed memory.
 */
BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        )
{
    BOOL *pfDSA=NULL;
    THSTATE *pTHS = pTHStls;

    pfDSA = (BOOL *)malloc(sizeof(BOOL));
    if(!pfDSA) {
        return FALSE;
    }

    *pfDSA = pTHS->fDSA;
    pTHS->fDSA = TRUE;
    *ppImpersonateData = pfDSA;

    return TRUE;
}

/*++ DirStopImpersonating
 *
 * Helper routine for threads ending the processing of a notification.
 * It sets fDSA back to its previous value and frees the memory allocated
 * to hold the previous value.
 */
VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        )
{
    BOOL *pfDSA = (BOOL *)pImpersonateData;
    THSTATE *pTHS = pTHStls;

    if(!pfDSA) {
        return;
    }

    pTHS->fDSA = *pfDSA;
    free(pfDSA);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdsearch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdsearch.c
//
//--------------------------------------------------------------------------


/*
Description:

    Implements the DirSearch API.

    DSA_DirSearch() is the main function exported from this module.

*/
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <samsrvp.h>                    // to support CLEAN_FOR_RETURN()
#include <ntdsctr.h>            // Perf Hook

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "permit.h"
#include "filtypes.h"                   // For FI_CHOICE...
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "MDSEARCH:"              // define the subsystem for debugging

// LDAP errors
#include <winldap.h>

#include <fileno.h>
#define  FILENO FILENO_MDSEARCH

#include <dstrace.h>
#include "dsutil.h"


// Search Logging
ULONG gcSearchInefficientThreshold = 10000;
ULONG gcSearchExpensiveThreshold = 5;
ULONG gcSearchInefficient_count = 0;
ULONG gcSearchExpensive_count = 0;
BOOL  isSearchPerformanceLoggingFirstTime = TRUE;
DSTIME timeLastSearchLoggingPerformed;

/* Internal functions */

int
GetNextEntInf (
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pRange,
    IN ENTINFLIST **ppEntInfList,
    IN RANGEINFLIST **ppRangeInfList,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN PCACHED_AC CachedAC,
    IN OPTIONAL PSID psidQuotaTrustee
    );

DWORD
FindFirstSearchObject(
        DBPOS *pDB,
        SEARCHARG *pSearchArg,
        PRESTART pArgRestart
        );

void
GeneratePOQ(THSTATE *pTHS,
            const SEARCHARG *pSearchArg,
            PARTIALOUTCOME **ppPOQ);
void
GenerateASQ_POQ(THSTATE *pTHS,
                const SEARCHARG *pSearchArg,
                PARTIALOUTCOME **ppPOQ,
                DWORD cASQRefCount,
                DWORD *pASQReferrals);
void
AddCurrentObjectToAsqReferrals (THSTATE *pTHS,
                                DWORD *pcASQRefCount,
                                DWORD *pcASQRefAlloced,
                                DWORD **ppASQReferrals);
VOID
SimpleBaseSearch (
        THSTATE   *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags
        );

BOOL
IsBaseOnlyAttPresent(
        SEARCHARG *pSearchArg
        );

void
SearchPerformanceLogFilter (DBPOS *pDB, SEARCHARG *pSearchArg);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

ULONG
DirSearch(
          SEARCHARG*  pSearchArg,
          SEARCHRES **ppSearchRes
          )
{
    THSTATE*     pTHS;
    SEARCHRES *pSearchRes;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    DPRINT1(1,"DirSearch(%ws) entered\n",pSearchArg->pObject->StringName);

   /* Initialize the THSTATE anchor and set a read sync-point.  This sequence
      is required on every API transaction.  First the state DS is initialized
      and then either a read or a write sync point is established.
   */

    pTHS = pTHStls;
    Assert(VALID_THSTATE(pTHS));
    Assert(!pTHS->errCode); // Don't overwrite previous errors
    *ppSearchRes = pSearchRes = NULL;

    __try {
        // This function shouldn't be called by threads that are already
        // in an error state because the caller can't distinguish an error
        // generated by this new call from errors generated by previous calls.
        // The caller should detect the previous error and either declare he
        // isn't concerned about it (by calling THClearErrors()) or abort.
        *ppSearchRes = pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));
        if (pTHS->errCode) {
            __leave;
        }
        if (eServiceShutdown) {
            // This somewhat complicated test is designed to allow in-process
            // clients to continue to perform read-only operations while
            // the we're in the process of shutting down.
            if (   (eServiceShutdown >= eSecuringDatabase)
                || (   (eServiceShutdown >= eRemovingClients)
                    && (   !(pTHS->fDSA)
                        || (pTHS->fSAM)))) {
                ErrorOnShutdown();
                __leave;
            }
        }

        SYNC_TRANS_READ();   /*Identify a reader trans*/
        __try {

            // REVIEW:  this is dead code because the struct is zeroed on alloc
            pSearchRes->CommRes.aliasDeref = FALSE;   /*Initialize to Default*/

            // REVIEW:  this copy is dead code because we zero it immediately
            pSearchRes->PagedResult = pSearchArg->CommArg.PagedResult;

            // Assume no paged result
            // REVIEW:  this memset is dead code because we already zeroed this
            // REVIEW:  struct on alloc and the above copy is nullified
            memset(&pSearchRes->PagedResult,0,sizeof(PAGED_RESULT));

            /* Call main search function*/

            SearchBody(pTHS, pSearchArg, pSearchRes,0);

        } __finally {
            CLEAN_BEFORE_RETURN( pTHS->errCode);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    if (pSearchRes) {
        pSearchRes->CommRes.errCode = pTHS->errCode;
        pSearchRes->CommRes.pErrInfo = pTHS->pErrInfo;
    }
    // NTRAID#NTRAID-668987-2002/07/22-rrandall: added to catch a strange AV
    // earlier.
    Assert(VALID_THSTATE(pTHS));

    return pTHS->errCode;
} // DirSearch


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check if this is a restarted operation.

   The continued operation was either on this DSA or this DSA or on a remote
   chained DSA.  This is determined using the isRemote flag.  Both the
   R_DirSearch remote DSA fns and the LocalSearch  function
   can be continued.  On input, pRestart indicates if the function is a
   continuation.  On output it indicates if a continuation is necessary.
   These functions are responsible for setting this flag.  It should be
   TRUE only  when a good return is generated and a continuation is necessary.

   Different information is needed to restart a local search from a remote
   one.  For a local call, we save the DN of the next object to be  returned.
   For foreign call we save a pointer to the beginning of the user's RPC
   output Buf, a pointer to the next entInfList to be returned and the
   remote DSA handle.

*/

void
SearchBody (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags)
{
    PRESTART       pRestart;
    DWORD          dwNameResFlags = NAME_RES_QUERY_ONLY;

   pRestart = pSearchArg->CommArg.PagedResult.pRestart;    /* continuation? */

   if( pRestart != NULL ) {
       // all the data we need should be in PRESTART struct
       pSearchArg->pResObj = ResObjFromRestart(pTHS,
                                               pSearchArg->pObject,
                                               pRestart);
       LocalSearch(pTHS, pSearchArg, pSearchRes,flags);
       // Search may have opened a sort table.  Some callers require that it be
       // closed.
       DBCloseSortTable(pTHS->pDB);
   }
   else          /* First transaction...Not a continuation.  */
   {
       /* We perform name resolution. Set the children needed flag
          according to if the search includes child objects.
          */

       if(pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
           dwNameResFlags |= NAME_RES_CHILDREN_NEEDED;
           if(!pSearchArg->bOneNC) {
               // We are on a GC, thus it is OK to root a search from a phantom
               // as long as the search wasn't a base-only one.
               // Set the flags to show this.
               dwNameResFlags |= NAME_RES_PHANTOMS_ALLOWED;
           }
       }
       // If we're on a GC port we need to pass this flag to DoNameRes, so
       // we'll get referrals to all objects in NDNCs.
       dwNameResFlags |= (pSearchArg->bOneNC) ? 0 : NAME_RES_GC_SEMANTICS;

       if( 0 == DoNameRes(pTHS,
                          dwNameResFlags,
                          pSearchArg->pObject,
                          &pSearchArg->CommArg,
                          &pSearchRes->CommRes,
                          &pSearchArg->pResObj)) {
            LocalSearch(pTHS, pSearchArg, pSearchRes,flags);
           // Search may have opened a sort table.  Some callers require that it
           // be closed.
           DBCloseSortTable(pTHS->pDB);
       }
   }
   return;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Main body of local search function.  We get as many objects as will fit
   into the output buffer.  If more data is available, we use a non-null
   partialoutcomequalifier to indicate to the user that there is more data.

   The steps are as follows:

   1 - Set the client filter.

   2 - a - If this is not a restarted transaction, we retrieve and test the
           filter against the base of the subtree or

       b - This is a restarted transaction so we reposition on the next
           entry to retrieve.  (Note that we assume that we have been called
           with the same exact filter ( this is expected)

   3 - We determine the scope of the call, this indicates if the client
       requested the base object only or the base and the immediate children.
       If it is base only we return.

   4 - a - Retrieve each child that passes the filter test.  (Note that the
           filter test is implicit in the DBGetNextSearchObj database call.)

       b - Try to retrieve its data into an entry info structure.
           If we failulSearchStatus because we are out of space, we leave the partial
           outcome qualifier to indicate to the client that there is more
           data and we return the name of the current object that we were
           not able to return. We also indicate that a restart is needed.

   5 - If there are no more children, we NULL out the partial outcome
       qualifier and return.
*/

#if DBG
DWORD gulInefficientSearchTrigger = 5000;
BOOL fBreakOnInefficientSearchTrigger = FALSE;
#endif

INT
LocalSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags)
{
    DBPOS      *pDB = pTHS->pDB;
    ENTINFLIST *pEntInfList; /*Points to next output Entry info list*/
    RANGEINFLIST *pRangeInfList;
    ULONG        dwSearchStatus;
    COMMARG *  pCommArg;
    BOOL       fExitLoop = FALSE;
    BOOL       fFirstTime = TRUE;
    DWORD      cbSecurity;
    PSECURITY_DESCRIPTOR pSecurity=NULL;
    BOOL       fSDIsGlobalSDRef;
    PRESTART   pArgRestart, pResRestart=NULL;
    POBJECT_TYPE_LIST pFilterSecurity;
    DWORD      *pResults;
    ULONG      FilterSecuritySize;
    ULONG      SearchFlags=0;
    PFILTER    pInternalFilter = NULL;
    INT        numAtts = 0; // holds total number of attributes found
                            // across all entries.  error if it stays == 0
    BOOL       *pbSortSkip=NULL;
    BOOL        bSkipEntInf = FALSE;
    DWORD       cASQRefCount = 0;
    DWORD       cASQRefAlloced = 0;
    DWORD       *pASQReferrals = NULL;

    CACHED_AC   cachedAC;
    DWORD       getEntInfFlags = 0;
    DWORD       err;
    BOOL        fVLVPresent, fASQPresent;
    ATTCACHE    *pSortAC = NULL;
    ATTCACHE    *pASQAC;
    VLV_REQUEST *pVLVRequest;
    ASQ_REQUEST *pASQRequest;
    PDSNAME     pParent = NULL;
    CLASSCACHE  *pCC;
    ULONG       cAtts;
    ATTRTYP     ErrAttrTyp;
    DSNAME      NullDN;


    DPRINT1(1,"LocalSearch(%ws) entered\n",pSearchArg->pObject->StringName);

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BEGIN_DIR_SEARCH,
                     EVENT_TRACE_TYPE_START,
                     DsGuidSearch,
                     szInsertSz(GetCallerTypeString(pTHS)),
                     szInsertSz(SEARCHTYPE_STRING(pSearchArg->choice)),
                     szInsertDN(pSearchArg->pObject),
                     NULL, NULL, NULL, NULL, NULL);

    Assert(pSearchArg->pResObj);

    PERFINC(pcTotalSearches);
    INC_SEARCHES_BY_CALLERTYPE( pTHS->CallerType );
    GetPLS()->cTotalSearchesInLastPeriod++;

    pCommArg = &pSearchArg->CommArg;
    pArgRestart = pCommArg->PagedResult.pRestart;

    // Assert that we either don't have a restart structure OR we have said
    // that we are going to have one.  Note that it is legal to have
    // fPresent == TRUE and not actually have a pArgRestart
    Assert(!pArgRestart || pCommArg->PagedResult.fPresent);



    // check that they ask for a sort on an attribute that we know how to sort
    //
    if (pSearchArg->CommArg.SortType != SORT_NEVER) {

        pSortAC = SCGetAttById(pTHS, pSearchArg->CommArg.SortAttr);
        if (!pSortAC) {
            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
            CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
            goto exit;
        }

        // check whether we support sorting on this attribute.
        // constructed attributes are not ok for sorting
        // all the syntaxes that support >, support >=, <, <= and are ok for sorting
        //
        if (pSortAC->bIsConstructed ||
            !FLegalOperator (pSortAC->syntax, FI_CHOICE_GREATER)) {
            pSearchRes->SortResultCode = LDAP_INAPPROPRIATE_MATCHING;
            if (pSearchArg->CommArg.SortType == SORT_OPTIONAL) {
                pSearchArg->CommArg.SortType = SORT_NEVER;
            }
            else {
                SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED_SORT_ORDER);
                CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
                goto exit;
            }
        }
    }


    // Check for VLV presence
    //
    pVLVRequest = &pCommArg->VLVRequest;
    fVLVPresent = pVLVRequest->fPresent;
    Assert(!pVLVRequest->pVLVRestart || fVLVPresent);
    if (fVLVPresent) {

        DPRINT5 (1, "VLV: before:%d after:%d cnt:%d target:%d res: 0x%x\n",
                                pVLVRequest->beforeCount,
                                pVLVRequest->afterCount,
                                pVLVRequest->contentCount,
                                pVLVRequest->targetPosition,
                                pVLVRequest->pVLVRestart);

        if (pVLVRequest->fseekToValue) {
            DPRINT1 (1, "VLV: seekToValue  seekVal: %ws\n",
                            pVLVRequest->seekValue.pVal);
        }

        // we don't support VLV without a sort request
        //
        if (pSearchArg->CommArg.SortType == SORT_NEVER) {

            // set this so to exit with VLV specific errors
            DBSetVLVArgs (pDB, pVLVRequest, pCommArg->SortAttr);
            pDB->Key.pVLV->Err = LDAP_SORT_CONTROL_MISSING;
            DBSetVLVResult (pDB, &pSearchRes->VLVRequest, NULL);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
            CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
            goto exit;
        }

        // we don't support VLV on base searches, unless we are also doing an ASQ
        //
        if (pSearchArg->choice == SE_CHOICE_BASE_ONLY &&
            !pSearchArg->CommArg.ASQRequest.fPresent) {

                // set this so to exit with VLV specific errors
                //
                DBSetVLVArgs (pDB, pVLVRequest, pCommArg->SortAttr);
                pDB->Key.pVLV->Err = LDAP_UNWILLING_TO_PERFORM;
                DBSetVLVResult (pDB, &pSearchRes->VLVRequest, NULL);

                SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
                CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
                goto exit;
        }
    }

    // check for ASQ presence
    pASQRequest = &pCommArg->ASQRequest;

    if (fASQPresent = pASQRequest->fPresent) {

        //
        // The client should be able to see this object
        // before we continue.
        //
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            goto exit;
        }

        // we support ASQ only on base searches
        //
        if (pSearchArg->choice != SE_CHOICE_BASE_ONLY) {

            pDB->Key.asqRequest.Err = LDAP_UNWILLING_TO_PERFORM;
            DBSetASQResult (pDB, &pSearchRes->ASQRequest);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
            goto exit;
        }

        if (!(pASQAC = SCGetAttById (pTHS, pASQRequest->attrType))) {
            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, DIRERR_ATT_NOT_DEF_IN_SCHEMA);
            goto exit;
        }

        DPRINT3 (1, "ASQ Scoped Query on %s(0x%x) linkID:0x%x\n",
                 pASQAC->name, pASQAC->id, pASQAC->ulLinkID);

        // we only support ASQ on certain attribute syntaxes
        //
        if (pASQAC->syntax != SYNTAX_DISTNAME_TYPE) {
            DPRINT1 (1, "Invalid Syntax on ASQ Attribute: %d\n", pASQAC->syntax);

            // set this so as to exit with ASQ specific errors
            //
            pDB->Key.asqRequest.Err = LDAP_INVALID_SYNTAX;
            DBSetASQResult (pDB, &pSearchRes->ASQRequest);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_BAD_ATT_SCHEMA_SYNTAX);
            goto exit;
        }

        // we do not support ASQ on constructed attributes
        //
        if (pASQAC->bIsConstructed) {

            pDB->Key.asqRequest.Err = LDAP_UNWILLING_TO_PERFORM;
            DBSetASQResult (pDB, &pSearchRes->ASQRequest);

            SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, ERROR_DS_NOT_SUPPORTED);
            goto exit;
        }

        //
        // Client should have read permission on the attribute.
        //
        if (!(pCC = SCGetClassById(pTHS, pSearchArg->pResObj->MostSpecificObjClass))) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_OBJECT_CLASS_REQUIRED);
            goto exit;
        }
        // grab NTSD
        err = DBGetObjectSecurityInfo(pDB, pDB->DNT,
                                      &cbSecurity, &pSecurity, NULL, NULL, NULL,
                                      DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                                      &fSDIsGlobalSDRef
                                     );
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CANT_RETRIEVE_SD,
                          err);
            goto exit;
        }

        cAtts = 1;
        CheckReadSecurity(pTHS, 0, pSecurity, pSearchArg->pResObj->pObj, pCC, NULL, &cAtts, &pASQAC);
        if (pSecurity && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pSecurity);
        }
        pSecurity = NULL;

        if (!pASQAC) {
            //
            // The client can't see this attribute.  Act as if the attribute simply
            // doesn't exist on this object.
            //
            goto exit;
        }

        // if we are a GC, possibly we have local copies of objects
        // without all the requested attributes.
        // check whether the requested attributes are all replicated to the GC
        if (gAnchor.fAmGC && !pSearchArg->bOneNC) {

            if (!pSearchArg->pSelection) {
                DPRINT(1, "ASQ Setting missing attrs to TRUE\n");
                pASQRequest->fMissingAttributesOnGC = TRUE;
            } else {
                DPRINT1(1, "ASQ Setting missing attrs to %s\n",
                        pCommArg->Svccntl.fMissingAttributesOnGC ? "TRUE" : "FALSE");
                pASQRequest->fMissingAttributesOnGC = pCommArg->Svccntl.fMissingAttributesOnGC;
            }
        }
    }

    // Assume not sorted
    pSearchRes->bSorted = FALSE;

    //Set the base object name if an alias has been dereferenced
    if (pSearchRes->CommRes.aliasDeref) {
        DWORD len;
        pSearchRes->baseProvided = TRUE;
        DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME,
                    0, 0,
                    &len, (PUCHAR *)&(pSearchRes->pBase)) ;
    }
    else {
        pSearchRes->baseProvided = FALSE;
    }

    if (pSearchArg->pSelection)
    {
        DPRINT2(4,"Attribute selection is <%c>, infotypes <%c>\n",
            (pSearchArg->pSelection->attSel),
            (pSearchArg->pSelection->infoTypes));

        // We allow certain constructed attributes to be asked for
        // only if it is a base search.
        if (IsBaseOnlyAttPresent(pSearchArg)) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_NON_BASE_SEARCH, 0);
            CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
            goto exit;
        }
    } else{
        DPRINT(4,"No selection specified.\n");
    }

    // internalize and register the filter with the DBlayer
    // and check to see if the filter is valid

    if ((err = DBMakeFilterInternal(pDB,
                         pSearchArg->pFilter,
                         &pInternalFilter,
                         &ErrAttrTyp)) != ERROR_SUCCESS ) {
        if ((ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS == err) ||
            (ERROR_DS_INAPPROPRIATE_MATCHING == err)) {
            memset(&NullDN, 0, sizeof(NullDN));
            SetAttError(&NullDN, ErrAttrTyp, PR_PROBLEM_WRONG_MATCH_OPER, NULL, err);

        } else {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, err, 0);
        }
        CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
        goto exit;
    }

    // initialize results
    pRangeInfList = &(pSearchRes->FirstRangeInf);
    pEntInfList = &(pSearchRes->FirstEntInf);
    pSearchRes->count = 0;     /* init num of entries counter to 0 */

    // Check for simplest case
    if(pInternalFilter &&
       !pInternalFilter->pNextFilter &&
       pInternalFilter->choice == FILTER_CHOICE_ITEM &&
       pInternalFilter->FilterTypes.Item.choice == FI_CHOICE_TRUE &&
       pSearchArg->choice == SE_CHOICE_BASE_ONLY && !fASQPresent) {
        // This is a base object read, no filter.  Verify the parent, then do a
        // getentinf.
        SimpleBaseSearch(pTHS, pSearchArg,pSearchRes,flags);

        goto exit;
    }

    GetFilterSecurity(pTHS,
                      pInternalFilter,
                      pCommArg->SortType,
                      pCommArg->SortAttr,
                      (flags & SEARCH_AB_FILTER),
                      &pFilterSecurity,
                      &pbSortSkip,
                      &pResults,
                      &FilterSecuritySize);

    DBSetFilter(pDB,
                pInternalFilter,
                pFilterSecurity,
                pResults,
                FilterSecuritySize,
                pbSortSkip
                );

    //
    // if this is not the first page and we are paging and the
    // size is 0, abort at this point.
    //      We need to generate referrals with the first page.
    //      If page size is 0, then the client is signalling us
    //      to abort the paging sequence. We do this check way
    //      down in the core and not on the ldap head so we
    //      can check the validity of client parameters
    //

    if ( (pArgRestart != NULL) &&
         (pCommArg->ulSizeLimit == 0) &&
         pCommArg->PagedResult.fPresent ) {

        // exit to avoid generating referrals on succeeding pages
        CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
        goto exit;
    }

    if (fVLVPresent) {
        DBSetVLVArgs (pDB, pVLVRequest, pCommArg->SortAttr);
    }

    if (fASQPresent) {
        DBSetASQArgs (pDB, pASQRequest, pCommArg);
    }

    // position on the first record that qualifies.
    SearchFlags = SEARCH_FLAGS((*pCommArg));

    dwSearchStatus = FindFirstSearchObject(pDB,
                                           pSearchArg,
                                           pArgRestart);

    if (DB_ERR_NEXTCHILD_NOTFOUND == dwSearchStatus) {
	//
	// There were no entries visible to the client.  If the
	// base of the search is not visible to the client, then
	// make sure not to reveal it's existence.
	//
        if (CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE)) {
            goto exit;
        }
    }

    if(dwSearchStatus == DB_ERR_CANT_SORT) {
        // A mandatory sort order was unavailable.  Other errors fall through
        // and are dealt with below.
        pSearchRes->SortResultCode = LDAP_UNWILLING_TO_PERFORM;
        SetSvcError(SV_PROBLEM_UNAVAIL_EXTENSION, DIRERR_UNKNOWN_ERROR);
        CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
        goto exit;
    }
    else if ( dwSearchStatus == DB_ERR_NOT_AN_OBJECT) {
        AddCurrentObjectToAsqReferrals (pTHS,
                                        &cASQRefCount,
                                        &cASQRefAlloced,
                                        &pASQReferrals);
        bSkipEntInf = TRUE;
        dwSearchStatus = 0;
    }

    // Did we find a sort order?
    pSearchRes->bSorted = (pDB->Key.ulSorted != SORT_NEVER);

    // we might be directed to leave the results in the
    // sort table and don't create the ENTINF in-memory list
    if (pSearchArg->fPutResultsInSortedTable) {
        pSearchRes->count = pDB->Key.ulEntriesInTempTable;
    }

    ZeroMemory(&cachedAC, sizeof(cachedAC));

    SvccntlFlagsToGetEntInfFlags(&pCommArg->Svccntl,&getEntInfFlags);

    if(flags & SEARCH_UNSECURE_SELECT) {
        getEntInfFlags |= GETENTINF_NO_SECURITY;
    }

    while (   !dwSearchStatus
           && !fExitLoop
           && ((eServiceShutdown == eRunning)
               || ((eServiceShutdown == eRemovingClients)
                   && (pTHS->fDSA
                       && !pTHS->fSAM)))) {

        if((pSearchRes->count + cASQRefCount) >= pCommArg->ulSizeLimit) {

            DPRINT(4, "Size Limit reached\n");
            if (!pSearchRes->pPartialOutcomeQualifier) {
                pSearchRes->pPartialOutcomeQualifier =
                    THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
            }
            pSearchRes->pPartialOutcomeQualifier->problem =
                PA_PROBLEM_SIZE_LIMIT;

            if( pCommArg->PagedResult.fPresent) {
                // Info from DB layer
                DBCreateRestart(pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_SIZE_LIMIT,
                                pSearchArg->pResObj);

                // Control info
                pSearchRes->PagedResult.fPresent = TRUE;
                pSearchRes->PagedResult.pRestart = pResRestart;
            }

            fExitLoop = TRUE;
            continue;
        }
        else if (pDB->Key.pVLV &&
                 (pSearchRes->count >= pDB->Key.pVLV->requestedEntries) ) {

            DBCreateRestart(pDB,
                            &pResRestart,
                            SearchFlags,
                            PA_PROBLEM_SIZE_LIMIT,
                            pSearchArg->pResObj);

            DBSetVLVResult (pDB,
                            &pSearchRes->VLVRequest,
                            pResRestart);

            fExitLoop = TRUE;
            continue;
        }

        if (!bSkipEntInf) {
            if (fFirstTime ?
                GetEntInf2(pDB,
                          pSearchArg->pSelection,
                          pSearchArg->pSelectionRange,
                          &pEntInfList->Entinf,
                          &pRangeInfList->RangeInf,
                          pCommArg->Svccntl.SecurityDescriptorFlags,
                          pDB->pSecurity,
                          getEntInfFlags,
                          &cachedAC,
                          NULL,
                          pCommArg->pQuotaSID)
                :
                GetNextEntInf(pDB,
                              pSearchArg->pSelection,
                              pSearchArg->pSelectionRange,
                              &pEntInfList,
                              &pRangeInfList,
                              pCommArg->Svccntl.SecurityDescriptorFlags,
                              pDB->pSecurity,
                              getEntInfFlags,
                              &cachedAC,
                              pCommArg->pQuotaSID)
            ) {
                DPRINT(0,"Bad return building ENT\n");
                goto exit;
            }

            numAtts += pEntInfList->Entinf.AttrBlock.attrCount;
            fFirstTime = FALSE;
            pDB->SearchEntriesReturned++;
            pSearchRes->count++;
        }
        bSkipEntInf = FALSE;

        if ((pSearchArg->choice == SE_CHOICE_BASE_ONLY && !fASQPresent) || IsExactMatch(pDB)) {
            dwSearchStatus = DB_ERR_NEXTCHILD_NOTFOUND;

	} else {

            do {
                dwSearchStatus = DBGetNextSearchObject(pDB,
                                                       pCommArg->StartTick,
                                                       pCommArg->DeltaTick,
                                                       SearchFlags);

                if ( dwSearchStatus == DB_ERR_NOT_AN_OBJECT) {
                    AddCurrentObjectToAsqReferrals (pTHS,
                                                    &cASQRefCount,
                                                    &cASQRefAlloced,
                                                    &pASQReferrals);
                    bSkipEntInf = TRUE;
                    dwSearchStatus = 0;
                    break;
                }


                if (!dwSearchStatus) {
                    // Check if the parent is one we don't have rights to list contents of.

                    // we already checked security for this
                    if(pDB->Key.ulSorted && pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
                        break;
                    }
                    // check security
                    else if (IsObjVisibleBySecurity(pTHS, TRUE)) {
                        break;
                    }
                }

            } while ( !dwSearchStatus );
        }
    }

    if (eServiceShutdown
        && ((eServiceShutdown >= eSecuringDatabase)
            || (!pTHS->fDSA || pTHS->fSAM))) {
        SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN);
    } else {

        switch (dwSearchStatus) {

        case DB_ERR_TIMELIMIT:
            DPRINT(4, "Time Limit reached\n");
            if (!pSearchRes->pPartialOutcomeQualifier) {
                pSearchRes->pPartialOutcomeQualifier =
                    THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
            }
            pSearchRes->pPartialOutcomeQualifier->problem =
                PA_PROBLEM_TIME_LIMIT;

            if(pCommArg->PagedResult.fPresent) {
                // We were asked for paged results and we hit a time limit.
                // Build a paged results.  Note that we explicitly DO NOT come
                // through here if we hit a size limit.  In that case, we
                // already built the paged result above as soon as we found that
                // we hit the size limit.
                //

                // Info from DB layer
                DBCreateRestart(pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_TIME_LIMIT,
                                pSearchArg->pResObj);

                // Control info
                pSearchRes->PagedResult.fPresent = TRUE;
                pSearchRes->PagedResult.pRestart = pResRestart;
            }
            else if (fVLVPresent) {
                DBCreateRestart(pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_TIME_LIMIT,
                                pSearchArg->pResObj);

                DBSetVLVResult (pDB,
                                &pSearchRes->VLVRequest,
                                pResRestart);
            }

            // Fall through to see if we failed to read any attributes, since
            // that is an error.

        case DB_ERR_NEXTCHILD_NOTFOUND:
            // This is the case of a complete search (i.e. no more objects to be
            // returned, even if paging was requested.


            if (fVLVPresent) {

                DBCreateRestart(pDB,
                                &pResRestart,
                                SearchFlags,
                                PA_PROBLEM_SIZE_LIMIT,
                                pSearchArg->pResObj);

                DBSetVLVResult (pDB,
                                &pSearchRes->VLVRequest,
                                pResRestart);
            }

            // Fall through to see if we failed to read any attributes, since
            // that is an error.

        case 0:
            // This is the case of a sizeLimit reached.

            //
            // This is #if 0 instead of removed to allow for our bosses to
            // change their minds on the issue of whether we should be returning
            // an error or not
            //

#if 0
            if ((numAtts == 0) &&
                (pSearchRes->count != 0) &&
                (pSearchArg->pSelection) &&
                ((pSearchArg->choice != SE_CHOICE_BASE_ONLY) ||
                (pInternalFilter)                            ) &&
                (pSearchArg->pSelection->AttrTypBlock.attrCount != 0)) {

                // it is an error if the user requested a list of
                // attributes and none were found on any objects.

                SetAttError(pSearchArg->pObject, 0L,
                            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                            DIRERR_NO_REQUESTED_ATTS_FOUND);
            }
#endif
            break;

        case DB_ERR_VLV_CONTROL:
            Assert (fVLVPresent);

            // we got a VLV related error. more info for this error
            // is found on the VLV_SEARCH on the pDB
            // we don't want to fail the call, just the specific part (VLV)
            DBSetVLVResult (pDB,
                            &pSearchRes->VLVRequest,
                            NULL);
            break;

        default:
            DPRINT(1, "Bad error returned from DBGetNextSearchObj\n");
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_CHILD,
                     szInsertWC(pSearchArg->pObject->StringName),
                     szInsertUL(dwSearchStatus),
                     NULL);
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_RETRIEVE_CHILD,
                          dwSearchStatus);

        }
    }

    if (fASQPresent) {
        DBSetASQResult (pDB, &pSearchRes->ASQRequest);
    }

    /* Generate a Partial Outcome Qualifier, if needed */
    if (!pArgRestart &&         /* only do this on first packet */
        !pTHS->errCode &&       /* only do if nothing has gone wrong */
        pSearchArg->choice != SE_CHOICE_BASE_ONLY && /* unnecessary */
        !fVLVPresent && /* if VLV we don't want this */
        !pSearchArg->CommArg.Svccntl.localScope) { /* don't if local only */

        GeneratePOQ(pTHS,
                    pSearchArg,
                    &pSearchRes->pPartialOutcomeQualifier);
    }

    if (cASQRefCount) {
        GenerateASQ_POQ (pTHS,
                         pSearchArg,
                         &pSearchRes->pPartialOutcomeQualifier,
                         cASQRefCount,
                         pASQReferrals);

        THFreeEx (pTHS, pASQReferrals);
    }

exit:

    LogAndTraceEvent(FALSE,
                     DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_END_DIR_SEARCH,
                     EVENT_TRACE_TYPE_END,
                     DsGuidSearch,
                     szInsertUL(pTHS->errCode),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertWC (pTHS->searchLogging.pszFilter)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertSz (pTHS->searchLogging.pszIndexes)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertUL (pTHS->searchLogging.SearchEntriesVisited)
                        : NULL),
                     (gpDsEventConfig->fTraceEvents
                        ? szInsertUL (pDB->SearchEntriesReturned)
                        : NULL),
                     NULL, NULL, NULL);

#if DBG

    //
    // Used to trackdown callers doing inefficient searches
    //

    if ( pTHS->searchLogging.SearchEntriesVisited > gulInefficientSearchTrigger ) {

        if ( pTHS->CallerType != CALLERTYPE_LDAP ) {

            KdPrint(("Search Entries Visited == %d\n",pTHS->searchLogging.SearchEntriesVisited));
            KdPrint(("Caller %s SearchArg %x\n",
                     GetCallerTypeString(pTHS),
                     pSearchArg));
            if ( fBreakOnInefficientSearchTrigger ) {
                DebugBreak();
            }
        }
    }
#endif

    //
    // We only update stats control info and inefficient\expensive search stats
    // on the first page of a paged search.
    //
    if (!pArgRestart) {
        DWORD searchExpensiveInefficient = 0;

        pTHS->searchLogging.SearchEntriesReturned = pDB->SearchEntriesReturned;
        pTHS->searchLogging.SearchEntriesVisited = pDB->SearchEntriesVisited;

        if (pDB->SearchEntriesVisited >= gcSearchExpensiveThreshold) {
            gcSearchExpensive_count += 1;
            searchExpensiveInefficient |= 1;
        }

        if (pDB->SearchEntriesVisited >= gcSearchInefficientThreshold) {
            if (pDB->SearchEntriesVisited >= (10 * pDB->SearchEntriesReturned) ) {
                gcSearchInefficient_count += 1;
                searchExpensiveInefficient |= 2;
            }
        }

        // check if we are asked to log all inefficient / expensive searches
        if ( searchExpensiveInefficient &&
             (DS_EVENT_SEV_INTERNAL <=
              gpDsEventConfig->rgEventCategories[DS_EVENT_CAT_FIELD_ENGINEERING].ulLevel) ) {

            SearchPerformanceLogFilter (pDB, pSearchArg);
        }
    }

    if(pDB->pSecurity && !pDB->fSecurityIsGlobalRef) {
        THFreeEx(pTHS, pDB->pSecurity);
    }
    pDB->pSecurity = NULL;

    DPRINT2 (2, "Objects Visited: %d   Returned: %d\n",
                    pDB->SearchEntriesVisited,
                    pDB->SearchEntriesReturned);

    return pTHS->errCode;

} // LocalSearch



// -------------------------------------------------------------------------
//  performs logging of the various search operations that took place the
//  last period. this function is invoked from within the garbage collector
//  so they share the same invocation interval.
// -------------------------------------------------------------------------
void
SearchPerformanceLogging (void)
{
    size_t iProc;
    ULONG cTotalSearchesInLastPeriod;
    DSTIME timeNow = DBTime();
    DSTIME timeElapsed;
    DWORD hours;

    // Collect total search data
    cTotalSearchesInLastPeriod = 0;
    for (iProc = 0; iProc < GetProcessorCount(); iProc++) {
        cTotalSearchesInLastPeriod += GetSpecificPLS(iProc)->cTotalSearchesInLastPeriod;
    }

    // We are not interested in the first time this function is called,
    // which happens 15 minutes after starting the DS, since we are bundled
    // together with GarbageCollection
    if (isSearchPerformanceLoggingFirstTime) {
        isSearchPerformanceLoggingFirstTime = FALSE;
        timeLastSearchLoggingPerformed = timeNow;
        return;
    }

    timeElapsed = timeNow - timeLastSearchLoggingPerformed;

    hours = (DWORD)timeElapsed / 3600;

    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_SEARCH_OPERATIONS,
             szInsertUL(hours),
             szInsertUL(cTotalSearchesInLastPeriod),
             szInsertUL(gcSearchExpensive_count),
             szInsertUL(gcSearchInefficient_count),
             NULL, NULL, NULL, NULL);

    DPRINT4 (0, "SearchPerformanceLogging: %d total searches in %d hours, %d expensive, %d inefficient\n",
            cTotalSearchesInLastPeriod, hours, gcSearchExpensive_count, gcSearchInefficient_count);

    // reset period loging variables
    gcSearchExpensive_count = gcSearchInefficient_count = 0;
    for (iProc = 0; iProc < GetProcessorCount(); iProc++) {
        GetSpecificPLS(iProc)->cTotalSearchesInLastPeriod = 0;
    }
    timeLastSearchLoggingPerformed = timeNow;
}


void
SearchPerformanceLogFilter (DBPOS *pDB, SEARCHARG *pSearchArg)
{
    PWCHAR pszFilter;
    PWCHAR pszRequestedAttributes;
    PWCHAR pszServerControls;

    DBCreateSearchPerfLogData(
        pDB,
        pSearchArg->pFilter,
        FALSE,                          // filter is NOT internal
        pSearchArg->pSelection,
        &pSearchArg->CommArg,
        &pszFilter,
        &pszRequestedAttributes,
        &pszServerControls);

    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
             DS_EVENT_SEV_INTERNAL,
             DIRLOG_SEARCH_FILTER_LOGGING,
             szInsertWC(!pSearchArg->pObject->NameLen ? L"RootDSE" : pSearchArg->pObject->StringName),
             szInsertWC(pszFilter),
             szInsertUL(pDB->SearchEntriesVisited),
             szInsertUL(pDB->SearchEntriesReturned),
             szInsertSz(GetCallerTypeString(pDB->pTHS)),
             szInsertSz(pSearchArg->choice == SE_CHOICE_BASE_ONLY ? "base" :
                        pSearchArg->choice == SE_CHOICE_IMMED_CHLDRN ? "onelevel" : "subtree"),
             szInsertWC(pszRequestedAttributes),
             szInsertWC(pszServerControls)
             );

    DPRINT5 (1, "Filter %ws\nRequested: %ws\nControls: %ws\nReturned %d Visited %d\n",
                    pszFilter,
                    pszRequestedAttributes,
                    pszServerControls,
                    pDB->SearchEntriesReturned,
                    pDB->SearchEntriesVisited);

    THFreeEx (pDB->pTHS, pszFilter);
    THFreeEx (pDB->pTHS, pszRequestedAttributes);
    THFreeEx (pDB->pTHS, pszServerControls);
}



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Build the Ent Inf datastructure for the current object and add to
   the linked-list.  If we run out of RPC space, we throw away the partial
   object and sucessfully return.  Note however, that atleast 1 object must
   be able to fit in RPC space.
*/

int
GetNextEntInf (
    IN DBPOS *pDB,
    IN ENTINFSEL *pSel,
    IN RANGEINFSEL *pRange,
    IN ENTINFLIST **ppEntInfList,
    IN RANGEINFLIST **ppRangeInfList,
    IN ULONG SecurityDescriptorFlags,
    IN PSECURITY_DESCRIPTOR pSecurity,
    IN DWORD Flags,
    IN PCACHED_AC CachedAC,
    IN OPTIONAL PSID psidQuotaTrustee
    )
{
    THSTATE *pTHS = pDB->pTHS;
    ENTINFLIST *pNewEntList;
    RANGEINFLIST *pNewRangeList = NULL;     //initialized to avoid C4701
    RANGEINF *pRangeInf = NULL;
    DPRINT(3, "GetNextEntInf entered\n");

    if(pRange) {
        // A range was specified, so we need to allocate a range list
        (*ppRangeInfList)->pNext = THAllocEx(pTHS, sizeof(RANGEINFLIST));
        pNewRangeList = (*ppRangeInfList)->pNext;
        pRangeInf = &(pNewRangeList->RangeInf);
    }
    (*ppEntInfList)->pNextEntInf = THAllocEx(pTHS, sizeof(ENTINFLIST));

    pNewEntList = (*ppEntInfList)->pNextEntInf;

    if (GetEntInf2(pDB,
                  pSel,
                  pRange,
                  &(pNewEntList->Entinf),
                  pRangeInf,
                  SecurityDescriptorFlags,
                  pSecurity,
                  Flags,
                  CachedAC,
                  NULL,
                  psidQuotaTrustee)) {

        DPRINT(2,"Error in getting object info\n");
        return pTHS->errCode;
    }
    else {
         DPRINT1(5, "Object retrieved: %S\n", pNewEntList->Entinf.pName);
         *ppEntInfList = pNewEntList;
         if(pRange) {
             *ppRangeInfList = pNewRangeList;
         }
         return 0;
    }
}


/*-------------------------------------------------------------------------*/
/*
   Check if this is a continued operation (paged results).  Regardless, find
   the first object which matches the search.
*/

DWORD
FindFirstSearchObject (
        DBPOS *pDB,
        SEARCHARG *pSearchArg,
        PRESTART pArgRestart
        )
{
    ULONG dwSearchStatus;
    BOOL fNegDelta=FALSE;
    ULONG LocalSearchFlags;
    ULONG SearchFlags;
    BOOL  fVLVSearch = FALSE;
    PRESTART pArgVLVRestart = NULL;

    if (pDB->Key.pVLV) {
        fVLVSearch = TRUE;
        pArgVLVRestart = pDB->Key.pVLV->pVLVRequest->pVLVRestart;
    }

    // we don't want Delta usage with VLV, since VLV imposes
    // its own delta usage
    Assert ( (pSearchArg->CommArg.Delta && !fVLVSearch) ||
             (!pSearchArg->CommArg.Delta) );

    // we ignore Delta usage on ASQ
    if (pDB->Key.asqRequest.fPresent) {
        pSearchArg->CommArg.Delta = 0;
    }

    // Set up the search flags we'll use to find the first object based on
    // restarting or simply going to the first element of the index, ignoring
    // deltas and security.
    SearchFlags = SEARCH_FLAGS(pSearchArg->CommArg);

    // Set up the search flags we'll use to move away from that object to the
    // object which is the real first object after we take into account security
    // and deltas.
    LocalSearchFlags = SearchFlags;

    switch(pSearchArg->CommArg.Delta) {
    case DB_MoveFirst:
        // Fall through
    case DB_MoveLast:
        // Fall through
    case 0:
        // No Delta anyway.

        // In all these cases, we don't need to change anything about direction
        // and we aren't backing up.
        break;
    default:
        if(pSearchArg->CommArg.Delta < 0) {
            fNegDelta = TRUE;
            pSearchArg->CommArg.Delta *= -1;
            // Switch the DB_SEARCH_FORWARD flag in the local search flags.
            LocalSearchFlags = REVERSE_SEARCH_FLAGS(pSearchArg->CommArg);
        }
        break;
    }

    if (pArgRestart) {
        // restarted operation
        dwSearchStatus = DBRepositionSearch(pDB,
                                            pArgRestart,
                                            pSearchArg->CommArg.StartTick,
                                            pSearchArg->CommArg.DeltaTick,
                                            SearchFlags
                                            );
    }
    else if (pArgVLVRestart) {
        // VLV operation
        dwSearchStatus = DBRepositionSearch(pDB,
                                            pArgVLVRestart,
                                            pSearchArg->CommArg.StartTick,
                                            pSearchArg->CommArg.DeltaTick,
                                            SearchFlags
                                            );
    }
    else {
        DWORD dwIndexFlags = (pSearchArg->choice == SE_CHOICE_BASE_ONLY)
                                ? 0 : DBCHOOSEINDEX_fUSEFILTER;

        if(!(pSearchArg->CommArg.fForwardSeek)) {
            dwIndexFlags |= DBCHOOSEINDEX_fREVERSE_SORT;
        }

        if (pSearchArg->CommArg.PagedResult.fPresent) {
            dwIndexFlags |= DBCHOOSEINDEX_fPAGED_SEARCH;
        }

        if (fVLVSearch) {
            dwIndexFlags |= DBCHOOSEINDEX_fVLV_SEARCH;
        }

        if (SearchFlags & DB_SEARCH_DELETIONS_VISIBLE) {
            dwIndexFlags |= DBCHOOSEINDEX_fDELETIONS_VISIBLE;
        }

        // if the client asks to leave the results in a sorted table,
        // then we do that since we sort at the same time
        // otherwise we use the default mechanism,
        // which is creating a list of the returned entries in memory

        if (pSearchArg->fPutResultsInSortedTable) {
            dwIndexFlags |= DBCHOOSEINDEX_fUSETEMPSORTEDTABLE;
        }

        if ((dwSearchStatus = DBSetSearchScope(
                pDB,
                pSearchArg->choice,
                pSearchArg->bOneNC,
                pSearchArg->pResObj)) ||
            (dwSearchStatus = DBChooseIndex(
                    pDB,
                    pSearchArg->CommArg.StartTick,
                    pSearchArg->CommArg.DeltaTick,
                    pSearchArg->CommArg.SortAttr,
                    pSearchArg->CommArg.SortType,
                    dwIndexFlags,
                    pSearchArg->CommArg.MaxTempTableSize))) {
            return dwSearchStatus;
        }

#if DBG
        {
           KEY_INDEX *tmp_index;

           for (tmp_index = pDB->Key.pIndex; tmp_index; tmp_index = tmp_index->pNext) {
               DPRINT3 (2, "Cantidate Idx: %s(%d) %d\n", tmp_index->szIndexName, tmp_index->bIsIntersection, tmp_index->ulEstimatedRecsInRange);
           }
        }
#endif

        // check to see what kind of search operation control we are passed
        //
        if (pSearchArg->CommArg.Svccntl.DontPerformSearchOp) {

            DBGenerateLogOfSearchOperation (pDB);

            // if we are told not to find any object, but just optimize the filter,
            // return an error so as to finish searching.
            //
            if (pSearchArg->CommArg.Svccntl.DontPerformSearchOp & SO_ONLY_OPTIMIZE) {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
        // if we are tracing, and we already don't have created the logfilter
        // we do this now
        else if (gpDsEventConfig->fTraceEvents) {
            DBGenerateLogOfSearchOperation (pDB);
        }

        if (pSearchArg->fPutResultsInSortedTable) {
            return DB_ERR_NEXTCHILD_NOTFOUND;
        }

        // we don't want to find the first object here if we are doing VLV
        if (!fVLVSearch) {
            // enable the possible optimization of exact match searches for
            // this code path.  we can do this because we know that if we are
            // doing an exact match search then the last index we considered
            // during DBChooseIndex is the chosen index and that index is
            // already pointing to the correct record and no other intervening
            // JET calls have been made that could invalidate this currency.
            // as a result, we can pass this flag to tell DBGetNextSearchObject
            // that it may assume that we are already setup on the correct
            // record.  if this is not an exact match search that has found its
            // record then this flag has no effect
            dwSearchStatus= DBGetNextSearchObject(pDB,
                                                  pSearchArg->CommArg.StartTick,
                                                  pSearchArg->CommArg.DeltaTick,
                                                  SearchFlags | DB_SEARCH_OPT_EXACT_MATCH);
        }
    }

    // if we are doing a VLV search, then use special positioning for this
    if (fVLVSearch) {
        // if we are doing container based VLV, we have to check for
        // access rights on the container.
        if (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) {

            // look up the container object.
            if(DBTryToFindDNT(pDB, pDB->Key.ulSearchRootDnt)) {
                // The container couldn't be found, hence it is empty.
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }

            // Check access
            if(!IsAccessGrantedSimple(RIGHT_DS_LIST_CONTENTS, FALSE)) {
                DPRINT(1, "Access Denied Listing Contents of VLV search.\n");

                // set count to zero, since we don't allow you to see any entries
                pDB->Key.pVLV->contentCount = 0;

                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }

        // At this point, we need to position ourselves correctly
        // on the specified entry.

        dwSearchStatus = DBPositionVLVSearch (pDB, pSearchArg);

        return dwSearchStatus;
    }
    else if(dwSearchStatus && dwSearchStatus != DB_ERR_NEXTCHILD_NOTFOUND) {
        // Oops, we've already failed.  Other failures are handled below.
        return dwSearchStatus;
    }

    // Delta position adjustments
    if (pSearchArg->CommArg.Delta) {

        if(pSearchArg->CommArg.Delta == DB_MoveFirst) {
            pDB->Key.fSearchInProgress = FALSE;
            dwSearchStatus =
                DBGetNextSearchObject(pDB,
                                      pSearchArg->CommArg.StartTick,
                                      pSearchArg->CommArg.DeltaTick,
                                      SearchFlags);
            pSearchArg->CommArg.Delta = 0;
        }
        else if(pSearchArg->CommArg.Delta == DB_MoveLast) {
            // Drop any positioning we currently have, switch the forward bit in the
            // flags, and reposition.  We switch the forward bit so that we will go
            // to the end of the index instead of the beginning.
            pDB->Key.fSearchInProgress = FALSE;
            dwSearchStatus =
                DBGetNextSearchObject(pDB,
                                      pSearchArg->CommArg.StartTick,
                                      pSearchArg->CommArg.DeltaTick,
                                      REVERSE_SEARCH_FLAGS(pSearchArg->CommArg));
            if(dwSearchStatus == DB_ERR_TIMELIMIT) {
                // We bail out if we get this error.
                return dwSearchStatus;
            }
            if (pSearchArg->CommArg.fForwardSeek || pDB->Key.fChangeDirection) {
                DBMove(pDB, FALSE, DB_MoveNext);
            } else {
                DBMove(pDB, FALSE, DB_MovePrevious);
            }
            dwSearchStatus = DB_ERR_NEXTCHILD_NOTFOUND;
            pSearchArg->CommArg.Delta = 0;
        }
        else if(dwSearchStatus && pSearchArg->CommArg.Delta && fNegDelta) {
            // We aren't on an object (so we are logically past the end of the
            // list), but we need to apply a delta backwards.  Force the code path
            // to back up.
            dwSearchStatus = 0;
        }
    }

    // At this point, we are on the beginning object of the search (that is,
    // we are either at the beginning of the index if DB_MoveFirst was
    // specified, the end if DB_MoveLast was specified, or somewhere in the
    // middle if we did a restart. Now, walk away
    // from that object applying security and the delta we were given to arrive
    // at the "real" first object.

    while(!dwSearchStatus) {
        // Found something, apply list rights.
        if(IsObjVisibleBySecurity(pDB->pTHS, !IsExactMatch(pDB))) {
            // List rights OK
            if(pSearchArg->CommArg.Delta) {
                // But we need to skip some.
                pSearchArg->CommArg.Delta--;
            }
            else {
                // And we don't need to skip any
                break;
            }
        }

        dwSearchStatus = DBGetNextSearchObject(
                pDB,
                pSearchArg->CommArg.StartTick,
                pSearchArg->CommArg.DeltaTick,
                LocalSearchFlags );
    }

    if((dwSearchStatus == DB_ERR_NEXTCHILD_NOTFOUND) && fNegDelta) {
        // Not on a valid object, and we were backing up.  That means we should
        // find the first object.  Call recursively to avoid duplicate code, but
        // recursion depth will never be greater than 1.
        pSearchArg->CommArg.Delta = DB_MoveFirst;
        return FindFirstSearchObject (pDB,
                                      pSearchArg,
                                      pArgRestart);
    }

    return dwSearchStatus;
}


void
AddCurrentObjectToAsqReferrals (THSTATE *pTHS,
                                DWORD *pcASQRefCount,
                                DWORD *pcASQRefAlloced,
                                DWORD **ppASQReferrals)
{
    DWORD DNT, actualRead;
    DWORD err;

    if (*ppASQReferrals == NULL) {
        *pcASQRefAlloced = 32;
        *ppASQReferrals = THAllocEx (pTHS, sizeof (DWORD) * (*pcASQRefAlloced));
    }
    else if (*pcASQRefCount >= *pcASQRefAlloced) {
        *pcASQRefAlloced = *pcASQRefAlloced * 2;
        *ppASQReferrals = THReAllocEx (pTHS, *ppASQReferrals, sizeof (DWORD) * (*pcASQRefAlloced));
    }

    // REVIEW:  why don't we just use pTHS->pDB->DNT?
    if (err = DBGetSingleValue (pTHS->pDB, FIXED_ATT_DNT, &DNT, sizeof (DNT), &actualRead)) {
        DPRINT1 (0, "Error reading DNT: 0x%x\n", err);
        // REVIEW:  the only way we can get here is if the DNT is NULL (and it can't be)
        // REVIEW:  so this is dead code
        return;
    }

    (*ppASQReferrals)[*pcASQRefCount] = DNT;

    *pcASQRefCount = *pcASQRefCount + 1;

    DPRINT1 (1, "ASQREF for DNT: 0x%x\n", DNT);

    return;
}

void
GenerateASQ_POQ(THSTATE *pTHS,
                const SEARCHARG *pSearchArg,
                PARTIALOUTCOME **ppPOQ,
                DWORD cASQRefCount,
                DWORD *pASQReferrals)
{
    DBPOS * pDB = pTHS->pDB;
    DSNAME *pObject;
    ATTRBLOCK *pObjB = NULL;
    PARTIALOUTCOME * pPOQ;
    CONTREF *pContRef, **ppContRef;
    DWORD DNT, actualRead;
    DWORD err, i;


    DPRINT1 (0, "GENERATING %d refferral(s) for ASQ\n", cASQRefCount);

    pPOQ = *ppPOQ;

    if (pPOQ == NULL) {
        // no POQ allocated yet
        pPOQ = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
        pPOQ->problem = PA_PROBLEM_ADMIN_LIMIT;
    }

    pContRef = pPOQ->pUnexploredDSAs;
    ppContRef = &pPOQ->pUnexploredDSAs;


    for (i=0; i<cASQRefCount; i++) {
        DNT = pASQReferrals[i];

        pObject = DBGetDSNameFromDnt (pDB, DNT);
        if (!pObject) {
            DPRINT (0, "Error getting DSNAME\n");
            return;
        }
        DPRINT1 (0, "ASQREF: %ws\n", pObject->StringName);

        err = DSNameToBlockName(pTHS, pObject, &pObjB, DN2BN_PRESERVE_CASE);
        if (err) {
            DPRINT (0, "Bad Name\n");
            return;
        }

        // Alloc and stitch in the Contref
        pContRef = THAllocEx(pTHS, sizeof(CONTREF));
        pContRef->pNextContRef = pPOQ->pUnexploredDSAs;
        pPOQ->pUnexploredDSAs = pContRef;
        pPOQ->count++;

        pContRef->pTarget = pObject;

        pContRef->pNewFilter = pSearchArg->pFilter;

        // Ok, now we need to aim the search at the DC
        pContRef->pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
        pContRef->pDAL->pNextAddress = NULL; // one address per target
        GenSupRef(pTHS,
                  pContRef->pTarget,
                  pObjB,
                  &pSearchArg->CommArg,
                  &pContRef->pDAL->Address);

        FreeBlockName(pObjB);
    }

    // Did we find anything worth returning?  If so, return it.  If we
    // entered with an existing POQ this step is unnecessary, but if
    // we created the POQ here then it's needed.  Why make it conditional?
    // To handle the case where no unexplored DSAs were found, and no
    // POQ should be returned.
    if (pPOQ->pUnexploredDSAs) {
        *ppPOQ = pPOQ;
    }
}


void
GeneratePOQ(THSTATE *pTHS,
            const SEARCHARG *pSearchArg,
            PARTIALOUTCOME **ppPOQ)
{
    const DSNAME * const pObject = pSearchArg->pObject;
    const UCHAR choice = pSearchArg->choice;
    PARTIALOUTCOME * pPOQ;
    DBPOS * pDB = pTHS->pDB;
    ULONG it;
    ULONG len, iVal;
    DWORD err;
    ATTCACHE * pAC;
    DSNAME *pSRName = NULL;
    CONTREF *pContRef, **ppContRef;
    DSNAME *pName = NULL;
    WCHAR * pDNS;
    CROSS_REF *pCrossRef;
    ATTRTYP ObjClass;
    PSUBREF_LIST pDomainSubref;
    BOOL fDomainSubrefHit;
    DWORD i, nVal;
    DSA_ADDRESS_LIST *pDAL;

    pPOQ = *ppPOQ;

    if (!pSearchArg->bOneNC &&
        pSearchArg->choice != SE_CHOICE_IMMED_CHLDRN) {
        // The only time we issue referrals on a GC search should be
        // for the special ABView referrals, which we only issue for
        // one level searches.
        return;
    }
    if (pPOQ == NULL) {

        // no POQ allocated yet
        pPOQ = THAllocEx(pTHS, sizeof(PARTIALOUTCOME));
        pPOQ->problem = PA_PROBLEM_ADMIN_LIMIT;

        // WHy an admin limit?  Because the only case where we
        // generate a brand-new POQ here is from encountering NC
        // boundaries.  If we've already encountered a size or time
        // limit, we'll let that POQ code stand as is, and just return
        // the contrefs as a bonus.  Note the special handling of pPOQ
        // at the end of this routine for the other half of this logic.
    }
    pPOQ->count = 0;

    ObjClass = pSearchArg->pResObj->MostSpecificObjClass;
    it = pSearchArg->pResObj->InstanceType;

    if (pSearchArg->bOneNC) {
        // We need to go to the NC head to get the subref information. The
        // assert swears that if the search root is an NC head, then our resobj
        // NCDNT matches our DNT, meaning that we're going to the right place.
        Assert(   !!(it & IT_NC_HEAD)
               == !!(pSearchArg->pResObj->NCDNT == pSearchArg->pResObj->DNT));

        Assert(pPOQ->pUnexploredDSAs == 0);
        ppContRef = &pPOQ->pUnexploredDSAs;

        // Check the cache of ATT_SUB_REFS in gAnchor
        if (pSearchArg->pResObj->NCDNT == gAnchor.ulDNTDomain &&
            gAnchor.fDomainSubrefList) {

            // For each cached ATT_SUB_REFS
            for (pDomainSubref = gAnchor.pDomainSubrefList;
                 pDomainSubref;
                 pDomainSubref = pDomainSubref->pNextSubref) {

                fDomainSubrefHit = FALSE;

                // Is the subref subordinate to this object?
                if (choice == SE_CHOICE_WHOLE_SUBTREE) {
                    for (i = 0; i < pDomainSubref->cAncestors; ++i) {
                        if (*(pDomainSubref->pAncestors + i) == pSearchArg->pResObj->DNT) {
                            fDomainSubrefHit = TRUE;
                            break; // out of inner for
                        }
                    }
                }
                // Is the subref an immediate child of this object?
                else if (   (choice == SE_CHOICE_IMMED_CHLDRN)
                           && (pDomainSubref->cAncestors > 1)
                           && (*(pDomainSubref->pAncestors + 1) == pSearchArg->pResObj->DNT)) {
                    fDomainSubrefHit = TRUE;
                }
                // HIT. save a copy of the DSName
                if (fDomainSubrefHit) {
                    *ppContRef = pContRef = THAllocEx(pTHS, sizeof(CONTREF));
                    ppContRef = &pContRef->pNextContRef;
                    pContRef->pTarget = THAllocEx(pTHS,
                                                  pDomainSubref->pDSName->structLen);
                    CopyMemory(pContRef->pTarget,
                               pDomainSubref->pDSName,
                               pDomainSubref->pDSName->structLen);
                    pPOQ->count++;
                }
            }
        }
        // Read the subrefs because the cache isn't valid for this search.
        else {
            if (pObject->NameLen == 0) {
                err = DBFindDNT(pDB, pSearchArg->pResObj->DNT);
                if (err) {
                    LogUnhandledError(err);
                    return;
                }
                err = DBGetAttVal(pDB,
                                1,
                                ATT_OBJ_DIST_NAME,
                                0,
                                0,
                                &len,
                                (UCHAR**)&pObject);
                if (err) {
                    LogUnhandledError(err);
                    return;
                }
            }

            err = DBFindDNT(pDB, pSearchArg->pResObj->NCDNT);
            if (err) {
                LogUnhandledError(err);
                return;
            }

            iVal = 1;
            pAC = SCGetAttById(pTHS, ATT_SUB_REFS);
            //
            // PREFIX: PREFIX complains that pAC hasn't been checked to
            // make sure that it is not NULL.  This is not a bug.  Since
            // a predefined constant was passed to SCGetAttById, pAC will
            // never be NULL.
            //

            Assert(pAC);

            while (0 == DBGetAttVal_AC(pDB,
                                       iVal,
                                       pAC,
                                       0,
                                       0,
                                       &len,
                                       (UCHAR**)&pSRName)) {
                pName = (DSNAME *)THAllocEx(pTHS, pSRName->structLen);
                if (((choice == SE_CHOICE_IMMED_CHLDRN) &&
                     (0 == TrimDSNameBy(pSRName, 1, pName)) &&
                     NameMatched(pObject, pName))
                    ||
                    ((choice == SE_CHOICE_WHOLE_SUBTREE) &&
                     NamePrefix(pObject, pSRName))) {

                    *ppContRef = pContRef = THAllocEx(pTHS, sizeof(CONTREF));
                    ppContRef = &pContRef->pNextContRef;
                    pContRef->pTarget = pSRName;
                    pSRName = NULL;
                    pPOQ->count++;
                }
                else {
                    THFreeEx(pTHS, pSRName);
                }
                ++iVal;
                // Free memory allocated in this iteration of while
                THFreeEx(pTHS, pName);
            }
        }
    }

    pContRef = pPOQ->pUnexploredDSAs;
    ppContRef = &pPOQ->pUnexploredDSAs;
    while (pContRef) {
        // Find the in memory CrossRef structure corresponding to this NC
        pCrossRef = FindExactCrossRef(pContRef->pTarget,
                                      &pSearchArg->CommArg);
        if (!pCrossRef) {
            /*
             * Once replication has quiesced, we should have a cross-ref
             * for every sub-ref.  While replication is still going on,
             * though, we could easily have replicated in a sub-ref with
             * one naming context before we have fully synched the config
             * NC, meaning that the cross-ref would not have replicated in
             * yet.  This means that we can't make a blanket assertion that
             * we should have a cross ref.  Instead we can only assert that
             * this should be the case if replication is complete.
             */
            DPRINT1(0, "Can't find cross-ref for %ls\n",
                        pContRef->pTarget->StringName);
            LooseAssert(!"Can't find cross-ref object!", SubrefReplicationDelay);

            goto SkipIt;
        }

        if(!pCrossRef->bEnabled){
            // We don't generate referrals of any kind for disabled
            // crossRefs.  As far as the directory is concerned we this
            // part of the directory does not exist yet.
            goto SkipIt;
        }

        // No referrals?
        if (0 == pCrossRef->DnsReferral.valCount) {
            goto SkipIt;
        }

        // Add each dns name
        pContRef->pDAL = NULL; // just in case
        for (nVal = 0; nVal < pCrossRef->DnsReferral.valCount; ++nVal) {
            len = pCrossRef->DnsReferral.pAVal[nVal].valLen;
            pDNS = THAllocEx(pTHS, len);
            memcpy(pDNS, pCrossRef->DnsReferral.pAVal[nVal].pVal, len);

            Assert(len < 64*1024);

            // Copy the address information into the Continuation
            pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
            pDAL->pNextAddress = pContRef->pDAL;
            pDAL->Address.Length = (unsigned short) len;
            pDAL->Address.MaximumLength = (unsigned short) len;
            pDAL->Address.Buffer = pDNS;
            pContRef->pDAL = pDAL;
        }
        if (choice == SE_CHOICE_IMMED_CHLDRN) {
            pContRef->bNewChoice = TRUE;
            pContRef->choice = SE_CHOICE_BASE_ONLY;
        }

        /* Since we have successfully processed this entry, step to the
         * next entry in the list.
         */
        ppContRef = &pContRef->pNextContRef;
        pContRef = pContRef->pNextContRef;
        continue;

        /* this line is not reached */
SkipIt:
        /* This contref was messed up for some reason, so we want to snip
         * it out of the list, so that all contrefs in our output list
         * are valid
         */
        pPOQ->count--;             // decrement the count of contrefs
        *ppContRef = pContRef->pNextContRef; // step around the element
        THFreeEx(pTHS, pContRef->pTarget); // free a sub part
        THFreeEx(pTHS, pContRef);          // free the contref
        pContRef = *ppContRef;     // reset our loop pointer
    }

    if ((ObjClass == CLASS_ADDRESS_BOOK_CONTAINER) &&
        (pSearchArg->choice == SE_CHOICE_IMMED_CHLDRN)) {
        // Ok, this was a one-level search under an ABView, which means
        // that we get to construct a magic search continuation.  The
        // search described will have be to a GC (always), have a base
        // object of root, be whole subtree, and have a filter that is
        // an AND of the input filter, a special Show-In this View filter,
        // and DISPLAY_NAME present (the index we maintain over Show-In is
        // compound over show-in and display-name, and is defined
        // ignore_any_null, so we can only use it in the display-name present
        // case.
        FILTER * pFilterTemp;

        // Alloc and stitch in the Contref
        pContRef = THAllocEx(pTHS, sizeof(CONTREF));
        pContRef->pNextContRef = pPOQ->pUnexploredDSAs;
        pPOQ->pUnexploredDSAs = pContRef;
        pPOQ->count++;

        // re-base the search to the root
        pContRef->pTarget = THAllocEx(pTHS, DSNameSizeFromLen(0));
        pContRef->pTarget->structLen = DSNameSizeFromLen(0);

        // re-scope the search
        pContRef->bNewChoice = TRUE;
        pContRef->choice = SE_CHOICE_WHOLE_SUBTREE;

        // re-filter the search
        pContRef->pNewFilter = THAllocEx(pTHS, sizeof(FILTER));
        pContRef->pNewFilter->choice = FILTER_CHOICE_AND;
        pContRef->pNewFilter->FilterTypes.And.count = 3;
        pContRef->pNewFilter->FilterTypes.And.pFirstFilter =
            pFilterTemp = THAllocEx(pTHS, 2 * sizeof(FILTER));

        // First clause: Show-In is the address book in question
        pFilterTemp->choice = FILTER_CHOICE_ITEM;
        pFilterTemp->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.type =
          ATT_SHOW_IN_ADDRESS_BOOK;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.valLen =
          pSearchArg->pObject->structLen;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.pVal =
          (UCHAR*)(pSearchArg->pObject);
        pFilterTemp->pNextFilter = &pFilterTemp[1];
        pFilterTemp++;

        // Second clause: Display-name present
        pFilterTemp->choice = FILTER_CHOICE_ITEM;
        pFilterTemp->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.type =
            ATT_DISPLAY_NAME;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.valLen = 0;
        pFilterTemp->FilterTypes.Item.FilTypes.ava.Value.pVal = NULL;

        // Third clause: Pick up the filter they gave us.
        pFilterTemp->pNextFilter = pSearchArg->pFilter;

        // Ok, now we need to aim the search at a GC
        pContRef->pDAL = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST));
        pContRef->pDAL->pNextAddress = NULL; // one address per target
        GenSupRef(pTHS,
                  pContRef->pTarget,
                  gpRootDNB,
                  &pSearchArg->CommArg,
                  &pContRef->pDAL->Address);

    }

    // Did we find anything worth returning?  If so, return it.  If we
    // entered with an existing POQ this step is unnecessary, but if
    // we created the POQ here then it's needed.  Why make it conditional?
    // To handle the case where no unexplored DSAs were found, and no
    // POQ should be returned.
    if (pPOQ->pUnexploredDSAs) {
        *ppPOQ = pPOQ;
    }
}


VOID
SimpleBaseSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags
        )
{
    ULONG                ulLen;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD               getEntInfFlags = 0;
    RESOBJ              *pResObjArg;
    BOOL                fSDIsGlobalSDRef;

    // Before we start, mark that we are as sorted as we were requested to be.
    pTHS->pDB->Key.ulSorted = pSearchArg->CommArg.SortType;
    pSearchRes->bSorted = (pTHS->pDB->Key.ulSorted != SORT_NEVER);

    pTHS->pDB->SearchEntriesVisited++;
    PERFINC(pcSearchSubOperations);

    // First, make sure we have list content rights on the parent.
    if (!(pTHS->fDSA || pTHS->fDRA)) {
        if (!IsObjVisibleBySecurity(pTHS, FALSE)) {
            // No list-contents on parent.  We match nothing.
            CheckObjDisclosure(pTHS, pSearchArg->pResObj, FALSE);
            return;
        }

        // Now, get the security descriptor for this object.
        if(!(flags & SEARCH_UNSECURE_SELECT)) {
            DBPOS* pDB = pTHS->pDB;
            char objFlag;
            DWORD err;
            err = DBGetObjectSecurityInfo(
                    pDB,
                    pDB->DNT,
                    &ulLen,
                    &pSec,
                    NULL,
                    NULL,
                    &objFlag,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef
                );
            if (err) {
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }
            // Every object should have an SD.
            Assert(objFlag == 0 || ulLen > 0);
        }
    }

    SvccntlFlagsToGetEntInfFlags(&pSearchArg->CommArg.Svccntl,&getEntInfFlags);

    if(flags & SEARCH_UNSECURE_SELECT) {
        getEntInfFlags |= GETENTINF_NO_SECURITY;
    }

    if ((pSearchArg->pResObj->pObj->NameLen)
        || (pSearchArg->pSelection->infoTypes  == EN_INFOTYPES_SHORTNAMES)) {
        // If we already have a good enough object name, don't fetch another
        pResObjArg = pSearchArg->pResObj;
    }
    else {
        pResObjArg = NULL;
    }

    // Do the GetEntInf
    if(!GetEntInf2(pTHS->pDB,
                  pSearchArg->pSelection,
                  pSearchArg->pSelectionRange,
                  &pSearchRes->FirstEntInf.Entinf,
                  &pSearchRes->FirstRangeInf.RangeInf,
                  pSearchArg->CommArg.Svccntl.SecurityDescriptorFlags,
                  pSec,
                  getEntInfFlags,
                  NULL,
                  pResObjArg,
                  pSearchArg->CommArg.pQuotaSID)) {

#if 0
        //
        // This is #if 0 instead of removed to allow for our bosses to
        // change their minds on the issue of whether we should be returning
        // an error or not
        //

        if ((pSearchRes->FirstEntInf.Entinf.AttrBlock.attrCount == 0) &&
            (pSearchArg->pSelection) &&
            (pSearchArg->pSelection->AttrTypBlock.attrCount != 0)) {

            // it is an error if the user requested a list of
            // attributes and none were found on any objects.

            SetAttError(pSearchArg->pObject, 0L,
                        PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, NULL,
                        DIRERR_NO_REQUESTED_ATTS_FOUND);
        }
#endif
        // success, set the count.
        pTHS->pDB->SearchEntriesReturned = 1;
        pSearchRes->count = 1;
    }

    if(pSec && !fSDIsGlobalSDRef) {
        THFreeEx(pTHS, pSec);
    }

    return;
} // SimpleBaseSearch

BOOL
IsBaseOnlyAttPresent(
    SEARCHARG *pSearchArg
)
{
   ULONG i;
   ENTINFSEL *pSel = pSearchArg->pSelection;

   if (!pSel) {
      // no selection to check
      // return false, since constructed atts are returned
      // only when explicitly asked for, that is, there is
      // a selection
      return FALSE;
   }

   for (i=0; i<pSel->AttrTypBlock.attrCount; i++) {
       switch(pSel->AttrTypBlock.pAttr[i].attrTyp) {
          case ATT_TOKEN_GROUPS:
          case ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE:
              if (pSearchArg->choice != SE_CHOICE_BASE_ONLY) {
                 // non-base search
                 return TRUE;
              }
              break;
          default:
             // more attributes may need to be added later
             ;
       }
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\nlwrap.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nlwrap.c
//
//--------------------------------------------------------------------------

/* 
    This file contains wrappers for various netlogon routines and either
    stubs them out or passes them on to netlogon depending on whether
    we're running as an executable or inside the lsass process.

    Remember to use STATUS_NOT_IMPLEMENTED, not STATUS_SUCCESS for 
    routines which have OUT parameters.
*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nlwrap.h>                     // wrapper prototypes
#include <lsaisrv.h>

extern BOOL gfRunningInsideLsa;

NTSTATUS
dsI_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetNotifyNtdsDsaDeletion(
                                DnsDomainName,
                                DomainGuid,
                                DsaGuid,
                                DnsHostName);
}

NTSTATUS
dsI_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_NOT_IMPLEMENTED;
    }

    return I_NetLogonReadChangeLog(
                                InContext,
                                InContextSize,
                                ChangeBufferSize,
                                ChangeBuffer,
                                BytesRead,
                                OutContext,
                                OutContextSize);
}

NTSTATUS
dsI_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_NOT_IMPLEMENTED;
    }

    return I_NetLogonNewChangeLog(ChangeLogHandle);
}

NTSTATUS
dsI_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetLogonAppendChangeLog(
                                ChangeLogHandle,
                                ChangeBuffer,
                                ChangeBufferSize);
}

NTSTATUS
dsI_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetLogonCloseChangeLog(ChangeLogHandle, Commit);
}

NTSTATUS
dsI_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_NOT_IMPLEMENTED;
    }

    return I_NetLogonLdapLookupEx(
                                Filter,
                                SockAddr,
                                Response,
                                ResponseSize);
}

NTSTATUS
dsI_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    if ( ServiceBitsOfInterest & DS_GC_FLAG ) {
        LsaINotifyGCStatusChange( !!(ServiceBits & DS_GC_FLAG) );
    }

    return I_NetLogonSetServiceBits(ServiceBitsOfInterest, ServiceBits);
}

VOID
dsI_NetLogonFree(
    IN PVOID Buffer
    )
{
    if ( !gfRunningInsideLsa ) {
        return;
    }

    I_NetLogonFree(Buffer);
}

NTSTATUS
dsI_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    )
{
    if ( !gfRunningInsideLsa ) {
        return STATUS_SUCCESS;
    }

    return I_NetNotifyDsChange(DsChangeType);
}

NET_API_STATUS
dsDsrGetDcNameEx2(
    IN LPWSTR ComputerName OPTIONAL,
    IN LPWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
{
    if ( !gfRunningInsideLsa ) {
        return ERROR_INVALID_FUNCTION;
    }

    return(DsrGetDcNameEx2(
                        ComputerName,
                        AccountName,
                        AllowableAccountControlBits,
                        DomainName,
                        DomainGuid,
                        SiteName,
                        Flags,
                        DomainControllerInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\msrpc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msrpc.c
//
//--------------------------------------------------------------------------

/*
Description:
    Routines to setup MS RPC, server side.
*/

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include <dsconfig.h>
#include <dsutil.h>
#include "dsexcept.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB  "MSRPC:"                // Define subsystem for debugging

// RPC interface headers
#include <nspi.h>
#include <drs.h>
#include <sddl.h>

#include "msrpc.h"          /* Declarations of exports from this file */

#include <ntdsbcli.h>
#include <ntdsbsrv.h>

#include <fileno.h>
#define  FILENO FILENO_MSRPC

#define DRS_INTERFACE_ANNOTATION        "MS NT Directory DRS Interface"
#define NSP_INTERFACE_ANNOTATION        "MS NT Directory NSP Interface"

BOOL gbLoadMapi = FALSE;
ULONG gulLDAPServiceName=0;
PUCHAR gszLDAPServiceName=NULL;

char szNBPrefix[] ="ncacn_nb";

int gRpcListening = 0;
int gNumRpcNsExportedInterfaces = 0;
RPC_IF_HANDLE gRpcNsExportedInterface[MAX_RPC_NS_EXPORTED_INTERFACES];

// Used to set the max rpc threads and max jet sessions; although the call
// to set the max rpc threads is a NOP when ntdsa is running in lsass
// because the process-wide, max number of rpc threads has already been set
// to 12,345 by some other subsystem.
//
// Make this configurable in the future. 
ULONG ulMaxCalls = 15;

//
// The maximum incoming RPC message to accept.  Currently this is the 
// same as the default limit on LDAP message plus some fudge since this
// isn't a precise limit according to the RPC group.  This also should
// be made configurable in the future.
ULONG cbMaxIncomingRPCMessage = (13 * (1024 * 1024)); // 13MB 

BOOL StartServerListening(void);

/*
 * We should get this from nspserv.h, but it's defined with MAPI stuff there.
 */
extern UUID muidEMSAB;

#define DEFAULT_PROTSEQ_NUM 20

typedef struct _PROTSEQ_INFO {
    UCHAR * pszProtSeq;
    UCHAR * pszEndpoint;
    BOOL fAvailable;
    BOOL fRegistered;
    DWORD dwInterfaces;
} PROTSEQ_INFO;

ULONG gcProtSeqInterface = 0;
PROTSEQ_INFO grgProtSeqInterface[DEFAULT_PROTSEQ_NUM];

typedef struct _DEFAULT_PROTSEQ {
    UCHAR * pszProtSeq;
    UCHAR * pszEndpoint;
    BOOL fRegOnlyIfAvail;
} DEFAULT_PROTSEQ;

typedef struct _DEFAULT_PROTSEQ_INFO {
    ULONG cDefaultProtSeq;
    DEFAULT_PROTSEQ * rgDefaultProtSeq;
} DEFAULT_PROTSEQ_INFO;

// add new protseqs for each protocol here...  
// 	format is {PROTOCOL, ENDPOINT, fRegisterOnlyIfAvailable}
//         if the default protseq list changes, simply change this
//         list for whichever interface.
//
//      if the user would like to add protseqs, they should use 
//      the registry keys in rgInterfaceProtSeqRegLoc (below)
//
//      Note that the maximum prot seq's for one DC is DEFAULT_PROTSEQ_NUM
// 		(that's for all interfaces combined, not counting
//		repeats)
//
// implementation note:
//	we go through these in order, and add the protseqs in order
//      since there are only 3 protseqs by default, we haven't made
//      any complicated structure for searching for them.  If this
//      isn't so - ie we expect a lot of different protseqs, either
//      by adding defaults below, or from reg input, then we should
//      search via a hash or something.  instead, I put the most
//      used first in the list below, so that they are first in the
//      global list and therefore will be found the quickest, etc.  
DEFAULT_PROTSEQ rgDefaultDrsuapiProtSeq[] = {
	{TCP_PROTSEQ, NULL, 0}, 
	{LPC_PROTSEQ, DS_LPC_ENDPOINT, 1} 
}; 

DEFAULT_PROTSEQ rgDefaultDsaopProtSeq[] = {
	{TCP_PROTSEQ, NULL, 0}, 
	{LPC_PROTSEQ, DS_LPC_ENDPOINT, 1} 
};

DEFAULT_PROTSEQ rgDefaultNspiProtSeq[] = {
	{TCP_PROTSEQ, NULL, 0}, 
	{LPC_PROTSEQ, DS_LPC_ENDPOINT, 1}, 
	{HTTP_PROTSEQ, NULL, 1},
        {NP_PROTSEQ, NULL, 1}
}; 

DEFAULT_PROTSEQ_INFO rgDefaultDrsuapiProtSeqInfo = {
    sizeof(rgDefaultDrsuapiProtSeq)/sizeof(rgDefaultDrsuapiProtSeq[0]), 
    rgDefaultDrsuapiProtSeq
    };
DEFAULT_PROTSEQ_INFO rgDefaultDsaopProtSeqInfo = {
    sizeof(rgDefaultDsaopProtSeq)/sizeof(rgDefaultDsaopProtSeq[0]), 
    rgDefaultDsaopProtSeq
    };
DEFAULT_PROTSEQ_INFO rgDefaultNspiProtSeqInfo = {
    sizeof(rgDefaultNspiProtSeq)/sizeof(rgDefaultNspiProtSeq[0]), 
    rgDefaultNspiProtSeq
    };

#define DRSUAPI_INTERFACE 0
#define DSOAP_INTERFACE 1
#define NSPI_INTERFACE 2 // should be MAX_RPC_NS_EXPORTED_INTERFACES -1

#define VALIDATE_INTERFACE_NUM(iInterface) Assert((iInterface<=NSPI_INTERFACE) && (iInterface>=DRSUAPI_INTERFACE))

DEFAULT_PROTSEQ_INFO * rgpDefaultIntProtSeq[MAX_RPC_NS_EXPORTED_INTERFACES] = {
    &rgDefaultDrsuapiProtSeqInfo, // DRSUAPI_INTERFACE
    &rgDefaultDsaopProtSeqInfo, // DSOAP_INTERFACE
    &rgDefaultNspiProtSeqInfo // NSPI_INTERFACE
};

LPSTR rgInterfaceProtSeqRegLoc[MAX_RPC_NS_EXPORTED_INTERFACES] = {
    DRSUAPI_INTERFACE_PROTSEQ,
    DSAOP_INTERFACE_PROTSEQ,
    NSPI_INTERFACE_PROTSEQ
};

#define PROTSEQ_NOT_FOUND -1

INT
GetProtSeqInList(
    UCHAR * pszProtSeq, 
    UCHAR * pszEndpoint) 
/*++

  Description:
    Looks for a ProtSeq and Endpoint pair in the global data struct. 
	
  Arguments:
    pszProtSeq
    pszEndpoint

  Return Value:
    The index of the protseq_info block in the global array is returned if found, 
    PROTSEQ_NOT_FOUND otherwise.
 
--*/

{

    ULONG i = 0;

    DPRINT2(3, "GetProtSeqInList Entered with %s (%s)\n", pszProtSeq, pszEndpoint);

    for (i=0; i<gcProtSeqInterface; i++) {
	if (!_stricmp(grgProtSeqInterface[i].pszProtSeq, pszProtSeq)
	    && 
	    (
	     (((pszEndpoint==NULL) && (grgProtSeqInterface[i].pszEndpoint==NULL))) ||  
	     (((pszEndpoint!=NULL) && (grgProtSeqInterface[i].pszEndpoint!=NULL)) && 
	      (!_stricmp(grgProtSeqInterface[i].pszEndpoint, pszEndpoint)))
	     )
	    ) {
	    DPRINT1(3, "GetProtSeqInList Exit with %d\n", i);
	    return i;
	} 
    }
    DPRINT1(3, "GetProtSeqInList Exit with %d\n", PROTSEQ_NOT_FOUND);
    return PROTSEQ_NOT_FOUND;
}

DWORD
VerifyProtSeqInList(
    UCHAR * pszProtSeq, 
    UCHAR * pszEndpoint,
    ULONG iInterface
    )
/*++

  Description:
    Verifies that iInterface is registered in the global list for the given 
    ProtSeq and Endpoint. 
	
  Arguments:
    pszProtSeq
    pszEndpoint
    iInterface (DRSUAPI_INTERFACE, DSOAP_INTERFACE, NSPI_INTERFACE)

  Return Value:
    The index of the protseq_info block in the global array is returned if found and verified, 
    PROTSEQ_NOT_FOUND otherwise.
    
  
    The list has a bit mask for each interface registered with each protseq.  Shifting
    the interface value will get the bit field value.  Note that if a default endpoint
    was registered (NULL), we can't validate the input endpoint, so we accept in that case.
 
--*/
{
    ULONG i = 0;

    DPRINT3(3, "VerifyProtSeqInList Entered with %s (%s) for %d\n", pszProtSeq, pszEndpoint, iInterface);
    VALIDATE_INTERFACE_NUM(iInterface);

    for (i=0; i<gcProtSeqInterface; i++) {
	if (!_stricmp(grgProtSeqInterface[i].pszProtSeq, pszProtSeq)
	    /*
	    // gregjohn - 8/23/2002
	    
	    // ideally we could verify the caller not only used the right protseq, but also the right
	    // endpoint - ie one we specifically registered.  This isn't possible right now.  Perhaps in
	    // longhorn (so say the Rpc devs).  Specifically why this won't work, is the following situation:
	    // if drsuapi registerd tcp/ip on port 3001, and another in process interface registered a dynamic port
	    // then it would depend *who* registered first as to what would get denied from this function.  
	    // Why?  Because if we registered first, then the "dynamic" port would be 3001 (dynamic means "I don't 
	    // care" so RPC chooses one already in existance.  If they registered first the dynamic port  would be
	    // in the 1000 block - say 1026 w.l.o.g.  Now, in the first case everything *currently* works fine.  The
	    // server returns all endpoints on the tcp protseq for our interface : 3001.  Success.  
	    // In the second case when our callers ask for all enpoints on the tcp protseq for our interface, they get
	    // 1026 first, and then 3001.  Currently our implemented callers all use the first one given from the endpoint
	    // mapper (since we don't walk it ourselves).  But - big but - the order of the endpoints returned isn't
	    // guarenteed by RPC, rather it's implied.  So, that means even if we could ensure that we registered first,
	    // before anyone else, if they registered a non dynamic endpoint - say 4001, our clients would get a random
	    // choice between 4001 and 3001 to use to call us - so we have to ignore the endpoint they used and simply
	    // validate the protseq.  (I'm leaving this code here, because they say they're working on support for this
	    // in the next release.)
	    
	    && 
	    (
	     (
	      (grgProtSeqInterface[i].pszEndpoint==NULL) ||  
	     (((pszEndpoint!=NULL) && (grgProtSeqInterface[i].pszEndpoint!=NULL)) && 
	      (!_stricmp(grgProtSeqInterface[i].pszEndpoint, pszEndpoint)))
	     )) */
	    && (grgProtSeqInterface[i].dwInterfaces & (1 << iInterface))) 
	    {
	    DPRINT(3, "VerifyProtSeqInList Exited Successfully\n");
	    return i;
	} 
    }
    
    DPRINT(3, "VerifyProtSeqInList Exited Not Found\n");
    Assert(!"VerifyProtSeq failed - Investigate - dsrepl, gregjohn\n");
    return PROTSEQ_NOT_FOUND;
}

DWORD
VerifyRpcCallUsedValidProtSeq(
    VOID            *Context,
    ULONG iInterface
    )
/*++

  Description:
    Verifies that the RPC call using Context as it's binding and from interface
    iInterface is valid (ie we registered it at startup). 
	
  Arguments:
    Context - rpc binding context
    iInterface (DRSUAPI_INTERFACE, DSOAP_INTERFACE, NSPI_INTERFACE)

  Return Value:
    ERROR_SUCCESS if it's a valid prot seq for this interface.  Else something else.    
 
--*/
{
    DWORD ret = ERROR_SUCCESS;
    LPBYTE pBinding = NULL;
    UCHAR * pszProtSeq = NULL;
    UCHAR * pszEndpoint = NULL;
    INT i = 0;

    VALIDATE_INTERFACE_NUM(iInterface);

    ret = RpcBindingToStringBinding(Context, &pBinding);
    if (ret==ERROR_SUCCESS) {
	ret = RpcStringBindingParse(pBinding,
				    NULL,
				    &pszProtSeq,
				    NULL,
				    &pszEndpoint,
				    NULL //NetworkOptions
				    );
    }

    if (ret==ERROR_SUCCESS) {
	i = VerifyProtSeqInList(pszProtSeq, pszEndpoint, iInterface);
	if (i==PROTSEQ_NOT_FOUND) {
	    ret = ERROR_ACCESS_DENIED;
	}

	// future:  could log high level here to detect attacks/dos/etc.
    }

    Assert(ret==ERROR_SUCCESS);

    if (pszProtSeq) {
	RpcStringFree(&pszProtSeq);
    }

    if (pszEndpoint) {
	RpcStringFree(&pszEndpoint);
    }

    if (pBinding) {
	RpcStringFree(&pBinding);
    }

    return ret;

}

DWORD
VerifyRpcCallUsedPrivacy() 
/*++

  Description:
    Verifies that the RPC call on this thread used privacy and integrity. 
	
  Arguments:

  Return Value:
    ERROR_SUCCESS if it did.  Else ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION.    
 
--*/
{
    
    DWORD ret = ERROR_SUCCESS;
    RPC_STATUS rpcStatus = RPC_S_OK;
    RPC_AUTHZ_HANDLE hAuthz;
    ULONG ulAuthLev = 0;

    rpcStatus = RpcBindingInqAuthClient(
	NULL, &hAuthz, NULL,
	&ulAuthLev, NULL, NULL);
    if ( RPC_S_OK != rpcStatus ||
	 ulAuthLev < RPC_C_PROTECT_LEVEL_PKT_PRIVACY ) {

	ret = ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION; 
	Assert(!"VerifyRpcSecurity failed - Investigate - dsrepl,gregjohn\n");
    }

    return ret;
}

DWORD
VerifyServerIsReady()
/*++

  Description:
    Verifies that we are ready to answer RPC calls. 
	
  Arguments:

  Return Value:
    ERROR_SUCCESS if ready, RPC_C_SERVER_UNAVAILABLE otherwise.    
 
--*/
{

    DWORD ret = ERROR_SUCCESS;

    if (DsaIsInstalling()) {  
	ret = RPC_S_SERVER_UNAVAILABLE; 
    }

    return ret;
}

RPC_STATUS RPC_ENTRY
DraIfCallbackFn(
    RPC_IF_HANDLE   InterfaceUuid,
    void            *Context
    )
/*++
    This function is called by RPC before any drsuapi interface call is
    dispatched to a server routine.  This function performs generic
    security measures common to all drsuapi functions.  Currently it does:
 
    PROT SEQ VERIFICATION
	1.  RPC is a per process application, not per interface.  If we listen
	on prot seq X, and another interface listens on Y(ie a call to
	RpcServerUseProtseqEx with prot seq Y), then BOTH interfaces will
	be listening on both prot seq X and Y!  (Wait, you say, this sure sounds
	like an RPC bug, and not a DS bug - you're preaching to the choir on
	that one, I agree.)  In order to get around this, we need to 
	inquire from RPC what prot seq was used to connect, and see if it
	matches the prot seqs we actually wanted to listen on in the first
	place.    
	
    CLIENT AUTHENTICATION 
	2.  Clients use GSS_NEGOTIATE when binding to the DRA interface as
	prescribed by the security folks.  For various reasons, the negotiated
	protocol may be NTLM as opposed to Kerberos.  If the client security
	context was local system and NTLM is negotiated, then the client comes
	in as the null session which has few rights in the DS.  This causes 
	clients like the KCC, print spooler, etc. to get an incomplete view of 
	the world with correspondingly negative effects.  
    
	This routine insures that unauthenticated users will be rejected. These
	are the correct semantics from the client perspective as well.  
	I.e.  Either the client comes in with useful credentials that let him 
	see what he should, or he is rejected totally and should retry the bind.
	
    CLIENT CONNECTION VALIDATION
	3.  Validate that the Client used privacy and integrity on their calls. 
--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = VerifyServerIsReady();
    if (dwErr==ERROR_SUCCESS) {
	dwErr = VerifyRpcClientIsAuthenticatedUser(Context, InterfaceUuid);   
    }
    if (dwErr==ERROR_SUCCESS) {
	dwErr = VerifyRpcCallUsedValidProtSeq(Context, DRSUAPI_INTERFACE);
    }
    if (dwErr==ERROR_SUCCESS) {
	dwErr = VerifyRpcCallUsedPrivacy();
    }

    return(dwErr);
}

RPC_STATUS RPC_ENTRY
DsaopIfCallbackFn(
    RPC_IF_HANDLE   InterfaceUuid,
    void            *Context
    )
/*++
    This function is called by RPC before any dsaop interface call is
    dispatched to a server routine.  This function performs generic
    security measures common to all dsaop functions.  See comment on
    DrsuapiIfCallbackFn for description of the overall model.
    
--*/
{

    DWORD dwErr = ERROR_SUCCESS;

    // dmritrig and arunn direct that this interface cannot use
    // authentication due to constraints from the domain rename process.
	
    dwErr = VerifyServerIsReady();
    if (dwErr==ERROR_SUCCESS) {
        dwErr = VerifyRpcCallUsedValidProtSeq(Context, DSOAP_INTERFACE);
    }
   
    return(dwErr);
}

RPC_STATUS RPC_ENTRY
NspiIfCallbackFn(
    RPC_IF_HANDLE   InterfaceUuid,
    void            *Context
    )
/*++
    This function is called by RPC before any nspi interface call is
    dispatched to a server routine.  This function performs generic
    security measures common to all nspi functions.  See comment on
    DrsuapiIfCallbackFn for description of the overall model.
    
    Note that this interface doesn't require privacy, or authentication.  Nice.
    
--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = VerifyServerIsReady();
    if (dwErr==ERROR_SUCCESS) {
	dwErr = VerifyRpcCallUsedValidProtSeq(Context, NSPI_INTERFACE);
    }
    return(dwErr);

}

VOID InitRPCInterface( RPC_IF_HANDLE hServerIf )
{
    RPC_STATUS status;
    int i;

    if ( hServerIf == drsuapi_ServerIfHandle ) {

	status = RpcServerRegisterIfEx(hServerIf,
                                       NULL,
                                       NULL,
                                       0,
                                       ulMaxCalls,
                                       DraIfCallbackFn);

    } else if ( hServerIf == dsaop_ServerIfHandle ) {

	status = RpcServerRegisterIfEx(hServerIf,
                                       NULL,
                                       NULL,
                                       RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
                                       ulMaxCalls,
                                       DsaopIfCallbackFn);

    } else if ( hServerIf == nspi_ServerIfHandle ) {

	status = RpcServerRegisterIf2(hServerIf,
                                      NULL,
                                      NULL,
                                      RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
                                      ulMaxCalls,
                                      cbMaxIncomingRPCMessage,
                                      NspiIfCallbackFn); 

    } else {
	Assert(!"Unknown interface attempting to register!\n");
	return;
    } 
    
    if ( status && (status != RPC_S_TYPE_ALREADY_REGISTERED)) {
        DPRINT1( 0, "RpcServerRegisterIf = %d\n", status);
        LogAndAlertUnhandledError(status);

        if ( gfRunningInsideLsa )
        {
            // Don't exit process as this will kill the entire system!
            // Keep running w/o RPC interfaces.  LDAP can still function
            // and if this is a standalone server (i.e. no replicas)
            // that may be good enough.

            return;
        }
        else
        {
            // Original service based behavior.

            exit(1);
        }
    }
    DPRINT( 2, "InitRPCInterface(): Server interface registered.\n" );
    
    
    // If the handle is already in the array, don't add it into the array again
    // This checking is necessary because nspi can be opened/closed multiple times
    // without being reboot.

    for ( i = 0; 
          i<gNumRpcNsExportedInterfaces && gRpcNsExportedInterface[i]!=hServerIf;
          i ++ );
   
    if( i >= gNumRpcNsExportedInterfaces )
    {

        // export interface to RPC name service
        // we keep track of the interfaces we want to export to the RPC name
        // service because we export them and unexport them every time the
        // server starts and stops listening

        if (gNumRpcNsExportedInterfaces >= MAX_RPC_NS_EXPORTED_INTERFACES)
        {
            DPRINT(0,"Vector of interfaces exported to Rpc NS is too small\n");
            return;
        }
        gRpcNsExportedInterface[ gNumRpcNsExportedInterfaces++ ] = hServerIf;
    }
    // If server is currently listening export the interface. Otherwise,
    // it will be taken care of when the server starts listening

    if (gRpcListening) {
        MSRPC_RegisterEndpoints(hServerIf);
    } 
}


BOOL StartServerListening(void)
{
    RPC_STATUS  status;

    status = RpcServerListen(1,ulMaxCalls, TRUE);
    if (status != RPC_S_OK) {
        DPRINT1( 0, "RpcServerListen = %d\n", status);
    }

   return (status == RPC_S_OK);
}


VOID StartNspiRpc(VOID)
{
    if(gbLoadMapi) {
        InitRPCInterface(nspi_ServerIfHandle);
        DPRINT(0,"nspi interface installed\n");
    }
    else {
        DPRINT(0,"nspi interface not installed\n");
    }
}

VOID StartDraRpc(VOID)
{
    InitRPCInterface(drsuapi_ServerIfHandle);
    DPRINT(0,"dra (and duapi!) interface installed\n");
}

VOID StartOrStopDsaOpRPC(BOOL fStart)
/*++

Routine Description:

    Starts or stops the DsaOp RPC interface based on the fStart flag, and
    whether the interface is already started.
        
Arguments:

    fStart  - If TRUE then attempt to start he inteface, if FALSE attempt
              to shut it down.
    
Return Value:

    N/A    

--*/
{
    static fDsaOpStarted = FALSE;

    if (fStart && !fDsaOpStarted) {
        InitRPCInterface(dsaop_ServerIfHandle);
        fDsaOpStarted = TRUE;
        DPRINT(0, "dsaop interface installed\n");
    } else if (!fStart && fDsaOpStarted) {
        MSRPC_UnregisterEndpoints(dsaop_ServerIfHandle);
        fDsaOpStarted = FALSE;
        DPRINT(0, "dsaop interface uninstalled\n");
    }
}

// Start the server listening. Ok to call this even if the server is already
// listening

void
MSRPC_Install(BOOL fRunningInsideLsa)
{
    int i;
    
    if (gRpcListening)
        return;

    // start listening if not running as DLL
    if (!fRunningInsideLsa)
      gRpcListening = StartServerListening();

    // export all registered interfaces to RPC name service

    for (i=0; i < gNumRpcNsExportedInterfaces; i++)
        MSRPC_RegisterEndpoints( gRpcNsExportedInterface[i] );
    
    if (fRunningInsideLsa) {
        gRpcListening = TRUE;
    }
    
}

VOID
MSRPC_Uninstall(BOOL fStopListening)
{
    RPC_STATUS status;
    int i;

    if ( fStopListening )
    {
        //
        // N.B.  This is the usual case.  The ds is responsible for
        // shutting down the rpc listening for the entire lsass.exe
        // process.  We do this because we are the ones that need to kill
        // clients and then safely secure the database.
        //
        // The only case where we don't do this is during the two phase
        // shutdown of demote, where we want to kill external clients
        // but not stop the lsa from listening
        //
        status = RpcMgmtStopServerListening(0) ;
        if (status) {
            DPRINT1( 1, "RpcMgmtStopServerListening returns: %d\n", status);
        }
        else {
            gRpcListening = 0;
        }
    }

    // unexport the registered interfaces

    for (i=0; i < gNumRpcNsExportedInterfaces; i++)
        MSRPC_UnregisterEndpoints( gRpcNsExportedInterface[i] );

}

void MSRPC_WaitForCompletion()
{
    RPC_STATUS status;

    if (status = RpcMgmtWaitServerListen()) {
        DPRINT1(0,"RpcMgmtWaitServerListen: %d", status);
    }
}

void
MSRPC_RegisterEndpoints(RPC_IF_HANDLE hServerIf)
{

    RPC_STATUS status;
    RPC_BINDING_VECTOR * RpcBindingVector;
    char *szAnnotation;
    
    if(hServerIf == nspi_ServerIfHandle && !gbLoadMapi) {
        return;
    }

    if (status = RpcServerInqBindings(&RpcBindingVector))
    {
        DPRINT1(1,"Error in RpcServerInqBindings: %d", status);
        LogUnhandledErrorAnonymous( status );
        return;
    }

    // set up annotation strings for ability to trace client endpoints to
    // interfaces

    if (hServerIf == nspi_ServerIfHandle)
        szAnnotation = NSP_INTERFACE_ANNOTATION;
    else if (hServerIf ==  drsuapi_ServerIfHandle)
        szAnnotation = DRS_INTERFACE_ANNOTATION;
    else
        szAnnotation = "";

    // register endpoints with the endpoint mapper

    if (status = RpcEpRegister(hServerIf, RpcBindingVector, 0, szAnnotation))
    {
        DPRINT1(0,"Error in RpcEpRegister: %d\nWarning: Not all protocol "
                "sequences will work\n", status);
        LogUnhandledErrorAnonymous( status );
    }

    RpcBindingVectorFree( &RpcBindingVector );
}

void
MSRPC_UnregisterEndpoints(RPC_IF_HANDLE hServerIf)
{

    RPC_STATUS status;
    RPC_BINDING_VECTOR * RpcBindingVector;

    if(hServerIf == nspi_ServerIfHandle && !gbLoadMapi) {
        // We never loaded this
        return;
    }

    if (status = RpcServerInqBindings(&RpcBindingVector))
    {
        DPRINT1(1,"Error in RpcServerInqBindings: %d", status);
        LogUnhandledErrorAnonymous( status );
        return;
    }

    // unexport endpoints

    if ((status = RpcEpUnregister(hServerIf, RpcBindingVector, 0))
        && (!gfRunningInsideLsa)) {
            // Endpoints mysteriously unregister themselves at shutdown time,
            // so we shouldn't complain if our endpoint is already gone.  If
            // we're not inside LSA, though, all of our endpoints should
            // still be here (because RPCSS is still running), and should
            // unregister cleanly.
        DPRINT1(1,"Error in RpcEpUnregister: %d", status);
        LogUnhandledErrorAnonymous( status );
    }

    RpcBindingVectorFree( &RpcBindingVector );
}

BOOL
IsProtSeqAvail(
    RPC_PROTSEQ_VECTOR * pProtSeqVector,
    UCHAR * pszProtSeq
    )
/*++

  Description:
    Checks to see if a given ProtSeq was available on this machine at startup.
	
  Arguments:
    pProtSeqVector - all ProtSeq's available as given to us by RPC.
    pszProtSeq - ProtSeq to search for.

  Return Value:
    TRUE if avail, FALSE otherwise.
 
--*/
{
    ULONG i;
    if (pProtSeqVector) {
        for (i=0; i<pProtSeqVector->Count; i++) {
            if (!_stricmp(pProtSeqVector->Protseq[i], pszProtSeq)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

BOOL
AddProtSeq(
    UCHAR * pszProtSeq,
    UCHAR * pszEndpoint,
    DWORD dwInterface,
    BOOL fAvailable,
    BOOL fRegistered
    )
/*++

  Description:
    Add a ProtSeq and endpoint which we will later register to the global list.  These are
    process wide, so if two interfaces overlap, we don't register twice, so we don't put two in
    this list, we just update the dwInterface mask to reflect the new interface also.
	
  Arguments:
    pszProtSeq - ProtSeq to add.
    pszEndpoint - Endpoint
    dwInterface - bit mask identifying what interfaces want to register this prot seq, endpoint
	with us
    fAvailable - debugging and logging purposes only, reflects whether this protocol was available
	at startup.
    fRegisterd - currently always FALSE, but included for completeness

  Return Value:
    TRUE if we actually added something, as opposed to matching an existing one.  (Basically since
    we aren't copying pszProtSeq and pszEndpoint, the caller knows they can't free them if we return
    TRUE).  FALSE otherwise.
 
--*/
{
    INT iProtSeq;
    BOOL fRet = FALSE;
    
    DPRINT(3,"AddProtSeq() entered\n");

    iProtSeq = GetProtSeqInList(pszProtSeq, pszEndpoint);
    if (iProtSeq==PROTSEQ_NOT_FOUND) {
	if (gcProtSeqInterface+1==DEFAULT_PROTSEQ_NUM) {
	    // perhaps this could grow...
	    Assert(!"Too many protocol sequences - contact GregJohn,DsRepl");
	    // log something here.
	    return FALSE;
	}
	grgProtSeqInterface[gcProtSeqInterface].fAvailable = fAvailable;
	grgProtSeqInterface[gcProtSeqInterface].dwInterfaces = dwInterface;
	grgProtSeqInterface[gcProtSeqInterface].pszProtSeq = pszProtSeq;
	grgProtSeqInterface[gcProtSeqInterface].fRegistered = fRegistered;
	grgProtSeqInterface[gcProtSeqInterface].pszEndpoint = pszEndpoint;
	gcProtSeqInterface++;
	fRet = TRUE;
    } else {
	grgProtSeqInterface[iProtSeq].dwInterfaces |= dwInterface;
	Assert(grgProtSeqInterface[iProtSeq].fAvailable == fAvailable);
	fRet = FALSE;
    }

    DPRINT(3,"AddProtSeq() exited\n");
    return fRet;
}

VOID
AddDefaultProtSeq(
    ULONG iInterface,
    RPC_PROTSEQ_VECTOR * pProtSeqVector
    ) 
/*++

  Description:
    Add the default ProtSeq's for iInterface to the global list.
	
  Arguments:
    iInterface - interface
    pProtSeqVector - list of available protseqs, so we can validate the defaults to see
	if they are actually available. 

  Return Value:
    None!
 
--*/
{
    ULONG i;
    DWORD ret = ERROR_SUCCESS;
    BOOL fAvailable = FALSE;

    DEFAULT_PROTSEQ_INFO Defaults = *(rgpDefaultIntProtSeq[iInterface]); 

    VALIDATE_INTERFACE_NUM(iInterface);

    DPRINT(3,"AddDefaultProtSeq() entered\n");

    for (i=0; i<Defaults.cDefaultProtSeq;i++) {
	fAvailable = IsProtSeqAvail(pProtSeqVector, Defaults.rgDefaultProtSeq[i].pszProtSeq);
	if (!Defaults.rgDefaultProtSeq[i].fRegOnlyIfAvail || fAvailable) {
	    // ignore the return value.  if they're already there, we don't care.  
	    AddProtSeq(Defaults.rgDefaultProtSeq[i].pszProtSeq, Defaults.rgDefaultProtSeq[i].pszEndpoint, 1 << iInterface, fAvailable, FALSE);
	}
    }

    DPRINT(3,"AddDefaultProtSeq() exit\n");
}

DWORD
GetProtSeqi(
    ULONG iProtSeq,
    LPSTR pszProtSeqBlock,
    DWORD dwProtSeqBlock,
    UCHAR ** ppszProtSeq,
    UCHAR ** ppszEndpoint
    )
/*++

  Description:
    Get the i-th protseq from the pszPRotSeqBlock.  This block is a MULTISZ-STRING value from
    the registry.  So you've got a NULL terminated block filled with NULL terminated strings (NULL-NULL at
    the end).  The format of the protseq's is
	protseq:endpoint
	
	or if there isn't an endpoint/use the default endpoint
	
	protseq
	
  Arguments:
    iProtSeq - which protseq string we want in the multi string
    pszProtSeqBlock - 
    dwProtSeqBlock - size of above
    ppszProtSeq - copy from (malloc'ed) pszProtSeqBlock - user must free
    ppszEndpoint - copy from (malloc'ed) pszProtSeqBlock - user must free 

  Return Value:
    ERROR_SUCCESS if we successfully got the i'th protseq and filled in the return values, 
    ERROR_NOT_FOUND if there isn't an i'th, and other things on error.
 
--*/
{

    // get the iProtSeq-th element of the block.
    // allocate and copy into the return values.
    ULONG i = 0;
    LPSTR pszProtSeqBlockEnd = pszProtSeqBlock ? pszProtSeqBlock + dwProtSeqBlock - 1 : NULL; // subtract 1, because it's NULL-NULL at the end
    LPSTR pszTemp = NULL;

    DPRINT1(3, "GetProtSeqi entered with %d\n", iProtSeq);

    for (i=0; (i<iProtSeq) && (pszProtSeqBlock!=pszProtSeqBlockEnd); i++, pszProtSeqBlock+=strlen(pszProtSeqBlock)+1);

    if ((pszProtSeqBlock!=pszProtSeqBlockEnd) && (pszProtSeqBlock!=NULL)) {
	// we have a winner!
	// format is protseq:endpoint or just protseq if they don't have an endpoint.
	pszTemp = strchr(pszProtSeqBlock, ':');
	if (pszTemp) {
	    // we have an endpoint   
	    LPSTR pszEndProtSeq = pszTemp;
	    pszTemp++; // forward past the ':'

	    *ppszProtSeq = malloc((pszEndProtSeq - pszProtSeqBlock + 1)*sizeof(CHAR));
	    if (*ppszProtSeq==NULL) {
		// shoot, no memory
		return ERROR_OUTOFMEMORY;
	    }
	    *ppszEndpoint = malloc((strlen(pszTemp) + 1)*sizeof(CHAR));
	    if (*ppszEndpoint==NULL) {
		// darn.
		free(*ppszProtSeq);
		return ERROR_OUTOFMEMORY;
	    }
	    
	    // okay, copy them in
	    memcpy(*ppszProtSeq, pszProtSeqBlock, (pszEndProtSeq - pszProtSeqBlock)*sizeof(CHAR));
	    (*ppszProtSeq)[pszEndProtSeq - pszProtSeqBlock] = '\0';

	    memcpy(*ppszEndpoint, pszTemp, strlen(pszTemp)*sizeof(CHAR));
	    (*ppszEndpoint)[strlen(pszTemp)] = '\0';
	} else {
	    // just a protseq
	    *ppszProtSeq = malloc((strlen(pszProtSeqBlock) + 1)*sizeof(CHAR));
	    if (*ppszProtSeq==NULL) {
		// shoot, no memory
		return ERROR_OUTOFMEMORY;
	    }
	    strcpy(*ppszProtSeq, pszProtSeqBlock);
	    *ppszEndpoint = NULL;
	}
	DPRINT1(3, "GetProtSeqi exited with %s\n", *ppszProtSeq);
	return ERROR_SUCCESS;
    } else {
	DPRINT(3, "GetProtSeqi exited not found\n");
	return ERROR_NOT_FOUND;
    }
}

VOID
AddUserDefinedProtSeq(
    ULONG iInterface,
    RPC_PROTSEQ_VECTOR * pProtSeqVector
    )
/*++

  Description:
    All ProtSeq's defined by the user in the registry to the global list.
	
  Arguments:
    iInterface - interface to get user input from
    pProtSeqVector - list of available protseqs so that we can see if user inputed sequences
	are available.

  Return Value:
    NONE!
 
--*/
{
    DWORD ret = ERROR_SUCCESS;
    ULONG i = 0;
    BOOL fAvailable = FALSE;
    UCHAR * pszProtSeq = NULL;
    UCHAR * pszEndpoint = NULL;
    DWORD dwSize = 0;
    LPSTR pszProtSeqBlock = NULL;
    // look up in the registry.  different key for each interface

    DPRINT(3, "AddUserDefinedProtSeq entered\n");

    VALIDATE_INTERFACE_NUM(iInterface);

    ret = GetConfigParamAlloc(rgInterfaceProtSeqRegLoc[iInterface], &pszProtSeqBlock, &dwSize);
    if (ret!=ERROR_SUCCESS) {
	DPRINT1(3, "No user defined protseq's, or we cannot read user defined protseq's (%d)\n", ret);
	return;
    }

    ret = GetProtSeqi(i, pszProtSeqBlock, dwSize, &pszProtSeq, &pszEndpoint);
    while (ret==ERROR_SUCCESS) {
	Assert(pszProtSeq);
	fAvailable = IsProtSeqAvail(pProtSeqVector, pszProtSeq);

	// we assume that any regkey entry we want to attempt to add/register, even if it's not
	// available.
	if (!AddProtSeq(pszProtSeq, pszEndpoint, 1 << iInterface, fAvailable, FALSE)) {
	    // we didn't use these, free them.
	    if (pszProtSeq) {
		free(pszProtSeq);
		pszProtSeq = NULL;
	    }
	    if (pszEndpoint) {
		free(pszEndpoint);
		pszEndpoint = NULL;
	    }
	}

	ret = GetProtSeqi(++i, pszProtSeqBlock, dwSize, &pszProtSeq, &pszEndpoint);
    }

    if (pszProtSeqBlock) {
	free(pszProtSeqBlock);
    }

    DPRINT(3, "AddUserDefinedProtSeq exited\n");

}

VOID
InitInterfaceProtSeqList() 
/*++

  Description:
    Create the global list of ProtSeq's to register
	
  Arguments:
    NONE!

  Return Value:
    NONE!
 
--*/
{
    DWORD ret = ERROR_SUCCESS;
    RPC_PROTSEQ_VECTOR * pProtSeqVector = NULL;
    DWORD cDefaultProtSeqNum = 0;
    ULONG i = 0;

    DPRINT(3,"InitInterfaceProtSeqList() entered\n");

    // init in-memory list
    memset(grgProtSeqInterface, 0, sizeof(grgProtSeqInterface));
    
    // find out what prot seq's are available.

    if ((ret = RpcNetworkInqProtseqs(&pProtSeqVector)) != RPC_S_OK) {
	DPRINT1(0,"RpcNetworkInqProtseqs returned %d\n", ret);
	//
	// This appears to be normal during the GUI mode portion of upgrade,
	// so don't log anything in that case.  If it's not setup, complain.
	//
	if (!IsSetupRunning()) {
	    LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_NO_RPC_PROTSEQS,
		     szInsertUL(ret),
		     szInsertWin32Msg(ret),
		     NULL);
	}

	// continue - we'll try and register some anyway.
	pProtSeqVector = NULL;
	ret = ERROR_SUCCESS;
    } 

    // for each interface, add default and user defined prot seqs
    for (i=0; i<MAX_RPC_NS_EXPORTED_INTERFACES; i++) {
	AddDefaultProtSeq(i, pProtSeqVector);
	AddUserDefinedProtSeq(i, pProtSeqVector); 
    }

    if (pProtSeqVector) {
	RpcProtseqVectorFree(&pProtSeqVector);
    }

    DPRINT(3,"InitInterfaceProtSeqList() exit\n");
}

ULONG
GetRegConfigTcpProtSeqPort() 
/*++

  Description:
    There is a special key to control the TCP port.  This get's it.
	
  Arguments:
    NONE!

  Return Value:
    0 if no port, some value otherwise.  (we can get away with using 0 because that's not
    a valid TCP port)
 
--*/
{
    ULONG ulPort = 0;

    if (GetConfigParam(TCPIP_PORT, &ulPort, sizeof(ulPort))) {
	ulPort = 0;
	DPRINT1(0,"%s key not found. Using default\n", TCPIP_PORT);
    } else {
	DPRINT2(0,"%s key forcing use of end point %d\n", TCPIP_PORT,
		ulPort);
    }

    return ulPort;
}

DWORD
RegisterGenericProtSeq(
    UCHAR * pszProtSeq,
    UCHAR * pszEndPoint,
    PSECURITY_DESCRIPTOR pSD,
    BOOL fIsAvailable)
/*++

  Description:
    Helper function to register protseqs and log on failure.
	
  Arguments:
    pszProtSeq - ready to register
    pszEndpoint -
    pSD - security descriptors are used by LPC
    fAvailable - used for logging if we can't register

  Return Value:
    RPC_S_OK if it was registered, rpc errors otherwise.
 
--*/
{
    RPC_STATUS rpcStatus = RPC_S_OK;
    RPC_POLICY rpcPolicy;
    
    rpcPolicy.Length = sizeof(RPC_POLICY);
    rpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;
    rpcPolicy.NICFlags = 0;

    DPRINT2(3, "Registering %s (%s)\n", pszProtSeq, pszEndPoint ? pszEndPoint : "default ep");

    if (pszEndPoint) {
	rpcStatus=RpcServerUseProtseqEpEx(pszProtSeq,
					  ulMaxCalls, 
					  pszEndPoint, 
					  pSD, 
					  &rpcPolicy );
    } else {
	rpcStatus=RpcServerUseProtseqEx(pszProtSeq,
					ulMaxCalls, 
					pSD, 
					&rpcPolicy );
    }

    if (rpcStatus != RPC_S_OK) {

	DPRINT2(0,
		"RpcServerUseProtseqEx (%s) returned %d\n",
		pszProtSeq,
		rpcStatus);
	LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
		 DS_EVENT_SEV_ALWAYS,
		 fIsAvailable ? DIRLOG_RPC_PROTSEQ_FAILED : DIRLOG_RPC_PROTSEQ_FAILED_UNAVAILABLE,
		 szInsertSz(pszProtSeq),
		 szInsertUL(rpcStatus),
		 szInsertWin32Msg(rpcStatus)); 

    }

    return rpcStatus;
}



VOID
RegisterInterfaceProtSeqList()
/*++

  Description:
    Register all protseqs on the global list.
	
  Arguments:
    NONE!
    
  Return Value:
    NONE!
 
--*/
{
    DWORD ret = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG i = 0;
    RPC_STATUS rpcStatus = RPC_S_OK;
    ULONG ulPort = 0;

    for (i=0; i<gcProtSeqInterface; i++) {
	// some protocols register differently
	if (!_stricmp(grgProtSeqInterface[i].pszProtSeq, TCP_PROTSEQ)) { 
	    // if we have a configured endpoint, use it, otherwise check regkey for default
	    if (grgProtSeqInterface[i].pszEndpoint==NULL) { 
		ulPort = GetRegConfigTcpProtSeqPort();
		if (ulPort!=0) {
		    grgProtSeqInterface[i].pszEndpoint = malloc(16*sizeof(UCHAR));
		    if (grgProtSeqInterface[i].pszEndpoint) {
			_ultoa(ulPort, grgProtSeqInterface[i].pszEndpoint, 10);
		    } else {
			// no mem!
			LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
				 DS_EVENT_SEV_ALWAYS,
				 DIRLOG_TCP_DEFAULT_PROTSEQ_USED,
				 NULL,
				 NULL,
				 NULL);
		    }
		}   
	    }
	} else if (!_stricmp(grgProtSeqInterface[i].pszProtSeq, LPC_PROTSEQ)) {
	    // LPC requires a security descriptor

	    //
	    // construct the default security descriptor allowing access to all
	    // this is used to allow authenticated connections over LPC.
	    // By default LPC allows access only to the same account
	    //
	    // default security descriptor to protect the RPC port with
	    // Everyone gets PORT_CONNECT (0x00000001)
	    // LocalSystem gets PORT_ALL_ACCESS (0x000F0001)
	    if (!ConvertStringSecurityDescriptorToSecurityDescriptor( 
		"O:SYG:SYD:(A;;0x00000001;;;WD)(A;;0x000F0001;;;SY)",
		SDDL_REVISION_1,
		&pSD,
		NULL)) 
		{
		ret = GetLastError();
		DPRINT1(0, "Error %d constructing a security descriptor\n", ret);
		LogUnhandledError(ret);
	    }

	} 

	ret = RegisterGenericProtSeq(grgProtSeqInterface[i].pszProtSeq, 
				     grgProtSeqInterface[i].pszEndpoint, 
				     pSD,
				     grgProtSeqInterface[i].fAvailable);
	grgProtSeqInterface[i].fRegistered = !ret;
	if (pSD) {
		LocalFree(pSD);
		pSD = NULL;
	}
    }

}

void
RegisterProtSeq()
/*++

  Description:
    Register protseq's.
	
  Arguments:
    NONE!
    
  Return Value:
    NONE!
 
--*/
{
    DWORD ret = ERROR_SUCCESS;

    DPRINT(3,"RegisterProtSeq() entered\n");

    InitInterfaceProtSeqList();

    RegisterInterfaceProtSeqList();

    DPRINT(3,"RegisterProtSeq() exit\n");
    
}

int
DsaRpcMgmtAuthFn(
    RPC_BINDING_HANDLE ClientBinding,
    ULONG RequestedMgmtOperation,
    RPC_STATUS *Status) 
/*++

  Description:
    Function given to RPC to authorize management functions.
	
  Arguments:
    
  Return Value:
    FALSE!
 
--*/
{
    // nobody needs to use these.  deny!
    *Status = RPC_S_ACCESS_DENIED;
    return FALSE;
}

void
MSRPC_Init()
{

    char *szPrincipalName;
    
    PSECURITY_DESCRIPTOR pSDToUse = NULL;
    char *szEndpoint;
    RPC_STATUS  status = 0;
    unsigned ulPort;
    char achPort[16];
   
    unsigned i;
    
    // 
    // Register prot seq
    //
    RegisterProtSeq();

    /*
    RpcMgmtSetAuthorizationFn(
	DsaRpcMgmtAuthFn);
	
    We can't set auth to the rpc management functions because it's a per process
    setting, and some clients of lsass can't handle it.  For example, IPSEC 
    doesn't use mutual auth with SPN's and must use RpcMgmtInqServerPrincName in
    order to get an SPN.
    
    A valid question would be why it's per process - but that's a valid question 
    against a lot of RPC code (mgmt funcs, prot seqs, associations, security 
    contexts, etc).  If RPC ever fixes that, we can re-enable this code, or if
    we're alone in this process we can re-enable (ADAM?).
    
    */



    /*
     * register the authentication services (NTLM and Kerberos)
     */

    if ((status=RpcServerRegisterAuthInfo(SERVER_PRINCIPAL_NAME,
        RPC_C_AUTHN_WINNT, NULL, NULL)) != RPC_S_OK) {
        DPRINT1(0,"RpcServerRegisterAuthInfo for NTLM returned %d\n", status);
        LogUnhandledErrorAnonymous( status );
     }

    // Kerberos requires principal name as well.

    status = RpcServerInqDefaultPrincNameA(RPC_C_AUTHN_GSS_KERBEROS,
                                           &szPrincipalName);

    if ( RPC_S_OK != status )
    {
        LogUnhandledErrorAnonymous( status );
        DPRINT1(0,
                "RpcServerInqDefaultPrincNameA returned %d\n",
                status);
    }
    else
    {
        Assert( 0 != strlen(szPrincipalName) );

        // save the PrincipalName, since the LDAP head needs it constantly
        gulLDAPServiceName = strlen(szPrincipalName);
        gszLDAPServiceName = malloc(gulLDAPServiceName);
        if (NULL == gszLDAPServiceName) {
            LogUnhandledErrorAnonymous( ERROR_OUTOFMEMORY );
            DPRINT(0, "malloc returned NULL\n");
            return;
        }
        memcpy(gszLDAPServiceName, szPrincipalName, gulLDAPServiceName);

        // Register negotiation package so we will also accept clients
        // which provided NT4/NTLM credentials to DsBindWithCred, for
        // example.

        status = RpcServerRegisterAuthInfo(szPrincipalName,
                                           RPC_C_AUTHN_GSS_NEGOTIATE,
                                           NULL,
                                           NULL);

        if ( RPC_S_OK != status )
        {
            LogUnhandledErrorAnonymous( status );
            DPRINT1(0,
                    "RpcServerRegisterAuthInfo for Negotiate returned %d\n",
                    status);
        }

        status = RpcServerRegisterAuthInfo(szPrincipalName,
                                           RPC_C_AUTHN_GSS_KERBEROS,
                                           NULL,
                                           NULL);

        if ( RPC_S_OK != status )
        {
            LogUnhandledErrorAnonymous( status );
            DPRINT1(0,
                    "RpcServerRegisterAuthInfo for Kerberos returned %d\n",
                    status);
        }

        RpcStringFree(&szPrincipalName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\mdupdate.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       mdupdate.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <lmaccess.h>                   // UF_* definitions

#include <dsjet.h>

// Core DSA headers.
#include <attids.h>
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <drs.h>                        // DRS_MSG_*
#include <gcverify.h>                   // THSTATE.GCVerifyCache
#include <winsock.h>                    // htonl, ntohl
#include <windns.h>
#include <quota.h>
#include <sddl.h>
#include <sddlp.h>                      // needed for special SD conversion: ConvertStringSDToSDDomainW()

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected atts
#include "anchor.h"
#include <permit.h>                     // permission constants
#include "dstaskq.h"
#include "filtypes.h"                   // definitions for FILTER_CHOICE_*
#include "mappings.h"
#include "debug.h"                      // standard debugging header
#include "prefix.h"
#include "hiertab.h"
#include "mdglobal.h"                   // DBIsSecretData
#include "dsexcept.h"

#include "drameta.h"

#include "nlwrap.h"                     // for dsI_NetNotifyDsChange()

#include <lmcons.h>                     // DNLEN

#define DEBSUB "MDUPDATE:"              // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_MDUPDATE

/* extern from mdinidsa.h. Should not be used anywhere else */
extern int WriteSchemaVersionToReg(DBPOS *pDB);

//
// Boolean to indicate if DS is running as mkdit.exe (constructing the
// boot dit (aka ship dit, initial dit) winnt\system32\ntds.dit.
//
// mkdit.exe manages the schema cache on its own. This boolean is used
// to disable schema cache updates by the mainline code.
//
extern BOOL gfRunningAsMkdit;


/* MACROS */
/* Internal functions */

BOOL gbDoListObject = FALSE;
BOOL gbSpecifyGuidOnAddAllowed = FALSE;
BOOL gfDontStandardizeSDs = FALSE;

DWORD gulUnlockSystemSubtree=0;


#if defined(DBG)
DWORD GlobalKnowledgeCommitDelay = GLOBAL_KNOWLEDGE_COMMIT_DELAY_MIN;
DWORD gdwLastGlobalKnowledgeOperationTime; // from debug.h
#endif

typedef struct _INTERIM_FILTER_SEC {
    ATTCACHE *pAC;
    BOOL **pBackPointer;
} INTERIM_FILTER_SEC;

// Get temp DBPOS from hVerifyAtts cache if it's there already, or allocate
// one and cache it if not.
#define HVERIFYATTS_GET_PDBTMP(hVerifyAtts) \
    ((NULL != (hVerifyAtts)->pDBTmp_DontAccessDirectly) \
        ? (hVerifyAtts)->pDBTmp_DontAccessDirectly \
        : (DBOpen2(FALSE, &(hVerifyAtts)->pDBTmp_DontAccessDirectly), \
            (hVerifyAtts)->pDBTmp_DontAccessDirectly))

DWORD
IsAccessGrantedByObjectTypeList (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE* pCC,
        ACCESS_MASK ulAccessMask,
        POBJECT_TYPE_LIST pObjList,
        DWORD cObjList,
        DWORD *pResults,
        DWORD flags,
        PWCHAR szAdditionalInfo,
        GUID*  pAdditionalGUID
        );

int
VerifyDsnameAtts (
        THSTATE *pTHS,
        HVERIFY_ATTS hVerifyAtts,
        ATTCACHE *pAC,
        ATTRVALBLOCK *pAttrVal);

void
HandleDNRefUpdateCaching (
        THSTATE *pTHS
        );

BOOL
fLastCrRef (
        THSTATE * pTHS,
        DSNAME *pDN
        );


BOOL IsMember(ATTRTYP aType, int arrayCount, ATTRTYP *pAttArray);
BOOL IsAuxMember (CLASSSTATEINFO  *pClassInfo, ATTRTYP aType, BOOL fcheckMust, BOOL fcheckMay );

#define LOCAL_DSNAME    0
#define NONLOCAL_DSNAME 1

VOID ImproveDSNameAtt(DBPOS *pDBTemp,
                      DWORD LocalOrNot,
                      DSNAME *pDN,
                      BOOL *pfNonLocalNameVerified);

int
CheckModifyPrivateObject(THSTATE *pTHS,
                   PSECURITY_DESCRIPTOR pSD,
                   RESOBJ * pResObj);


// Control access rights that the DS understands.
const GUID RIGHT_DS_CHANGE_INFRASTRUCTURE_MASTER =
            {0xcc17b1fb,0x33d9,0x11d2,0x97,0xd4,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_CHANGE_SCHEMA_MASTER =
            {0xe12b56b6,0x0a95,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_CHANGE_RID_MASTER    =
            {0xd58d5f36,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_DO_GARBAGE_COLLECTION =
            {0xfec364e0,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_RECALCULATE_HIERARCHY =
            {0x0bc1554e,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_ALLOCATE_RIDS         =
            {0x1abd7cf8,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_OPEN_ADDRESS_BOOK     =
            {0xa1990816,0x4298,0x11d1,0xad,0xe2,0x00,0xc0,0x4f,0xd8,0xd5,0xcd};
const GUID RIGHT_DS_CHANGE_PDC            =
            {0xbae50096,0x4752,0x11d1,0x90,0x52,0x00,0xc0,0x4f,0xc2,0xd4,0xcf};
const GUID RIGHT_DS_ADD_GUID              =
            {0x440820ad,0x65b4,0x11d1,0xa3,0xda,0x00,0x00,0xf8,0x75,0xae,0x0d};
const GUID RIGHT_DS_CHANGE_DOMAIN_MASTER =
            {0x014bf69c,0x7b3b,0x11d1,0x85,0xf6,0x08,0x00,0x2b,0xe7,0x4f,0xab};
const GUID RIGHT_DS_REPL_GET_CHANGES =
            {0x1131f6aa,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_GET_CHANGES_ALL =
            {0x1131f6ad,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_SYNC =
            {0x1131f6ab,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_MANAGE_TOPOLOGY =
            {0x1131f6ac,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_MONITOR_TOPOLOGY =
            {0xf98340fb,0x7c5b,0x4cdb,0xa0,0x0b,0x2e,0xbd,0xfa,0x11,0x5a,0x96};
const GUID RIGHT_DS_REPL_MANAGE_REPLICAS =
            {0x9923a32a,0x3607,0x11d2,0xb9,0xbe,0x00,0x00,0xf8,0x7a,0x36,0xb2};
const GUID RIGHT_DS_RECALCULATE_SECURITY_INHERITANCE =
            {0x62dd28a8,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05};
const GUID RIGHT_DS_CHECK_STALE_PHANTOMS =
            {0x69ae6200,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05};
const GUID RIGHT_DS_UPDATE_SCHEMA_CACHE =
            {0xbe2bb760,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05};
const GUID RIGHT_DS_REFRESH_GROUP_CACHE =
            {0x9432c620,0x033c,0x4db7,0x8b,0x58,0x14,0xef,0x6d,0x0b,0xf4,0x77};
const GUID RIGHT_DS_MIGRATE_SID_HISTORY =
            {0xBA33815A,0x4F93,0x4c76,0x87,0xF3,0x57,0x57,0x4B,0xFF,0x81,0x09};
const GUID RIGHT_DS_REANIMATE_TOMBSTONES =
            {0x45ec5156,0xdb7e,0x47bb,0xb5,0x3f,0xdb,0xeb,0x2d,0x03,0xc4,0x0f};
const GUID RIGHT_DS_EXECUTE_SCRIPT =
            {0x2f16c4a5,0xb98e,0x432c,0x95,0x2a,0xcb,0x38,0x8b,0xa3,0x3f,0x2e};
const GUID RIGHT_DS_QUERY_SELF_QUOTA =
            {0x4ecc03fe,0xffc0,0x4947,0xb6,0x30,0xeb,0x67,0x2a,0x8a,0x9d,0xbc};

// Fake PropSet guid to use for properties that don't have a propset. It only
// affects the way audits are generated, there will be no matching ACEs in SD.
// Used in CheckSecurityAttCacheArray
const GUID PROPSET_GUID_DEFAULT =
            {0x771727b1,0x31b8,0x4cdf,0xae,0x62,0x4f,0xe3,0x9f,0xad,0xf8,0x9e};

// Guid to decern whether or not the enterprise was created using a whistler
// code base or a win2k.
const GUID GUID_WHISTLER_CREATED_ENTERPRISE =
            {0x94fdebc6,0x8eeb,0x4640,0x80,0xde,0xec,0x52,0xb9,0xca,0x17,0xfa};

// Fake rights guid to audit DumpDatabase operations
// {65ED5CB2-42FF-40a5-9AFC-B67E1539AA3C}
const GUID RIGHT_DS_DUMP_DATABASE =
            {0x65ed5cb2,0x42ff,0x40a5,0x9a,0xfc,0xb6,0x7e,0x15,0x39,0xaa,0x3c};

/*-------------------------------------------------------------------------*/
/* If an instance type and value was not provided, we assume the object is
   an internal master INT_MASTER.  We also validate the instance type.
*/

int SetInstanceType(THSTATE *pTHS,
                    DSNAME *pDN,
                    CREATENCINFO * pCreateNC)
{
    SYNTAX_INTEGER iType;
    DB_ERR dbErr = 0;
    DWORD errCode = 0;

    DPRINT(2, "SetInstanceType entered\n");

    dbErr = DBGetSingleValue(pTHS->pDB,
                             ATT_INSTANCE_TYPE, &iType, sizeof(iType), NULL);
    if (dbErr) {
        // No instance type has yet been set.
        Assert(DB_ERR_NO_VALUE == dbErr);
        Assert(!pTHS->fDRA && "Disable if running ref count test");

        if (pCreateNC) {
            // NC creation.
            if (pCreateNC->fNcAbove){
                // We hold the parent NC above the one being added. ...
                iType = NC_MASTER_SUBREF;
            } else {
                // We don't hold the parent NC above this one ...
                iType = NC_MASTER;
            }

        } else {
            // Normal internal node creation.
            iType = INT_MASTER;
        }

        dbErr = DBAddAttVal(pTHS->pDB, ATT_INSTANCE_TYPE, sizeof(iType), &iType);
        if (dbErr) {
            errCode = SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR,
                                    dbErr);
        }
    } else {
        // Check the instance type is OK.
        if (!ISVALIDINSTANCETYPE(iType)) {
            DPRINT1(2, "Bad InstanceType <%lu>\n", iType);

            errCode = SetAttError(pDN, ATT_INSTANCE_TYPE,
                                  PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                                  DIRERR_BAD_INSTANCE_TYPE);
        }
    }

    return errCode;
}/*SetInstanceType*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

/*
  Called from:
      LocalAdd
      AddPlaceholderNC
      LocalModify->ModCheckCatalog (instance type change)
      LocalModifyDN (parenting/instance type change)
  Rules:
      A subref should not be present if the cross ref for the NC is not present.
      A subref should be present if the instance type contains IT_NC_ABOVE

  AddSubToNC is called directly from AddAutoSubref and ModAutoSubref
 */
int AddCatalogInfo(THSTATE *pTHS,
                   DSNAME *pDN){

    SYNTAX_INTEGER iType;
    DWORD rtn;


    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(CheckCurrency(pDN));

    DPRINT(2,"AddCatalogInfo entered\n");

    /* Update the system catalog if necessary.  The basic rules are that NC
       objects are added to the DSA catalog, Subordinate Refs are only added
       if the parent object exists.  These references are added to the
       catalog of its parent NC.  Internal References are added only
       if the parent object exists on the same DSA.
    */


    /* Position on the attribute instance.  */
    if(rtn = DBGetSingleValue(pTHS->pDB,
                              ATT_INSTANCE_TYPE, &iType, sizeof(iType), NULL)) {
        // No instance type set or instance type is smaller than it should be.
        DPRINT(2,"Couldn't retrieve the att instance dir error\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_RETRIEVE_INSTANCE,
                 szInsertDN(pDN),
                 szInsertUL(rtn),
                 szInsertHex(DSID(FILENO, __LINE__)));

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_CANT_RETRIEVE_INSTANCE, rtn );
    }

    DPRINT1(3,"Object Instance Type is <%lx>\n", iType);

    if(iType & IT_NC_HEAD) {
        // These are Naming Context heads.
        ATTRTYP attrNCList;

        if (iType & IT_NC_ABOVE) {
            // These are subrefs of some flavor.
            if (ParentExists(PARENTMASTER + PARENTFULLREP, pDN)) {
                return pTHS->errCode;
            }

            if (!(iType & IT_NC_GOING)) {
                // Add this NC to the subrefs list on the NC above it.
                if (AddSubToNC(pTHS, pDN, DSID(FILENO,__LINE__))) {
                    return pTHS->errCode;
                }
            }
        }

        if (!(iType & IT_UNINSTANT)) {
            // Add this NC to the appropriate NC list on the ntdsDsa object.
            if (iType & IT_WRITE) {
                attrNCList = ATT_MS_DS_HAS_MASTER_NCS;
            }
            else {
                attrNCList = ATT_HAS_PARTIAL_REPLICA_NCS;
            }

            if (AddNCToDSA(pTHS, attrNCList, pDN, iType)) {
                return pTHS->errCode;
            }

            if (!(iType & (IT_NC_COMING | IT_NC_GOING))) {

                // This NC is now completely instantiated -- it is okay to
                // advertise the presence of this NC to clients.
                //
                // Bug 103583 2000/04/21 JeffParh - Note that currently this
                // will notify netlogon to reload NDNCs more often than it
                // should.  We can't differentiate NDNCs from "normal" NCs here
                // because during the originating creation of the NDNC the flags
                // on the in-memory crossRef haven't yet been updated (because
                // we're still in the middle of the transaction that sets the
                // flags on the cross-ref).
                pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon = TRUE;

                if ( !(iType & IT_WRITE)) {
                    //
                    // We had just completed replication of a RO NC.
                    // It's time to fork a GC promotion task
                    // (mark thread so that we'll fork it on transaction commit)
                    //
                    pTHS->JetCache.dataPtr->objCachingInfo.fSignalGcPromotion = TRUE;
                }
            }
        }
    }
    else {
        // These are not NC heads.
        if(ParentExists((iType & IT_WRITE)?PARENTMASTER:PARENTFULLREP, pDN))
            return pTHS->errCode;
    }

    DPRINT(3,"Good return from AddCatalogInfo\n");
    return 0;

}/*AddCatalogInfo*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
   /* Update the system catalog if necessary.  The basic rules are that NC
      objects are removed from the DSA catalog, Subordinate Refs removed
      from the NC.

      This function can be called when an object is deleted or when an
      object is modified.
   */
/*
  Called from:
      LocalDelete->CheckCatalogd
      LocalModify->ModCheckCatalog (instance type change)
      LocalModifyDN (parenting/instance type change)

  DelSubFromNC is called directly from DelAutoSubRef
 */


int
DelCatalogInfo (
        THSTATE *pTHS,
        DSNAME *pDN,
        SYNTAX_INTEGER iType
        )
{
    CROSS_REF_LIST *pCRL = NULL;

    DPRINT(2,"DelCatalogInfo entered\n");

    DPRINT1(3,"Object Instance Type is <%lx>\n", iType);

    if (iType & IT_NC_HEAD) {
        // These are Naming Context heads.
        ATTRTYP attrNCList;

        if (iType & IT_NC_ABOVE) {
            // These are subrefs of some flavor.
            // Remove this NC from the subrefs list on the NC above it.
            if (DelSubFromNC(pTHS, pDN, DSID(FILENO,__LINE__))) {
                return pTHS->errCode;
            }
        }

        if (!(iType & IT_UNINSTANT)) {
            // Remove this NC from the appropriate NC list on the ntdsDsa object.
            if (iType & IT_WRITE) {
                attrNCList = ATT_MS_DS_HAS_MASTER_NCS;
            }
            else {
                attrNCList = ATT_HAS_PARTIAL_REPLICA_NCS;
            }

            if (DelNCFromDSA(pTHS, attrNCList, pDN)) {
                return pTHS->errCode;
            }
        }

        if (!(iType & (IT_NC_COMING | IT_NC_GOING))) {
            // This NC was completely instantiated but is no longer -- we should
            // stop advertising the presence of this NC to clients.
            // BUGBUG this is basically the parrallel bug to the bug
            // mentioned with the comment "Bug 103583 2000/04/21 JeffParh"
            // in AddCatalogInfo() above.  At this point if we're just
            // removing a replica then we can tell from the cross-ref
            // if we're deleting an NDNC, but if we have removed an NDNC
            // all together from the forest, via deleting it's cross-ref
            // then we won't have a cross-ref to check out.  So this will
            // basically notify netlogon a few extra times when someone
            // un-checks the GC bit for a GC.
            pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon
                 = TRUE;

        }
    }

    DPRINT(3,"Good return from DelCatalogInfo\n");
    return 0;

}/*DelCatalogInfo*/


CSACA_RESULT
CheckSecurityAttCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        CLASSCACHE *pObjectCC,                  
        CLASSCACHE *pCC,                        
        ULONG  cInAtts,
        ATTCACHE **rgpAC,
        DWORD flags,
        PWCHAR szAdditionalInfo,
        GUID*  pAdditionalGUID
        )
/*++
  Arguments:
    pTHS            thread state
    RightRequested  access bit(s) to check
    pSecurity       SD pointer
    pDN             The DN of the object being checked (we need its SID if any)
    pObjectCC       object class of the DN (used for auditing)
    pCC             pCC->Guid is put into the root of the GUID tree for the access check.
                    In most cases, pCC==pObjectCC. However, in some cases (i.e. object creation),
                    it is not the same.
    cInAtts         length of the attribute array (may be zero)
    rgpAC           array of attributes to fill the GUID tree with. The attributes are
                    sorted by into propsets, propset guids go into first level of the tree,
                    and the property guids go into the second level.
    flags           Flags to pass to CheckPermissionsAnyClient, e.g. CHECK_PERMISSIONS_AUDIT_ONLY.
    szAdditionalInfo (optional) additionalInfo string to use in the audit.
    pAdditionalGUID  (optional) additional guid for audits.
                    
  Returns a special enum value indicating that:
  csacaAllAccessGranted - All requested access was granted
  csacaAllAccessDenied  - No access was granted whatsoever
  csacaPartialGrant     - Access was granted to some attributes but not to
                          others.  The caller must look at the ATTCACHE array
                          to see which attributes have been granted (pAC still
                          filled in) and which have been denied (pAC NULLed)
--*/
{
    ULONG i, j, k;
    DWORD cObjList;
    ATTCACHE ***Sorted = NULL, **temp;
    ULONG propSets=0;
    DWORD *pResults;
    GUID *pCurrentPropSet;
    ATTCACHE *pPrevAttribute=NULL;
    POBJECT_TYPE_LIST pObjList;
    BOOL fGranted, fDenied;
    DWORD err;

    if(pTHS->fDRA || pTHS->fDSA ) {
        // These bypass security, they are internal
        return csacaAllAccessGranted;
    }

    if(!pCC) {
        // We are missing some parameters.
        // set up for no access
        memset(rgpAC, 0, cInAtts * sizeof(ATTCACHE *));
        return csacaAllAccessDenied;
    }

    if(cInAtts) {
        // We actually have an ATTCACHE array to deal with.

        // First, group the ATTCACHEs by propset.  Actually, indirect by one to
        // maintain the original sort order, which we must maintain.

        Sorted = (ATTCACHE ***)THAllocEx(pTHS,cInAtts * sizeof(ATTCACHE**));
        for(i=0;i<cInAtts;i++) {
            if(rgpAC[i]) {
                Sorted[i] = &rgpAC[i];
            }
            else {
                Sorted[i] = NULL;
            }
        }

        propSets = 1;
        for(i=0;i<(cInAtts-1);) {
            if(!Sorted[i]) {
                i++;
                continue;
            }

            // First, skip over all the attributes at the front of the list that
            // are already grouped into a propset.
            while((i < (cInAtts - 1)) &&
                  Sorted[i+1]         &&
                  (memcmp(&(*Sorted[i])->propSetGuid,
                          &(*Sorted[i + 1])->propSetGuid,
                          sizeof(GUID)) == 0 )) {
                i++;
            }

            // Now, elements 0 through i in Sorted[] are already grouped by
            // propset, and Sorted[i+i] belongs in another propset than
            // Sorted[i]. Continue looking through Sorted[] for more attributes
            // in the same propset as Sorted[i].

            for(k=i+1,j=i+2; j < cInAtts; j++) {
                if(Sorted[j] &&
                   memcmp(&(*Sorted[i])->propSetGuid,
                          &(*Sorted[j])->propSetGuid,
                          sizeof(GUID)) == 0) {
                    // equal, swap
                    temp = Sorted[k];
                    Sorted[k] = Sorted[j];
                    Sorted[j] = temp;
                    k++;
                    // Now, elements 0 through (k - 1) in Sorted[] are
                    // grouped by propset.  Furthermore, Sorted[i] and
                    // Sorted[k - 1] are in the same propset.
                }
            }

            propSets++;
            i=k;
        }

    }

    // Now, create the list
    pObjList = (POBJECT_TYPE_LIST) THAllocEx( pTHS,
            (cInAtts + propSets + 1) * sizeof(OBJECT_TYPE_LIST));
    pResults = (LPDWORD) THAllocEx(pTHS,(cInAtts + propSets + 1) * sizeof(DWORD));
    pObjList[0].Level = ACCESS_OBJECT_GUID;
    pObjList[0].Sbz = 0;
    pObjList[0].ObjectType = &(pCC->propGuid);

    if(cInAtts) {
        // Ok, put the grouped GUIDS into the objlist structure.
        pCurrentPropSet = NULL;

        for(j=1,i=0;i<cInAtts;i++) {
            if(!Sorted[i]) {
                continue;
            }

            // we are not allowed to pass the same attribute (under the same)
            // propGuid more than once.
            // this will make sure this is not happening, since the
            // attributes are already sorted on propguid+attrGuid
            if (pPrevAttribute == (*Sorted[i])) {
                continue;
            }

            if(!pCurrentPropSet ||
               memcmp(&(*Sorted[i])->propSetGuid,
                      pCurrentPropSet,
                      sizeof(GUID))) {
                // Tripped into a new propset.
                pObjList[j].Level = ACCESS_PROPERTY_SET_GUID;
                pObjList[j].Sbz = 0;
                pCurrentPropSet = &(*Sorted[i])->propSetGuid;
                // Properties that don't belong to any propset use the null GUID as propset guid.
                // Audit folks don't like NULL guids appearing in audits. Thus, we will replace
                // the null propset guid with a fake guid, that is guaranteed not to match any
                // object type guid in an ACE. Audit viewer calls SchemaGuidCrackNames with this
                // guid. This function knows about this guid and will return a hardcoded string
                // for it.
                if (memcmp(pCurrentPropSet, &gNullUuid, sizeof(GUID)) == 0) {
                    pObjList[j].ObjectType = (GUID*)&PROPSET_GUID_DEFAULT;
                }
                else {
                    pObjList[j].ObjectType = &(*Sorted[i])->propSetGuid;
                }

                j++;
            }
            pObjList[j].Level = ACCESS_PROPERTY_GUID;
            pObjList[j].Sbz = 0;
            pObjList[j].ObjectType = &(*Sorted[i])->propGuid;
            pPrevAttribute = *Sorted[i];
            j++;
        }

        cObjList = j;
    }
    else {
        cObjList = 1;
    }

    // Make the security check call.
    if(err = IsAccessGrantedByObjectTypeList(pSecurity,
                                             pDN,
                                             pObjectCC,
                                             RightRequested,
                                             pObjList,
                                             cObjList,
                                             pResults,
                                             flags,
                                             szAdditionalInfo,
                                             pAdditionalGUID
                                             )) {
        // No access to anything.
        memset(rgpAC, 0, cInAtts * sizeof(ATTCACHE *));
        if (Sorted) {
            THFreeEx(pTHS,Sorted);
        }
        THFreeEx(pTHS, pObjList);
        THFreeEx(pTHS, pResults);
        return csacaAllAccessDenied;
    }

    if(!pResults[0]) {
        // We have full access to this object, return
        if (Sorted) {
            THFreeEx(pTHS,Sorted);
        }
        THFreeEx(pTHS, pObjList);
        THFreeEx(pTHS, pResults);
        return csacaAllAccessGranted;
    }

    // Filter the incoming list of attrs so that if they are not readable, we
    // drop them out of the list.

    // So far we haven't granted or denied anything
    fGranted = fDenied = FALSE;

    // Start by setting up j, our index into the Sorted array.
    // The Sorted array is in the same order as the pResults returned,
    // but may have extra embedded NULLs.  Skip any NULLs in the Sorted
    // list
    j=0;
    while((j < cInAtts) && !Sorted[j])  {
        j++;
    }

    for(i=1;i<cObjList;) {
        BOOL fOK=FALSE;

        Assert (pObjList[i].Level == ACCESS_PROPERTY_SET_GUID);
        if(!pResults[i]) {
            // Access to this propset is granted, skip over all the granted
            // props.
            fOK = TRUE;
            fGranted=TRUE;
        }
        i++;
        Assert(pObjList[i].Level == ACCESS_PROPERTY_GUID); // This is a prop.
        while(i < cObjList && (pObjList[i].Level == ACCESS_PROPERTY_GUID)) {
            if(!fOK && pResults[i]) {
                // Access to this prop is not granted.
                fDenied = TRUE;
                Assert(Sorted[j]); // We should have already skipped nulls.
                (*Sorted[j]) = NULL;
            }
            else {
                fGranted=TRUE;
            }
            i++;
            j++;
            // The Sorted array is in the same order as the pResults returned,
            // but may have extra embedded NULLs.  Skip any NULLs in the Sorted
            // list
            while((j < cInAtts) && !Sorted[j]) {
                j++;
            }
            // Assert the we are either done walking through the pResults array
            // or we still have elements in the Sorted array to consider.  That
            // is, we can't have exhausted the SortedArray unless we have also
            // exhausted the pResults array.
            Assert(i == cObjList || (j < cInAtts));
        }
    }
    if (Sorted) {
        THFreeEx(pTHS,Sorted);
    }

    THFreeEx(pTHS, pObjList);
    THFreeEx(pTHS, pResults);

    if(fGranted) {
        // We have rights to something...
        if (fDenied) {
            // ...but not everything
            return csacaPartialGrant;
        }
        else {
            // I guess we did get everything after all
            return csacaAllAccessGranted;
        }
    }

    // We didn't grant anything, so...
    return csacaAllAccessDenied;
}

DWORD
CheckSecurityClassCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG  cInClasses,
        CLASSCACHE **rgpCC,
        CLASSCACHE* pCC,
        DWORD dwFlags
        )
/*++
  Returns 0 if some access was granted, or an error code describing why all
  access was denied.

  NOTE.  rgpCC is 0 indexed.  pObjList and pResults are effectively 1 indexed.
  The 0th element of both of these two arrays is a holding space required by the
  call to IsAccessGrantedByObjectTypeList.  Make sure you use the right indexing
  for these arrays.

--*/
{
    ULONG i,j,k;
    DWORD cObjList;
    ULONG propSets=0;
    DWORD *pResults;
    GUID *pCurrentPropSet;
    POBJECT_TYPE_LIST pObjList;
    BOOL fGranted=FALSE;
    DWORD err;

    if(pTHS->fDRA || pTHS->fDSA ) {
        // These bypass security, they are internal
        return 0;
    }

    if(!cInClasses) {
        // Nothing to do
        return ERROR_DS_SECURITY_CHECKING_ERROR;
    }

    // Now, create the list
    pObjList = (POBJECT_TYPE_LIST)
        THAllocEx(pTHS,(1+cInClasses) * sizeof(OBJECT_TYPE_LIST));
    pResults = (LPDWORD) THAllocEx(pTHS, ((1+cInClasses) * sizeof(DWORD)));

    // 0th entry in POBJECT_TYPE_LIST must be ACCESS_OBJECT_GUID so that
    // CliffV's API has something to match generic ACEs against.  So when
    // checking access for a class, we do as CliffV requires in the 0th
    // entry, and place the classes' guids in the Nth entries and call them
    // ACCESS_PROPERTY_SET_GUID.

    // We can use a NULL guid here because we are not generating an audit.
    // The read_property access has already been audited. This is the "test"
    // access check that does not involve actual create_child operation.
    pObjList[0].Level = ACCESS_OBJECT_GUID;
    pObjList[0].Sbz = 0;
    pObjList[0].ObjectType = &gNullUuid;

    // If in future this function is used for actual access checks, then
    // this code needs to be changed so that a non-null guid is passed
    // by the caller.
    Assert((dwFlags & CHECK_PERMISSIONS_WITHOUT_AUDITING) || !fNullUuid(pObjList[0].ObjectType));

    for(i=1;i<=cInClasses;i++) {
        pObjList[i].Level = ACCESS_PROPERTY_SET_GUID;
        pObjList[i].Sbz = 0;
        pObjList[i].ObjectType = &(rgpCC[i-1]->propGuid);
    }

    // Make the security check call.
    if(err = IsAccessGrantedByObjectTypeList(pSecurity,
                                             pDN,
                                             pCC,
                                             RightRequested,
                                             pObjList,
                                             cInClasses+1,
                                             pResults,
                                             dwFlags,
                                             NULL,
                                             NULL)) {
        // No access to anything.
        memset(rgpCC, 0, cInClasses*sizeof(CLASSCACHE *));
        THFreeEx(pTHS,pObjList);
        THFreeEx(pTHS,pResults);
        return err;
    }

    // Filter the incoming list of classes so that if they are not readable, we
    // drop them out of the list.

    for(i=1;i<=cInClasses;i++) {
        if(pResults[i]) {
            // Access not granted
            rgpCC[i-1] = NULL;
        }
        else {
            fGranted = TRUE;
        }
    }

    THFreeEx(pTHS,pObjList);
    THFreeEx(pTHS,pResults);

    if(fGranted) {
        // We have access to something
        return 0;
    }

    // we have no access to anything
    return ERROR_DS_INSUFF_ACCESS_RIGHTS;
}


BOOL
ValidateMemberAttIsSelf (
        ATTRMODLIST *pMemberAtt
        )
/*++

Routine Description.
    Verify that the the modification is only adding or removing me.

Arguments

    pMemberAtt - modification to check.

Return Values

    TRUE if the modification is adding or removing a single value, and the value
    is the caller.
    FALSE otherwise.

--*/
{
    DWORD err;
    PDSNAME pMemberDN;
    BOOL fMatches;

#ifdef DBG
    // make sure this function is called for DN-valued attributes only
    THSTATE* pTHS = pTHStls;
    ATTCACHE* pAC = SCGetAttById(pTHS, pMemberAtt->AttrInf.attrTyp);
    Assert(pAC && (pAC->syntax == SYNTAX_DISTNAME_TYPE ||
                   pAC->syntax == SYNTAX_DISTNAME_BINARY_TYPE ||
                   pAC->syntax == SYNTAX_DISTNAME_STRING_TYPE)
          );
#endif

    // In the extended write case, we allow only addition or deletion of a
    // single DN where that DN is the DN of the person making the call.

    if(pMemberAtt->AttrInf.AttrVal.valCount != 1)
        return FALSE;

    if(pMemberAtt->choice != AT_CHOICE_ADD_VALUES &&
       pMemberAtt->choice != AT_CHOICE_REMOVE_VALUES )
        return FALSE;


    // OK, we're adding or removing a single value.

    pMemberDN = (PDSNAME)pMemberAtt->AttrInf.AttrVal.pAVal->pVal;

    // First, make sure the thing you are trying to add has a SID, because
    // otherwise, it can't be a security principal, which means it can't be the
    // client who is trying to add this.
    if(err = FillGuidAndSid (pMemberDN)) {
        if (err != ERROR_DS_NOT_AN_OBJECT && err != ERROR_DS_OBJ_NOT_FOUND) {
            LogUnhandledError(err);
        }
        return FALSE;
    }

    // Now make sure that there is a SID
    if(!pMemberDN->SidLen) {
        return FALSE;
    }

    // Now, see if we are this sid.
    if(err = SidMatchesUserSidInToken(&pMemberDN->Sid, pMemberDN->SidLen, &fMatches)) {
        LogUnhandledError(err);
        return FALSE;
    }

    // You are indeed just trying to mess with your own name, go ahead and let
    // you.
    return fMatches;

}

int
CheckRenameSecurity (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        PWCHAR szNewName,
        GUID*  pNewParentGUID,
        CLASSCACHE *pCC,
        RESOBJ * pResObj,
        ATTRTYP rdnType,
        BOOL    fMove,
        BOOL    fIsUndelete
        )
/*++

Routine Description.
    Verify that the caller has WRITE_PROPERTY on the RDN attribute and the
    attribute which is the RDN (e.g. common-name).

Arguments

    pSecurity - Security Descriptor to use for the Access Check.

    pDN - DSNAME of the object that pSecurity came from.  Doesn't require string
          portion, just object guid and sid.
          
    szNewName -- the new object DN. Used for auditing only.
    
    pNewParentGUID -- the new parent's GUID (for Move or Undelete). Used for auditing only.

    pCC - CLASSCACHE * for the class to check RDN attributes for.

Return Values

    0 if all went well, an error otherwise.  Sets an error in the THSTATE if an
    error occurs.

--*/
{
    ATTCACHE *rgpAC[2];
    CSACA_RESULT accRes;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return 0;
    }

    if(fMove &&
       // don't check Delete when reanimating
       !fIsUndelete &&
       // check DELETE_SELF first (to audit the object being deleted)
       // then, if failed, check DELETE_CHILD on the parent
       !IsAccessGranted(pSecurity,
                        pResObj->pObj,
                        pCC,
                        pCC,
                        RIGHT_DS_DELETE_SELF,
                        NULL, 
                        NULL,
                        FALSE ) &&
       !IsAccessGrantedParent(RIGHT_DS_DELETE_CHILD,pCC,TRUE)
       ) {
        // We don't have access to remove the object from it's current
        // location. The TRUE param to the second call to IsAccessGranted
        // forced IsAccessGranted to set an error already, so just return
        // it.
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }

    if(!(rgpAC[0] = SCGetAttById(pTHS, ATT_RDN)) ||
       !(rgpAC[1] = SCGetAttById(pTHS, rdnType))) {
        LogUnhandledError(DIRERR_MISSING_REQUIRED_ATT);
        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_MISSING_REQUIRED_ATT);
    }

    // check if the user is allowed to change an object that is in the
    // configuration NC or schema NC
    if (CheckModifyPrivateObject(pTHS,
                                 pSecurity,
                                 pResObj)) {
        // it is not allowed to rename this object on this DC
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }


    accRes = CheckSecurityAttCacheArray(pTHS,
                                        RIGHT_DS_WRITE_PROPERTY,
                                        pSecurity,
                                        pDN,
                                        pCC,
                                        pCC,
                                        2,
                                        rgpAC,
                                        0,
                                        szNewName,
                                        pNewParentGUID);
    if(accRes != csacaAllAccessGranted) {
        // Failed for some reason to get access to both attributes.
        SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                    ERROR_ACCESS_DENIED);
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }

    return 0;
}

void
CheckReadSecurity (
        THSTATE *pTHS,
        ULONG SecurityInformation,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        PSID psidQuotaTrustee,
        ULONG * pcInAtts,
        ATTCACHE **rgpAC
        )
{
    ATTCACHE *pACSD = NULL;        //intialized to avoid C4701
    ATTCACHE *pACEffectiveQuota = NULL;
    ATTCACHE *pACQuotaUsage = NULL;
    LONG secDescIndex=-1;
    LONG iEffectiveQuota = -1;
    LONG iQuotaUsage = -1;
    ULONG i;
    ACCESS_MASK DesiredAccess;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return;
    }

    // Look through the list for NT_SECURITY_DESCRIPTOR
    for(i=0; i < *pcInAtts; i++) {
        if(rgpAC[i]) {
            // We skip NULLs in the rgpAC array.
            switch(rgpAC[i]->id) {
            case ATT_NT_SECURITY_DESCRIPTOR:
                // Found a security descriptor request.  Keep hold of the
                // attcache pointer for later and null out the element in the
                // array so that the CheckSecurity call later doesn't apply
                // normal security checks to this attribute.
                pACSD = rgpAC[i];
                rgpAC[i] = NULL;
                if(secDescIndex == -1) {
                    // If SD is asked for multiple times, it will be denied for
                    // all except possibly the last one.
                    secDescIndex = i;
                }
                break;

            case ATT_MS_DS_QUOTA_EFFECTIVE:
                // Found en Effective-Quota request. Keep hold of the
                // attcache pointer for later in case we need to check
                // for Query Self-quota privileges if normal read
                // privileges fail
                //
                // if Effective-Quota is asked for multiple times, only
                // honour the first request
                //
                if ( iEffectiveQuota == -1 ) {
                    pACEffectiveQuota = rgpAC[i];
                    iEffectiveQuota = i;
                } else {
                    rgpAC[i] = NULL;
                }
                break;

            case ATT_MS_DS_QUOTA_USED:
                // Found a Quota-Used request. Keep hold of the
                // attcache pointer for later in case we need to check
                // for Query Self-Quota privileges if normal read
                // privileges fail
                //
                // if Quota-Used is asked for multiple times, only
                // honour the first request
                //
                if ( iQuotaUsage == -1 ) {
                    pACQuotaUsage = rgpAC[i];
                    iQuotaUsage = i;
                } else {
                    rgpAC[i] = NULL;
                }
                break;

            }

            if ( rgpAC[i] && DBIsHiddenData(rgpAC[i]->id) ) {
                // We will ALWAYS deny read property on these attributes.  If
                // you have to ask, you can't have it.  If any more attributes
                // are deemed to be invisible in the future, they should be
                // added to this case of the switch (note that this only denies
                // access to attributes in the selection list of a read or
                // search, see the routine GetFilterSecurityHelp below to deny
                // access to attributes in filters.)
                rgpAC[i] = NULL;
            }
        }
    }

    if(secDescIndex != -1) {
        // Mask out to just the important bits
        SecurityInformation &= (SACL_SECURITY_INFORMATION  |
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION    );
        if(!SecurityInformation) {
            // Asking for nothing in the flags is the same as asking for
            // everything.
            SecurityInformation = (SACL_SECURITY_INFORMATION  |
                                   OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION    );
        }

        //
        // Set the desired access based upon the requested SecurityInformation
        //

        DesiredAccess = 0;
        if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
            DesiredAccess |= ACCESS_SYSTEM_SECURITY;
        }
        if ( SecurityInformation &  (DACL_SECURITY_INFORMATION  |
                                     OWNER_SECURITY_INFORMATION |
                                     GROUP_SECURITY_INFORMATION)
            ) {
            DesiredAccess |= READ_CONTROL;
        }

        // Make the access check to see that we have rights to change this.
        if(!IsAccessGranted (pSecurity,
                             pDN,
                             pCC,
                             pCC,
                             DesiredAccess,
                             NULL, NULL,
                             FALSE )) {
            // The caller doesn't have rights to mess with the SD in the way
            // they said they wanted to.
            secDescIndex = -1;
        }
    }

    CheckSecurityAttCacheArray(pTHS,
                               RIGHT_DS_READ_PROPERTY,
                               pSecurity,
                               pDN,
                               pCC,
                               pCC,
                               *pcInAtts,
                               rgpAC,
                               0,
                               NULL,
                               NULL);

    // Don't check to see what kind of access we got for the read.  Read
    // operations never return security errors.

    if (secDescIndex != -1) {
        // We need to re-enable an attcache pointer in the array to the SD pAC
        rgpAC[secDescIndex] =  pACSD;
    }

    // see if we need to check for Query Self-Quota privileges
    //
    if ( ( -1 != iEffectiveQuota && NULL == rgpAC[iEffectiveQuota] )
        || ( -1 != iQuotaUsage && NULL == rgpAC[iQuotaUsage] ) ) {
        BOOL    fQueryingSelf   = FALSE;

        Assert( NULL != pACEffectiveQuota || NULL != pACQuotaUsage );

        //  sid, if any, should have been prevalidated already
        //
        Assert( NULL == psidQuotaTrustee || IsValidSid( psidQuotaTrustee ) );

        if ( NULL == psidQuotaTrustee ) {
            // no quota trustee specified, must be querying self
            fQueryingSelf = TRUE;

        } else if ( SidMatchesUserSidInToken(
                        psidQuotaTrustee,
                        GetLengthSid( psidQuotaTrustee ),
                        &fQueryingSelf ) ) {
            // QUOTA_UNDONE: we err'd out attempting to determine
            // if the specified quota trustee matches the current user,
            // but this function is not designed to err out, so
            // swallow the error and assume the trustee specified is
            // not the same as the current user
            //
            const DWORD     err     = GetLastError();

            DPRINT2( 0, "SidMatchesUserSidInToken failed with error %d (0x%x)\n", err, err );

            Assert( !"Unexpected failure from SidMatchesUserSidInToken(). Assuming FALSE!" );
            Assert( !fQueryingSelf );
        }

        // don't have normal read privileges,
        // so if we're not querying for another
        // quota trustee, check if we have
        // Query Self Quota privileges
        //
        if ( fQueryingSelf 
            && IsControlAccessGranted(
                        pSecurity,
                        pDN,
                        pCC,
                        RIGHT_DS_QUERY_SELF_QUOTA,
                        FALSE ) ) {

            // reinstate Effective-Quota attribute
            // if stripped
            //
            if ( -1 != iEffectiveQuota
                && NULL == rgpAC[iEffectiveQuota] ) {
                Assert( NULL != pACEffectiveQuota );
                rgpAC[iEffectiveQuota] = pACEffectiveQuota;
            }

            // reinstate Quota-Used attribute
            // if stripped
            //
            if ( -1 != iQuotaUsage
                && NULL == rgpAC[iQuotaUsage] ) {
                Assert( NULL != pACQuotaUsage );
                rgpAC[iQuotaUsage] = pACQuotaUsage;
            }
        }
    }
}

CROSS_REF *
FindCrossRefBySid(PSID pSID)
{
    CROSS_REF_LIST *pCRL = gAnchor.pCRL;

    while (pCRL) {
        if (pCRL->CR.pNC->SidLen &&
            EqualSid(pSID,
                     &(pCRL->CR.pNC->Sid))) {
            return &(pCRL->CR);
        }
        pCRL = pCRL->pNextCR;
    }
    return NULL;
}

int
CheckSecurityOwnership(THSTATE *pTHS,
                       PSECURITY_DESCRIPTOR pSD,
                       RESOBJ * pResObj)
{
    PSID pSID=NULL;
    BOOL defaulted;
    NT4SID domSid;
    ULONG  objectRid;

    // pSID is NULL if pSD does not contain an owner
    if (   GetSecurityDescriptorOwner(pSD, &pSID, &defaulted)
        && pSID) {

        SampSplitNT4SID( (NT4SID *)pSID, &domSid, &objectRid);

        if (!EqualPrefixSid(&domSid,
                            &(gAnchor.pDomainDN->Sid))) {
            /* If the SIDs don't match, generate an error */
            CROSS_REF *pCR;
            pCR = FindCrossRefBySid(&domSid);


            if (!pCR) {
                // generate a cross reference for the Root domain
                pCR = FindCrossRefBySid(&(gAnchor.pRootDomainDN->Sid));
            }

            if (pCR) {
                if (pResObj) {
                    /* If we found a cross ref, refer the user to the right domain */
                    GenCrossRef(pCR, pResObj->pObj);
                }
                else {
                    /* We don't know where to refer to, sorry. */
                    SetSecError(SE_PROBLEM_NO_INFORMATION,
                                ERROR_DS_NO_CROSSREF_FOR_NC);
                }
            }
            else {
                /* We don't know where to refer to, sorry. */
                SetSecError(SE_PROBLEM_NO_INFORMATION,
                            ERROR_DS_NO_CROSSREF_FOR_NC);
            }
        }
    }
    else {
        /* Can't read the SD owner?  Don't allow the operation */
        SetSecError(SE_PROBLEM_NO_INFORMATION,
                    ERROR_DS_NO_CROSSREF_FOR_NC);
    }
    return pTHS->errCode;
}

int
CheckTakeOwnership(THSTATE *pTHS,
                   PSECURITY_DESCRIPTOR pSD,
                   RESOBJ * pResObj)
{
    // CreateResObject makes sure NCDNT=DNT for NC heads
    Assert(!(pResObj->DNT == gAnchor.ulDNTDMD && pResObj->NCDNT != gAnchor.ulDNTDMD));
    Assert(!(pResObj->DNT == gAnchor.ulDNTConfig && pResObj->NCDNT != gAnchor.ulDNTConfig));
    if (!gAnchor.fAmRootDomainDC
        && (   (pResObj->NCDNT == gAnchor.ulDNTDMD)
            || (pResObj->NCDNT == gAnchor.ulDNTConfig))) {
        // We only do these checks if this DC is not in the root domain
        // and the object being modified is in either the schema or config NC

        return CheckSecurityOwnership (pTHS, pSD, pResObj);

    }
    return pTHS->errCode;
}

int
CheckModifyPrivateObject(THSTATE *pTHS,
                   PSECURITY_DESCRIPTOR pSD,
                   RESOBJ * pResObj)
{
    // CreateResObject makes sure NCDNT=DNT for NC heads
    Assert(!(pResObj->DNT == gAnchor.ulDNTDMD && pResObj->NCDNT != gAnchor.ulDNTDMD));
    Assert(!(pResObj->DNT == gAnchor.ulDNTConfig && pResObj->NCDNT != gAnchor.ulDNTConfig));
    if (!gAnchor.fAmRootDomainDC
        && (   (pResObj->NCDNT == gAnchor.ulDNTDMD)
            || (pResObj->NCDNT == gAnchor.ulDNTConfig))) {
        // We only do these checks if this DC is not in the root domain
        // and the object being modified is in either the schema or config NC

        UCHAR rmControl;
        DWORD cbSD=0;
        DWORD err;

        if (pSD == NULL) {
            // Find the security descriptor attribute
            if(err = DBGetAttVal(pTHS->pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                         0,0,
                         &cbSD, (PUCHAR *)&pSD)) {
                // No SD found. We assume the object is therefore locked down
                return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             ERROR_DS_CANT_RETRIEVE_SD,
                             err);
            }
        }


        // try to get the resource manager (RM) control field from the SD
        //
        err = GetSecurityDescriptorRMControl (pSD, &rmControl);

        if (err == ERROR_SUCCESS) {
            // this is a private object

            // we have something in this field. check to see if this
            // makes this object a private object
            if (rmControl & SECURITY_PRIVATE_OBJECT) {
                return CheckSecurityOwnership (pTHS, pSD, pResObj);
            }
        }
        // INVALID_DATA means the RMcontrol bit is not Set.
        // Other return codes are errors
        else if (err != ERROR_INVALID_DATA) {

            /* Can't read the RM control?  Don't allow the operation */
            SetSecError(SE_PROBLEM_NO_INFORMATION,
                        ERROR_DS_NO_CROSSREF_FOR_NC);
        }
    }
    return pTHS->errCode;
}



int CheckModifyQuota(
	DBPOS * const			pDB,
	MODIFYARG * const		pModifyArg,
	PSECURITY_DESCRIPTOR	pOldSD,
	PSECURITY_DESCRIPTOR	pNewSD,
	const ULONG				cbNewSD,
	BOOL					fOwnerChanged,
	const BOOL				fIsUndelete )
	{
	DWORD					err;
	BOOL					fAllocatedOldSD		= FALSE;
	SYNTAX_INTEGER			insttype;

	//	caller should prevalidate that we either changed ownership
	//	or did an undelete before calling this function
	//
	Assert( fOwnerChanged || fIsUndelete );

	//	only need a new SD for change-ownership
	//
	Assert( !fOwnerChanged || NULL != pNewSD );
	Assert( !fOwnerChanged || cbNewSD > 0 );

	//	must retrieve instance type to check if
	//	if we're tracking quota for this object
	//
	//	QUOTA_UNDONE: what if the Modify operation
	//	resulted in a change of the instance type
	//	such that we used to track quota for the
	//	object, but now we don't (or vice versa)??
	//
	err = GetExistingAtt(
					pDB,
					ATT_INSTANCE_TYPE,
					&insttype,
					sizeof(insttype) );
	if ( DB_success != err )
		{
		//	instance type is missing, something is horribly wrong
		//
		Assert( !"Missing instance type.\n" );
		err = SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err );
		goto HandleError;
		}

	//	see if we must track quota for this object
	//
	if ( FQuotaTrackObject( insttype ) )
		{
		//	if original SD was not yet retrieved, retrieve it now
		//
		if ( NULL == pOldSD )
			{
			ULONG	cbOldSD;

			if ( err = DBGetAttVal(
							pDB,
							1,
							ATT_NT_SECURITY_DESCRIPTOR,
							0,
							0,
							&cbOldSD,
							(PUCHAR *)&pOldSD ) )
				{
				//	no SD found, something is amiss
				//
				err = SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, ERROR_DS_CANT_RETRIEVE_SD, err );
				goto HandleError;
				}


			//	indicate that we've allocated memory
			//	for the old SD, so that we can free
			//	it on function exit
			//
			fAllocatedOldSD = TRUE;

			//	if we believe the owner changed, try to verify that it was indeed
			//	modified by ensuring that the SD is different (though this doesn't
			//	guarantee for sure that the owner was in fact changed)
			//
			//	note that if the caller passed in an old SD, then they should
			//	already have performed this comparison
			//
			if ( fOwnerChanged )
            	{
                Assert( NULL != pNewSD );
                Assert( cbNewSD > 0 );
                fOwnerChanged = ( cbOldSD != cbNewSD
								|| 0 != memcmp( pOldSD, pNewSD, cbOldSD ) );
            	}
			}

		if ( fOwnerChanged )
			{                   
			BOOL	fTombstoned;

			//	must see of object was tombstoned so we
			//	update quota counts accordingly
			//
			err = DBGetSingleValue(
						pDB,
						ATT_IS_DELETED,
						&fTombstoned,
						sizeof(fTombstoned),
						NULL );		//	pSizeRead
			if ( DB_ERR_NO_VALUE == err )
				{
				// attribute is NULL, meaning
				// that the object was not
				// actually tombstoned, so this
				// isn't really an undelete
				//
				fTombstoned = FALSE;
				}
			else if ( DB_success != err )
				{
				// something went wrong
				//
				err = SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err );
				goto HandleError;
				}

			//	update quota counts for old and new owner
			//
			//	NOTE: it's possible fTombstoned is FALSE
			//	and fIsUndelete is TRUE because the IsDeleted
			//	flag may get reset first (in UndeletePreProcess)
			//
			if ( ErrQuotaDeleteObject( pDB, pDB->NCDNT, pOldSD, fTombstoned || fIsUndelete )
			    || ErrQuotaAddObject( pDB, pDB->NCDNT, pNewSD, fTombstoned && !fIsUndelete ) )
			    {
				DPRINT( 0, "Failed updating quota counts for object change-ownership.\n" );
				Assert( ERROR_SUCCESS != pDB->pTHS->errCode );
				Assert( NULL != pDB->pTHS->pErrInfo );

				if ( serviceError == pDB->pTHS->errCode
					&& STATUS_QUOTA_EXCEEDED == pDB->pTHS->pErrInfo->SvcErr.extendedErr )
					{
					PSID	pOwnerSid	= NULL;
					BOOL	fUnused;

					//	attempt to extract owner sid from the SD, but if we fail,
					//	ignore the error and just report the event without the sid
					//
					Assert( IsValidSecurityDescriptor( pNewSD ) );
					(VOID)GetSecurityDescriptorOwner( pNewSD, &pOwnerSid, &fUnused );
					Assert( NULL != pOwnerSid );
					Assert( IsValidSid( pOwnerSid ) );

					//	report quota exceeded
					//
					LogEvent8WithData(
							DS_EVENT_CAT_SECURITY,
							DS_EVENT_SEV_MINIMAL,
							DIRLOG_QUOTA_EXCEEDED_ON_CHANGE_OWNER,
							szInsertDN( pModifyArg->pObject ),
							szInsertUL( pDB->NCDNT ),
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							( NULL != pOwnerSid ? GetLengthSid( pOwnerSid ) : 0 ),
							pOwnerSid );
					}

				err = pDB->pTHS->errCode;
				goto HandleError;
				}
			}

		else if ( fIsUndelete )
			{
			//	just update the quota count for the resurrected object
			//
			//	QUOTA_UNDONE: I'm assuming here that attempts to undelete a non-tombstoned
			//	object will fail elsewhere
			//
			if ( ErrQuotaResurrectObject( pDB, pDB->NCDNT, pOldSD ) )
				{
				DPRINT( 0, "Failed updating quota counts for object resurrection.\n" );
				Assert( ERROR_SUCCESS != pDB->pTHS->errCode );
				Assert( NULL != pDB->pTHS->pErrInfo );

				if ( serviceError == pDB->pTHS->errCode
					&& STATUS_QUOTA_EXCEEDED == pDB->pTHS->pErrInfo->SvcErr.extendedErr )
					{
					PSID	pOwnerSid	= NULL;
					BOOL	fUnused;

					//	attempt to extract owner sid from the SD, but if we fail,
					//	ignore the error and just report the event without the sid
					//
					Assert( IsValidSecurityDescriptor( pOldSD ) );
					(VOID)GetSecurityDescriptorOwner( pOldSD, &pOwnerSid, &fUnused );
					Assert( NULL != pOwnerSid );
					Assert( IsValidSid( pOwnerSid ) );

					//	report quota exceeded
					//
					LogEvent8WithData(
							DS_EVENT_CAT_SECURITY,
							DS_EVENT_SEV_MINIMAL,
							DIRLOG_QUOTA_EXCEEDED_ON_UNDELETE,
							szInsertDN( pModifyArg->pObject ),
							szInsertUL( pDB->NCDNT ),
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							( NULL != pOwnerSid ? GetLengthSid( pOwnerSid ) : 0 ),
							pOwnerSid );
					}

				err = pDB->pTHS->errCode;
				goto HandleError;
				}
			}

		else
			{
			//	must have retrieved the old SD above and then reset
			//	fOwnerChanged because we discovered that the SD
			//	hasn't actually changed
			//
			Assert( fAllocatedOldSD );
			}
		}

	err = ERROR_SUCCESS;

HandleError:
	if ( fAllocatedOldSD )
		{
		THFreeEx( pDB->pTHS, pOldSD );
		}

	return err;
	}


// WARNING: this function should only be called by
// replication or during IFM, but I can't currently
// enforce it without passing in an extra param
//
BOOL FIsModReplicatedUndelete( const ATTRMODLIST * const pMod )
	{
	BOOL	fUndeleting		= FALSE;

	//	caller should already have determined that
	//	this is the IsDeleted attribute
	//
	Assert( ATT_IS_DELETED == pMod->AttrInf.attrTyp );

	if ( AT_CHOICE_REMOVE_ATT == pMod->choice )
		{
		//	IsDeleted is being removed
		//
		fUndeleting = TRUE;
		}
	else if ( AT_CHOICE_REPLACE_ATT == pMod->choice
			&& 0 != pMod->AttrInf.AttrVal.valCount )
		{
		//	should not be multi-valued
		//
		Assert( 1 == pMod->AttrInf.AttrVal.valCount );
		Assert( NULL != pMod->AttrInf.AttrVal.pAVal );

		if ( sizeof(SYNTAX_BOOLEAN) == pMod->AttrInf.AttrVal.pAVal->valLen
			&& FALSE == *( (SYNTAX_BOOLEAN *)( pMod->AttrInf.AttrVal.pAVal->pVal ) ) )
			{
			//	IsDeleted is being set to FALSE
			//
			fUndeleting = TRUE;
			}
		}

    return fUndeleting;
    }


int
CheckModifySecurity (
        THSTATE *pTHS,
        MODIFYARG* pModifyArg,
        BOOL       *pfCheckDNSHostNameValue,
        BOOL       *pfCheckAdditionalDNSHostNameValue,
        BOOL       *pfCheckSPNValues,
        BOOL       fIsUndelete
        )
{
    DBPOS * const pDB = pTHS->pDB;
    ATTRMODLIST *pAttList = &(pModifyArg->FirstMod);  /*First att in list*/
    ATTRMODLIST *pSDAtt=NULL;
    ATTRMODLIST *pMemberAtt=NULL;
    ULONG       count, i;
    ULONG       ulLen;
    ATTCACHE    *pAC;
    ATTCACHE    **rgpAC = NULL;
    ATTCACHE    **rgpACExtended = NULL;
    CLASSCACHE  *pCC=NULL;
    PSECURITY_DESCRIPTOR pOldSD = NULL;     // SD already on the object.
    PSECURITY_DESCRIPTOR pMergedSD = NULL;  // SD to write on the object.
    PSECURITY_DESCRIPTOR pUseSD;            // SD to check access with.
    PSECURITY_DESCRIPTOR pSetSD = NULL;     // SD Passed in by Client
    PSECURITY_DESCRIPTOR pMergedSD1 = NULL, pMergedSD2 = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdcSetSD;
    BOOL        fMustInheritParentACEs;
    BOOL        fReplacingAllSDParts;
    BOOL        fOwnerChanged = FALSE;
    DWORD       sdRevision;
    DWORD       cbOldSD=0;
    DWORD       cbMergedSD=0;
    DWORD       cbMergedSD1, cbMergedSD2;
    DWORD       cbSetSD;
    ULONG       samclass;
    DWORD       err;
    DWORD       memberFound = 0;
    BOOL        fsmoRoleFound = FALSE;
    BOOL        dnsHostNameFound = FALSE;
    BOOL        additionalDnsHostNameFound = FALSE;
    BOOL        servicePrincipalNameFound = FALSE;
    BOOL        fIsDerivedFromComputer = FALSE;
    BOOL        fQuotaError = FALSE;
    CSACA_RESULT accRes;
    GUID*       ppGuid[1];

    // The SD propagator should never be here.
    Assert(!pTHS->fSDP);

    if ( DsaIsInstalling() && !DsaIsInstallingFromMedia() ) {
        return 0;
    }

    // If access Checks have already done then bail out
    if ( pTHS->fAccessChecksCompleted ) {
        return 0;
    }


    // NTRAID#NTRAID-757507-2002/12/19-JLiem 
    // The check below originally checked for DsaIsInstallingFromMedia()
    // instead of DsaIsInstalling(), but this introduced a problem
    // whereby if DsaIsInstallingFromMedia() is TRUE but DsaIsInstalling()
    // is FALSE, then we would bypass the code below that merges SD's
    // properly. This was something of a revelation because no one I asked
    // (brettsh, wlees) believed that we should ever have
    // DsaIsInstallingFromMedia() return TRUE but DsaIsInstalling() return
    // FALSE. We now know that this can in fact occur

	/*
    From some email I sent out bug#757507:

    CheckModifySecurity() can do one of two things depending on when its
    called. It may simply enqueue SD propagation and update quota counts.
    Or it may also do more sophisticated SD merging and such.  If its
    being called by replication, only the former is performed, otherwise
    the latter is normally performed. However, there are a couple of
    install-related scenarios that must also be dealt with:

    DsaIsInstalling() == TRUE, DsaIsInstallingFromMedia() == FALSE:
        We short-circuit CheckModifySecurity() altogether and return right
        away. This is fine for quota counts, because the quota table is not
        built until after install.
    DsaIsInstalling() == TRUE, DsaIsInstallingFromMedia() == TRUE:
        In this case, the only thing we need to do is ensure quota counts
        are correct, so we take the *simple* path
    DsaIsInstalling() == FALSE, DsaIsInstallingFromMedia() == TRUE:
        This is the case I didnt handle correctly.  We originally thought
        this was impossible, but it turns out thats not the case. There is
        in fact a window where DsaIsInstalling() is FALSE, but
        DsaIsInstallingFromMedia() is TRUE.  In such cases, we want to take
        the full code path that deals with SD merging in addition to
        updating quota counts.  The fix now permits this.

    Heres a sample callstack of where LocalModify() (and CheckModifySecurity())
    is called with DsaIsInstalling()==FALSE but DsaIsInstallingFromMedia()==TRUE
    (ignore the Jet assert, as I had used a bootleg esent.dll rigged to assert
    at a certain point so that I could trap this scenario):

        ChildEBP RetAddr  Args to Child
        0176ea18 0128a3d9 0176f30c 0128ab1c e0010004 ntdll!DbgBreakPoint
        0176ea20 0128ab1c e0010004 02d506c8 00000000 ESENT!KernelDebugBreakPoint+0x9
        0176f30c 011b5759 010478f4 010478d7 000000c6 ESENT!AssertFail+0x2ac
        0176f338 0110b6c8 00fe03c0 02423e70 00000000 ESENT!ErrIsamUpdate+0xd9
        0176f360 01175dbf 00fe03c0 02423e70 00000000 ESENT!ErrDispUpdate+0x58
        0176f3a4 01175eda 00fe03c0 02423e70 00000000 ESENT!JetUpdateEx+0x3f
        0176f3f0 70c0db01 00fe03c0 02423e70 00000000 ESENT!JetUpdate2+0x4a
        0176f41c 70bdd8d8 00fe03c0 02423e70 00000000 NTDSA!JetUpdateException+0x138
        0176f44c 70be68fa 00000001 00000000 70aaee6c NTDSA!DBUpdateRec+0xc5
        0176f518 70b2d846 02d506c8 00000000 00000000 NTDSA!DBRepl+0x1cd
        0176f624 70b15189 025a0dc0 0176f890 00000000 NTDSA!InsertObj+0x8d
        0176f760 70b16fa2 025a0dc0 00000000 0176fa5c NTDSA!LocalModify+0x580
        0176f880 7083cba8 0176fa40 0176fb08 00000120 NTDSA!DirModifyEntry+0x1b0
        0176fb54 7083dba1 0176fe78 0176fdd4 0176fe78 Ntdsetup!NtdspAddDomainAdminAccessToServer+0x2e6
        0176fce4 70836a78 0176fe78 0176fdd4 00000000 Ntdsetup!NtdspDsInitialize+0x5bd
        0176fe54 733c9f7a 0176fe78 0176ff5c 0176ff80 Ntdsetup!NtdsInstall+0x248
        0176fed4 733cf2cc 00131350 00000000 00000000 LSASRV!DsRolepInstallDs+0x1fd
        0176ffb8 77e6d28c 0009f9e0 00000000 00000000 LSASRV!DsRolepThreadPromoteReplica+0x408
        0176ffec 00000000 733ceec4 0009f9e0 00000000 kernel32!BaseThreadStart+0x34
    */
    

    // Anyone else must find out if the SD is being modified.
    if ( pTHS->fDRA || DsaIsInstalling() ) {

        // if installing, this must be IFM, so we still need to
        // update quota counts
        //
        Assert( !DsaIsInstalling() || DsaIsInstallingFromMedia() );

        // an originating undelete is detected differently than
        // a replicated undelete, so reset the flag and make
        // our own determination regarding whether this is
        // an undelete
        //
        fIsUndelete = FALSE;

        // We don't go through the normal check, so do a quick look through the
        // list to see if we are touching the SD.
        //
        for (count = 0; count < pModifyArg->count; count++) {
            Assert( NULL != pAttList );
            if ( ATT_NT_SECURITY_DESCRIPTOR == pAttList->AttrInf.attrTyp ) {
                // Yes, queue a SD propagation
                if ( !DsaIsInstallingFromMedia()
                    && ( err = DBEnqueueSDPropagation(pDB, TRUE) ) ) {
                    // We failed to enqueue the propagation, fail the call
                    return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
                 }

                // Keep track of the value (last one wins)
                //
                pSDAtt = pAttList;
                pSetSD = pSDAtt->AttrInf.AttrVal.pAVal->pVal;
                cbSetSD= pSDAtt->AttrInf.AttrVal.pAVal->valLen;

            } else if ( ATT_IS_DELETED == pAttList->AttrInf.attrTyp ) {
                // should only see one occurrence of this attribute
                //
                Assert( !fIsUndelete );
                fIsUndelete = FIsModReplicatedUndelete( pAttList );
            }

            pAttList = pAttList->pNextMod;   /*Next mod*/
        }

        // if security descriptor being modified, see if owner
        // is being changed, in which case we have to update
        // quota counts accordingly
        if ( NULL != pSDAtt ) {
            // We got a new security descriptor.  Make the call to see if
            // the old security descriptor allows the new security descriptor to be
            // written.  The call also performs magic and returns a merged security
            // descriptor which we should write.
            SECURITY_INFORMATION SecurityInformation =
                pModifyArg->CommArg.Svccntl.SecurityDescriptorFlags;

            fOwnerChanged = ( SecurityInformation & OWNER_SECURITY_INFORMATION );
        }

        // if we're undeleting, verify that the IsDeleted flag was originally
        // set to TRUE (if not, then it's not really an undelete)
        //
        if ( fIsUndelete )
            {
            err = DBGetSingleValue(
                        pDB,
                        ATT_IS_DELETED,
                        &fIsUndelete,
                        sizeof(fIsUndelete),
                        NULL );     // pSizeRead
            if ( DB_ERR_NO_VALUE == err )
                {
                // attribute is NULL, meaning
                // that the object was not
                // actually tombstoned, so this
                // isn't really an undelete
                //
                fIsUndelete = FALSE;
                }
            else if ( DB_success != err )
                {
                // something went wrong
                //
                return SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR, err );
                }
            }

        // we will be updating quota counts if the owner changed or this is an undelete
        //
        if ( ( fOwnerChanged || fIsUndelete )
            && CheckModifyQuota( pDB, pModifyArg, NULL, pSetSD, cbSetSD, fOwnerChanged, fIsUndelete ) ) {
            Assert( ERROR_SUCCESS != pTHS->errCode );
            return pTHS->errCode;
        }

        return 0;
    }

    __try {
        // Look up the classcache.
        if (!(pCC = SCGetClassById(pTHS,
                                   pModifyArg->pResObj->MostSpecificObjClass))) {
            // Failed to get the class cache pointer.
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_OBJECT_CLASS_REQUIRED);
            __leave;
        }



        // Find the security descriptor attribute
        if(err = DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR,
                             0,0,
                             &cbOldSD, (PUCHAR *)&pOldSD)) {
            // No SD found. We assume the object is therefore locked down
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_CANT_RETRIEVE_SD, err);
            __leave;
        }

        //build the list of attrtyps we are modifying in this call.
        rgpAC =
            (ATTCACHE **)THAllocEx(pTHS,pModifyArg->count * sizeof(ATTCACHE *));

        for (count = 0, i=0; count < pModifyArg->count; count++){
            if(pAC = SCGetAttById(pTHS, pAttList->AttrInf.attrTyp)) {
                // Look up the attribute.
                rgpAC[i++] = pAC;

                switch (pAC->id) {
                case ATT_NT_SECURITY_DESCRIPTOR:
                    // Special call for the security descriptor.
                    // We only allow replacement of the SD, not removing (attribute
                    // or values) or addind (attribute or values).

                    if(  pAttList->choice != AT_CHOICE_REPLACE_ATT
                       || pAttList->AttrInf.AttrVal.valCount == 0 ) {
                        // Set aunwilling to perform
                        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, DIRERR_ILLEGAL_MOD_OPERATION);
                        __leave;
                    }

                    // We don't do normal security checks, remove this from this
                    // list of attributes to check.
                    i--;

                    // Keep track of the value, since we'll need to do magic on this
                    // later, and replace the last SD we try to write using this
                    // modification with a merged SD.
                    pSDAtt = pAttList;
                    break;

                case ATT_MEMBER:
                    memberFound++;
                    // Keep track of the value, since we might need to check it
                    // later if we do a check for WriteSelf.
                    pMemberAtt = pAttList;
                    break;

                case ATT_USER_PASSWORD:

                    //depending on the value of the heristic we will treat this
                    // as a sam attribute or a regular ds attribute

                    if (!gfUserPasswordSupport) {
                        break;
                    }

                case ATT_UNICODE_PWD:

                    // Ignore this attribute on Sam objects
                    // as loopback will make SAM check for appropriate access

                    if (SampSamClassReferenced(pCC,&samclass)) {
                        i--;
                    }
                    break;

                case ATT_FSMO_ROLE_OWNER:
                    fsmoRoleFound = TRUE;
                    break;

                case ATT_DNS_HOST_NAME:
                    dnsHostNameFound = TRUE;
                    break;

                case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                    additionalDnsHostNameFound = TRUE;
                    break;


                case ATT_SERVICE_PRINCIPAL_NAME:
                    servicePrincipalNameFound = TRUE;
                    break;

                case ATT_IS_DELETED:
                case ATT_OBJ_DIST_NAME:
                    if (fIsUndelete) {
                        // we don't want to check these for undelete
                        i--;
                    }
                    break;

                default:
                    break;
                }
            }
            else {
                SAFE_ATT_ERROR(pModifyArg->pObject,
                               pAttList->AttrInf.attrTyp,
                               PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                               DS_ERR_ATT_NOT_DEF_IN_SCHEMA);
            }

            pAttList = pAttList->pNextMod;   /*Next mod*/
        }
        if (pTHS->errCode) {
            // we encountered at least one unknown attribute. Bail.
            __leave;
        }

        if(pSDAtt) {
            // We got a new security descriptor.  Make the call to see if
            // the old security descriptor allows the new security descriptor to be
            // written.  The call also performs magic and returns a merged security
            // descriptor which we should write.
            PSECURITY_DESCRIPTOR pTempSD;
            SECURITY_INFORMATION SecurityInformation =
                pModifyArg->CommArg.Svccntl.SecurityDescriptorFlags;
            ACCESS_MASK SDAccess = 0;

#define SEC_INFO_ALL (SACL_SECURITY_INFORMATION  | \
                      OWNER_SECURITY_INFORMATION | \
                      GROUP_SECURITY_INFORMATION | \
                      DACL_SECURITY_INFORMATION    )

            // Mask out to just the important bits
            SecurityInformation &= SEC_INFO_ALL;
            if(!SecurityInformation) {
                // Asking for nothing in the flags is the same as asking for
                // everything.
                SecurityInformation = SEC_INFO_ALL;
            }

            if(!pTHS->fDSA) {
                // Need to check security before we let you touch SDs
                if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
                    SDAccess |= ACCESS_SYSTEM_SECURITY;
                }
                if ( SecurityInformation & (OWNER_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION)) {
                    SDAccess |= WRITE_OWNER;
                    if (CheckTakeOwnership(pTHS,
                                           pOldSD,
                                           pModifyArg->pResObj)) {
                        // This DC will not allow taking ownership of this obj
                        __leave;
                    }
                }
                if ( SecurityInformation & DACL_SECURITY_INFORMATION ) {
                    SDAccess |= WRITE_DAC;
                }

                // Make the access check to see that we have rights to change this.
                if(!IsAccessGranted (pOldSD,
                                     pModifyArg->pObject,
                                     pCC,
                                     pCC,
                                     SDAccess,
                                     NULL, NULL,
                                     TRUE)) {
                    // The caller doesn't have rights to mess with the SD in the
                    // way they said they wanted to.
                    __leave;
                }
            }

            // Ok, we have rights, go ahead and merge the SD.

            // Save the original security descriptor passed in by the client
            // This is used by the hack below to reduce security descriptor
            // propagation events
            pSetSD = pSDAtt->AttrInf.AttrVal.pAVal->pVal;
            cbSetSD= pSDAtt->AttrInf.AttrVal.pAVal->valLen;

            // for proper quota tracking, we'll need to know if the owner
            // is being changed
            //
            fOwnerChanged = ( SecurityInformation & OWNER_SECURITY_INFORMATION );

            // KedarD says we need to ALWAYS merge with the parent SD.
            // Then MergeSecurityDescriptorAnyClient is called with
            // MERGE_CREATE, which ensures that we properly inherit
            // all inheritable ACEs from parent and also re-expand
            // creator-owner aces (in case owner has changed).
            // Also note that SD propagator does the MERGE_CREATE
            // with the parent SD anyway.
            //
            // We must first do a MERGE with current SD and then
            // CREATE with parentSD.
            // The only exception is when all SD parts (DACL, SACL, Group
            // and Owner info) are modified: in this case the MERGE step
            // can be skipped because pSetSD contains all new info that must
            // replace the original info

            fReplacingAllSDParts = SecurityInformation == SEC_INFO_ALL;

            // figure out if we need to inherit parent ACEs. We do by default.
            fMustInheritParentACEs = TRUE;
            // grab SD control value for Set SD
            GetSecurityDescriptorControl(pSetSD, &sdcSetSD, &sdRevision);
            if ((sdcSetSD & SE_DACL_PROTECTED) && (sdcSetSD & SE_SACL_PROTECTED)) {
                fMustInheritParentACEs = FALSE;
            }
            else {
                // the SD is not protected. Figure out if it's an NC head
                // or a deleted object.
                if ((pModifyArg->pResObj->InstanceType & IT_NC_HEAD) || pModifyArg->pResObj->IsDeleted) {
                    fMustInheritParentACEs = FALSE;
                }
            }

            ppGuid[0] = &pCC->propGuid;

            if (fMustInheritParentACEs && fReplacingAllSDParts) {
                // pSetSD contains all the non-inherited info we need to put into the new SD.
                // The inherited ACEs are picked up from the parent's SD (see below)
                pMergedSD = pSetSD;
                cbMergedSD = cbSetSD;
            }
            else {
                // Merge the new SD with the old SD. This step is performed in either of the
                // two cases:
                // 1. Not all SD parts are being set, so we need to pick up remaining (unchanged)
                //    parts from the old SD
                //       and/or
                // 2. The new SD is protected from inheritance (fMustInheritParentACEs == FALSE),
                //    so we will not merge with the parent. Then we want to validate the supplied
                //    SD, strip non-explicit aces and such.
                if (err = MergeSecurityDescriptorAnyClient(
                                pTHS,
                                pOldSD,
                                cbOldSD,
                                pSetSD,
                                cbSetSD,
                                SecurityInformation,
                                (pTHS->fDSA?MERGE_AS_DSA:0),
                                ppGuid,
                                1,
                                NULL,
                                &pMergedSD1,
                                &cbMergedSD1)) {
                    SetAttError(pModifyArg->pObject, ATT_NT_SECURITY_DESCRIPTOR,
                                PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                NULL, err);
                    __leave;
                }
                pMergedSD = pMergedSD1;
                cbMergedSD = cbMergedSD1;
            }

            if (fMustInheritParentACEs) {
                // have to grab parent's SD so that inherited ACE get into the new
                PSECURITY_DESCRIPTOR    pParentSD = NULL;     // SD of parent
                DWORD                   cbParentSD;
                BOOL                    fParentSDIsGlobalSDRef;

                // grab parent info (this uses Search table so that currency is not disturbed)
                err = DBGetParentSecurityInfo(pDB, &cbParentSD, &pParentSD, NULL, NULL, &fParentSDIsGlobalSDRef);

                if (err == 0) {

                    // we need to skip security checks if we already performed
                    // a merge above (i.e. fReplacingAllSDParts == FALSE)
                    // or if we are the DSA. This is because the SD we are merging
                    // now contains all SD parts (including the owner and group),
                    // while the user did not actually set them.
                    err = MergeSecurityDescriptorAnyClient(
                                pTHS,
                                pParentSD,
                                cbParentSD,
                                pMergedSD,
                                cbMergedSD,
                                SecurityInformation,
                                MERGE_CREATE | (pTHS->fDSA || !fReplacingAllSDParts ? MERGE_AS_DSA:0),
                                ppGuid,
                                1,
                                NULL,
                                &pMergedSD2,
                                &cbMergedSD2);
                }

                if (pParentSD && !fParentSDIsGlobalSDRef) {
                    THFreeEx(pTHS, pParentSD);
                }

                if (err) {
                    SetAttError(pModifyArg->pObject, ATT_NT_SECURITY_DESCRIPTOR,
                                PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                NULL, err);
                    __leave;
                }

                // the new sd is what we need
                pMergedSD = pMergedSD2;
                cbMergedSD = cbMergedSD2;
            }

            pTempSD = (PSECURITY_DESCRIPTOR)THAllocEx(pTHS, cbMergedSD);
            memcpy(pTempSD, pMergedSD, cbMergedSD);
            pMergedSD = pTempSD;

            // we should never accept an SD from the user without validating it.
            Assert(pMergedSD != pSetSD);

            if (!gfDontStandardizeSDs && gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WIN_DOT_NET) {
                DWORD dwSavedDACLSize, dwSavedSACLSize;
                // sort the ACEs in the SD
                if (StandardizeSecurityDescriptor(pMergedSD, &dwSavedDACLSize, &dwSavedSACLSize)) {
                    Assert(cbMergedSD - dwSavedDACLSize - dwSavedSACLSize == RtlLengthSecurityDescriptor(pMergedSD));
                    // even if we got it wrong and the assert went off, fix it up and continue.
                    cbMergedSD = RtlLengthSecurityDescriptor(pMergedSD);
                }
                else {
                    // failed to standardize the SD. This is not a big problem
                    DPRINT1(0, "Failed to standardize SD, err=%d. The SD might be in a non-canonical form\n",
                            GetLastError());
                }
            }

            // Even though we replace the value in modarg, we should not free
            // the old value. It might have not been created on THSTATE heap
            // in case the call is from an internal caller. An example of this
            // is NtdspAddDomainAdminAccessToServer, which allocates the SD on
            // the process heap.

            // replace the value in the modarg
            pSDAtt->AttrInf.AttrVal.pAVal->pVal = pMergedSD;
            pSDAtt->AttrInf.AttrVal.pAVal->valLen = cbMergedSD;

            // we should be using the old SD to check permissions for this MODIFY
            pUseSD = pOldSD;

            Assert( IsValidSecurityDescriptor( pOldSD ) );
            Assert( IsValidSecurityDescriptor( pMergedSD ) );

            if (cbOldSD != cbMergedSD || memcmp(pOldSD, pMergedSD, cbOldSD)) {
                // We are changing the SD, so we need to enqueue a propagation
                // of the change. Note: the SDP will only see this event when
                // we commit.
                if(err = DBEnqueueSDPropagation(pDB, pTHS->fDSA)) {
                    // We failed to enqueue the propagation.  Fail the call.
                    SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
                    __leave;
                }
            } else {
                // old and new SD's are identical, so unequivocally reset
                // fOwnerChanged flag
                //
                fOwnerChanged = FALSE;
            }
        }
        else {
            pUseSD = pOldSD;
        }

        // enforce/update quota if necessary
        //
        if ( ( fOwnerChanged || fIsUndelete ) 
            && CheckModifyQuota( pDB, pModifyArg, pOldSD, pMergedSD, cbMergedSD, fOwnerChanged, fIsUndelete ) ) {
            Assert( ERROR_SUCCESS != pTHS->errCode );
            fQuotaError = TRUE;
            __leave;
        }

        if(pTHS->fDSA) {
            // We don't actually need to make any checks if we are the DSA, we've
            // only come this far in order to do the SD merge above.
            __leave;
        }

        // RAID: 343097
        // check if the user is allowed to change an object that is in the
        // configuration NC or schema NC
        if (CheckModifyPrivateObject(pTHS,
                                     pOldSD,
                                     pModifyArg->pResObj)) {
            // it is not allowed to change this object on this DC
            __leave;
        }

        if(!i) {
            // We don't seem to have any more attributes to check security rights
            // on.  Therefore, either we were passed in an empty list of
            // modifications, or a list that only included SDs and UNICODE_PASSWORDs
            // on SAM objects.  These two kinds of attributes have already been
            // dealt with via other code paths, and since we're here, we must have
            // already been granted access to those attributes.  Anyway, there is
            // nothing more to do, so return.
            __leave;
        }

        // Special check for control access rights if you are messing with the
        // fsmoRoleOwner attribute.
        if(fsmoRoleFound) {
            GUID ControlGuid;

            switch (pCC->ClassId) {
            case CLASS_INFRASTRUCTURE_UPDATE:
                ControlGuid = RIGHT_DS_CHANGE_INFRASTRUCTURE_MASTER;
                break;

            case CLASS_DMD:
                ControlGuid = RIGHT_DS_CHANGE_SCHEMA_MASTER;
                break;

            case CLASS_RID_MANAGER:
                ControlGuid = RIGHT_DS_CHANGE_RID_MASTER;
                break;

            case CLASS_DOMAIN:
                ControlGuid = RIGHT_DS_CHANGE_PDC;
                break;

            case CLASS_CROSS_REF_CONTAINER:
                ControlGuid = RIGHT_DS_CHANGE_DOMAIN_MASTER;
                break;

            default:
                fsmoRoleFound = FALSE;
                break;
            }

            if(fsmoRoleFound &&
               !IsControlAccessGranted(pUseSD,
                                       pModifyArg->pObject,
                                       pCC,
                                       ControlGuid,
                                       TRUE)) {
                __leave;
            }
        }


        // Make a copy of the attcache array we're going to use for the check.  We
        // use this copy during processing of insufficient rights checks, below.
        rgpACExtended = (ATTCACHE **)THAllocEx(pTHS,pModifyArg->count * sizeof(ATTCACHE *));
        memcpy(rgpACExtended, rgpAC, pModifyArg->count * sizeof(ATTCACHE *));

        // Now make the call to see if we have WRITE rights on all the properties we
        // are messing with.
        accRes = CheckSecurityAttCacheArray(
                        pTHS,
                        RIGHT_DS_WRITE_PROPERTY,
                        pUseSD,
                        pModifyArg->pObject,
                        pCC,
                        pCC,
                        i,
                        rgpAC,
                        0,
                        NULL,
                        NULL);

        if(accRes != csacaAllAccessGranted) {
            // Find out if this is derived from a computer, since we need to know
            // while doing this extended check.
            if(pCC->ClassId != CLASS_COMPUTER) {
                DWORD j;
                fIsDerivedFromComputer = FALSE;
                for (j=0; !fIsDerivedFromComputer && j<pCC->SubClassCount; j++) {
                    if (pCC->pSubClassOf[j] == CLASS_COMPUTER) {
                        fIsDerivedFromComputer = TRUE;
                    }
                }
            }
            else {
                fIsDerivedFromComputer = TRUE;
            }


            // We were denied all access for some reason.  Check for extended
            // access.
            accRes = CheckSecurityAttCacheArray(
                        pTHS,
                        RIGHT_DS_WRITE_PROPERTY_EXTENDED,
                        pUseSD,
                        pModifyArg->pObject,
                        pCC,
                        pCC,
                        i,
                        rgpACExtended,
                        0,
                        NULL,
                        NULL);

            while(i) {
                // Any properties we don't have normal WRITE_PROPERTY rights to have
                // been replaced with a NULL in rgpAC.  Any that we don't have
                // WRITE_PROPERTY_EXTENDED rights to have been replace with a NULL
                // in rgpACExtended.
                i--;
                if(!rgpAC[i]) {
                    BOOL fError = FALSE;
                    // Null in rgpAC means that we were denied WRITE_PROPERTY
                    // access.  See if we were granted WRITE_PROPERTY_EXTENDED on
                    // this attribute.
                    if(!rgpACExtended[i]) {
                        // Nope.  Neither WRITE_PROPERTY nor
                        // WRITE_PROPERTY_EXTENDED.   Error out.
                        fError = TRUE;
                    }
                    else switch(rgpACExtended[i]->id) {
                    case ATT_MEMBER:
                        Assert(memberFound);
                        // No normal rights to member, but we do have extended
                        // rights.  Verify that the value we are writing is correct.
                        if((memberFound != 1) ||
                           !ValidateMemberAttIsSelf(pMemberAtt)) {
                            // Nope, even though we have the extended rights, we
                            // don't have the correct value.
                            fError = TRUE;
                        }
                        break;

                    case ATT_DNS_HOST_NAME:
                        Assert(dnsHostNameFound);
                        // No normal rights to this attribute, but extended rights.
                        // If this class is derived from computer, then we will
                        // allow certain modifications to this attribute, based
                        // on the modification value.
                        // NOTE: we don't check the value here.  After the mods
                        // are done, we check the value if we were granted
                        // rights because of this case.
                        if(!fIsDerivedFromComputer) {
                            fError = TRUE;
                        }
                        else {
                            // Yep, we'll allow this modulo a check of the values
                            // written later.
                            if(pfCheckDNSHostNameValue) {
                                *pfCheckDNSHostNameValue = TRUE;
                            }
                        }
                        break;

                    case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
                        Assert(additionalDnsHostNameFound);
                        // No normal rights to this attribute, but extended rights.
                        // If this class is derived from computer, then we will
                        // allow certain modifications to this attribute, based
                        // on the modification value.
                        // NOTE: we don't check the value here.  After the mods
                        // are done, we check the value if we were granted
                        // rights because of this case.
                        if(!fIsDerivedFromComputer) {
                            fError = TRUE;
                        }
                        else {
                            // Yep, we'll allow this modulo a check of the values
                            // written later.
                            if(pfCheckAdditionalDNSHostNameValue) {
                                *pfCheckAdditionalDNSHostNameValue = TRUE;
                            }
                        }
                        break;


                    case ATT_SERVICE_PRINCIPAL_NAME:
                        Assert(servicePrincipalNameFound);
                        // No normal rights to this attribute, but extended rights.
                        // If this class is derived from computer, then we will
                        // allow certain modifications to this attribute, based
                        // on the modification value.
                        // NOTE: we don't check the value here.  After the mods
                        // are done, we check the value if we were granted
                        // rights because of this case.
                        if(!fIsDerivedFromComputer) {
                            fError = TRUE;
                        }
                        else {
                            // Yep, we'll allow this modulo a check of the values
                            // written later.
                            if(pfCheckSPNValues) {
                                *pfCheckSPNValues = TRUE;
                            }
                        }
                        break;

                    default:
                        // No normal rights to this attribute, but extended rights.
                        // But, we don't have special handling for this. This means
                        // no rights.
                        fError = TRUE;
                        break;
                    }

                    if(fError) {
                        SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, DIRERR_INSUFF_ACCESS_RIGHTS);
                        __leave;
                    }
                }
            }
        }
    }
    __finally {
        if (pMergedSD1) {
            DestroyPrivateObjectSecurity(&pMergedSD1);
        }
        if (pMergedSD2) {
            DestroyPrivateObjectSecurity(&pMergedSD2);
        }
        if (pOldSD) THFreeEx(pTHS, pOldSD);
        if (rgpAC) THFreeEx(pTHS, rgpAC);
        if (rgpACExtended) THFreeEx(pTHS, rgpACExtended);
    }

    if (fQuotaError) {
        // permit quota-related errors to be returned
        Assert( ERROR_SUCCESS != pTHS->errCode );
        return pTHS->errCode;
    }
    else if (pTHS->errCode) {
        // we failed to check security, so check for object disclosure for any error
        return CheckObjDisclosure(pTHS, pModifyArg->pResObj, FALSE);
    }
    else {
        return 0;
    }

#undef SEC_INFO_ALL
}/*CheckModifySecurity*/

int
CreateSecurityDescriptorForNewObject (
        THSTATE *pTHS,
        CLASSCACHE *pCC,
        ADDARG *pAddArg,
        PSECURITY_DESCRIPTOR pParentSD,
        ULONG cbParentSD
        )
/*++

Routine Description
   Calculate the merged SD we are going to put on the object based on the
   parents SD (passed in as a parameter) and the SD in the AddArg, or the SD
   which is default for this class if none was specified in the AddArg.  The
   newly created SD is either tacked onto the AddArgs list of entries (if no SD
   was already in the list) or is put into the AddArg in place of an existing SD
   (everything must be THAlloc'ed)

   N.B. if pTHS->fDSA, then the caller MUST provided an SD in the ADDARG.
   N.B. if the object being added is a new NC root, then the pParentSD should be
   passed in as NULL.  This is not enforced, but is expected.

Arguements

    pCC - class cache pointer to the class of the object we are adding.

    pAddArg - AddArg describing the add we're trying to do.

    pParentSD - pointer to the parents SD.  Used to calculate inheritance into
    the SD we write on the object.

    cbParentSD - count of bytes of pParentSD


Return Values

    0 if all went well, a direrr otherwise.

--*/
{
    BOOL        bFoundMemberOnce = FALSE;
    ULONG       count;
    PSECURITY_DESCRIPTOR pSetSD=NULL;
    PSECURITY_DESCRIPTOR pMergedSD=NULL;
    PSECURITY_DESCRIPTOR pTempSD=NULL;
    DWORD       cbSetSD = 0;         //initialized to avoid C4701
    DWORD       cbMergedSD=0;
    DWORD       cbTempSD;
    DWORD       cbUseSD;
    DWORD       rtn;
    ULONG       ulCRNCDNT;
    ULONG       sdIndex = 0;        //initialized to avoid C4701
    ATTRVAL     *newAttrVal=NULL;
    COMMARG     CommArg; // Need this for the FindBestCrossRef() func.
    CROSS_REF * pCR;
    PSID        pDomSid = NULL;
    GUID        *ppGuid[1];

    // The flags we're going to pass to the MergeSecurityDescriptor call
    // We need to set MERGE_AS_DSA if we are DSA or DRA to avoid client
    // impersonation  in MergeSecurityDescriptor
    ULONG       MergeFlags = (MERGE_CREATE |
                              ((pTHS->fDSA || pTHS->fDRA)?MERGE_AS_DSA:0));
    NAMING_CONTEXT_LIST * pNCL = NULL;

    // The SD propagator should never be here.
    Assert(!pTHS->fSDP);

    Assert( DsaIsRunning() || pTHS->fDSA || pTHS->fDRA);

    // Look through the AddArg's entries looking for the Security
    // Descriptor

    for (count=0; count < pAddArg->AttrBlock.attrCount; count++) {

        if(ATT_NT_SECURITY_DESCRIPTOR == pAddArg->AttrBlock.pAttr[count].attrTyp ){
            // Keep track of the last provided SD.  Note that if two SDs are
            // provided, the call will fail later anyway.
            pSetSD = pAddArg->AttrBlock.pAttr[count].AttrVal.pAVal->pVal;
            cbSetSD= pAddArg->AttrBlock.pAttr[count].AttrVal.pAVal->valLen;
            sdIndex = count;
            break;
        }

    }

    if(pTHS->errCode)
        return pTHS->errCode;

    if(!pSetSD && pTHS->fDRA && (pCC->ClassId == CLASS_TOP)) {
        // Replicating in an auto-generated-subref skip further SD
        // processing
        return 0;
    }

    // Create the Security Descriptor for the object based on the Parent SD and
    // (in order of preference) the provided SD, the default SD, or a NULL
    // pointer.

    if(pSetSD) {
        // We have been provided a SD. Set up the replacement pointer to stuff
        // the new SD we are about to create back into the addarg in place of
        // that security descriptor.
        newAttrVal = pAddArg->AttrBlock.pAttr[sdIndex].AttrVal.pAVal;
        if(pTHS->fDSA) {
            // The assumption is that if we are adding this as an in-process
            // client, then the SD provided is nothing more that the default SD
            // plus an owner and a group.  Since that is so, set the MerfeFlags
            // to appropriately reflect this.
            MergeFlags |= MERGE_DEFAULT_SD;
        }

        // If we are fDRA then we are basically replicating in a new object
        // which should have a valid SD at this point. Thus, the SD is not the
        // default SD, so don't set MERGE_DEFAULT_SD.
    }
    else {
        // Use whatever form of default SD we have (might be a NULL pointer and
        // 0 length).

        if(pAddArg->pCreateNC &&
           pAddArg->pCreateNC->iKind != CREATE_NONDOMAIN_NC){
            // Currently the only type of NC head we can add w/o an explicit
            // provided security descriptor is an NDNC.
            Assert(!"Currently we can't add NON NDNC heads unless we have a SD.");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            return(pTHS->errCode);
        }

        if(!pAddArg->pCreateNC &&
           (DsaIsInstalling() ||
            pAddArg->pResParent->NCDNT == gAnchor.ulDNTDomain ||
            pAddArg->pResParent->NCDNT == gAnchor.ulDNTConfig ||
            pAddArg->pResParent->NCDNT == gAnchor.ulDNTDMD) ){
            // This is a shortcut for Domain/Schema/Config NCs, so we
            // don't have to look up the SD Reference Domain SID.
            pDomSid = NULL;
        } else {

            if(pAddArg->pCreateNC){
                // The reference domain may not have been set on the
                // cross-ref yet, so we get the ref dom SID for the
                // default security descriptor creation from the cached
                // create NC info structure.
                pDomSid = &pAddArg->pCreateNC->pSDRefDomCR->pNC->Sid;
                MergeFlags |= MERGE_OWNER;

            } else {

                // We know this object is internal to an NC, and we need the
                // cross-ref of this NC to figure out it's SD Reference SID.
                // However, it turns out that this DN hasn't been validated
                // yet for correctness, so passing in a bad DN will make
                // FindBestCrossRef gives us a NULL, and then we'll AV in
                // GetSDRefDomSid().  However, since we've already done a
                // DoNameRes() on the parent object in DirAddEntry(), we'll
                // FindBestCrossRef() on the parent instead, so we know we'll
                // get a valid CR.

                InitCommarg(&CommArg);
                CommArg.Svccntl.dontUseCopy = FALSE;
                pCR = FindBestCrossRef(pAddArg->pResParent->pObj, &CommArg);
                if(pCR == NULL){
                    SetSvcError(SV_PROBLEM_DIR_ERROR,
                                DIRERR_CANT_FIND_EXPECTED_NC);
                    return(pTHS->errCode);
                }
                // Here we need to know if the Best Cross Ref we got for the
                // object (we got this cross-ref from the in memory cross-ref
                // cache) we're adding, is in fact the cross-ref for the same
                // NC with which this object was resolved to (pResParent->NCDNT).
                ulCRNCDNT = DBGetDntFromDSName(pTHS->pDB, pCR->pNC);
                if (ulCRNCDNT == INVALIDDNT ||
                    ulCRNCDNT != pAddArg->pResParent->NCDNT) {
                    // BUGBUG This is a temporary condition, because the in
                    // memory cross-ref cache is not up to date yet.  We
                    // should fix this someday.
                    SetSvcError(SV_PROBLEM_DIR_ERROR,
                                DIRERR_CANT_FIND_EXPECTED_NC);
                    return(pTHS->errCode);
                }
                pDomSid = GetSDRefDomSid(pCR);
                if(pTHS->errCode){
                    // There was an error in GetSDRefDomSid()
                    return(pTHS->errCode);
                }
                Assert(pDomSid);
            }

            Assert(pDomSid && IsValidSid(pDomSid));
        }

        Assert(pDomSid == NULL ||
               IsValidSid(pDomSid));

        // The pDomSid parameter can be NULL, and then the default domain of
        // the DC will be used for default string SD translation, we'll need
        // to change this in Blackcomb.
        SCGetDefaultSD(pTHS, pCC, pDomSid, fISADDNDNC(pAddArg->pCreateNC),
                       pAddArg->pObject, &pSetSD, &cbSetSD);
        if(pTHS->errCode){
            return(pTHS->errCode);
        }

        Assert(pSetSD);
        Assert(cbSetSD);

        MergeFlags |= MERGE_DEFAULT_SD;

        // No security descriptor was provided to us.  Therefore, we need to
        // tweak the add argument to add the security descriptor we have
        // calculated for the object.

        count = pAddArg->AttrBlock.attrCount;
        pAddArg->AttrBlock.attrCount++;
        pAddArg->AttrBlock.pAttr = THReAllocEx(pTHS,
                                               pAddArg->AttrBlock.pAttr,
                                               (pAddArg->AttrBlock.attrCount *
                                                sizeof(ATTR)));
        newAttrVal = THAllocEx(pTHS, sizeof(ATTRVAL));

        pAddArg->AttrBlock.pAttr[count].AttrVal.valCount = 1;
        pAddArg->AttrBlock.pAttr[count].AttrVal.pAVal = newAttrVal;
        pAddArg->AttrBlock.pAttr[count].attrTyp =
            ATT_NT_SECURITY_DESCRIPTOR;
    }

    ppGuid[0] = &pCC->propGuid;

    // Do the merge.
    if(rtn = MergeSecurityDescriptorAnyClient(
            pTHS,
            pParentSD,
            cbParentSD,
            pSetSD,
            cbSetSD,
            pAddArg->CommArg.Svccntl.SecurityDescriptorFlags,
            MergeFlags,
            ppGuid,
            1,
            pAddArg,
            &pTempSD,
            &cbTempSD)) {
        return SetAttError(pAddArg->pObject, ATT_NT_SECURITY_DESCRIPTOR,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL, rtn);
    }

    // Copy the merged SD into THAlloced memory and free the memory allocated
    // by MergeSecurityDescriptorAnyClient
    pMergedSD = (PSECURITY_DESCRIPTOR)THAllocEx(pTHS, cbTempSD);
    memcpy(pMergedSD,pTempSD,cbTempSD);
    DestroyPrivateObjectSecurity(&pTempSD);
    cbMergedSD=cbTempSD;

    if (!gfDontStandardizeSDs && gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WIN_DOT_NET) {
        DWORD dwSavedDACLSize, dwSavedSACLSize;
        // sort the ACEs in the SD
        if (StandardizeSecurityDescriptor(pMergedSD, &dwSavedDACLSize, &dwSavedSACLSize)) {
            Assert(cbMergedSD - dwSavedDACLSize - dwSavedSACLSize == RtlLengthSecurityDescriptor(pMergedSD));
            // even if we got it wrong and the assert went off, fix it up and continue.
            cbMergedSD = RtlLengthSecurityDescriptor(pMergedSD);
        }
        else {
            // failed to standardize the SD. This is not a big problem
            DPRINT1(0, "Failed to standardize SD, err=%d. The SD might be in a non-canonical form\n",
                    GetLastError());
        }
    }

    // Place the new SD into the addarg
    newAttrVal->pVal = pMergedSD;
    newAttrVal->valLen = cbMergedSD;

    return pTHS->errCode;

}/*CreateSecurityDescriptorForNewObject */

ULONG
CheckUndeleteSecurity(
    THSTATE *pTHS,
    RESOBJ* pResObj)
/*++

Routine Description
    Perform an UNDELETE security check. This is done by checking for
    Reanimate-Tombstones extended right on the NC head.

Arguements

    pTHS - current THSTATE
    pResObj - obj being undeleted

Return Values

    0 if all went well, a direrr otherwise.

--*/
{
    DWORD dwErr;
    CLASSCACHE* pCC;
    PSECURITY_DESCRIPTOR pNTSD;
    ULONG cbNTSD;
    BOOL fSDIsGlobalSDRef;
    DSNAME dnNC;

    if (pTHS->fDSA || pTHS->fDRA) {
        // DSA and DRA are allowed to do anything
        return 0;
    }

    dnNC.NameLen = 0;
    dnNC.structLen = DSNameSizeFromLen(0);

    // read the SD, DN and class cache
    dwErr = DBGetObjectSecurityInfo(
        pTHS->pDB,
        pResObj->NCDNT,
        &cbNTSD, &pNTSD,
        &pCC,
        &dnNC,
        NULL,
        DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE |     // use search table so that we don't disturb currency
            DBGETOBJECTSECURITYINFO_fSEEK_ROW,          // seek the row, as we are not positioned on the correct row
        &fSDIsGlobalSDRef
        );
    if (dwErr) {
        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM, DIRERR_DATABASE_ERROR, dwErr);
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }

    // check the right
    if (!IsControlAccessGranted(pNTSD,
                                &dnNC,
                                pCC,
                                RIGHT_DS_REANIMATE_TOMBSTONES,
                                TRUE))        // fSetError
    {
        Assert(pTHS->errCode);
    }

    if (pNTSD && !fSDIsGlobalSDRef) {
        THFreeEx(pTHS, pNTSD);
    }

    if (pTHS->errCode) {
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }
    else {
        return 0;
    }
}

int
ModifyAuxclassSecurityDescriptor (IN THSTATE *pTHS,
                                  IN DSNAME *pDN,
                                  IN COMMARG *pCommArg,
                                  IN CLASSCACHE *pClassSch,
                                  IN CLASSSTATEINFO *pClassInfo,
                                  IN RESOBJ * pResParent)
/*++

Routine Description
    Modifies the Security Descriptor of an object that has an auxClass attached,
    whenever the auxClass changed.
    As a result new ACLs might become effective on the particular object.
    Unfortunately we have to read the parent SD todo the merging.

Arguements

    pDn - the DN of the object we are modifying

    pCommArg - the COMMARG of the respecting ADDARG/MODIFYARG

    pClassSch - the structural class of the object we are modifying

    pClassInfo - all the info about the classes on this object

    pResParent - possibly the parent related info (used when we cannot use DBPOS)
                 for parent positioning

    pResParent - possibly the parent related info (used when we cannot use DBPOS)
                 for parent positioning

Return Values

    0 if all went well, a direrr otherwise.

--*/
{
    GUID **ppGuid, **ppGuidTemp;
    ULONG GuidCount = 0;
    ULONG i;

    DWORD                cbSD;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL                 fSDIsGlobalSDRef;
    PSECURITY_DESCRIPTOR pNewSD = NULL;
    ULONG                cbNewSD;
    DWORD  err = 0;
    DWORD  dwIT;

    PSECURITY_DESCRIPTOR    pParentSD = NULL;     // SD of parent
    DWORD                   cbParentSD;
    BOOL                    fParentSDIsGlobalSDRef;


    if (pClassInfo == NULL || !pClassInfo->fObjectClassChanged) {
        return 0;
    }

    if (err = GetExistingAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &dwIT, sizeof(dwIT))) {
        // error should be set
        Assert(pTHS->errCode);
        return err;
    }
    if (dwIT & IT_NC_HEAD) {
        // This object is an NC head, so it does not inherit ACEs from the parent.
        return 0;
    }

    GuidCount = 1 + pClassInfo->cNewAuxClasses;

    ppGuidTemp = ppGuid = THAllocEx (pTHS, sizeof (GUID *) * GuidCount);

    *ppGuidTemp++ = &(pClassSch->propGuid);

    for (i=0; i<pClassInfo->cNewAuxClasses; i++) {
        *ppGuidTemp++ = &(pClassInfo->pNewAuxClassesCC[i]->propGuid);
    }

    DPRINT1 (1, "Modifying AuxClass Security Descriptor: %d\n", GuidCount);

    __try {
        // get current object's SD
        err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pTHS->pDB->DNT,
                    &cbSD, &pSD,
                    NULL, NULL, NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                    &fSDIsGlobalSDRef);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_DATABASE_ERROR, err);
            __leave;
        }
        if (cbSD == 0) {
            // No SD? Nothing to remerge! Weird though...
            __leave;
        }

        // Get parent's SD, don't move currency.
        // If pResParent is specified, then use DNT from there, otherwise use PDNT.
        err = DBGetObjectSecurityInfo(
                    pTHS->pDB,
                    pResParent ? pResParent->DNT : pTHS->pDB->PDNT,
                    &cbParentSD, &pParentSD,
                    NULL, NULL, NULL,
                    DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE | DBGETOBJECTSECURITYINFO_fSEEK_ROW,
                    &fParentSDIsGlobalSDRef);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_DATABASE_ERROR, err);
            __leave;
        }
        if (cbParentSD == 0) {
            // no parent SD? Nothing to merge then
            __leave;
        }

        // we will do this merge as if we were the DSA,
        // since if the user was setting the SD in this
        // transaction, in a bad way, this already will
        // have been caught

        // we are interested in only setting the ACL parts

        // do the actual merging
        err = MergeSecurityDescriptorAnyClient(
                    pTHS,
                    pParentSD,
                    cbParentSD,
                    pSD,
                    cbSD,
                    (SACL_SECURITY_INFORMATION  |
                        OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION |
                        DACL_SECURITY_INFORMATION    ),
                    MERGE_CREATE | MERGE_AS_DSA,
                    ppGuid,
                    GuidCount,
                    NULL,
                    &pNewSD,
                    &cbNewSD);

        if (err) {
            err = SetAttError(pDN, ATT_NT_SECURITY_DESCRIPTOR,
                              PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                              NULL, err);
            __leave;
        }

        if (cbNewSD != cbSD || memcmp(pNewSD, pSD, cbSD) != 0) {
            // Something changed. Replace the object's current SD
            ATTRVAL sdVal = { cbNewSD, pNewSD };
            ATTRVALBLOCK sdValBlock = { 1, &sdVal };
            ATTCACHE *pAC = SCGetAttById(pTHS, ATT_NT_SECURITY_DESCRIPTOR);
            Assert(pAC);
            err = DBReplaceAtt_AC(pTHS->pDB, pAC, &sdValBlock, NULL);
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, ERROR_DS_DATABASE_ERROR, err);
                __leave;
            }
        }

    }
    __finally {
        if (pSD && !fSDIsGlobalSDRef) {
            THFreeEx(pTHS, pSD);
        }
        if (pParentSD && !fParentSDIsGlobalSDRef) {
            THFreeEx(pTHS, pParentSD);
        }
        if(pNewSD) {
            DestroyPrivateObjectSecurity(&pNewSD);
        }
        THFreeEx(pTHS, ppGuid);
    }

    return err;
}

VOID
GetFilterSecurityForItem(
        THSTATE *pTHS,
        ATTRTYP aType,
        BOOL **pbSkip,
        INTERIM_FILTER_SEC **ppIF,
        BOOL fABFilter,
        DWORD *pSecSize,
        DWORD *pAllocSize
        )
{
    if (DBIsHiddenData(aType)) {
        // We will ALWAYS deny READ_PROPERTY on these attributes.  If
        // you have to ask, you can't have it.  If any more attributes
        // are deemed to be invisible in the future, they should be
        // added to this case of the switch (note that this only denies
        // access to attributes in the filter of a search, see the
        // routine CheckReadSecurity above to deny access to attributes
        // in selection lists.)
        (*pbSkip) =THAllocEx(pTHS, sizeof(BOOL));
        *(*pbSkip) = TRUE;
        return;
    }

    // Now deal with the
    switch(aType) {
    // We will not optimize (objectClass=*) filter because it has been already
    // turned into FI_CHOICE_TRUE in DBFlattenItemFilter().
    // (objectClass=value) must be checked as a normal attribute.

    case ATT_SHOW_IN_ADDRESS_BOOK:
        if(fABFilter) {
            // Filters doing "Address Book" type filters (i.e. look for
            // all objects with SHOW_IN set to a specific value) should
            // already have checked that the address book should be
            // visible. Therefore, do not apply security to this filter
            // item.
            (*pbSkip) = NULL;
            break;
        }
        // Otherwise, fall through to do normal security.
    default:
        // build the filter security structure for evaluating with
        // specific SDs later.
        if(*pSecSize == *pAllocSize) {
            *pAllocSize = *pAllocSize * 2 + 10;
            *ppIF = THReAllocEx(pTHS,
                                *ppIF,
                                *pAllocSize*sizeof(INTERIM_FILTER_SEC));
        }

        (*ppIF)[*pSecSize].pAC = SCGetAttById(pTHS, aType);
        (*ppIF)[*pSecSize].pBackPointer = pbSkip;
        *pSecSize += 1;
        break;
    }
    return;
}

BOOL
GetFilterSecurityHelp (
        THSTATE *pTHS,
        FILTER *pFilter,
        INTERIM_FILTER_SEC **ppIF,
        BOOL fABFilter,
        DWORD *pSecSize,
        DWORD *pAllocSize
        )
{
    ATTRTYP aType;

    if(!pFilter)
        return TRUE;

    // Walk the filter, building a list of the attributes in the filter and
    // pointer back to the filter element which referenced them.

    switch (pFilter->choice){
        // count number of filters are anded together.  If any are false
        // the AND is false.
    case FILTER_CHOICE_AND:
        for (pFilter = pFilter->FilterTypes.And.pFirstFilter;
             pFilter != NULL;
             pFilter = pFilter->pNextFilter){
            GetFilterSecurityHelp (pTHS,
                                   pFilter,ppIF,
                                   fABFilter,
                                   pSecSize,
                                   pAllocSize );
        }
        break;

        // count number of filters are ORed together.  If any are true
        // the OR is true.
    case FILTER_CHOICE_OR:
        for (pFilter = pFilter->FilterTypes.Or.pFirstFilter;
             pFilter != NULL;
             pFilter = pFilter->pNextFilter){
            GetFilterSecurityHelp (pTHS,
                                   pFilter,ppIF,
                                   fABFilter,
                                   pSecSize,
                                   pAllocSize);
        } /*for*/
            break;

    case FILTER_CHOICE_NOT:
        GetFilterSecurityHelp(pTHS,
                              pFilter->FilterTypes.pNot, ppIF,
                              fABFilter,
                              pSecSize,
                              pAllocSize);
        break;

        // Apply the chosen test to the database attribute on the current
        // object.
    case FILTER_CHOICE_ITEM:

        // First, find the type of the attribute this item filters on.
        switch(pFilter->FilterTypes.Item.choice) {
        case FI_CHOICE_PRESENT:
            aType = pFilter->FilterTypes.Item.FilTypes.present;
            break;

        case FI_CHOICE_SUBSTRING:
            aType = pFilter->FilterTypes.Item.FilTypes.pSubstring->type;
            break;

        default:
            aType = pFilter->FilterTypes.Item.FilTypes.ava.type;
        }

        GetFilterSecurityForItem(
                pTHS,
                aType,
                &pFilter->FilterTypes.Item.FilTypes.pbSkip,
                ppIF,
                fABFilter,
                pSecSize,
                pAllocSize);
        return TRUE;
        break;

    default:
        return FALSE;
        break;
    }  /*switch FILTER*/

    return TRUE;

} /* GetFilterSecurityHelp */
BOOL
GetFilterSecurity (
        THSTATE *pTHS,
        FILTER *pFilter,
        ULONG   SortType,
        ATTRTYP SortAtt,
        BOOL fABFilter,
        POBJECT_TYPE_LIST *ppFilterSecurity,
        BOOL **ppbSortSkip,
        DWORD **ppResults,
        DWORD *pSecSize
        )
{
    ULONG count,i,j;
    ULONG AllocSize = 10;
    INTERIM_FILTER_SEC *pIF;
    INTERIM_FILTER_SEC *pIF2;
    DWORD *pResults;
    DWORD cIF=0;
    POBJECT_TYPE_LIST pObjList;
    GUID *pCurrentPropSet;
    DWORD cPropSets, cProps;
    ATTCACHE *pCurrentAC=NULL;

    *ppFilterSecurity = NULL;
    *ppResults = NULL;
    *pSecSize = 0;

    *pSecSize = 0;
    pIF = THAllocEx(pTHS, 10 * sizeof(INTERIM_FILTER_SEC));

    if(SortType != SORT_NEVER) {
        // Hey, they are going to want us to sort.  Make sure this ends up in
        // the security to check.
        GetFilterSecurityForItem(
                pTHS,
                SortAtt,
                ppbSortSkip,
                &pIF,
                fABFilter,
                &cIF,
                &AllocSize);
    }
    else {
        *ppbSortSkip = NULL;
    }

    if(!GetFilterSecurityHelp(pTHS,
                              pFilter,
                              &pIF,
                              fABFilter,
                              &cIF,
                              &AllocSize))
        return FALSE;


    if(!cIF)                            // Nothing to apply security to.
        return TRUE;

    // We have the list of Interim_Filter_Sec's, with the possibility of dups.
    // Rearrange the list to first group duplicates, then group by propset.

    if(cIF > 2) {
        // two element lists are already grouped.
        cProps = 0;
        cPropSets = 0;
        // First, group all properties together
        for(count=0; count < cIF; count++) {
            cProps++;
            i=count+1;
            while( i < cIF && (pIF[count].pAC == pIF[i].pAC)) {
                count++;
                i++;
            }
            j = i+1;
            while(j<cIF) {
                if(pIF[count].pAC == pIF[j].pAC) {
                    INTERIM_FILTER_SEC IFTemp;
                    // Found one.
                    IFTemp = pIF[i];
                    pIF[i] = pIF[j];
                    pIF[j] = IFTemp;
                    count++;
                    i++;
                }
                j++;
            }
        }

        // Now that they are grouped, sort them into propset order
        pIF2 = THAllocEx(pTHS,cIF * sizeof(INTERIM_FILTER_SEC));
        j=0;
        for(count=0;count<cIF;count++) {
            if(!pIF[count].pAC)
                continue;
            cPropSets++;
            pCurrentPropSet = &pIF[count].pAC->propSetGuid;
            pIF2[j++] = pIF[count];
            pIF[count].pAC = NULL;
            for(i=count+1;i<cIF;i++) {
                if(!pIF[i].pAC)
                    continue;
                if(memcmp(pCurrentPropSet,
                          &pIF[i].pAC->propSetGuid,
                          sizeof(GUID)) == 0) {
                    // Yes, this is the propset we're sifting for.
                    pIF2[j++] = pIF[i];
                    pIF[i].pAC = NULL;
                }
            }
        }
        memcpy(pIF,pIF2,cIF * sizeof(INTERIM_FILTER_SEC));
        THFreeEx(pTHS,pIF2);
    }
    else {
        // maximal numbers
        cPropSets = cIF;
        cProps = cIF;
    }


    // pIF holds an array of INTERIM_FILTER_SECs, grouped by propset and then
    // grouped by property.



    // Now, create an obj list used later for a security check.
    pObjList = THAllocEx(pTHS, (cPropSets + cProps + 1) * sizeof(OBJECT_TYPE_LIST));
    pResults = THAllocEx(pTHS, (cPropSets + cProps + 1) * sizeof(DWORD));

    // pObjList[0] will be filled in later with a class guid.
    pObjList[0].Level = ACCESS_OBJECT_GUID;
    pObjList[0].Sbz = 0;
    pObjList[0].ObjectType = NULL;

    // Ok, put the grouped GUIDS into the objlist structure.
    pObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
    pObjList[1].Sbz = 0;
    pObjList[1].ObjectType = &pIF[0].pAC->propSetGuid;
    pCurrentPropSet = &pIF[0].pAC->propSetGuid;

    for(j=1,i=0;i<cIF;i++) {
        if(pIF[i].pAC != pCurrentAC) {
            // This entry does not refer to the same attribute as the last
            // entry.  We need to add a new entry into the obj list to
            // correspond to this new attribute

            // First, keep track of this new attribute
            pCurrentAC = pIF[i].pAC;

            // Inc the increment in the objlist.  This variable tracks the last
            // filled in element in the objlist.
            j++;
            // J is now the index of the element in the objlist to fill in.

            if(memcmp(&(pCurrentAC->propSetGuid),
                      pCurrentPropSet,
                      sizeof(GUID))) {
                // Hey, we tripped into a new propset.  We need an entry in the
                // objlist for this new prop set.
                pObjList[j].Level = ACCESS_PROPERTY_SET_GUID;
                pObjList[j].Sbz = 0;
                pObjList[j].ObjectType = &pCurrentAC->propSetGuid;
                pCurrentPropSet = &pCurrentAC->propSetGuid;

                // Inc again, since we still need to put an entry for the
                // attribute into the objlist.
                j++;
            }

            // Fill in the entry for the attribute.
            pObjList[j].Level = ACCESS_PROPERTY_GUID;
            pObjList[j].Sbz = 0;
            pObjList[j].ObjectType = &pCurrentAC->propGuid;
        }

        // OK, if this entry in the pIF is a new attribute, we've added the
        // information from that new attribute to the objlist.  If it wasn't a
        // new attribute, we didn't do anything.  In either case, j is the index
        // of the last object filled in, and we need to set the backpointer up.

        // For the curious: pIF[i].pBackPointer points to the pbSkip field of
        // some item filter element.  When we go to evaluate security later, we
        // use the objlist we've built here in a call to the security
        // functions.  Furthermore, we use pResults as the place for the
        // security function to put the results of the security check.  So, we
        // set the pbSkip pointer in the item filter to point to the appropriate
        // element in the pResults array.  When we evaluate the filter, we check
        // pResults[x] via pbSkip, and if non-zero (i.e. failed the security
        // check for reading), we evaluate the filter as if that item had no
        // value in the database.
        *(pIF[i].pBackPointer) = &pResults[j];
    }

    *ppResults = pResults;
    *ppFilterSecurity = pObjList;
    // j is an index (0 based).  Remember to add in one extra to get the count
    *pSecSize = j + 1;

    THFreeEx(pTHS, pIF);
    return TRUE;
}/* GetFilterSecurity */



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int GetObjSchema(DBPOS *pDB, CLASSCACHE **ppClassSch){

   ATTRTYP ObjClass;
   DWORD err = 0;

   // Object class
   if((err=DBGetSingleValue(pDB, ATT_OBJECT_CLASS, &ObjClass,
                       sizeof(ObjClass), NULL)) ||
      !(*ppClassSch = SCGetClassById(pDB->pTHS, ObjClass))) {

      DPRINT(2, "Couldn't find Object class \n");

      return SetUpdErrorEx(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                           DIRERR_OBJ_CLASS_NOT_DEFINED, err);
   }

   return 0;

}/*GetObjSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int GetObjRdnType(DBPOS *pDB, CLASSCACHE *pCC, ATTRTYP *pRdnType){

    // rdnType
    // If no rdnType is present then use the rdnattid from the class
    // defn. If the class doesn't have an rdnattid, return ATT_COMMON_NAME.
    if(DBGetSingleValue(pDB, FIXED_ATT_RDN_TYPE, pRdnType,
                        sizeof(*pRdnType), NULL)) {
        if (pCC->RDNAttIdPresent) {
            *pRdnType = pCC->RdnIntId;
        } else {
            *pRdnType = ATT_COMMON_NAME;
        }
    }

    return 0;

}/*GetObjRdnType*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int
CallerIsTrusted(
    IN THSTATE *pTHS
     )
/*++
Routine Description
    The caller is trusted if the caller is
        replicating
        AD
        promoting
        upgrading
        running as mkdit

Paramters
    pTHS - thread struct, obviously

Return
    0 caller is not trusted
    1 caller is trusted
--*/
{
    extern BOOL gfRunningAsMkdit;

    // The caller is trusted if the caller is
    //    replicating
    //    AD (calling itself)
    //    promoting
    //    upgrading
    //    running as mkdit

    if (   pTHS->fDRA
        || pTHS->fDSA
        || DsaIsInstalling()
        || gAnchor.fSchemaUpgradeInProgress
        || gfRunningAsMkdit) {
        return 1;
    }
    return 0;
}/*CallerIsTrusted*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int ValidateAuxClass (THSTATE *pTHS,
                      DSNAME *pDN,
                      CLASSCACHE *pClassSch,
                      CLASSSTATEINFO  *pClassInfo)
{
    CLASSCACHE      *pCC;
    DWORD           objClassCount, baseIdx;
    DWORD           err;
    DWORD           cCombinedObjClass;
    ATTRTYP         *pCombinedObjClass;

    if (pClassInfo->cNewAuxClasses == 0) {
        return 0;
    }

    // if one of the auxClasses is a class that is already on the
    // object's hierarchy, this is an error
    for (objClassCount=0; objClassCount < pClassInfo->cNewAuxClasses; objClassCount++) {
        if (pClassInfo->pNewAuxClasses[objClassCount] == pClassSch->ClassId) {
            DPRINT1 (0, "AuxClass containes a class (0x%x) already on the object hierarchy\n", pClassInfo->pNewAuxClasses[objClassCount]);

            return SetAttError(pDN, ATT_OBJECT_CLASS,
                               PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                               ERROR_DS_ATT_VAL_ALREADY_EXISTS);
        }
        for (baseIdx=0; baseIdx < pClassSch->SubClassCount; baseIdx++) {
            if (pClassInfo->pNewAuxClasses[objClassCount] == pClassSch->pSubClassOf[baseIdx]) {
                DPRINT1 (0, "AuxClass containes a class (0x%x) already on the object hierarchy\n", pClassInfo->pNewAuxClasses[objClassCount]);

                return SetAttError(pDN, ATT_OBJECT_CLASS,
                                   PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                                   ERROR_DS_ATT_VAL_ALREADY_EXISTS);
            }
        }
    }

    // all the superclasses of the new auxClasses
    // should exist in the combined objectClass hierarchy

    objClassCount = pClassInfo->cNewAuxClasses + 1 + pClassSch->SubClassCount;
    pCombinedObjClass = THAllocEx (pTHS, sizeof (ATTRTYP) * objClassCount);

    pCombinedObjClass[0] = pClassSch->ClassId;
    cCombinedObjClass = 1;

    for (objClassCount=0; objClassCount<pClassSch->SubClassCount; objClassCount++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassSch->pSubClassOf[objClassCount];
    }

    for (objClassCount=0; objClassCount < pClassInfo->cNewAuxClasses; objClassCount++) {
        pCombinedObjClass[cCombinedObjClass++] = pClassInfo->pNewAuxClasses[objClassCount];
    }

    qsort(pCombinedObjClass,
          cCombinedObjClass,
          sizeof(ATTRTYP),
          CompareAttrtyp);


    for (objClassCount=0; objClassCount < pClassInfo->cNewAuxClasses; objClassCount++) {

        for (baseIdx=0; baseIdx < pClassInfo->pNewAuxClassesCC[objClassCount]->SubClassCount; baseIdx++) {

            if (!bsearch(&pClassInfo->pNewAuxClassesCC[objClassCount]->pSubClassOf[baseIdx],
                         pCombinedObjClass,
                         cCombinedObjClass,
                         sizeof(ATTRTYP),
                         CompareAttrtyp)) {

                DPRINT1 (0, "AuxClass hierarchy containes a class (0x%x) that is not on the object hierarchy\n",
                         pClassInfo->pNewAuxClassesCC[objClassCount]->pSubClassOf[baseIdx]);

                SetAttError(pDN, ATT_OBJECT_CLASS,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                                   ERROR_DS_ILLEGAL_MOD_OPERATION);

                THFreeEx (pTHS, pCombinedObjClass);

                return pTHS->errCode;
            }
        }
    }

    THFreeEx (pTHS, pCombinedObjClass);

    return pTHS->errCode;
}

int ValidateObjClass(THSTATE *pTHS,
                     CLASSCACHE *pClassSch,
                     DSNAME *pDN,
                     ULONG cModAtts,
                     ATTRTYP *pModAtts,
                     CLASSSTATEINFO  **ppClassInfo,
                     BOOL fIsUndelete)
{
    ULONG   count, auxClsCount;
    ATTRTYP *pMust;
    ATTR    *pAttr;
    ULONG   i;
    BOOL    CheckMust = FALSE, CheckMay = FALSE;
    ULONG   err;
    CLASSCACHE *pCC;
    CLASSSTATEINFO  *pClassInfo = NULL;

    Assert (ppClassInfo);

    if (pTHS->fDRA ||
        (pTHS->fSAM && pTHS->fDSA)){
        // Replication is allowed to perform modifications that violate the
        // schema, OR if it's SAM calling us and he's swearing that he's
        // only modifying SAM owned attributes, we'll trust him.
        return 0;
    }

    // this means that we changed the objectClass/auxClass
    if ( (pClassInfo = *ppClassInfo) != NULL) {

        if (ValidateAuxClass (pTHS, pDN, pClassSch, pClassInfo)) {
            return pTHS->errCode;
        }

        // since we changed objectClass or auxClass
        // we have todo a full validation

        CheckMay = TRUE;
        CheckMust = TRUE;

        goto mustMayChecks;
    }
    // we haven't changed objectClass. have to see whether we have an auxClass
    // on the object
    else  {
        pClassInfo = ClassStateInfoCreate(pTHS);
        if (!pClassInfo) {
            return pTHS->errCode;
        }
        if (ppClassInfo) {
            *ppClassInfo = pClassInfo;
        }

        if (ReadClassInfoAttribute (pTHS->pDB,
                                    pClassInfo->pObjClassAC,
                                    &pClassInfo->pNewObjClasses,
                                    &pClassInfo->cNewObjClasses_alloced,
                                    &pClassInfo->cNewObjClasses,
                                    NULL) ) {
            return pTHS->errCode;
        }

        BreakObjectClassesToAuxClassesFast (pTHS, pClassSch, pClassInfo);

        if (ValidateAuxClass (pTHS, pDN, pClassSch, pClassInfo)) {
            return pTHS->errCode;
        }

    }

    // We should have a ClassInfo if we got here
    Assert(pClassInfo != NULL);

    if (fIsUndelete) {
        // reanimation case: check both mays and musts
        CheckMay = CheckMust = TRUE;
        goto mustMayChecks;
    }

    /* For each attribute touched during this modification, check
     * to see if it was a may-have (good), must-have (bad), or neither
     * (really bad).  The theory is that assuming that the object was
     * in compliance when we started, and we've only touched legal
     * may-have attributes, we could not have brought the object out
     * of compliance.
     */
    for (i=0; i<cModAtts; i++) {
        if (IsMember(pModAtts[i],
                     pClassSch->MustCount,
                     pClassSch->pMustAtts)) {
            /* The attribute touched was a must-have.  That means that
             * we need to do a full check to make sure that all the must-
             * haves are present on the current version of the object.
             */
            CheckMust = TRUE;
        }
        else if (IsAuxMember (pClassInfo, pModAtts[i], TRUE, FALSE)) {

            // so we touched a must have from an auxClass
            // we need a fullCheck

            CheckMust = TRUE;
        }
        else {
            if ( (!IsMember(pModAtts[i],
                            pClassSch->MayCount,
                            pClassSch->pMayAtts) ) &&
                 (!IsAuxMember (pClassInfo, pModAtts[i], FALSE, TRUE)) ) {

                /* This attribute was neither a may-have nor a must-have.
                 * Odds are that this is going to end up as an error, but
                 * it could be some weird case where the attribute used to
                 * be legal an is no longer and is being removed.  Anyway,
                 * we're not trying to optimize the error path, but the
                 * normal success path.  Flag this for a full check of all
                 * attributes, which will also set the appropriate error.
                 */
                CheckMay = TRUE;
            }
            else {
                /* This is the case we actually like, which is that the
                 * attribute being modified was a may-have.  If all of
                 * the attributes are in this category, we can get off
                 * easy and just return success.
                 */
            }
        }
    }

mustMayChecks:

    if (CheckMust) {
        /* Check that all required attributes with their values are on the obj*/

        pMust = pClassSch->pMustAtts;

        for (count = 0 ; count < pClassSch->MustCount; count++){
            if(!DBHasValues(pTHS->pDB, *(pMust + count))) {

                DPRINT1(1, "Missing Required Att. <%lu>\n", *(pMust + count));

                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   ERROR_DS_MISSING_REQUIRED_ATT);
            }
        }/*for*/


        // now check for mustHaves from the auxClasses on this object
        if (pClassInfo->cNewAuxClasses) {
            for (auxClsCount = 0 ; auxClsCount < pClassInfo->cNewAuxClasses; auxClsCount++){

                pCC = pClassInfo->pNewAuxClassesCC[auxClsCount];
                Assert (pCC);

                pMust = pCC->pMustAtts;
                for (count = 0 ; count < pCC->MustCount; count++) {

                    if(!DBHasValues(pTHS->pDB, *(pMust + count))) {
                        DPRINT2(1, "Missing Required Att. <0x%x> from AuxClass\n", *(pMust + count), pCC->ClassId);

                        return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                           ERROR_DS_MISSING_REQUIRED_ATT);
                    }
                }
            }
        }
    }

    if (CheckMay) {
        /*Make sure that all atts on the object are defined for the class*/

        DBGetMultipleAtts(pTHS->pDB,
                          0,
                          NULL,
                          NULL,
                          NULL,
                          &count,
                          &pAttr,
                          0,
                          0);

        for(i=0;i<count;i++) {
            if (!IsMember(pAttr[i].attrTyp, pClassSch->MustCount,
                          pClassSch->pMustAtts)  &&
                !IsMember(pAttr[i].attrTyp, pClassSch->MayCount,
                          pClassSch->pMayAtts)   &&
                !IsAuxMember (pClassInfo, pAttr[i].attrTyp, TRUE, TRUE) ){
                    DPRINT2 (1, "Attr 0x%x is not a member of class 0x%x\n",
                            pAttr[i].attrTyp, pClassSch->ClassId);

                return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                                   ERROR_DS_ATT_NOT_DEF_FOR_CLASS);
            }
        }
    }

    return 0;
}/*ValidateObjClass*/


HVERIFY_ATTS
VerifyAttsBegin(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pObj,
    IN  ULONG       dntOfNCRoot,
    IN  ADDCROSSREFINFO * pCRInfo
    )
/*++

Routine Description:

    Create a verify atts handle to be passed to future calls to AddAttVals,
    ReplaceAttVals, etc.

    Caller *MUST* free the handle with VerifyAttsEnd() when done, even under
    exceptional circumstances.

Arguments:

    pTHS (IN)

    pObj (IN) - DSNAME of the object being added/modified.

    dntOfNCRoot (IN) - The DNT of the root of this NC, or INVALIDDNT if this
        operation is creating (not modifiying) the NC root.

Return Values:

    HVERIFY_ATTS handle.  Throws memory exceptions.

--*/
{
    HVERIFY_ATTS hVerifyAtts;

    hVerifyAtts = THAllocEx(pTHS, sizeof(*hVerifyAtts));
    hVerifyAtts->pObj = pObj;
    hVerifyAtts->NCDNT = dntOfNCRoot;
    hVerifyAtts->pCRInfo = pCRInfo;

    return hVerifyAtts;
}

void
VerifyAttsEnd(
    IN      THSTATE *       pTHS,
    IN OUT  HVERIFY_ATTS *  phVerifyAtts
    )
/*++

Routine Description:

    Closes a verify atts handle created by a previous call to VerifyAttsBegin().

Arguments:

    pTHS (IN)

    phVerifyAtts (IN/OUT) - Ptr to previously allocated handle.  Set to NULL on
        return.

Return Values:

    None.

--*/
{
    Assert(NULL != *phVerifyAtts);

    if (NULL != (*phVerifyAtts)->pDBTmp_DontAccessDirectly) {
        // This DBPOS doesn't have its own transaction, so fCommit = TRUE is
        // ignored.
        DBClose((*phVerifyAtts)->pDBTmp_DontAccessDirectly, TRUE);
    }

    THFreeEx(pTHS, *phVerifyAtts);
    *phVerifyAtts = NULL;
}

int
VerifyAttsGetObjCR(
    IN OUT  HVERIFY_ATTS    hVerifyAtts,
    OUT     CROSS_REF **    ppObjCR
    )
/*++

Routine Description:

    Derives and caches the cross-ref corresponding to the object.

Arguments:

    hVerifyAtts (IN/OUT) - Ptr to previously allocated handle.  On return
        references the derived cross-ref.

    ppObjCR (OUT) - On return, holds a ptr to the cross-ref corresponding to
        the object's NC.

Return Values:

    pTHS->errCode

--*/
{
    NAMING_CONTEXT_LIST *pNCL;
    CROSS_REF *pCR;

    if (NULL != hVerifyAtts->pObjCR_DontAccessDirectly) {
        // Already cached -- success!
        *ppObjCR = hVerifyAtts->pObjCR_DontAccessDirectly;
        return 0;
    }

    *ppObjCR = NULL;

    // Cache a ptr to the cross ref for the NC containing the object we're
    // adding/modifying.
    if (INVALIDDNT != hVerifyAtts->NCDNT) {
        // We're modifying an NC root or adding/modifying an interior node.
        if ((NULL == (pNCL = FindNCLFromNCDNT(hVerifyAtts->NCDNT, TRUE)))
            || (NULL == (pCR = FindExactCrossRef(pNCL->pNC, NULL)))) {
            LooseAssert(!"Modifying existing object in unknown NC?", GlobalKnowledgeCommitDelay);
            return SetNamError(NA_PROBLEM_NO_OBJECT,
                               NULL,
                               DIRERR_OBJ_NOT_FOUND);
        }
    } else {
        // We're performing an add of the root of this NC and thus have not
        // yet allocated a DNT for it.
        if (NULL == (pCR = FindExactCrossRef(hVerifyAtts->pObj, NULL))) {
            Assert(!"No crossRef in gAnchor for NC being created?");
            return SetNamError(NA_PROBLEM_NO_OBJECT,
                               NULL,
                               DIRERR_OBJ_NOT_FOUND);
        }
    }

    *ppObjCR = hVerifyAtts->pObjCR_DontAccessDirectly = pCR;

    // Success!
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add the attribute and its values to the object. */

int
AddAtt(
    THSTATE *       pTHS,
    HVERIFY_ATTS    hVerifyAtts,
    ATTCACHE *      pAttSchema,
    ATTRVALBLOCK *  pAttrVal
    )
{
    // The reason this is not done in the originating write case is that this
    // call enforces that the attributes does not already have values. We want
    // to permit on an originating write the scenario where the same attribute
    // appears multiple times in the input change list, each time adding additional
    // values.  However, for the replicator this call is essential since it
    // assures that the attribute's metadata is marked as changed.
    if (pTHS->fDRA) {
        /* Add the attribute type*/
        if (AddAttType(pTHS, hVerifyAtts->pObj, pAttSchema)) {
            return pTHS->errCode;
        }
    }

    /* Add att values */
    return AddAttVals(pTHS,
                      hVerifyAtts,
                      pAttSchema,
                      pAttrVal,
                      AAV_fCHECKCONSTRAINTS | AAV_fENFORCESINGLEVALUE);
}/*AddAtt*/

int
ReplaceAtt(
    THSTATE *       pTHS,
    HVERIFY_ATTS    hVerifyAtts,
    ATTCACHE *      pAttSchema,
    ATTRVALBLOCK *  pAttrVal,
    BOOL            fCheckAttValConstraint
    )
/*++
  Description:
      Replace all the values of an attribute with the values passed in.

  Parameters:
     pTHS - THSTATE for this thread.
     hVerifyAtts - verify atts handle returned by prior call to
         VerifyAttsBegin().
     pAttSchema - schema cache entry for attribute to be modified.
     pAttrVal - new values to put on the object.
     fCheckAttValConstraint - flag describing whether we should check
         constraints or not.

  Return value.
      0 if all went well.
      Non-zero error type if something went wrong.  If this is the case, a full
          error structure in the THSTATE is filled out, including the win32
          error code.
--*/
{
    DWORD    vCount;
    DWORD     err;
    ATTRVAL  *pAVal;

    if(pAttSchema->isSingleValued && (pAttrVal->valCount > 1)) {
        // The attribute we wish to replace values on is single valued and the
        // caller gave us more than one value. So we have too many values.

        return SetAttError(hVerifyAtts->pObj, pAttSchema->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                           DIRERR_SINGLE_VALUE_CONSTRAINT);
    }


    // Check constraints only if we were asked to and we're not
    // a replication thread. In free builds fDSA overrides
    // constraint checks for performance. Checked builds still
    // do checks to catch problems

#if DBG
    if ( fCheckAttValConstraint &&  !pTHS->fDRA ) {
#else
    if ( fCheckAttValConstraint && !(pTHS->fDRA || pTHS->fDSA)) {
#endif

        pAVal = pAttrVal->pAVal;
        for(vCount = 0; vCount < pAttrVal->valCount; vCount++){
            // Check constraints only if we were asked to and we're not
            // a replication thread. In free builds fDRA overrides
            // constraint checks for performance. Checked builds still
            // do checks to catch problems
            err = CheckConstraint( pAttSchema, pAVal );

            if ( 0 != err ){

                // Continue processing if the attribute error was sucessful

                SAFE_ATT_ERROR_EX(hVerifyAtts->pObj, pAttSchema->id,
                                  PR_PROBLEM_CONSTRAINT_ATT_TYPE, pAVal,
                                  err, 0);
            }

            pAVal++;
        }
    }

    if(pTHS->errCode) {
        return pTHS->errCode;
    }

    if(err = VerifyDsnameAtts(pTHS, hVerifyAtts, pAttSchema, pAttrVal)) {
        // VerifyDsnameAtts should set an error in the THSTATE if an error
        // occurred.
        Assert(pTHS->errCode);
        return err;
    }
    // OK, the view of the attribute they want is legal.

    err = DBReplaceAtt_AC(pTHS->pDB, pAttSchema, pAttrVal,NULL);

    switch(err) {
    case 0:
        // nothing to do.
        break;
    case DB_ERR_VALUE_EXISTS:
        // constraint violation,
        SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                       PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                       ERROR_DS_ATT_VAL_ALREADY_EXISTS);
        break;
    default:
        SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);
        break;
    }

    return err;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add the attribute and its values to the object. */

int
AddAttType (
        THSTATE *pTHS,
        DSNAME *pObject,
        ATTCACHE *pAttSchema
        )
{
    DWORD rtn;
    ULONG tempSyntax;    /*Temp variable used to hold att syntax*/

    /* Add the attribute type*/

    rtn = DBAddAtt_AC(pTHS->pDB, pAttSchema, (UCHAR)pAttSchema->syntax);
    switch(rtn) {

    case 0:
        return 0;

    case DB_ERR_ATTRIBUTE_EXISTS:
        return SetAttError(pObject, pAttSchema->id,
                           PR_PROBLEM_ATT_OR_VALUE_EXISTS, NULL,
                           DIRERR_ATT_ALREADY_EXISTS);

    case DB_ERR_BAD_SYNTAX:
        tempSyntax = (ULONG) (pAttSchema->syntax);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_BAD_ATT_SCHEMA_SYNTAX,
                 szInsertUL(tempSyntax),
                 szInsertUL(pAttSchema->id),
                 NULL);

        return SetAttError(pObject, pAttSchema->id,
                           PR_PROBLEM_INVALID_ATT_SYNTAX, NULL,
                           DIRERR_BAD_ATT_SCHEMA_SYNTAX);

    default:
        return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, rtn);

    } /*select*/


}/*AddAttType*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add attribute values to the object.  Check the various value
   constraints (single-valued and range limits), if a value fails continue
   processing to validate all values.
*/

int
AddAttVals(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAttSchema,
    ATTRVALBLOCK *pAttrVal,
    DWORD dwFlags
    )
{
    ATTRVAL *pAVal;
    UCHAR outSyntax;
    ULONG vCount;
    int returnVal;
    unsigned err;
    BOOL fCheckConstraints = !!(dwFlags & AAV_fCHECKCONSTRAINTS);
    BOOL fEnforceSingleValue = !!(dwFlags & AAV_fENFORCESINGLEVALUE);
    BOOL fPermissive = !!(dwFlags & AAV_fPERMISSIVE);

   /* Single-Value constraint check.  if fEnfoceSingleVale == FALSE, we are
      doing a modify call, which is allowed to violate single valuedness during
      the call, but must end up with a legal object. */

    if (fEnforceSingleValue                      &&
        pAttSchema->isSingleValued               &&
        ((pAttrVal->valCount > 1)      ||
         (DBHasValues_AC(pTHS->pDB,
                         pAttSchema)   &&
          pAttrVal->valCount          )   )      ) {
        // We are supposed to enforce single valuedness
        //            AND
        // the attribute is single valued
        //            AND
        // (
        //   Either we are simply adding multiple values
        //        OR
        //   The object has values AND we are adding new values.
        // )
        // So we have too many values.

        return SetAttError(hVerifyAtts->pObj, pAttSchema->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                           DIRERR_SINGLE_VALUE_CONSTRAINT);
    }

    if (returnVal = VerifyDsnameAtts(pTHS, hVerifyAtts, pAttSchema, pAttrVal)) {
        return returnVal;
    }

    /* Add the attribute values for this attribute.  */

    pAVal = pAttrVal->pAVal;

    for(vCount = 0; vCount < pAttrVal->valCount; vCount++){

        // Check constraints only if we were asked to and we're not
        // a replication thread. In free builds fDRA overrides
        // constraint checks for performance. Checked builds still
        // do checks to catch problems

#if DBG
        if ( !fCheckConstraints || pTHS->fDRA ) {
#else
        if ( !fCheckConstraints || pTHS->fDRA || pTHS->fDSA) {
#endif
            err = 0;
        }
        else {
            err = CheckConstraint( pAttSchema, pAVal );
        }

        if ( 0 != err ){

            /* Continue processing if the attribute error was sucessful*/

            SAFE_ATT_ERROR_EX(hVerifyAtts->pObj, pAttSchema->id,
                              PR_PROBLEM_CONSTRAINT_ATT_TYPE, pAVal,
                              err, 0);
        }
        else {
            err = DBAddAttVal_AC(pTHS->pDB, pAttSchema,
                                 pAVal->valLen, pAVal->pVal);
            switch(err) {
            case 0:
                break;

            case DB_ERR_VALUE_EXISTS:
                /* Continue processing if the attribute error was sucessful*/

                if (!fPermissive) {
                    SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                                   PR_PROBLEM_ATT_OR_VALUE_EXISTS, pAVal,
                                   DIRERR_ATT_VAL_ALREADY_EXISTS);
                }
                break;

            case DB_ERR_SYNTAX_CONVERSION_FAILED:
                SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                               PR_PROBLEM_INVALID_ATT_SYNTAX, pAVal,
                               DIRERR_BAD_ATT_SYNTAX);
                break;

            case DB_ERR_NOT_ON_BACKLINK:
                SAFE_ATT_ERROR(hVerifyAtts->pObj, pAttSchema->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, pAVal,
                               DIRERR_NOT_ON_BACKLINK);
                break;

            default:
                return SetSvcErrorEx(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR, err);

            } /*switch*/
        }

        pAVal++;

    }/*for*/

    return pTHS->errCode;

}/*AddAttVals*/

BOOL
DsCheckConstraint(
    IN ATTRTYP  attID,
    IN ATTRVAL *pAttVal,
    IN BOOL     fVerifyAsRDN
        )
/*++
  NOTE NOTE NOTE:
      This routine is exported.  Don't mess with it.

  Description:
      This routine checks the attribute and value passed in for schema
      constraints, and for the extra constraints applied to RDNs if necessary.
      It is intended to be called by out of core DS clients (i.e. SAM) to verify
      an attribute before trying to use it.  We expect a valid THSTATE to be
      accessible.

  Parameters
      attID   - internal attribute ID of the attribute being checked
      pAttVal - the specific value being checked
      fVerifyAsRDN - Do we need to check the extra things we require of RDN
              attributes.

  Return Values:
      Returns TRUE if we can verify that the attribute value assertion passed in
      does not violate any known constraints.  Returns FALSE if we can not
      verify this for any reason (e.g. no THSTATE will result in a FALSE
      return).

--*/
{
    THSTATE *pTHS=pTHStls;
    ATTCACHE *pAC;
    Assert(pTHS);
    if(!pTHS) {
        return FALSE;
    }

    pAC = SCGetAttById(pTHS, attID);
    Assert(pAC);
    if(!pAC) {
        return FALSE;
    }

    if(CheckConstraint(pAC, pAttVal)) {
        return FALSE;
    }

    if(fVerifyAsRDN) {
        // They want to know if this would be valid as an RDN
        if(pAC->syntax != SYNTAX_UNICODE_TYPE) {
            // Only UNICODE atts are RDNs
            return FALSE;
        }

        if((pAttVal->valLen/sizeof(WCHAR)) > MAX_RDN_SIZE) {
            // Too long for any RDN
            return FALSE;
        }

        if(fVerifyRDN((WCHAR *)pAttVal->pVal,
                      pAttVal->valLen / sizeof(WCHAR))) {
            // Characters are invalid.
            return FALSE;
        }
    }

    return TRUE;
}


/*++

Routine Description
   Check that an attribute conforms to any schema range constraints and that
   any given security descriptors are valid.

Arguements

    pAttSchema - pointer to the schema cache of the attribute we are adding
       values for.

   pAttVal - pointer to the value we are adding.

Return Values

    0 if all went well, a WIN32 error code otherwise.

--*/
unsigned
CheckConstraint (
        ATTCACHE *pAttSchema,
        ATTRVAL *pAttVal
        )
{
    unsigned err=0;
    SYNTAX_ADDRESS *pAddr;
    ULONG cBlobSize, cNoOfChar;

    switch (pAttSchema->syntax){
    case SYNTAX_INTEGER_TYPE:
        if ( pAttVal->valLen != sizeof(LONG)
            || (    pAttSchema->rangeLowerPresent
                && ((SYNTAX_INTEGER) pAttSchema->rangeLower)
                             > *(SYNTAX_INTEGER *)(pAttVal->pVal))
            || (   pAttSchema->rangeUpperPresent
                && ((SYNTAX_INTEGER) pAttSchema->rangeUpper)
                         < *(SYNTAX_INTEGER *)(pAttVal->pVal))){

            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;
    case SYNTAX_OBJECT_ID_TYPE:
        if ( pAttVal->valLen != sizeof(LONG)
            || (    pAttSchema->rangeLowerPresent
                && pAttSchema->rangeLower > *(ULONG *)(pAttVal->pVal))
            || (    pAttSchema->rangeUpperPresent
                && pAttSchema->rangeUpper < *(ULONG *)(pAttVal->pVal))){

            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;
    case SYNTAX_TIME_TYPE:
        if ( pAttVal->valLen != sizeof(DSTIME)
            || (    pAttSchema->rangeLowerPresent
                && (DSTIME)pAttSchema->rangeLower > *(DSTIME *)(pAttVal->pVal))
            || (    pAttSchema->rangeUpperPresent
                && (DSTIME)pAttSchema->rangeUpper < *(DSTIME *)(pAttVal->pVal))){

            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;

    case SYNTAX_I8_TYPE:
        if ( pAttVal->valLen != sizeof(LARGE_INTEGER)
            || (    pAttSchema->rangeLowerPresent
                && (LONGLONG)pAttSchema->rangeLower > ((LARGE_INTEGER *)pAttVal->pVal)->QuadPart)
            || (    pAttSchema->rangeUpperPresent
                && (LONGLONG)pAttSchema->rangeUpper < ((LARGE_INTEGER *)pAttVal->pVal)->QuadPart)){

            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;


    case SYNTAX_BOOLEAN_TYPE:
        // range checking does not make sense for BOOLEAN, since
        // there is no obvious external mapping between bool and dword
        // values. For example, true can be treated as either 1 or -1.
        // At the same time, we will enforce that the caller supplies
        // a valid value (0 or 1). LDAP head already makes sure that
        // only "true" or "false" are allowed and converts them
        // appropriately.
        if ( pAttVal->valLen != sizeof(BOOL)
            || ((*(BOOL *)(pAttVal->pVal) != 1) &&
                (*(BOOL *)(pAttVal->pVal) != 0))){
            err = ERROR_DS_RANGE_CONSTRAINT;
        }
        break;

    case SYNTAX_UNICODE_TYPE:
        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > (pAttVal->valLen / sizeof(WCHAR))
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < (pAttVal->valLen / sizeof(WCHAR))) {
            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        break;


    case SYNTAX_OCTET_STRING_TYPE:
    case SYNTAX_SID_TYPE:

        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > pAttVal->valLen
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < pAttVal->valLen) {

            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        break;

    case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:

        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > pAttVal->valLen
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < pAttVal->valLen) {

            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        // The SD must be in a self-relative format. We don't require that owner and
        // group are necessarily present. They will be merged in from the old SD or
        // default SD.
        if(!RtlValidRelativeSecurityDescriptor(pAttVal->pVal, pAttVal->valLen, 0)) {
            DPRINT(1, "Unusable security descriptor.\n");
            err = ERROR_DS_SEC_DESC_INVALID;
        }

        break;

    case SYNTAX_DISTNAME_TYPE:

        // range checking doesn't make sense
        break;

    case SYNTAX_DISTNAME_BINARY_TYPE:

        // This can be DNBinary or OR-Name
        // Check the binary part for range
        // no. of bytes should fall within range

        pAddr = DATAPTR( (SYNTAX_DISTNAME_BINARY *) pAttVal->pVal);
        cBlobSize = PAYLOAD_LEN_FROM_STRUCTLEN(pAddr->structLen);

        if ( pAttSchema->rangeLowerPresent
             && pAttSchema->rangeLower > cBlobSize
             || pAttSchema->rangeUpperPresent
             && pAttSchema->rangeUpper < cBlobSize) {

             err = ERROR_DS_RANGE_CONSTRAINT;
         }

         break;

    case SYNTAX_DISTNAME_STRING_TYPE:
        // This can be DNString or Access-Point
        // This is a unicode string and no. of chars should fall within range

         pAddr = DATAPTR( (SYNTAX_DISTNAME_STRING *) pAttVal->pVal);
         cNoOfChar = PAYLOAD_LEN_FROM_STRUCTLEN(pAddr->structLen)/2;

         if ( pAttSchema->rangeLowerPresent
              && pAttSchema->rangeLower > cNoOfChar
              || pAttSchema->rangeUpperPresent
              && pAttSchema->rangeUpper < cNoOfChar) {

              err = ERROR_DS_RANGE_CONSTRAINT;
          }
        break;

    default: /* all string types */

        if ( pAttSchema->rangeLowerPresent
            && pAttSchema->rangeLower > pAttVal->valLen
            || pAttSchema->rangeUpperPresent
            && pAttSchema->rangeUpper < pAttVal->valLen) {

            err = ERROR_DS_RANGE_CONSTRAINT;
        }

        break;

    }/*switch*/

    return err;

}/*CheckConstraint*/

/*++

Routine Description
   Check that an EntryTTL conforms to any schema range constraints

Arguements

    pAttSchema - pointer to the schema cache of the attribute we are adding
       values for.

   pAttVal - pointer to the value we are adding.

Return Values

    0 if all went well, a WIN32 error code otherwise.

--*/
BOOL
CheckConstraintEntryTTL (
        IN  THSTATE     *pTHS,
        IN  DSNAME      *pObject,
        IN  ATTCACHE    *pACTtl,
        IN  ATTR        *pAttr,
        OUT ATTCACHE    **ppACTtd,
        OUT LONG        *pSecs
        )
{
    LONG        Secs;
    ATTCACHE    *pACTtd;
    extern LONG DynamicObjectDefaultTTL;
    extern LONG DynamicObjectMinTTL;

    // single valued
    if (pAttr->AttrVal.valCount != 1) {
        SetAttError(pObject, pACTtl->id,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                    ERROR_DS_SINGLE_VALUE_CONSTRAINT);
        return FALSE;
    }

    // integer
    if (pAttr->AttrVal.pAVal->valLen != sizeof(LONG)) {
        SetAttError(pObject, pACTtl->id,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                    ERROR_DS_INVALID_ATTRIBUTE_SYNTAX);
        return FALSE;
    }

    // get time-to-live in seconds and adjust if needed
    memcpy(&Secs, pAttr->AttrVal.pAVal->pVal, sizeof(LONG));

    // 0 means take the default
    if (Secs == 0) {
        Secs = DynamicObjectDefaultTTL;
    }
    // Too small, lengthen
    if (Secs < DynamicObjectMinTTL) {
        Secs = DynamicObjectMinTTL;
    }
    // Constraints
    if (   Secs < (LONG)pACTtl->rangeLower
        || Secs > (LONG)pACTtl->rangeUpper) {
        SetAttError(pObject, pACTtl->id,
                    PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                    ERROR_DS_RANGE_CONSTRAINT);
        return FALSE;
    }

    // attrcache for time to die
    pACTtd = SCGetAttById(pTHS, ATT_MS_DS_ENTRY_TIME_TO_DIE);
    if (!pACTtd) {
        SetAttError(pObject, ATT_MS_DS_ENTRY_TIME_TO_DIE,
                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
        return FALSE;
    }

    // Defunct?
    if (pACTtd->bDefunct && !pTHS->fDRA && !pTHS->fDSA) {
        SetAttError(pObject, ATT_MS_DS_ENTRY_TIME_TO_DIE,
                       PR_PROBLEM_UNDEFINED_ATT_TYPE, NULL,
                       DIRERR_ATT_NOT_DEF_IN_SCHEMA);
        return FALSE;
    }

    *ppACTtd = pACTtd;
    *pSecs = Secs;

    return TRUE;

}/*CheckConstraintEntryTTL*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
// InsertObj
// Replace an object or add a new one, both via the multitalented DBRepl.

int InsertObj(THSTATE *pTHS,
              DSNAME *pDN,
              PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
              BOOL bModExisting,
              DWORD dwMetaDataFlags)
{
    DBPOS *pDBTmp;
    DWORD  fAddFlags;
    int   err;
    DPRINT1(2,"InsertObj entered: %S\n", pDN->StringName);

    if (!pTHS->fDRA && (NULL != pMetaDataVecRemote)) {
        // Only the replicator can merge remote meta data vectors.
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           DIRERR_REPLICATOR_ONLY);
    }

    if (bModExisting) {
        fAddFlags = 0;
    }
    else {
        DBOpen2(FALSE, &pDBTmp);
        __try {
            // See if we are adding or modifying an object. If we are replacing
            // a deleted object, DBFind will not find it because it's not an
            // object at this point as we removed the object flag. So we
            // re-add it.

            if (!DBFindDSName(pDBTmp, pDN)) {
                /* Existing object */
                fAddFlags = 0;
            } else {
                /* Adding new object or reviving deleted object. */
                fAddFlags = DBREPL_fADD;
                if (IsRoot(pDN)) {
                    fAddFlags |= DBREPL_fROOT;
                }
            }
        }
        __finally {
            // not committing because we did not open a transaction
            DBClose(pDBTmp, FALSE);
        }
    }

    switch (err = DBRepl(   pTHS->pDB,
                            pTHS->fDRA,
                            fAddFlags,
                            pMetaDataVecRemote,
                            dwMetaDataFlags)){
      case 0:
        DPRINT(3,"Object sucessfully added\n");
        return 0;
        break;
      case DB_ERR_DATABASE_ERROR:
        DPRINT(0,"Database error error returned generate DIR_ERROR\n");

        return SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
        break;
      default:   /*All other error should never happen*/
        DPRINT1(0,"Unknown DBADD error %u returned generate DIR_ERROR\n", err);
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CODE_INCONSISTENCY,
                 szInsertSz("InsertObj"),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY,
                             err);
        break;
    }/*switch*/

}/*InsertObj*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Small helper routine to increment the global gNoOfSchChangeSinceBoot.
   The global keeps count of the no. of schema changes since last reboot,
   and is incremented once on each originating schema change on this DC, and
   once on a successful schema NC sync (including schema fsmo transfer) if
   any actual schema changes are brought in. When the schema cache is loaded,
   the current value of this global is cached, indicating how uptodate the
   schema cache is.

   When a schema NC replication is done, the cached value in the thread
   state's schema pointer is compared with the global to decide if the
   cache is uptodate with all prior changes in this DC (including replicated
   in changes), since any replicated in schema changes will be validated
   against this cache. The variable is updated and read only within the
   critical section. When a schema replication starts, the critical section
   is first entered before reading this value, and the critical section is
   held for the entire packet processing (not necessarily the entire NC
   processing). Similarly, all originating writes write this variable in the
   critical section through this function. This ensures that a replicated-in
   schema change and originating schema changes are serialized, and the
   replicated-in change cannot see a backdated schema cache and still
   continue.

*/

VOID
IncrementSchChangeCount(THSTATE *pTHS)
{
    EnterCriticalSection(&csNoOfSchChangeUpdate);
    gNoOfSchChangeSinceBoot++;
    LeaveCriticalSection(&csNoOfSchChangeUpdate);
}


BOOL
ObjCachingPreProcessTransactionalData (
        BOOL fCommit
        )
{
    THSTATE* pTHS = pTHStls;
    NESTED_TRANSACTIONAL_DATA *pData = pTHS->JetCache.dataPtr;

    if (fCommit && pTHS->transactionlevel <= 1 && pData->objCachingInfo.fUpdateScriptChanged) {
        Assert(pTHS->transactionlevel == 1);
        // We are commiting a transaction that changed the update script value.
        // Reset the cached script optype value. We will schedule a recompute task in
        // ObjCachingPostProcessTransactionalData. Meanwhile, everyone will compute
        // a value for themselves based on their transactional view.
        ScriptResetOptype();
    }

    return TRUE;
}

VOID
FreeCrossRefListEntry(
    IN OUT CROSS_REF_LIST **ppCRL
    )
/*++

Routine Description:

    Free the malloc'ed memory associated w/*ppCRL. Assumes
    *ppCRL has been removed from or was never on the global
    cross ref list.

Arguments:

    ppCRL - pointer to address of cross_ref_list

Return Value:

    None. Sets *ppCRL to NULL

--*/
{
    DWORD i;
    CROSS_REF_LIST *pCRL;

    if (NULL == (pCRL = *ppCRL)) {
        return;
    }
    *ppCRL = NULL;

    if (pCRL->CR.pNC) {
        free(pCRL->CR.pNC);
    }
    if (pCRL->CR.pNCBlock) {
        free(pCRL->CR.pNCBlock);
    }
    if (pCRL->CR.pObj) {
        free(pCRL->CR.pObj);
    }
    if (pCRL->CR.NetbiosName) {
        free(pCRL->CR.NetbiosName);
    }
    if (pCRL->CR.DnsName) {
        free(pCRL->CR.DnsName);
    }
    if (pCRL->CR.DnsAliasName) {
        free(pCRL->CR.DnsAliasName);
    }
    if (pCRL->CR.pdnSDRefDom) {
        free(pCRL->CR.pdnSDRefDom);
    }
    if (pCRL->CR.DnsReferral.pAVal) {
        for (i = 0; i < pCRL->CR.DnsReferral.valCount; ++i) {
            if (pCRL->CR.DnsReferral.pAVal[i].pVal) {
                free(pCRL->CR.DnsReferral.pAVal[i].pVal);
            }
        }
        free(pCRL->CR.DnsReferral.pAVal);
    }
    free(pCRL);
}

VOID
ObjCachingPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
{
    OBJCACHE_DATA *pTemp, *pTemp2;
    DWORD         err;
    BOOL          catalogChanged;
    DSA_DEL_INFO  *pDsaDelInfo;

    Assert(VALID_THSTATE(pTHS));

    if (pTHS->JetCache.dataPtr->objCachingInfo.fUpdateScriptChanged && fCommit && pTHS->transactionlevel == 0) {
        // The script was changed in this transaction. No matter whether we actually committed or not,
        // we still have to schedule a recompute task, because we have reset the cached value in
        // ObjCachingPreProcessTransactionalData.
        InsertInTaskQueueDamped(TQ_CacheScriptOptype,
                                NULL,
                                0,
                                0,
                                TaskQueueNameMatched,
                                NULL);
    }

    if ( !fCommitted ) {
        // Aborted transaction - throw away all the data of
        // this (possibly nested) transaction.

        // Free up anything in the pData.
        pTemp = pTHS->JetCache.dataPtr->objCachingInfo.pData;
        pTHS->JetCache.dataPtr->objCachingInfo.pData = NULL;

        while(pTemp) {
            pTemp2 = pTemp;
            pTemp = pTemp->pNext;
            if(pTemp2->pMTX) {
                free(pTemp2->pMTX);
            }
            if(pTemp2->pRootDNS) {
                free(pTemp2->pRootDNS);
            }
            if(pTemp2->pCRL) {
                Assert(pTemp2->pCRL->CR.pNC);
                Assert(pTemp2->pCRL->CR.pNCBlock);
                Assert(pTemp2->pCRL->CR.pObj);
                FreeCrossRefListEntry(&pTemp2->pCRL);
            }
        }

        // free pDsaDelInfo list
        while (pDsaDelInfo = pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo) {
            pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo = pDsaDelInfo->pNext;
            FreeDsaDelInfo(pTHS, pDsaDelInfo);
        }

        if (pTHS->fCatalogCacheTouched) {
            // free catalog_updates data
            CatalogUpdatesFree(&pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates);
            CatalogUpdatesFree(&pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates);
        }
        pTHS->fRebuildCatalogOnCommit = FALSE;
    }
    else if (pTHS->JetCache.transLevel > 0) {
        // Committing, to non-zero level.  Propagate the objCaching info to the
        // outer transaction.

        Assert(pTHS->JetCache.dataPtr->pOuter);
        if(pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fRecalcMapiHierarchy
                = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fSignalSCache = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fNotifyNetLogon = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalGcPromotion) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fSignalGcPromotion = TRUE;
        }

        if (pTHS->JetCache.dataPtr->objCachingInfo.fUpdateScriptChanged) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fUpdateScriptChanged = TRUE;
        }

        if (pTHS->JetCache.dataPtr->objCachingInfo.fEnableLVR) {
            pTHS->JetCache.dataPtr->pOuter->objCachingInfo.fEnableLVR = TRUE;
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.pData) {
            if(!pTHS->JetCache.dataPtr->pOuter->objCachingInfo.pData) {
                pTHS->JetCache.dataPtr->pOuter->objCachingInfo.pData =
                    pTHS->JetCache.dataPtr->objCachingInfo.pData;
            }
            else {
                // Tack onto the end of outer.
                pTemp = pTHS->JetCache.dataPtr->pOuter->objCachingInfo.pData;
                while(pTemp->pNext) {
                    pTemp = pTemp->pNext;
                }
                pTemp->pNext = pTHS->JetCache.dataPtr->objCachingInfo.pData;

            }
        }

        // merge pDsaDelInfo lists
        if(pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo) {
            DSA_DEL_INFO **ppDsaDelInfo = &pTHS->JetCache.dataPtr->pOuter->objCachingInfo.pDsaDelInfo;
            while (*ppDsaDelInfo) {
                ppDsaDelInfo = &(*ppDsaDelInfo)->pNext;
            }
            *ppDsaDelInfo = pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo;
        }

        if (pTHS->fCatalogCacheTouched) {
            // merge catalog updates to the outer transaction
            CatalogUpdatesMerge(
                &pTHS->JetCache.dataPtr->pOuter->objCachingInfo.masterNCUpdates,
                &pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates
                );
            CatalogUpdatesMerge(
                &pTHS->JetCache.dataPtr->pOuter->objCachingInfo.replicaNCUpdates,
                &pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates
                );
        }
    }
    else {
        // OK, we're committing to transaction level 0.  Give the people who
        // care about this data a chance to do something with it, then delete
        // the data.

        if(pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy &&
           DsaIsRunning() &&
           gfDoingABRef) {
            // Insert damped, so that we can only have a single
            // BuildHierarchyTable task scheduled.
            InsertInTaskQueueDamped(TQ_BuildHierarchyTable,
                              (void *)((DWORD) HIERARCHY_DO_ONCE),
                              15,
                              15,
                              TaskQueueNameMatched,
                              NULL);
        }
        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache) {
            SCSignalSchemaUpdateLazy();
            // the schema fsmo cannot be transferred for a few seconds after
            // it has been transfered or after a schema change (excluding
            // replicated or system changes). This gives the schema admin a
            // chance to change the schema before having the fsmo pulled away
            // by a competing schema admin who also wants to make schema
            // changes.
            if (!pTHS->fDRA && !pTHS->fDSA) {
                SCExtendSchemaFsmoLease();
            }
        }

        if(pTHS->JetCache.dataPtr->objCachingInfo.fSignalGcPromotion) {
            InsertInTaskQueueSilent(
                TQ_CheckGCPromotionProgress,
                NULL,
                0,
                TRUE);
        }
        if (pTHS->JetCache.dataPtr->objCachingInfo.fEnableLVR) {
            // Check if linked value replication should be enabled
            // We also check in RebuildAnchor to handle the replicated write case
            DsaEnableLinkedValueReplication( NULL /*noths*/, TRUE /*first */ );
        }

        // notify Netlogon of DSA objects deleted in this transaction.
        while (pDsaDelInfo = pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo) {
            pTHS->JetCache.dataPtr->objCachingInfo.pDsaDelInfo = pDsaDelInfo->pNext;

            __try {
                // If we don't have a DnsDomainName, we also don't have
                // a DomainGuid. I_NNNDD wants a null pointer to a guid
                // rather than a pointer to a null guid, though, so
                // we get the funky second argument to the call.
                I_NetNotifyNtdsDsaDeletion(pDsaDelInfo->pDnsDomainName,
                                           (pDsaDelInfo->pDnsDomainName
                                            ? &(pDsaDelInfo->DomainGuid)
                                            : NULL),
                                           &(pDsaDelInfo->DsaGuid),
                                           pDsaDelInfo->pDnsHostName);
            } __except (HandleAllExceptions(GetExceptionCode())) {
                // Ignore errors
                ;
            }
            FreeDsaDelInfo(pTHS, pDsaDelInfo);
        }

        pTemp = pTHS->JetCache.dataPtr->objCachingInfo.pData;
        while(pTemp) {
            switch(pTemp->type) {
            case OBJCACHE_ADD:
                // Doing an add cache
                Assert(pTemp->pCRL);

                AddCRLToMem(pTemp->pCRL);
                // The AddCRLToMem grabbed the CRL and put it in the in-memory
                // list.  Let go of it here to avoid freeing it.
                pTemp->pCRL = NULL;
                if(pTemp->pMTX) {
                    Assert(pTemp->pRootDNS);
                    // Just recached the Cross-Ref for the root domain,
                    // presumably due to a modification.  In case ATT_DNS_ROOT
                    // was updated...
                    // Update gAnchor.pwszRootDomainDnsName.

                    EnterCriticalSection(&gAnchor.CSUpdate);
                    // no try/finally because nothing can except in
                    // the block below.
                    if ( NULL != gAnchor.pwszRootDomainDnsName ) {
                        DELAYED_FREE( gAnchor.pwszRootDomainDnsName );
                    }

                    gAnchor.pwszRootDomainDnsName = pTemp->pRootDNS;
                    pTemp->pRootDNS = NULL;

                    if (NULL != gAnchor.pmtxDSA) {
                        DELAYED_FREE(gAnchor.pmtxDSA);
                    }

                    gAnchor.pmtxDSA = pTemp->pMTX;
                    pTemp->pMTX = NULL;
                    LeaveCriticalSection( &gAnchor.CSUpdate );
                }

                // If we're doing an add AND the pDN is set, it's because we
                // need to tell LSA about this change.
                if(pTemp->pDN) {
                    // pDN is THAllocOrg'ed
                    SampNotifyLsaOfXrefChange(pTemp->pDN);
                }
                break;

            case OBJCACHE_DEL:
                Assert(pTemp->pDN);
                Assert(!pTemp->pMTX);
                Assert(!pTemp->pCRL);
                Assert(!pTemp->pRootDNS);
                err = DelCRFromMem(pTHS, pTemp->pDN);
                // DelCRFromMem returns a boolean.  Assert success.
                Assert(err);
                break;

            default:
                Assert(!"Post process obj caching invalid type.\n");
                break;
            }
            pTemp2 = pTemp;
            pTemp = pTemp->pNext;
            if(pTemp2->pMTX) {
                free(pTemp2->pMTX);
            }
            if(pTemp2->pRootDNS) {
                free(pTemp2->pRootDNS);
            }

            if(pTemp2->pCRL) {

                Assert(pTemp2->pCRL->CR.pNC);
                Assert(pTemp2->pCRL->CR.pNCBlock);
                Assert(pTemp2->pCRL->CR.pObj);

                free(pTemp2->pCRL->CR.pNC);
                free(pTemp2->pCRL->CR.pNCBlock);
                free(pTemp2->pCRL->CR.pObj);
                free(pTemp2->pCRL);
            }

            // We've modified something in the cross ref cache.
            // Tell the KCC to look around and see if it needs to do anything
            // when it gets its chance to run.
#ifndef DONT_RUN_KCC_AFTER_CHANGING_CROSSREF
            pTHS->fExecuteKccOnCommit = TRUE;
#endif
        } // while

        // BUGBUG if we ever fix up the in memory ref and catalog cache to be
        // consistently in the right state, then we can reenable this code, and
        // remove the calls to dsI_NetNotifyDsChange(NlNdncChanged); in
        // BuildRefCache() and RebuildCatalog()
        //
        // if(pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon) {
        //     dsI_NetNotifyDsChange(NlNdncChanged);
        // }

        if (pTHS->JetCache.dataPtr->objCachingInfo.pData != NULL && !DsaIsInstalling()) {
            // we had something changed in CR list
            // schedule a cr cache rebuild to ensure data is valid even if two threads overlapped their updates
            // Insert damped: we don't want to schedule if there is one already scheduled.
            // Damped secs is zero, because we always schedule this in zero seconds.
            // Note: if there is a rebuild going on right now, then it has been
            // already taken off the task queue, and we will insert a new task
            // (which is what we want).
            InsertInTaskQueueDamped(TQ_RebuildRefCache,
                                    pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon ? (void *) 1 : NULL,
                                    0, 0, TaskQueueNameMatched, NULL);
        }

        if (pTHS->fCatalogCacheTouched) {

            // apply masterNC catalog updates
            catalogChanged = CatalogUpdatesApply(&pTHS->JetCache.dataPtr->objCachingInfo.masterNCUpdates, &gAnchor.pMasterNC);
            if (catalogChanged) {
                // If master NCs changed, then we need to write SPNs
                InsertInTaskQueueDamped(TQ_WriteServerInfo, (void *)(DWORD)SERVINFO_RUN_ONCE,
                                        0, 0, TaskQueueNameMatched, NULL);
            }

            // apply replicaNC catalog updates
            catalogChanged |= CatalogUpdatesApply(&pTHS->JetCache.dataPtr->objCachingInfo.replicaNCUpdates, &gAnchor.pReplicaNC);

            if (catalogChanged && !DsaIsInstalling()) {
                // schedule a catalog rebuild to ensure data is valid even if two threads overlapped their updates
                // Insert damped: we don't want to schedule if there is one already scheduled.
                // Damped secs is zero, because we always schedule this in zero seconds.
                // Note: if there is a rebuild going on right now, then it has been
                // already taken off the task queue, and we will insert a new task
                // (which is what we want).
                pTHS->fRebuildCatalogOnCommit = TRUE;
            }
        }

#ifdef DBG
        if (pTHS->fCatalogCacheTouched || pTHS->JetCache.dataPtr->objCachingInfo.pData) {
            // NC cache was updated or CR cache was updated
            gdwLastGlobalKnowledgeOperationTime = GetTickCount();
        }
#endif

        if ( pTHS->fRebuildCatalogOnCommit ) {
            InsertInTaskQueueDamped(
                        TQ_RebuildCatalog,
                        pTHS->JetCache.dataPtr->objCachingInfo.fNotifyNetLogon ? (void *) 1 : NULL,
                        0,
                        0,
                        TaskQueueNameMatched,
                        NULL );
            pTHS->fRebuildCatalogOnCommit = FALSE;

#ifdef DBG
            gdwLastGlobalKnowledgeOperationTime = GetTickCount();
#endif
        }
    } // if
    return;
}


int
AddObjCaching(THSTATE *pTHS,
              CLASSCACHE *pClassSch,
              DSNAME *pDN,
              BOOL fAddingDeleted,
              BOOL fIgnoreExisting)
/*++
  Description:
      This routine tracks changes that should be made to global in-memory data
      structures when certain object classes are added.  The actual changes to
      the global in-memory data structures are not done until
      ObjCachingPostProcessTransactionalData().  This way, if the transaction is
      not successfully committed, we don't actually change the data structures.

--*/

{
    UCHAR  syntax;
    DSNAME *pParent;
    ULONG i;
    int err;
    SCHEMAPTR * pSchema = pTHS->CurrSchemaPtr;
    PrefixTableEntry * pNewPrefix = pTHS->NewPrefix;
    CROSS_REF_LIST *pCRL = NULL;
    MTX_ADDR       *pmtxAddress=NULL;
    WCHAR          *pDNSRoot=NULL;
    OBJCACHE_DATA  *pObjData = NULL;

    // Since the only things we check currently are CLASS_CROSS_REF,
    // CLASS_CLASS_SCHEMA, and CLASS_ATTRIBUTE_SCHEMA, and none of these
    // need any processing in the fAddingDeleted case, we can test here.
    // If other cases get added which do require fAddingDeleted processing,
    // then the test will need to be replicated in each case that needs it.

    // CLASS_MS_EXCH_CONFIGURATION_CONTAINER and CLASS_ADDRESS_BOOK_CONTAINER
    // are also tracked.  These can affect the MAPI hierarchy.  The same logic
    // regarding fAddingDeleted applies.

    if (  fAddingDeleted
       && (CLASS_INFRASTRUCTURE_UPDATE != pClassSch->ClassId) ) {
        return(0);
    }

    switch (pClassSch->ClassId) {
    case CLASS_MS_EXCH_CONFIGURATION_CONTAINER:
    case CLASS_ADDRESS_BOOK_CONTAINER:
        // This may have affected the MAPI hierarchy.  Do a recalc.
        pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy = TRUE;
        break;

    case CLASS_CROSS_REF:
        // Cross-Ref objects can exist anywhere in NT5.
        pObjData = THAllocOrgEx(pTHS, sizeof(OBJCACHE_DATA));
        pObjData->type = OBJCACHE_ADD;

        err = MakeStorableCRL(
                pTHS,
                pTHS->pDB,
                pDN,
                &pCRL,
                fIgnoreExisting ? NULL : gAnchor.pCRL);

        if (!err) {
            if (pCRL->CR.DnsName
                && ( NULL != gAnchor.pRootDomainDN )
                && NameMatched( gAnchor.pRootDomainDN, pCRL->CR.pNC ) ) {
                // Just recached the Cross-Ref for the root domain,
                // presumably due to a modification.  In case ATT_DNS_ROOT
                // was updated...

                CHAR *pszServerGuid = NULL;
                RPC_STATUS rpcStatus;
                DWORD cch;
                CHAR *pchDnsName=NULL;
                LONG cb;
                ULONG  dnslen = 0;

                // Need to realloc this to get it to be NULL terminated.
                dnslen = wcslen(pCRL->CR.DnsName) * sizeof(WCHAR);
                if (NULL != (pDNSRoot = malloc(dnslen + sizeof(WCHAR)))) {
                    memcpy(pDNSRoot, pCRL->CR.DnsName, dnslen);
                    pDNSRoot[dnslen/sizeof(WCHAR)] = L'\0';

                    Assert(NULL != gAnchor.pDSADN);
                    Assert(!fNullUuid(&gAnchor.pDSADN->Guid));

                    // OK, create the mtx address. We're going to just construct
                    // it here, rather than call DRA routines.

                    // Stringize the server's GUID.
                    rpcStatus = UuidToStringA(&gAnchor.pDSADN->Guid,
                                              &pszServerGuid);
                } else {
                    rpcStatus = RPC_S_OUT_OF_MEMORY;
                }

                if ( RPC_S_OK == rpcStatus ) {

                    __try {
                        Assert(36 == strlen(pszServerGuid));

                        pchDnsName = (PUCHAR) String8FromUnicodeString(
                                                      FALSE,
                                                      CP_UTF8,
                                                      pDNSRoot,
                                                      dnslen/sizeof(WCHAR),
                                                      &cb,
                                                      NULL);
                        if (pchDnsName == NULL) {
                            rpcStatus = RPC_S_OUT_OF_MEMORY;
                            __leave;
                        }

                        cch = (36 /* guid */ +
                               8 /* "._msdcs." */ +
                               cb +
                               1 /* \0 */);

                        pmtxAddress =  malloc(MTX_TSIZE_FROM_LEN(cch));
                        if(!pmtxAddress) {
                            rpcStatus = RPC_S_OUT_OF_MEMORY;
                            __leave;
                        }

                        pmtxAddress->mtx_namelen = cch; //includes null-term
                        sprintf(&pmtxAddress->mtx_name[0],
                                "%s._msdcs.%s",
                                pszServerGuid,
                                pchDnsName);
                    }
                    __finally {
                        if (pchDnsName) {
                            THFreeEx(pTHS, pchDnsName);
                        }
                        RpcStringFreeA(&pszServerGuid);
                    }
                }
                if (rpcStatus) {
                    // Failed to convert server GUID to string.
                    LogUnhandledError( rpcStatus );
                }
            }

            // Now, build the transactional data structure.
            pObjData->pCRL = pCRL;
            pObjData->pMTX = pmtxAddress;
            pObjData->pRootDNS = pDNSRoot;
            pObjData->pNext = NULL;
            // Tack this onto the end, it's a queue

            if(pTHS->JetCache.dataPtr->objCachingInfo.pData) {
                OBJCACHE_DATA *pTemp =
                    pTHS->JetCache.dataPtr->objCachingInfo.pData;
                while(pTemp->pNext) {
                    pTemp = pTemp->pNext;
                }
                pTemp->pNext = pObjData;
            }
            else {
                pTHS->JetCache.dataPtr->objCachingInfo.pData = pObjData;
            }
        }
        break;

    case CLASS_CLASS_SCHEMA:
        //
        // Update in memory schema cache
        //

        // PERFHINT: why go to all this name trouble?  We should be positioned on
        // the object we are adding, so (pDB->PDNT == gAnchor.ulDNTDMD) should
        // get us the same thing, shouldn't it?
        pParent = THAllocEx(pTHS, pDN->structLen);
        TrimDSNameBy(pDN, 1, pParent);

        // mkdit.exe manages the schema cache on its own. Don't update.
        if (   !gfRunningAsMkdit
            && (NameMatched(gAnchor.pDMD, pParent) || DsaIsInstalling())) {

            if (DsaIsRunning() && (pTHS->cNewPrefix || !pTHS->fDRA)) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            if (pTHS->cNewPrefix > 0) {
                if ( DsaIsInstalling() ) {
                    // Add new prefixes directly to cache during install.
                    for (i=0; i<pTHS->cNewPrefix; i++) {
                        if (!AddPrefixToTable(&pNewPrefix[i],
                                              &(pSchema->PrefixTable.pPrefixEntry),
                                              &(pSchema->PREFIXCOUNT))) {
                            InterlockedIncrement(
                                    &pSchema->PrefixTable.PrefixCount);
                        }
                    }
                }

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            InterlockedIncrement(
                    &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB));

            if ( DsaIsInstalling() ) {
                // Let it add to cache directly during install
                AddClassToSchema();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
        }
        THFreeEx(pTHS, pParent);
        break;

    case CLASS_ATTRIBUTE_SCHEMA:
        //
        // Update in memory schema cache
        //

        // PERFHINT: why go to all this name trouble?  We should be positioned on
        // the object we are adding, so (pDB->PDNT == gAnchor.ulDNTDMD) should
        // get us the same thing, shouldn't it?
        pParent = THAllocEx(pTHS, pDN->structLen);
        TrimDSNameBy(pDN, 1, pParent);

        // mkdit.exe manages the schema cache on its own. Don't update.
        if (   !gfRunningAsMkdit
            && (NameMatched(gAnchor.pDMD, pParent) || DsaIsInstalling())) {

            // This may be a bogus assert.
            Assert(DsaIsInstalling() || pTHS->pDB->PDNT == gAnchor.ulDNTDMD);

            if (DsaIsRunning() && (pTHS->cNewPrefix || !pTHS->fDRA)) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            if (pTHS->cNewPrefix > 0) {
                if ( DsaIsInstalling() ) {
                    // Add new prefixes directly to cache during install.
                    for (i=0; i<pTHS->cNewPrefix; i++) {
                        if (!AddPrefixToTable(&pNewPrefix[i],
                                              &(pSchema->PrefixTable.pPrefixEntry),
                                              &(pSchema->PREFIXCOUNT))) {
                            InterlockedIncrement(
                                &pSchema->PrefixTable.PrefixCount);
                        }
                    }
                }

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            InterlockedIncrement(
                    &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB));

            if ( DsaIsInstalling() ) {
                // Let it add to cache directly during install
                AddAttToSchema();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
        }
        THFreeEx(pTHS, pParent);
        break;


    case CLASS_INFRASTRUCTURE_UPDATE:
        if ( DsaIsRunning() ) {
            // Too complicated to handle inline
            HandleDNRefUpdateCaching(pTHS);
        }
        break;

    default:
        /* no other kinds of objects are cached */
        ;
    }

    return pTHS->errCode;

}/*AddObjCaching*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function removes cache references and shema objects from memory.  We
   have no rollback feature associated with this cache.

   NOTE: It is assumed that all database operations that may err,
   have already been performed and we have a sucessful transaction so far.
   If this function completes normally then we are done.  Note that this
   routine may fail, but if it does so it should leave memory structures
   unaltered, or restore them appropriately.

*/

int DelObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  RESOBJ *pRes,
                  BOOL fCleanUp)
{
    BOOL fLastRef;
    int err = 0;
    OBJCACHE_DATA *pObjData;

    switch (pClassSch->ClassId) {

    case CLASS_MS_EXCH_CONFIGURATION_CONTAINER:
    case CLASS_ADDRESS_BOOK_CONTAINER:
        pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy = TRUE;
        break;

    case CLASS_CROSS_REF:
        pObjData = THAllocOrgEx(pTHS, sizeof(OBJCACHE_DATA));
        err = 0;
        if(fCleanUp && fLastCrRef(pTHS, pRes->pObj)) {
            // This was the last reference to some subref.  Delete it.
            err = DelAutoSubRef(pRes->pObj);
            Assert(!err || pTHS->errCode);
        }
        if(!err) {
            // OK, successful so far.  Add this to the transactional data.
            pObjData->type = OBJCACHE_DEL;
            pObjData->pDN = THAllocOrgEx(pTHS, pRes->pObj->structLen);
            pObjData->pNext = NULL;
            memcpy(pObjData->pDN, pRes->pObj, pRes->pObj->structLen);
            // Tack this onto the end, it's a queue
            if( pTHS->JetCache.dataPtr->objCachingInfo.pData) {
                OBJCACHE_DATA *pTemp =
                    pTHS->JetCache.dataPtr->objCachingInfo.pData;
                while(pTemp->pNext) {
                    pTemp = pTemp->pNext;
                }
                pTemp->pNext = pObjData;
            }
            else {
                pTHS->JetCache.dataPtr->objCachingInfo.pData = pObjData;
            }
        }

        break;

    case CLASS_CLASS_SCHEMA:
        // Don't update the in memory schema cache if running as mkdit.exe.
        // mkdit.exe manages the schema cache on its own.
        if (!gfRunningAsMkdit && pRes->PDNT == gAnchor.ulDNTDMD) {

            InterlockedDecrement(
                    &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB));

            if (DsaIsRunning() && !pTHS->fDRA) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            if ( DsaIsInstalling() ) {
                // Allow direct access to scache during install
                DelClassFromSchema();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }

        }
        break;


    case CLASS_ATTRIBUTE_SCHEMA:
        // Don't update the in memory schema cache if running as mkdit.exe.
        // mkdit.exe manages the schema cache on its own.
        if (!gfRunningAsMkdit && pRes->PDNT == gAnchor.ulDNTDMD) {

            InterlockedDecrement(
                &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB));

            if (DsaIsRunning() && !pTHS->fDRA) {
                // successful schema change. Up the global that keeps track of
                // no. of schema changes since last reboot.
                IncrementSchChangeCount(pTHS);
            }

            if ( DsaIsInstalling() ) {
                // Allow direct access to scache during install
                DelAttFromSchema();

            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
           }
       }
       break;

    default:
        /* uncached class */
        ;
    }

    return err;

}/*DelObjCaching*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function modifies cache entries for attibute and class objects.
   For other objects, it just calls DelObjCaching and AddObjCaching

   NOTE: It is assumed that all database operations that may err,
   have already been performed and we have a sucessful transaction so far.
   If this function completes normally then we are done.

*/

int ModObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  ULONG cModAtts,
                  ATTRTYP *pModAtts,
                  RESOBJ *pRes)
{
    ULONG i;
    int err;
    DBPOS *pDB;

    switch (pClassSch->ClassId) {
    case CLASS_MS_EXCH_CONFIGURATION_CONTAINER:
        // This may have affected the MAPI hierarchy.  Do a recalc.
        for(i=0;i<cModAtts;i++) {
            switch(pModAtts[i]) {
            case ATT_TEMPLATE_ROOTS:
            case ATT_GLOBAL_ADDRESS_LIST:
            case ATT_ADDRESS_BOOK_ROOTS:
                pTHS->JetCache.dataPtr->objCachingInfo.fRecalcMapiHierarchy =
                    TRUE;
                break;
            default:
                break;
            }
        }
        return 0;
        break;

    case CLASS_CROSS_REF:
        // The objcaching is via a queue, so pushe the delete first, then the
        //add
        return(DelObjCaching (pTHS, pClassSch, pRes, FALSE) ||
               AddObjCaching (pTHS, pClassSch, pRes->pObj, FALSE, TRUE));
        break;

    case CLASS_CLASS_SCHEMA:
        /* Update in memory class schema if this is a class schema obj under
         * The governing DMD for this DSA.
         */
        if (pRes->PDNT == gAnchor.ulDNTDMD) {

            if (DsaIsRunning() && (pTHS->cNewPrefix || !pTHS->fDRA)) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            if (pTHS->cNewPrefix > 0) {
                // there should not be any new prefix created or brought in by
                // replication during install

                Assert(DsaIsRunning());

                // free so that later schema object add/modifies, if any,
                // by the same thread (possible in replication) do not
                // add the prefixes again

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            // Allow direct modification during install
            if ( DsaIsInstalling() ) {
                return ModClassInSchema ();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
       }
       break;

    case CLASS_ATTRIBUTE_SCHEMA:
        /* Update in memory att schema if this is an att schema obj under
         * The governing DMD for this DSA.
         */
        if (pRes->PDNT == gAnchor.ulDNTDMD) {

            if (DsaIsRunning() && (pTHS->cNewPrefix || !pTHS->fDRA)) {
               // successful schema change. Up the global that keeps track of
               // no. of schema changes since last reboot.
               IncrementSchChangeCount(pTHS);
            }

            if (pTHS->cNewPrefix > 0) {
                // there should not be any new prefix created or brought in by
                // replication during install

                Assert(DsaIsRunning());

                // free so that later schema object add/modifies, if any,
                // by the same thread (possible in replication) do not
                // add the prefixes again

                THFreeOrg(pTHS, pTHS->NewPrefix);
                pTHS->NewPrefix = NULL;
                pTHS->cNewPrefix = 0;
            }

            // Allow direct modification during install
            if ( DsaIsInstalling() ) {
                return ModAttInSchema ();
            }
            else {
                // Track in the transactional data that we need to do a schema
                // update.  The rest of the stuff we did here is either safe to
                // do no matter what, or is done in the DB itself, so is already
                // transacted.
                pTHS->JetCache.dataPtr->objCachingInfo.fSignalSCache = TRUE;
            }
        }
        break;

    case CLASS_NTDS_DSA:
        // not transactionally aware.
        if (NameMatched(gAnchor.pDSADN, pRes->pObj)) {
            // modified the NTDS-DSA object for this server
            // update gAnchor with changes
            return ModLocalDsaObj();
        }
        break;

    case CLASS_DMD:
        // not transactionally aware.

        // Schema version may have changed, so write it to registry.
        // Sinc schema container will be modified only very rarely,
        // we write the version no. out registry whenever it is touched
        // (provided it is our schema container)

        if (pRes->DNT == gAnchor.ulDNTDMD) {

            // pTHStls->pDB is already positioned on the object

            err = 0;
            pDB = pTHS->pDB;

            Assert(pDB);

            err = WriteSchemaVersionToReg(pDB);

            if (err) {
                LogUnhandledError(err);
                DPRINT1(0,"WriteSchemaVersionToReg(); %d\n", err);
            }

        }
        break;

    default:
        break;
    }

    return 0;

}/*ModObjCaching*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Reset gAnchor.fAmVirtualGC based on the domain count in the entperprise.
   If there is only one domain, then we're virtually a GC.  Some components,
   eg: SAM, leverage this notion.
*/

VOID
ResetVirtualGcStatus()
{
    // *** Caller is responsible for acquiring gAnchor.CSUpdate. ***

    unsigned        cDomains = 0;
    CROSS_REF_LIST  *pCRL = gAnchor.pCRL;

    while ( pCRL ) {

        if ( pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN ) {
            ++cDomains;
        }

        pCRL = pCRL->pNextCR;
    }

    gAnchor.uDomainsInForest = cDomains;

    if ( gAnchor.fAmGC || (cDomains <= 1)) {
        gAnchor.fAmVirtualGC = TRUE;
    }
    else {
        gAnchor.fAmVirtualGC = FALSE;
    }
    return;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Incrementally update gAnchor.fAmVirtualGC.
Arguments:
    pCR    -- cross-ref being modified
    fAdded -- was this cross-ref added or deleted?
*/

VOID
UpdateVirtualGcStatus(CROSS_REF* pCR, BOOL fAdded)
{
    // *** Caller is responsible for acquiring gAnchor.CSUpdate. ***

    if (!(pCR->flags & FLAG_CR_NTDS_DOMAIN)) {
        // not a domain CR, so nothing changes regarding virtual GC status.
        return;
    }
    if (fAdded) {
        gAnchor.uDomainsInForest++;
    }
    else {
        Assert(gAnchor.uDomainsInForest > 0);
        gAnchor.uDomainsInForest--;
    }

    gAnchor.fAmVirtualGC = gAnchor.fAmGC || gAnchor.uDomainsInForest <= 1;
}

__inline
DWORD
CRAlloc(
    OUT VOID **ppMem,
    IN DWORD nBytes
    )
/*++

Routine Description:

    malloc nBytes of memory. Free with free

Arguments:

    pMem - return address of malloced memory
    nBytes - bytes to malloc

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - malloc failed; *pMem set to NULL
    ERROR_SUCCESS - malloc succeeded; *pMem set to allocated memory

--*/
{
    if (NULL == (*ppMem = malloc(nBytes))) {
        MemoryPanic(nBytes);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    return ERROR_SUCCESS;
}


/*++
  Description:
    Make a malloced data structure holding a Cross Reference List.  This
    function may be called from a transaction or at initialization time.

  INPUT:
    pTHS    - thread state
    pDB     - may not be pTHS->pDB
    pObj    - OPTIONAL DN of cross ref
    ppCRL   - if no error, address of malloc'ed cross ref
              if error, set to NULL
    fIgnoreExisting - Ignore existing cross ref

--*/

DWORD
MakeStorableCRL(THSTATE *pTHS,
                DBPOS *pDB,
                DSNAME *pObj,
                CROSS_REF_LIST **ppCRL,
                CROSS_REF_LIST* pCheckForDupInList)
{
    DWORD           i, nVal, nAtts, err, cOut = 0;
    ATTR            *pAttr = NULL;
    CROSS_REF_LIST  *pCRL = NULL;
    ATTRBLOCK       *pNCBlock = NULL;
    ATTRVAL         *pAVal;
    CROSS_REF       *pCRexisting;

    ATTRTYP aAttids[] = {
        ATT_NC_NAME,
        ATT_OBJ_DIST_NAME,
        ATT_SYSTEM_FLAGS,
        ATT_NETBIOS_NAME,
        ATT_DNS_ROOT,
        ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY,
        ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY,
        ATT_MS_DS_SD_REFERENCE_DOMAIN,
        ATT_MS_DS_DNSROOTALIAS,
        ATT_ENABLED
    };
    ATTCACHE *ppAC[sizeof(aAttids) / sizeof (ATTRTYP)];

    // Initialize a new CROSS_REF_LIST entry
    if (err = CRAlloc(&pCRL, sizeof(CROSS_REF_LIST))) {
        goto cleanup;
    }
    memset(pCRL, 0, sizeof(CROSS_REF_LIST));
    pCRL->CR.dwFirstNotifyDelay = ResolveReplNotifyDelay(TRUE, NULL);
    pCRL->CR.dwSubsequentNotifyDelay = ResolveReplNotifyDelay(FALSE, NULL);
    pCRL->CR.bEnabled = TRUE; // defaults to TRUE if not present

    //
    // Read attributes from the cross ref object
    //

    // Don't bother reading the object's DN if the caller passed it in.
    // Skip undefined attributes (TODO: remove when ATT_MS_DS_DNSROOTALIAS
    // exists everywhere)
    for (i = nAtts = 0; i < sizeof(aAttids) / sizeof (ATTRTYP); ++i) {
        if ((pObj == NULL || aAttids[i] != ATT_OBJ_DIST_NAME)
            && (ppAC[nAtts] = SCGetAttById(pTHS, aAttids[i]))) {
            ++nAtts;
        }
    }
    if (err = DBGetMultipleAtts(pDB,
                                nAtts,
                                ppAC,
                                NULL,
                                NULL,
                                &cOut,
                                &pAttr,
                                DBGETMULTIPLEATTS_fEXTERNAL,
                                0)) {
        DPRINT1(0, "MakeStorableCRL: could not read attributes; error %d\n", err);
        goto cleanup;
    }

    // Process the returned attributes
    for(i = 0; i < cOut; ++i) {

        // Ignore attributes w/no values
        if (0 == pAttr[i].AttrVal.valCount || 0 == pAttr[i].AttrVal.pAVal->valLen) {
            continue;
        }

        // Make the code more readable
        pAVal = pAttr[i].AttrVal.pAVal;

        switch(pAttr[i].attrTyp) {

        // NC Name
        case ATT_NC_NAME:
            if (err = CRAlloc(&pCRL->CR.pNC, pAVal->valLen)) {
                goto cleanup;
            }
            memcpy(pCRL->CR.pNC, pAVal->pVal, pAVal->valLen);
            break;

        // DN
        case ATT_OBJ_DIST_NAME:
            if (err = CRAlloc(&pCRL->CR.pObj, pAVal->valLen)) {
                goto cleanup;
            }
            memcpy(pCRL->CR.pObj, pAVal->pVal, pAVal->valLen);
            break;

        // Ref Domain
        case ATT_MS_DS_SD_REFERENCE_DOMAIN:
            if (err = CRAlloc(&pCRL->CR.pdnSDRefDom, pAVal->valLen)) {
                goto cleanup;
            }
            memcpy(pCRL->CR.pdnSDRefDom, pAVal->pVal, pAVal->valLen);
            break;

        // Netbios
        case ATT_NETBIOS_NAME:
            Assert((pAVal->valLen + sizeof(WCHAR)) <= ((DNLEN + 1 ) * sizeof(WCHAR)));
            if (err = CRAlloc(&pCRL->CR.NetbiosName, pAVal->valLen + sizeof(WCHAR))) {
                goto cleanup;
            }
            memcpy(pCRL->CR.NetbiosName, pAVal->pVal, pAVal->valLen);
            pCRL->CR.NetbiosName[pAVal->valLen / sizeof(WCHAR)] = L'\0';
            break;

        // DNS
        case ATT_DNS_ROOT:
            if (err = CRAlloc(&pCRL->CR.DnsName, pAVal->valLen + sizeof(WCHAR))) {
                goto cleanup;
            }
            memcpy(pCRL->CR.DnsName, pAVal->pVal, pAVal->valLen);
            pCRL->CR.DnsName[pAVal->valLen / sizeof(WCHAR)] = L'\0';

            // DnsName (above) is a copy of the first value. A copy is
            // used to avoid confusing the old code that thinks a cross
            // ref has one and only one dns name. Which is true
            // for Active Directory's NC cross refs although it might not
            // be true for the user-created cross refs. At any rate, the
            // code will use DnsName when a DNS name is needed and will use
            // the values stored here when generating a referral.
            if (err = CRAlloc(&pCRL->CR.DnsReferral.pAVal,
                               pAttr[i].AttrVal.valCount * sizeof(ATTRVAL))) {
                goto cleanup;
            }
            for (nVal = 0; nVal < pAttr[i].AttrVal.valCount; ++nVal) {
                // Ignore empty values
                if (0 == pAVal[nVal].valLen) {
                    continue;
                }
                if (err = CRAlloc(&pCRL->CR.DnsReferral.pAVal[nVal].pVal,
                                   pAVal[nVal].valLen)) {
                    goto cleanup;
                }
                pCRL->CR.DnsReferral.pAVal[nVal].valLen = pAVal[nVal].valLen;
                memcpy(pCRL->CR.DnsReferral.pAVal[nVal].pVal,
                       pAVal[nVal].pVal,
                       pAVal[nVal].valLen);
                ++pCRL->CR.DnsReferral.valCount;
            }
            break;

        // DNS Alias
        case ATT_MS_DS_DNSROOTALIAS:
            if (err = CRAlloc(&pCRL->CR.DnsAliasName, pAVal->valLen + sizeof(WCHAR))) {
                goto cleanup;
            }
            memcpy(pCRL->CR.DnsAliasName, pAVal->pVal, pAVal->valLen);
            pCRL->CR.DnsAliasName[pAVal->valLen / sizeof(WCHAR)] = L'\0';
            break;

        // System Flags
        case ATT_SYSTEM_FLAGS:
            memcpy(&pCRL->CR.flags, pAVal->pVal, sizeof(DWORD));
            break;

        // First delay
        case ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY:
            memcpy(&pCRL->CR.dwFirstNotifyDelay, pAVal->pVal, sizeof(DWORD));
            pCRL->CR.dwFirstNotifyDelay = ResolveReplNotifyDelay(TRUE, &pCRL->CR.dwFirstNotifyDelay);
            break;

        // Subsequent delay
        case ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY:
            memcpy(&pCRL->CR.dwSubsequentNotifyDelay, pAVal->pVal, sizeof(DWORD));
            pCRL->CR.dwSubsequentNotifyDelay = ResolveReplNotifyDelay(FALSE, &pCRL->CR.dwSubsequentNotifyDelay);
            break;

        // Enabled
        case ATT_ENABLED:
            memcpy(&pCRL->CR.bEnabled, pAVal->pVal, sizeof(DWORD));
            break;

        default:
            DPRINT1(0, "MakeStorableCRL: don't understand attribute %x\n", pAttr[i].attrTyp);

        } // switch attrtype

    } // for each attr

    // Use the caller's pObj
    if (pObj && !pCRL->CR.pObj) {
        if (err = CRAlloc(&pCRL->CR.pObj, pObj->structLen)) {
            goto cleanup;
        }
        memcpy(pCRL->CR.pObj, pObj, pObj->structLen);
    }

    // Missing nc name or dn
    if (!pCRL->CR.pNC || !pCRL->CR.pObj) {
        err = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // Convert NC name into block name
    __try {
        err = DSNameToBlockName(pTHS, pCRL->CR.pNC, &pNCBlock, DN2BN_LOWER_CASE);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    if (err) {
        goto cleanup;
    }

    if (NULL == (pCRL->CR.pNCBlock = MakeBlockNamePermanent(pNCBlock))) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // check for pre-existing cross ref
    if (!(pTHS->fDSA || pTHS->fDRA) && pCheckForDupInList != NULL) {
        pCRexisting = FindCrossRefInList(pNCBlock, pCheckForDupInList);
        if ( pCRexisting
            && BlockNamePrefix(pTHS, pNCBlock, pCRexisting->pNCBlock)) {
            Assert(NameMatched(pCRL->CR.pNC, pCRexisting->pNC));
            // The only way this could happen is if a CR is already present
            // for the exact NC we're trying to add a CR for now.  Although
            // the DS handles this, we don't want to encourage people in
            // doing so.  Therefore fail the operation unless it's the DS
            // itself or the replicator who's creating the object, or we
            // have asked to ignore this case since a prior deletion will
            // remove this before adding the new one.
            Assert(!"We should never hit this, as we moved this error condition to be checked in VerifyNcName()");
            SetSvcError(SV_PROBLEM_INVALID_REFERENCE, DIRERR_CROSS_REF_EXISTS);
            err = ERROR_DS_CROSS_REF_EXISTS;
            goto cleanup;
        }
    }

cleanup:
    if (pNCBlock) {
        FreeBlockName(pNCBlock);
    }

    // Free the ATTR array from DBGetMultipleAtts
    DBFreeMultipleAtts(pDB, &cOut, &pAttr);

    // sets pCRL to NULL
    if (err) {
        FreeCrossRefListEntry(&pCRL);
    }

    // Return cross ref list entry
    *ppCRL = pCRL;

    return err;
}


VOID
AddCRLToMem (
        CROSS_REF_LIST *pCRL
        )
/*++
  Description:
      Put an already allocated CROSS_REF_LIST into the global list held on the
      anchor.
--*/
{
    EnterCriticalSection(&gAnchor.CSUpdate);
    // no try/finally because nothing can except below.
    pCRL->pNextCR = gAnchor.pCRL;
    if (gAnchor.pCRL) {
        gAnchor.pCRL->pPrevCR = pCRL;
    }
    gAnchor.pCRL = pCRL;

    UpdateVirtualGcStatus(&pCRL->CR, TRUE);

    LeaveCriticalSection(&gAnchor.CSUpdate);
}

BOOL
fLastCrRef (
        THSTATE *pTHS,
        DSNAME *pObj
        )
/*++
  Description:
    Find out if there are more than one references to a given NC in the global
    CR list
--*/
{
    CROSS_REF_LIST *pCRL;
    DWORD count = 0;

    for (pCRL= gAnchor.pCRL; (pCRL && count < 2) ; pCRL = pCRL->pNextCR){
        if (NameMatched(pCRL->CR.pObj, pObj)){
            count++;
        }
    }/*for*/

    if(count < 2) {
        return TRUE;
    }
    return FALSE;
} /*fLastCrRef*/

// initial size and growth delta for papv arrays
#define PAPV_INITIAL_SIZE 32
#define PAPV_DELTA        32

DWORD addPapvPtr(VOID* ptr, DWORD_PTR** ppapv, DWORD* plenpapv)
/*++
  Description:
    A routine to deal with papv lists. Papv lists are used by the DelayedFreeMemoryEx routine.
    It takes an array of DWORD_PTRs. The first one contains the count of the list (excluding
    self). The rest contains the pointers to free (from the process heap).
    The current array length is in plenpapv.

    Return 0 if all ok, !0 if out of memory
--*/
{
    DWORD_PTR* newPapv;

    Assert(ppapv && plenpapv);

    if (ptr == NULL) {
        // nothing to free
        return 0;
    }

    if (*plenpapv == 0 || *ppapv == NULL) {
        // new array, alloc
        newPapv = (DWORD_PTR*)malloc(PAPV_INITIAL_SIZE * sizeof(DWORD_PTR));
        if (newPapv == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *plenpapv = PAPV_INITIAL_SIZE;
        *ppapv = newPapv;
        // the first element of the array is the count of pointers to free
        (*ppapv)[0] = 0;
    }
    else if ((*ppapv)[0]+1 >= (DWORD_PTR)*plenpapv) {
        // filled all space, need to realloc more
        // The first element of the array is the count of pointers to free.
        // We could not have put more pointers than our current length!
        Assert((*ppapv)[0]+1 == (DWORD_PTR)*plenpapv);
        newPapv = (DWORD_PTR*)realloc(*ppapv, (*plenpapv+PAPV_DELTA) * sizeof(DWORD_PTR));
        if (newPapv == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *plenpapv += PAPV_DELTA;
        *ppapv = newPapv;
    }
    // inc count, record the pointer
    (*ppapv)[0]++;
    (*ppapv)[(*ppapv)[0]] = (DWORD_PTR)ptr;

    return 0;
}

DWORD appendCRDataToPapv(CROSS_REF_LIST* pCRL, DWORD_PTR** ppapv, DWORD* plenpapv)
/*++
  Description:
    append CR data pointers to free to the papv list
--*/
{
    DWORD err = 0;
    ULONG nVal;
    ATTRVAL *pAVal;

    Assert(ppapv && plenpapv);

    err = addPapvPtr(pCRL->CR.pNC, ppapv, plenpapv);
    if (err) goto exit;
    err = addPapvPtr(pCRL->CR.pNCBlock, ppapv, plenpapv);
    if (err) goto exit;
    err = addPapvPtr(pCRL->CR.pObj, ppapv, plenpapv);
    if (err) goto exit;
    err = addPapvPtr(pCRL, ppapv, plenpapv);
    if (err) goto exit;
    err = addPapvPtr(pCRL->CR.NetbiosName, ppapv, plenpapv);
    if (err) goto exit;
    err = addPapvPtr(pCRL->CR.DnsName, ppapv, plenpapv);
    if (err) goto exit;
    err = addPapvPtr(pCRL->CR.DnsAliasName, ppapv, plenpapv);
    if (err) goto exit;
    err = addPapvPtr(pCRL->CR.pdnSDRefDom, ppapv, plenpapv);
    if (err) goto exit;

    if ( pCRL->CR.DnsReferral.valCount) {
        pAVal = pCRL->CR.DnsReferral.pAVal;
        err = addPapvPtr(pAVal, ppapv, plenpapv);
        if (err) goto exit;
        for (nVal = 0; nVal < pCRL->CR.DnsReferral.valCount; ++nVal, ++pAVal) {
            err = addPapvPtr(pAVal->pVal, ppapv, plenpapv);
            if (err) goto exit;
        }
    }
exit:
    return err;
}

BOOL
DelCRFromMem (
        THSTATE *pTHS,
        DSNAME *pObj
        )
/*++
  Description:
    Removes a CR from the global cross ref list, if it exists there, and delay
    frees.

  NOTE:
    If called at transaction level 0 and a malloc fails here WE LEAK THE MEMORY
    THAT WOULD NORMALLY BE DELAY-FREED!  This is because we are being called
    from PostProcessTransactionalData, which is NOT ALLOWED TO FAIL!.

--*/
{
    CROSS_REF_LIST *pCRL;
    CROSS_REF_LIST *pCRLi; // pointer to a CR for finding dead SIDs.
    DWORD_PTR * pointerArray;
    DWORD      lenpapv;
    DWORD      err;

    DPRINT(2,"DelCRFromMem entered.. delete the CR with name\n");

    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {

        for (pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR){

            if (NameMatched(pCRL->CR.pObj, pObj)){

                // Remove link from double linked chain

                if (pCRL->pNextCR != NULL)
                    pCRL->pNextCR->pPrevCR = pCRL->pPrevCR;

                if (pCRL->pPrevCR != NULL)
                    pCRL->pPrevCR->pNextCR = pCRL->pNextCR;


                // If removing the first CR, update the global pointer to
                // point to the next CR (or NULL if the list is empty)

                if (gAnchor.pCRL == pCRL)
                    gAnchor.pCRL = pCRL->pNextCR;

                break;
            }
        } /*for*/

        if(pCRL){
            // Find all the dead cached SIDs in NDNCs.
            for(pCRLi = gAnchor.pCRL; pCRLi != NULL; pCRLi = pCRLi->pNextCR){
                // We destroy all NDNC's cacheing links to this CR's Sid.
                if(pCRLi->CR.pSDRefDomSid == &pCRL->CR.pNC->Sid){
                    // We shouldn't be here for domains.
                    Assert(!(pCRLi->CR.flags & FLAG_CR_NTDS_DOMAIN));
                    pCRLi->CR.pSDRefDomSid = NULL;
                }
            }
            // update virtual GC status
            UpdateVirtualGcStatus(&pCRL->CR, FALSE);
        }

    } __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }

    if (!pCRL) {
        /* Huh.  This CR wasn't cached, so we can't very well uncache it.
         * We don't have any work to do, so we'll just return success.
         */
        return TRUE;
    }

    // Free the CR.
    lenpapv = 0;
    err = appendCRDataToPapv(pCRL, &pointerArray, &lenpapv);

    if (err) {
        /* this is bogus.  We can't even get 20 bytes! */
        if (lenpapv > 0) {
            free(pointerArray);
        }
        if (pTHS->JetCache.transLevel == 0) {
            // We are called from a place that is not allowed to fail.  Just
            // return (and leak).
            return TRUE;
        }
        MemoryPanic((lenpapv+1) * sizeof(DWORD_PTR));
        return FALSE;
    }

    DelayedFreeMemoryEx(pointerArray, 3600);

    return TRUE;

}/*DelCRFromMem*/


int AddClassToSchema()
/*++
  Description:
     Add an object class to the in memory class schema cache.  Not all
     attributes of the class schema are needed for the directory.  We only
     cache the ATT_GOVERNS_ID, ATT_RDN_ATT_ID, ATT_SUB_CLASS_OF, ATT_MUST_CONTAIN
     and ATT_MAY_CONTAIN.

     All Temp memory is allocated from transaction memory space.  This is
     automatically freed at the end of the transaction.

  Returns:
     0 on success
     Error otherwise
*/
{
   CLASSCACHE *pCC, *tempCC;
   int rtn;
   THSTATE *pTHS = pTHStls;
   BOOL tempDITval;

   DPRINT(2,"AddClassToSchema entered\n");

   if (rtn = SCBuildCCEntry(NULL, &pCC)) {
      return rtn;
   }

   // Check if class is already in cache
   if (tempCC = SCGetClassById(pTHS, pCC->ClassId)) {
      // class is already in cache
      // Decrement ClsCount since it was incremented in AddObjCaching
      // The object already in cache has already increased the count
      // when it was loaded
      InterlockedDecrement(
                  &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nClsInDB));
      return rtn;
   }

   /* Call function to add the new class to the cache*/
   /* Set pTHS->UpdateDITStructure to TRUE to indicate that it
      is not a validation cache load, so that the classcache
      will not be added to the hashed-by-schemaGuid table, which
      is added only during validation cache load during schema update
    */

   tempDITval = pTHS->UpdateDITStructure;

   __try {
      pTHS->UpdateDITStructure = TRUE;

      if ((rtn = SCResizeClsHash(pTHS, 1))
          || (rtn = SCAddClassSchema(pTHS, pCC))) {

         DPRINT1(2,"Couldn't add class to memory cache rtn <%u>\n",rtn);
         LogEvent(DS_EVENT_CAT_SCHEMA,
           DS_EVENT_SEV_MINIMAL,
           DIRLOG_CANT_CACHE_CLASS,
           NULL,
           NULL,
           NULL);

         rtn = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_CACHE_CLASS,rtn);
      }
   }
   __finally {
      pTHS->UpdateDITStructure = tempDITval;
   }

   return rtn;

}/*AddClassToSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Del an object class from the  memory class schema cache.  */


int
DelClassFromSchema (
        )
{
    THSTATE *pTHS = pTHStls;
    ULONG len;
    int    rtn;
    SYNTAX_OBJECT_ID  ClassID;
    SYNTAX_OBJECT_ID *pClassID=&ClassID;
    DPRINT(2,"DelClassToSchema entered\n");

    /* Get the class that this schema record governs */

    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_GOVERNS_ID,
                         DBGETATTVAL_fCONSTANT,
                         sizeof(ClassID),
                         &len,
                         (UCHAR **) &pClassID)){
        DPRINT(2,"Couldn't retrieve the objects class\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_GOVERNSID_MISSING,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_GOVERNSID_MISSING,rtn);
    }

    /* Call function to remove the class from the cache*/


    if (rtn = SCDelClassSchema (ClassID)){

        DPRINT1(2,"Couldn't del class from memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_CLASS_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_CANT_REMOVE_CLASS_CACHE, rtn);
    }

    return 0;

}/*DelClassFromSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Modify a class definition in the schema memory cache. */

int
ModClassInSchema (
        )
{
    THSTATE *pTHS=pTHStls;
    ULONG len;
    SYNTAX_OBJECT_ID  ClassID;
    SYNTAX_OBJECT_ID *pClassID=&ClassID;
    int rtn;

    /* Get the CLASS ID that this schema record governs */

    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_GOVERNS_ID,
                         DBGETATTVAL_fCONSTANT, sizeof(ClassID), &len,
                         (UCHAR **)&pClassID)){
        DPRINT(2,"Couldn't retrieve the schema's class id\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_ATT_SCHEMA_REQ_ID,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_ATT_SCHEMA_REQ_ID,
                             rtn);
    }

    /* Call function to modify the Class schema in the cache*/

    if (rtn = SCModClassSchema (pTHS, ClassID)){

        DPRINT1(2,"Couldn't del Attribute from memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_ATT_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_REMOVE_ATT_CACHE,
                             rtn);
    }
    return 0;

}/*ModClassInSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add an Attribute schema to the in memory att schema cache.  Not all
   propertioes of the att schema are needed for the directory.  We only
   cache the ATT_ATTRIBUTE_ID, ATT_ATTRIBUTE_SYNTAX, ATT_IS_SINGLE_VALUED
   ,ATT_RANGELOWER,and ATT_RANGE_UPPER.
*/

int AddAttToSchema()
{
   ATTCACHE *pAC, *tempAC;
   int rtn, err=0;
   THSTATE *pTHS = pTHStls;
   BOOL tempDITval;

   DPRINT(2,"AddAttToSchema entered\n");

   if (rtn = SCBuildACEntry(NULL, &pAC)) {
       return rtn;
   }

   // Check if attribute is already in cache
   if (tempAC = SCGetAttById(pTHS, pAC->id)) {

      // Attribute with same id already in cache. However, this
      // may not be the same attribute, as in the source machine,
      // the old attribute may have been deleted and a new attribute
      // added again that uses the same OID. So we need to compare this
      // two attributes and see if they are the same. If they are the same,
      // we do nothing, else, we delete the old attribute from the cache
      // and add the new one.
      // For now, we just compare the syntax

      // Decrement AttCount since it was incremented in AddObjCaching
      // The object already in cache has already increased the count
      // when it was loaded. We will either leave it the same or delete it
      // and add a new cache entry. Either way th no. of entries remain
      // the same
      InterlockedDecrement(
                  &(((SCHEMAPTR*)(pTHS->CurrSchemaPtr))->nAttInDB));

      if (pAC->syntax == tempAC->syntax) {

          // The syntaxes are the same.
          // Since this is called only during install time,
          // the attribute also has a column (either it is
          // part of the boot dit, in which case the initial
          // LoadSchemaInfo created the col, or it is a new
          // replicated in attribute, in which case the column is
          // created when it is added to the cache below)

          return rtn;
      }

      // The syntaxes are not the same. We will treat this as a new
      // attribute and create a new col for it further down in this function.
      // But before that, we want to delete the old column and cache entry

      err = DBDeleteCol(tempAC->id, tempAC->syntax);
      if (err ==  JET_errSuccess) {
          LogEvent(DS_EVENT_CAT_SCHEMA,
                   DS_EVENT_SEV_ALWAYS,
                   DIRLOG_SCHEMA_DELETED_COLUMN,
                   szInsertUL(tempAC->jColid), szInsertUL(tempAC->id), szInsertUL(tempAC->syntax));
      }
      else {
          LogEvent8(DS_EVENT_CAT_SCHEMA,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
                    szInsertUL(tempAC->jColid),
                    szInsertUL(tempAC->id),
                    szInsertInt(err),
                    szInsertJetErrMsg(err),
                    NULL, NULL, NULL, NULL);
       }

      SCDelAttSchema(pTHS, tempAC->id);

   }

   /* Call function to add the new Attribute schema to the cache*/
   // Create a Jet Column, since this is a new attribute (otherwise
   // it would have been in the cache, since schema objects are added
   // to the cache immediately during install, and this function is
   // called only during install)

   tempDITval = pTHS->UpdateDITStructure;

   __try {
      pTHS->UpdateDITStructure = TRUE;

      if ((rtn = SCResizeAttHash(pTHS, 1))
          || (rtn = SCAddAttSchema(pTHS, pAC, TRUE, FALSE))) {
         DPRINT1(2,"Couldn't add Attribute to memory cache rtn <%u>\n",rtn);
         LogEvent(DS_EVENT_CAT_SCHEMA,
           DS_EVENT_SEV_MINIMAL,
           DIRLOG_CANT_CACHE_ATT,
           NULL,
           NULL,
           NULL);

         rtn = SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_CACHE_ATT, rtn);
      }
   }
   __finally {
      pTHS->UpdateDITStructure = tempDITval;
   }

   if (rtn) {
       return rtn;
   }

   // Make sure that the right attribute is in the cache
   if (!(tempAC = SCGetAttById(pTHS, pAC->id))) {
     DPRINT1(0,"Attribute %s not in cache \n", pAC->name);
   }
   else {
     // the one in cache should be the same one as the one built from the dit
     Assert(tempAC==pAC);
   }

   return 0;

}/*AddAttToSchema*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Remove an attribute definition from the schema memory cache. */

int
DelAttFromSchema (
        )
{
    THSTATE *pTHS=pTHStls;
    UCHAR  syntax;
    ULONG len;
    SYNTAX_OBJECT_ID AttID;
    SYNTAX_OBJECT_ID *pAttID=&AttID;
    int rtn;

    DPRINT(2,"DelAttFromSchema entered\n");

    /* Get the ATT ID that this schema record governs */

    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_ATTRIBUTE_ID,
                   DBGETATTVAL_fCONSTANT, sizeof(AttID), &len,
                   (UCHAR **)&pAttID)){
        DPRINT(2,"Couldn't retrieve the schema's attribute id\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_ATT_SCHEMA_REQ_ID,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_ATT_SCHEMA_REQ_ID,
                             rtn);
    }

    /* Call function to del the Attribute schema from the cache*/

    if (rtn = SCDelAttSchema (pTHS, AttID)){

        DPRINT1(2,"Couldn't del Attribute from memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_ATT_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_CANT_REMOVE_ATT_CACHE,rtn);
    }
    return 0;

}/*DelAttFromSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Modify an attribute definition in the schema memory cache. */

int
ModAttInSchema (
        )
{
    ULONG len;
    SYNTAX_OBJECT_ID AttID;
    SYNTAX_OBJECT_ID *pAttID=&AttID;
    int rtn;
    THSTATE *pTHS=pTHStls;

    // Get the ATT ID that this schema record governs
    if(rtn = DBGetAttVal(pTHS->pDB, 1, ATT_ATTRIBUTE_ID,
                         DBGETATTVAL_fCONSTANT, sizeof(AttID),
                         &len,
                         (UCHAR **)&pAttID)) {

        DPRINT(2,"Couldn't retrieve the schema's attribute id\n");
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_ATT_SCHEMA_REQ_ID,
                 szInsertSz(GetExtDN(pTHS,pTHS->pDB)),
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_ATT_SCHEMA_REQ_ID,
                             rtn);
    }

    /* Call function to update the cache from the database */

    if (rtn = SCModAttSchema (pTHS, AttID)){

        DPRINT1(2,"Couldn't update Attribute in memory cache rtn <%u>\n",rtn);
        LogEvent(DS_EVENT_CAT_SCHEMA,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_CANT_REMOVE_ATT_CACHE,
                 NULL,
                 NULL,
                 NULL);

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_REMOVE_ATT_CACHE,
                             rtn);
    }
    return 0;

}/*ModAttInSchema*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Update gAnchor with modifications made to the NTDS-DSA object
   corresponding to this DSA.
*/

int
ModLocalDsaObj( void )
{
    int iErr;

    iErr = UpdateNonGCAnchorFromDsaOptions( FALSE /* not startup */);

    if (!iErr) {
        iErr = UpdateGCAnchorFromDsaOptionsDelayed( FALSE /* not startup */);
    }

    if ( iErr )
    {
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_UNKNOWN_ERROR, iErr);
    }
    else
    {
        return 0;
    }
}/*ModLocalDsaObj*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Remove a set of attribute values from a specific attribute. */


int
RemAttVals(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal,
    BOOL fPermissive
    )
{
    ATTRVAL *pAVal;
    ULONG vCount;
    DWORD err;

    // delete values for this attribute.

    pAVal = pAttrVal->pAVal;

    for(vCount = 0; vCount < pAttrVal->valCount; vCount++){

        if (err = DBRemAttVal_AC(pTHS->pDB,
                                 pAC,
                                 pAVal->valLen,
                                 pAVal->pVal)) {

            // Continue processing if the attribute error was sucessful
            if (!fPermissive ||
                err != DB_ERR_VALUE_DOESNT_EXIST) {
                SAFE_ATT_ERROR(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_NO_ATTRIBUTE_OR_VAL, pAVal,
                               DIRERR_CANT_REM_MISSING_ATT_VAL);
            }
        }

        pAVal++;

    }/*for*/

    return pTHS->errCode;

}/*RemAttVals*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the first value of an attribute that is known to exist.  It is an
   error if it doesn't exist.
*/

int
GetExistingAtt(DBPOS *pDB,
               ATTRTYP type,
               void *pOutBuf,
               ULONG buffSize)
{
   UCHAR  syntax;
   ULONG len;
   UCHAR *pVal;
   DWORD rtn;

   DPRINT1(2,"GetExistingAtt entered. get att type <%lu>\n",type);

   if(rtn = DBGetSingleValue(pDB, type, pOutBuf, buffSize, NULL)) {
       DPRINT(2,"Couldn't Get att assume directory  error\n");
       LogEvent(DS_EVENT_CAT_SCHEMA,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_MISSING_EXPECTED_ATT,
                szInsertUL(type),
                szInsertSz(GetExtDN(pDB->pTHS, pDB)),
                NULL);

       return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR, DIRERR_MISSING_EXPECTED_ATT,
                            rtn);
   }

   return 0;

}/*GetExistingAtt*/

int __cdecl
CompareAttrtyp(
        const void * pv1,
        const void * pv2
        )
/*
 * Cheap function needed by qsort & bsearch
 */
{
    // Using *pv1 - *pv2 only works when all values for *pv1 and *pv2
    // are all positive or all negative. Eg, try qsorting the array
    // (0x70000000, 0x70000001, 0xe0000000, 5) and bsearching
    // for 5.
    return ((*(ATTRTYP *)pv1 > *(ATTRTYP *)pv2) ? 1
            : (*(ATTRTYP *)pv1 < *(ATTRTYP *)pv2) ? -1
            : 0);
}

/*-------------------------------------------------------------------------*/
BOOL IsMember(ATTRTYP aType, int arrayCount, ATTRTYP *pAttArray){

   int count;

   if (arrayCount < 6) {
       /* Too few entries for bsearch to be worth it */
       for (count = 0 ; count < arrayCount; count++, pAttArray++){
           if (aType == *pAttArray)
             return TRUE;
       }
   }
   else {
       if (bsearch(&aType,
                   pAttArray,
                   arrayCount,
                   sizeof(ATTRTYP),
                   CompareAttrtyp)) {
           return TRUE;
       }
   }
   return FALSE;
}/*IsMember*/

BOOL IsAuxMember (CLASSSTATEINFO  *pClassInfo, ATTRTYP aType, BOOL fcheckMust, BOOL fcheckMay )
{
    DWORD count;
    CLASSCACHE *pCC;

    if (!pClassInfo->cNewAuxClasses) {
        return FALSE;
    }

    for (count=0; count < pClassInfo->cNewAuxClasses; count++) {

        pCC = pClassInfo->pNewAuxClassesCC[count];

        if ((fcheckMust && IsMember (aType, pCC->MustCount, pCC->pMustAtts)) ||
            (fcheckMay && IsMember (aType, pCC->MayCount, pCC->pMayAtts)) ) {
                return TRUE;
        }
    }

    return FALSE;
}


/*++ IsAccessGrantedByObjectTypeList

Routine Description:

    Checks for the specified access on the specified type list using the
    specified Security Descriptor.  A return of 0 means that the pResults
    have been filled in with access info.  Non-zero is an error code associated
    with not being able to check the access (not that access was checked and
    denied, but that access was't checked).
--*/

DWORD
IsAccessGrantedByObjectTypeList (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE* pCC,
        ACCESS_MASK ulAccessMask,
        POBJECT_TYPE_LIST pObjList,
        DWORD cObjList,
        DWORD *pResults,
        DWORD flags,
        PWCHAR szAdditionalInfo,
        GUID*  pAdditionalGUID
        )
{
    DWORD  error, i;
    ULONG  ulLen;
    THSTATE *pTHS=pTHStls;

    Assert(pObjList);
    Assert(cObjList);
    Assert(pResults);

    // Assume full access
    memset(pResults, 0, cObjList*sizeof(DWORD));

    if(pTHS->fDRA || pTHS->fDSA ) {
        // These bypass security, they are internal
        return 0;
    }

    if(!pNTSD || !pDN || !ulAccessMask) {
        // We are missing some parameters.
        return ERROR_DS_SECURITY_CHECKING_ERROR;
    }

    // Check access in this Security descriptor. If an error occurs during
    // the process of checking permission access is denied.
    if(error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDN,                        // DSNAME of the object
            pCC,                        // object class
            ulAccessMask,               // access mask
            pObjList,                   // Object Type List
            cObjList,                   // Number of objects in list
            NULL,
            pResults,                   // access status array
            flags,
            NULL,                       // authz client context (grab from THSTATE)
            szAdditionalInfo,           // additionalInfo string
            pAdditionalGUID             // additional guid
            )) {
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error, ulAccessMask);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 szInsertWin32Msg(error),
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }

    // Permission checking was successful.  The attcache array has nulls for
    // those attributes we don't have rights to.
    return 0;

} /* IsAccessGrantedByObjectTypeList*/

BOOL
IsAccessGrantedParent (
        ACCESS_MASK ulAccessMask,
        CLASSCACHE *pInCC,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the parent of the current object in the directory,
    not touching database positioning or state.

Parameters
    ulAccessMask - right requested.
    pInCC - a classcache to use instead of the classcache of the
            parent. Optional.
    szAdditionalInfo (optional) additionalInfo string for auditing
    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    THSTATE *pTHS = pTHStls;
    CSACA_RESULT   retval;
    ULONG  cbNTSD;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    CLASSCACHE *pCC=NULL;
    DSNAME  parentDN;
    DWORD   err;
    BOOL    fSDIsGlobalSDRef;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return TRUE;
    }

    // Find the security descriptor attribute, classcache and dn of the parent
    if(err = DBGetParentSecurityInfo(pTHS->pDB, &cbNTSD, &pNTSD, &pCC, &parentDN, &fSDIsGlobalSDRef))
    {
        // Didn't get the info we need. We assume the object is therefore locked
        // down, since we can't check the security.
        if(fSetError) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CANT_RETRIEVE_SD, err);
        }
        return FALSE;
    }

    if (!pCC) {
        // Failed to get the class cache pointer.
        LogUnhandledError(DIRERR_OBJECT_CLASS_REQUIRED);
        if(fSetError) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_OBJECT_CLASS_REQUIRED);
        }
        if (pNTSD && !fSDIsGlobalSDRef) {
            THFreeEx (pTHS, pNTSD);
        }

        return FALSE;
    }

    if (!pInCC) {
        // the caller did not provide the classcache pointer to use instead of the
        // classcache of the parent. So, use parent's one.
        pInCC = pCC;
    }
    
    // Security descriptor found. Check access.
    retval = CheckSecurityAttCacheArray (
                pTHS,
                ulAccessMask,
                pNTSD,
                &parentDN,
                pCC,            // parent's class
                pInCC,          // class to check (root GUID in the guid tree)
                0,
                NULL,
                0,
                NULL,
                NULL);

    if (pNTSD && !fSDIsGlobalSDRef) {
        THFreeEx (pTHS, pNTSD);
    }

    if(retval == csacaAllAccessDenied) {
        // No access granted
        if(fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }

        return FALSE;
    }

    return TRUE;
}

BOOL
IsAccessGrantedSimpleEx (
        ACCESS_MASK ulAccessMask,
        PWCHAR szAdditionalInfo,
        GUID*  pAdditionalGUID,
        const ULONG cInAtts,
        ATTCACHE ** rgpAC,
        DWORD dwFlags,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the current object.  Reads all necessary info from
    the current object.
Parameters

    ulAccessMask - right requested.

    szAdditionalInfo - additional info string for the audit
    
    pAdditionalGUID  - additional GUID for the audit

    dwFlags      - CheckPermissions flags

    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    THSTATE *pTHS = pTHStls;
    CSACA_RESULT   retval;
    UCHAR  *pVal;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    CLASSCACHE *pCC = NULL;        //initialized to avoid C4701
    ULONG cbNTSD;
    BOOL fSDIsGlobalSDRef;
    DSNAME  TempDN;
    DWORD   rtn;

    if (pTHS->fDSA || pTHS->fDRA) {
        // These bypass security, they are internal
        return TRUE;
    }

    rtn = DBGetObjectSecurityInfo(pTHS->pDB, pTHS->pDB->DNT,
                                  &cbNTSD, &pNTSD, &pCC, &TempDN, NULL,
                                  DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                                  &fSDIsGlobalSDRef
                                 );
    if (rtn) {
        if(fSetError) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_DATABASE_ERROR,
                          rtn);
        }
        return FALSE;
    }

    if (cbNTSD == 0) {
        // No SD found. We assume the object is therefore locked down
        if(fSetError) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CANT_RETRIEVE_SD,
                          rtn);
        }
        return FALSE;
    }

    // Security descriptor found. Check access.
    retval = CheckSecurityAttCacheArray (
                pTHS,
                ulAccessMask,
                pNTSD,
                &TempDN,
                pCC,
                pCC,
                cInAtts,
                rgpAC,
                dwFlags,
                szAdditionalInfo,
                pAdditionalGUID);

    if (pNTSD && !fSDIsGlobalSDRef) {
        THFreeEx (pTHS, pNTSD);
    }

    if(retval != csacaAllAccessGranted) {
        // Not all access granted
        if(fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }
        return FALSE;
    }

    // All requested rights granted.
    return TRUE;
}


BOOL
IsControlAccessGrantedEx (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        GUID ControlGuid,
        DWORD dwFlags,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the specified Security Descriptor for the specified
    control access right (specified as a pointer to a GUID).

Parameters
    pNTSD - The security descriptor.

    pDN - The DSNAME of the object being checked.  Only the GUID and SID must be
    filled in, the string is optional

    pCC - the ClassCache pointer.

    ControlGuid - guid of the control access being requested.

    dwFlags - check permissions flags
    
    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    DWORD            err;
    BOOL             fChecked, fGranted;
    OBJECT_TYPE_LIST ObjList[2];
    DWORD            Results[2];
    THSTATE     *pTHS = pTHStls;

    if(pTHS->fDSA || pTHS->fDRA) {
        // These bypass security, they are internal
        return TRUE;
    }

    fChecked = FALSE;
    fGranted = FALSE;

    if(!pNTSD || !pDN || !pCC || fNullUuid(&ControlGuid)) {
        if(fSetError) {
            // Didn't succeed in making the isaccess check
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                        ERROR_DS_SECURITY_CHECKING_ERROR);
        }
    }
    else {
        // Now, create the list
        ObjList[0].Level = ACCESS_OBJECT_GUID;
        ObjList[0].Sbz = 0;
        ObjList[0].ObjectType = &pCC->propGuid;
        // Every control access guid is considered to be in it's own property
        // set. To achieve this, we treat control access guids as property set
        // guids.
        ObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
        ObjList[1].Sbz = 0;
        ObjList[1].ObjectType = &ControlGuid;

        // Make the security check call.
        err = IsAccessGrantedByObjectTypeList(pNTSD,
                                              pDN,
                                              pCC,
                                              RIGHT_DS_CONTROL_ACCESS,
                                              ObjList,
                                              2,
                                              Results,
                                              dwFlags,
                                              NULL,
                                              NULL);
        if(!err) {
            fChecked = TRUE;
        }
        else if(fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                        err);
        }
    }


    if(fChecked) {
        // OK, we checked access.  Now, access is granted if either we were
        // granted access on the entire object (i.e. Results[0] is NULL) or we
        // were granted explicit rights on the access guid (i.e. Results[1] is
        // NULL).
        fGranted = (!Results[0] || !Results[1]);

        if(!fGranted && fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                        DIRERR_INSUFF_ACCESS_RIGHTS );
        }
    }

    return fGranted;
}

BOOL
IsAccessGrantedAttribute (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        ULONG  cInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC,
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        )
/*++

Routine Description
    Do a security check on the specified Security Descriptor for the specified
    access mask for the specified attributes.

Parameters
    pNTSD - The security descriptor.

    pDN - The DSNAME of the object being checked.  Only the GUID and SID must
    be filled in, the string is optional

    pCC - the ClassCache pointer.

    ulAccessMask - right requested.

    fSetError - whether or not the call should set an error if it fails.

    cInAtts - the number of attributes in rgpAC

    rgpAC - the array of the attributes beeing checked.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    CSACA_RESULT    retval;

    retval = CheckSecurityAttCacheArray(pTHS,
                           ulAccessMask,
                           pNTSD,
                           pDN,
                           pCC,
                           pCC,
                           cInAtts,
                           rgpAC,
                           0,
                           NULL,
                           NULL
                           );

    if(retval != csacaAllAccessGranted) {
        // Not all access granted
        if (fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
IsAccessGranted (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME     pDN,
        CLASSCACHE *pObjectCC,
        CLASSCACHE *pCC,
        ACCESS_MASK ulAccessMask,
        PWCHAR      szAdditionalInfo,
        GUID*       pAdditionalGUID,
        BOOL        fSetError
        )
/*++

Routine Description
    Do a security check on the specified Security Descriptor for the specified
    access mask.

Parameters
    pNTSD - The security descriptor.

    pDN - The DSNAME of the object being checked.  Only the GUID and SID must
    be filled in, the string is optional
    
    pObjectCC - the ClassCache pointer for the pDN (used for auditing)

    pCC - the ClassCache pointer to use in the access check (in the ObjectType list)

    ulAccessMask - right requested.
    
    szAdditionalInfo - additional info string for the audit
    
    pAdditionalGuid - additional guid for audit

    fSetError - whether or not the call should set an error if it fails.

Return Values
    FALSE if the requested access cannot be granted, TRUE if it can.

--*/
{
    CSACA_RESULT    retval;
    THSTATE     *pTHS = pTHStls;

    if(pTHS->fDSA || pTHS->fDRA) {
        // These bypass security, they are internal
        return TRUE;
    }

    retval = CheckSecurityAttCacheArray (
                pTHS,
                ulAccessMask,
                pNTSD,
                pDN,
                pObjectCC,
                pCC,
                0,
                NULL,
                0,
                szAdditionalInfo,
                pAdditionalGUID);

    if(retval == csacaAllAccessDenied) {
        // No access granted
        if (fSetError) {
            SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_ACCESS_DENIED);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
IsObjVisibleBySecurity(THSTATE *pTHS, BOOL fUseCache)
{
    // Typing hack
#define VIEWCACHE pTHS->ViewSecurityCache
    VIEW_SECURITY_CACHE_ELEMENT *pCacheVals;
    DWORD ThisPDNT = pTHS->pDB->PDNT;
    DWORD ThisDNT  = pTHS->pDB->DNT;
    DWORD i, err, it;
    DWORD dwCachedValue = LIST_CONTENTS_UNKNOWN;

    if(pTHS->fDRA || pTHS->fDSA) {
        // These bypass security, they are internal
        return TRUE;
    }
    if(ThisPDNT == ROOTTAG) {
        // Also allow everyone to list immediately under root.
        return TRUE;
    }

    // First, look through the cache if we have one, create a cache if we don't
    // have one.

    if(fUseCache) {
        if(VIEWCACHE) {
            pCacheVals = VIEWCACHE->CacheVals;
            // The cache is preloaded with nulls, short circuit if we find one
            for(i=0;pCacheVals[i].dnt && i<VIEW_SECURITY_CACHE_SIZE;i++) {
                if(pCacheVals[i].dnt == ThisPDNT) {
                    // A cache hit.
                    if (pCacheVals[i].State == LIST_CONTENTS_ALLOWED) {
                        // We are granted rights to read this object.
                        // This is the most probable case, so we optimize out
                        // checking for NC-head, which is unnecessary when
                        // parent has LIST_CONTENTS.
                        return TRUE;
                    }
                    // Remember the cached value. We can only use it only if
                    // the object is NOT an NC head (which are always visible).
                    dwCachedValue = pCacheVals[i].State;
                    break;
                }
            }
        }
        else {
            // We don't yet have a cache.  Make one if we can.
            VIEWCACHE = THAllocEx(pTHS,sizeof(VIEW_SECURITY_CACHE));
        }
    }

    // There's a special case, that is where the instance type
    // of the object is NC head.  Since it has no parent in the NC, and since
    // security doesn't cross NC boundaries, you can always see these.  Check
    // for that.
    err = DBGetSingleValue(pTHS->pDB,
                           ATT_INSTANCE_TYPE,
                           &it,
                           sizeof(it),
                           NULL);
    if(err) {
        if (DBCheckObj(pTHS->pDB)) {
            // object without an instance type??? Not right.
            LogUnhandledError(ERROR_DS_MISSING_EXPECTED_ATT);
        }
        // Couldn't find the instance type?  Well, that means we're not getting
        // granted rights to this.
        return FALSE;
    }

    if (it & IT_NC_HEAD) {
        // NC heads are always visible.
        // Note: we never update the cache based on
        // the results obtained for an NC head.
        return TRUE;
    }

    // Now that we know this is not an NC head, check if we found
    // a value in the cache.
    switch(dwCachedValue) {
    case LIST_CONTENTS_DENIED:
        // We are denied rights to read this object.
        return FALSE;

    case LIST_CONTENTS_AMBIGUOUS:
        // We don't know enough just based on the parent, we
        // have to look at the object itself.
        // Check for RIGHT_DS_LIST_OBJECT on the object.
        // LIST_CONTENTS_AMBIGUOUS could only be cached when gbDoListObject is TRUE.
        Assert(gbDoListObject);
        return IsAccessGrantedSimple(RIGHT_DS_LIST_OBJECT, FALSE);
    }

    // If we got here, we missed in the cache.
    if(IsAccessGrantedParent(RIGHT_DS_LIST_CONTENTS,
                             NULL,
                             FALSE)) {
        if(fUseCache) {
            // We can see, so put the parent in the cache with state
            // LIST_CONTENTS_ALLOWED.
            VIEWCACHE->CacheVals[VIEWCACHE->index].dnt =
                ThisPDNT;
            VIEWCACHE->CacheVals[VIEWCACHE->index].State =
                LIST_CONTENTS_ALLOWED;
            VIEWCACHE->index =
                (VIEWCACHE->index + 1) % VIEW_SECURITY_CACHE_SIZE;
        }
        return TRUE;
    }

    // We weren't granted normal access, check for the object view rights.
    if(gbDoListObject &&
       IsAccessGrantedParent(RIGHT_DS_LIST_OBJECT,
                             NULL,
                             FALSE)) {
        if(fUseCache) {
            // We are granted ambiguous rights based on the parent.
            VIEWCACHE->CacheVals[VIEWCACHE->index].dnt =
                ThisPDNT;
            VIEWCACHE->CacheVals[VIEWCACHE->index].State =
                LIST_CONTENTS_AMBIGUOUS;
            VIEWCACHE->index =
                (VIEWCACHE->index + 1) % VIEW_SECURITY_CACHE_SIZE;
        }
        // Check for RIGHT_DS_LIST_OBJECT on the object.
        return IsAccessGrantedSimple(RIGHT_DS_LIST_OBJECT,FALSE);
    }

    // OK, not granted at all, so put the parent in the cache with state
    // LIST_CONTENTS_DENIED.
    if(fUseCache) {
        VIEWCACHE->CacheVals[VIEWCACHE->index].dnt =
            ThisPDNT;
        VIEWCACHE->CacheVals[VIEWCACHE->index].State =
            LIST_CONTENTS_DENIED;
        VIEWCACHE->index =
            (VIEWCACHE->index + 1) % VIEW_SECURITY_CACHE_SIZE;
    }

    return FALSE;
#undef VIEWCACHE
}

DWORD
FindFirstObjVisibleBySecurity(
    THSTATE       *pTHS,
    ULONG          ulDNT,
    DSNAME       **ppParent
    )
/*++

Routine Description

    Given the DNT of an existing object, search for the first object in
    the hierarchy that is visible by this client.

Parameters

    pTHS - a valid thread state.
    ulDNT  - the DNT of an object that exists on this server.
    ppParent - where to put the DSNAME of an object visible by the client.

Return Values

    0

--*/
{
    DBPOS  *pDB = pTHS->pDB;
    ULONG            cbActual;
    DWORD            err;

    // Start at the object provided.
    // DBFindDNT succeeds or excepts
    DBFindDNT(pDB, ulDNT);

    // And move up the hierarchy until we reach an object that is visible to
    // this client.
    while (pDB->DNT != ROOTTAG && (!DBCheckObj(pDB) || !IsObjVisibleBySecurity(pTHS, TRUE))) {
        err = DBFindDNT(pDB, pDB->PDNT);
        if (err) {
            //
            // This shouldn't happen so bail if it does.
            //
            pDB->DNT = ROOTTAG;
        }
    }

    if (pDB->DNT != ROOTTAG) {
        // OK, we're on an object, go ahead and pull its name.
        DBGetAttVal(pDB, 1,  ATT_OBJ_DIST_NAME, 0, 0, &cbActual, (PCHAR *)ppParent);
    } else {
        *ppParent = NULL;
    }

    return 0;

}

DWORD
CheckObjDisclosure(
    THSTATE       *pTHS,
    RESOBJ        *pResObj,
    BOOL          fCheckForSecErr
    )
/*++

Routine Description

    If there is current security error, check whether the client
    is allowed to know the existence of the base of the operation
    and set no such object if not.

Parameters

    pTHS - a valid thread state.
    pResObj - The base of the op to be checked.
    fCheckForSecErr - If this is true then CheckObjDisclosure will only
                      perform the disclosure check if a security error
                      has already been set.

Return Values

    returns the current threadstate error code if the object is visible to
    the client, otherwise returns 2 for nameError.

--*/
{
    PDSNAME  pParent;

    if ((!fCheckForSecErr) || (securityError == pTHS->errCode)) {
        if (pResObj->DNT == ROOTTAG) {
            return 0;
        }
        DBFindDNT(pTHS->pDB, pResObj->DNT);

        if (!IsObjVisibleBySecurity(pTHS, FALSE)) {
            THClearErrors();
            FindFirstObjVisibleBySecurity(pTHS,
                                          pResObj->PDNT,
                                          &pParent);

            SetNamError(NA_PROBLEM_NO_OBJECT, pParent, DIRERR_OBJ_NOT_FOUND);
            THFreeEx(pTHS, pParent);
        }
    }
    return pTHS->errCode;
}

DWORD
InstantiatedParentCheck(
    THSTATE *          pTHS,
    ADDCROSSREFINFO *  pChildCRInfo,
    CROSS_REF *        pParentCR,
    ULONG              bImmediateChild
    )
/*++

Routine Description:

    This routine verifies the pChildCRInfo to check whether the
    parent is instatiated.

Arguments:

    pChildCRInfo - This info from the PreTransVerifyNcName() func.
    pParentCR - This is the superior crossRef, it's actually, only
        a true parent CR to the Child CR being added if
        bImmediateChild is true.
    bImmediateChild - Whether the parent CR is an immediate parent
        or just a superior CR.

Return value:

    DIRERR
    - also sets thstate err

--*/
{
    Assert(pParentCR);
    Assert(pChildCRInfo);
    Assert(pTHS);

    //
    // Check whether the immediate parent object is instantiated.
    //
    if(pChildCRInfo->ulDsCrackParent == ERROR_SUCCESS &&
       pChildCRInfo->ulParentCheck == ERROR_SUCCESS){

        if(fNullUuid(&pChildCRInfo->ParentGuid)){

            // This means that the instantiated parent check never
            // got run in PreTransVerifyNcName().  There are several
            // valid reasons, there was no CR (at that time), or the
            // CR had no NTDS_NC flag.
            if(pParentCR->flags & FLAG_CR_NTDS_NC){
                LooseAssert(!"We must've just added or changed this CR.",
                            GlobalKnowledgeCommitDelay);
                SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CANT_FIND_NC_IN_CACHE);
                return(pTHS->errCode);
            }

            // At any rate, irrelevant if there was a slight global
            // memory cache timing problem, or were here because the
            // parent CR has no FLAG_CR_NTDS_NC, we can't claim that
            // the Parent Obj is instantiated.
            SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                        ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
            return(pTHS->errCode);

        } else {

            if(bImmediateChild &&
               !fNullUuid(&pParentCR->pNC->Guid)){

                // If both the CR GUID and the Parent obj GUID are
                // non-NULL, and the child NC is an immediate child
                // of the parent NC, then the GUIDs should match.

                if(memcmp(&pParentCR->pNC->Guid,
                          &pChildCRInfo->ParentGuid,
                          sizeof(GUID)) == 0){
                    // This means the GUIDs match, return success.
                    return(ERROR_SUCCESS);
                } else {
                    // The object we returned, was not the CR's NC
                    // object.  Return error.
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    return(pTHS->errCode);
                }
            }

            // We checked that the parent was instatiated.
            return(ERROR_SUCCESS);

        }

    } else {

        // There was an actual failure trying to reach the parent NC,
        // and verify the parent object is insantiated.  NOTE: the
        // parent NC and parent object could be different objects.

        SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
        return(pTHS->errCode);

    }

    Assert(!"Should never reach this point.");
    SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
    return(pTHS->errCode);
}

DWORD
ChildConflictCheck(
    THSTATE *          pTHS,
    ADDCROSSREFINFO *  pCRInfo
    )
/*++

Routine Description:

    This routine verifies the pChildCRInfo to check whether there
    is not conflicting child object with this data.

Arguments:

    pChildCRInfo - This info from the PreTransVerifyNcName() func.

Return value:

    DIRERR
    - also sets thstate err

--*/
{
    if( pCRInfo->ulDsCrackChild ){
        // This means we couldn't even locate a responsible parent, we must
        // set a couldn't verify nCName attribute.
        SetUpdErrorEx(UP_PROBLEM_NAME_VIOLATION,
                      ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2,
                      pCRInfo->ulDsCrackChild);
        return(pTHS->errCode);
    }

    if( !pCRInfo->ulChildCheck ) {
        // If we've gotten here, it means that there is a conflicting child
        // object.
        Assert(pCRInfo->wszChildCheck);
        SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_OBJ_STRING_NAME_EXISTS);
        return(pTHS->errCode);
    }

    if( pCRInfo->wszChildCheck ) {
        // This would mean that we never tried to check for a conflicting
        // child due to some operations error that occured before we even
        // called the VerifyByCrack routines in PreTransVerifyNcName.  So
        // we must return that we couldn't verify the nCName attribute.
        SetUpdError(UP_PROBLEM_ENTRY_EXISTS,
                    ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
        return(pTHS->errCode);
   }

    return(ERROR_SUCCESS);
}



int
VerifyNcNameCommon(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTRVALBLOCK *pAttrVal,
    ATTCACHE *pAC
    )
/*
 * This routine contains common checks shared by the fDRA path
 */
{
    DSNAME *           pDN = (DSNAME*)pAttrVal->pAVal->pVal;
    DBPOS *            pDBTmp = HVERIFYATTS_GET_PDBTMP(hVerifyAtts);
    DWORD              dwErr;

    // Verify that if the NCname doesn't have a guid, that there doesn't already
    // exist an instantiated object with that name.  Guid-less ncNames are used in
    // special circumstances when the guid is not known at cross-ref creation time.
    // Since this is part of a cross ref creation, we expect that there should not
    // be an nc holding this name already.
    if (fNullUuid(&pDN->Guid)) {
        // See if the named NC exists. The nc should not exist at all, or should be
        // a phantom.
        dwErr = DBFindDSName(pDBTmp, pDN);
        if (!dwErr) {

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_GUIDLESS_NC_HEAD_NAME_CONFLICT,
                     szInsertDN(pDN),
                     NULL,
                     NULL);
            // We have an NC head collision. We just abort creation of the cross ref
            // until the KCC can run or the user corrects the condition.
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_CROSS_REF_BUSY, ERROR_DS_DRA_NAME_COLLISION);
        }
        dwErr = 0;
    }

    return(pTHS->errCode);

}

// context struct to use in EnumerateCrossRefs callback
typedef struct {
    DWORD dwParentDNT;          // the best matching cross-ref dnt here
    ULONG iBest;                // current NC block name prefix length (to find the best one)
    BOOL  fADChildNc;           // whether there is an Active Directory child NC
    ATTRBLOCK* pObj;            // NCname in block form
} ENUMERATE_CROSS_REFS_CONTEXT;

DWORD
enumerateCrossRefsCallback(
    THSTATE* pTHS,
    DBPOS* pDB,
    ENUMERATE_CROSS_REFS_CONTEXT* pContext
)
/*++

Routine Description:

    This is a virtual function passed to EnumerateCrossRefs() from inside
    VerifyNcName() to look at all the cross-refs in the DB/Enterprise to
    determine if any transaction created a cross-ref that wasn't already
    in the global memory cache.

    This function is called once on every cross-ref encountered in the DB,
    to determine two things:

    A) the DNT of the best parent cross-ref
    B) whether there exists a cross-ref representing a naming context
        internal to the AD naming space.

Arguments:

    pTHS -
    pDB - DBPOS on the current cross-ref.
    pContext - This context is the only in/out block of any significance:
        pObj [IN] - The DN of the naming context/cross-ref the user is trying
            to create.
        dwParentDNT [OUT] - See (A) above in desc.
        iBest [PROCESSING] - This is used to track the best matching naming
            context so far between calls to this function.
        fADChildNc [OUT] - See (B) above in desc.

Return Value:

    Error.

--*/
{
    ULONG iCur;
    DSNAME* pNCname = NULL;
    ATTRBLOCK* pNCblock = NULL;
    DWORD cbLen;
    DWORD dwErr;
    BOOL  bEnabled;
    DWORD dwSystemFlags;

    // get the NC name of the current crossref
    if (dwErr = DBGetAttVal(pDB, 1, ATT_NC_NAME, DBGETATTVAL_fREALLOC, 0, &cbLen, (PUCHAR*) &pNCname)) {
        goto cleanup;
    }

    // Convert NC name into block name
    if (dwErr = DSNameToBlockName(pTHS, pNCname, &pNCblock, DN2BN_LOWER_CASE)) {
        goto cleanup;
    }

    iCur = BlockNamePrefix(pTHS, pNCblock, pContext->pObj);
    if (iCur > pContext->iBest) {
        pContext->iBest = iCur;
        pContext->dwParentDNT = pDB->DNT;
    }

    //
    // Check if there exists an child NC cross-ref that is
    // internal to the AD naming space.
    //
    iCur = BlockNamePrefix(pTHS, pContext->pObj, pNCblock);
    if (iCur) {
        dwErr = DBGetSingleValue(pDB,
                                 ATT_ENABLED,
                                 &bEnabled,
                                 sizeof(bEnabled),
                                 NULL);
        if(dwErr == DB_ERR_NO_VALUE){
            // Deal w/ no value seperately, because, no value means TRUE in
            // this context.
            dwErr = 0;
            bEnabled = TRUE;
        } else if (dwErr){
            goto cleanup;
        }

        dwErr = DBGetSingleValue(pDB,
                                 ATT_SYSTEM_FLAGS,
                                 &dwSystemFlags,
                                 sizeof(dwSystemFlags),
                                 NULL);
        if(dwErr == DB_ERR_NO_VALUE){
            // Means systemFlags is zero.
            dwErr = 0;
            dwSystemFlags = 0;
        } else if (dwErr){
            goto cleanup;
        }

        if ( !bEnabled ||
             (dwSystemFlags & FLAG_CR_NTDS_NC) ) {
            // This is an internal child AD Naming Context!!!
            pContext->fADChildNc = TRUE;
        }
    }

cleanup:
    if (pNCname) {
        THFreeEx(pTHS, pNCname);
    }
    if (pNCblock) {
        FreeBlockName(pNCblock);
    }
    return dwErr;
}



int
VerifyNcName(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTRVALBLOCK *pAttrVal,
    ATTCACHE *pAC
    )
{
// Makes subsequent code more readable
#define VNN_OK         Assert(pTHS->errCode == 0); \
                       fNCNameVerified = TRUE; \
                       DPRINT1(1, "Cross Ref nCName Verified OK at DSID-%X\n", DSID(FILENO, __LINE__)); \
                       __leave;
#define VNN_Error      Assert(pTHS->errCode && !fNCNameVerified); \
                       DPRINT1(1, "Cross Ref nCName NOT Verified ... Failure at DSID-%X\n", DSID(FILENO, __LINE__)); \
                       __leave;

    ADDCROSSREFINFO *  pChildCRInfo = hVerifyAtts->pCRInfo;
    DSNAME *           pDN = (DSNAME*)pAttrVal->pAVal->pVal;

    DSNAME *           pDNTmp;
    CROSS_REF *        pParentCR = NULL;
    CROSS_REF_LIST*    pCRL = NULL;
    DWORD              dwErr;
    BOOL               fNCNameVerified = FALSE;
    DBPOS *            pDBTmp = HVERIFYATTS_GET_PDBTMP(hVerifyAtts);
    ULONG              bImmediateChild = FALSE;
    ULONG              bEnabledParentCR;
    unsigned           rdnlen;
    WCHAR              rdnbuf[MAX_RDN_SIZE];
    ATTRTYP            ChildRDNType;
    ATTRTYP            ParentRDNType;
    DSNAME *           pdnImmedParent = NULL;
    GUID               NcGuid;
    ENUMERATE_CROSS_REFS_CONTEXT context;

    Assert(!pTHS->fDRA);
    Assert(!DsaIsInstalling());
    Assert(pChildCRInfo);
    Assert(pDN);

    // The NC name (a.k.a. ATT_NC_NAME or nCName) is a special attribute,
    // because it almost always needs to point to something we don't
    // have.  In this function like its helper PreTransVerifyNcName(),
    // we'll refer to the nCName attr to be added as the child (or child
    // CR), and the enclosing CR (if any) as the parent henceforward.
    // Though the "parent CR" is not necessarily an immediately enclosing
    // parent, 95% of the time this is the case.
    // Further we'll have a concept of internal vs. external CR.  An
    // internal CR will be a CR for a NC that is part of the Active
    // Directory (AD) naming space.  An external CR, will be a CR for
    // some part of the LDAP name space outside the AD.  Finally, we'll
    // also have the concept of inside vs. outside the AD naming space,
    // this is very closely linked to internal vs. external, but usually
    // refers to if whether the parent CR is an internal or external CR.
    // If the parent CR is an internal CR, then the child we're trying to
    // add is being added inside the AD naming space.  If the parent CR is
    // and external CR, then the child we're trying to add is outside the
    // AD naming space.

    // internal vs. external CR (often external CR is known as a foreign CR)
    //            a CR can be internal by either having Enabled == FALSE or
    //            having FLAG_CR_NTDS_NC set in it's systemFlags.
    // inside vs. outside AD naming space
    //            inside if the containing parent CR is an AD CR, else
    //            outside.
    // child vs. parent CR/NC
    //            The child CR (or nCName) is the nCName attribute that we're
    //            currently trying to add.  The Parent CR is what ever CR
    //            contains the child CR.
    // parent obj vs. parent CR/NC
    //            The parent object, is the actual immediate parent object,
    //            The parent CR/NC is just the enclosing CR/NC for the child.
    //            These two are one and the same if bImmediateChild is TRUE.

    //
    //   parent
    //     |-----child (this is what we're adding)
    //             |------grand-child (possible child to CR we're adding)
    //
    // To verify the nCName, we need several pieces of state:
    //
    //    Child DN.                     (pDN)
    //    Child RDNType                 (ChildRDNType)
    //    Child CR enabled attr         (pChildCRInfo->bEnabled)
    //    Child CR systemFlags attr     (pChildCRInfo->ulSysFlags)
    //    Child directly below parent   (bImmediateChild)
    //    Parent Obj instantiated       (bInstantiedParentObj)
    //    Parent RDNType                (ParentRDNType)
    //    Superior CR enabled attr      (bEnabledParentCR)
    //    Superior CR systemFlags       (pParentCR->flags)
    //    Enclosing/Superior Cross-Ref  (pParentCR)
    //    AD Grand Child CR Exists      (context.fADChildNc)
    //
    // NOTE: Deceptively, the "Parent CR" may not actually be a parent, but
    // may be just a superior (great grand parent, etc.)  However, Parent Obj
    // refers to the immediate parent object, not the whatever the parent CR
    // points to.  Of course if bImmediateChild is TRUE, then these are one
    // and the same.  The reason to leave it as Parent, is because in 95% of
    // the cases, this is how you should think of it, so it's reasonable to
    // leave the variable named as parent.
    //
    // NOTE: We do not allow ourselves to add internal cross-refs that have
    // other internal (Active Directory) children cross-refs.  The naming
    // context heirarchy must be built top down.

    // The approximate rules we're trying adhere to goes something like this:
    //
    // A) If the child crossRef is external then it doesn't need follow any
    //    naming conventions.
    // B) If the child crossRef (external or internal) is inside the AD naming
    //    space we need to check it for a conflicting child in the DS, and
    //    that the child is directly below and instantiated object.
    // C) If the child crossRef is internal to the AD and a seperate tree,
    //    then we only need to check that all it's RDNType's conform to the
    //    DC= standard, and that there are no internal children CRs.
    // D) If the child crossRef is internal to the AD, and inside the existing
    //    naming space, then we need to ensure that the crossRef is added
    //      a) Immediately below an instantiated parent NC.
    //      b) if the child RDNType is "DC", then the parent must be "DC=".
    //      c) if the child is a domain CR, then the parent must be a domain CR.
    //      d) must not have a internal child CR.

    // I think this helps clarity, it makes the intention overly clear.
    //
    // VNN_OK;     =  Assert(pTHS->errCode == 0);
    //                fNCNameVerified = TRUE;
    //                <Print out success, and DSID.>;
    //                __leave;
    //
    // VNN_Error;  =  Assert(pTHS->errCode);
    //                <Print out error, and DSID>;
    //                __leave;
    //

    __try {

        //
        // First, some basic setup checks, before we go any further.
        //

        // We expect to have the pChildCRInfo setup by PreTransVerifyNcName().
        if(!pChildCRInfo){
            Assert(!"Why was pChildCRInfo not supplied!?!");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            VNN_Error;
        }

        // This attribute is a single valued attribute.
        if (pAttrVal->valCount != 1) {
            SetAttError(hVerifyAtts->pObj,
                        pAC->id,
                        PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                        NULL,
                        ERROR_DS_SINGLE_VALUE_CONSTRAINT);
            VNN_Error;
        }

        // Perform an otherwise worthless test to make sure that the NCname
        // doesn't match the name of the object being added.  Since the object
        // being added is still mid-addition it's a little flakey to deal with
        // (e.g., it's presently a phantom), and it's easier to screen out
        // this degenerate case now.
        if ( NameMatchedStringNameOnly(hVerifyAtts->pObj, pDN) ) {
            SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                        DIRERR_NAME_REFERENCE_INVALID);
            VNN_Error;
        }

        //
        // Get some Parent CR info.
        //

        context.dwParentDNT = INVALIDDNT;
        context.fADChildNc = FALSE;
        context.iBest = 0;
        if (dwErr = DSNameToBlockName(pTHS, pDN, &context.pObj, DN2BN_LOWER_CASE)) {
            SetUpdErrorEx(UP_PROBLEM_NAME_VIOLATION, DIRERR_NAME_REFERENCE_INVALID, dwErr);
            VNN_Error;
        }
        dwErr = EnumerateCrossRefs(pTHS, pDBTmp, enumerateCrossRefsCallback, &context);
        // we don't need the block name any more
        FreeBlockName(context.pObj);
        if (dwErr) {
            SetUpdErrorEx(UP_PROBLEM_NAME_VIOLATION, ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2, dwErr);
            VNN_Error;
        }

        if(context.dwParentDNT != INVALIDDNT){
            // ok, we found a matching CR. Locate it. Succeeds or excepts.
            DBFindDNT(pDBTmp, context.dwParentDNT);

            // Make a StorableCRL for it
            dwErr = MakeStorableCRL(pTHS, pDBTmp, NULL, &pCRL, NULL);
            if (dwErr) {
                SetUpdErrorEx(UP_PROBLEM_NAME_VIOLATION, ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2, dwErr);
                VNN_Error;
            }
            pParentCR = &pCRL->CR;

            //
            // First a quick degenerate case check.
            //
            if(NameMatchedStringNameOnly(pParentCR->pNC, pDN)){
                // This means that we're trying to add a crossRef for one
                // that already exists, i.e. that the "parent" and "child"
                // CR, are turning out to be one and the same nCName value.
                // This isn't OK.
                SetSvcError(SV_PROBLEM_INVALID_REFERENCE,
                            ERROR_DS_CROSS_REF_EXISTS);
                VNN_Error;
            }

            // 1. bEnabledParentCR
            //
            // We want to know whether the Parent CR is enabled or not
            // so we know whether it's part of the AD naming space.
            //
            if (dwErr = DBGetSingleValue(pDBTmp,
                                         ATT_ENABLED,
                                         &bEnabledParentCR,
                                         sizeof(bEnabledParentCR),
                                         NULL)){
                // By default it's enabled, if the attr is not present.
                Assert(dwErr == DB_ERR_NO_VALUE);
                bEnabledParentCR = TRUE;
            }

            // 2. bImmediateChild
            //
            // Is the Child CR an actual immediate Child of the Parent CR we
            // found.
            //
            pdnImmedParent = THAllocEx(pTHS, pDN->structLen);
            if(TrimDSNameBy(pDN, 1, pdnImmedParent)){
                // If the name isn't root, but still can't be trimmed,
                // then the name passed in must have been junk.  Another,
                // possibility is root, but it can't be root if we found
                // a crossRef above it.
                SetNamError(NA_PROBLEM_BAD_NAME,
                            pDN,
                            DIRERR_BAD_NAME_SYNTAX);
                VNN_Error;
            }
            bImmediateChild = NameMatchedStringNameOnly(pdnImmedParent, pParentCR->pNC);

        }

        // Do some common checks with the dra path. This check needs to
        // happen after the ERROR_DS_CROSS_REF_EXISTS error check above.
        dwErr = VerifyNcNameCommon( pTHS, hVerifyAtts, pAttrVal, pAC );
        if (dwErr) {
            // Thread state error already set
            VNN_Error;
        }

        //
        // Now verify the nCName attr is legal.
        //

        // Note: The only way to leave this function before this point, has been
        // through an error path.
        //
        // With the first two levels of if/else, we seperate this into 4 cases:
        // if(external child CR){
        //     if(under internal parent CR (this means in AD naming space)){
        //     } else { // not under CR or under external parent CR.
        //     }
        // } else { // internal child CR
        //     if(no parent CR){
        //     } else { // Parent CR enclosing
        //     }
        //
        // NOTE: All these tests are in a certain order, do not change
        // the order unless you know what you are doing.


        if(pChildCRInfo->bEnabled == TRUE &&
           !(pChildCRInfo->ulSysFlags & FLAG_CR_NTDS_NC)){

            // The Simple Case:

            // The Child CR is external, i.e. not an AD crossRef.  In this case,
            // we've only need to check if the CR is grafted on inside the current
            // AD naming space, and if so, make sure it doesn't conflict with an
            // existing child object.

            if(pParentCR &&
               ((pParentCR->flags & FLAG_CR_NTDS_NC) || !bEnabledParentCR)){

                // This external child CR that we're trying to add, is hanging off
                // of the AD naming space somewhere.  The only thing left we need
                // to check is that it isn't conflicting with some child somewhere,
                // and that it is parent is instantiated.

                // We need to ensure that the immediate parent object is
                // insantiated above this CR, so there are no holes.
                if(InstantiatedParentCheck(pTHS, pChildCRInfo,
                                           pParentCR, bImmediateChild)){
                    // InstantiatedParentCheck() sets the thstate error.
                    VNN_Error;
                }

                // Check that there is not conflicting child.
                if(ChildConflictCheck(pTHS, pChildCRInfo) ){
                    // ChildConflictCheck() sets the thstate error.
                    VNN_Error;
                }

                VNN_OK;

            } else {

                // It's not internal to the AD naming space at all.  I.e. this
                // child CR is not internal, nor is the parent CR, or there is
                // no parent CR.

                VNN_OK;

            }

            Assert(!"Should never reach here.");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            VNN_Error;

        } else {

            // The Complex Case:

            // The Child CR is internal, i.e. it's an AD crossRef.  In this case,
            // we must apply several tests to verify that it's OK.

            if(!pParentCR){

                // There is no parent CR, meaning this "child CR" is not a child
                // at all, it's actually a new tree.  All we have to do is test
                // that the nCName satisfies the DOMAIN_COMPONENT naming
                // restrictions and we're done.

                if( ValidateDomainDnsName(pTHS, pDN) ){
                    // ValidateDomainDnsName sets it's own errors.
                    VNN_Error;
                }

                // See if we've got an internal grand child CR below us.
                if(context.fADChildNc){
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_EXISTING_AD_CHILD_NC);
                    VNN_Error;
                }

                // New tree domain CR creations should exit here.
                VNN_OK;

            } else {

                // There is a parent CR.  This is also where the most typical
                // CR creations will end up.  This case requires the most
                // verification.

                // To start with we only allow immediate children
                if(!bImmediateChild){
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    VNN_Error;
                }

                // The Parent CR must be a NTDS CR.
                if(!(pParentCR->flags & FLAG_CR_NTDS_NC)){
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    VNN_Error;
                }

                // If child is of type DC, parent must be of type DC.
                if((dwErr = GetRDNInfo(pTHS, pDN, rdnbuf, &rdnlen, &ChildRDNType)) ||
                   (ChildRDNType == ATT_DOMAIN_COMPONENT && (
                        (dwErr = ValidateDomainDnsNameComponent(pTHS, rdnbuf, rdnlen * sizeof(WCHAR))) ||
                        (dwErr = GetRDNInfo(pTHS, pParentCR->pNC, rdnbuf, &rdnlen, &ParentRDNType)) ||
                        ParentRDNType != ATT_DOMAIN_COMPONENT))){
                    // This combined with the ValidateDomainDnsName() function
                    // for new trees, will enforce DC= only naming syntaxes for
                    // all new NCs within the AD.
                    // NOTE: This constraint was not enforced in the previous
                    // version of VerifyNcName().
                    if(dwErr){
                        // Something is wrong with the child CR's last RDN.
                        SetUpdError(UP_PROBLEM_NAME_VIOLATION, dwErr);
                    } else {
                        // We've got a DC component mismatch.
                        SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                    DIRERR_NAME_REFERENCE_INVALID);
                    }

                    VNN_Error;
                }

                // We must have the parent instantiated, to create a child
                // CR.
                if(InstantiatedParentCheck(pTHS, pChildCRInfo,
                                           pParentCR, bImmediateChild)){
                    // We think you should not be allowed to create an AD crossRef
                    // enabled or disabled if the parent NC is not instantiated.
                    // NOTE: This constraint was not enforced in the previous
                    // version of VerifyNcName(), though it was supposed to be.
                    // InstatiatedParentCheck() sets the thstate error.
                    VNN_Error;
                }

                // We need to check that there are no conflicting children.
                if(ChildConflictCheck(pTHS, pChildCRInfo) ){
                    // ChildConflictCheck() sets the thstate error.
                    VNN_Error;
                }

                // If we're adding a Domain CR, make sure the parent is also
                // a domain.
                if( pChildCRInfo->ulSysFlags & FLAG_CR_NTDS_DOMAIN &&
                    !(pParentCR->flags & FLAG_CR_NTDS_DOMAIN) ){
                    // It'd be better to have this exact error, but for domains.
                    SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                                ERROR_DS_NC_MUST_HAVE_NC_PARENT);
                    VNN_Error;
                }

                // Children domain CR creations should exit here.
                VNN_OK;

            }

            Assert(!"Should never reach here either.");
            SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_CODE_INCONSISTENCY);
            VNN_OK;

        }

    } __finally {

        // Either we verified the nCName, or we set an error, because the
        // new nCName broke the rules we require for a valid nCName.
        Assert(fNCNameVerified || pTHS->errCode);

        if ( !fNCNameVerified
            && (pTHS->errCode == 0)) {
            Assert(!"We should never be here, but we've covered our butts.");
            SetUpdError(UP_PROBLEM_NAME_VIOLATION,
                        ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2);
        }

        // We said in PreTransVerifyNcName() that we'd free this here.
        if(hVerifyAtts->pCRInfo){
            if(hVerifyAtts->pCRInfo->wszChildCheck) { THFreeEx(pTHS, hVerifyAtts->pCRInfo->wszChildCheck); }
            THFreeEx(pTHS, hVerifyAtts->pCRInfo);
            hVerifyAtts->pCRInfo = NULL;
        }

        if (pCRL) {
            // release parent CR that we allocated
            FreeCrossRefListEntry(&pCRL);
        }

    }

    // If this DC is in the middle of being demoted, we don't allow
    // cross-refs to be created.
    if (!gUpdatesEnabled) {
        SetSvcError(SV_PROBLEM_UNAVAILABLE, DIRERR_SHUTTING_DOWN);
        return(pTHS->errCode);
    }

    // This is set if we hit an "VNN_OK;"
    if(fNCNameVerified){

        // We need to set the GUID on this nCName attribute.
        Assert(fNullUuid(&pDN->Guid) &&
               "Should not have a GUID specified, unless by user.");
        DsUuidCreate(&pDN->Guid);

    }

#undef VNN_OK
#undef VNN_Error

    return(pTHS->errCode);
}

int
VerifyRidAvailablePool(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    DWORD err;
    ULARGE_INTEGER RidAvailablePool;

    // If it is the RID available pool that is being written then
    // check that the RID available pool is only being rolled forward
    // not rolled back

    Assert(!pTHS->fDRA);
    if (pTHS->fDSA) {
        // No checking for the DS itself
        return 0;
    }

    if ((NULL == pAttrVal) ||
        (1 != pAttrVal->valCount )) {
        //
        // Badly formed input data
        //

        return SetAttError(hVerifyAtts->pObj,
                           pAC->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL,
                           ERROR_DS_SINGLE_VALUE_CONSTRAINT);

    }
    else if (sizeof(LARGE_INTEGER) != pAttrVal->pAVal->valLen) {
        return SetAttError(hVerifyAtts->pObj, pAC->id,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                           ERROR_DS_RANGE_CONSTRAINT);
    }

    if (0 == (err = DBGetSingleValue(pTHS->pDB,
                                     ATT_RID_AVAILABLE_POOL,
                                     &RidAvailablePool,
                                     sizeof(RidAvailablePool),
                                     NULL))) {
        ULARGE_INTEGER * pNewRidAvailablePool=
          (ULARGE_INTEGER *) pAttrVal->pAVal->pVal;

        if ((pNewRidAvailablePool->LowPart < RidAvailablePool.LowPart)
            || (pNewRidAvailablePool->HighPart < RidAvailablePool.HighPart)) {

            //
            // Unsuccessful validation. Fail the call
            //

            return SetAttError(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                               ERROR_DS_RANGE_CONSTRAINT);
        }

        return 0;
    }
    else {
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             DIRERR_DATABASE_ERROR, err);
    }
}

int
VerifyObjectCategory(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    ULONG ObjClass;
    int retCode = 0;
    DSNAME *pDN= (DSNAME *) pAttrVal->pAVal->pVal;
    DBPOS *pDBTmp = HVERIFYATTS_GET_PDBTMP(hVerifyAtts);

    // Object-Category must point to an existing class-schema object
    // (Except during install, but we do not come here during
    // install anyway)

    // The Default-Object-Category attribute on a class-schema object
    // can be set in the addarg. During Install, the attribute can
    // be set to an yet non-existent object, since the class that the
    // attribute is pointing to may not have been created yet (depending
    // on the order in which they are added from schema.ini). However,
    // during normal operation, this attribute is allowed to point to
    // only an exisiting object, or the object being added in this
    // transaction

    if (DBFindDSName(pDBTmp, pDN)) {
        // Not an existing object. Check if it is
        // the current object

        if ((pAC->id != ATT_DEFAULT_OBJECT_CATEGORY)
            || !NameMatched(pDN, hVerifyAtts->pObj)) {

            // Either no default-object-category attribute,
            // or the value is not set to the current object either
            // Something is wrong with this DSName.  I don't
            // care what.  Set an attribute error.
            return SetAttError(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                               DIRERR_NAME_REFERENCE_INVALID);
        }
        // We are here means the current object is added as
        // value for the default-object-category attribute,
        // so it is ok. We don't need to check if this is
        // a class-schema object, since no one else can have
        // default-object-category anyway (and so, if it is
        // on any other type of object, it will be caught later
        // during schema constraint check anyway.
    }
    else {
        // Object exists. Check its object class
        if (DBGetSingleValue(pDBTmp, ATT_OBJECT_CLASS, &ObjClass,
                            sizeof(ObjClass), NULL)
            || (ObjClass != CLASS_CLASS_SCHEMA) ) {
            // either error getting the object class, or it is not
            // a class-schema object
            return SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                               DIRERR_OBJECT_CLASS_REQUIRED);
        }
    }

    return 0;
}

int
VerifyServerPrincipalName(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    ULONG vCount;
    ATTRVAL *pAVal;

    // Validate syntax of SPN
    Assert(!pTHS->fDRA);
    if (pTHS->fDSA) {
        // No checking for the DS itself
        return 0;
    }

    // Set up index pointer.
    pAVal = pAttrVal->pAVal;

    for (vCount = 0; vCount < pAttrVal->valCount; vCount++) {
        LPWSTR pwstrSpn = THAllocEx( pTHS, pAVal->valLen + sizeof(WCHAR) );
        DWORD status;

        // Create a null terminated string from the attribute value
        memcpy( pwstrSpn, pAVal->pVal, pAVal->valLen );
        pwstrSpn[pAVal->valLen / 2] = L'\0';

        // Validate the SPN using this routine from ntdsapi.dll
        status = DsCrackSpnW(
            pwstrSpn,
            NULL, NULL,
            NULL, NULL,
            NULL, NULL,
            NULL
            );

        THFreeEx( pTHS, pwstrSpn );

        if (status != ERROR_SUCCESS) {
            return SetAttError(hVerifyAtts->pObj, pAC->id,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE, NULL,
                               DIRERR_NAME_REFERENCE_INVALID);
        }

        // Next val...
        pAVal++;
    }
    return 0;
}

int
VerifyGenericDsnameAtt(
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    ULONG vCount;
    ATTRVAL *pAVal;
    BOOL fVerified;
    ULONG retCode = 0;
    CROSS_REF *pRefCR;
    DBPOS *pDBTmp = HVERIFYATTS_GET_PDBTMP(hVerifyAtts);
    CROSS_REF *pObjCR;

    if (VerifyAttsGetObjCR(hVerifyAtts, &pObjCR)) {
        Assert(pTHS->errCode);
        return pTHS->errCode;
    }

    // Set up index pointer.
    pAVal = pAttrVal->pAVal;

    // Walk through the values.
    for (vCount = 0; vCount < pAttrVal->valCount; vCount++){
        DSNAME *pDN = DSNameFromAttrVal(pAC, pAVal);

        if (pDN) {
            // Verify that pDN is the name of a real object and improve its
            // GUID/SID.

            // If pDN is a valid name, we impose additional restrictions on
            // which objects can be referenced by which other objects.
            // Specifically, we do not yet have efficient ways to fix up string
            // DNs of objects not held on GCs (i.e., references *to* objects in
            // NDNCs) or to fix up string DNs of objects where no one replica
            // (IM candidate) has only NCs that other replicas of the NC in
            // question are guaranteed to also have (i.e., references *from*
            // objects in NDNCs, since a given NDNC can be hosted by DCs of any
            // domain).
            //
            // Thus we enforce the following rules to ensure the stale phantom
            // cleanup daemon does not need to worry about fixing up references
            // into or out of NDNCs:
            //
            // Objects in NDNCs can reference:
            //      Any object in the same NDNC.
            //      Any object in config/schema.
            //      Any NC root.
            //      (i.e., NOT objects in other NDNCs or domain NCs.)
            //
            // Objects in config/schema/domain NCs can reference:
            //      Any object in any domain NC.
            //      Any object in config/schema.
            //      Any NC root.
            //      (i.e., NOT objects in NDNCs.)
            //
            // As an exception, values of non-replicated linked attributes can
            // reference any object present on the local machine.  (Linked
            // requirement comes from need to be able to efficiently enumerate
            // such references when an NC is removed -- see DBPhysDel.)

            if (DBFindDSName(pDBTmp, pDN)) {
                // Referred-to object is not instantiated in the local database.
                ImproveDSNameAtt(NULL, NONLOCAL_DSNAME, pDN, &fVerified);

                if ( !fVerified ) {
                    // Something is wrong with this DSName.  I don't
                    // care what.  Set an attribute error.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                }

                // The verification cache enforces that the non-local
                // DSNAMEs are not GUID/SID-only.
                Assert(pDN->NameLen);

                pRefCR = FindBestCrossRef(pDN, NULL);

                if (NULL == pRefCR) {
                    // Couldn't find the cross ref normally.  Look in the
                    // transactional view.  Note that we look only for exact
                    // matches -- i.e., we allow adding references to the root
                    // of the NC in the same transaction as the corresponding
                    // crossRef, but not to any interior nodes.  (We could add
                    // such support later if needed, however.)
                    OBJCACHE_DATA *pTemp
                        = pTHS->JetCache.dataPtr->objCachingInfo.pData;

                    while (pTemp) {
                        switch(pTemp->type) {
                        case OBJCACHE_ADD:
                            if (NameMatched(pTemp->pCRL->CR.pNC, pDN)) {
                                Assert(!pRefCR);
                                pRefCR = &pTemp->pCRL->CR;
                            }
                            pTemp = pTemp->pNext;
                            break;
                        case OBJCACHE_DEL:
                            if (pRefCR
                                && NameMatched(pTemp->pDN, pRefCR->pObj)) {
                                pRefCR = NULL;
                            }
                            pTemp = pTemp->pNext;
                            break;
                        default:
                            Assert(!"New OBJCACHE_* type?");
                            pRefCR = NULL;
                            pTemp = NULL;
                        }
                    }
                }

                if (NULL == pRefCR) {
                    // Don't know what NC the referred-to object is in.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                } else if (NameMatched(pRefCR->pNC, pObjCR->pNC)
                           || NameMatched(pRefCR->pNC, gAnchor.pDMD)
                           || NameMatched(pRefCR->pNC, gAnchor.pConfigDN)) {
                    // Referred-to object is in the same NC as the referencing
                    // object or referred-to object is in the config or schema
                    // NCs.  Note that the referred-to object is in an NC that's
                    // instantiated on this DSA but the referred-to object
                    // itself is not present locally.  However, the referred-to
                    // object has been verified by another DSA (a GC or the DSA
                    // given us via the "verify names" control), so the
                    // reference is okay.
                    ;
                } else if (NameMatched(pRefCR->pNC, pDN)) {
                    // Referred-to object is the root of an NC.  These
                    // references are always okay.
                    ;
                } else if (pObjCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
                    // Referring object is in an interior node of an NC not
                    // replicated to GCs (synonymous with an NDNC as of this
                    // writing).  From previous checks we already know that the
                    // referred-to object is an interior node of an NC other
                    // than config, schema, or that of the referring object.
                    // This is not allowed.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                } else if (pRefCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
                    // Referred-to object is in an interior node of an NC not
                    // replicated to GCs (i.e., in an NDNC).  From previous
                    // checks we already know that the referring object is in
                    // an NC that is replicated to GCs (i.e., config, schema,
                    // or a domain NC as of this writing).  This is not allowed.
                    return SetAttError(hVerifyAtts->pObj,
                                       pAC->id,
                                       PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                       NULL,
                                       DIRERR_NAME_REFERENCE_INVALID);
                }

                // Non-local reference is valid.
            }
            else if (pAC->ulLinkID && DBIsObjDeleted(pDBTmp)) {
                // Referred-to object is deleted, which makes it an invalid
                // target for a linked attribute.
                return SetAttError(hVerifyAtts->pObj,
                                   pAC->id,
                                   PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                   NULL,
                                   DIRERR_NAME_REFERENCE_INVALID);
            }
            else {
                // Referred-to object is a live, instantiated object in the
                // local database.  Enforce the rules re cross NC references
                // described above.

                // Not that we attempt to "pass" this check through as
                // many simple cases as we can early on in order to reduce
                // the number of paths where we must pay performance
                // penalties to read additional attributes, perform extra
                // cache lookups, etc.

                if (!(pAC->bIsNotReplicated && pAC->ulLinkID)
                    && (pDBTmp->NCDNT != hVerifyAtts->NCDNT) // may be INVALIDDNT
                    && (pDBTmp->NCDNT != gAnchor.ulDNTDMD)
                    && (pDBTmp->NCDNT != gAnchor.ulDNTConfig)) {
                    // The referred-to object is not an interior node of
                    // the same NC as the referencing object (although
                    // it may be the root of the referencing object's NC)
                    // and is not an interior node of either the config or
                    // schema NC.

                    NAMING_CONTEXT_LIST * pNCL;
                    SYNTAX_INTEGER iType;

                    retCode = GetExistingAtt(pDBTmp,
                                             ATT_INSTANCE_TYPE,
                                             &iType,
                                             sizeof(iType));
                    if (retCode) {
                        Assert(retCode == pTHS->errCode);
                        return retCode;
                    }

                    if (iType & IT_NC_HEAD) {
                        // It's always okay to reference an NC head -- they
                        // can't be renamed, and if they were then that
                        // knowledge would have to published to all DCs in
                        // the forest via the config NC (thus alleviating
                        // the need for the stale phantom cleanup daemon to
                        // query a GC for the name and publish it to the
                        // other replicas).
                        ;
                    } else if (pObjCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
                        // Referring object is in an NC not replicated to GCs
                        // (an NDNC as of this writing) and referred-to object
                        // is an interior node of another NC that is neither
                        // config nor schema.  This is not allowed.
                        return SetAttError(hVerifyAtts->pObj,
                                           pAC->id,
                                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                           NULL,
                                           DIRERR_NAME_REFERENCE_INVALID);
                    } else {
                        // Referring object is in an NC replicated to GCs and
                        // the referred-to object is an interior node of another
                        // NC that is neither config nor schema (i.e., a domain
                        // NC or NDNC).  Referred-to object must be in an NC
                        // that's also replicated to GCs (i.e., a domain NC).
                        pNCL = FindNCLFromNCDNT(pDBTmp->NCDNT, FALSE);
                        Assert(NULL != pNCL);

                        if ((NULL == pNCL)
                            || (NULL
                                == (pRefCR
                                    = FindExactCrossRef(pNCL->pNC, NULL)))
                            || (pRefCR->flags
                                & FLAG_CR_NTDS_NOT_GC_REPLICATED)) {
                            // Failure to resolve NC of the referred-to
                            // object or it's not replicated to GCs.
                            return SetAttError(hVerifyAtts->pObj,
                                               pAC->id,
                                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                               NULL,
                                               DIRERR_NAME_REFERENCE_INVALID);
                        }
                    }
                }

                // Local reference is valid.
                ImproveDSNameAtt(pDBTmp, LOCAL_DSNAME, pDN, NULL);
            }
        }

        // Next val...
        pAVal++;
    }

    // Success!
    return 0;
}



/*++
Routine Description:
    Verify that any Dsname valued atts actually refer to objects in this
    enterprise or meet some constraints if not.

    One special case is for the creation of crossref objects, which by
    necessity must refer to objects that aren't necessarily instantiated.
    We check that the NC-Name on a CrossRef either refers to an object
    outside the scope of our enterprise, or would be the immediate child of
    an object instantiated on this server.  If the NC-Name is a potential
    child of an NC not instantiated on this server, the user will be
    referred to the server holding the best enclosing NC.  If this server
    holds the best enclosing NC, but the NC-Name is not an immediate child
    (i.e., there would be a gap between the subref and its nearest parent),
    an UpdateError(NamingViolation) will be returned.  Additionally, if the
    NC-Name refers to an object instantiated on this server, we will succeed
    if and only if the object referred to is in fact an NC_HEAD.

    THIS ROUTINE MUST EITHER INSURE THE DSNAME'S GUID AND SID ARE CORRECT
    OR NULL THEM OUT SO AS TO AVOID BACK DOOR SETTING OF A PHANTOM'S GUID
    AND SID.  See further comments in ImproveDSNameAtt and
    UpdatePhantomGuidAndSid().

    Simple tests are performed inline, more complex tests are farmed out
    to attribute-specific worker routines.

Arguments:
    pTHS
    hVerifyAtts - handle returned from previous call to VerifyAttsBegin()
    pAC - attcache * of attribute we are trying to write.
    pAttrVal - list of attribute values we are trying to write.

Return Value
    0 if the attribute is not dsname valued OR the dsnames referred to in
        pAttr already exist OR it's an "allowable" phantom.
    non-zero error type code if one of the dsnames referred to does not exist.
        Sets an error in the THSTATE if one is encountered.

--*/
int
VerifyDsnameAtts (
    THSTATE *pTHS,
    HVERIFY_ATTS hVerifyAtts,
    ATTCACHE *pAC,
    ATTRVALBLOCK *pAttrVal
    )
{
    int retCode=0;                      // Assume nothing will go wrong.

    // The DRA may add phantoms, as may anyone at install time
    if (DsaIsInstalling()) {
        return 0;
    }
    if (pTHS->fDRA) {
        // Some special restrictions for the replicator
        switch (pAC->id) {
        case ATT_NC_NAME:
            retCode = VerifyNcNameCommon(pTHS,
                                         hVerifyAtts,
                                         pAttrVal,
                                         pAC);
            break;
        default:
            retCode = 0;
            break;
        }
        return retCode;
    }

    Assert(hVerifyAtts->pObj);

    switch (pAC->id) {
      case ATT_NC_NAME:
        retCode = VerifyNcName(pTHS,
                               hVerifyAtts,
                               pAttrVal,
                               pAC);
        break;

      case ATT_RID_AVAILABLE_POOL:
        retCode = VerifyRidAvailablePool(pTHS,
                                         hVerifyAtts,
                                         pAC,
                                         pAttrVal);
        break;

      case ATT_DEFAULT_OBJECT_CATEGORY:
      case ATT_OBJECT_CATEGORY:
        retCode = VerifyObjectCategory(pTHS,
                                       hVerifyAtts,
                                       pAC,
                                       pAttrVal);
        break;

      case ATT_SERVICE_PRINCIPAL_NAME:
        retCode = VerifyServerPrincipalName(pTHS,
                                            hVerifyAtts,
                                            pAC,
                                            pAttrVal);
        break;

      case ATT_FSMO_ROLE_OWNER:
        // There are two ways that the FSMO role owner attribute can get
        // set: (a) by the DSA itself during a controlled role-transfer
        // operation or (b) in an emergency override where an administrator
        // is whacking the value because the current role-owner is dead,
        // unreachable, or held by hostile forces.  We can detect case (a)
        // by noticing that fDSA is set, and we will trust whatever value
        // the DSA is setting.  For case (b), we're already in dangerous
        // territory, and we want to make sure that the caller puts a useful
        // value in.  Since the only valid value we truly know of at this
        // point is this DSA (i.e., claiming the role-ownership for this
        // server), the DN of this DSA is the only value we'll permit.
        if (pTHS->fDSA ||
            NameMatched((DSNAME*)pAttrVal->pAVal->pVal, gAnchor.pDSADN)) {
            // Either trusted caller or good value.
            retCode= 0;
        }
        else {
            // Someone other than the DSA itself is attempting to set the
            // role owner to something other than this particular DSA.
            retCode = SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                  DIRERR_INVALID_ROLE_OWNER);
        }
        break;

      case ATT_PROXIED_OBJECT_NAME:
        // No external client may set this name.  Only routine which may
        // set this is CreatyProxyObject - and then only with fDSA and
        // fCrossDomainMove set.

        if ( pTHS->fDSA && pTHS->fCrossDomainMove ) {
            retCode = 0;
        }
        else {
            retCode = SetAttError(hVerifyAtts->pObj,
                                  pAC->id,
                                  PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                                  NULL,
                                  DIRERR_NAME_REFERENCE_INVALID);
        }
        break;

        // Attributes with generic checks, but skip them when fDSA
    case ATT_MS_DS_REPLICATES_NC_REASON:
        if (pTHS->fDSA) {
            retCode = 0;
            break;
        }
        // fall through

    default:
        // Check any attribute with a DSNAME buried in it

        switch (pAC->syntax) {
          case SYNTAX_DISTNAME_TYPE:
          case SYNTAX_DISTNAME_STRING_TYPE:
          case SYNTAX_DISTNAME_BINARY_TYPE:
            if ( pTHS->fCrossDomainMove ) {
                // We did the specials checking by ATTRTYP, now we let through
                // everything else if this is a cross domain move.  Cross
                // domain move code before here validated that the caller is a
                // bona fide peer DC, so we will trust that he is giving us
                // good DSNAME references within the enterprise.  We *could*
                // verify DSNAME atts as a separate step before opening the
                // first transaction, but it is simpler, and seemingly safe,
                // to trust our peer.
                retCode = 0;
            }
            else {
                retCode = VerifyGenericDsnameAtt(pTHS,
                                                 hVerifyAtts,
                                                 pAC,
                                                 pAttrVal);
            }
            break;

          default:
            // Not a DSNAME-based attribute
            retCode = 0;
        }
    }

    return retCode;
}


PDSNAME
DSNameFromAttrVal(
    ATTCACHE    *pAC,
    ATTRVAL     *pAVal)

/*++

Description:

    Returns the pointer to an embedded DSNAME or NULL if
    the attribute value doesn't contain a DSNAME.

    This routine expects the values to be in EXTERNAL form.  There is also a routine in
    dbobj.c which handles values in internal form.

Arguments:

    pAC - ATTCACHE pointer for the attribute.

    pAVal - ATTRVAL pointer whose DSNAME we are to extract.

Returns:

    Valid PDSNAME or NULL

--*/

{
    DSNAME  *pDN = NULL;

    switch(pAC->syntax) {
    case SYNTAX_DISTNAME_TYPE:
        // Easy case, the whole value is a dsname.
        pDN = (DSNAME *)pAVal->pVal;
        // Make sure value length makes sense
        Assert(pAVal->valLen >= DSNameSizeFromLen(0));
        break;
    case SYNTAX_DISTNAME_BINARY_TYPE:
    case SYNTAX_DISTNAME_STRING_TYPE:
        {
            // Ok, pull the DSName out of the complex structure.
            SYNTAX_DISTNAME_STRING *pDA =
                (SYNTAX_DISTNAME_STRING *)pAVal->pVal;

            pDN = ((DSNAME *)&pDA->Name);

            // Make sure value is good
            Assert(pDN->structLen >= DSNameSizeFromLen(0));
        }
    }

    return(pDN);
}




//-----------------------------------------------------------------------
//
// Function Name:            WriteSchemaObject
//
// Routine Description:
//
//    Writes to the Schema Object on a Schema Update as a Conflict
//    Resolution Mechanism. Its not the best way but serves the purpose.
//
// Author: RajNath
// Date  : [3/26/1997]
//
// Arguments:
//
//
// Return Value:
//
//    int              Zero On Succeess
//
//-----------------------------------------------------------------------
int
WriteSchemaObject()
{
    DBPOS *pDB;
    DWORD err=0;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    THSTATE *pTHS;
    ULONG cLen;
    UCHAR *pBuf;
    DWORD versionNo, netLong;

    if ( DsaIsInstalling() )
    {
        //
        // not when installing ...
        //
        return 0;
    }

    DBOpen2(TRUE, &pDB);
    Assert(pDB != NULL); // pDB should always be set or DBOpen2 throws exception

    pTHS=pDB->pTHS;
    Assert(!pTHS->fDRA);

    __try  {
        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen2 returns non-NULL pDB or throws an exception
        if ( (err = DBFindDSName(pDB, gAnchor.pDMD)) ==0) {

            ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
            if (ac==NULL) {
                // messed up schema
                err = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }
            // Read the current version no., if any
            err = DBGetAttVal_AC(pDB, 1, ac, DBGETATTVAL_fREALLOC,
                                 0, &cLen, (UCHAR **) &pBuf);
            switch (err) {
                case DB_ERR_NO_VALUE:
                    // first value added
                    cLen = SCHEMA_INFO_PREFIX_LEN + sizeof(versionNo) + sizeof(UUID);
                    pBuf = (UCHAR *) THAllocEx(pTHS, cLen);
                    versionNo = 1;
                    // version no. is stored in network data format for
                    // uniformity across little-endian/big-endian m/cs

                    netLong = htonl(versionNo);
                    memcpy(pBuf,SCHEMA_INFO_PREFIX, SCHEMA_INFO_PREFIX_LEN);
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN],&netLong,sizeof(netLong));
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN+sizeof(netLong)],
                           &pTHS->InvocationID,
                           sizeof(UUID));
                    break;
                case 0:
                    // value exists, length will be the same
                    // version no. is stored in network data format for
                    // uniformity across little-endian/big-endian m/cs. So
                    // convert accordingly (but be careful to be properly
                    // aligned for ntohl!)

                    memcpy(&versionNo, &pBuf[SCHEMA_INFO_PREFIX_LEN], sizeof(versionNo));
                    versionNo = ntohl(versionNo);
                    versionNo++;
                    netLong = htonl(versionNo);
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN],&netLong,sizeof(netLong));
                    memcpy(&pBuf[SCHEMA_INFO_PREFIX_LEN+sizeof(netLong)],
                           &pTHS->InvocationID,
                           sizeof(UUID));
                    break;
                default:
                    // other error
                    __leave;

            }  /* switch */

            if ((err= DBRemAtt_AC(pDB, ac)) != DB_ERR_SYSERROR) {
                err = DBAddAttVal_AC(pDB, ac, cLen, pBuf);
            }

            if (!err) {
                err = DBRepl( pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
            }
        }
        if (0 == err) {
            fCommit = TRUE;
        }

    }
    __finally {
        DBClose(pDB,fCommit);
    }

    if (err){
        // common practice is to return this error when the modification of
        // metadata fails.
        SetSvcErrorEx(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION,
                      err);
    }

    return err;

} // End WriteSchemaObject

VOID ImproveDSNameAtt(
        DBPOS *pDBTmp,
        DWORD   LocalOrNot,
        DSNAME  *pDN,
        BOOL    *pfNonLocalNameVerified)

/*++

Description:

    Improves the GUID and SID of a DSNAME valued attribute.

Arguments:

    pDBTmp - pDB that we used to do a DBFindDSName on the pDN.  Should only be
             NON-NULL in the LocalOrNot == LOCAL_DSNAME case, and in that case,
             currency should be on the object pDN.

    LocalOrNot - Flag indicating locality - eg: did DSNAME pass DBFindDSName.

    pDN - Pointer to DSNAME in the ADDARG or MODIFYARG.  Yes, we are modifying
        the caller's arguments.  See comments below.

    pfNonLocalNameVerified - pointer to optional BOOL which indicates if a
        non-local DSNAME was verified against the GC.

--*/

{
    ENTINF  *pEntinfTmp;
    DSNAME  *pDNTmp = NULL;
    CROSS_REF *pCR;
    COMMARG  CommArg;
    DWORD dwErr;

    switch(LocalOrNot) {
    case NONLOCAL_DSNAME:
        Assert(!pDBTmp);
        pEntinfTmp = GCVerifyCacheLookup(pDN);
        if ((NULL!=pEntinfTmp) && (NULL != (pDNTmp = pEntinfTmp->pName)))  {
            // The non-local name was verified against the GC and we
            // consider the cached version to be better than the
            // ATTRVALBLOCK version because it has the proper GUID and
            // possibly SID.  So overwrite the ATTRVALBLOCK DSNAME with the
            // verified DSNAME to insure that the resulting phantom has the
            // right GUID, SID, casing, etc. Note that the GC verified name
            // may be longer than the ATTRBLOCK version. This may happen if
            // the attrblock version is a SID or a GUID only name, and the
            // GCVerified Version contains the string name also
            Assert(pDNTmp);

        } else {

            // OK, we failed to find this DN in the GC verification cache,
            // but it just so happens that we've got a cache of NC Heads in
            // addition to the GC verification cache.  We'll use this if
            // pDN is an NC head.

            Assert(pDNTmp == NULL);
            InitCommarg(&CommArg);
            CommArg.Svccntl.dontUseCopy = FALSE;
            pCR = FindExactCrossRef(pDN, &CommArg);
            // FindExactCrossRef guarantees that the DN matches ncname
            if(pCR){

                // The object we're Improving is an actual NC Head, so
                // we've got a hit, just a little more verification:
                if(pCR->flags & FLAG_CR_NTDS_DOMAIN &&
                   !fNullUuid(&pCR->pNC->Guid)){
                    // We've got a valid Domain, ie must have GUID & SID.
                    pDNTmp = pCR->pNC;
                }

                if((pCR->flags & FLAG_CR_NTDS_NC) &&
                   !(pCR->flags & FLAG_CR_NTDS_DOMAIN) &&
                   !fNullUuid(&pCR->pNC->Guid)){
                    // We've got a valid NC (Config, Schema, or NDNC),
                    // ie we've got a non-NULL GUID.
                    pDNTmp = pCR->pNC;
                }

            }

        }

        if(pDNTmp){
            // We got a NC Head gAnchor cache hit, so we don't have to
            // error out.

            if (pDN->structLen >= pDNTmp->structLen)
            {
                //
                // if the passed in buffer can hold the
                // DSNAME that we found, copy it over.
                // Mark the name as verified
                //

                memcpy(pDN, pDNTmp, pDNTmp->structLen);
                if ( pfNonLocalNameVerified )
                    *pfNonLocalNameVerified = TRUE;
            }
            else
            {
                //
                // This will happen if the client passed in a
                // GUID only or SID only name and the name in the GC verify
                // cache will also have the string name in it. Unfortunately
                // we cannot improve the DS name Att, because that would make
                // us realloc the callers arguments. Passing in GUID or SID
                // based name is important only for manipulating memberships
                // in groups, and SAM takes care of this case by substituting
                // the verified name while making the modify call. For manipulation
                // of other classes / attributes we will fail the call.
                //
              if ( pfNonLocalNameVerified )
                   *pfNonLocalNameVerified = FALSE;
            }

        } else {

            // We couldn't verify this non-local name in the GCCache.  In order
            // to avoid sneaky attempts to change an object's GUID or SID by
            // referencing it in a DSNAME-valued attribute, null the GUID and
            // SID (non-verified non-local dsname atts shouldn't have SIDs or
            // GUIDs).
            memset(&pDN->Guid, 0, sizeof(GUID));
            pDN->SidLen = 0;
            if ( pfNonLocalNameVerified ){
                *pfNonLocalNameVerified = FALSE;
            }
        }

        break;

    case LOCAL_DSNAME:
        // We have a DSNAME about to be referenced, and that DSNAME can be
        // successfully found via DBFindDSName.  As a matter of fact, we are
        // positioned on the object in question.  Since ExtIntDist will try to
        // reference by GUID, we need to make sure that if there is a GUID on
        // the object, that it is the correct GUID. So, whack the ATTRVALBLOCK
        // value's GUID and SID to be the correct values to avoid sneaky
        // attempts to change an object's GUID or SID by referencing it in a
        // DSNAME-valued attribute.
        Assert(pDBTmp);
        memset(&pDN->Guid, 0, sizeof(GUID));
        pDN->SidLen = 0;
        if (dwErr = DBFillGuidAndSid(pDBTmp, pDN)) {
            // something really bad happened
            DsaExcept(DSA_DB_EXCEPTION, dwErr, 0);
        }
        break;
    default:
        Assert((LOCAL_DSNAME == LocalOrNot) || (NONLOCAL_DSNAME == LocalOrNot));
    }

    return;
}

#if DBG
BOOL CheckCurrency(DSNAME *pShouldBe)
{

    ULONG len;
    DSNAME *pCurObj=0;
    THSTATE     *pTHS = pTHStls;

    DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                0, 0, &len, (CHAR **)&pCurObj);
    if (!NameMatched(pShouldBe, pCurObj)) {
        DPRINT2(0, "Someone lost DB currency, we're on '%S' but should be on '%S'\n",
                pCurObj->StringName, pShouldBe->StringName);
        Assert(!"Currency lost");
        return FALSE;
    }
    if (pCurObj) {
        THFreeEx(pTHS, pCurObj);
    }
    return TRUE;
}
#endif

ULONG
DoSecurityChecksForLocalAdd(
    ADDARG      *pAddArg,
    CLASSCACHE  *pCC,
    GUID        *NewObjectGuid,
    BOOL        fAddingDeleted
    )
/*++

    Routine Description

        This Routine Does all the Security Checks needed for An Add operation.
        It Checks the security on the parent and then checks the Add arg for
        rights on the object. It also calls the routines that will generate a
        merged security descriptor to be used in the Parent.
        Also, as a side effect, it will generate a new GUID for the object and
        store it in the pAddArg->pObject->Guid. If the user has specified a
        GUID as one of the add arguments, then all appropriate security checks 
        are also performed.

    Parameters:

        AddArg         -- Pointer to the Add Arg for the Add Operation
        pCC            -- Class of the object being created
        NewObjectGuid  -- Guid of the new object if found in the addarg (or NULL)
        fAddingDeleted -- TRUE if Adding a Deleted Object.

    Return Values

        0 Upon Success.
        Upon an Error this routine will return the error and also set pTHStls->errCode

--*/
{
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    ULONG                cbNTSD = 0;
    BOOL                 fSDIsGlobalSDRef;
    THSTATE              *pTHS = pTHStls;
    DWORD                err;


    if(NewObjectGuid) {
        // Found a guid in the entry.
        if (fNullUuid(NewObjectGuid)) {
            // Hey, that won't work;
            err = SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               DIRERR_SECURITY_ILLEGAL_MODIFY);
            goto exit;
        }
        else if (fNullUuid(&pAddArg->pObject->Guid)) {
            // No guid specified in the name, so copy the one from the attribute
            // list. 
            memcpy(&pAddArg->pObject->Guid, NewObjectGuid, sizeof(GUID));
        }
        else {
            // Yep, there is a guid in the name already.  Make sure they are the
            // same value.
            if (memcmp(&pAddArg->pObject->Guid, NewObjectGuid, sizeof(GUID))) {
                // Different GUIDs specified.
                err = SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                  DIRERR_SECURITY_ILLEGAL_MODIFY);
                goto exit;
            }
        }
    }
    
    //
    // Generate a New Object GUID for this object. Note doing this
    // here has no real effect on CheckNameForAdd as that function
    // checks both the GUID as well as the string name.
    //

    // This does, however, generate extra work for CheckNameForAdd().  If we
    // create a new GUID for this object, we should pass a flag to
    // CheckNameForAdd() to indicate that it doesn't need to check for GUID
    // uniqueness.
    // Actually, we can't do that safely.  It is possible for an end user to
    // specify a GUID to us.  In that case, we can't actually rely on the fact
    // that just because we created the guid here that it is really not already
    // in use.

    if (fNullUuid(&pAddArg->pObject->Guid)) {
        // If no Guid has been specified, make one up
        // If replicated object doesn't have a guid (could happen in
        // auto-generated subref obj) we shouldn't create one.
        if (!pTHS->fDRA) {
            DsUuidCreate(&pAddArg->pObject->Guid);
        }
    }
    else {
        // We only let important clients (such as the replicator) specify
        // GUIDs, other clients can lump off. If we are creating an NDNC 
        // then we allow the GUID to be specified by the 
        // AddNDNCInitAndValidate() function.
        if (! (pTHS->fDRA                   ||
               pTHS->fDSA                   ||
               pTHS->fAccessChecksCompleted ||
               pTHS->fCrossDomainMove       ||
               fISADDNDNC(pAddArg->pCreateNC)  ||
               IsAccessGrantedAddGuid (pAddArg->pObject,
                                       &pAddArg->CommArg))) {
            err = SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                              DIRERR_SECURITY_ILLEGAL_MODIFY);
            goto exit;
        }
    }

    // Bail if Security Checks have already been done.
    if (pTHS->fAccessChecksCompleted)
        return 0;

    if (!pAddArg->pCreateNC) {
        //
        // Check Security on the Parent
        //
        if (err = CheckParentSecurity(pAddArg->pResParent,
                                      pCC,
                                      fAddingDeleted,
                                      pAddArg->pObject,
                                      &pNTSD,
                                      &cbNTSD,
                                      &fSDIsGlobalSDRef)) {
            goto exit;
        }
    }
    else {
        // We are creating an NC. We DON'T WANT to inherit parent's security.
        // Thus, we are not checking it, and passing NULL parentSD into
        // CreateSecurityDescriptorForNewObject.
    }
    //
    // Replace the security Descriptor on the object with the merged descriptor
    //
    err = CreateSecurityDescriptorForNewObject(
            pTHS,
            pCC,
            pAddArg,
            pNTSD,
            cbNTSD);

exit:
    if (pNTSD && !fSDIsGlobalSDRef) {
        THFreeEx(pTHS, pNTSD);
    }
    if (err) {
        return CheckObjDisclosure(pTHS, pAddArg->pResParent, TRUE);
    }

    return 0;

}

ULONG
CheckRemoveSecurity(
        BOOL fTree,
        CLASSCACHE * pCC,
        RESOBJ *pResObj )
/*++

    Does Security Checks for Removes.

    Actual security checks should be done first so that non security
    errors aren't returned if the client doesn't have permission to perform
    the op.

    Parameters:

        fTree     -- bool, are we trying to delete a whole tree?
        pCC       -- Pointer to the Class Cache

    Return Values
        0 Upon Success.
        Upon an Error this routine will return the error and also set pTHStls->errCode

--*/
{
    THSTATE     *pTHS = pTHStls;
    ULONG       ulSysFlags;

    // Bail if Security Checks have already been done.
    if (pTHS->fAccessChecksCompleted)
        return 0;

    // check if the user is allowed to change an object that is in the
    // configuration NC or schema NC
    if (CheckModifyPrivateObject(pTHS,
                             NULL,
                             pResObj)) {
        // it is not allowed to delete this object on this DC
        return CheckObjDisclosure(pTHS, pResObj, TRUE);
    }


    if(fTree) {
        if (!IsAccessGrantedSimple(RIGHT_DS_DELETE_TREE,TRUE)) {
            return CheckObjDisclosure(pTHS, pResObj, TRUE);
        }
    }
    else {
        // If pTHS->fDeletingTree is set, then we have already checked the permission on the tree root,
        // see the access check just above. So we will only do the first call with AUDIT_ONLY flag.
        // This always returns TRUE, so the second call will never be invoked.
        // FUTURE: in Longhorn, we should include the new DN of the object and the GUID of the
        // new parent (Deleted Objects in most cases). Currently, we don't log this info because
        // it is not yet available this early in the execution path.
        if ((!IsAccessGrantedSimpleEx(
                    RIGHT_DS_DELETE_SELF, 
                    NULL, 
                    NULL,
                    0,
                    NULL,
                    pTHS->fDeletingTree ? CHECK_PERMISSIONS_AUDIT_ONLY : 0, 
                    FALSE))
            && (!IsAccessGrantedParent(RIGHT_DS_DELETE_CHILD,pCC,TRUE))) {

            return CheckObjDisclosure(pTHS, pResObj, TRUE);
        }
    }

    if (!(pTHS->fDSA || pTHS->fDRA)) {
        if(!DBGetSingleValue(pTHS->pDB,
                             ATT_SYSTEM_FLAGS,
                             &ulSysFlags,
                             sizeof(ulSysFlags),
                             NULL)) {
            // We have system flags.
            if(ulSysFlags & FLAG_DISALLOW_DELETE) {
                // We're trying to delete, but the flags say that that is a no
                // no.
                return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                                   DIRERR_CANT_DELETE);
            }
        }
    }


    return 0;
}

ULONG
CheckIfEntryTTLIsAllowed(
        THSTATE *pTHS,
        ADDARG  *pAddArg )
/*++

    Check system flags, delete permission, and NC.

    Parameters:

        pTHS - thread state
        pAddArg - add args

    Return Values
        0 Upon Success.
        Otherwise, pTHS->errCode is set

--*/
{
    ULONG       ulSysFlags;
    CROSS_REF   *pCR;

    // always allowed
    if (DsaIsInstalling() || pTHS->fDRA || pTHS->fDSA) {
        return 0;
    }

    // check system flags for non-deletable object
    if(!DBGetSingleValue(pTHS->pDB,
                         ATT_SYSTEM_FLAGS,
                         &ulSysFlags,
                         sizeof(ulSysFlags),
                         NULL)) {
        // flags disallow delete
        if(ulSysFlags & FLAG_DISALLOW_DELETE) {
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               DIRERR_CANT_DELETE);
        }
    }

    // Not allowed in SchemaNC or ConfigNC
    if (   (pAddArg->pResParent->NCDNT == gAnchor.ulDNTDMD)
        || (pAddArg->pResParent->NCDNT == gAnchor.ulDNTConfig)
        || (pAddArg->pResParent->DNT == gAnchor.ulDNTDMD)
        || (pAddArg->pResParent->DNT == gAnchor.ulDNTConfig)) {
        return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_DS_NOT_SUPPORTED);
    }

    // If not a whistler enterprise, dynamic objects must be in an NDNC
    if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET) {
        pCR = FindBestCrossRef(pAddArg->pObject, NULL);
        if (   !pCR
            || !(pCR->flags & FLAG_CR_NTDS_NC)
            || (pCR->flags & FLAG_CR_NTDS_DOMAIN)) {
            return SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                               ERROR_DS_NOT_SUPPORTED);
        }
    }

    return 0;
}

BOOL
IsAccessGrantedAddGuid (
        PDSNAME pDN,
        COMMARG *pCommArg
        )
{
    CROSS_REF           *pCR = NULL;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    DWORD                ulLen = 0;
    BOOL                 fSDIsGlobalSDRef;
    DSNAME              *pName;
    ATTRTYP              classP;
    CLASSCACHE          *pCC=NULL;
    THSTATE             *pTHS = pTHStls;
    PUCHAR               pVal = (PUCHAR)&classP;
    DWORD                err;
    BOOL                 rtn;

    // First you can only do this if the heuristic has explicitly
    // been set to allow this.
    if (!gbSpecifyGuidOnAddAllowed) {
        return FALSE;
    }

    // Instead of requiring that the add operation is performed on a GC
    // (as we used to), we now do a GCVerify call with the new GUID. This
    // resolves a problem of not being able to create the object if the GC
    // does not hold a writable replica of the NC being written to.
    // Note: pDN contains the GUID being added, and GCVerifyCacheLookup
    // always uses the GUID lookup if there is a guid in the dsname.
    if (GCVerifyCacheLookup(pDN) != NULL) {
        // name was verified on a GC! No, we can not add
        // this object then.
        return FALSE;
    }

    // Find the best cross reference for this name
    pCR = FindBestCrossRef(pDN, pCommArg);
    if(!pCR) {
        return FALSE;
    }

    pName = pCR->pNC;
    if(DBFindDSName(pTHS->pDB, pName)) {
        // Couldn't find that name
        return FALSE;
    }

    // Get the security descriptor and object class
    err = DBGetObjectSecurityInfo(pTHS->pDB, pTHS->pDB->DNT,
                                  &ulLen, &pNTSD, &pCC,
                                  NULL, NULL,
                                  DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                                  &fSDIsGlobalSDRef
                                 );
    if (err || ulLen == 0) {
        return FALSE;
    }

    rtn = IsControlAccessGranted(pNTSD,
                                 pName,
                                 pCC,
                                 RIGHT_DS_ADD_GUID,
                                 FALSE);
    if (!fSDIsGlobalSDRef && pNTSD) {
        THFreeEx(pTHS, pNTSD);
    }

    return rtn;
}


VOID
ModCrossRefCaching(
    THSTATE *pTHS,
    CROSS_REF *pCR
    )

/*++

Routine Description:

Queue this up as if it were a modObjCaching of
a cross ref.  In order to do that, we must open a new
DBPOS, position on the CR object, remove and add its
object caching, and then go back to the old DBPOS to
hide what we just did from callers.

Arguments:

    pTHS -
    pCR - Cross reference object being refreshed

Return Value:

    None

--*/

{
    DWORD err;
    DBPOS *pDBtmp, *pDBsafe;
    CLASSCACHE *pCrossRefCC;
    RESOBJ DummyRes;
    DSNAME *pCRName;

    DBOpen2(FALSE, &pDBtmp);
    pDBsafe = pTHS->pDB;
    pTHS->pDB = pDBtmp;
    __try {
        err = DBFindDSName(pDBtmp, pCR->pObj);
        if (err) {
            __leave;
        }

        pCRName = THAllocOrgEx(pTHS, pCR->pObj->structLen);
        memcpy(pCRName, pCR->pObj, pCR->pObj->structLen);

        DummyRes.pObj = pCRName;
        pCrossRefCC = SCGetClassById(pTHS, CLASS_CROSS_REF);
        PREFIX_ASSUME(pCrossRefCC, "base classes are always present in schema");

        DelObjCaching (pTHS, pCrossRefCC, &DummyRes, FALSE);

        err = AddObjCaching(pTHS, pCrossRefCC, pCRName, FALSE, FALSE);
        if(!err) {
            // Keep track of the DN of the object also, since we
            // use the existance of the DN on an ADD record to
            // trigger us to notify LSA.
            OBJCACHE_DATA *pObjData =
                pTHS->JetCache.dataPtr->objCachingInfo.pData;

            Assert(pObjData);
            // The AddObjCaching will have put its transactional
            // data at the end of the queue, so we must walk
            // to the end of the list to find it.
            while (pObjData->pNext) {
                pObjData = pObjData->pNext;
            }
            Assert(pObjData->type == OBJCACHE_ADD);
            pObjData->pDN = pCRName;
        }
    } __finally {
        DBClose(pDBtmp, TRUE);
        pTHS->pDB = pDBsafe;
    }

} /* ModCrossRefCaching */


/* HandleDNRefUpdateCaching
 *
 * This routine gets passed in the name of a InfrastructureUpdate object
 * that is being added (presumably replicated in).  We must check to see
 * if the reference update it's carrying is the name of an NC, and if so,
 * whether our cross-ref cache for that NC is missing data (specifically
 * the GUID and/or SID of the NC).  If so, we need to update the cache.
 * We do that by finding the name of the CrossRef object corresponding
 * to the NC and refreshing its object caching data.  Oh, and we have to
 * do all of this without affecting database currency.
 */
void
HandleDNRefUpdateCaching (
        THSTATE *pTHS
        )
{
    DWORD len;
    DWORD err;
    DSNAME *pRef = NULL;
    COMMARG FakeCommArg;
    CROSS_REF *pCR = NULL;

    len = 0;
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_DN_REFERENCE_UPDATE,
                      0,
                      0,
                      &len,
                      (UCHAR **)&pRef);
    if (0 == err) {
        // First check: is this reference an ncname?
        InitCommarg(&FakeCommArg);
        Assert(!FakeCommArg.Svccntl.dontUseCopy); // read-only is okay
        pCR = FindExactCrossRef(pRef, &FakeCommArg);
        if ( pCR ) {
            // Yes, it's a cross ref.

            // Ok the reference is an nc name - does the in memory
            // version need  improving?
            if(   (fNullUuid(&pCR->pNC->Guid) &&
                   !fNullUuid(&pRef->Guid))
               || ((0 == pCR->pNC->SidLen) &&
                   (0 < pRef->SidLen) ) ) {

                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_DN_REF_UPDATE,
                         szInsertDN(pCR->pObj),
                         szInsertDN(pCR->pNC),
                         szInsertUUID(&(pRef->Guid)) );

                ModCrossRefCaching( pTHS, pCR );
            }
        }
    }
}


/* The following data structure is used to hold the data required
   when doing ValidateSPNsAndDnsHostName() */
typedef struct {
    ATTRVALBLOCK *pOriginalDNSHostName;             // the original DNS Host Name
    ATTRVALBLOCK *pOriginalAdditionalDNSHostName;   // the original additional DNS Host Name
    ATTRVALBLOCK *pOriginalSamAccountName;          // the original SamAccountName
    ATTRVALBLOCK *pOriginalSPNs;                    // the original ServicePricipalName
    ATTRVALBLOCK *pCurrentDNSHostName;              // the current DNS Host Name
    ATTRVALBLOCK *pCurrentAdditionalDNSHostName;    // the current Additional DNS Host Name
    ATTRVALBLOCK *pCurrentSamAccountName;           // the current SamAccountName
    ATTRVALBLOCK *pCurrentAdditionalSamAccountName; // the current addtional Sam Account Name
    ATTRVALBLOCK *pCurrentSPNs;                     // the current ServicePricipalName
    ATTRVALBLOCK *pCurrentSvrRefBL;                 // the current SvrRefBL;
    ATTRVALBLOCK *pUpdatedAdditionalSamAccountName; // the updated AdditionalSamAccountName;
    BYTE         *pOrgMask;                         // An array of flags for Original AdditionalDNSHostName
    BYTE         *pCurrMask;                        // An array of flags for Current AdditionalDNSHostName
    ATTRVAL      *pOrgGeneratedSamAccountName;      // The Sam Account Names generated from original AdditionalDnsHostName
    ATTRVAL      *pCurrGeneratedSamAccountName;     // The Sam Account Names generated from current AdditionalDnsHostName
    BOOL         fAdditionalDNSHostNameUnchanged:1; // if the AdditionalDNSHostName is changed
    BOOL         fDNSHostNameUnchanged:1;           // if the DnsHostName is changed
    BOOL         fSamAccountNameUnchanged:1;        // if the SamAccountName is changed
} SPN_DATA_COLLECTION;


DWORD VerifyUniqueSamAccountName ( THSTATE      *pTHS,
                                   WCHAR        *SamAccountNameToCheck,
                                   DWORD        cbSamAccountNameToCheck,
                                   ATTRVALBLOCK *pCurrentSamAccountName )

/* verify if the given SamAccountName is unique domainwise in the space
   of ATT_SAM_ACCOUNT_NAME and ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
   However, we allow the SamAccountName to be the same as the
   ATT_SAM_ACCOUNT_NAME of the same account.

   Parameters:
     SamAccountNameToCheck:    the SamAccountName to verify;
     cbSamAccountNameToCheck:  the size of SamAccountNameToCheck in byte;
     pCurrentSamAccountName:   the SamAccountName of the current object;

   Return value:
    0 if success; win32 error otherwise.

*/

{
    DWORD err = 0;
    FILTER SamAccountNameFilter, OrFilter, AdditionalSamAccountNameFilter;
    BOOL fSamAccountSame = FALSE;
    PWCHAR buff;

    BOOL fDSASave;
    DBPOS *pDBSave;

    SEARCHARG SearchArg;
    SEARCHRES SearchRes;

    Assert(1==pCurrentSamAccountName->valCount);

    //
    // check if SamAccountNameToCheck is the same as the current SamAccountName
    //

    if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            (WCHAR*)pCurrentSamAccountName->pAVal->pVal,
                            pCurrentSamAccountName->pAVal->valLen/sizeof(WCHAR),
                            SamAccountNameToCheck,
                            cbSamAccountNameToCheck/sizeof(WCHAR) ) ) {
          fSamAccountSame = TRUE;
    }

    // add '$' to the end
    buff = (PWCHAR)THAllocEx(pTHS, cbSamAccountNameToCheck+sizeof(WCHAR));
    memcpy(buff, SamAccountNameToCheck, cbSamAccountNameToCheck);
    buff[cbSamAccountNameToCheck/sizeof(WCHAR)] = L'$';

    //save current DBPOS etc
    fDSASave = pTHS->fDSA;
    pDBSave  = pTHS->pDB;

    __try {
        memset(&SearchArg,0,sizeof(SearchArg));
        SearchArg.pObject = gAnchor.pDomainDN;
        SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
        SearchArg.bOneNC  = TRUE;

        // set search filters
        // (ATT_SAM_ACCOUNT_NAME=samAccountName || ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME=samAccountName)
        memset(&OrFilter,0, sizeof(OrFilter));
        OrFilter.choice = FILTER_CHOICE_OR;
        OrFilter.FilterTypes.Or.pFirstFilter = &SamAccountNameFilter;

        memset(&SamAccountNameFilter,0,sizeof(SamAccountNameFilter));
        SamAccountNameFilter.choice = FILTER_CHOICE_ITEM;
        SamAccountNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        SamAccountNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_SAM_ACCOUNT_NAME;
        SamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = cbSamAccountNameToCheck+sizeof(WCHAR);
        SamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)buff;
        SamAccountNameFilter.pNextFilter = &AdditionalSamAccountNameFilter;

        memset(&AdditionalSamAccountNameFilter,0,sizeof(AdditionalSamAccountNameFilter));
        AdditionalSamAccountNameFilter.choice = FILTER_CHOICE_ITEM;
        AdditionalSamAccountNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        AdditionalSamAccountNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME;
        AdditionalSamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = cbSamAccountNameToCheck+sizeof(WCHAR);
        AdditionalSamAccountNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*)buff;

        SearchArg.pFilter = &OrFilter;

        InitCommarg(&SearchArg.CommArg);

        //return two objects only
        SearchArg.CommArg.ulSizeLimit = 2;

        memset(&SearchRes,0,sizeof(SearchRes));


        //open another DBPOS
        pTHS->pDB = NULL;
        DBOpen(&(pTHS->pDB));

        __try {

            if (err = DBFindDSName(pTHS->pDB,SearchArg.pObject)) {
                __leave;
            }

            SearchArg.pResObj = CreateResObj(pTHS->pDB,SearchArg.pObject);

            if (err = LocalSearch(pTHS,&SearchArg,&SearchRes,0)){
                __leave;
            }

            // it fails if 1 ) we got two objects, or  2) one object and the
            // samAccountNameToCheck is different from pCurrentSamAccountName.
            if (   SearchRes.count > 1
                || (SearchRes.count > 0 && !fSamAccountSame ) ) {
                err = ERROR_DS_NAME_NOT_UNIQUE;
                __leave;
            }

        }
        __finally {
            // faster to commit a read transaction than rollback
            DBClose(pTHS->pDB, TRUE);
        }
    }
    __finally{
        //restore the saved value
        pTHS->pDB = pDBSave;
        pTHS->fDSA = fDSASave;
        THFreeEx(pTHS, buff);
    }

    return err;
}

DWORD SpnCase( WCHAR * pServiceName,
               DWORD cchServiceName,
               WCHAR * pInstanceName,
               DWORD cchInstanceName,
               WCHAR * pDNSHostName,
               DWORD cchDNSHostName,
               WCHAR * pSamAccountName,
               DWORD cchSamAccountName )
/* This function will try to match the service name and
instance name of the spn with the dnshostname and samaccountname.
It returns:
0  -- no match;
1  -- the instance name of the SPN matches the DNSHostName.
2  -- the service name of the SPN matches the DNSHostName.
3  -- both the service name and the instance name of the SPN
      matches the DNSHostName.
4  -- the SPN is two-part, and matches the samAccountName

Parameters:
    pServiceName  :  the service name part of the spn;
    cchServiceName:  the length of pServiceName in char;
    pInstanceName :  the instance name part of the spn;
    cchInstanceName: the lenght of pInstanceName in char;
    pDNSHostName  :  the DNS Host name to match;
    cchDNSHostName:  the length of pDNSHostName in char;
    pSamAccountName: the SamAccountName to match;
    cchSamAccountName: the length of pSamAccountName in char.

Return value:
    see above
*/
{

    DWORD switchFlags = 0;
    // First, check for the sam account name case
    if(
       (2 == CompareStringW(DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            pServiceName,
                            cchServiceName - 1,
                            pInstanceName,
                            cchInstanceName - 1)) &&
       // Yep, this is a 'two-part-spn' where part 2 and 3 of the
       // cracked SPNs are the same.  This might be affected.
       (2 == CompareStringW(DS_DEFAULT_LOCALE,
                            DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                            pSamAccountName,
                            cchSamAccountName,
                            pInstanceName,
                            cchInstanceName - 1))) {
        switchFlags = 4;
    }
    else {
        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pDNSHostName,
                               cchDNSHostName,
                               pInstanceName,
                               cchInstanceName - 1)) {
            switchFlags = 1;
        }

        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pDNSHostName,
                               cchDNSHostName,
                               pServiceName,
                               cchServiceName - 1)) {
            switchFlags |= 2;
        }

    }
    return switchFlags;
}


BOOL  SpnInsertIntoAddList( THSTATE      * pTHS,
                            BOOL         fAddToNewList,
                            WCHAR        * pNewSpn,
                            DWORD        cbNewSpn,
                            ATTRVALBLOCK * pCurrentSPNs,
                            ATTRVAL      ** ppNewSpnList,
                            DWORD        * pcNewSpnList,
                            DWORD        * pcAllocated,
                            BYTE         * pSPNMask )

/* Insert an SPN into the pNewSpnList, but first
we will check:
    1. if the SPN is already in pCurrentSPNs, if so, mark it as
       "don't delete" in the flag array pSPNMask;
    2. if it is already in pNewSpnList;
    3. if all of the above fails, and fAddToNewList is set, we will
       add it into pNewSpnList, allocate more memory if necessary.

Parameters:
   pTHS :          the thread state;
   fAddToNewList:  whether or not to add the object to the list;
   pNewSpn:        the new spn to add;
   cbNewSpn:       the length of the spn in byte;
   pCurrentSPNs:   the ATTRVALBLOCK that holds the current SPNs;
   ppNewSpnList:    the spns to add;
   pcNewSpnList:   how many items in pNewSpnList;
   pcAllocated :   the number of slots allocated;
   pSPNMask:       the flags for the current SPNs.

Return value:
  TRUE  : if the new spn is added into the list;
  FALSE : otherwise.
*/

{
    DWORD i;

    //check if the new SPN is already in the pCurrentSPNs
    for (i=0; i<pCurrentSPNs->valCount; i++) {

        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pNewSpn,
                               cbNewSpn/sizeof(WCHAR),
                               (WCHAR*)pCurrentSPNs->pAVal[i].pVal,
                               pCurrentSPNs->pAVal[i].valLen/sizeof(WCHAR))) {
            pSPNMask[i] |= 0x2;   //"don't delete"
            return FALSE;
        }

    }

    if (!fAddToNewList) {
        return FALSE;
    }

    //check if the new SPN is already in pNewSpnList
    for (i=0; i<*pcNewSpnList; i++) {

        if(2 == CompareStringW(DS_DEFAULT_LOCALE,
                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                               pNewSpn,
                               cbNewSpn/sizeof(WCHAR),
                               (WCHAR*)(*ppNewSpnList)[i].pVal,
                               (*ppNewSpnList)[i].valLen/sizeof(WCHAR))) {

            return FALSE;
        }

    }

    Assert(*pcNewSpnList<=*pcAllocated);

    //allocate memory if necessary
    if (*pcNewSpnList==*pcAllocated) {
        *ppNewSpnList = THReAllocEx(pTHS,*ppNewSpnList,sizeof(ATTRVAL)*((*pcAllocated)+16));
        *pcAllocated += 16;
    }

    // add it to the list
    (*ppNewSpnList)[*pcNewSpnList].pVal = (UCHAR*)pNewSpn;
    (*ppNewSpnList)[*pcNewSpnList].valLen = cbNewSpn;
    (*pcNewSpnList)++;

    return TRUE;

}


DWORD
FixupSPNsOnComputerObject (
        THSTATE *pTHS,
        DSNAME *pDN,
        CLASSCACHE *pCC,
        SPN_DATA_COLLECTION * pDataSet
)

/*++
  Update SPNs:  delete those obsolete values, and add new ones.

Parameters:
  pDN: the DN of the computer object;
  pCC: classcache of the class of the object being changed;
  pDataSet: pointer to the all necessary data.

Return value:
    0 on success; win32 error otherwise.
--*/
{
    DWORD i;
    DWORD err = 0;
    DWORD len, cbVal;
    ATTCACHE *pAC = SCGetAttById(pTHS, ATT_SERVICE_PRINCIPAL_NAME);
    WCHAR *pCurrentHostName;
    USHORT InstancePort;
    WCHAR  *pServiceClass, *pServiceName, *pInstanceName;
    DWORD  cchServiceClass, cchServiceName, cchInstanceName;
    WCHAR  *pNewVal;
    DWORD  cbNewVal;
    DWORD  switchFlags;
    WCHAR *pNewDNSHostName=NULL;
    DWORD  cchNewDNSHostName=0;
    WCHAR *pOldDNSHostName=NULL;
    DWORD  cchOldDNSHostName=0;
    WCHAR *pNewSamAccountName=NULL;
    DWORD  cchNewSamAccountName=0;
    WCHAR *pOldSamAccountName=NULL;
    DWORD  cchOldSamAccountName=0;

    BYTE * pCurrentSPNMask = NULL;
    DWORD  cNewSpnList = 0;
    ATTRVAL *pNewSpnList = NULL;
    DWORD  cAllocated = 0;
    DWORD iOrg, iCurr;
    DWORD result;
    BOOL  fAdded;
    BOOL  fSkipDNSHostName, fSkipSamAccountName;

    Assert(pAC);

    if(!pDataSet->pCurrentSPNs ||
       pDataSet->pCurrentSPNs->valCount == 0) {
        // No SPNs, nothing to fix.
        return 0;
    }

    // Get the DNS host Names.
    if(pDataSet->pCurrentDNSHostName) {
        if(pDataSet->pCurrentDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewDNSHostName = pDataSet->pCurrentDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pNewDNSHostName =  (WCHAR *)pDataSet->pCurrentDNSHostName->pAVal->pVal;
    }

    if(pDataSet->pOriginalDNSHostName) {
        if(pDataSet->pOriginalDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchOldDNSHostName = pDataSet->pOriginalDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pOldDNSHostName =  (WCHAR *)pDataSet->pOriginalDNSHostName->pAVal->pVal;
    }

    // Get the SAM account Names.
    if(pDataSet->pCurrentSamAccountName) {
        if(pDataSet->pCurrentSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewSamAccountName = (pDataSet->pCurrentSamAccountName->pAVal->valLen/sizeof(WCHAR));
        pNewSamAccountName =  (WCHAR *)pDataSet->pCurrentSamAccountName->pAVal->pVal;
    }

    if(pDataSet->pOriginalSamAccountName) {
        if(pDataSet->pOriginalSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchOldSamAccountName = (pDataSet->pOriginalSamAccountName->pAVal->valLen / sizeof(WCHAR));
        pOldSamAccountName =  (WCHAR *)pDataSet->pOriginalSamAccountName->pAVal->pVal;
    }

    // skip checking DNSHostName(SamAccountName) if
    // 1) DNSHostName(SamAccountName) is not changed
    // or 2) either original or new DNSHostName(SamAccountName)
    // is empty.

    fSkipDNSHostName = pDataSet->fDNSHostNameUnchanged || !pOldDNSHostName || !pNewDNSHostName;

    fSkipSamAccountName = pDataSet->fSamAccountNameUnchanged || !pOldSamAccountName || !pNewSamAccountName;

    //
    // if none of the additionalDnsHostName, dnsHostName, or SamAccountName is changed,
    // we don't need to go into this time-comsuming process.
    //

    if (   pDataSet->fAdditionalDNSHostNameUnchanged
        && fSkipDNSHostName
        && fSkipSamAccountName )
    {
        return 0;
    }

    //
    // allocate an array of flags for the SPNs. Later, we will mark 0x1 bitwise to indicate
    // this item will be deleted; and mark 0x2 bitwise to indicate "don't delete" this item.
    // At the end, only those with flag==1 will be deleted.
    //
    pCurrentSPNMask = THAllocEx(pTHS,pDataSet->pCurrentSPNs->valCount*sizeof(BYTE));

    //pre-allocate some space for the new SPNs
    cAllocated = 32;
    pNewSpnList = THAllocEx(pTHS,sizeof(ATTRVAL)*cAllocated);

    len = 256;
    pServiceClass = THAllocEx(pTHS, len);
    pServiceName  = THAllocEx(pTHS, len);
    pInstanceName = THAllocEx(pTHS, len);

    // Now, loop over the SPNs
    for(i=0;i<pDataSet->pCurrentSPNs->valCount;i++) {

        if((pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR)) > len ) {
            // Need to grow the buffers.
            len = pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR);
            pServiceClass = THReAllocEx(pTHS, pServiceClass, len);
            pServiceName  = THReAllocEx(pTHS, pServiceName, len);
            pInstanceName = THReAllocEx(pTHS, pInstanceName, len);
        }

        cchServiceClass = len/sizeof(WCHAR);
        cchServiceName = len/sizeof(WCHAR);
        cchInstanceName = len/sizeof(WCHAR);

        //  Break into components
        err = DsCrackSpnW((WCHAR *)pDataSet->pCurrentSPNs->pAVal[i].pVal,
                          &cchServiceClass, pServiceClass,
                          &cchServiceName,  pServiceName,
                          &cchInstanceName, pInstanceName,
                          &InstancePort);

        if(err) {
            // Huh?
            goto cleanup;
        }

        // let's see which case it matches.
        switchFlags = SpnCase( pServiceName,
                               cchServiceName,
                               pInstanceName,
                               cchInstanceName,
                               pOldDNSHostName,
                               cchOldDNSHostName,
                               pOldSamAccountName,
                               cchOldSamAccountName );

        switch(switchFlags) {
        case 0:
            //
            // Case 0: the SPN does not match anything for
            // primary DNSHostName or primary SamAccountName.
            // We will do a search on all the deleted values of
            // the original additionalDNSHostName, if the SPN matches
            // either the dns name or its derived samAccountName, We
            // marked as 'delete'(0x1 bitmask).
            //
            if (!pDataSet->fAdditionalDNSHostNameUnchanged) {

                for(iOrg=0; iOrg<pDataSet->pOriginalAdditionalDNSHostName->valCount; iOrg++)
                {
                    if (!pDataSet->pOrgMask[iOrg]) {
                        result =  SpnCase( pServiceName,
                                           cchServiceName,
                                           pInstanceName,
                                           cchInstanceName,
                                           (WCHAR*)pDataSet->pOriginalAdditionalDNSHostName->pAVal[iOrg].pVal,
                                           pDataSet->pOriginalAdditionalDNSHostName->pAVal[iOrg].valLen/sizeof(WCHAR),
                                           (WCHAR*)pDataSet->pOrgGeneratedSamAccountName[iOrg].pVal,
                                           pDataSet->pOrgGeneratedSamAccountName[iOrg].valLen/sizeof(WCHAR) );
                        if (result) {
                            // mark it as "delete"
                            pCurrentSPNMask[i] |= 0x1;
                            break;

                        }

                    }
                }
            }
            break;
        case 1:
            //
            // Case 1: the instance name of the SPN matches the
            // primary DNSHostName. We will replace the SPN
            // with one with the new DNSHostName is necessary.
            // And we will construct such a SPN for every newly
            // added value in additionalDNSHostName.
            //
            if (fSkipDNSHostName){
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // the DNS_HOST_NAME is changed.

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pServiceName,
                                      pNewDNSHostName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                    goto cleanup;
                }

                //mark old one as deleted
                pCurrentSPNMask[i] |= 0x1;

                //insert the new one into the list
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               &pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );
                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }

            for (iCurr=0; iCurr<pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pServiceName,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                      goto cleanup;
                 }



                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                // (Because the user may have deleted it intentionally.)
                fAdded = SpnInsertIntoAddList( pTHS,
                                               !pDataSet->pCurrMask[iCurr],
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               &pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );
                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }

                pNewVal = NULL;
                cbNewVal = 0;
            }
            break;


        case 2:
            //
            // Case 2: the service name of the SPN matches the
            // primary DNSHostName. We will replace the SPN
            // with one with the new DNSHostName is necessary.
            // And we will construct such a SPN for each newly
            // added value in additionalDNSHostName.
            //

            if (fSkipDNSHostName) {
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // DNS_HOST_NAME is changed.

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pNewDNSHostName,
                                      pInstanceName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                      goto cleanup;
                }


                //mark old one as deleted
                pCurrentSPNMask[i] |= 0x1;

                //insert the new one
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               &pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );
                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }

                pNewVal = NULL;
                cbNewVal = 0;
             }

            //add new spns generated from ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME

            for (iCurr = 0; iCurr < pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      pInstanceName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                      goto cleanup;
                }


                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                //(Because the user may have deleted it intentionally.)

                fAdded = SpnInsertIntoAddList( pTHS,
                                               !pDataSet->pCurrMask[iCurr],
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               &pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }
            break;


        case 3:
            //
            // Case 3: both the service name and the instance name
            // of the SPN matches the primary DNSHostName. We will replace the SPN
            // with one with the new DNSHostName is necessary.
            // And we will construct such a SPN for each newly
            // added value in additionalDNSHostName.
            //
            if(fSkipDNSHostName){
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // DNS_HOST_NAME is changed.
                err = WrappedMakeSpnW(pTHS,
                                     pServiceClass,
                                     pNewDNSHostName,
                                     pNewDNSHostName,
                                     InstancePort,
                                     NULL,
                                     &cbNewVal,
                                     &pNewVal);
                if(err) {
                  goto cleanup;
                }

                // delete the old one
                pCurrentSPNMask[i] |= 0x1;

                // add the new one
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               &pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }

            //add new spns generated from ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME

            for (iCurr = 0; iCurr < pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {
                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                  goto cleanup;
                }

                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                // (Because the user may have deleted it intentionally.)
                fAdded = SpnInsertIntoAddList( pTHS,
                                               !pDataSet->pCurrMask[iCurr],
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               &pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;


            }
            break;

        case 4:
            //
            // Case 4: the SPN matches the primary samAccountName.
            // We will replace the SPN
            // with one with the new samAccountName is necessary.
            // And we will make sure that the SPN that contains
            // non-deleted additionalSamAccountName won't be deleted.
            // We also construct such a SPN for each newly
            // added value in additionalDNSHostName.
            //

            if (fSkipSamAccountName) {
                // make sure this one won't be deleted.
                pCurrentSPNMask[i] |= 0x2;
            }
            else {
                // SAM_ACCOUNT_NAME is changed
                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      pNewSamAccountName,
                                      pNewSamAccountName,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                    goto cleanup;
                }

                // delete the old one
                pCurrentSPNMask[i] |= 0x1;

                // add the new one
                fAdded = SpnInsertIntoAddList( pTHS,
                                               1,
                                               pNewVal,
                                               cbNewVal,
                                               pDataSet->pCurrentSPNs,
                                               &pNewSpnList,
                                               &cNewSpnList,
                                               &cAllocated,
                                               pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;

            }

            // for each newly added AdditionalDNSHostName,
            // use its derived samAccountName to construct spn.
            for (iCurr=0; iCurr<pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++) {

                err = WrappedMakeSpnW(pTHS,
                                      pServiceClass,
                                      (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                      (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                      InstancePort,
                                      NULL,
                                      &cbNewVal,
                                      &pNewVal);
                if(err) {
                  goto cleanup;
                }


                // if the dnshostname is newly added, always add the spn;
                // if the dnshostname is not changed, mark the corresponding
                // spn as "don't delete", but don't add the spn if it is not there.
                // (Because the user may have deleted it intentionally.)
                fAdded = SpnInsertIntoAddList(pTHS,
                                              !pDataSet->pCurrMask[iCurr],
                                              pNewVal,
                                              cbNewVal,
                                              pDataSet->pCurrentSPNs,
                                              &pNewSpnList,
                                              &cNewSpnList,
                                              &cAllocated,
                                              pCurrentSPNMask );

                if (!fAdded) {
                    THFreeEx(pTHS,pNewVal);
                }
                pNewVal = NULL;
                cbNewVal = 0;
            }

            break;

        default:
            Assert(!"You can't get here!\n");
            err = DB_ERR_UNKNOWN_ERROR;
            goto cleanup;
        }

     } //for


    // delete all the values marked "delete"(1) only
    for (i=0;i<pDataSet->pCurrentSPNs->valCount; i++) {
        if (1 == pCurrentSPNMask[i]) {
            DBRemAttVal_AC(pTHS->pDB,
                           pAC,
                           pDataSet->pCurrentSPNs->pAVal[i].valLen,
                           pDataSet->pCurrentSPNs->pAVal[i].pVal);
        }
    }


    // add new values
    for(i=0;i<cNewSpnList;i++) {
        if(!err) {
            err = DBAddAttVal_AC(pTHS->pDB,
                                 pAC,
                                 pNewSpnList[i].valLen,
                                 pNewSpnList[i].pVal);
            if(err == DB_ERR_VALUE_EXISTS) {
                err = 0;
                continue;
            }
            if (err) {
                goto cleanup;
            }
        }

    }


cleanup:

    for(i=0;i<cNewSpnList;i++) {
        THFreeEx(pTHS, pNewSpnList[i].pVal);
    }

    THFreeEx(pTHS, pNewSpnList);
    THFreeEx(pTHS,pCurrentSPNMask);

    if( pServiceClass ) THFreeEx(pTHS, pServiceClass);
    if( pServiceName ) THFreeEx(pTHS, pServiceName);
    if( pInstanceName ) THFreeEx(pTHS, pInstanceName);

    return err;
}



DWORD
SPNValueCheck (
        THSTATE *pTHS,
        SPN_DATA_COLLECTION * pDataSet
        )
/*++
  Description:
      Look at the value of the current ATT_SERVICE_PRINCIPAL_NAME attribute.
      Make sure that
      1) Only two part SPNs have been added or removed.
      2) If an SPN has been added or removed, it references the DNS name
         described in the original or final value of the DNS_HOST_NAME
         attribute.
         -- OR --
         it references the original or final value of ATT_SAM_ACCOUNT_NAME
            of the machine.
         -- OR --
         it references the original/final values of ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
            or ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.


  Parameters:
      pTHS - thread state to use.
      pDataSet - the collection of data.

  Return value:
       0 on success, non-zero on failure.

--*/
{
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD rtn;
    DWORD minCount = 0;
    BOOL  fFound;
    BOOL *pIsInCurrent=NULL;
    DWORD err;
    USHORT InstancePort;
    DWORD  len;
    WCHAR  *pVal;
    WCHAR  *pServiceClass, *pServiceName, *pInstanceName;
    DWORD  cchServiceClass, cchServiceName, cchInstanceName;
    WCHAR  *pNewDNSHostName = NULL;
    DWORD  cchNewDNSHostName = 0;
    WCHAR  *pNewSamAccountName = NULL;
    DWORD  cchNewSamAccountName = 0;
    WCHAR  *pOldDNSHostName = NULL;
    DWORD  cchOldDNSHostName = 0;
    WCHAR  *pOldSamAccountName = NULL;
    DWORD  cchOldSamAccountName = 0;
    DWORD  OriginalSPNCount;
    DWORD  CurrentSPNCount;
    BOOL   fLegal;

    if(!pDataSet->pOriginalSPNs && !pDataSet->pCurrentSPNs) {
        // No change to SPNs
        return 0;
    }

    // Get the DNSHostNames. Check that we do indeed have a DNSHostNames.
    if(pDataSet->pCurrentDNSHostName) {
        if(pDataSet->pCurrentDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewDNSHostName = pDataSet->pCurrentDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pNewDNSHostName =  (WCHAR *)pDataSet->pCurrentDNSHostName->pAVal->pVal;
    }

    if(pDataSet->pOriginalDNSHostName) {
        if(pDataSet->pOriginalDNSHostName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }


        // OK, get simpler variables to it.
        cchOldDNSHostName = pDataSet->pOriginalDNSHostName->pAVal->valLen / sizeof(WCHAR);
        pOldDNSHostName =  (WCHAR *)pDataSet->pOriginalDNSHostName->pAVal->pVal;
    }

    // Get the SamAccountNames. Check that we do indeed have a DNSHostNames.
    if(pDataSet->pCurrentSamAccountName) {
        if(pDataSet->pCurrentSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }

        // OK, get simpler variables to it.
        cchNewSamAccountName = pDataSet->pCurrentSamAccountName->pAVal->valLen / sizeof(WCHAR);
        pNewSamAccountName =  (WCHAR *)pDataSet->pCurrentSamAccountName->pAVal->pVal;
    }

    if(pDataSet->pOriginalSamAccountName) {
        if(pDataSet->pOriginalSamAccountName->valCount != 1) {
            // Huh?
            return DB_ERR_UNKNOWN_ERROR;
        }


        // OK, get simpler variables to it.
        cchOldSamAccountName = pDataSet->pOriginalSamAccountName->pAVal->valLen / sizeof(WCHAR);
        pOldSamAccountName =  (WCHAR *)pDataSet->pOriginalSamAccountName->pAVal->pVal;
    }

    if(!cchOldDNSHostName && !cchNewDNSHostName &&
       !cchOldSamAccountName && !cchNewSamAccountName) {
        // No values anywhere
        return DB_ERR_NO_VALUE;
    }



    // The usual scenario for deltas is that something has been added to the end
    // of the list of things in the pCurrentSPNs, and perhaps something has been
    // removed from the pCurrentSPNs in the middle.  The following algorithm is
    // efficient for that data pattern.

    OriginalSPNCount = (pDataSet->pOriginalSPNs?pDataSet->pOriginalSPNs->valCount:0);
    CurrentSPNCount =  (pDataSet->pCurrentSPNs?pDataSet->pCurrentSPNs->valCount:0);

    pIsInCurrent = THAllocEx(pTHS, OriginalSPNCount * sizeof(DWORD));



    i=0;
    len = 128;
    pServiceClass = THAllocEx(pTHS, len);
    pServiceName  = THAllocEx(pTHS, len);
    pInstanceName = THAllocEx(pTHS, len);
    while(i < CurrentSPNCount) {
        Assert(pDataSet->pCurrentSPNs);
        j = minCount;
        fFound = FALSE;
        while(!fFound && (j < OriginalSPNCount)) {
            Assert(pDataSet->pOriginalSPNs);

            rtn = CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 (WCHAR *)pDataSet->pCurrentSPNs->pAVal[i].pVal,
                                 pDataSet->pCurrentSPNs->pAVal[i].valLen /sizeof(WCHAR),
                                 (WCHAR *)pDataSet->pOriginalSPNs->pAVal[j].pVal,
                                 pDataSet->pOriginalSPNs->pAVal[j].valLen /sizeof(WCHAR));

            if(rtn == 2) {
                // Found it.
                fFound = TRUE;
                pIsInCurrent[j] = TRUE;
                break;
            }
            j++;
        }


        if(!fFound) {
            // Have a value in the new list that wasnt in the old list.  Verify
            // it.

            if(len <  (pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR))) {
                // Make sure the buffers are long enough.
                len           = pDataSet->pCurrentSPNs->pAVal[i].valLen + sizeof(WCHAR);
                pServiceClass = THReAllocEx(pTHS, pServiceClass, len);
                pServiceName  = THReAllocEx(pTHS, pServiceName, len);
                pInstanceName = THReAllocEx(pTHS, pInstanceName, len);
            }

            cchServiceClass = len/sizeof(WCHAR);
            cchServiceName = len/sizeof(WCHAR);
            cchInstanceName = len/sizeof(WCHAR);
            //  Break into components
            err = DsCrackSpnW((WCHAR *)pDataSet->pCurrentSPNs->pAVal[i].pVal,
                              &cchServiceClass, pServiceClass,
                              &cchServiceName,  pServiceName,
                              &cchInstanceName, pInstanceName,
                              &InstancePort);

            if(err) {
                // Huh?  Just bail
                return err;
            }
            // Only two part SPNs are legal.  Thus pServiceName == pInstanceName
            rtn = CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 pServiceName,
                                 cchServiceName,
                                 pInstanceName,
                                 cchInstanceName);

            if(rtn != 2) {
                // Not a legal change.
                THFreeEx(pTHS, pIsInCurrent);
                return 1;
            }

            // Only changes that map to the current or old dnshostname or the
            // current or old SAM Account name are legal.
            if(   (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewDNSHostName,
                                       cchNewDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new dns host name.  How about the old one?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldDNSHostName,
                                       cchOldDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the old dns host name either.  How about the new sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewSamAccountName,
                                       cchNewSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new sam account name either.  How about the old sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldSamAccountName,
                                       cchOldSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))) {

                // Let's check the current AdditionaldnshostName and additionalSamAccountName

                fLegal = FALSE;

                // check in the original additionaldnshostname
                if (pDataSet->pOriginalAdditionalDNSHostName) {
                    for ( k=0; !fLegal && k < pDataSet->pOriginalAdditionalDNSHostName->valCount; k++) {
                      if ( 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                               (WCHAR*)pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].pVal,
                                               pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                               pInstanceName,
                                               cchInstanceName))
                      {
                          // yes it is legal
                          fLegal = TRUE;
                      }

                    }
                }


                // check in the current additionaldnshostname list, see if it matches any newly added name
                if (!pDataSet->fAdditionalDNSHostNameUnchanged
                    && pDataSet->pCurrentAdditionalDNSHostName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalDNSHostName->valCount; k++) {
                        if (!pDataSet->pCurrMask[k]     //only the newly added ones
                            && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                                   (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].pVal,
                                                   pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                                   pInstanceName,
                                                   cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                    }
                }

                //check in the currentAdditionalSamAccountName list
                if (pDataSet->pCurrentAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }

                //check in the updatedAdditionalSamAccountName list
                if ( !pDataSet->fAdditionalDNSHostNameUnchanged
                     && pDataSet->pUpdatedAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pUpdatedAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }


               if (!fLegal) {
                   // Nope, not a valid name.
                   THFreeEx(pTHS, pIsInCurrent);
                   return 1;

               }

            }

            // OK, this is a legal change.

        }
        else {
            if(j == minCount) {
                minCount++;
            }
        }
        i++;
    }

    // Now, look through the originals for values not found in the current list
    for(i=minCount;i<OriginalSPNCount;i++) {
        Assert(pDataSet->pOriginalSPNs);
        if(!pIsInCurrent[i]) {
            // A value in the original is not in the current.
            if(len <  (pDataSet->pOriginalSPNs->pAVal[i].valLen + sizeof(WCHAR))) {
                // Make sure the buffers are long enough.
                len           = pDataSet->pOriginalSPNs->pAVal[i].valLen + sizeof(WCHAR);
                pServiceClass = THReAllocEx(pTHS, pServiceClass, len);
                pServiceName  = THReAllocEx(pTHS, pServiceName, len);
                pInstanceName = THReAllocEx(pTHS, pInstanceName, len);
            }

            cchServiceClass = len/sizeof(WCHAR);
            cchServiceName = len/sizeof(WCHAR);
            cchInstanceName = len/sizeof(WCHAR);
            //  Break into components
            err = DsCrackSpnW((WCHAR *)pDataSet->pOriginalSPNs->pAVal[i].pVal,
                              &cchServiceClass, pServiceClass,
                              &cchServiceName,  pServiceName,
                              &cchInstanceName, pInstanceName,
                              &InstancePort);

            if(err) {
                // Huh?  Just bail
                return err;
            }
            // Only two part SPNs are legal.  Thus pServiceName == pInstanceName
            rtn = CompareStringW(DS_DEFAULT_LOCALE,
                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                 pServiceName,
                                 cchServiceName,
                                 pInstanceName,
                                 cchInstanceName);

            if(rtn != 2) {
                // Not a legal change.
                THFreeEx(pTHS, pIsInCurrent);
                return 1;
            }

            // Only changes that map to the current or old dnshostname or the
            // current or old SAM Account name are legal.
            if(   (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewDNSHostName,
                                       cchNewDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new dns host name.  How about the old one?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldDNSHostName,
                                       cchOldDNSHostName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the old dns host name either.  How about the new sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pNewSamAccountName,
                                       cchNewSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))
               // Not the new sam account name either.  How about the old sam
               // account name?
               && (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                       pOldSamAccountName,
                                       cchOldSamAccountName,
                                       pInstanceName,
                                       cchInstanceName))) {


                // Let's check the current AdditionaldnshostName and additionalSamAccountName

                fLegal = FALSE;

                // check in the original additionaldnshostname
                if (pDataSet->pOriginalAdditionalDNSHostName) {
                    for ( k=0; !fLegal && k < pDataSet->pOriginalAdditionalDNSHostName->valCount; k++) {
                      if ( 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                               (WCHAR*)pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].pVal,
                                               pDataSet->pOriginalAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                               pInstanceName,
                                               cchInstanceName))
                      {
                          // yes it is legal
                          fLegal = TRUE;
                      }

                    }
                }

                // check in the current additionaldnshostname list, compare those newly added ones only
                if (!pDataSet->fAdditionalDNSHostNameUnchanged
                    && pDataSet->pCurrentAdditionalDNSHostName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalDNSHostName->valCount; k++) {
                        if (!pDataSet->pCurrMask[k]
                            && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                                   (WCHAR*)pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].pVal,
                                                   pDataSet->pCurrentAdditionalDNSHostName->pAVal[k].valLen/sizeof(WCHAR),
                                                   pInstanceName,
                                                   cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                    }
                }

                //check in the currentAdditionalSamAccountName list
                if (pDataSet->pCurrentAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pCurrentAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pCurrentAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }

                //check in the updatedAdditionalSamAccountName list
                if (!pDataSet->fAdditionalDNSHostNameUnchanged
                    && pDataSet->pUpdatedAdditionalSamAccountName) {
                    for (k=0; !fLegal && k<pDataSet->pUpdatedAdditionalSamAccountName->valCount; k++) {
                        if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                           DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                           (WCHAR*)pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].pVal,
                                           pDataSet->pUpdatedAdditionalSamAccountName->pAVal[k].valLen/sizeof(WCHAR),
                                           pInstanceName,
                                           cchInstanceName))
                        {
                            // yes it is legal
                            fLegal = TRUE;
                        }

                   }
                }


               if (!fLegal) {
                   // Nope, not a valid name.
                   THFreeEx(pTHS, pIsInCurrent);
                   return 1;

               }


            }
            // OK, this is a legal change.
        }
    }

    THFreeEx(pTHS, pIsInCurrent);

    // We didn't fail out before now, so any changes found were legal.
    return 0;
}


DWORD
DNSHostNameValueCheck (
        THSTATE *pTHS,
        ATTRVALBLOCK *pCurrentDNSHostName,
        ATTRVALBLOCK *pCurrentSamAccountName
        )
/*++
  Description:
      Look at the value of the current DNS Host name.  Make sure that it is the
      concatenation of ATT_SAM_ACCOUNT_NAME with the '$' removed, and one of the
      allowed DNS suffixes (the DNS address of the domain is always the first
      allowed suffix -- see RebuildAnchor)

  Parameters:
      pTHS - thread state to use.
      pCurrentDNSHostName - an attrvalblock containing the current dns host
             name.

  Return value:
       0 on success, non-zero on failure.

--*/
{
    DWORD err, cbSamAccountName;
    WCHAR *pSamAccountName, *pTemp;
    WCHAR *pNext;
    DWORD cbComputerName;
    DWORD cbNewHostName;
    WCHAR *pNewHostName;
    PWCHAR *curSuffix;
    BOOL matchingSuffixFound;

    // Check that we do indeed have a DNSHostName.
    if(!pCurrentDNSHostName ||
       pCurrentDNSHostName->valCount != 1 ||
       ! pCurrentDNSHostName->pAVal->valLen ) {
        // No value for DNSHost name.  Fail
        return DB_ERR_NO_VALUE;
    }

    // Check that we do indeed have a SamAccountName.
    if(!pCurrentSamAccountName ||
       pCurrentSamAccountName->valCount != 1 ||
       ! pCurrentSamAccountName->pAVal->valLen ) {
        // No value for Sam Account name.  Fail
        return DB_ERR_NO_VALUE;
    }


    // OK, get simpler variables to it.
    cbNewHostName = pCurrentDNSHostName->pAVal->valLen;
    pNewHostName =  (WCHAR *)pCurrentDNSHostName->pAVal->pVal;

    // NOTE: we expect the caller to have already stripped the '$'
    cbSamAccountName = pCurrentSamAccountName->pAVal->valLen;
    pSamAccountName = (WCHAR *)pCurrentSamAccountName->pAVal->pVal;

    
    // get the computer name part from the dns host name
    pNext = wcschr(pNewHostName,L'.');
    cbComputerName = pNext?(pNext-pNewHostName)*sizeof(WCHAR):cbNewHostName;
    
    if (cbComputerName < sizeof(WCHAR)) {
         return STATUS_INVALID_COMPUTER_NAME;

    }
          
    // make sure the value == SamAccountName - $
    err = CompareStringW(DS_DEFAULT_LOCALE,
                         DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                         pSamAccountName,
                         cbSamAccountName/sizeof(WCHAR),
                         pNewHostName,
                         cbComputerName/sizeof(WCHAR));

    if(err != 2) {
        return DB_ERR_UNKNOWN_ERROR;
    }


    // The right hand side (everything after the first ".") of the new DHN
    // and the old DHN are the same as the DNS name of the domain. Get pTemp to
    // point to the right place in the buffer holding the current DNSHostName.
    pTemp = pNewHostName;
    while(*pTemp != 0 && *pTemp != L'.') {
        pTemp++;
    }
    if(*pTemp == 0) {
        return DB_ERR_UNKNOWN_ERROR;
    }

    pTemp++;

    // try to find a matching DNS suffix
    Assert(gAnchor.allowedDNSSuffixes);
    matchingSuffixFound = FALSE;
    for (curSuffix = gAnchor.allowedDNSSuffixes; *curSuffix != NULL; curSuffix++) {
        if (DnsNameCompare_W(pTemp, *curSuffix)) {
            matchingSuffixFound = TRUE;
            break;
        }
    }
    if(!matchingSuffixFound) {
        return DB_ERR_UNKNOWN_ERROR;
    }

    return 0;
}


DWORD
AdditionalDNSHostNameValueCheck (
        THSTATE *pTHS,
        ATTRVALBLOCK *pCurrentAdditionalDNSHostName,
        BYTE * pMask
        )
/*++
  Description:
      Look at the values of the current Additional DNS Host name.  Make sure that its
      suffix matches one of the allowed DNS suffixes (the DNS address of the domain
      is always the first allowed suffix -- see RebuildAnchor)

  Parameters:
      pTHS - thread state to use.
      pCurrentAdditionalDNSHostName - an attrvalblock containing the current additional
             dns host name.
      pMask - the mask for additional dns host name, only those with !pMask[i] will be checked


  Return value:
       0 on success, non-zero on failure.

--*/
{
    WCHAR *pTemp;
    PWCHAR *curSuffix;
    BOOL matchingSuffixFound;
    DWORD i;

    for ( i=0; i<pCurrentAdditionalDNSHostName->valCount; i++ ) {
        if (!pMask[i]) {
            //new item
            pTemp = (WCHAR*)pCurrentAdditionalDNSHostName->pAVal[i].pVal;
            while(*pTemp != 0 && *pTemp != L'.') {
                pTemp++;
            }
            if(*pTemp == 0) {
                return DB_ERR_UNKNOWN_ERROR;
            }

            pTemp++;
            matchingSuffixFound = FALSE;

            for (curSuffix = gAnchor.allowedDNSSuffixes; *curSuffix != NULL; curSuffix++) {
                if (DnsNameCompare_W(pTemp, *curSuffix)) {
                    matchingSuffixFound = TRUE;
                    break;
                }
            }
            if (!matchingSuffixFound) {
                return DB_ERR_UNKNOWN_ERROR;
            }
        }

    }

    return 0;
}

DWORD
FixupServerDnsHostName(
    THSTATE         *pTHS,                  // required
    ATTCACHE        *pAC_DHS,               // required
    ATTCACHE        *pAC_BL,                // required
    ATTRVALBLOCK    *pCurrentSvrRefBL,      // required
    ATTRVALBLOCK    *pOriginalDNSHostName,  // may be NULL
    ATTRVALBLOCK    *pCurrentDNSHostName    // may be NULL
    )
/*++

  Description:

    If ATT_DNS_HOST_NAME has changed AND (ATT_SERVER_REFERENCE_BL exists
    OR has changed) AND it references an object in the config container,
    update that object's ATT_DNS_HOST name property if it is derived from
    CLASS_SERVER.

  Arguments:

    pTHS - Valid THSTATE.

    pAC_DHS - ATTCACHE entry for ATT_DNS_HOST_NAME.

    pAC_BL - ATTCACHE entry for ATT_SERVER_REFERENCE_BL.

    pCurrentScrRefBL - Post-update value of computer's server reference BL.

    pOriginalDNSHostName - Pre-update value of computer's DNS host name.

    pCurrentDNSHostName - Post-update value of computer's DNS host name.

  Return Values:

    pTHS->errCode

--*/
{
    // See if we need to update ATT_DNS_HOST_NAME on the related
    // CLASS_SERVER object.

    DWORD       i, dwErr = 0;
    ATTRVAL     *pOriginalDHS = NULL;
    ATTRVAL     *pCurrentDHS = NULL;
    ATTRVAL     *pCurrentBL = NULL;
    CROSS_REF   *pCR;
    COMMARG     commArg;
    ATTRTYP     attrTyp;
    CLASSCACHE  *pCC;
    BOOL        fBlIsServer = FALSE;
    DBPOS       *pDB = NULL;
    BOOL        fCommit = FALSE;
    BOOL        fChanged = FALSE;

    Assert(pTHS && pAC_DHS && pAC_BL && pCurrentSvrRefBL);
    Assert((ATT_DNS_HOST_NAME == pAC_DHS->id) && (pAC_DHS->isSingleValued));
    Assert(ATT_SERVER_REFERENCE_BL == pAC_BL->id);

    if ( pOriginalDNSHostName ) {
        pOriginalDHS = (ATTRVAL *) pOriginalDNSHostName->pAVal;
    }

    if ( pCurrentDNSHostName ) {
        pCurrentDHS = (ATTRVAL *) pCurrentDNSHostName->pAVal;
    }

    if ( pCurrentSvrRefBL ) {
        pCurrentBL = (ATTRVAL *) pCurrentSvrRefBL->pAVal;
    }

    if (    (!pOriginalDHS &&  pCurrentDHS)
         || ( pOriginalDHS && !pCurrentDHS)
         || ( pOriginalDHS &&  pCurrentDHS &&
              (2 != CompareStringW(DS_DEFAULT_LOCALE,
                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                   (WCHAR *) pOriginalDHS->pVal,
                                   pOriginalDHS->valLen / sizeof(WCHAR),
                                   (WCHAR *) pCurrentDHS->pVal,
                                   pCurrentDHS->valLen / sizeof(WCHAR))) ) ) {
        // Something has changed - now see if the ATT_SERVER_REFERENCE_BL
        // we need to chase is in the config container.

        InitCommarg(&commArg);
        pCR = FindBestCrossRef((DSNAME *) pCurrentBL->pVal, &commArg);

        if (    pCR
             && gAnchor.pConfigDN
             && NameMatched(pCR->pNC, gAnchor.pConfigDN) ) {

            // Check whether the BL object is derived from CLASS_SERVER
            // and write the new value if required.  We do this in a new,
            // nested transaction so as not to disturb the existing DBPOS
            // in terms of positioning nor DBRepl state/requirements.

            DBOpen2(TRUE, &pDB);
            __try {
                // Since we're checking against the config container which
                // we know is local and since this is a back link, we
                // definitely expect the object to be found.
                if (    (dwErr = DBFindDSName(pDB,
                                              (DSNAME *) pCurrentBL->pVal))
                     || (dwErr = DBGetSingleValue(pDB, ATT_OBJECT_CLASS,
                                                  &attrTyp, sizeof(attrTyp),
                                                  NULL))
                     || !(pCC = SCGetClassById(pTHS, attrTyp)) ) {

                    // If !dwErr then this was the !pCC case.
                    if ( !dwErr ) {
                        dwErr = DIRERR_INTERNAL_FAILURE;
                    }
                    LogUnhandledError(dwErr);
                    SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                    __leave;
                }

                // Check for CLASS_SERVER.
                if ( CLASS_SERVER == pCC->ClassId ) {
                    fBlIsServer = TRUE;
                } else {
                    for ( i = 0; i < pCC->SubClassCount; i++ ) {
                        if ( CLASS_SERVER == pCC->pSubClassOf[i] ) {
                            fBlIsServer = TRUE;
                            break;
                        }
                    }
                }

                if ( !fBlIsServer ) {
                    // Nothing to do.
                    __leave;
                }

                // We are positioned on the object pointed to by
                // ATT_SERVER_REFERENCE_BL and all checks have been
                // satisfied.  Now update its ATT_DNS_HOST_NAME.
                // Keep in ming that pOriginalDHS represents the original
                // value on the computer object.  I.e. We do not know
                // whether the server object currently has a value.

                if ( pCurrentDHS ) {
                    if ( dwErr = DBReplaceAtt_AC(pDB, pAC_DHS,
                                                 pCurrentDNSHostName,
                                                 &fChanged) ) {
                        SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
                        __leave;
                    }
                } else {


                    dwErr = DBRemAtt_AC(pDB, pAC_DHS);
                    if ( (dwErr != DB_success) && (dwErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST) ) {
                        SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
                        __leave;
                    }
                }

                if ( dwErr = DBRepl(pDB, FALSE, 0, NULL,
                                    META_STANDARD_PROCESSING) ) {
                    SetSvcErrorEx(SV_PROBLEM_BUSY, ERROR_DS_BUSY, dwErr);
                    __leave;
                }

                fCommit = TRUE;
            } __finally {
                DBClose(pDB, fCommit);
            }
        }
    }

    return(pTHS->errCode);
}

DWORD FixupAdditionalSamAccountName(  THSTATE      *pTHS,
                                      ATTCACHE     *pAC,
                                      SPN_DATA_COLLECTION * pDataSet )
/* This function will do:
    1. if a new value is added to ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME, we
       will check if the corresponding SamAccountName name is unique in
       the domain, and if yes add the samAccountName into
       ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME attribute.

    2. if a value of ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME is deleted, and no
       other value in ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME corresponds to its
       SamAccountName, the SamAccountName will be deleted from
       ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.

   Parameters:
    pAC:     the ATTCACHE pointer for ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME;
    pDataSet: all the necessary data;

   Return value: 0 on success; win32 error otherwise.

*/
{

    DWORD i, j, iCurr;
    DWORD err = 0;
    BYTE * pSamAccountNameMask  = NULL;
    ATTRVAL * pNewSamAccountName = NULL;
    DWORD cNewSamAccountName = 0;
    BOOL fFound;
    PWCHAR buff;

    //
    // Allocate an array of flags for pCurrentAdditionalSamAccountName list.
    // In the rest of this function, each value in pCurrentadditionalSamAccountName
    // will be examined and those that have corresponding DNSHostNames in
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME will be marked "don't delete"(2).
    // Those unmarked will be deleted from ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
    //
    if (pDataSet->pCurrentAdditionalSamAccountName->valCount) {
        pSamAccountNameMask=
            THAllocEx(pTHS, sizeof(BYTE)*pDataSet->pCurrentAdditionalSamAccountName->valCount);
    }

    //
    // Allocate some space to store the values to be added to additionalsamAccountName.
    // A new SamAccountName will be be stored here temporily, and at the end, they
    // will be added to ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME attribute.
    //
    if (pDataSet->pCurrentAdditionalDNSHostName->valCount) {
        pNewSamAccountName =
            THAllocEx(pTHS,sizeof(ATTRVAL)*pDataSet->pCurrentAdditionalDNSHostName->valCount);
    }

    //
    // Loop over the current values in ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
    //
    for( iCurr = 0; iCurr < pDataSet->pCurrentAdditionalDNSHostName->valCount; iCurr++ )
    {
        fFound = FALSE;

        //
        // Search in the current values of ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME
        //
        for (j = 0; j < pDataSet->pCurrentAdditionalSamAccountName->valCount; j++) {

            if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                    pDataSet->pCurrGeneratedSamAccountName[iCurr].valLen/sizeof(WCHAR),
                                    (WCHAR*)pDataSet->pCurrentAdditionalSamAccountName->pAVal[j].pVal,
                                    pDataSet->pCurrentAdditionalSamAccountName->pAVal[j].valLen/sizeof(WCHAR)) ) {

                // Already there, mark it as "don't delete",
                // So this item will not be deleted later.
                pSamAccountNameMask[j] |= 0x2;
                fFound = TRUE;
                break;
            }
        }

        //  Yes, the value exists.
        //  Try next one.
        if (fFound) {
            continue;
        }

        // Let's try to find it in the new samAccountName list
        for (i=0; i<cNewSamAccountName; i++) {
            if (2 == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                    pDataSet->pCurrGeneratedSamAccountName[iCurr].valLen/sizeof(WCHAR),
                                    (WCHAR*)pNewSamAccountName[i].pVal,
                                    pNewSamAccountName[i].valLen/sizeof(WCHAR) ) ) {
                fFound = TRUE;
                break;

            }
        }

        // Yes, it is already in the new samAccountName list
        // try next one.
        if (fFound) {
            continue;
        }

        //
        // This is a new value.  Before we add it into the list,
        // Let's check if it is unique domainwise in the space
        // of ATT_SAM_ACCOUNT_NAME and ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
        //
        err = VerifyUniqueSamAccountName( pTHS,
                                          (WCHAR*)pDataSet->pCurrGeneratedSamAccountName[iCurr].pVal,
                                          pDataSet->pCurrGeneratedSamAccountName[iCurr].valLen,
                                          pDataSet->pCurrentSamAccountName );

        if (err) {
            goto goodbye;
        }

        //
        // add to the new list
        //
        Assert(cNewSamAccountName<pDataSet->pCurrentAdditionalDNSHostName->valCount);

        pNewSamAccountName[cNewSamAccountName] = pDataSet->pCurrGeneratedSamAccountName[iCurr];
        cNewSamAccountName++;


    } //for

    //
    // delete those that are not marked, since no value in
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME corresponds to it.
    //
    for( i = 0; i < pDataSet->pCurrentAdditionalSamAccountName->valCount; i++ )
    {
        if ( !pSamAccountNameMask[i] ) {

            // it could be with or without '$' at the end
            // delete them both.
            buff = (PWCHAR)THAllocEx(pTHS, pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].valLen+sizeof(WCHAR));
            memcpy(buff, pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].pVal, pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].valLen);
            buff[pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].valLen/2] = L'$';

            __try {
                DBRemAttVal_AC(pTHS->pDB,
                               pAC,
                               pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].valLen+sizeof(WCHAR),
                               buff);

                DBRemAttVal_AC(pTHS->pDB,
                               pAC,
                               pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].valLen,
                               pDataSet->pCurrentAdditionalSamAccountName->pAVal[i].pVal);
            }
            __finally {
                THFreeEx(pTHS, buff);
            }
        }
    }

    //
    // add new ones
    //
    for (i=0; i < cNewSamAccountName; i ++) {

        // add '$' to the end
        buff = (PWCHAR)THAllocEx(pTHS, pNewSamAccountName[i].valLen+sizeof(WCHAR));
        memcpy(buff, pNewSamAccountName[i].pVal, pNewSamAccountName[i].valLen);
        buff[pNewSamAccountName[i].valLen/2] = L'$';

        __try {
            err = DBAddAttVal_AC(pTHS->pDB,
                                 pAC,
                                 pNewSamAccountName[i].valLen+sizeof(WCHAR),
                                 buff );
        }
        __finally {
            THFreeEx(pTHS, buff);
        }

        if (DB_ERR_VALUE_EXISTS==err) {
            err = 0;
            continue;
        }
        if (err) {
            goto goodbye;
        }
    }

goodbye:

    if (pSamAccountNameMask) {
        THFreeEx(pTHS, pSamAccountNameMask);
    }

    THFreeEx(pTHS, pNewSamAccountName);

    return err;

}



DWORD
ValidateSPNsAndDNSHostName (
        THSTATE    *pTHS,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        BOOL       fCheckDNSHostNameValue,
        BOOL       fCheckAdditionalDNSHostNameValue,
        BOOL       fCheckSPNValues,
        BOOL       fNewObject
        )
/*++
  Description:
      This routine does a few things for computer objects (or objects descended from
      computers), but only if this isn't the DRA or SAM.  It is expected to be
      called after modifications are done during a local modify, but before the
      object has been updated to the DB.

      1) If told to check the DNSHostNameValue, calls the routine that verifies
      the ATT_DNS_HOST_NAME has only changed in legal ways. (See
      DNSHostNameValueCheck(), above.)

      2) If told to check the AdditionalDNSHostNameValue, calls the routine
      that verifies the ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME has only changed
      in legal ways. (See AdditionalDNSHostNameValueCheck(), above.)

      3) If told to check the SPNValues, calls the routine that verifies
      the ATT_SERVICE_PRINCIPAL_NAME attribute has only changed in legal
      ways. (See SPNValueCheck(), above.)

      4) Derive the corresponding ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME from
      ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME; Delete the obsolete values.
      (see FixupAdditionalSamAccountName, above.)

      5) Update the values of ATT_SERVICE_PRINCIPAL_NAME based on the
      current value of ATT_DNS_HOST_NAME and ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
      (see FixupSPNValues() above.)

      6) If ATT_DNS_HOST_NAME has changed AND (ATT_SERVER_REFERENCE_BL exists
      OR has changed) AND it references an object in the config container,
      update that object's ATT_DNS_HOST name property if it is derived from
      CLASS_SERVER.

      NOTE:  We are told to check DNSHostName value if the caller failed the
      security check for modifying the DNSHostName, but was granted a specific
      control access right that allows limited modifications anyway.  The same
      goes for check SPNValues and AdditionalDNSHostName.

  Parameters:
      pTHS - the thread state.
      pDN  - DN of the object being changed.
      pCC  - classcache of the class of the object being changed.
      fCheckDNSHostNameValue - should I check the ATT_DNS_HOST_NAME?
      fCheckAdditionalDNSHostNameValue - should I check the
                                    ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
      fCheckSPNValues - should I check the ATT_SERVICE_PRINCIPAL_NAME
      fNewObject - If this object is newly added

  Return Values:
      0 on success, an error otherwise.  Also, the error is set in the thread
      state.
--*/
{
    ATTCACHE     *ACs[6];
    ATTR         *pOriginalAttr=NULL;
    ATTR         *pCurrentAttr=NULL;
    ATTR         *pUpdatedAttr=NULL;
    DWORD         cOriginalOut=0;
    DWORD         cCurrentOut=0;
    DWORD         cUpdatedOut=0;
    DWORD         i, j, rtn, err, iClass;

    SPN_DATA_COLLECTION DataSet;

    DWORD        length;
    DWORD        iOrg, iCurr;

    CLASSCACHE * pCCComputer;

    DWORD        UF_Control;

    if ( pTHS->fDRA ) {
        // Replication is allowed to perform modifications that violate the
        // spn/dns host name consistancy restritctions.
        return(0);
    }

    // N.B. We must do the checks in the fSAM case because:
    //
    // 1) A change to ATT_SAM_ACCOUNT_NAME is ultimately performed by SAM
    //    via loopback, yet we want to update SAM account name dependent SPNs.
    //
    // 2) In the loopback case, the core DS merges in non-SAM attributes on
    //    the first SAM write.  Eg: If the external client writes the SAM
    //    account name and the display name in the same call, this will come
    //    in on the same DirModifyEntry call to the DS.
    //
    // Thus there is no notion that if fSAM is set, then only SAM attributes
    // are referenced.

    // If this isn't a computer object, just leave.

    // According to Murlis, "SAM enforces that an object must be class computer or
    // derived from it to have the user account control set to UF_SERVER_TRUST_ACCOUNT,
    // or UF_WORKSTATION TRUST_ACCOUNT."  So it is sufficient to check if the the class
    // is computer or drived from computer.  This should cover all the "computers".

    pCCComputer = SCGetClassById(pTHS,CLASS_COMPUTER);
    Assert(pCCComputer);

    if (CLASS_COMPUTER != pCC->ClassId
        && pCC != FindMoreSpecificClass(pCCComputer, pCC) ) {
        return(0);
    }


    memset(&DataSet,0,sizeof(DataSet));

    ACs[0] = SCGetAttById(pTHS, ATT_DNS_HOST_NAME);
    ACs[1] = SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME);
    ACs[2] = SCGetAttById(pTHS, ATT_SERVICE_PRINCIPAL_NAME);
    ACs[3] = SCGetAttById(pTHS, ATT_SAM_ACCOUNT_NAME);
    ACs[4] = SCGetAttById(pTHS, ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME);
    ACs[5] = SCGetAttById(pTHS, ATT_SERVER_REFERENCE_BL);

    // Now, get various properties from the current object (i.e. after mods
    // have been applied.)  In this case we do want the server reference BL
    // therefore att count is 6.
    if (err=DBGetMultipleAtts(pTHS->pDB,
                              6,
                              ACs,
                              NULL,
                              NULL,
                              &cCurrentOut,
                              &pCurrentAttr,
                              DBGETMULTIPLEATTS_fEXTERNAL,
                              0)) {

        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             ERROR_DS_COULDNT_UPDATE_SPNS,
                             err);
    }

    // Now, get the dnshostname and service principal names from the original
    // object (i.e. before mods have been applied.), if this object is not newly
    // added, in which case there is no original value.
    // Now, get various properties from the original object (i.e. before mods
    // have been applied.)  In this case we do not want the server reference BL
    // since you can't change the BL on an originating write to this object.
    // Also, we don't want to read original msds-additionalSamAccountName.
    // Therefore att count is 4.
    if (!fNewObject &&
        (err=DBGetMultipleAtts(pTHS->pDB,
                               4,
                               ACs,
                               NULL,
                               NULL,
                               &cOriginalOut,
                               &pOriginalAttr,
                               (DBGETMULTIPLEATTS_fOriginalValues |
                                DBGETMULTIPLEATTS_fEXTERNAL  ),
                               0))) {
        return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                             ERROR_DS_COULDNT_UPDATE_SPNS,
                             err);
    }

    // Get pointers to the individual AttrTypes;
    // NOTE: Values stored in the DS are not NULL terminated.  However, most of
    // the processing here requires that the values be NULL terminated.  So,
    // we're going to extend the buffers and null terminate everything.
    for(i=0;i<cCurrentOut;i++) {
        switch(pCurrentAttr[i].attrTyp) {
        case ATT_SAM_ACCOUNT_NAME:
            // NOTE: not only null terminate, but trim any trailing '$'
            DataSet.pCurrentSamAccountName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pCurrentSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                if(PWVAL[CCHVAL - 1] == L'$') {
                    PWVAL[CCHVAL - 1] = 0;
                    PAVAL.valLen -= sizeof(WCHAR);
                }
                else {
                    PWVAL = THReAllocEx(pTHS,
                                        PWVAL,
                                        PAVAL.valLen + sizeof(WCHAR));
                }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
            }
            break;

        case ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME:
            // NOTE: not only null terminate, but trim any trailing '$'
            DataSet.pCurrentAdditionalSamAccountName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentAdditionalSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pCurrentAdditionalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                if(PWVAL[CCHVAL - 1] == L'$') {
                    PWVAL[CCHVAL - 1] = 0;
                    PAVAL.valLen -= sizeof(WCHAR);
                }
                else {
                    PWVAL = THReAllocEx(pTHS,
                                        PWVAL,
                                        PAVAL.valLen + sizeof(WCHAR));
                }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
            }
            break;


        case ATT_DNS_HOST_NAME:
            DataSet.pCurrentDNSHostName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentDNSHostName->valCount;j++) {
                DataSet.pCurrentDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pCurrentDNSHostName->pAVal[j].pVal,
                                (DataSet.pCurrentDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;


        case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
            DataSet.pCurrentAdditionalDNSHostName = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentAdditionalDNSHostName->valCount;j++) {
                DataSet.pCurrentAdditionalDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pCurrentAdditionalDNSHostName->pAVal[j].pVal,
                                (DataSet.pCurrentAdditionalDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        case ATT_SERVICE_PRINCIPAL_NAME:
            DataSet.pCurrentSPNs = &pCurrentAttr[i].AttrVal;
            for(j=0;j<DataSet.pCurrentSPNs->valCount;j++) {
                DataSet.pCurrentSPNs->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pCurrentSPNs->pAVal[j].pVal,
                                (DataSet.pCurrentSPNs->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        case ATT_SERVER_REFERENCE_BL:
            DataSet.pCurrentSvrRefBL = &pCurrentAttr[i].AttrVal;
            // Extension with NULL terminator not required.
            break;

        default:
            // Huh?
            LogUnhandledError(pCurrentAttr[i].attrTyp);
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_COULDNT_UPDATE_SPNS,
                                 pCurrentAttr[i].attrTyp);
        }
    }

    for(i=0;i<cOriginalOut;i++) {
        switch(pOriginalAttr[i].attrTyp) {
        case ATT_SAM_ACCOUNT_NAME:
            // NOTE: not only null terminate, but trim any trailing '$'
            DataSet.pOriginalSamAccountName = &pOriginalAttr[i].AttrVal;
            for(j=0;j<DataSet.pOriginalSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pOriginalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                if(PWVAL[CCHVAL - 1] == L'$') {
                    PWVAL[CCHVAL - 1] = 0;
                    PAVAL.valLen -= sizeof(WCHAR);
                }
                else {
                    PWVAL = THReAllocEx(pTHS,
                                        PWVAL,
                                        PAVAL.valLen + sizeof(WCHAR));
                }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
            }
            break;

        case ATT_DNS_HOST_NAME:
            DataSet.pOriginalDNSHostName = &pOriginalAttr[i].AttrVal;
            for(j=0;j<DataSet.pOriginalDNSHostName->valCount;j++) {
                DataSet.pOriginalDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pOriginalDNSHostName->pAVal[j].pVal,
                                (DataSet.pOriginalDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        case ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME:
            DataSet.pOriginalAdditionalDNSHostName = &pOriginalAttr[i].AttrVal;
            for(j=0;j<DataSet.pOriginalAdditionalDNSHostName->valCount;j++) {
                DataSet.pOriginalAdditionalDNSHostName->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pOriginalAdditionalDNSHostName->pAVal[j].pVal,
                                (DataSet.pOriginalAdditionalDNSHostName->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;


        case ATT_SERVICE_PRINCIPAL_NAME:
            DataSet.pOriginalSPNs =  &pOriginalAttr[i].AttrVal;;
            for(j=0;j<DataSet.pOriginalSPNs->valCount;j++) {
                DataSet.pOriginalSPNs->pAVal[j].pVal =
                    THReAllocEx(pTHS,
                                DataSet.pOriginalSPNs->pAVal[j].pVal,
                                (DataSet.pOriginalSPNs->pAVal[j].valLen +
                                 sizeof(WCHAR)));
            }
            break;

        default:
            // Huh?
            LogUnhandledError(pOriginalAttr[i].attrTyp);
            return SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                 ERROR_DS_COULDNT_UPDATE_SPNS,
                                 pOriginalAttr[i].attrTyp);
        }
    }

    // sanity check
    if ( !DataSet.pCurrentSamAccountName ) {
        Assert(!"Empty Sam Account Name!\n");

        return  SetAttError(pDN,
                            ATT_SAM_ACCOUNT_NAME,
                            PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                            NULL,
                            DIRERR_BAD_ATT_SYNTAX);

    }


    // if the attributes don't have value, we will allocate an ATTRVALBLOCK for
    // it anyway, so the handling will be uniform.

    if (!DataSet.pOriginalAdditionalDNSHostName) {
        DataSet.pOriginalAdditionalDNSHostName = THAllocEx(pTHS,sizeof(ATTRVALBLOCK));
    }
    if (!DataSet.pCurrentAdditionalDNSHostName) {
        DataSet.pCurrentAdditionalDNSHostName = THAllocEx(pTHS,sizeof(ATTRVALBLOCK));
    }

    if (!DataSet.pCurrentAdditionalSamAccountName) {
        DataSet.pCurrentAdditionalSamAccountName = THAllocEx(pTHS,sizeof(ATTRVALBLOCK));
    }


    //
    // Calculate which values of additional dns host name were added,
    // and which were deleted.
    // For the original ones, pOrgMask[i]=0 means the name is deleted;
    // for the current ones, pCurrMask[i]=0 means the name is newly added.
    //

    if (DataSet.pOriginalAdditionalDNSHostName->valCount) {
        DataSet.pOrgMask =
            THAllocEx(pTHS,sizeof(BYTE)*DataSet.pOriginalAdditionalDNSHostName->valCount);
    }

    if (DataSet.pCurrentAdditionalDNSHostName->valCount) {
        DataSet.pCurrMask =
            THAllocEx(pTHS,sizeof(BYTE)*DataSet.pCurrentAdditionalDNSHostName->valCount);
    }

    for (iOrg = 0; iOrg < DataSet.pOriginalAdditionalDNSHostName->valCount; iOrg++) {

        for(iCurr = 0; iCurr < DataSet.pCurrentAdditionalDNSHostName->valCount; iCurr++){

            if(0 == DataSet.pCurrMask[iCurr]
               && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                      DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                      (WCHAR*)DataSet.pOriginalAdditionalDNSHostName->pAVal[iOrg].pVal,
                                      DataSet.pOriginalAdditionalDNSHostName->pAVal[iOrg].valLen/sizeof(WCHAR),
                                      (WCHAR*)DataSet.pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                      DataSet.pCurrentAdditionalDNSHostName->pAVal[iCurr].valLen/sizeof(WCHAR))) {
            // The name is in both original and current AdditionalDNSHostName, mark it.
            DataSet.pOrgMask[iOrg] = DataSet.pCurrMask[iCurr] = 1;
            break;
            }

        }

    }


    //
    // check if anything changed for ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME
    //

    // same size?
    DataSet.fAdditionalDNSHostNameUnchanged =
        (DataSet.pOriginalAdditionalDNSHostName->valCount==DataSet.pCurrentAdditionalDNSHostName->valCount) ;


    // check if any name in Original ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME is deleted
    for ( iOrg = 0;
          DataSet.fAdditionalDNSHostNameUnchanged && iOrg <DataSet.pOriginalAdditionalDNSHostName->valCount;
          iOrg++ )
    {
        if (!DataSet.pOrgMask[iOrg]) {
            DataSet.fAdditionalDNSHostNameUnchanged = FALSE;
        }
    }

    // check if any name in Current ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME is newly added
    for ( iCurr = 0;
          DataSet.fAdditionalDNSHostNameUnchanged && iCurr <DataSet.pCurrentAdditionalDNSHostName->valCount;
          iCurr++ )
    {
        if (!DataSet.pCurrMask[iCurr]) {
            DataSet.fAdditionalDNSHostNameUnchanged = FALSE;
        }
    }


    //
    // We don't allow the change of ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME in W2K domain mode
    //

    if (   !DataSet.fAdditionalDNSHostNameUnchanged
        && gAnchor.DomainBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET ) {
        rtn =  SetAttError(pDN,
                           ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL,
                           ERROR_DS_NOT_SUPPORTED);

        goto cleanup;
    }


    //
    // check if ATT_DNS_HOST_NAME is changed
    //

    if (   (    DataSet.pOriginalDNSHostName != NULL
            &&  DataSet.pCurrentDNSHostName != NULL
            &&  2 == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    (WCHAR*)DataSet.pOriginalDNSHostName->pAVal[0].pVal,
                                    DataSet.pOriginalDNSHostName->pAVal[0].valLen/sizeof(WCHAR),
                                    (WCHAR*)DataSet.pCurrentDNSHostName->pAVal[0].pVal,
                                    DataSet.pCurrentDNSHostName->pAVal[0].valLen/sizeof(WCHAR))
            )
         || (DataSet.pOriginalDNSHostName == DataSet.pCurrentDNSHostName) ) {

        DataSet.fDNSHostNameUnchanged = TRUE;
    }
    else {
        DataSet.fDNSHostNameUnchanged = FALSE;
    }



    //
    // check if ATT_SAM_ACCOUNT_NAME is changed
    //

    if (        DataSet.pOriginalSamAccountName != NULL
            &&  DataSet.pCurrentSamAccountName != NULL
            && 2 == CompareStringW(DS_DEFAULT_LOCALE,
                                   DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                   (WCHAR*)DataSet.pOriginalSamAccountName->pAVal[0].pVal,
                                   DataSet.pOriginalSamAccountName->pAVal[0].valLen/sizeof(WCHAR),
                                   (WCHAR*)DataSet.pCurrentSamAccountName->pAVal[0].pVal,
                                   DataSet.pCurrentSamAccountName->pAVal[0].valLen/sizeof(WCHAR)) )
    {

        DataSet.fSamAccountNameUnchanged = TRUE;
    }
    else {
        DataSet.fSamAccountNameUnchanged = FALSE;
    }


    //
    // First, check if the change of ATT_DNS_HOST_NAME is legitimiate if required.
    //

    if(fCheckDNSHostNameValue) {
        err = DNSHostNameValueCheck(pTHS,
                                    DataSet.pCurrentDNSHostName,
                                    DataSet.pCurrentSamAccountName );

        if(err) {
            rtn =  SetAttError(pDN,
                               ATT_DNS_HOST_NAME,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                               NULL,
                               DIRERR_BAD_ATT_SYNTAX);
            goto cleanup;
        }
    }

    //
    // Then, check the ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME if required.
    //

    if(    fCheckAdditionalDNSHostNameValue
        && !DataSet.fAdditionalDNSHostNameUnchanged ) {
        err = AdditionalDNSHostNameValueCheck(pTHS,
                                              DataSet.pCurrentAdditionalDNSHostName,
                                              DataSet.pCurrMask );

        if(err) {
            rtn =  SetAttError(pDN,
                               ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                               NULL,
                               DIRERR_BAD_ATT_SYNTAX);
            goto cleanup;
        }
    }


    //
    // Now generate a sam account name for each name in additionalDNSHostName
    // and cache them for later use.  There are two places we will use it:
    // FixupAdditionalSamAccountName() and FixupSPNsOnComputerObject().
    //

    if (DataSet.pOriginalAdditionalDNSHostName->valCount) {
        DataSet.pOrgGeneratedSamAccountName =
            THAllocEx(pTHS,sizeof(ATTRVAL)*DataSet.pOriginalAdditionalDNSHostName->valCount);
    }
    if (DataSet.pCurrentAdditionalDNSHostName->valCount) {
        DataSet.pCurrGeneratedSamAccountName =
            THAllocEx(pTHS,sizeof(ATTRVAL)*DataSet.pCurrentAdditionalDNSHostName->valCount);
    }

    for (iOrg=0; iOrg<DataSet.pOriginalAdditionalDNSHostName->valCount; iOrg++) {

        DataSet.pOrgGeneratedSamAccountName[iOrg].pVal =
            THAllocEx(pTHS,(MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR) );

        length = MAX_COMPUTERNAME_LENGTH+1;

        // we only need to use those deleled ones
        if (!DataSet.pOrgMask[iOrg] &&
            !DnsHostnameToComputerNameW((WCHAR*)DataSet.pOriginalAdditionalDNSHostName->pAVal[iOrg].pVal,
                                        (WCHAR*)DataSet.pOrgGeneratedSamAccountName[iOrg].pVal,
                                         &length ))
        {
            rtn = SetSvcError(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE);
            goto cleanup;
        }
        DataSet.pOrgGeneratedSamAccountName[iOrg].valLen = length * sizeof(WCHAR);
    }

    for (iCurr=0; iCurr < DataSet.pCurrentAdditionalDNSHostName->valCount; iCurr++) {

        DataSet.pCurrGeneratedSamAccountName[iCurr].pVal =
            THAllocEx(pTHS,(MAX_COMPUTERNAME_LENGTH+1)*sizeof(WCHAR) );

        length = MAX_COMPUTERNAME_LENGTH+1;

        if (!DnsHostnameToComputerNameW((WCHAR*)DataSet.pCurrentAdditionalDNSHostName->pAVal[iCurr].pVal,
                                        (WCHAR*)DataSet.pCurrGeneratedSamAccountName[iCurr].pVal,
                                        &length ))
        {
            rtn = SetSvcError(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE);
            goto cleanup;
        }
        DataSet.pCurrGeneratedSamAccountName[iCurr].valLen = length * sizeof(WCHAR);
    }


    //
    // ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME is generated from
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME.
    // Now fix up ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
    //

    err = FixupAdditionalSamAccountName(pTHS,
                                        ACs[4],     //ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME
                                        &DataSet );

    if(err) {

        rtn =  SetAttError(pDN,
                           ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME,
                           PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                           NULL,
                           DIRERR_BAD_ATT_SYNTAX);

        goto cleanup;

    }


    //
    // Now, check the SPN values.
    //

    if(fCheckSPNValues) {

        // ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME could be updated in
        // FixupAdditionalSamAccountName(). We will need the updated
        // values when checking the SPN values.

        if (!DataSet.fAdditionalDNSHostNameUnchanged) {
            if (err=DBGetMultipleAtts(pTHS->pDB,
                                      1,
                                      &(ACs[4]),
                                      NULL,
                                      NULL,
                                      &cUpdatedOut,
                                      &pUpdatedAttr,
                                      DBGETMULTIPLEATTS_fEXTERNAL,
                                      0)) {

                 rtn =  SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                                      ERROR_DS_COULDNT_UPDATE_SPNS,
                                      err);
                 goto cleanup;
             }

            for (i=0;i<cUpdatedOut; i++) {

              if( pUpdatedAttr->attrTyp==ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME ){

                // NOTE: not only null terminate, but trim any trailing '$'
                DataSet.pUpdatedAdditionalSamAccountName = &pUpdatedAttr[i].AttrVal;
                for(j=0;j<DataSet.pUpdatedAdditionalSamAccountName->valCount;j++) {
#define PAVAL  (DataSet.pUpdatedAdditionalSamAccountName->pAVal[j])
#define PWVAL  ((WCHAR *)(PAVAL.pVal))
#define CCHVAL (PAVAL.valLen /sizeof(WCHAR))
                    if(PWVAL[CCHVAL - 1] == L'$') {
                        PWVAL[CCHVAL - 1] = 0;
                        PAVAL.valLen -= sizeof(WCHAR);
                    }
                    else {
                        PWVAL = THReAllocEx(pTHS,
                                            PWVAL,
                                            PAVAL.valLen + sizeof(WCHAR));
                    }
#undef CCHVAL
#undef PWVAL
#undef PAVAL
                }
                break;

              }

            }
        } // end of "if (!DataSet.fAdditionalDNSHostNameUnchanged)"


        // check if the SPN change is legitimate
        err = SPNValueCheck(pTHS,
                            &DataSet);

        if(err) {
            rtn =  SetAttError(pDN,
                               ATT_SERVICE_PRINCIPAL_NAME,
                               PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                               NULL,
                               DIRERR_BAD_ATT_SYNTAX);
            goto cleanup;
        }
    }



    //
    // A SPN is based on ATT_DNS_HOST_NAME, ATT_SAM_ACCOUNT_NAME,
    // ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME, or ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME.
    // If any of these attributes is changed, the ATT_SERVICE_PRINCIPAL_NAME
    // attribute need to be updated.
    // Now, fixup the SPNs.
    //

    err = FixupSPNsOnComputerObject(pTHS,
                                    pDN,
                                    pCC,
                                    &DataSet );


    if(err) {
        rtn =  SetSvcErrorEx(SV_PROBLEM_BUSY,
                             ERROR_DS_COULDNT_UPDATE_SPNS,
                             err);
        goto cleanup;
    }

    //
    // Fixup DNS host name on referenced server object if req'd.
    //

    if ( DataSet.pCurrentSvrRefBL ) {
        if ( err = FixupServerDnsHostName(pTHS, ACs[0], ACs[5],
                                          DataSet.pCurrentSvrRefBL,
                                          DataSet.pOriginalDNSHostName,
                                          DataSet.pCurrentDNSHostName) )  {
            // ValidateServerReferenceBL sets pTHS->errCode itself.
            rtn = err;
            goto cleanup;
        }
    }


    //
    // All went well.
    //
    rtn = 0;



cleanup:

    if (DataSet.pCurrGeneratedSamAccountName) {
        for (i=0;i<DataSet.pCurrentAdditionalDNSHostName->valCount;i++) {
            if (DataSet.pCurrGeneratedSamAccountName[i].pVal)
            {
                THFreeEx(pTHS,DataSet.pCurrGeneratedSamAccountName[i].pVal);
            }

        }
        THFreeEx(pTHS,DataSet.pCurrGeneratedSamAccountName);
    }

    if (DataSet.pOrgGeneratedSamAccountName) {
        for (j=0;j<DataSet.pOriginalAdditionalDNSHostName->valCount;j++) {
            if (DataSet.pOrgGeneratedSamAccountName[j].pVal)
            {
                THFreeEx(pTHS,DataSet.pOrgGeneratedSamAccountName[j].pVal);
            }

        }
        THFreeEx(pTHS,DataSet.pOrgGeneratedSamAccountName);
    }

    if (DataSet.pCurrMask) {
        THFreeEx(pTHS,DataSet.pCurrMask);
    }

    if (DataSet.pOrgMask) {
        THFreeEx(pTHS,DataSet.pOrgMask);

    }

    return rtn;
}



/* AppendNonReplAttsToModifiedList combines the
two lists:ppModAtts and ppNonReplAtts into one
ppModAtts, and it will free ppNonReplAtts.  */


ULONG AppendNonReplAttsToModifiedList(THSTATE *pTHS,
                                      ULONG * pcModAtts,
                                      ATTRTYP **ppModAtts,
                                      ULONG * pcNonReplAtts,
                                      ATTRTYP **ppNonReplAtts)

{
    if (!*pcNonReplAtts) {
        return 0;
    }

    if (!*pcModAtts) {
        *ppModAtts = *ppNonReplAtts;
        *pcModAtts = *pcNonReplAtts;
        return 0;
    }


    *ppModAtts = THReAllocEx(pTHS, *ppModAtts, (*pcModAtts+*pcNonReplAtts)*sizeof(ATTRTYP));

    memcpy(&(*ppModAtts)[*pcModAtts],*ppNonReplAtts, *pcNonReplAtts*sizeof(ATTRTYP));

    *pcModAtts += *pcNonReplAtts;

    THFreeEx(pTHS,*ppNonReplAtts);
    *pcNonReplAtts = 0;
    *ppNonReplAtts = NULL;

    return 0;
}


/* The following function decides if the provided DNT
   is under system container.
*/

BOOL IsUnderSystemContainer(THSTATE *pTHS, ULONG ulDNT )
{
    DBPOS * pDB = NULL;
    ULONG i, len=0, number=0, *ancestors=NULL;
    BOOL bRet = TRUE;

    Assert(gAnchor.ulDNTSystem && gAnchor.ulDNTSystem != INVALIDDNT);

    DBOpen2(FALSE, &pDB);

    __try{
        
        DBFindDNT(pDB,ulDNT);  //would except on failure

        DBGetAncestors(pDB, &len,&ancestors,&number);

        for (i=0;i<number;i++) {
            if (gAnchor.ulDNTSystem == ancestors[i]) {
                __leave;
            }
        }
        bRet = FALSE;
    }
    __finally{
        DBClose(pDB, FALSE);
    }
    return bRet;

}

DWORD
createNtdsQuotaContainer(THSTATE *  pTHS, 
                         DSNAME  *  pRootDN,
                         PSID       pDomainSid,
                         PSID       pRootDomainSid,
                         WCHAR   *  pPrefix,
                         WCHAR   *  pSD,
                         DSNAME  ** ppDN,
                         DWORD   *  pdsid )
{

//*** The following functions are from mdndnc.c
VOID
SetAttSingleValueUlong(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    ULONG                 ulAttData
    );

VOID
SetAttSingleValueString(
    THSTATE *             pTHS,
    ATTR *                pAttr,
    ULONG *               piAttr,
    ULONG                 ulAttType,
    WCHAR *               wcszAttData
    );
// ****************


    ULONG len, prefixLen;
    DBPOS * pDB = NULL;
    WCHAR *buff;
    WCHAR num[20];  //big enough to hold an int
    int i = 0;
    DWORD err = 0;
    ADDARG AddArg;
    ADDRES AddRes;
    int iAttr;
    DSNAME *pDN = NULL;

    // copy the name into buffer for later manipulation
    prefixLen = wcslen(pPrefix);
    buff = THAllocEx(pTHS,sizeof(WCHAR)*(prefixLen+20)); // a little extra space
    wcscpy(buff, pPrefix);
    
    DBOpen(&pDB);
    
    __try {
        
        // first settle the name
        // hopefully, we can use name "ntds quotas",
        // if not, we try "ntds quotas x" where x is a
        // random number
        do {
            //construct the DN
            len = wcslen(buff)+pRootDN->NameLen;
            pDN = THAllocEx(pTHS,DSNameSizeFromLen(len));
            pDN->NameLen = len;
            pDN->structLen = DSNameSizeFromLen(len);
            wcscpy(pDN->StringName,buff);
            wcsncat(pDN->StringName,pRootDN->StringName,pRootDN->NameLen);

            // try to find it
            err = DBFindDSName(pTHS->pDB,pDN);

            
            // if it already exists, try another name
            if (err != DIRERR_OBJ_NOT_FOUND) {
                
                DPRINT2(0,"createNtDsQuotaContainer:DBFindDSName returns %x on object %S\n",err, pDN->StringName);

                swprintf(num,L" %u,",rand());

                buff[prefixLen-1] = 0;

                wcscat(buff,num);

                i++;
                
                THFreeEx(pTHS,pDN);
                pDN = NULL;
                
            }
        }
        while(err!=DIRERR_OBJ_NOT_FOUND && i<9);

        
        // fail?
        if (err!=DIRERR_OBJ_NOT_FOUND) {
            err = DIRERR_OBJ_STRING_NAME_EXISTS;
            *pdsid = DSID(FILENO, __LINE__);
            __leave;
        }
        else {
            err = 0;
        }

        // Create AddArg for "NTDS Quotas" Container
        memset(&AddArg, 0, sizeof(ADDARG));
        memset(&AddRes, 0, sizeof(ADDRES));
        // Set pObject
        AddArg.pObject = pDN;

        iAttr = 0;        
        AddArg.AttrBlock.attrCount = 4;
        AddArg.AttrBlock.pAttr = THAllocEx( pTHS, AddArg.AttrBlock.attrCount * sizeof(ATTR) );
        
        // Set the objectClass attribute.
        SetAttSingleValueUlong(pTHS,
                               &(AddArg.AttrBlock.pAttr[iAttr]),
                               &iAttr,
                               ATT_OBJECT_CLASS,
                               CLASS_MS_DS_QUOTA_CONTAINER);

        // Set the isCriticalSystemObject attribute
        SetAttSingleValueUlong(pTHS,
                               &(AddArg.AttrBlock.pAttr[iAttr]),
                               &iAttr,
                               ATT_IS_CRITICAL_SYSTEM_OBJECT,
                               TRUE);
    
        // Set the systemFlags attribute
        SetAttSingleValueUlong(pTHS,
                               &(AddArg.AttrBlock.pAttr[iAttr]),
                               &iAttr,
                               ATT_SYSTEM_FLAGS,
                               (FLAG_DOMAIN_DISALLOW_MOVE |
                                FLAG_DISALLOW_DELETE));

        // set the security descriptor
        
        {
            
          SECURITY_DESCRIPTOR * pSDNew = 0;
          ULONG                 cSD = 0;
        
          // This is a special version of ConvertStringSDToSD() that takes a domain
          // argument too.
          if (!ConvertStringSDToSDDomainW(pDomainSid,
                                          pRootDomainSid,
                                          pSD,
                                          SDDL_REVISION_1,
                                          &pSDNew,
                                          &cSD)){
                        
              err = GetLastError();
              __leave;
          }
        
          Assert(pSD);
          Assert(cSD);
        
          // Note: we reallocate the pSD into thread allocated memory, because 
          // CheckAddSecurity or someone under it assumes that it's THAlloc'd
          AddArg.AttrBlock.pAttr[iAttr].attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
          AddArg.AttrBlock.pAttr[iAttr].AttrVal.valCount = 1;
          AddArg.AttrBlock.pAttr[iAttr].AttrVal.pAVal = THAllocEx(pTHS, sizeof(ATTRVAL));
          AddArg.AttrBlock.pAttr[iAttr].AttrVal.pAVal[0].valLen = cSD;
          AddArg.AttrBlock.pAttr[iAttr].AttrVal.pAVal[0].pVal = THAllocEx(pTHS, cSD);
          memcpy (AddArg.AttrBlock.pAttr[iAttr].AttrVal.pAVal[0].pVal, pSDNew, cSD);
          iAttr++;
          LocalFree(pSDNew);
        }
    
    
            
        Assert(iAttr == AddArg.AttrBlock.attrCount);
    
        
        // Set pMetaDataVecRemote
        AddArg.pMetaDataVecRemote = NULL;
        
        // Set CommArg
        InitCommarg(&(AddArg.CommArg));
        AddArg.CommArg.Svccntl.dontUseCopy = FALSE;
        
        // Do the Add object.
        if(DoNameRes(pTHS, 0, pRootDN, &AddArg.CommArg,
                     &AddRes.CommRes, &AddArg.pResParent)){
            Assert(pTHS->errCode);
            *pdsid = DSID(FILENO, __LINE__);
            err = Win32ErrorFromPTHS(pTHS);
            __leave;
        }
        
        LocalAdd(pTHS, &AddArg, FALSE);
        if(pTHS->errCode){
            *pdsid = DSID(FILENO, __LINE__);
            err = Win32ErrorFromPTHS(pTHS);
            __leave;
        }
    }

    __finally{
        DBClose(pDB,!err);
        THFreeEx(pTHS,buff);
    }

    if (!err ) {
        Assert(pDN);
        *ppDN = pDN;
        

    }
    else {
        if (pDN) {
            THFreeEx(pTHS,pDN);
        }
        *ppDN = NULL;
    }
    return err;


}


/*  DsUpdateOnPDC
    This function is called by SAM on PDC when the PDC is
    upgraded to newer version or when the PDC role is transferred.
*/

DWORD DsUpdateOnPDC(BOOL fRootDomain)
{
    
    struct WKOUpdate{
       char *wkoGuid;
       WCHAR *dnPrefix;
    };

    struct WKOUpdate wkoDomain[] = { 
        {GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE,L"CN=ForeignSecurityPrincipals,"},
        {GUID_PROGRAM_DATA_CONTAINER_BYTE, L"CN=Program Data,"},
        {GUID_MICROSOFT_PROGRAM_DATA_CONTAINER_BYTE,L"CN=Microsoft,CN=Program Data,"},
        {GUID_NTDS_QUOTAS_CONTAINER_BYTE,L"CN=NTDS Quotas,"} };

#define wkoDomainCount (sizeof(wkoDomain)/sizeof(wkoDomain[0]))


    struct WKOUpdate wkoConfig[] = {
        {GUID_NTDS_QUOTAS_CONTAINER_BYTE,L"CN=NTDS Quotas,"} };


#define wkoConfigCount (sizeof(wkoConfig)/sizeof(wkoConfig[0]))


    THSTATE *pTHS=NULL;
    
    ULONG dwException, dsid;
    PVOID dwEA;

    ULONG i, ulRet=0, len,DNT;
    ULONG cAttrVal;
    
    SYNTAX_DISTNAME_BINARY *  pSynDistName;
    SYNTAX_ADDRESS * pSynAddr;
    DSNAME *pDN=NULL;
    DSNAME *pQuotasDN;
    
    MODIFYARG ModArg;
    ATTRVAL AttrVals[max(wkoDomainCount,wkoConfigCount)];
    COMMRES CommRes;
    
    struct WKOUpdate *p;
    PDSNAME pRootDN;
    
    BOOL fConfig = FALSE;

    Assert(pTHStls==NULL);

    pTHS = InitTHSTATE(CALLERTYPE_INTERNAL);
    
    if (NULL == pTHS) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    pTHS->fDSA = TRUE;

    __try{

    
        do {

            cAttrVal = 0;

            pRootDN = fConfig?gAnchor.pConfigDN:gAnchor.pDomainDN;
            
            
            DBOpen(&(pTHS->pDB));
            
            
                
            __try{

                for ( i = 0; i < (fConfig?wkoConfigCount:wkoDomainCount); i++ ) {
                    
                    
                    p = fConfig?&wkoConfig[i]:&wkoDomain[i];

                    pQuotasDN = NULL;

                                    
                    if(!DBFindDSName(pTHS->pDB,pRootDN)
                      && !GetWellKnownDNT(pTHS->pDB,(GUID*)p->wkoGuid,&DNT)){

                                               
                       // The wko value does not exist, add it!

                       // if it is ntds quotas container, 
                       // create the container first
                       if( !memcmp(GUID_NTDS_QUOTAS_CONTAINER_BYTE,p->wkoGuid, sizeof(GUID)))
                       {
                           Assert(gAnchor.pDomainDN->SidLen);
                            ulRet = createNtdsQuotaContainer(pTHS, 
                                                             pRootDN, 
                                                             (PSID)&gAnchor.pDomainDN->Sid,
                                                             fConfig?(PSID)&gAnchor.pDomainDN->Sid:NULL,
                                                             p->dnPrefix,
                                                             fConfig?L"O:EAG:EAD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;EA)(A;;RPLCLORC;;;BA)(OA;;CR;4ecc03fe-ffc0-4947-b630-eb672a8a9dbc;;WD)S:(AU;CISA;WDWOSDDTWPCRCCDCSW;;;WD)"
                                                                 :L"O:DAG:DAD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPLCLORC;;;BA)(OA;;CR;4ecc03fe-ffc0-4947-b630-eb672a8a9dbc;;WD)S:(AU;CISA;WDWOSDDTWPCRCCDCSW;;;WD)",
                                                             &pQuotasDN,
                                                             &dsid );
                            if (ulRet) {
                                DPRINT(0,"DS failed to create the NTDS quotas container\n");
                                __leave;

                            }
                            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                     DS_EVENT_SEV_ALWAYS,
                                     DIRlOG_NTDS_QUOTAS_CONTAINER_CREATED,
                                     szInsertDN(pQuotasDN),
                                     NULL,
                                     NULL );
                                                  
                       }

                       
                                              
                       if (pQuotasDN) {
                            pDN = pQuotasDN;
                       }
                       else {
                           //construct the DN 
                            len = wcslen(p->dnPrefix)+pRootDN->NameLen;
                            pDN = THAllocEx(pTHS,DSNameSizeFromLen(len));
                            pDN->NameLen = len;
                            pDN->structLen = DSNameSizeFromLen(len);
                            wcscpy(pDN->StringName,wkoDomain[i].dnPrefix);
                            wcsncat(pDN->StringName,pRootDN->StringName,pRootDN->NameLen);
                       }
                                           
                        //check the existence of the object
                        ulRet=DBFindDSName(pTHS->pDB,pDN);
                        if (ulRet) {
                            
                            DPRINT2(0,"DS cannot read object %S, err=%x\n",pDN->StringName, ulRet);
                            dsid=DSID(FILENO, __LINE__);
                            __leave;
                        }
    
                        // Get binary GUID
                        pSynAddr = THAllocEx(pTHS, STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID)));
                        pSynAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN(sizeof(GUID));
                        memcpy(pSynAddr->byteVal, p->wkoGuid, sizeof(GUID));
                        
                        // Set up the Syntax DistName Binary attribute.
                        pSynDistName = THAllocEx(pTHS, DERIVE_NAME_DATA_SIZE(pDN, pSynAddr));
                        BUILD_NAME_DATA(pSynDistName, pDN, pSynAddr);
                        
                        // Put the syntax distname in the attribute value block.
                        AttrVals[cAttrVal].valLen = NAME_DATA_SIZE(pSynDistName);
                        AttrVals[cAttrVal].pVal = (PBYTE) pSynDistName;
                        
                        cAttrVal++;
    
                        // Free Temp variables
                        THFreeEx(pTHS,pDN);
                        pDN = NULL;
                        THFreeEx(pTHS,pSynAddr);
                        pSynAddr = NULL;
    
    
                    }
                }
                
                //something need to be added
    
                if (cAttrVal > 0) {
    
                    pTHS->fDSA = TRUE;
                    
                    memset(&ModArg, 0, sizeof(ModArg));
                    ModArg.pObject = pRootDN;
                    ModArg.count = 1;
                    InitCommarg(&ModArg.CommArg);
                    ModArg.FirstMod.choice = AT_CHOICE_ADD_ATT;
                    ModArg.FirstMod.AttrInf.attrTyp = ATT_WELL_KNOWN_OBJECTS;
                    ModArg.FirstMod.AttrInf.AttrVal.valCount = cAttrVal;
                    ModArg.FirstMod.AttrInf.AttrVal.pAVal = AttrVals;
                    ModArg.FirstMod.pNextMod = NULL;
                    
                    ulRet = DoNameRes(pTHS, 0, ModArg.pObject, &ModArg.CommArg, &CommRes, &ModArg.pResObj);
                    if(ulRet){
                        dsid = DSID(FILENO, __LINE__);
                        __leave;
                    }
         
                    LocalModify(pTHS, &ModArg);
                         
                    if (pTHS->errCode) {
                        //err
                        dsid = DSID(FILENO, __LINE__);
                        ulRet = Win32ErrorFromPTHS(pTHS);
                        __leave;
                    }
                }
            }
            __finally{
                DBClose(pTHS->pDB,!ulRet&&!AbnormalTermination());
                
                if (ulRet) {
                    LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_CANT_UPDATE_WELLKNOWNOBJECTS,
                              szInsertDN(pRootDN),
                              szInsertUL(ulRet),
                              szInsertWin32Msg(ulRet),
                              szInsertHex(dsid),
                              NULL, NULL, NULL, NULL);

         
                }

            }

            if (!fRootDomain || fConfig) {
                // quit if the PDC is not in the root domain, or 
                // the config part is done already
                break;
            }
            
            fConfig = TRUE;
            ulRet = 0;
            THClearErrors();
                    
        }while ( TRUE );

    }
    
    __except(GetExceptionData( GetExceptionInformation(),
                               &dwException,
                               &dwEA,
                               &ulRet,
                               &dsid ) ){
        HandleDirExceptions(dwException, ulRet, dsid );
    }

    DPRINT1(2,"DsUpdateOnPdc returns %x\n", ulRet);

    
        
    free_thread_state();

    return ulRet;

#undef wkoDomainCount 
#undef wkoConfigCount

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\oidconv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       OidConv.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Conversion routines from OID<->ATTR Types
    Orignally in xds.

    The OID encoding and decoding routines in this module are based
    on the explanations of BER encoding of OIDs found in "A Layman's
    guide to a Subset of ASN.1, BER, and DER", by Burton S. Kaliski Jr,
    which is available as http://www.rsa.com/pub/pkcs/ascii/layman.asc.
    The most relevant content is in section 5.9 (Object Identifiers).

    This file is now closely related to scache.c, since all accesses to
    the prefix table are through the thread-specific schema pointer

Revision History

    Don Hacherl (DonH) 7-17-96  added string DN conversion functions
    Arobinda Gupta (Arobindg) 5-8-97 added dynamic prefix table
                                     loading\unloading
    Arobinda Gupta (ArobindG) 5-22-97 dynamix prefix table support

--*/
#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <objids.h>
#include <dsconfig.h>

// Assorted DSA headers
#include <dsevent.h>
#include <mdcodes.h>
#include <debug.h>
#define DEBSUB "OIDCONV:"

//Prefix Table header
#include <prefix.h>

#include <dstaskq.h>
#include <anchor.h>
#include <drameta.h>


#include <fileno.h>
#define  FILENO FILENO_SCACHE

typedef struct
{
    ULONG       Ndx;
    DWORD       NextSuffix;
    DWORD       EndSuffix;
}OIDPOOL;

extern int RecalcPrefixTable();


// Local functions
int AddPrefixIfNeeded(OID_t *Prefix,
                      unsigned PrefixLength,
                      DWORD *ndx);
int AssignIndex(OID_t *NewPrefix,
                unsigned PrefixLength,
                DWORD *ndx);
int ParseAndLoad(PrefixTableEntry *PrefixTable,
                 ULONG PREFIXCOUNT,
                 UCHAR *pBuf);

BOOL ReplaceHardcodedPrefix(PrefixTableEntry *PrefixTable,
                            PrefixTableEntry *NewPrefix);

// External function (defined in scchk.c) to free prefix tabale)
extern void SCFreePrefixTable(PrefixTableEntry **ppPrefixTable, ULONG PREFIXCOUNT);

// From various X series headers:
#define OMP_O_MH_C_OR_NAME  "\126\006\001\002\005\013\035"
#define OMP_O_DS_C_ACCESS_POINT  "\x2B\x0C\x02\x87\x73\x1C\x00\x85\x3E"

OID_EXPORT(MH_C_OR_NAME);
OID_EXPORT(DS_C_ACCESS_POINT);


// Known MS Prefixes. The runtime prefix table loads these.


PrefixTableEntry MSPrefixTable[] =
{
    {_dsP_attrTypePrefIndex, {_dsP_attrTypePrefLen, _dsP_attrTypePrefix}},
    {_dsP_objClassPrefIndex, {_dsP_objClassPrefLen, _dsP_objClassPrefix}},
    {_msP_attrTypePrefIndex, {_msP_attrTypePrefLen, _msP_attrTypePrefix}},
    {_msP_objClassPrefIndex, {_msP_objClassPrefLen, _msP_objClassPrefix}},
    {_dmsP_attrTypePrefIndex, {_dmsP_attrTypePrefLen, _dmsP_attrTypePrefix}},
    {_dmsP_objClassPrefIndex, {_dmsP_objClassPrefLen, _dmsP_objClassPrefix}},
    {_sdnsP_attrTypePrefIndex, {_sdnsP_attrTypePrefLen, _sdnsP_attrTypePrefix}},
    {_sdnsP_objClassPrefIndex, {_sdnsP_objClassPrefLen, _sdnsP_objClassPrefix}},
    {_dsP_attrSyntaxPrefIndex, {_dsP_attrSyntaxPrefLen, _dsP_attrSyntaxPrefix}},
    {_msP_attrSyntaxPrefIndex, {_msP_attrSyntaxPrefLen, _msP_attrSyntaxPrefix}},
    {_msP_ntdsObjClassPrefIndex, {_msP_ntdsObjClassPrefLen, _msP_ntdsObjClassPrefix}},
    {_Ldap_0AttPrefIndex, {_Ldap_0AttLen, _Ldap_0AttPrefix}},
    {_Ldap_1AttPrefIndex, {_Ldap_1AttLen, _Ldap_1AttPrefix}},
    {_Ldap_2AttPrefIndex, {_Ldap_2AttLen, _Ldap_2AttPrefix}},
    {_Ldap_3AttPrefIndex, {_Ldap_3AttLen, _Ldap_3AttPrefix}},
    {_msP_ntdsExtnObjClassPrefIndex, {_msP_ntdsExtnObjClassPrefLen,
                                      _msP_ntdsExtnObjClassPrefix}},
    {_Constr_1AttPrefIndex, {_Constr_1AttLen, _Constr_1AttPrefix}},
    {_Constr_2AttPrefIndex, {_Constr_2AttLen, _Constr_2AttPrefix}},
    {_Constr_3AttPrefIndex, {_Constr_3AttLen, _Constr_3AttPrefix}},
    {_Dead_AttPrefIndex_1, {_Dead_AttLen_1, _Dead_AttPrefix_1}},
    {_Dead_ClassPrefIndex_1, {_Dead_ClassLen_1, _Dead_ClassPrefix_1}},
    {_Dead_AttPrefIndex_2, {_Dead_AttLen_2, _Dead_AttPrefix_2}},
    {_Dead_ClassPrefIndex_2, {_Dead_ClassLen_2, _Dead_ClassPrefix_2}},
    {_Dead_AttPrefIndex_3, {_Dead_AttLen_3, _Dead_AttPrefix_3}},
    {_Dead_ClassPrefIndex_3, {_Dead_ClassLen_3, _Dead_ClassPrefix_3}},
    {_Dead_ClassPrefIndex_4, {_Dead_ClassLen_4, _Dead_ClassPrefix_4}},
    {_Dead_AttPrefIndex_4, {_Dead_AttLen_4, _Dead_AttPrefix_4}},
    {_DynObjPrefixIndex, {_DynObjLen, _DynObjPrefix}},
    {_InetOrgPersonPrefixIndex,{_InetOrgPersonLen, _InetOrgPersonPrefix}},
    {_labeledURIPrefixIndex,{_labeledURILen, _labeledURIPrefix}},
    {_unstructuredPrefixIndex,{_unstructuredLen, _unstructuredPrefix}},
    {_Ldap_3ClassPrefixIndex,{_Ldap_3ClassLen, _Ldap_3ClassPrefix}},
};

// Dummy Prefix to void out an intermediate entry in the prefix table
// The index does not really matter, since it would never be used
// Also, by definition of an OID, no OID can create this prefix
// (since the first decimal in an OID must be 0,1,or 2, and the
// second less than 40 (we check this), so 40x(firstdecimal)+second
// decimal can not be more than 120
//
// The invalid prefix index (_invalidPrefIndex) must be a value that
// will never occur in practice when translating an OID into an attid.
// Otherwise, PrefixMapOpenHandle will create an rgMappings array that
// may return this invalid prefix. For example, pretend the invalid
// prefix was 0 (which it was), and that 0 was in use as a valid index
// (which it is). The rgMappings array would then have two entries for
// 0, one for the invalid entry and one for the valid entry. PrefixMapAttr
// may then return the invalid entry (which it did) and replication will
// fail.
//

#define _invalidPrefIndex  (FIRST_INTID_PREFIX)
#define _invalidPrefix     "\xFF"
#define _invalidPrefLen    1



///////////////////////////////////////////////////////////////////////
// Loads MS-specific prefixes in a prefix table.
// Memory for MAX_PREFIX_COUNT no. of prefix table entries  is
// assumed to be already allocated (in SCSchemaCacheInit)
//
// Return Value:  0 on success, non-0 on error
//
///////////////////////////////////////////////////////////////////////

int InitPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT)
{
    ULONG i;
    THSTATE *pTHS = pTHStls;
    SCHEMAPTR *pSchemaPtr=(SCHEMAPTR *) pTHS->CurrSchemaPtr;


    Assert(PrefixTable && PREFIXCOUNT >= MSPrefixCount);

    // Initialize (necessary?)
    for (i=0; i<PREFIXCOUNT; i++) {
        PrefixTable[i].prefix.elements = NULL;
        PrefixTable[i].prefix.length = 0;
    }

    // Load the hardcoded MS prefixes
    for (i=0; i<MSPrefixCount; i++) {
        PrefixTable[i].ndx = MSPrefixTable[i].ndx;
        PrefixTable[i].prefix.length = MSPrefixTable[i].prefix.length;
        if (SCCallocWrn(&PrefixTable[i].prefix.elements, 1, strlen(MSPrefixTable[i].prefix.elements) + 1 )) {
            return 1;
        }
        memcpy( PrefixTable[i].prefix.elements, MSPrefixTable[i].prefix.elements,PrefixTable[i].prefix.length);
    }

    // Update the thread state to reflect the Prefix Count
     pSchemaPtr->PrefixTable.PrefixCount += MSPrefixCount;

     return 0;

}


///////////////////////////////////////////////////////////////////////
// Load the user defined prefixes, if any, from the prefix-map
// attribute in schema container
//
// Arguments: PrefixTable -- start of prefix table
//            PREFIXCOUNT -- size of table
//
// Return value: 0 on success, non-0 on error
//////////////////////////////////////////////////////////////////////

int InitPrefixTable2(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT)
{
    DSNAME *pSchemaDMDName = NULL;
    DBPOS *pDB = NULL;
    int err = 0;
    UCHAR *pBuf;
    ULONG cLen, totalSize;
    ULONG newSize, newPREFIXCOUNT;
    char temp[100];
    THSTATE *pTHS = pTHStls;
    SCHEMAPTR *pSchemaPtr=(SCHEMAPTR *) pTHS->CurrSchemaPtr;


     // Get the schema container


    DBOpen2(TRUE, &pDB);

    // The call to DBOpen2 will call DBTransIn, which, if we are going from 
    // transaction level 0 to 1 (i.e., we are at transaction level 1 now after the DBOpen2 call),
    // and fDRA is 1, will call THRefresh, and we will lose the schema pointer.
    // This can be very bad when this is called from RecalcPrefixTable
    // in the process of assigning a new index for a new prefix, since the
    // cache that we had in the thread state is the recalc cache, which we
    // will free later (the prefix table part at least); so guess what happens
    // if THRefresh puts in the global schema cache again. So restore the saved
    // off recalc schema cache. Note that InitPrefixTable2 is called from 3
    // places: (1) normal schema cache load, (2) validatioon cache load, and 
    // (3) from RecalcPrefixTable when trying to assign index to a new prefix.
    // fDRA can never do the first two, and the third case is the case we are
    // considering here.
  
 
    if ( (pTHS->transactionlevel == 1) && pTHS->fDRA) {
       pTHS->CurrSchemaPtr = pSchemaPtr;
    }

    // In other cases, it should already be the same

    Assert(pTHS->CurrSchemaPtr == pSchemaPtr);

    __try {
       // Schema cache is loaded and hence gAnchor.pDMD is defined at
       // this point

       if (gAnchor.pDMD == NULL) {
              DPRINT(0, "Couldn't find DMD name/address to load\n");
              err = DSID(FILENO, __LINE__);
              __leave;
          }

        // PREFIX: dereferencing NULL pointer 'pDB' 
        //         DBOpen2 returns a non-NULL pDB or throws an exception
       if( DBFindDSName(pDB, gAnchor.pDMD) ) {
         DPRINT(0, "Cannot find DMD in dit\n");
         err = DSID(FILENO, __LINE__);
         __leave;
       }

       // schema cache should already be loaded at this point, as
       // DBGetAttVal needs that
       if (err = DBGetAttVal(pDB,
                      1,
                      ATT_PREFIX_MAP,
                      DBGETATTVAL_fREALLOC,
                      0,
                      &cLen,
                      (UCHAR **) &pBuf)) {

            if (err ==  DB_ERR_NO_VALUE) {
             // This is fine, as there may not be any user-defined
             // prefixes
              err = 0;
              __leave;
             }

            // otherwise, some error. Return the error
            DPRINT(0, "Error reading prefix-map attribute\n");
            err = DSID(FILENO, __LINE__);
            __leave;
       }

       // Now see if the table space is sufficient

       memcpy(&newSize, pBuf, sizeof(ULONG));
       newSize += MSPrefixCount;

       if (newSize > PREFIXCOUNT) {
          // Make sure there is sufficient space later

          newPREFIXCOUNT = START_PREFIXCOUNT;
          while ( newSize > newPREFIXCOUNT) {
                newPREFIXCOUNT += START_PREFIXCOUNT;
          }

          if (SCReallocWrn(&PrefixTable, newPREFIXCOUNT*sizeof(PrefixTableEntry))) {
             DPRINT(0,"Error reallocing prefix table\n");
             err = DSID(FILENO, __LINE__);
             __leave;
          }

          // Zero memory, leaving already loaded MS prefixes intact
          ZeroMemory(&PrefixTable[MSPrefixCount], (newPREFIXCOUNT-MSPrefixCount)*sizeof(PrefixTableEntry));

          // update the thread's schemaptr
          pSchemaPtr->PrefixTable.pPrefixEntry = PrefixTable;
          PREFIXCOUNT = newPREFIXCOUNT;
          pSchemaPtr->PREFIXCOUNT = PREFIXCOUNT;
       }

       // Do a check on the total size in the prefix map, just in
       // case the value is corrupted. TotalSize starts at byte 4
       memcpy(&totalSize, &pBuf[4], sizeof(ULONG));
       if (totalSize != cLen) {
         // the size in the prefix map is not the same as the
         // size read. Something is wrong!
         DPRINT(0,"Prefix Map corrupted\n");
         err = DSID(FILENO, __LINE__);
         __leave;
       }

       // Now parse the binary value and load into table
       err = ParseAndLoad(PrefixTable, PREFIXCOUNT, pBuf);

    }
    __finally {
        if (pDB) {        
            DBClose(pDB, FALSE);
        }
    }
    return err;
}


//////////////////////////////////////////////////////////////////////
// Parses the binary prefix-map attribute read from the schema, and
// loads the prefix table with the prefixes. Called from InitPrefixTable2
// only
//
// Arguments:  PrefixTable  -- pointer to prefix table
//             PREFIXCOUNT  -- size of table
//             pBuf         -- ptr to start of binary blob that is the
//                             prefix-map attribute read from the schema
//
// Return value: 0 on success, non-0 on error
/////////////////////////////////////////////////////////////////////

int ParseAndLoad(PrefixTableEntry *PrefixTable,
                  ULONG PREFIXCOUNT,
                  UCHAR *pBuf)
{
    ULONG totalSize, dummy, nextByte = 0;
    ULONG i = 0;
    USHORT index, length;
    int ulongSize, ushortSize;
    THSTATE *pTHS = pTHStls;
    SCHEMAPTR *pSchemaPtr=(SCHEMAPTR *) pTHS->CurrSchemaPtr;

    // USHORT = 16bits, ULONG = 32bits

    ulongSize = sizeof(ULONG);
    ushortSize = sizeof(USHORT);
    Assert(ulongSize==4);
    Assert(ushortSize==2);

    // skip the MS-specific prefixes (which are always loaded in
    // consecutive positions at the beginning of the table

    while ((PrefixTable[i].prefix.elements != NULL)
             && (i < PREFIXCOUNT)) {
        i++;
    }

    // i is now positioned on the first free entry in the table

    if (i == PREFIXCOUNT) {
     // No free space in table
      DPRINT(0,"Prefix Table Full?\n");
      return DSID(FILENO, __LINE__);
    }

    // Now parse the string

    // skip the first 4 bytes with the no. of prefixes
    memcpy(&dummy, &pBuf[nextByte], ulongSize);
    nextByte += ulongSize;

    // read the first 4 bytes containing the  size of the value
    memcpy(&totalSize, &pBuf[nextByte], ulongSize);
    nextByte += ulongSize;

    // Now read the prefixes one by one
    while( nextByte < totalSize) {

        if (i == PREFIXCOUNT) {
            // No free space in table
            DPRINT(0,"Prefix Table Full?\n");
            return DSID(FILENO, __LINE__);
         }
        Assert(PrefixTable[i].prefix.elements == NULL);

        // This is a prefix, so should have at least 4 bytes
        if ((nextByte + 4) > totalSize) {
          // something is wrong
          DPRINT(0,"Corrupted prefix\n");
          return DSID(FILENO, __LINE__);
        }

        // pick up the first two bytes (the index)

        memcpy(&index, &pBuf[nextByte], ushortSize);
        PrefixTable[i].ndx = (DWORD) index;
        nextByte += ushortSize;

        // pick up the next two bytes (Prefix length)

        memcpy(&length, &pBuf[nextByte], ushortSize);
        PrefixTable[i].prefix.length = length;
        nextByte += ushortSize;

        // Check if the length is valid. We don't want an AV
        // because the length got corrupted and we end up trying to
        // copy from after the end of the map
        // nextByte is now positioned at the beginning of the prefix

        if ( (nextByte + PrefixTable[i].prefix.length) > totalSize) {
          // something is wrong
          DPRINT1(0,"Length of Prefix is corrupted (index %d)\n",PrefixTable[i].ndx);
          return DSID(FILENO, __LINE__);
        }

        // Now copy the prefix itself

        if (SCCallocWrn(&PrefixTable[i].prefix.elements, 1, PrefixTable[i].prefix.length + 1)) {
           DPRINT(0,"Error allocating memory for prefix\n");
           return DSID(FILENO, __LINE__);
        }

        memcpy(PrefixTable[i].prefix.elements, &pBuf[nextByte], PrefixTable[i].prefix.length);
        nextByte += PrefixTable[i].prefix.length;

        // If this prefix we just added to the table is the same as
        // an earlier prefix loaded from the hardcoded table, replace
        // the copy of the hardcoded entry with the entry from the DIT.
        // The DIT always wins because the hardcoded entry in the new
        // binaries may collide with an existing prefix added with the
        // old binaries. Simply put, the system was upgraded and the ndx
        // used prior to the upgrade must be maintained because there
        // may be objects in the DIT that reference the attids based
        // on that ndx.
        if (!ReplaceHardcodedPrefix(PrefixTable, &PrefixTable[i])) {
            // This entry did not replace a hardcoded entry,
            // advance to the next free entry
            i++;

            // Increment the Prefix Count in the current threads schema ptr
            pSchemaPtr->PrefixTable.PrefixCount++;

        } // else a hardcoded entry was replaced; this entry is still free


      } /* while */


    return 0;
}



/////////////////////////////////////////////////////////////////////
// Appends a new prefix to the end of the prefix map
//
// Arguments: NewPrefix -- Prefix to be added
//            ndx       -- Index of new prefix
//            pBuf      -- start of prefix map to append to
//            fFirst    -- TRUE means first ever prefix in prefix-map
//                         FALSE means prefix-map already exists
//
// Assumes space is already allocated  at the end of pBuf
//
// Return Value: 0 on success, 1 on error
///////////////////////////////////////////////////////////////////

int AppendPrefix(OID_t *NewPrefix,
                 DWORD ndx,
                 UCHAR *pBuf,
                 BOOL fFirst)
{
    ULONG totalSize, oldTotalSizeSave, count, i, nextByte = 0, nextByteSave;
    ULONG Length = NewPrefix->length;

    int ulongSize, ushortSize;

    // USHORT = 16bits, ULONG = 32bits

    ulongSize = sizeof(ULONG);
    ushortSize = sizeof(USHORT);
    Assert(ulongSize==4);
    Assert(ushortSize==2);

    if (fFirst) {
        // Prefix-map does not exist, so need to create it

           totalSize = 2*ulongSize + 2*ushortSize + Length;
           count = 1;
           memcpy(pBuf,&count,ulongSize);
           pBuf+=ulongSize;
           memcpy(pBuf,&totalSize,ulongSize);
           pBuf+=ulongSize;
           memcpy(pBuf,&ndx,ushortSize);
           pBuf+=ushortSize;
           memcpy(pBuf,&Length,ushortSize);
           pBuf+=ushortSize;
           memcpy(pBuf,NewPrefix->elements,Length);
           return 0;
    }

    // Else, prefix-map already exists, need to append to it

    // update the no. of prefixes
    memcpy(&count, pBuf, ulongSize);
    count++;
    memcpy(pBuf, &count, ulongSize);

    nextByte += ulongSize;

    // Increment size of map.
    // 2 for the index, 2 for length, plus the prefix length
    memcpy(&totalSize, &pBuf[nextByte], ulongSize);

    oldTotalSizeSave = totalSize;

    totalSize += 2*ushortSize + Length;

    // Write new TotalSize back
    memcpy(&pBuf[nextByte], &totalSize, ulongSize);

    nextByte = oldTotalSizeSave; // beginning of place to write;

    // Write ndx in the first 2 bytes at the end of map
    memcpy(&pBuf[nextByte], &ndx, ushortSize);
    nextByte  += ushortSize;

    // Write length in the next 2 bytes
    memcpy(&pBuf[nextByte], &Length, ushortSize);
    nextByte  += ushortSize;

    // write the prefix
    memcpy(&pBuf[nextByte], NewPrefix->elements, Length);

    return 0;
}



/////////////////////////////////////////////////////////////////////
// Creates a new index for a new prefix object and adds it to a
// thread-specific storage
//
// Arguments: Prefix       -- the OID string with the new prefix (NOT
//                            just the actual prefix)
//            PrefixLength -- Length of the prefix in the OID string
//            ndx          -- Place to return the newly created index
//
// Returns: 0 on sucess, non-0 on error
/////////////////////////////////////////////////////////////////////

int AddPrefixIfNeeded(OID_t *Prefix,
                      unsigned PrefixLength,
                      DWORD *ndx)
{
    THSTATE *pTHS=pTHStls;
    DWORD i;
    PrefixTableEntry *ptr;
    int fNew;

    // We are here means that the prefix is not found in the global
    // prefix table. So first find an unused index (or the index
    // assigned to this prefix if it is already created by an earlier
    // schema operation, but the global schema cache is not yet
    // been updated)

    fNew = AssignIndex(Prefix, PrefixLength, &i);

    if (fNew == -1) {
      // Some error occured
      return 1;
    }

    if (fNew == 1) {

      // truely a new prefix, store it in the thread state

       pTHS->cNewPrefix++;
       if (pTHS->cNewPrefix == 1) {
         // This is the first new prefix

            ptr = (PrefixTableEntry *) THAllocOrgEx(pTHS, sizeof(PrefixTableEntry));
       }
       else {
         // Not the first new prefix for this thread

            ptr = (PrefixTableEntry *) THReAllocOrgEx(pTHS, pTHS->NewPrefix,
                          (pTHS->cNewPrefix)*(sizeof(PrefixTableEntry)));
       }

       pTHS->NewPrefix = ptr;

       // position on place to write

       ptr += pTHS->cNewPrefix - 1;
       ptr->ndx = i;
       ptr->prefix.length = PrefixLength;
       ptr->prefix.elements = THAllocOrgEx(pTHS, PrefixLength+1);
       if (ptr->prefix.elements == NULL) {
          DPRINT(0,"AddPrefix: Error allocating prefix space\n");
          // Reset new prefix count
          pTHS->cNewPrefix--;
          return 1;
       }
       memcpy(ptr->prefix.elements, Prefix->elements, ptr->prefix.length);

    }

    // return the index for the prefix
    *ndx = i;

    return 0;

}



/////////////////////////////////////////////////////////////////////////
// Finds a new random index that does not currently exist in the
// prefix table.  This function is called only by AddPrefix.
//
// WARNING: DB Currency is reset!
//
// Arguments: Prefix       -- the OID string with the new prefix (NOT
//                            just the actual prefix)
//            PrefixLength -- Length of the prefix in the OID string
//            ndx          -- Place to return the index
//
// Return Value: DB Currency is reset!
//               1 if the prefix is not already in the dit/thread-specific
//               new prefix storage, 0 if it is in the dit/Thread-storage
//               (but not yet in the schema cache, otherwise the prefix
//               would have been found earlier in FindPrefix)
//               -1 on error.
//
////////////////////////////////////////////////////////////////////////

int AssignIndex(OID_t *NewPrefix,
                unsigned PrefixLength,
                DWORD *ndx)
{
    THSTATE *pTHS=pTHStls;
    DWORD TempNdx;
    ULONG i, PREFIXCOUNT;
    SCHEMAPTR *OldSchemaPtr;
    PrefixTableEntry *PrefixTable, *ptr;
    ULONG CurrPrefixCount, newSize, newPREFIXCOUNT;
    int err=0, returnVal;
    BOOL bAllocedDBPos = FALSE;

    // Save pTHS->CurrSchemaPtr
    OldSchemaPtr = pTHS->CurrSchemaPtr;

    // If there isn't a DBPOS open a new one and remember to close it.

    if (!pTHS->pDB) {
        bAllocedDBPos = TRUE;
        DBOpen2(FALSE,&pTHS->pDB);
    }

    // Recalc thread-specifc prefix table from dit

    __try {
       if (err=RecalcPrefixTable()) {
          // error during RecalcPrefixTable
          // Set return val to indicate error
           returnVal = -1;
           __leave;
       }

       PREFIXCOUNT = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->PREFIXCOUNT;
       PrefixTable = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->PrefixTable.pPrefixEntry;

       // If there is any new prefix in thread-specific storage, add
       // it to the prefix table. This is needed since the head may
       // call FindPrefix multiple times with the same prefix before
       // the prefix is added to the dit. Also, replication thread
       // may add multiple prefixes in a single thread, and we need
       // to look at the prefixes' indices to make sure that a new prefix
       // gets a unique index

       if (pTHS->NewPrefix != NULL) {
         ptr = (PrefixTableEntry *) pTHS->NewPrefix;
         for (i=0; i<pTHS->cNewPrefix; i++, ptr++) {
            if (AddPrefixToTable(ptr, &PrefixTable, &PREFIXCOUNT)) {
               DPRINT(0,"AssignIndex:Error adding new prefix to prefix table\n");
               // Free the prefix table of the cache used for validation
                SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

               // Set return val to indicate error
                returnVal = -1;
                __leave;
            }
         }
       }

       // First check if prefix is already in dit (This is possible when
       // a prefix has been added as part of a previous successful schema
       // object update, but the schema cache has not been updated yet)
       // In this case, just return the stored index

       for (i=0; i<PREFIXCOUNT; i++) {
          if (PrefixTable[i].prefix.elements != NULL) {
             if ( (PrefixTable[i].prefix.length == PrefixLength) &&
                 (memcmp(PrefixTable[i].prefix.elements,
                     NewPrefix->elements,PrefixLength) == 0)) {

                // Prefix is found, return the corresponding index

                *ndx = PrefixTable[i].ndx;

                // Free the cache used for validation
                SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

                // Set return value to indicate not really a new prefix
                // (so that it won't be added to the thread on return)
                returnVal = 0;
                __leave;
              }
           }
        }

       // Prefix is truely new. New index need to be assigned to it
       // first generate a random index between 100 and 65,500
       // and check if clashing with any existing prefix

       {
       BOOL flag = TRUE;

       srand((unsigned) time(NULL));

       while (flag) {
           TempNdx = rand() % _invalidPrefIndex;

           // check if clashing with MS-prefix reservered index range
           if (TempNdx < MS_RESERVED_PREFIX_RANGE) {
              continue;
           }

         // check if its a duplicate index
           for (i=0; i<PREFIXCOUNT; i++) {
              if (PrefixTable[i].ndx == TempNdx) {
                break;
              }
           }
           if (i == PREFIXCOUNT) {
            // index is not duplicate
             flag = FALSE;
           }
       }

       // return the index
       *ndx = TempNdx;

       // free the thread-specific schema cache used for validation
       SCFreePrefixTable(&PrefixTable, PREFIXCOUNT);

       // Set return value to indicate this is truely a new prefix
       // (so that it will be added to the thread on return)
       returnVal = 1;
       __leave;

       }


    } /* try */
    __finally {
       // Restore the schema pointer
       pTHS->CurrSchemaPtr = OldSchemaPtr;

       if (bAllocedDBPos) {
           DBClose(pTHS->pDB,FALSE);
       }
    }

    return returnVal;
}

////////////////////////////////////////////////////////////////////////
// Adds a PrefixTableEntry structure to a Prefix Table
//
// Arguments: NewPrefix   -- entry to add
//            Table       -- Start of Prefix Table
//            PREFIXCOUNT -- Size of table
//
// return Value: 0 on success, non-0 on error
////////////////////////////////////////////////////////////////////////
int AddPrefixToTable(PrefixTableEntry *NewPrefix,
                     PrefixTableEntry **ppTable,
                     ULONG *pPREFIXCOUNT)
{
    ULONG i;
    ULONG CurrPREFIXCOUNT = (*pPREFIXCOUNT);
    PrefixTableEntry *Table = (*ppTable);
 


    // Find the first free entry in the table
    for (i=0; i<CurrPREFIXCOUNT; i++) {
      if (Table[i].prefix.elements == NULL) {
          break;
      }
    }

    // If table is full, grow it

    if (i == CurrPREFIXCOUNT) {

      DPRINT(0,"AddPrefixToTanle: Prefix Table is full, growing prefix table\n");
      // Grow table to twice the current size

      if (SCReallocWrn(&Table, 2*CurrPREFIXCOUNT*sizeof(PrefixTableEntry))) {
        DPRINT(0, "Error reallocing prefix table\n");
        return 1;
      }

      // zero out the unloaded part, since it may contain junk and
      // so freeing may fail

      ZeroMemory(&Table[CurrPREFIXCOUNT], CurrPREFIXCOUNT*sizeof(PrefixTableEntry));

      // ok, we have now doubled the size, and i is correctly pointing
      // to the first free entry. But we need to return this new size
      // and the new table pointer.
      // Return it irrespective of success or failure later in this
      // function since the table size is already grown and the table is
      // realloced.

      (*pPREFIXCOUNT) = 2*CurrPREFIXCOUNT;
      (*ppTable) = Table;
    }

    // Add prefix to table

    Table[i].ndx = NewPrefix->ndx;
    Table[i].prefix.length = NewPrefix->prefix.length;
    if (SCCallocWrn(&Table[i].prefix.elements, 1, NewPrefix->prefix.length + 1 )) {
       DPRINT(0, "AddPrefixToTable: Mem. Allocation error\n");
       return 1;
    }
    memcpy( Table[i].prefix.elements, NewPrefix->prefix.elements,
                        Table[i].prefix.length);

    // If the same prefix is also loaded from the hardcoded table,
    // replace it. Should never happen here, but just to be sure
    (VOID)ReplaceHardcodedPrefix(Table, &Table[i]);

    return 0;
}


////////////////////////////////////////////////////////////////////////
//
//  Checks if the prefix NewPrefix is in the first part of the
//  PrefixTable that is hardcoded (that is, the first MsPrefixCount
//  no. of prefixes. If so, replace that prefix since NewPrefix
//  got created implies that that hardcoded prefix wasn't there
//  because of older binaries when this prefix got created
//
//  Arguments:
//      PrefixTable - Pointer to the prefix table
//      NewPrefix - pointer to the prefix
//
//  Return Value:
//      TRUE if replaced entry; FALSE if it did not
//
/////////////////////////////////////////////////////////////////////////
BOOL ReplaceHardcodedPrefix(PrefixTableEntry *PrefixTable,
                            PrefixTableEntry *NewPrefix)
{

    ULONG i;

    for (i=0; i<MSPrefixCount; i++) {
        Assert(PrefixTable[i].prefix.elements);
        if ( (PrefixTable[i].prefix.length == NewPrefix->prefix.length)
                && (memcmp(PrefixTable[i].prefix.elements,
                            NewPrefix->prefix.elements,
                            PrefixTable[i].prefix.length) == 0)) {

            // replacing a previously replaced entry is okay if the
            // ndx matches. It should never happen, but there are no
            // known problems with dup entries that have the same ndx.
            Assert(   PrefixTable[i].ndx < MS_RESERVED_PREFIX_RANGE
                   || PrefixTable[i].ndx == NewPrefix->ndx);

            // Don't replace a previously replaced entry.
            if (PrefixTable[i].ndx >= MS_RESERVED_PREFIX_RANGE) {
                continue;
            }

            // replace hardcoded entry with entry from DIT
            free(PrefixTable[i].prefix.elements);
            PrefixTable[i].prefix.length = NewPrefix->prefix.length;
            PrefixTable[i].prefix.elements = NewPrefix->prefix.elements;
            PrefixTable[i].ndx = NewPrefix->ndx;

            // Free entry read from DIT
            NewPrefix->prefix.length = 0;
            NewPrefix->prefix.elements = NULL;
            NewPrefix->ndx = 0;

            return TRUE;
        }
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
int WritePrefixToSchema(THSTATE *pTHS)
{
    DBPOS *pDB = NULL;
    DWORD err = 0;
    BOOL fCommit = FALSE;

    __try  {
        // if any new prefixes were created,
        // write it to the prefix-map

        if (pTHS->NewPrefix != NULL) {

           ULONG cLen, totalSize, i;
           USHORT length, index;
           UCHAR *pBuf;
           PrefixTableEntry *ptr;
           int ulongSize, ushortSize;
           DSNAME *pDMD;

           ulongSize = sizeof(ULONG);
           ushortSize = sizeof(USHORT);
           Assert(ulongSize==4);
           Assert(ushortSize==2);


           DBOpen(&pDB);

           if ( DsaIsRunning() ) {
               pDMD = gAnchor.pDMD;
           }
           else {
               // Installing.  Write prefix table to the new DMD rather than the
               // one in O=Boot.
               WCHAR       *pSchemaDNName = NULL;
               DWORD       ccbSchemaDNName = 0;
               ULONG       SchemaDNSize, SchemaDNLength;

               err = GetConfigParamAllocW(SCHEMADNNAME_W, &pSchemaDNName, &ccbSchemaDNName);

               if (!err) {
                   SchemaDNLength = wcslen( pSchemaDNName );
                   SchemaDNSize = DSNameSizeFromLen( SchemaDNLength );
                   pDMD = (DSNAME*) THAllocEx( pTHS, SchemaDNSize );

                   pDMD->structLen = SchemaDNSize;
                   pDMD->NameLen = SchemaDNLength;
                   wcscpy( pDMD->StringName, pSchemaDNName );
                   free (pSchemaDNName); 
               }
               else {
                   _leave;
               }
           }

           if ( (err = DBFindDSName(pDB, pDMD)) == 0) {

               ptr = (PrefixTableEntry *) pTHS->NewPrefix;

               for (i=0; i<pTHS->cNewPrefix; i++, ptr++) {
                  err = DBGetAttVal(pDB,
                                    1,
                                    ATT_PREFIX_MAP,
                                    DBGETATTVAL_fREALLOC,
                                    0,
                                    &cLen,
                                    (UCHAR **) &pBuf);

                  switch (err) {
                   case DB_ERR_NO_VALUE:
                   // this is the first new prefix that is being added ever

                      totalSize = 2*ulongSize + 2*ushortSize + ptr->prefix.length;
                      pBuf = (UCHAR *) THAllocEx(pTHS, totalSize);
                      if (AppendPrefix(&(ptr->prefix), ptr->ndx, pBuf, TRUE)) {
                        __leave;
                      }
                      break;
                   case 0:
                     // prefix-map already exists

                     totalSize = cLen + 2*ushortSize + ptr->prefix.length;

                     pBuf = (UCHAR *) THReAllocEx(pTHS, pBuf, totalSize);
                     if (AppendPrefix(&(ptr->prefix), ptr->ndx, pBuf, FALSE)) {
                       __leave;
                     }
                     break;
                   default :
                       // Some error occured in DBGetAttVal
                     __leave;
                  } /* switch */

                 // Write the new prefix-map
                 if ((err = DBRemAtt(pDB, ATT_PREFIX_MAP)) != DB_ERR_SYSERROR) {
                     err = DBAddAttVal(pDB, ATT_PREFIX_MAP, totalSize, pBuf);
                 }
                 if (err) {
                   __leave;
                 }
               } /* for */


           if (!err) {
              err = DBRepl( pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
            }
          } /* DBFindDSName */

      } /* pTHS->NewPrefix != NULL */

      if (0 == err) {
          fCommit = TRUE;
      }
    } /* try */
    __finally {
       if (pDB) {
        DBClose(pDB,fCommit);
       }
    }


    if (err){
    // this error is really misleading.  Surely we can do better?
        SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,DIRERR_ILLEGAL_MOD_OPERATION);
    }

    return err;

} // End WritePrefixToSchema

// Current limits on OID string length and value count
#define cchOIDMost      200
#define cvalOIDMost     40

BOOL IsValidOID(
    IN  OID_t*  oidBER
    )
/*++
Routine Description:
    Determines if an encoded OID has a valid number of values and has a string
    representation that is short enough to be represented by the server.

Arguments:
    oidBER - the encoded OID.

Return Values:
    TRUE if the OID is valid, FALSE otherwise.
--*/
{
    OID oidStruct;
    // add 4 for L"OID." prefix added by OidStructToString
    WCHAR wszOID[4 + cchOIDMost];
    BOOL fValid = TRUE;

    oidStruct.Val = (unsigned *)THAlloc((1 + oidBER->length)*(sizeof(unsigned)));
    if (!oidStruct.Val ||
        !DecodeOID(oidBER->elements, oidBER->length, &oidStruct) ||
        oidStruct.cVal > cvalOIDMost ||
        !OidStructToString(&oidStruct, wszOID, sizeof(wszOID) / sizeof(wszOID[0]))) {
        fValid = FALSE;
    }
    THFree(oidStruct.Val);

    return fValid;
}


///////////////////////////////////////////////////////////////////////
// Returns the ndx and the length of the prefix of a given OID. If the
// prefix doesn't exist, a new prefix is created , new unused ndx assigned to
// it, and is stored in th pTHS's NewPrefix field. The new prefix will
// later be made persistent if this is a schema object add/modify and the
// object is added to the dit.
//
// Arguments: OID    - OID string
//            index  - index corresponding to OID prefix returned in this
//            length - length of prefix returned in this
//            longId - Set to 1 on return if it is found that the last
//                     decimal in the dotted decimal OID string is encoded
//                     in 3 or more bytes, otherwise set to 0 on return.
//                     This is used on return for special encodings
//                     of the attrtype
//
// Returns TRUE on success, FALSE otherwise
////////////////////////////////////////////////////////////////////////

BOOL FindPrefix(OID_t *OID,
                DWORD *index,
                unsigned *length,
                int  *longID,
                BOOL fAddToTable)
{
    DECLAREPREFIXPTR
    DWORD i, ndx;
    unsigned PrefixLen;

    // make sure we have an OID, and that it is at least 2 chars long.
    if((!OID) || (!(OID->elements)) || (OID->length < 2))
        return FALSE;

    

    if ((OID->length > 2) &&
        (((unsigned char *)(OID->elements))[OID->length - 2] & 0x80)) {
          PrefixLen = OID->length - 2;
      if ( (((unsigned char *)(OID->elements))[OID->length - 3] & 0x80)) {
        // Last decimal encoded took three or more octets. Will need special
        // encoding in attrtype. See OidStrToAttrType for details
        *longID = 1;
      }
      // no special encoding in attrtyp needed
      else {
        *longID = 0;
      }
    }
    else {
        PrefixLen = OID->length - 1;
    }

    // Look through the table for this prefix;
    for(i=0;i<PREFIXCOUNT ;i++) {
        /* Prefixes must match all but the last 1 or two bytes of
         * the OID string depending on the nature of the string,
         * and the location where the suffix starts (why? because
         * it's the nature of ASN.1 encoding.) So, don't compare
         * memory unless the prefix is the right length
         */

        if ((PrefixTable[i].prefix.elements != NULL) &&
            (PrefixTable[i].prefix.length == PrefixLen) &&
            (0 == memcmp(PrefixTable[i].prefix.elements,
                         OID->elements,
                         PrefixTable[i].prefix.length))) {
            *index = PrefixTable[i].ndx;
        *length= PrefixTable[i].prefix.length;
            return TRUE;
        }
    }

    if (!fAddToTable) {
        return FALSE;
    }

    // The execution is here means no prefix is found in the global
    // prefix table. So add a new prefix (or find it if the prefix
    // is already added but not yet updated in the schema cache)
    // and return the index it maps to

    if (!IsValidOID(OID)) {
        DPRINT(0, "New OID is invalid (too long, too many levels)\n");
        return FALSE;
    }

     if (AddPrefixIfNeeded(OID, PrefixLen, &ndx)) {
          DPRINT(0, "Error adding new prefix\n");
          return FALSE;
       }
     *index = ndx;
     *length= PrefixLen;

    return TRUE;

}


// Returns the index into the prefix table in "index" if the given ndx is found

BOOL FindNdx(DWORD ndx, DWORD *index)
{
    DECLAREPREFIXPTR
    DWORD i;

    // Look through the table for this prefix;
    for(i=0;i<PREFIXCOUNT ;i++) {
    /* Prefixes must match all but the last 1 or two bytes of
     * the OID string depending on the nature of the string,
     * and the location where the suffix starts (why? because
     * it's the nature of ASN.1 encoding.) So, don't compare
     * memory unless the prefix is the right length
     */

    if ((PrefixTable[i].prefix.elements != NULL) &&
        (PrefixTable[i].ndx == ndx)) {
        *index = i;
        return TRUE;
    }

    }

    return FALSE;
}


// returns 0 on success, non-0 on failure
ULONG OidToAttrCache (OID_t *OID, ATTCACHE ** ppAC)
{
    THSTATE *pTHS=pTHStls;
    DECLAREPREFIXPTR
    ATTRTYP attrtyp;
    DWORD   Ndx;
    unsigned Length;
    int LongID = 0;

    *ppAC = NULL;

    if(!FindPrefix(OID, &Ndx, &Length, &LongID, TRUE)) {
        return 1;
    }

    attrtyp = Ndx << 16;

    // handle the case where we have two bytes after the prefix;
    if (  OID->length == Length + 2 )
    {
      attrtyp += ( ((unsigned char *)OID->elements)[OID->length - 2] & 0x7f ) << 7;
      if (LongID == 1) {
        // Put a 1 in the 16th bit to indicate that both bytes of the
        // attrtype is to be considered during the reverse mapping
        // See OidStrToAttrTyp for Details
      attrtyp |= (0x8000);
      }
    }

    attrtyp += ((unsigned char *)OID->elements)[OID->length - 1];

    // check the tokenized OID hash table
    if (*ppAC = SCGetAttByExtId(pTHS, attrtyp)) {
        return 0;
    }
    else {
        return 2;
    }
}


ATTRTYP
KeyToAttrType (
        THSTATE *pTHS,
        WCHAR * pKey,
        unsigned cc
        )
/*++
Routine Description:
    Translates a key value (primarily used in string representations of DNs
    e.g. O or OU of OU=Foo,O=Bar) to the attrtype for the attribute it implies.

Arguments
    pKey - pointer to the key to be translated from.
    cc - count of charactes in the key.

Return Values
    the attrtyp implied, or 0 if the key did not correspond to a known attrtyp.
--*/
{
    ATTRTYP     at;
    ATTCACHE    *pAC;
    DWORD       cName;
    PUCHAR      pName;
    BOOL        fIntId;
    ULONGLONG   ullVal;

    // 99% case
    if (0 != (at = KeyToAttrTypeLame(pKey, cc))) {
        return at;
    }

    if (cc == 0 || pKey == NULL) {
        return 0;
    }

    // Check for the ldap display name in the schema cache.
    //
    // Handle DNs of the form foo=xxx,bar=yyy, where foo and bar are the
    // LdapDisplayNames of arbitrary attributes that may or may not be 
    // defined in the schema. KeyToAttrType is enhanced to call 
    // SCGetAttByName if KeyToAttrTypeLame fails, and before trying the
    // OID decode.  The rest of this change consists of enhancing the 
    // default clause of AttrTypeToKey to call SCGetAttById and to return
    // a copy of the pAC->name (LdapDisplayName).
    //
    // Convert UNICODE pKey into UTF8 for scache search
    // Note: the scache is kept in UTF8 format for the ldap head.
    pName = THAllocEx(pTHS, cc);
    cName = WideCharToMultiByte(CP_UTF8,
                                0,
                                pKey,
                                cc,
                                pName,
                                cc,
                                NULL,
                                NULL);
    if (   (cName == cc) 
        && (pAC = SCGetAttByName(pTHS, cc, pName)) ) {
        at = pAC->id;
    }
    THFreeEx(pTHS, pName);

    //
    // FOUND AN LDN
    //
    if (at) {
        return at;
    }

    //
    // Not an LDN. See if it is an OID or an IID
    //

    // ignore trailing spaces
    while (cc && pKey[cc-1] == L' ') {
        --cc;
    }

    // Skip leading "OID." or "IID."
    fIntId = FALSE;
    if (   (cc > 3)
        && (   pKey[0] == L'O' 
            || pKey[0] == L'I'
            || pKey[0] == L'o'
            || pKey[0] == L'i')
        && (pKey[1] == L'I' || pKey[1] == L'i')
        && (pKey[2] == L'D' || pKey[2] == L'd')
        && (pKey[3] == L'.')) {

        // IID.xxx
        if (pKey[0] == L'I' || pKey[0] == L'i') {
            fIntId = TRUE;
        }
        pKey += 4;
        cc -= 4;
    }

    // Must have at least one digit!
    if (cc == 0) {
        return 0;
    }

    //
    // Key is a number representing the msDS-IntId
    //
    if (fIntId) {
        // Validate and convert string into a DWORD
        ullVal = (ULONGLONG)0;
        while (cc) {
            if (iswdigit(*pKey)) {
                ullVal = (ullVal * (ULONGLONG)10) + (*pKey - L'0');
                // 32bit Overflow
                if (ullVal > (ULONGLONG)0xFFFFFFFF) {
                    return 0;
                }
            } else {
                // not a decimal digit
                return 0;
            }
            --cc;
            ++pKey;
        }
        return (ATTRTYP)ullVal;
    }

    //
    // Must be an OID
    //

    if (iswdigit(*pKey)) {
        // Possibly a literal OID.
        OID oid;
        OID_t Encoded;
        char buf[128];
        ATTRTYP attrtype;
        
        // Allocate room for the oid struct (each decimal can only
        // be paired with one dot, except the last, which has none)
        oid.cVal = cc/2 + 1;
        oid.Val = (unsigned *) THAlloc(((cc/2) + 1)*(sizeof(unsigned)));
        if (!oid.Val) {
            return 0;    //Failure.
        }
        
        // turn the OID.1.2.3 string into an OID structure
        if (OidStringToStruct(pTHS, pKey, cc, &oid) != 0) {
            THFreeEx(pTHS,oid.Val);
            return 0;   // Failure.
        }

        // produce a BER encoded version of the OID
        Encoded.length = EncodeOID(&oid, buf, sizeof(buf));
        THFreeEx(pTHS,oid.Val);
        if (!Encoded.length) {
            return 0;   // Failure.
        }
        Encoded.elements = buf;

        // convert from the encoded OID to an ATTRTYP
        if (OidToAttrType(pTHS, TRUE, &Encoded, &at)) {
            return 0;   // Failure.
        }
        
        // AttrTypes are internal ids (msDS-IntId).
        return SCAttExtIdToIntId(pTHS, at);
    }

    return 0;
}

ULONG
OidToAttrType (
        THSTATE *pTHS,
        BOOL fAddToTable,
        OID_t *OID,
        ATTRTYP *attrtyp
        )
/*++
Routine Description:
    Given an encoded OID (a.k.a. the binary value handed to the ds by the XDS
    interface), find the internal attrtyp encoding.  Also, if asked to, add
    the prefix to the prefix attribute in the DS if it does not already
    exist.

Arguments:
    fAddTotable - if the prefix is not found, add it to the prefix attribute
    OID - the encoded OID.
    attrtyp - pointer to an attrtyp to fill in.

Return Values:
    0 if all went well, a core error code otherwise.
--*/
{
    DECLAREPREFIXPTR
    DWORD   Ndx;
    unsigned Length;
    ATTCACHE * pAC;
    CLASSCACHE * pCC;
    BOOL    found = FALSE;
    int LongID = 0;


    if(!FindPrefix(OID,&Ndx, &Length, &LongID, fAddToTable)) {
        return PR_PROBLEM_UNDEFINED_ATT_TYPE;
    }

    *attrtyp = Ndx << 16;

    // handle the case where we have two bytes after the prefix;
    if (  OID->length == Length + 2 )
    {
      *attrtyp += ( ((unsigned char *)OID->elements)[OID->length - 2] & 0x7f ) << 7;
      if (LongID == 1) {
        // Put a 1 in the 16th bit to indicate that both bytes of the
        // attrtype is to be considered during the reverse mapping.
        // This is to take care of the case when the last decimal
        // in the dotted decimal string is mapped in 3 or 4 octets.
        // If the last decimal in the dotted decimal string mapped onto
        // more than one octet, the encoding scheme earlier used to just
        // put the last 7 bits of the last two octets of the BER encoded
        // OID into the last 14-bits of the attrtype, with the top two
        // bits set to 0. The decoding scheme (from attrtype to BER
        // encoding) used simply checks if bit 8-15 (counting from bit 0)
        // of the attrtype is > 0  to determine
        // if the prefix length is OID length - 2 or not (OID length -1)
        // This worked fine as long as the last decimal fitted within 2 bytes
        // in the BER encoding (decimals upto 16383, actually even 127 less
        // than that because of another bug in the encoding process, fixed
        // along with this in EncodeOID). However,
        // if the decimal becomes too big so that it is encoded in 3 or more
        // octets, for some decimals (depending on the bit string in the last
        // two bytes; for example, for 16384, where the last 16 bits in the
        // attrtype would be all 0), the decoding scheme used to infer the
        // bytes from the attrtype to be appended to the prefix
        // incorrectly (1 instead of 2), thereby giving out wrong
        // oids when printed out. Putting a 1 in the 16th bit (which is
        // unused anyway) makes sure that both bytes are appended to the
        // prefix during the decoding process in such cases.
        // [CAUTION] ArobindG 7/28/97: We do this only for 3 octets or more,
        // and not for two, since this will result in a different internal
        // id for an OID compared to the earlier schema, and many existing
        // OIDs have the last decimal encoded into two octets and we do not
        // want their internal ids changed (since dogfood machines are
        // already running with them)

      *attrtyp |= (0x8000);
      }

    }

    *attrtyp += ((unsigned char *)OID->elements)[OID->length - 1];

    return 0;
}

ULONG
AttrTypeToOid (
        ATTRTYP attrtyp,
        OID_t *OID
        )
/*++
Routine Description:
    Given an attrtype, return the encoded OID (a.k.a. the binary value returned
    to the DUA across the XDS interface.)

Arguments:
    attrtyp - the attrtyp to fill encode.
    OID - structure to hold the encoded OID.

Return Values:
    0 if all went well, non-zero on failure
--*/
{
    DECLAREPREFIXPTR
    DWORD   i, ndx;

    ndx = ( attrtyp & 0xFFFF0000 ) >> 16;
    if (FindNdx(ndx, &i) == FALSE) {
        LogEvent(DS_EVENT_CAT_XDS_INTERFACE,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_CODE_INCONSISTENCY,
                 NULL,
                 NULL,
                 NULL);
        return 1;
    }


    if ((attrtyp & 0xFFFF ) < 0x80) {
      OID->length = PrefixTable[i].prefix.length + 1;
      OID->elements = THAlloc (OID->length);
      if ( OID->elements == NULL) {
          return 2;
      }
      memcpy (OID->elements, PrefixTable[i].prefix.elements,PrefixTable[i].prefix.length);

      (( unsigned char *)OID->elements)[ OID->length - 1 ] =
          ( unsigned char ) ( attrtyp & 0xFF );
    }
    else {
      OID->length = PrefixTable[i].prefix.length + 2;
      OID->elements = THAlloc (OID->length);
      if ( OID->elements == NULL) {
          return 3;
      }
      memcpy (OID->elements, PrefixTable[i].prefix.elements,PrefixTable[i].prefix.length);

      (( unsigned char *)OID->elements)[ OID->length - 1 ] =
          ( unsigned char ) (attrtyp  & 0x7F );

      // Note here that the 16th bit in the attrtype may be a 1, since
      // the encoding of the decimal may have taken 3 or 4 octets. So
      // or'ing with FF80 and then right shifting by 7 may still leave
      // a 1 in the 9th bit, and hence a number greater than what can fit
      // in 1 byte (unsigned char). Does not matter since the typecasting
      // to unsigned char assigns only the lower 8 bits. So left this
      // unchanged.

      (( unsigned char *)OID->elements)[ OID->length - 2 ] =
          ( unsigned char )  (( (attrtyp & 0xFF80) >> 7 ) | 0x80 );
    }

    return 0;
}

/*++ EncodeOID
 *
 * Takes an OID in structure format and constructs a BER encoded octet
 * string representing that OID.
 *
 * INPUT:
 *    pOID     - Pointer to an OID structure to be encoded
 *    pEncoded - Pointer to a *preallocated* buffer that will hold the
 *               encoded octet string.
 *    ccEncoded - count of chars in pEncoded
 *
 * OUTPUT:
 *    pEncoded - Buffer holds the encoded OID
 *
 * RETURN VALUE:
 *    0        - Value could not be encoded (bad OID or buffer too small)
 *    non-0    - Length of resulting octet string, in bytes
 */
unsigned EncodeOID(OID *pOID, unsigned char * pEncoded, unsigned ccEncoded) {
    int i;
    unsigned len;
    unsigned val;

    // check for obviously invalid OIDs or outbuf sizes

    if (ccEncoded == 0
        || pOID->cVal <= 2
        || pOID->Val[0] > 2
        || (pOID->Val[0] < 2 && pOID->Val[1] > 39)) {
        return 0;       // error
    }

    // The first two values in the OID are encoded into a single octet
    // by a really appalling rule, as shown here.

    *pEncoded = (pOID->Val[0] * 40) + pOID->Val[1];
    len = 1;

    // For all subsequent values, each is encoded across multiple bytes
    // in big endian order (MSB first), seven bits per byte, with the
    // high bit being clear on the last byte, and set on all others.

    // PERFHINT -- The value can be directly checked against the hex value
    // instead of building up the bit patterns in a strange way.

    for (i=2; i<pOID->cVal; i++) {
        val = pOID->Val[i];
        if (val > ((0x7f << 14) | (0x7f << 7) | 0x7f) ) {
            // Do we need 4 octets to represent the value?
            // Make sure it's not 5
            // Assert(0 == (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)));
            if (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)) {
              DPRINT1(0,"Decimal %u in OID too big\n", val);
              return 0;   // we can't encode things this big
            }
            // buffer too small
            if (len == ccEncoded) {
                return 0;
            }
            pEncoded[len++] = 0x80 | ((val >> 21) & 0x7f);
        }
        if (val > ((0x7f << 7) | 0x7f) ) {
            // Do we need 3 octets to represent the value?
            // buffer too small
            if (len == ccEncoded) {
                return 0;
            }
            pEncoded[len++] = 0x80 | ((val >> 14) & 0x7f);
        }
        if (val > 0x7f) {
            // Do we need 2 octets to represent the value?
            // buffer too small
            if (len == ccEncoded) {
                return 0;
            }
            pEncoded[len++] = 0x80 | ((val >> 7) & 0x7f);
        }
        // Encode the low 7 bits into the last octet for this value
        // buffer too small
        if (len == ccEncoded) {
            return 0;
        }
        pEncoded[len++] = val & 0x7f;
    }

    return len;
}

/*++ DecodeOID
 *
 * Takes a BER encoded OID as an octet string and returns the OID in
 * structure format.
 *
 * INPUT:
 *    pEncoded - Pointer to a buffer holding the encoded octet string.
 *    len      - Length of the encoded OID
 *    pOID     - Pointer to a *preallocated* OID structure that will
 *               be filled in with the decoded OID.
 *
 * OUTPUT:
 *    pOID     - Structure is filled in with the decoded OID
 *
 * RETURN VALUE:
 *    0        - value could not be decoded (bad OID)
 *    non-0    - OID decoded successfully
 */
BOOL DecodeOID(unsigned char *pEncoded, int len, OID *pOID) {
    unsigned cval;
    unsigned val;
    int i, j;

    if (len < 2) {
    return FALSE;
    }

    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;
    cval = 2;
    i = 1;

    while (i < len) {
    j = 0;
    val = pEncoded[i] & 0x7f;
    while (pEncoded[i] & 0x80) {
        val <<= 7;
        ++i;
        if (++j > 4 || i >= len) {
        // Either this value is bigger than we can handle (we
        // don't handle values that span more than four octets)
        // -or- the last octet in the encoded string has its
        // high bit set, indicating that it's not supposed to
        // be the last octet.  In either case, we're sunk.
        return FALSE;
        }
        val |= pEncoded[i] & 0x7f;
    }
    Assert(i < len);
    pOID->Val[cval] = val;
    ++cval;
    ++i;
    }
    pOID->cVal = cval;

    return TRUE;
}



#define iswdigit(x) ((x) >= L'0' && (x) <= L'9')

OidStringToStruct (
        THSTATE *pTHS, 
        WCHAR * pString,
        unsigned len,
        OID * pOID
        )
/*++
Routine Description:
    Translates a string of the format "OID.X.Y.Z"  or "X.Y.Z"
    to an oid structure of the format {count=3, val[]={X,Y,Z}}

Arguments
    pString - the string format oid.
    pLen - the length of pString in characters.
    pOID - pointer to an OID structure to fill in.  Note: the value field must
    be pre-allocated and the len field should hold the number of values
    pre-allocated.

Return Values
    o if successfull, non-0 if a failure occurred.
--*/
{
    int i;
    int numVals = pOID->cVal;
    unsigned val;
    ULARGE_INTEGER val64, checkVal;
    WCHAR * pCur = pString;
    WCHAR * pEnd = pString + len;
    WCHAR * pTemp;
    BOOL  fFoundDot=TRUE;


    checkVal.QuadPart = 0xFFFFFFFF;

    // Must have non-zero-length
    if (len == 0) {
        return 1;
    }

    if (*pCur == L'O' || *pCur == L'o') {
       // The string must start with OID.

        if (len < 5 || // must be at least as long as "OID.1"
            (*++pCur != L'I' && *pCur != L'i') ||
            (*++pCur != L'D' && *pCur != L'd') ||
            (*++pCur != L'.')) {
            return 1;
        }
        // The string starts with OID. Ok to proceed. Make
        // pCur point to the first character after the '.'
        pCur++;
     }

    // pCur is now positioned on the first character in the
    // first decimal in the string (if the string didn't start
    // with OID., I will assume it starts with a decimal. If not,
    // it will fail in the code below as desired)

    pOID->cVal = 0;

    // Skip spaces at the end
    pTemp = pEnd - 1;
    while ( (pTemp > pCur) && (*pTemp == L' ') ) {
       pTemp--;
    }
    pEnd = pTemp + 1;
    
    while (pCur < pEnd) {
        fFoundDot = FALSE;
        if (!iswdigit(*pCur)) {
            return 2;
        }
        val = *pCur - L'0';
        val64.QuadPart = *pCur - L'0';
        ++pCur;
        while (pCur < pEnd && *pCur != L'.') {
            if (!iswdigit(*pCur)) {
                // not a digit
                return 3;
            }
              
            val = 10*val + *pCur - L'0';
            val64.QuadPart = 10*(val64.QuadPart) + *pCur - L'0';

            // This value should fit in 32 bits, as we load this into
            // a 32 bit value and EncodeOID later assumes that the value
            // indeed fits in 32 bits

            if (val64.QuadPart > checkVal.QuadPart) {
               // Value does not fit in 32 bits. Too big anyway, since
               // BER encoding is valid for only values that fit in 28
               // bits. Reject the string

               return 5;
             }

            ++pCur;
        }
        // Keep track of whether we found a dot for the last character.
        fFoundDot = (pCur < pEnd);
        if(pOID->cVal >= numVals) {
            return 4;
        }
        pOID->Val[pOID->cVal] = val;
        pOID->cVal++;
        ++pCur;
    }

    // If the last character we found was a dot, then this is an invalid
    // string.  Otherwise, everything is OK.
    return fFoundDot;
}

unsigned
AttrTypeToIntIdString (
        ATTRTYP attrtyp,
        WCHAR   *pOut,
        ULONG   ccOut
        )
/*++
Routine Description:
    Translates an attrtyp into a string of the format "IID.X"
    where X is the base 10 representation of the attrtyp
    (which should be the msDs-IntId, not the tokenized OID)

Arguments
    attrtyp - to be converted (msDs-IntId)
    pOut - preallocated string to fill in.
    ccOut - count of chars in pOut

Return Values
    number of characters in the resulting string.
--*/
{
    OID Oid;

    Oid.cVal = 1;
    Oid.Val = &attrtyp;

    ccOut = OidStructToString(&Oid, pOut, ccOut);
    if (ccOut) {
        // change OID. -> IID.
        Assert(*pOut == L'O');
        *pOut = L'I';
    }
    return (unsigned)ccOut;
}

unsigned
OidStructToString (
        OID *pOID,
        WCHAR *pOut,
        ULONG ccOut
        )
/*++
Routine Description:
    Translates a structure in the format
         {count=3, val[]={X,Y,Z}}
    to a string of the format "OID.X.Y.Z".

Arguments
    pOID - pointer to an OID structure to translate from.
    pOut - preallocated string to fill in.
    ccOut - count of chars in pOut

Return Values
    0 if not enough space; otherwise the
    number of characters in the resulting string.
--*/
{
    int i;
    WCHAR *pCur = pOut, *pEnd, *pVal;
    WCHAR Val[16]; // large enough to convert a 32bit number
                   // into an unsigned decimal string including
                   // the terminating NULL

    // PREFIX:  init Val to silence bogus warning caused by _ultow
    Val[0] = 0;

    // need enough space for at least OID.X
    if (ccOut < 5) {
        return 0;
    }

    // pEnd is the first char past the end of pOut
    pEnd = pOut + ccOut;

    // pOut = "OID"
    *pCur++ = L'O';
    *pCur++ = L'I';
    *pCur++ = L'D';

    // .X.Y.Z...
    for (i=0; i<pOID->cVal; i++) {
        if (pCur == pEnd) {
            return 0;
        }
        *pCur++ = L'.';
        _ultow(pOID->Val[i], Val, 10);
        for (pVal = Val; *pVal; ) {
            if (pCur == pEnd) {
                return 0;
            }
            *pCur++ = *pVal++;
        }
    }
    return (unsigned)(pCur - pOut);
}

int
AttrTypToString (
        THSTATE *pTHS,
        ATTRTYP attrTyp,
        WCHAR *pOutBuf,
        ULONG cLen
        )
/*++
Routine Description:
    Given an attrtype, return the dotted string representation in unicode.

Arguments:
    attrTyp - the attribute type to convert
    pOutBuf - pointer to a buffer to hold the unicode string.  
    cLen - length of the buffer in no. of characters

Return Values:
    the len of the string as characters, 
    -1 for errors other that insufficient buffer size
    -2 for insufficient buffer size
--*/
{
    OID_t Oid;
    OID                  oidStruct;
    unsigned             len;
    BOOL                 fOK;
    WCHAR                *pTemp;
    ULONG                cMaxChar;

    // First, build the OID describing the attrtype
    if(AttrTypeToOid (attrTyp, &Oid)) {
        return -1;
    }

    // Allocate space in oidStruct to hold the decoded decimals in the
    // dotted decimal string. Number of elements in the dotted string cannot
    // be more than Oid.length (length in bytes of the BER encoded string) + 1.
    // This is the case where each byte in the BER encoded string unencodes to a
    // single element in the oid structure (the other option is that it takes
    // multiple bytes in the BER encoding to get one element in the oid
    // structure).  The additional element is because the first byte in the BER
    // encoding ALWAYS encodes for two elements in the OID structure.  As an
    // example, the BER encoding 0x55,0x05,Ox7 translates to 1.2.5.7 (the first
    // 0x55 translates to 1.2., while the rest are single byte encodings.)
    // plus 1 (since the first two decimals in the dotted decimal string
    // are encoded into a single byte)

    oidStruct.Val = (unsigned *) THAlloc((1 + Oid.length)*(sizeof(unsigned)) );
    if (!oidStruct.Val) {
        return -1;   //fail to alloc
    }

    fOK = DecodeOID(Oid.elements, Oid.length, &oidStruct);
    THFreeEx(pTHS,Oid.elements);
    if(!fOK) {
        THFreeEx(pTHS,oidStruct.Val);
        return -1;
    }

    // Now, turn the OID to a string
    // OidStructToString expects a big enough buffer, so give it one. Note that 
    // the max no. of characters that can be there in the final string is
    // 3 (for "OID") + 1 (for ".") for each of the decimals, plus at most 9
    // for the string representation of each of the decimals (since each decimal
    // can be at most (2^28 - 1) from the nature of BER encoding)
    // So if the buffer supplied is big enough, use it directly,
    // else alloc a local buffer and use it, then copy to the output buffer
   // the actual no. of characters if buffer size is sufficient
   
    cMaxChar = 3 + 10*oidStruct.cVal;
    
    if (cLen >= cMaxChar) {
       len = OidStructToString(&oidStruct, pOutBuf, cLen);
    }
    else {
       pTemp = (WCHAR *) THAlloc(cMaxChar * sizeof(WCHAR));
       if (!pTemp) {
           THFreeEx(pTHS,oidStruct.Val);
           return -1;  //fail to alloc
       }
       len = OidStructToString(&oidStruct, pTemp, cMaxChar);

       // check if the buffer supplied to us is big enough
       if (cLen < len) {
         // buffer not big enough
         THFreeEx(pTHS,oidStruct.Val);
         THFreeEx(pTHS,pTemp);
         return (-2);
       }

       // ok, buffer is big enough. Copy to output
       memcpy(pOutBuf, pTemp, len*sizeof(WCHAR));
       THFreeEx(pTHS,pTemp);
    }

    THFreeEx(pTHS,oidStruct.Val);
    return len;

}

int
StringToAttrTyp (
        THSTATE *pTHS,
        WCHAR   *pInString,
        ULONG   len,
        ATTRTYP *pAttrTyp
        )
/*++
Routine Description:
    Given an attrtype, return the dotted string representation in unicode.

Arguments:
    attrTyp - the attribute type to convert
    pOutBuf - pointer to a buffer to hold the unicode string.  Must be large
    enough

Return Values:
    the len of the string as characters, -1 if something went wrong.
--*/
{
    OID oidStruct;
    // Each character in the OID string can take at most 4 octets
    // in the BER encoding
    OID_t EncodedOID;
    ULONG cbEncoded = (4 * len) * sizeof(unsigned char);
    unsigned char *Encoded = (unsigned char *)THAlloc(cbEncoded);

    if (!Encoded) {
        return -1; //fail to alloc
    }


    EncodedOID.elements = Encoded;

    // First, turn the string into an OID struct.

    // Allocate space first. Can be at most len no. of elements
    oidStruct.cVal = len;
    oidStruct.Val = (unsigned *) THAlloc((len*(sizeof(unsigned))));
    if (!oidStruct.Val) {
        THFreeEx(pTHS,Encoded);
        return -1; //fail to alloc
    }


    if(   OidStringToStruct(pTHS, pInString,len,&oidStruct)     
       // Turn the OID struct into an encoded OID.
       || !(EncodedOID.length = EncodeOID(&oidStruct, Encoded, cbEncoded))
       // Now, turn the encoded oid into an attrtyp
       || OidToAttrType(pTHS, TRUE, &EncodedOID, pAttrTyp))
    {
        THFreeEx(pTHS,Encoded);
        THFreeEx(pTHS,oidStruct.Val);
        return -1;
    }
    
    THFreeEx(pTHS,Encoded);
    THFreeEx(pTHS,oidStruct.Val);
    return 0;
}


#if DBG
////////////////////////////////////////////////////////////////////////////
// Debug routine to print out a prefix table
//////////////////////////////////////////////////////////////////////
void PrintPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT)
{
   ULONG i;
   UCHAR temp[200];
   DWORD       ib;
   BYTE *      pb;


   for (i=0; i<PREFIXCOUNT; i++) {
     pb = (LPBYTE) PrefixTable[i].prefix.elements;
     if (pb != NULL) {
       for ( ib = 0; ib < PrefixTable[i].prefix.length; ib++ )
        {
             sprintf( &temp[ ib * 2 ], "%.2x", *(pb++) );
        }
       temp[2*PrefixTable[i].prefix.length]='\0';
       DPRINT4(0,"%2d. Ndx=%-4d Length=%-3d Prefix=%s\n",i,PrefixTable[i].ndx,PrefixTable[i].prefix.length, temp);
     }
   }
  DPRINT(0, "Exitting Prefix table Print\n");
}
#endif


// Simple SCHEMA_PREFIX_MAP_ENTRY comparison routine for use by qsort().
int __cdecl CompareMappings(const void * pvMapping1, const void * pvMapping2)
{
    SCHEMA_PREFIX_MAP_ENTRY * pMapping1 = (SCHEMA_PREFIX_MAP_ENTRY *) pvMapping1;
    SCHEMA_PREFIX_MAP_ENTRY * pMapping2 = (SCHEMA_PREFIX_MAP_ENTRY *) pvMapping2;

    return (int)pMapping1->ndxFrom - (int)pMapping2->ndxFrom;
}


BOOL
PrefixTableAddPrefixes(
    IN  SCHEMA_PREFIX_TABLE *   pRemoteTable
    )
/*++

Routine Description:

    Scan the given prefix table and add entries in our own table for any
    missing prefixes.

Arguments:

    pTable (IN) - Table to incorporate into our own.

Return Values:

    TRUE - success.
    FALSE - failure.

--*/
{
    THSTATE               * pTHS=pTHStls;
    BOOL                    ok = TRUE;
    DWORD                   iRemote, iLocal;
    SCHEMA_PREFIX_TABLE   * pLocalTable;
    OID_t                 * pPrefixStr;
    DWORD                   ndx;

    pLocalTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    for (iRemote = 0; ok && (iRemote < pRemoteTable->PrefixCount); iRemote++) {
        pPrefixStr = &pRemoteTable->pPrefixEntry[iRemote].prefix;

        // Do we already have this prefix?
        for (iLocal = 0; iLocal < pLocalTable->PrefixCount; iLocal++) {
            if ((pLocalTable->pPrefixEntry[iLocal].prefix.length == pPrefixStr->length)
                && (0 == memcmp(pLocalTable->pPrefixEntry[iLocal].prefix.elements,
                                pPrefixStr->elements,
                                pPrefixStr->length))) {
                // Found matching local prefix.
                break;
            }
        }

        if (iLocal == pLocalTable->PrefixCount) {
            // Local prefix not found; add it.
            if (AddPrefixIfNeeded(pPrefixStr, pPrefixStr->length, &ndx)) {
                DPRINT(0, "Failed to incorporate new OID prefix.\n");
                ok = FALSE;
            }
        }
    }

    return ok;
}


SCHEMA_PREFIX_MAP_HANDLE
PrefixMapOpenHandle(
    IN  SCHEMA_PREFIX_TABLE *   pTableFrom,
    IN  SCHEMA_PREFIX_TABLE *   pTableTo
    )
/*++

Routine Description:

    Generate a mapping handle given two prefix tables for use in later calls to
    PrefixMapAttr() and PrefixMapTypes().

    Caller is responsible for eventually calling PrefixMapCloseHandle() on
    the returned handle.

Arguments:

    pTableFrom (IN) - holds the prefixes for the ATTRTYPs being mapped from.
    pTableTo (IN) - holds the prefixes for the ATTRTYPs being mapped to.

Return Values:

    The generated handle.

--*/
{
    THSTATE *                   pTHS = pTHStls;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap;
    OID_t *                     pPrefixStr;
    DWORD                       iFrom, iTo;
    SCHEMA_PREFIX_TABLE *       pLocalTable;
    PrefixTableEntry *          pNewPrefix = (PrefixTableEntry *) pTHS->NewPrefix;

    pLocalTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;

    hPrefixMap = THAllocEx(pTHS, SchemaPrefixMapSizeFromLen(pTableFrom->PrefixCount));

    hPrefixMap->pTHS = pTHS;
    if (pTableFrom == pLocalTable) {
        hPrefixMap->dwFlags = SCHEMA_PREFIX_MAP_fFromLocal;
    }
    else if (pTableTo == pLocalTable) {
        hPrefixMap->dwFlags = SCHEMA_PREFIX_MAP_fToLocal;
    }

    for (iFrom = 0; (iFrom < pTableFrom->PrefixCount); iFrom++) {
        // Only the lower 16 bits of an ndx should be significant.
        Assert((ULONG) (USHORT) pTableFrom->pPrefixEntry[iFrom].ndx
               == pTableFrom->pPrefixEntry[iFrom].ndx);

        pPrefixStr = &pTableFrom->pPrefixEntry[iFrom].prefix;

        for (iTo = 0; (iTo < pTableTo->PrefixCount); iTo++) {
            // Only the lower 16 bits of an ndx should be significant.
            Assert((ULONG) (USHORT) pTableTo->pPrefixEntry[iTo].ndx
                   == pTableTo->pPrefixEntry[iTo].ndx);

            if ((pPrefixStr->length
                 == pTableTo->pPrefixEntry[iTo].prefix.length)
                && !memcmp(pPrefixStr->elements,
                           pTableTo->pPrefixEntry[iTo].prefix.elements,
                           pPrefixStr->length)) {

                // Found matching prefix; generate a mapping entry.
                hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxFrom
                    = (USHORT) pTableFrom->pPrefixEntry[iFrom].ndx;

                hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxTo
                    = (USHORT) pTableTo->pPrefixEntry[iTo].ndx;

                hPrefixMap->cNumMappings++;
                break;
            }
        }

        if ((iTo == pTableTo->PrefixCount)
             && (hPrefixMap->dwFlags & SCHEMA_PREFIX_MAP_fToLocal)) {
            // No matching prefix found in the global cache; do we have one
            // in our thread's new prefix table?
            for (iTo = 0; iTo < pTHS->cNewPrefix; iTo++) {
                // Only the lower 16 bits of an ndx should be significant.
                Assert((ULONG) (USHORT) pNewPrefix[iTo].ndx
                       == pNewPrefix[iTo].ndx);

                if ((pPrefixStr->length
                     == pNewPrefix[iTo].prefix.length)
                    && !memcmp(pPrefixStr->elements,
                               pNewPrefix[iTo].prefix.elements,
                               pPrefixStr->length)) {

                    // Found matching prefix; generate a mapping entry.
                    hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxFrom
                        = (USHORT) pTableFrom->pPrefixEntry[iFrom].ndx;

                    hPrefixMap->rgMapping[hPrefixMap->cNumMappings].ndxTo
                        = (USHORT) pNewPrefix[iTo].ndx;

                    hPrefixMap->cNumMappings++;
                    break;
                }
            }
        }

        // Note that if no matching prefix was found in pTableTo, we simply fail
        // to add an entry in the mapping table for the corresponding "from"
        // ndx.  SUCH FAILURES ARE *NOT* FATAL.  If an attempt is later made to
        // map this ndx, a failure will be generated at that time.  If not, it
        // doesn't matter that we were unable to generate a mapping.
    }

    if (hPrefixMap->cNumMappings < pTableFrom->PrefixCount) {
        // Not all prefixes were mapped; release the memory allocated for the
        // unused mapping entries back to the heap.
        hPrefixMap = THReAllocEx(pTHS,
                                 hPrefixMap,
                         SchemaPrefixMapSizeFromLen(hPrefixMap->cNumMappings));
    }

    // Sort the mapping table by ndxFrom.
    qsort(&hPrefixMap->rgMapping[0],
          hPrefixMap->cNumMappings,
          sizeof(hPrefixMap->rgMapping[0]),
          &CompareMappings);

    return hPrefixMap;
}


BOOL
PrefixMapTypes(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN      DWORD                     cNumTypes,
    IN OUT  ATTRTYP *                 pTypes
    )
/*++

Routine Description:

    Map one or more ATTRTYPs from one prefix table to another.

Arguments:

    hPrefixMap (IN) - a mapping handle previously opened via
        PrefixMapOpenHandle().
    cNumTypes (IN) - number of types to convert.
    pTypes (IN/OUT) - array of types to convert.

Return Values:

    TRUE - attribute type(s) converted successfully.
    FALSE - conversion failed.

--*/
{
    SCHEMA_PREFIX_MAP_ENTRY *   pMapping;
    SCHEMA_PREFIX_MAP_ENTRY     MappingKey;
    DWORD                       iType;
    BOOL                        ok = TRUE;

    Assert(NULL != hPrefixMap);

    for (iType = 0; iType < cNumTypes; iType++) {
        // Find matching "from" ndx in mapping table.
        MappingKey.ndxFrom = (USHORT) (pTypes[iType] >> 16);

        pMapping = bsearch(&MappingKey,
                           &hPrefixMap->rgMapping[0],
                           hPrefixMap->cNumMappings,
                           sizeof(hPrefixMap->rgMapping[0]),
                           &CompareMappings);

        if (NULL != pMapping) {
            // Mapping found; convert the type.
            pTypes[iType] = (((ULONG) pMapping->ndxTo) << 16)
                            | (pTypes[iType] & 0xFFFF);
        } else if (pTypes[iType] <= LAST_MAPPED_ATT) {

            // The lack of a mapping is okay if the attid falls outside
            // the range of mapped attids. In that case, return success
            // and leave the attid unchanged. But if the attid falls
            // within the range of mapped attids and there is no mapping,
            // return failure.

            ok = FALSE;
            break;
        }
    }

    if (!ok) {
        DPRINT1(1, "Unable to map attribute 0x%x.\n", pTypes[iType]);
    }

    return ok;
}


BOOL
PrefixMapAttr(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTR *                    pAttr
    )
/*++

Routine Description:

    Convert ATTRTYPs embedded in an ATTR structure to or from their equivalents
    on a remote machine.

Arguments:

    hPrefixMap (IN) - a mapping handle previously opened via
        PrefixMapOpenHandle().
    pAttr (IN/OUT) - the ATTR to convert.

Return Values:

    TRUE - attribute type (and all of its values, if necessary) converted
        successfully.
    FALSE - conversion failed.

--*/
{
    THSTATE    *pTHS=hPrefixMap->pTHS;
    BOOL        ok = TRUE;
    ATTCACHE *  pAC;
    DWORD       iVal;
    ATTRTYP     typeFrom;
    ATTRTYP     typeLocal;

    Assert(NULL != hPrefixMap);

    // One of the "from" or "to" tables must be the local table.
    Assert(hPrefixMap->dwFlags & (SCHEMA_PREFIX_MAP_fFromLocal
                                  | SCHEMA_PREFIX_MAP_fToLocal));

    typeFrom = pAttr->attrTyp;

    if (PrefixMapTypes(hPrefixMap, 1, &pAttr->attrTyp)) {
        // Successfully mapped pAttr->attrTyp.
        typeLocal = (hPrefixMap->dwFlags & SCHEMA_PREFIX_MAP_fFromLocal)
                        ? typeFrom : pAttr->attrTyp;

        pAC = SCGetAttById(pTHS, typeLocal);

        if (NULL != pAC) {
            if (SYNTAX_OBJECT_ID_TYPE == pAC->syntax) {
                // Convert attribute's values.
                for (iVal = 0; ok && (iVal < pAttr->AttrVal.valCount); iVal++) {
                    ok = PrefixMapTypes(hPrefixMap, 1,
                                        (ATTRTYP *) pAttr->AttrVal.pAVal[iVal].pVal);
                }
            }
        }
        else if (typeFrom <= LAST_MAPPED_ATT) {
            // The lack of a mapping is okay if the attid falls outside
            // the range of mapped attids. In that case, return success
            // and leave the attid unchanged. But if the attid falls
            // within the range of mapped attids and there is no mapping,
            // return failure.

            // No ATTCACHE for this attribute.
            // and it is not one of the virtual attributes defined in objids.h.
            DPRINT1(0, "Unable to find ATTCACHE for local attribute %u.\n",
                    typeLocal);
            ok = FALSE;
        }
    }
    else {
        // Conversion of pAttr->attrTyp failed.
        ok = FALSE;
    }

    return ok;
}


BOOL
PrefixMapAttrBlock(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTRBLOCK *               pAttrBlock
    )
/*++

Routine Description:

    Map all ATTRTYPs embedded in an ATTRBLOCK structure.

Arguments:

    hPrefixMap (IN) - a mapping handle previously opened via
        PrefixMapOpenHandle().
    pAttrBlock (IN/OUT) - the ATTRBLOCK to convert.

Return Values:

    TRUE - success.
    FALSE - failure.

--*/
{
    BOOL  ok = TRUE;
    DWORD iAttr;

    Assert(NULL != hPrefixMap);
    Assert(NULL != pAttrBlock);

    for (iAttr = 0; ok && iAttr < pAttrBlock->attrCount; iAttr++) {
        ok = PrefixMapAttr(hPrefixMap, &pAttrBlock->pAttr[iAttr]);
    }

    return ok;
}

BOOL
OIDcmp (OID_t const *string1,
        OID_t const *string2)
{
    unsigned i;
    
    if (string1->length != string2->length)
        return FALSE;
    
    // optimize for OIDs, which differ ususally at the end
    for(i=string1->length; i> 0; i--) {
        if ((string1->elements)[i-1] !=
            (string2->elements)[i-1]      ) {
            return FALSE;
        }
    }
    
    return TRUE;
}


#define CHARTONUM(chr) (isalpha(chr)?(tolower(chr)-'a')+10:chr-'0')


unsigned
StringToOID (
        char* Stroid,
        OID_t *Obj
        )
/*++
Routine Description:
    Converts a hex char string into an OID string

Arguments:
    IN  stroid - char string
    OUT Obj    - OID_t kind of string
Return Values
    0 on success, non-0 on failure
--*/
{
    UCHAR  tmp[2048];
    int   i;
    int len=strlen(Stroid);


    if (len/2 > sizeof(tmp))
    {
        return 1;
    }

    //
    // Skip leading '\x' in str
    //

    if (Stroid[0]!='\\' || tolower(Stroid[1]!='x'))
    {
        return 2;
    }

    for (i=2;i<(len-1);i+=2)
    {
        UCHAR hi=CHARTONUM(Stroid[i])*16;
        UCHAR lo=CHARTONUM(Stroid[i+1]);
        tmp[(i-2)/2]=hi+lo;
    }

    //
    // The last byte...
    //
    if (i<len)
    {
        tmp[(i-2)/2]=CHARTONUM(Stroid[i]);
        i+=2;
    }

    Obj->length  =(i-2)/2;
    Obj->elements=(unsigned char *)calloc(1,Obj->length);

    if (Obj->elements)
    {
        CopyMemory
        (
            Obj->elements,
            tmp,
            Obj->length
        );
    }
    else
    {
        return 3;
    }

    return 0;
}


ULONG
OidStrToAttrType(THSTATE *pTHS,
                 BOOL fAddToTable,
                 char* StrOid,
                 ATTRTYP *attrtyp)
{
    unsigned err;
    OID_t OID;

    err = StringToOID(StrOid,&OID);

    if (err == 0)
    {
        err = OidToAttrType(pTHS, fAddToTable, &OID, attrtyp);
        free(OID.elements);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\permit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       permit.c
//
//--------------------------------------------------------------------------

/****************************************************************************
    PURPOSE:    Permission checking procedure to be called by the DSA

    FUNCTIONS:  CheckPermissions is the procedure that performs this task.

    COMMENTS:   This function must be called by a server within the context
        of impersonating a client. This can be done by calling
        RpcImpersonateClient() or ImpersonateNamedPipeClient(). This
        creates an impersonation token which is vital for AccessCheck
****************************************************************************/

#include <NTDSpch.h>
#pragma hdrstop

#define SECURITY_WIN32
#include <sspi.h>
#include <samisrv2.h>
#include <ntsam.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <rpcasync.h>

#include <ntdsa.h>
#include "scache.h"
#include "dbglobal.h"
#include <mdglobal.h>
#include "mdlocal.h"
#include <dsatools.h>
#include <objids.h>
#include <debug.h>

#define DEBSUB "PERMIT:"

#include "permit.h"
#include "anchor.h"

#include <dsevent.h>
#include <fileno.h>
#define FILENO FILENO_PERMIT

#include <checkacl.h>
#include <dsconfig.h>

extern PSID gpDomainAdminSid;
extern PSID gpSchemaAdminSid;
extern PSID gpEnterpriseAdminSid;
extern PSID gpBuiltinAdminSid;
extern PSID gpAuthUserSid;


// Debug only hook to turn security off with a debugger
#if DBG == 1
DWORD dwSkipSecurity=FALSE;
#endif

VOID
DumpToken(HANDLE);

VOID
PrintPrivileges(TOKEN_PRIVILEGES *pTokenPrivileges);

DWORD
SetDefaultOwner(
        IN  PSECURITY_DESCRIPTOR    CreatorSD,
        IN  ULONG                   cbCreatorSD,
        IN  HANDLE                  ClientToken,
        IN  ADDARG                  *pAddArg,
        OUT PSECURITY_DESCRIPTOR    *NewCreatorSD,
        OUT PULONG                  NewCreatorSDLen
        );

DWORD
VerifyClientIsAuthenticatedUser(
    AUTHZ_CLIENT_CONTEXT_HANDLE authzCtx
    );

WCHAR hexDigits[] = { 
    L'0', L'1', L'2', L'3', L'4', L'5', L'6', L'7',
    L'8', L'9', L'a', L'b', L'c', L'd', L'e', L'f'
};


__inline void
Hex(
    OUT     WCHAR*  wsz,
    IN      BYTE*   rgbData,
    IN      size_t  cbData
    )
{
    size_t ibData;
    
    rgbData += cbData-1;
    for (ibData = 0; ibData < cbData; ibData++, rgbData--, wsz+=2) {
        wsz[0] = hexDigits[*rgbData >> 4];
        wsz[1] = hexDigits[*rgbData & 0x0F];
    }
}

__inline void
Guid(
    OUT     WCHAR*  wsz,
    IN      GUID*   pguid
    )
{
    wsz[0] = L'%';
    wsz[1] = L'{';
    Hex(&wsz[2], (BYTE*)&pguid->Data1, 4);
    wsz[10] = L'-';
    Hex(&wsz[11], (BYTE*)&pguid->Data2, 2);
    wsz[15] = L'-';
    Hex(&wsz[16], (BYTE*)&pguid->Data3, 2);
    wsz[20] = L'-';
    Hex(&wsz[21], &pguid->Data4[0], 1);
    Hex(&wsz[23], &pguid->Data4[1], 1);
    wsz[25] = L'-';
    Hex(&wsz[26], &pguid->Data4[2], 1);
    Hex(&wsz[28], &pguid->Data4[3], 1);
    Hex(&wsz[30], &pguid->Data4[4], 1);
    Hex(&wsz[32], &pguid->Data4[5], 1);
    Hex(&wsz[34], &pguid->Data4[6], 1);
    Hex(&wsz[36], &pguid->Data4[7], 1);
    wsz[38] = L'}';
    wsz[39] = L'\0';
}

#define AUDIT_OPERATION_TYPE_W L"Object Access"

DWORD
CheckPermissionsAnyClient(
    PSECURITY_DESCRIPTOR pSelfRelativeSD,
    PDSNAME pDN,
    CLASSCACHE* pCC,
    ACCESS_MASK ulDesiredAccess,
    POBJECT_TYPE_LIST pObjList,
    DWORD cObjList,
    ACCESS_MASK *pGrantedAccess,
    DWORD *pAccessStatus,
    DWORD flags,
    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCtx,
    PWCHAR szAdditionalInfo,       OPTIONAL
    GUID*  pAdditionalGUID         OPTIONAL
    )
//
// CheckPermissionsAnyClient is the 'any' flavor of CheckPermissions. It assumes
// the server is currently treating a non-NP client, and is currently in its
// own security context. If the Authz context is not found in the thread state,
// the client will be impersonated on behalf of the server and the context created.
// Optionally, an authz client context can be passed in in hAuthzCtx.
//
// Parameters:
//
//  pSelfRelativeSD   pointer to the valid self relative security descriptor
//                    against which access is checked. (read only).
//  
//  pDN               DN of the object we are checking.  We only care about
//                    the GUID and SID.
//
//  pCC               object class of the object, used for auditing
//
//  DesiredAccess     access mask of requested permissions. If the generic
//                    bits are set they are mapped into specific and standard rights
//                    using DS_GENERIC_MAPPING. (read only)
//
//  pObjList          Array of OBJECT_TYPE_LIST objects describing the objects we are
//                    trying to check security against.
//
//  cObjList          the number of elements in pObjList
//
//  pGrantedAccess    pointer to an array of ACCESS_MASKs of the same number of
//                    elements as pObjList (i.e. cObjList).  Gets filled in with
//                    the actual access granted. If CheckPermissions was't successful
//                    this parameter's value is undefined. (write only)
//                    This parameter may be NULL if this info is not important
//
//  pAccessStatus     pointer to an array of DWORDs to be set to indicate
//                    whether the requested access was granted (0) or not (!0). If CheckPermissions
//                    wasn't successful this parameter's value is undefined. (write only)
//
//  flags             pass CHECK_PERMISSIONS_WITHOUT_AUDITING to disable audit generation
//                    pass CHECK_PERMISSIONS_AUDIT_ONLY to only trigger an audit (used in DeleteTree)
//
//  hAuthzCtx         (optional) -- pass Authz client context (this is used only in RPC callbacks,
//                    where there is no THSTATE). If hAuthzCtx is passed, then we will not cache
//                    hAuthzAuditInfo in the THSTATE either.
//  
//  szAdditionalInfo  (optional) additional info string, to be used for auditing. Generally used to
//                    record new object DN (in create, move, delete and undelete).
//
//  pAdditionalGUID   (optional) additional guid, create_child audits have child's guid, moves have parent's guid.
//
// Returns:
//
//   0 if successful. On failure the result of GetLastError() immediately
//   following the unsuccessful win32 api call.
//
{
    THSTATE        *pTHS = pTHStls;
    GENERIC_MAPPING GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK     DesiredAccess = (ACCESS_MASK) ulDesiredAccess;
    DWORD           ReturnStatus = 0;
    BOOL            bTemp=FALSE;
    RPC_STATUS      RpcStatus;
    PSID            pPrincipalSelfSid;
    WCHAR           GuidStringBuff[40]; // Long enough for a stringized guid
                                        // plus a prepended "%{", an
                                        // appended "}", and a final NULL.
    WCHAR           ObjectClassGuidBuff[40];  
    WCHAR           AdditionalGuidBuff[40];

    AUTHZ_CLIENT_CONTEXT_HANDLE authzClientContext;
    AUTHZ_ACCESS_REQUEST authzAccessRequest;
    AUTHZ_ACCESS_REPLY authzAccessReply;
    AUTHZ_AUDIT_EVENT_HANDLE hAuthzAuditInfo;
    DWORD dwError;
    BOOL bCreatedGrantedAccess = FALSE;

    // pTHS might be NULL when this is called from an RPC callback (VerifyRpcClientIsAuthenticated)
    // in this case we require that authz client context is passed in
    Assert(pAccessStatus && (pTHS || hAuthzCtx) && ghAuthzRM);
    Assert ( (flags | CHECK_PERMISSIONS_FLAG_MASK) == CHECK_PERMISSIONS_FLAG_MASK);
    // pCC (objectClass) is required if we are doing an audit
    Assert((flags & CHECK_PERMISSIONS_WITHOUT_AUDITING) || pCC != NULL);

#ifdef DBG
    if( dwSkipSecurity ) {
        // NOTE:  THIS CODE IS HERE FOR DEBUGGING PURPOSES ONLY!!!
        // Set the top access status to 0, implying full access.
        *pAccessStatus=0;
        if (pGrantedAccess) {
            *pGrantedAccess = ulDesiredAccess;
        }

        return 0;
    }
#endif

    //
    // Check self relative security descriptor validity
    // We assume that once the SD is in the database, it should be ok. Thus, a debug check only
    Assert(IsValidSecurityDescriptor(pSelfRelativeSD) && 
           "Invalid Security Descriptor passed. Possibly still in SD single instancing format.");

    if(pDN->SidLen) {
        // we have a sid
        pPrincipalSelfSid = &pDN->Sid;
    }
    else {
        pPrincipalSelfSid = NULL;
    }

    // if auditing was requested, create an audit info struct
    if (flags & CHECK_PERMISSIONS_WITHOUT_AUDITING) {
        hAuthzAuditInfo = NULL; // no auditing
    }
    else {
        Assert(!fNullUuid(&pDN->Guid));
        
        // Set up the stringized guid
        Guid(GuidStringBuff, &pDN->Guid);
        // set up object class string
        if (pCC) {
            Guid(ObjectClassGuidBuff, &pCC->propGuid);
        }
        else {
            // no object class -- use an empty string
            ObjectClassGuidBuff[0] = L'\0';
        }

        if (szAdditionalInfo == NULL) {
            szAdditionalInfo = L"";
        }

        if (pAdditionalGUID) {
            Guid(AdditionalGuidBuff, pAdditionalGUID);
        }
        else {
            // no child guid -- use an empty string
            AdditionalGuidBuff[0] = L'\0';
        }

        // try to grab audit info handle from THSTATE
        if (pTHS && (hAuthzAuditInfo = pTHS->hAuthzAuditInfo)) {
            // there was one already! update it
            bTemp = AuthziModifyAuditEvent2(
                AUTHZ_AUDIT_EVENT_OBJECT_NAME |
                AUTHZ_AUDIT_EVENT_OBJECT_TYPE |
                AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO |
                AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO2,
                hAuthzAuditInfo,                // audit info handle
                0,                              // no new flags
                NULL,                           // no new operation type
                ObjectClassGuidBuff,            // object type
                GuidStringBuff,                 // object name
                szAdditionalInfo,               // additional info
                AdditionalGuidBuff              // additional info2
                );
            if (!bTemp) {
                ReturnStatus = GetLastError();
                DPRINT1(0, "AuthzModifyAuditInfo failed: err 0x%x\n", ReturnStatus);
                goto finished;
            }
        }
        else {
            // create the structure
            bTemp = AuthzInitializeObjectAccessAuditEvent2(
                AUTHZ_DS_CATEGORY_FLAG |
                AUTHZ_NO_ALLOC_STRINGS,         // dwFlags
                NULL,                           // audit event type handle
                AUDIT_OPERATION_TYPE_W,         // operation type
                ObjectClassGuidBuff,            // object type
                GuidStringBuff,                 // object name
                szAdditionalInfo,               // additional info
                AdditionalGuidBuff,             // additional info2
                &hAuthzAuditInfo,               // audit info handle returned
                0                               // mbz
                );

            if (!bTemp) {
                ReturnStatus = GetLastError();
                DPRINT1(0, "AuthzInitializeAuditInfo failed: err 0x%x\n", ReturnStatus);
                goto finished;
            }
            if (pTHS) {
                // cache it in the THSTATE for future reuse
                pTHS->hAuthzAuditInfo = hAuthzAuditInfo;
            }
        }
    }

    // if pGrantedAccess was not supplied, we need to allocate a temp one
    if (pGrantedAccess == NULL) {
        // if no THSTATE is available, we require that pGrantedAccess is passed in
        Assert(pTHS);
        pGrantedAccess = THAllocEx(pTHS, cObjList * sizeof(ACCESS_MASK));
        bCreatedGrantedAccess = TRUE;
    }

    MapGenericMask(&DesiredAccess, &GenericMapping);

    // set up request struct
    authzAccessRequest.DesiredAccess = DesiredAccess;
    authzAccessRequest.ObjectTypeList = pObjList;
    authzAccessRequest.ObjectTypeListLength = cObjList;
    authzAccessRequest.OptionalArguments = NULL;
    authzAccessRequest.PrincipalSelfSid = pPrincipalSelfSid;

    // set up reply struct
    authzAccessReply.Error = pAccessStatus;
    authzAccessReply.GrantedAccessMask = pGrantedAccess;
    authzAccessReply.ResultListLength = cObjList;
    authzAccessReply.SaclEvaluationResults = NULL;

    if (pTHS) {
        // grab the authz client context from THSTATE
        // if it was never obtained before, this will impersonate the client, grab the token,
        // unimpersonate the client, and then create a new authz client context
        ReturnStatus = GetAuthzContextHandle(pTHS, &authzClientContext);
        if (ReturnStatus != 0) {
            DPRINT1(0, "GetAuthzContextHandle failed: err 0x%x\n", ReturnStatus);
            goto finished;
        }
    }
    else {
        // authz client context was passed in (this is checked by an assert above)
        authzClientContext = hAuthzCtx;
    }

    Assert(authzClientContext != NULL);

    if (flags & CHECK_PERMISSIONS_AUDIT_ONLY) {
        // do an audit check only. Access should have been already granted (e.g. delete-tree on the root)
        DWORD i;
        for (i = 0; i < cObjList; i++) {
            pGrantedAccess[i] = DesiredAccess;
            pAccessStatus[i] = 0;
        }
        // No additional SDs are passed
        bTemp = AuthzOpenObjectAudit(
            0,                          // flags
            authzClientContext,         // client context handle
            &authzAccessRequest,        // request struct
            hAuthzAuditInfo,            // audit info
            pSelfRelativeSD,            // the SD
            NULL,                       // no additional SDs
            0,                          // zero count of additional SDs
            &authzAccessReply           // reply struct
            );
        if (!bTemp) {
            ReturnStatus = GetLastError();
            DPRINT1(0, "AuthzOpenObjectAudit failed: err 0x%x\n", ReturnStatus);
            goto finished;
        }
    }
    else {
        // Check access of the current process
        // No additional SDs are passed
        bTemp = AuthzAccessCheck(
            0,                          // flags
            authzClientContext,         // client context handle
            &authzAccessRequest,        // request struct
            hAuthzAuditInfo,            // audit info
            pSelfRelativeSD,            // the SD
            NULL,                       // no additional SDs
            0,                          // zero count of additional SDs
            &authzAccessReply,          // reply struct
            NULL                        // we are not using AuthZ handles for now
            );
        if (!bTemp) {
            ReturnStatus = GetLastError();
            DPRINT1(0, "AuthzAccessCheck failed: err 0x%x\n", ReturnStatus);
            goto finished;
        }
    }


finished:
    if (bCreatedGrantedAccess) {
        // note: pGrantedAccess is only created if pTHS is non-null
        THFreeEx(pTHS, pGrantedAccess);
    }
    if (pTHS == NULL && hAuthzAuditInfo) {
        // get rid of the audit info (since we could not cache it in THSTATE)
        AuthzFreeAuditEvent(hAuthzAuditInfo);
    }

    return ReturnStatus;
}

BOOL
SetPrivateObjectSecurityLocalEx (
        SECURITY_INFORMATION SecurityInformation,
        PSECURITY_DESCRIPTOR pOriginalSD,
        ULONG                cbOriginalSD,
        PSECURITY_DESCRIPTOR ModificationDescriptor,
        PSECURITY_DESCRIPTOR *ppNewSD,
        ULONG                AutoInheritFlags,
        PGENERIC_MAPPING     GenericMapping,
        HANDLE               Token)
{
    BOOL bResult;
    *ppNewSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbOriginalSD);
    if(!*ppNewSD) {
        return FALSE;
    }
    memcpy(*ppNewSD, pOriginalSD, cbOriginalSD);

    bResult = SetPrivateObjectSecurityEx(
            SecurityInformation,
            ModificationDescriptor,
            ppNewSD,
            AutoInheritFlags,
            GenericMapping,
            Token);
    if (!bResult) {
        RtlFreeHeap(RtlProcessHeap(), 0, *ppNewSD);
        *ppNewSD = NULL;
    }
    return bResult;
}


DWORD
MergeSecurityDescriptorAnyClient(
        IN  THSTATE              *pTHS,
        IN  PSECURITY_DESCRIPTOR pParentSD,
        IN  ULONG                cbParentSD,
        IN  PSECURITY_DESCRIPTOR pCreatorSD,
        IN  ULONG                cbCreatorSD,
        IN  SECURITY_INFORMATION SI,
        IN  DWORD                flags,
        IN  GUID                 **ppGuid,
        IN  ULONG                GuidCount,
        IN  ADDARG               *pAddArg,
        OUT PSECURITY_DESCRIPTOR *ppMergedSD,
        OUT ULONG                *cbMergedSD
        )
/*++

Routine Description
    Given two security descriptors, merge them to create a single security
    descriptor.

    Memory is RtlHeapAlloced in the RtlProcessHeap()
Arguments
    pParentSD  - SD of the Parent of the object the new SD applies to.

    pCreatorSD - Beginning SD of the new object.

    flags      - Flag whether pCreatorSD is a default SD or a specific SD
                 supplied by a client.
                 
    pAddArg    - The AddArg from CheckAddSecurity, and it will be passed into
                 SetDefaultOwner, NULL if this is not called from LocalAdd
                 path.
                 
    ppMergedSD - Place to return the merged SD.

    cbMergedSD - Size of merged SD.

Return Values
    A win32 error code (0 on success, non-zero on fail).

--*/

{

    PSECURITY_DESCRIPTOR NewCreatorSD=NULL;
    DWORD                NewCreatorSDLen;
    PSECURITY_DESCRIPTOR pNewSD;
    ULONG                cbNewSD;
    GENERIC_MAPPING  GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK          DesiredAccess = 0;
    HANDLE               ClientToken=NULL;
    DWORD                ReturnStatus=0;
    ULONG                AutoInheritFlags = (SEF_SACL_AUTO_INHERIT |
                                             SEF_DACL_AUTO_INHERIT    );
    //
    // Check self relative security descriptor validity
    //

    if(pCreatorSD &&
       !RtlValidRelativeSecurityDescriptor(pCreatorSD, cbCreatorSD, 0)) {
        return ERROR_INVALID_SECURITY_DESCR;
    }

    if (pParentSD &&
        !RtlValidRelativeSecurityDescriptor(pParentSD, cbParentSD, 0)){
        return ERROR_INVALID_SECURITY_DESCR;
    }


    if(!pParentSD){
        if(!pCreatorSD) {
            // They didn't give us ANYTHING to merge.  Well, we can't build a
            // valid security descriptor out of that.
            return ERROR_INVALID_SECURITY_DESCR;
        }

        *cbMergedSD = cbCreatorSD;
        *ppMergedSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbCreatorSD);
        if(!*ppMergedSD) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy(*ppMergedSD,pCreatorSD,cbCreatorSD);

        if(!(flags & MERGE_OWNER)){
            return 0;
        }

        // NDNCs need to merge the owner and group into the SD, so continue
        // on.  If you continue on this code works correctly, without a
        // ParentSD.  What I believe this code is incorrectly assuming is that
        // if there is a provided CreatorSD and no ParentSD, then the
        // CreatorSD must be a non-domain relative SD.  Note:
        // IsValidSecurityDescriptor() returns TRUE even for a relative SD
        // with no set owner or group (SIDS are 0), this causes the SD to be
        // invalid for access checks later when read by DS.
    }

    if(flags & MERGE_DEFAULT_SD) {
        // It is nonsensical to specify the use of the default SD unless we are
        // doing a CreatePrivateObjectSecurityEx.
        Assert(flags & MERGE_CREATE);
        // We are going to call CreatePrivatObjectSecurityEx.  Set the flags
        // to avoid the privilege check about setting SACLS.  We used to
        // set the SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT flag here as well, but
        // our security architects decided in RAID 337518 that this was not
        // the right behavior, and that we should avoid that flag.  We leave
        // our flag (MERGE_DEFAULT_SD) in place but eliminate its effect in
        // case they later change their minds and ask us to put the flag back.
        AutoInheritFlags |= SEF_AVOID_PRIVILEGE_CHECK;
    }


    if(flags & MERGE_AS_DSA) {
        // We are the DSA, we can't impersonate.
        // Null token if we're doing this on behalf of the DSA.  Since we're
        // doing this on behalf of the DSA, don't check privilges or owners.
        ClientToken = NULL;
        AutoInheritFlags |= (SEF_AVOID_PRIVILEGE_CHECK |
                             SEF_AVOID_OWNER_CHECK      );
        if(flags & MERGE_DEFAULT_SD) {
            // Default SD and working as DSA?  In that case, we're using
            // a NULL ClientToken.  Thus, there is no default to use for the
            // owner and group.  Set the flags to use the parent SD as the
            // source for default Owner and Group.
            AutoInheritFlags |= (SEF_DEFAULT_OWNER_FROM_PARENT |
                                 SEF_DEFAULT_GROUP_FROM_PARENT   );
        }
    }
    else {
        PAUTHZ_CLIENT_CONTEXT pLocalCC = NULL;

        // Only do this if we aren't the DSA.

        // we need to hold on to the pAuthzCC ptr (refcount it!) because it will get
        // thrown away from the thread state by Impersonate/Unimpersonate
        AssignAuthzClientContext(&pLocalCC, pTHS->pAuthzCC);

        // First, impersonate the client.
        ReturnStatus = ImpersonateAnyClient();
        if ( 0 == ReturnStatus ) {
            // Now, get the client token.
            if (!OpenThreadToken(
                    GetCurrentThread(),         // current thread handle
                    TOKEN_READ,                 // access required
                    TRUE,                       // open as self
                    &ClientToken)) {            // client token
                ReturnStatus = GetLastError();
            }

            // Always stop impersonating.
            UnImpersonateAnyClient();
        }

        // now, put the pLocalCC back into the THSTATE (because it has been
        // removed from there by impersonate/unimpersonate calls)
        AssignAuthzClientContext(&pTHS->pAuthzCC, pLocalCC);

        // we need to release the local ptr
        AssignAuthzClientContext(&pLocalCC, NULL);

        // Return if OpenThreadToken failed.
        if(ReturnStatus)
            return ReturnStatus;

        if((flags & MERGE_CREATE) || (SI & OWNER_SECURITY_INFORMATION)) {

            ReturnStatus = SetDefaultOwner(
                    pCreatorSD,
                    cbCreatorSD,
                    ClientToken,
                    pAddArg,
                    &NewCreatorSD,
                    &NewCreatorSDLen);

            if(ReturnStatus) {
                CloseHandle(ClientToken);
                return ReturnStatus;
            }

            if(NewCreatorSDLen) {
                // A new SD was returned from SetDOmainAdminsAsDefaultOwner.
                // Therefore, we MUST have replaced the owner.  In this case, we
                // need to avoid an owner check.
                Assert(NewCreatorSD);
                AutoInheritFlags |= SEF_AVOID_OWNER_CHECK;
                pCreatorSD = NewCreatorSD;
                cbCreatorSD = NewCreatorSDLen;
            }

        }

        // Remember to close the ClientToken.
    }

    if(flags & MERGE_CREATE) {
        // We're actually creating a new SD.  pParent is the SD of the parent
        // object, pCreatorSD is the SD we're trying to put on the object.  The
        // outcome is the new SD with all the inheritable ACEs from the parentSD

        UCHAR RMcontrol = 0;
        BOOL  useRMcontrol = FALSE;
        DWORD err;

        // Get Resource Manager (RM) control field
        err = GetSecurityDescriptorRMControl (pCreatorSD, &RMcontrol);

        if (err == ERROR_SUCCESS) {
            useRMcontrol = TRUE;

            // mask bits in the RM control field that might be garbage
            RMcontrol = RMcontrol & SECURITY_PRIVATE_OBJECT;
        }

        if(!CreatePrivateObjectSecurityWithMultipleInheritance(
                pParentSD,
                pCreatorSD,
                &pNewSD,
                ppGuid,
                GuidCount,
                TRUE,
                AutoInheritFlags,
                ClientToken,
                &GenericMapping)) {
            ReturnStatus = GetLastError();
        }

        // Set back Resource Manager (RM) control field

        if (useRMcontrol && !ReturnStatus) {
            err = SetSecurityDescriptorRMControl  (pNewSD, &RMcontrol);

            if (err != ERROR_SUCCESS) {
                Assert(!"SetSecurityDescriptorRMControl failed");
                ReturnStatus  = err;
                DestroyPrivateObjectSecurity(&pNewSD);
            }
        }
#if INCLUDE_UNIT_TESTS
        if ( pParentSD ) {
            DWORD dw = 0;
            DWORD aclErr = 0;
            aclErr = CheckAclInheritance(pParentSD, pNewSD, ppGuid, GuidCount,
                                         DbgPrint, FALSE, FALSE, &dw);

            if (! ((AclErrorNone == aclErr) && (0 == dw)) ) {
                DPRINT3 (0, "aclErr:%d, dw:%d, ReturnStatus:%d\n",
                         aclErr, dw, ReturnStatus);
            }
            Assert((AclErrorNone == aclErr) && (0 == dw));
        }
#endif
    }
    else {
        // OK, a normal merge.  That is, pParentSD is the SD already on the
        // object and pCreatorSD is the SD we're trying to put on the object.
        // The result is the new SD combined with those ACEs in the original
        // which were inherited.

        if(!SetPrivateObjectSecurityLocalEx (
                SI,
                pParentSD,
                cbParentSD,
                pCreatorSD,
                &pNewSD,
                AutoInheritFlags,
                &GenericMapping,
                ClientToken)) {
            ReturnStatus = GetLastError();
            if(!ReturnStatus) {
                ReturnStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if(!(flags & MERGE_AS_DSA)) {
        // We opened the token, so clean up.
        CloseHandle(ClientToken);
    }


    if(!ReturnStatus) {
        *cbMergedSD = RtlLengthSecurityDescriptor(pNewSD);
        *ppMergedSD = pNewSD;
    }

    if(NewCreatorSD) {
        RtlFreeHeap(RtlProcessHeap(),0,NewCreatorSD);
    }

    return ReturnStatus;

}

DWORD
SidMatchesUserSidInToken (
        IN PSID pSid,
        IN DWORD cbSid,
        OUT BOOL* pfMatches
    )
{
    THSTATE *pTHS = pTHStls;
    DWORD err;
    AUTHZ_CLIENT_CONTEXT_HANDLE authzClientContext;
    // should be enough to get the SID and fill TOKEN_USER structure
    BYTE TokenBuffer[sizeof(TOKEN_USER)+sizeof(NT4SID)];
    PTOKEN_USER pTokenUser = (PTOKEN_USER)TokenBuffer;
    DWORD dwBufSize;

    Assert(pfMatches);
    *pfMatches = FALSE;

    err = GetAuthzContextHandle(pTHS, &authzClientContext);
    if (err != 0) {
        DPRINT1(0, "GetAuthzContextHandle failed: err 0x%x\n", err);
        return err;
    }
    
    if (!AuthzGetInformationFromContext(
            authzClientContext,
            AuthzContextInfoUserSid,
            sizeof(TokenBuffer),
            &dwBufSize,
            pTokenUser))
    {
        err = GetLastError();
        DPRINT1(0, "AuthzGetInformationFromContext failed: err 0x%x\n", err);
        return err;
    }

    // If the UserSid matches the sid passed in, we fine
    *pfMatches = RtlEqualSid(pTokenUser->User.Sid, pSid);
    
    return err;
}


VOID
DumpToken(HANDLE hdlClientToken)
/*++

    This Routine Currently Dumps out the Group Membership
    Information in the Token to the Kernel Debugger. Useful
    if We Want to Debug Access Check related Problems.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE   ClientToken= INVALID_HANDLE_VALUE;
    ULONG    i;
    ULONG    RequiredLength=0;

    KdPrint(("----------- Start DumpToken() -----------\n"));

    //
    // Get the client token
    //

    ClientToken = hdlClientToken;

    if (ClientToken == INVALID_HANDLE_VALUE) {
        NtStatus = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    TRUE,            //OpenAsSelf
                    &ClientToken
                    );

        if (!NT_SUCCESS(NtStatus))
            goto Error;
    }


    //
    // Query the Client Token For the Token User
    //

    //
    // First get the size required
    //

    NtStatus = NtQueryInformationToken(
                 ClientToken,
                 TokenUser,
                 NULL,
                 0,
                 &RequiredLength
                 );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (RequiredLength > 0)
    {
        PTOKEN_USER    pTokenUser = NULL;
        UNICODE_STRING TmpString;


        //
        // Allocate enough memory
        //

        pTokenUser = THAlloc(RequiredLength);
        if (NULL==pTokenUser)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token for the group memberships
        //

        NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenUser,
                    pTokenUser,
                    RequiredLength,
                    &RequiredLength
                    );

        NtStatus = RtlConvertSidToUnicodeString(
                        &TmpString,
                        pTokenUser->User.Sid,
                        TRUE);

       if (NT_SUCCESS(NtStatus))
       {
           KdPrint(("\t\tTokenUser SID: %S\n",TmpString.Buffer));
           RtlFreeHeap(RtlProcessHeap(),0,TmpString.Buffer);
       }

    }

    //
    // Query the Client Token For the group membership list
    //

    //
    // First get the size required
    //

    NtStatus = NtQueryInformationToken(
                 ClientToken,
                 TokenGroups,
                 NULL,
                 0,
                 &RequiredLength
                 );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (RequiredLength > 0)
    {
        PTOKEN_GROUPS    TokenGroupInformation = NULL;

        //
        // Allocate enough memory
        //

        TokenGroupInformation = THAlloc(RequiredLength);
        if (NULL==TokenGroupInformation)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token for the group memberships
        //

        NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenGroups,
                    TokenGroupInformation,
                    RequiredLength,
                    &RequiredLength
                    );

       for (i=0;i<TokenGroupInformation->GroupCount;i++)
       {
           UNICODE_STRING TmpString;
           NtStatus = RtlConvertSidToUnicodeString(
                        &TmpString,
                        TokenGroupInformation->Groups[i].Sid,
                        TRUE);

           if (NT_SUCCESS(NtStatus))
           {
               KdPrint(("\t\t%S\n",TmpString.Buffer));
               RtlFreeHeap(RtlProcessHeap(),0,TmpString.Buffer);
           }
       }
    }


    //
    // Query the Client Token for the privileges in the token
    //

    //
    // First get the size required
    //

    NtStatus = NtQueryInformationToken(
                 ClientToken,
                 TokenPrivileges,
                 NULL,
                 0,
                 &RequiredLength
                 );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (RequiredLength > 0)
    {
        PTOKEN_PRIVILEGES    pTokenPrivileges = NULL;

        //
        // Allocate enough memory
        //

        pTokenPrivileges = THAlloc(RequiredLength);
        if (NULL==pTokenPrivileges)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token for the group memberships
        //

        NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenPrivileges,
                    pTokenPrivileges,
                    RequiredLength,
                    &RequiredLength
                    );

        //
        // Print the token privileges to the debugger
        //
        PrintPrivileges(pTokenPrivileges);
    }

Error:

    if (INVALID_HANDLE_VALUE!=ClientToken && hdlClientToken == INVALID_HANDLE_VALUE)
        NtClose(ClientToken);

    KdPrint(("----------- End   DumpToken() -----------\n"));

}

VOID
PrintPrivileges(TOKEN_PRIVILEGES *pTokenPrivileges)
{
    ULONG i = 0;

    KdPrint(("\t\tToken Privileges count: %d\n", pTokenPrivileges->PrivilegeCount));

    for (i = 0; i < pTokenPrivileges->PrivilegeCount; i++)
    {
        // print the privilege attribute
        char strTemp[100];
        BOOL fUnknownPrivilege = FALSE;

        strcpy(strTemp, (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) ? "+" : "-");
        strcat(strTemp, (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED_BY_DEFAULT) ? " d" : "  ");
        strcat(strTemp, (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_USED_FOR_ACCESS) ? "u  " : "   ");

        fUnknownPrivilege = FALSE;
        if (pTokenPrivileges->Privileges[i].Luid.HighPart)
        {
            fUnknownPrivilege = TRUE;
        }
        else
        {
            switch (pTokenPrivileges->Privileges[i].Luid.LowPart)
            {
            case SE_CREATE_TOKEN_PRIVILEGE:
                strcat(strTemp, "SeCreateTokenPrivilege\n");
                break;

            case SE_ASSIGNPRIMARYTOKEN_PRIVILEGE:
                strcat(strTemp, "SeAssignPrimaryTokenPrivilege\n");
                break;

            case SE_LOCK_MEMORY_PRIVILEGE:
                strcat(strTemp, "SeLockMemoryPrivilege\n");
                break;

            case SE_INCREASE_QUOTA_PRIVILEGE:
                strcat(strTemp, "SeIncreaseQuotaPrivilege\n");
                break;

            case SE_UNSOLICITED_INPUT_PRIVILEGE:
                strcat(strTemp, "SeUnsolicitedInputPrivilege\n");
                break;

            case SE_TCB_PRIVILEGE:
                strcat(strTemp, "SeTcbPrivilege\n");
                break;

            case SE_SECURITY_PRIVILEGE:
                strcat(strTemp, "SeSecurityPrivilege\n");
                break;

            case SE_TAKE_OWNERSHIP_PRIVILEGE:
                strcat(strTemp, "SeTakeOwnershipPrivilege\n");
                break;

            case SE_LOAD_DRIVER_PRIVILEGE:
                strcat(strTemp, "SeLoadDriverPrivilege\n");
                break;

            case SE_SYSTEM_PROFILE_PRIVILEGE:
                strcat(strTemp, "SeSystemProfilePrivilege\n");
                break;

            case SE_SYSTEMTIME_PRIVILEGE:
                strcat(strTemp, "SeSystemtimePrivilege\n");
                break;

            case SE_PROF_SINGLE_PROCESS_PRIVILEGE:
                strcat(strTemp, "SeProfileSingleProcessPrivilege\n");
                break;

            case SE_INC_BASE_PRIORITY_PRIVILEGE:
                strcat(strTemp, "SeIncreaseBasePriorityPrivilege\n");
                break;

            case SE_CREATE_PAGEFILE_PRIVILEGE:
                strcat(strTemp, "SeCreatePagefilePrivilege\n");
                break;

            case SE_CREATE_PERMANENT_PRIVILEGE:
                strcat(strTemp, "SeCreatePermanentPrivilege\n");
                break;

            case SE_BACKUP_PRIVILEGE:
                strcat(strTemp, "SeBackupPrivilege\n");
                break;

            case SE_RESTORE_PRIVILEGE:
                strcat(strTemp, "SeRestorePrivilege\n");
                break;

            case SE_SHUTDOWN_PRIVILEGE:
                strcat(strTemp, "SeShutdownPrivilege\n");
                break;

            case SE_DEBUG_PRIVILEGE:
                strcat(strTemp, "SeDebugPrivilege\n");
                break;

            case SE_AUDIT_PRIVILEGE:
                strcat(strTemp, "SeAuditPrivilege\n");
                break;

            case SE_SYSTEM_ENVIRONMENT_PRIVILEGE:
                strcat(strTemp, "SeSystemEnvironmentPrivilege\n");
                break;

            case SE_CHANGE_NOTIFY_PRIVILEGE:
                strcat(strTemp, "SeChangeNotifyPrivilege\n");
                break;

            case SE_REMOTE_SHUTDOWN_PRIVILEGE:
                strcat(strTemp, "SeRemoteShutdownPrivilege\n");
                break;

            default:
                fUnknownPrivilege = TRUE;
                break;
            }

            if (fUnknownPrivilege)
            {
                KdPrint(("\t\t%s Unknown privilege 0x%08lx%08lx\n",
                        strTemp,
                        pTokenPrivileges->Privileges[i].Luid.HighPart,
                        pTokenPrivileges->Privileges[i].Luid.LowPart));
            }
            else
            {
                KdPrint(("\t\t%s", strTemp));
            }
        }
    }
}


// static buffers for admin sids
NT4SID DomainAdminSid, EnterpriseAdminSid, SchemaAdminSid, BuiltinAdminSid, AuthUsersSid;

DWORD
InitializeDomainAdminSid( )
//
// Function to initialize the DomainAdminsSid.
//
//
// Return Value:     0 on success
//                   Error on failure
//

{

    NTSTATUS                    Status;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;
    
    NTSTATUS    NtStatus, IgnoreStatus;
    ULONG       cbSid;
    PSID        pSid;
        
    //
    // Get the Domain SID
    //

    if (gfRunningInsideLsa) {

        Status = LsaIQueryInformationPolicyTrusted(
                PolicyPrimaryDomainInformation,
                (PLSAPR_POLICY_INFORMATION *)&PrimaryDomainInfo
                );

        if(!NT_SUCCESS(Status)) {
            LogUnhandledError(Status);
            return Status;
        }

        pSid = PrimaryDomainInfo->Sid;

    }
    else {

        READARG     ReadArg;
        READRES     *pReadRes;
        ENTINFSEL   EntInf;
        ATTR        objectSid;
        DWORD       dwErr;

        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
        EntInf.AttrTypBlock.attrCount = 1;
        RtlZeroMemory(&objectSid,sizeof(ATTR));
        objectSid.attrTyp = ATT_OBJECT_SID;
        EntInf.AttrTypBlock.pAttr = &objectSid;

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        InitCommarg(&(ReadArg.CommArg));

        ReadArg.pObject = gAnchor.pRootDomainDN;
        ReadArg.pSel    = & EntInf;

        dwErr = DirRead(&ReadArg,&pReadRes);

        if (dwErr)
        {
            DPRINT1 (0, "Error reading objectSid from %ws\n", gAnchor.pRootDomainDN->StringName);
            Status = dwErr;
            goto End;
        }

        if (pReadRes->entry.AttrBlock.attrCount == 0) {
            DPRINT1 (0, "objectSid is missing from %ws\n", gAnchor.pRootDomainDN->StringName);
            Status = ERROR_DS_MISSING_EXPECTED_ATT;
            goto End;
        }

        pSid = pReadRes->entry.AttrBlock.pAttr->AttrVal.pAVal->pVal;
    }

    gpDomainAdminSid = (PSID)&DomainAdminSid;
    gpEnterpriseAdminSid = (PSID)&EnterpriseAdminSid;
    gpSchemaAdminSid = (PSID)&SchemaAdminSid;
    gpBuiltinAdminSid = (PSID)&BuiltinAdminSid;
    gpAuthUserSid = (PSID)&AuthUsersSid;
    
    Assert(gpRootDomainSid);
    
    cbSid = MAX_NT4_SID_SIZE;
    if ( !CreateWellKnownSid(WinAccountDomainAdminsSid, pSid, gpDomainAdminSid, &cbSid))
    {
        Status = GetLastError();
        goto End;
    }
    
    cbSid = MAX_NT4_SID_SIZE;
    if ( !CreateWellKnownSid(WinAccountEnterpriseAdminsSid, gpRootDomainSid, gpEnterpriseAdminSid, &cbSid))
    {
        Status = GetLastError();
        goto End;
    }

    cbSid = MAX_NT4_SID_SIZE;
    if ( !CreateWellKnownSid(WinAccountSchemaAdminsSid, gpRootDomainSid, gpSchemaAdminSid, &cbSid))
    {
        Status = GetLastError();
        goto End;
    }

    cbSid = MAX_NT4_SID_SIZE;
    if(!CreateWellKnownSid(WinBuiltinAdministratorsSid, pSid, gpBuiltinAdminSid, &cbSid)) {
        Status = GetLastError();
    }

    cbSid = MAX_NT4_SID_SIZE;
    if(!CreateWellKnownSid(WinAuthenticatedUserSid, pSid, gpAuthUserSid, &cbSid)) {
        Status = GetLastError();
    }


End:
    if (gfRunningInsideLsa) {
        LsaFreeMemory( PrimaryDomainInfo );
    }
    
    return Status;
}

//
//  CreatorSD and ClientToken must not be NULL
//  NewCreatorSD gets allocated here.
//

DWORD
SetDefaultOwner(
        IN  PSECURITY_DESCRIPTOR    CreatorSD,
        IN  ULONG                   cbCreatorSD,
        IN  HANDLE                  ClientToken,
        IN  ADDARG                  *pAddArg,
        OUT PSECURITY_DESCRIPTOR    *NewCreatorSD,
        OUT PULONG                  NewCreatorSDLen
        )
{
// constants used in this function only
#define   DOMAIN_NC CREATE_DOMAIN_NC
#define   SCHEMA_NC CREATE_SCHEMA_NC
#define   CONFIGURATION_NC CREATE_CONFIGURATION_NC
#define   NONDOMAIN_NC CREATE_NONDOMAIN_NC
#define   ENTERPRISE_ADMIN 0x1
#define   SCHEMA_ADMIN 0x2
#define   DOMAIN_ADMIN 0x4
#define   NDNC_ADMIN   0x8
#define   BUILTIN_ADMIN 0x10


    PTOKEN_GROUPS   Groups = NULL;
    PTOKEN_OWNER    pDefaultOwnerInToken=NULL;
    PTOKEN_USER     pTokenUserInToken=NULL;
    DWORD           ReturnedLength;
    DWORD           retCode = 0;
    DWORD           i;
    PSECURITY_DESCRIPTOR    AbsoluteSD = NULL;
    DWORD           AbsoluteSDLen = 0;
    PACL            Dacl = NULL;
    DWORD           DaclLen = 0;
    PACL            Sacl = NULL;
    DWORD           SaclLen = 0;
    DWORD           OwnerLen = 0;
    PSID            Group = NULL;
    DWORD           GroupLen = 0;
    PSID            pOwnerSid=NULL, pNDNCAdminSid = NULL, pNDNCSid = NULL;
    DWORD           fNC = 0, fOwner = 0;
    PDSNAME         pDSName;
    COMMARG         CommArg;
    CROSS_REF       *pCR;
    DWORD           NCDNT;

    THSTATE *pTHS = pTHStls;

    Assert(pTHS && pTHS->pDB);

    *NewCreatorSD = NULL;
    *NewCreatorSDLen = 0;


    // Find out how much memory to allocate.
    MakeAbsoluteSD(CreatorSD, AbsoluteSD, &AbsoluteSDLen,
                   Dacl, &DaclLen, Sacl, &SaclLen,
                   NULL, &OwnerLen, Group, &GroupLen
                   );

    if(OwnerLen || !gfRunningInsideLsa || !pTHS || !pTHS->pDB ) {
        // The SD already has an owner, so we don't actually need to do any
        // magic here.  Or we're in dsamain.exe and wish to avoid calls
        // calls to LSA.  Return success with no new SD.
        return 0;
    }

        // OK, we are definitely going to be doing some replacement in the SD.

    __try {
        //
        // First I have to convert the self-relative SD to
        // absolute SD
        //

        AbsoluteSD = THAllocEx(pTHS, AbsoluteSDLen);
        Dacl = THAllocEx(pTHS, DaclLen);
        Sacl = THAllocEx(pTHS, SaclLen);
        Group = THAllocEx(pTHS, GroupLen);

        if(!MakeAbsoluteSD(CreatorSD, AbsoluteSD, &AbsoluteSDLen,
                           Dacl, &DaclLen, Sacl, &SaclLen,
                           NULL, &OwnerLen, Group, &GroupLen)) {
            retCode = GetLastError();
            __leave;
        }

        Assert(!OwnerLen);

        
        //
        // determine which NC the object belongs to
        //

        
        // if an object is being added, check its
        // parent's NC, because this object is still not there.
        NCDNT = (pAddArg)?pAddArg->pResParent->NCDNT:pTHS->pDB->NCDNT;


        if (pAddArg && pAddArg->pCreateNC) {
            fNC = pAddArg->pCreateNC->iKind & 
                (DOMAIN_NC|CONFIGURATION_NC|SCHEMA_NC|NONDOMAIN_NC); 
        }
        else {
            if (NCDNT == gAnchor.ulDNTDomain) {
                fNC = DOMAIN_NC;
            }
            else if (NCDNT == gAnchor.ulDNTConfig) {
                fNC = CONFIGURATION_NC;
            }
            else if (NCDNT == gAnchor.ulDNTDMD) {
                fNC = SCHEMA_NC;
            }
            else {
                fNC = NONDOMAIN_NC;
            }
        }
        

        Assert( DOMAIN_NC == fNC ||
                CONFIGURATION_NC == fNC ||
                SCHEMA_NC == fNC ||
                NONDOMAIN_NC == fNC );
        
        if (NONDOMAIN_NC == fNC) {
            // it is NDNC, we need to find the SD-ref-domain sid of the NC
            // and construct the corresponding domain admin sid.
            
            if (pAddArg && pAddArg->pCreateNC) {
                // if this is a new NDNC, read from AddArg
                pNDNCSid = &pAddArg->pCreateNC->pSDRefDomCR->pNC->Sid;
            }
            else {
                // ok, not the NC head, 
                // get it from crossref.

                pDSName = DBGetDSNameFromDnt(pTHS->pDB, NCDNT);
                if (!pDSName) {
                    retCode = ERROR_DS_CANT_FIND_EXPECTED_NC;
                    __leave;
                }
    
                Assert(pDSName);
    
                // get the cross ref object of the NC
                InitCommarg(&CommArg);
                CommArg.Svccntl.dontUseCopy = FALSE;
                pCR = FindExactCrossRef(pDSName, &CommArg);
                THFreeEx(pTHS,pDSName);
                if(pCR == NULL){
                    retCode = ERROR_DS_CANT_FIND_EXPECTED_NC;
                    __leave;
                }
                // find the sid of SD-Reference-Domain of the NDNC
                pNDNCSid = GetSDRefDomSid(pCR);
                if(pTHS->errCode){
                    // There was an error in GetSDRefDomSid()
                    retCode = pTHS->errCode;
                    __leave;
                }
                Assert(pNDNCSid);
            }
            
            Assert(pNDNCSid);
            
            //construct the ndnc sid
            pNDNCAdminSid = THAllocEx(pTHS, SECURITY_MAX_SID_SIZE);
            ReturnedLength = SECURITY_MAX_SID_SIZE;
            if(!CreateWellKnownSid(WinAccountDomainAdminsSid,
                                   pNDNCSid,
                                   pNDNCAdminSid,
                                   &ReturnedLength))
            {
                retCode = GetLastError();
                __leave;
                
            }
            
        }


        //
        // Get the default owner in the token
        //

        GetTokenInformation(ClientToken,TokenOwner,NULL,0,&ReturnedLength);
        
        pDefaultOwnerInToken = THAllocEx(pTHS, ReturnedLength);
        
        if(!GetTokenInformation(ClientToken, TokenOwner, pDefaultOwnerInToken,
                            ReturnedLength,
                            &ReturnedLength
                            )){
            retCode = GetLastError();
            __leave;
        }

        //
        // Get the user sid from the token
        //
        
        GetTokenInformation(ClientToken,TokenUser,NULL,0,&ReturnedLength);
        
        pTokenUserInToken = THAllocEx(pTHS, ReturnedLength);
        
        if(!GetTokenInformation(ClientToken, TokenUser, pTokenUserInToken,
                            ReturnedLength,
                            &ReturnedLength
                            )){
            retCode = GetLastError();
            __leave;
        }


        //
        // Domain Admins can't be TokenUser so just get TokenGroups
        //
        GetTokenInformation(ClientToken, TokenGroups, Groups,
                            0,
                            &ReturnedLength
                            );

        //
        // Let's really get the groups, now :-)
        //
        Groups = THAllocEx(pTHS, ReturnedLength);
        
        if(!GetTokenInformation(ClientToken, TokenGroups, Groups,
                                ReturnedLength,
                                &ReturnedLength
                                )) {
            retCode = GetLastError();
            __leave;
        }


        //
        // Scan through the group list, and see if it has
        // the groups in interest.
        //

        for(i=0;i<Groups->GroupCount;i++) {
            if (EqualSid(Groups->Groups[i].Sid, gpDomainAdminSid)) {
                fOwner |= DOMAIN_ADMIN;
            }
            else if(EqualSid(Groups->Groups[i].Sid, gpEnterpriseAdminSid)) {
                fOwner |= ENTERPRISE_ADMIN;
            }
            else if(EqualSid(Groups->Groups[i].Sid, gpSchemaAdminSid)) {
                fOwner |= SCHEMA_ADMIN;
            }
            if(pNDNCAdminSid && EqualSid(Groups->Groups[i].Sid, pNDNCAdminSid)) {
                fOwner |= NDNC_ADMIN;
            }
        }
        
        // check if the default owner is builtin admin
        if (EqualSid(pDefaultOwnerInToken->Owner, gpBuiltinAdminSid)) {
                fOwner |= BUILTIN_ADMIN;
        }

        //
        //  Determine the owner for the object
        //
        
        switch(fNC){
        
        case DOMAIN_NC:
            // domain NC
            if (fOwner & DOMAIN_ADMIN) {
                pOwnerSid = gpDomainAdminSid;
            }
            else if (fOwner & ENTERPRISE_ADMIN) {
                pOwnerSid = gpEnterpriseAdminSid;
            }
            else if (fOwner & BUILTIN_ADMIN ) {
                pOwnerSid = pTokenUserInToken->User.Sid;
            }
            else {
                pOwnerSid = pDefaultOwnerInToken->Owner;
            }
            break;

        case SCHEMA_NC:
            // schema NC
            if (fOwner & SCHEMA_ADMIN) {
                pOwnerSid = gpSchemaAdminSid;
                break;
            }
            // the rest is the same as Configuration NC,
            // so fall through.

        case CONFIGURATION_NC:
            // configuration NC
            if (fOwner & ENTERPRISE_ADMIN) {
                pOwnerSid = gpEnterpriseAdminSid;
            }
            else if (fOwner & DOMAIN_ADMIN) {
                pOwnerSid = gpDomainAdminSid;
            }
            else if (fOwner & BUILTIN_ADMIN ) {
                pOwnerSid = pTokenUserInToken->User.Sid;
            }
            else {
                pOwnerSid = pDefaultOwnerInToken->Owner;
            }
            break;

        case NONDOMAIN_NC:
            // nondomain NC
            if (fOwner & NDNC_ADMIN) {
                pOwnerSid = pNDNCAdminSid;
            }
            else if (fOwner & ENTERPRISE_ADMIN) {
                pOwnerSid = gpEnterpriseAdminSid;
            }
            else if (fOwner & BUILTIN_ADMIN ) {
                pOwnerSid = pTokenUserInToken->User.Sid;
            }
            else {
                pOwnerSid = pDefaultOwnerInToken->Owner;
            }
            break;

        default:
            Assert(!"We should never come here!!!");
            
        }

        if (pOwnerSid == NULL) {
            Assert(!"Unable to determine the default owner sid, code inconsistency?");
            retCode = ERROR_INVALID_SID;
            __leave;
        }

        // OK, we found it. Set it as the Owner in AbsoluteSD
        //
        if(!SetSecurityDescriptorOwner(
                AbsoluteSD,
                pOwnerSid,
                TRUE
                )) {
            retCode = GetLastError();
            __leave;
        }

        Assert(!retCode);

        //
        // Convert the AbsoluteSD back to SelfRelative and return that in the
        // NewCreatorSD.
        //

        MakeSelfRelativeSD(AbsoluteSD, *NewCreatorSD, NewCreatorSDLen);

        *NewCreatorSD = RtlAllocateHeap(RtlProcessHeap(), 0, *NewCreatorSDLen);

        if(!(*NewCreatorSD)) {
            // Memory allocation error, fail
            retCode = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        if(!MakeSelfRelativeSD(AbsoluteSD, *NewCreatorSD, NewCreatorSDLen)) {
            retCode = GetLastError();
        }

    }
    __finally {
        if(AbsoluteSD) {
            THFreeEx(pTHS, AbsoluteSD);
        }
        if(Dacl) {
            THFreeEx(pTHS, Dacl);
        }
        if(Sacl) {
            THFreeEx(pTHS, Sacl);
        }
        if(Group) {
            THFreeEx(pTHS, Group);
        }
        if(Groups) {
            THFreeEx(pTHS, Groups);
        }
        if (pNDNCAdminSid) {
            THFreeEx(pTHS, pNDNCAdminSid);
        }
        if (pTokenUserInToken) {
            THFreeEx(pTHS, pTokenUserInToken);
        }
        if (pDefaultOwnerInToken) {
            THFreeEx(pTHS, pDefaultOwnerInToken);
        }
        if(retCode && (*NewCreatorSD)) {
            RtlFreeHeap(RtlProcessHeap(), 0,(*NewCreatorSD));
        }
    }

    return retCode;

#undef   DOMAIN_NC
#undef   SCHEMA_NC 
#undef   CONFIGURATION_NC
#undef   NONDOMAIN_NC
#undef   ENTERPRISE_ADMIN
#undef   SCHEMA_ADMIN 
#undef   DOMAIN_ADMIN 
#undef   NDNC_ADMIN
#undef   BUILTIN_ADMIN

}



//
// CheckPrivilegesAnyClient impersonates the client and then checks to see if
// the requested privilege is held.  It is assumed that a client is impersonable
// (i.e. not doing this strictly on behalf of an internal DSA thread)
//
DWORD
CheckPrivilegeAnyClient(
        IN DWORD privilege,
        OUT BOOL *pResult
        )
{
    DWORD    dwError=0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    THSTATE *pTHS = pTHStls;
    AUTHZ_CLIENT_CONTEXT_HANDLE authzClientContext;
    DWORD dwBufSize;
    PTOKEN_PRIVILEGES pTokenPrivileges = NULL;
    BOOL bSuccess;
    DWORD i;

#ifdef DBG
    if( dwSkipSecurity ) {
        // NOTE:  THIS CODE IS HERE FOR DEBUGGING PURPOSES ONLY!!!
        // Set the top access status to 0, implying full access.
        *pResult=TRUE;
        return 0;
    }
#endif

    // assume privilege not granted
    *pResult = FALSE;

    // now, grab the authz client context
    // if it was never obtained before, this will impersonate the client, grab the token,
    // unimpersonate the client, and then create a new authz client context
    dwError = GetAuthzContextHandle(pTHS, &authzClientContext);
    if (dwError != 0) {
        goto finished;
    }

    // now we can check the privelege for the authz context
    // first, grab the buffer size...
    bSuccess = AuthzGetInformationFromContext(
        authzClientContext,             // context handle
        AuthzContextInfoPrivileges,     // requesting priveleges
        0,                              // no buffer yet
        &dwBufSize,                     // need to find buffer size
        NULL                            // buffer
        );
    // must return ERROR_INSUFFICIENT_BUFFER! if not, return error
    if (bSuccess) {
        DPRINT1(0, "AuthzGetInformationFromContext returned success, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", ERROR_INSUFFICIENT_BUFFER);
        goto finished;
    }
    if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
        DPRINT2(0, "AuthzGetInformationFromContext returned %d, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", dwError, ERROR_INSUFFICIENT_BUFFER);
        goto finished;
    }
    dwError = 0; // need to reset it to OK now

    // no buffer, nothing to do...
    if (dwBufSize == 0) {
        Assert(!"AuthzGetInformationFromContext says it needs zero-length buffer, weird... Let AuthZ people know. This assert is ignorable");
        goto finished;
    }

    // allocate memory
    pTokenPrivileges = THAllocEx(pTHS, dwBufSize);

    // now get the real privileges...
    bSuccess = AuthzGetInformationFromContext(
        authzClientContext,             // context handle
        AuthzContextInfoPrivileges,     // requesting priveleges
        dwBufSize,                      // and here is its size
        &dwBufSize,                     // just in case
        pTokenPrivileges                // now there is a buffer
        );
    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0, "AuthzGetInformationFromContext failed, err=%d\n", dwError);
        goto finished;
    }

    // now, scan the privileges
    for (i = 0; i < pTokenPrivileges->PrivilegeCount; i++) {
        if (pTokenPrivileges->Privileges[i].Luid.HighPart == 0 &&
            pTokenPrivileges->Privileges[i].Luid.LowPart == privilege) {
            // found matching privilege!
            *pResult = (pTokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED) != 0;
            break;
        }
    }
finished:
    // release memory
    if (pTokenPrivileges) {
        THFreeEx(pTHS, pTokenPrivileges);
    }
    return dwError;
}

DWORD
GetPlaceholderNCSD(
    IN  THSTATE *               pTHS,
    OUT PSECURITY_DESCRIPTOR *  ppSD,
    OUT DWORD *                 pcbSD
    )
/*++

Routine Description:

    Return the default security descriptor for a placeholder NC.

Arguments:

    pTHS (IN)

    ppSD (OUT) - On successful return, holds a pointer to the thread-allocated
        SD.

    pcbSD (OUT) - On successful return, holds the size in bytes of the SD.

Return Values:

    0 or Win32 error.

--*/
{
    CLASSCACHE *            pCC;
    SECURITY_DESCRIPTOR *   pSDAbs = NULL;
    DWORD                   cbSDAbs = 0;
    ACL *                   pDACL = NULL;
    DWORD                   cbDACL = 0;
    ACL *                   pSACL = NULL;
    DWORD                   cbSACL = 0;
    SID *                   pOwner = NULL;
    DWORD                   cbOwner = 0;
    SID *                   pGroup = NULL;
    DWORD                   cbGroup = 0;
    SID *                   pDomAdmin;
    DWORD                   err;

    // Use the default SD for the domainDNS objectClass as a template.
    // Note that this SD has no owner or group.

    pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);
    Assert(NULL != pCC);

    //
    // PREFIX: PREFIX complains that pCC returned by the call to SCGetClassById
    // is not checked for NULL.  This is not a bug as we pass a predefined constant
    // to SCGetClassById guaranteeing that it will not return NULL.
    //

    // Crack the self-relative SD into absolute format and set the owner
    // and group to (our) domain admins.

    MakeAbsoluteSD(pCC->pSD, NULL, &cbSDAbs, NULL, &cbDACL, NULL,
                   &cbSACL, NULL, &cbOwner, NULL, &cbGroup);

    if (cbSDAbs) pSDAbs = THAllocEx(pTHS, cbSDAbs);
    if (cbDACL ) pDACL  = THAllocEx(pTHS, cbDACL );
    if (cbSACL ) pSACL  = THAllocEx(pTHS, cbSACL );
    if (cbOwner) pOwner = THAllocEx(pTHS, cbOwner);
    if (cbGroup) pGroup = THAllocEx(pTHS, cbGroup);

    // PREFIX: dereferencing NULL pointer pOwner, pDACL, pSACL, pGroup
    //         these are not referenced when the corresponding cbOwner, cbDACL, cbSACL, cbGroup are 0

    if (!MakeAbsoluteSD(pCC->pSD, pSDAbs, &cbSDAbs, pDACL, &cbDACL, pSACL,
                        &cbSACL, pOwner, &cbOwner, pGroup, &cbGroup)
        || !SetSecurityDescriptorOwner(pSDAbs, gpDomainAdminSid, FALSE)
        || !SetSecurityDescriptorGroup(pSDAbs, gpDomainAdminSid, FALSE)) {
        err = GetLastError();
        DPRINT1(0, "Unable to crack/modify default SD, error %d.\n", err);
        return err;
    }

    // Convert back to a self-relative SD.
    *pcbSD = 0;
    MakeSelfRelativeSD(pSDAbs, NULL, pcbSD);
    if (*pcbSD) {
        *ppSD = THAllocEx(pTHS, *pcbSD);
    }

    if (!MakeSelfRelativeSD(pSDAbs, *ppSD, pcbSD)) {
        err = GetLastError();
        DPRINT1(0, "Unable to convert SD, error %d.\n", err);
        return err;
    }

    if (pSDAbs) THFreeEx(pTHS, pSDAbs);
    if (pDACL ) THFreeEx(pTHS, pDACL );
    if (pSACL ) THFreeEx(pTHS, pSACL );
    if (pOwner) THFreeEx(pTHS, pOwner);
    if (pGroup) THFreeEx(pTHS, pGroup);

    return 0;
}

LUID aLUID = {0, 0}; // a fake LUID to pass into AuthzInitializeContextFromToken
                     // maybe one day we will start using them...

DWORD
VerifyRpcClientIsAuthenticatedUser(
    VOID            *Context,
    GUID            *InterfaceUuid
    )
/*++

  Description:

    Verifies that an RPC client is an authenticated user and not, for
    example, NULL session.

  Arguments:

    Context - Caller context handle defined by RPC_IF_CALLBACK_FN.

    InterfaceUuid - RPC interface ID.  Access check routines typically need
        the GUID/SID of the object against which access is being checked.
        In this case, there is no real object being checked against.  But
        we need a GUID for auditing purposes.  Since the check is for RPC
        interface access, the convention is to provide the IID of the RPC
        interface.  Thus the audit log entries for failed interface access
        can be discriminated from other entries.

  Returns:

    0 on success, !0 otherwise

--*/
{
    // The correct functioning of this routine can be tested as follows.
    // We note that:
    //
    //  1) crack.exe allows specification of the SPN
    //  2) programs invoked by at.exe run as local system by default
    //  3) an invalid SPN in conjunction with weak domain security settings
    //     causes negotiation to drop down to NTLM
    //
    // Thus, all one needs to do is make a script which calls crack.exe with
    // an invalid SPN and invoke it via at.exe from a joined workstation.
    // Do not provide explicit credentials in the crack.exe arguments.

    DWORD                       dwErr;
    AUTHZ_CLIENT_CONTEXT_HANDLE authzCtx;

    // Caller must provide a valid Interface UIID.
    Assert(!fNullUuid(InterfaceUuid));

    // create authz client context from RPC security context
    if (dwErr = RpcGetAuthorizationContextForClient(
                    Context,        // binding context
                    FALSE,          // don't impersonate
                    NULL,           // expiration time
                    NULL,           // LUID
                    aLUID,          // reserved
                    0,              // another reserved
                    NULL,           // one more reserved
                    &authzCtx       // authz context goes here
                    )) {
        return dwErr;
    }

    __try {
        dwErr = VerifyClientIsAuthenticatedUser(authzCtx);
    }
    __finally {
        RpcFreeAuthorizationContext(&authzCtx);
    }

    return(dwErr);
}

DWORD
VerifyClientIsAuthenticatedUser(
    AUTHZ_CLIENT_CONTEXT_HANDLE authzCtx
    )
/*++

  Description:

    Verifies that a client is an authenticated user and not, for
    example, NULL session.

  Arguments:

    authzCtx - The clients Authz context handle.
    
  Returns:

    0 on success, !0 otherwise

--*/
{
    DWORD dwErr;
    BOOL  fIsMember;

    if (ghAuthzRM == NULL) {
        // must be before we had a chance to startup or after it has already shut down.
        // just say not allowed...
        return ERROR_NOT_AUTHENTICATED;
    }

    dwErr = CheckGroupMembershipAnyClient(NULL, authzCtx, &gpAuthUserSid, 1, &fIsMember);

    if ( dwErr != ERROR_SUCCESS || !fIsMember ) {
        dwErr = ERROR_NOT_AUTHENTICATED;
    }

    return dwErr;
}

/*
 * AuthZ-related routines
 */

/*
 * global RM handle
 */
AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzRM = NULL;

DWORD
InitializeAuthzResourceManager()
/*++
  Description:

    Initialize AuthzRM handle

  Returns:

    0 on success, !0 on failure

--*/
{
    DWORD dwError;
    BOOL bSuccess;

    // create the RM handle
    // all callbacks are NULLs
    bSuccess = AuthzInitializeResourceManager(
                    0,                  // flags
                    NULL,               // access check fn
                    NULL,               // compute dynamic groups fn
                    NULL,               // free dynamic groups fn
                    ACCESS_DS_SOURCE_W, // RM name
                    &ghAuthzRM          // return value
                    );

    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0,"Error from AuthzInitializeResourceManager: %d\n", dwError);
        return dwError;
    }
    Assert(ghAuthzRM);

    // all is fine!
    return 0;
}

DWORD
ReleaseAuthzResourceManager()
/*++
  Description:

    Release Authz RM handles

  Returns:

    0 on success, !0 on failure

--*/
{
    DWORD dwError;
    BOOL bSuccess;

    if (ghAuthzRM == NULL) {
        return 0;
    }

    bSuccess = AuthzFreeResourceManager(ghAuthzRM);
    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0,"Error from AuthzFreeResourceManager: %d\n", dwError);
        return dwError;
    }

    ghAuthzRM = NULL;
    return 0;
}

PAUTHZ_CLIENT_CONTEXT
NewAuthzClientContext()
/*++
  Description:

    create a new client context

  Returns:

    ptr to the new CLIENT_CONTEXT or NULL if an error occured
--*/
{
    PAUTHZ_CLIENT_CONTEXT result;
    // allocate a new structure
    result = (PAUTHZ_CLIENT_CONTEXT) malloc(sizeof(AUTHZ_CLIENT_CONTEXT));
    if (result) {
        result->lRefCount = 0;
        result->pAuthzContextInfo = NULL;
    }
    return result;
}

VOID AssignAuthzClientContext(
    IN PAUTHZ_CLIENT_CONTEXT *var,
    IN PAUTHZ_CLIENT_CONTEXT value
    )
/*++
  Description:

    Does a refcounted assignment of a CLIENT_CONTEXT
    Will decrement the prev value (if any) and increment the new value (if any)
    If the prev value's refCount is zero, then it will get destroyed.

  Arguments:

    var -- variable to be assigned
    value -- value to be assigned to the variable

  Note:
    on refcounting in a multithreaded environment:

    THIS WILL ONLY WORK IF EVERYBODY IS USING AssignAuthzClientContext TO WORK WITH
    AUTHZ CLIENT CONTEXT INSTANCES!

    assuming nobody is cheating and every reference to the context is counted. Then if the
    refcount goes down to zero, we can be sure that no other thread holds a reference to
    the context that it can assign to a variable. Thus, we are sure that once the refcount
    goes down to zero, we can safely destroy the context. This is because nobody else
    holds a reference to the context, thus, nobody can use it.

--*/
{
    PAUTHZ_CLIENT_CONTEXT       prevValue;
    PAUTHZ_CLIENT_CONTEXT_INFO  pAuthzContextInfo;
    PEFFECTIVE_QUOTA            pEffectiveQuotaToFree;
    PEFFECTIVE_QUOTA            pEffectiveQuotaNext;

    Assert(var);

    prevValue = *var;
    if (prevValue == value) {
        return; // no change!
    }

    if (prevValue != NULL) {
        Assert(prevValue->lRefCount > 0);

        // need to decrement the prev value
        if (InterlockedDecrement(&prevValue->lRefCount) == 0) {
            // no more refs -- release the context!
			pAuthzContextInfo = prevValue->pAuthzContextInfo;
            if ( NULL != pAuthzContextInfo ) {
                if ( NULL != pAuthzContextInfo->hAuthzContext ) {
                    AuthzFreeContext( pAuthzContextInfo->hAuthzContext );
                }
				
                for( pEffectiveQuotaToFree = pAuthzContextInfo->pEffectiveQuota;
                    NULL != pEffectiveQuotaToFree;
                    pEffectiveQuotaToFree = pEffectiveQuotaNext ) {
                	pEffectiveQuotaNext = pEffectiveQuotaToFree->pEffectiveQuotaNext;
                    free( pEffectiveQuotaToFree );
                }
                free( pAuthzContextInfo );
            }
            free(prevValue);
        }
    }

    // now, we can assign the new value to the variable (the value might be NULL!)
    *var = value;

    if (value != NULL) {
        // need to increment the refcount
        InterlockedIncrement(&value->lRefCount);
    }
}

DWORD
GetAuthzContextInfo(
    IN THSTATE *pTHS,
    OUT AUTHZ_CLIENT_CONTEXT_INFO **ppAuthzContextInfo
    )
/*++
  Description:

    gets AuthzContext from CLIENT_CONTEXT. If the context has not yet been allocated
    then the client will get impersonated, token grabbed and Authz context created.
    Then the client is unimpersonated again.

  Arguments:

    pTHS -- thread state
    ppAuthzContextInfo -- result, pointer contained in pAuthzCC

  Returns:

    0 on success, !0 otherwise
--*/
{
    DWORD   dwError = 0;
    HANDLE  hClientToken = INVALID_HANDLE_VALUE;
    PAUTHZ_CLIENT_CONTEXT pLocalCC = NULL;
    PAUTHZ_CLIENT_CONTEXT_INFO pContextInfoNew = NULL;
    BOOL bSuccess;

    Assert( NULL != pTHS );
    Assert( NULL != ppAuthzContextInfo );
    Assert( NULL == *ppAuthzContextInfo );  // assumes caller has initialised return value to NULL
    Assert( NULL != ghAuthzRM );

    // check that the thread state contains a client context. If not, create one
    if (pTHS->pAuthzCC == NULL) {
        AssignAuthzClientContext(&pTHS->pAuthzCC, NewAuthzClientContext());
        if (pTHS->pAuthzCC == NULL) {
            // what -- no context still??? must be out of memory...
            return ERROR_OUTOFMEMORY;
        }
    }

    // grab the authz handle that sits in the pCC struct
    if ( NULL != pTHS->pAuthzCC->pAuthzContextInfo ) {
        Assert( NULL != pTHS->pAuthzCC->pAuthzContextInfo->hAuthzContext );
        *ppAuthzContextInfo = pTHS->pAuthzCC->pAuthzContextInfo;
    } else {
        pContextInfoNew = (PAUTHZ_CLIENT_CONTEXT_INFO)malloc( sizeof(AUTHZ_CLIENT_CONTEXT_INFO) );
        if ( NULL == pContextInfoNew ) {
            return ERROR_OUTOFMEMORY;
        }

        // initialize empty list of cached quotas
        //
        pContextInfoNew->pEffectiveQuota = NULL;

        // authz context handle has not yet been created! get it.

        // NOTE: This code is NOT protected by a critical section.
        // in a (rare) case that two threads will come here and find an uninitialized AuthzContext,
        // they both will create it. However, they will not be able to write it into the struct
        // simultaneously since it is protected by an InterlockedCompareExchangePointer.
        // The thread that loses will destroy its context.

        // we need to hold on to the pAuthzCC ptr (refcount it!) because it will get
        // thrown away from the thread state by Impersonate/Unimpersonate
        AssignAuthzClientContext(&pLocalCC, pTHS->pAuthzCC);
        __try {
            // need to grab clientToken first
            if ((dwError = ImpersonateAnyClient()) != 0)
                __leave;

            // Now, get the client token.
            if (!OpenThreadToken(
                    GetCurrentThread(),        // current thread handle
                    TOKEN_READ,                // access required
                    TRUE,                      // open as self
                    &hClientToken)) {          // client token

                dwError =  GetLastError();                  // grab the error code

                DPRINT1 (0, "Failed to open thread token for current thread: 0x%x\n", dwError);
                Assert (!"Failed to open thread token for current thread");
            }

            UnImpersonateAnyClient();

            // now, put the pLocalCC back into the THSTATE (because it has been
            // removed from there by impersonate/unimpersonate calls)
            AssignAuthzClientContext(&pTHS->pAuthzCC, pLocalCC);

            if (dwError != 0)
                __leave;

            // Dump Token for Debugging
            if (TEST_ERROR_FLAG(NTDSERRFLAG_DUMP_TOKEN))
            {
                DPRINT(0, "GetAuthzContextHandle: got client token\n");
                DumpToken(hClientToken);
            }

            // now we can create the authz context from the token
            bSuccess = AuthzInitializeContextFromToken(
                            0,              // flags
                            hClientToken,   // client token
                            ghAuthzRM,      // global RM handle
                            NULL,           // expiration time (unsupported anyway)
                            aLUID,          // LUID for the context (not used)
                            NULL,           // dynamic groups
                            &pContextInfoNew->hAuthzContext     // new context
                            );

            if (!bSuccess) {
                dwError = GetLastError();
                DPRINT1(0, "Error from AuthzInitializeContextFromToken: %d\n", dwError);
                __leave;
            }

            Assert( NULL != pContextInfoNew->hAuthzContext );

            // now perform an InterlockedCompareExchangePointer to put the new
            // value into the context variable
            if (InterlockedCompareExchangePointer(
                    &pTHS->pAuthzCC->pAuthzContextInfo,
                    pContextInfoNew,
                    NULL
                    ) != NULL) {
                // this thread lost! assignment did not happen. Got to get rid of the context
                DPRINT(0, "This thread lost in InterlockedCompareExchange, releasing the duplicate context\n");
                AuthzFreeContext(pContextInfoNew->hAuthzContext);
                free(pContextInfoNew);
            }

            //  pointer to context info copied to THS (or freed on
            //  collision), reset local variable so memory won't
            //  be released by error-handler below
            //
            pContextInfoNew = NULL;

            // assign the result to the out parameter
            Assert( NULL != pTHS->pAuthzCC->pAuthzContextInfo );
            Assert( NULL != pTHS->pAuthzCC->pAuthzContextInfo->hAuthzContext );
            *ppAuthzContextInfo = pTHS->pAuthzCC->pAuthzContextInfo;
        }
        __finally {
            // we need to release the local ptr
            AssignAuthzClientContext(&pLocalCC, NULL);

            if ( NULL != pContextInfoNew ) {
                free( pContextInfoNew );
            }

            // and get rid of the token
            if (hClientToken != INVALID_HANDLE_VALUE) {
                CloseHandle(hClientToken);
            }
        }

    }

    Assert( 0 != dwError || NULL != *ppAuthzContextInfo );
    Assert( 0 != dwError || NULL != (*ppAuthzContextInfo)->hAuthzContext );

    return dwError;
}

DWORD
CheckGroupMembershipAnyClient(
    IN THSTATE* pTHS,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PSID *pGroupSids,
    IN DWORD cGroupSids,
    OUT BOOL *bResults
    )
/*++

  Description:

    Verify if the caller is a member of the group.
    The array of group sids is passed in.
    *bResults is an array of booleans, which correspond
    to the group sids.
    
    The context comes from either the THSTATE or is explicitly passed in.

  Arguments:

    pTHS (IN OPTIONAL) - Thread state
    
    hAuthzClientContext (IN OPTIONAL) - auth client context (must be passed if pTHS is null)

    pGroupSids  - array of groups to check
    
    cGroupSids  - number of elements in the array

    bResults   - array of booleans to receive the results

  Return Value:

    0 on success, !0 on error

--*/

{
    BOOL                        bSuccess;
    PTOKEN_GROUPS               pGroups = NULL;
    DWORD                       dwBufSize;
    DWORD                       i, j;
    DWORD                       dwError;

    Assert((pTHS != NULL || hAuthzClientContext != NULL) && pGroupSids && bResults);

    dwError = 0;
    memset(bResults, 0, cGroupSids*sizeof(BOOL));

    if (hAuthzClientContext == NULL) {
        // grab the authz client context
        // if it was never obtained before, this will impersonate the client, grab the token,
        // unimpersonate the client, and then create a new authz client context from the token
        dwError = GetAuthzContextHandle(pTHS, &hAuthzClientContext);
        if (dwError != 0) {
            goto finished;
        }
    }
    Assert(hAuthzClientContext);

    //
    // grab groups from the AuthzContext
    // But first get the size required
    //
    bSuccess = AuthzGetInformationFromContext(
        hAuthzClientContext,            // client context
        AuthzContextInfoGroupsSids,     // requested groups
        0,                              // no buffer yet
        &dwBufSize,                     // required size
        NULL                            // buffer
        );
    // must return ERROR_INSUFFICIENT_BUFFER! if not, return error
    if (bSuccess) {
        DPRINT1(0, "AuthzGetInformationFromContext returned success, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", ERROR_INSUFFICIENT_BUFFER);
        dwError = ERROR_DS_INTERNAL_FAILURE;
        goto finished;
    }
    if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
        DPRINT2(0, "AuthzGetInformationFromContext returned %d, expected ERROR_INSUFFICIENT_BUFFER (%d)\n", dwError, ERROR_INSUFFICIENT_BUFFER);
        goto finished;
    }
    dwError = 0; // need to reset it to OK now

    // no buffer, nothing to do...
    if (dwBufSize == 0) {
        Assert(!"AuthzGetInformationFromContext says it needs zero-length buffer, weird... Let AuthZ people know. This assert is ignorable");
        dwError = ERROR_DS_INTERNAL_FAILURE;
        goto finished;
    }

    // allocate memory
    if (pTHS) {
        pGroups = THAllocNoEx(pTHS, dwBufSize);
    }
    else {
        pGroups = malloc(dwBufSize);
    }
    if (pGroups == NULL) {
        dwError = ERROR_OUTOFMEMORY;
        goto finished;
    }

    // now get the real groups...
    bSuccess = AuthzGetInformationFromContext(
        hAuthzClientContext,           // context handle
        AuthzContextInfoGroupsSids,    // requesting groups
        dwBufSize,                     // and here is its size
        &dwBufSize,                    // just in case
        pGroups                        // now there is a buffer
        );
    if (!bSuccess) {
        dwError = GetLastError();
        DPRINT1(0, "AuthzGetInformationFromContext failed, err=%d\n", dwError);
        goto finished;
    }

    for (j = 0; j < cGroupSids; j++) {
        if (pGroupSids[j] != NULL) {
            for (i = 0; i < pGroups->GroupCount; i++) {
                if (RtlEqualSid(pGroupSids[j], pGroups->Groups[i].Sid)) {
                    bResults[j] = TRUE; // found group!
                    break;
                }
            }
        }
    }

finished:
    //
    // clean up
    //
    if (pGroups) {
        if (pTHS) {
            THFreeEx(pTHS, pGroups);
        }
        else {
            free(pGroups);
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\phantom.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       phantom.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop


// Core DSA headers.
#include <ntdsa.h>
#include <dsjet.h>                      // for error codes
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"
#include <dstaskq.h>
#include <filtypes.h>
#include <usn.h>
#include "dsexcept.h"
#include <drs.h>
#include <gcverify.h>
#include <dsconfig.h>                   // Definition of mask for visible
                                        // containers
#include "debug.h"                      // standard debugging header
#define DEBSUB "PHANTOM:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_PHANTOM

// How many times will we go to the GC before we quit running this task and
// reschedule ourselves?  Don't make it too high, or we end up hogging the task
// queue thread.
#define MAX_GC_TRIPS 10

// How many phantom names do we gather at once before we head off to the GC to
// verify the data?
#define NAMES_PER_GC_TRIP       240

// The algorithm below works best if max_stale_phantoms is a multiple of
// NAMES_PER_GC_TRIP, and MAX_STALE_PHANTOMS must be small enough that we can
// write that many dnt values as an attribute on an object (i.e. small enough to
// avoid DBLayer limits on max attribute values per object).
#define MAX_STALE_PHANTOMS 720

// No matter what, don't schedule this to run more often than once every 15
// minutes.
#define PHANTOM_DAEMON_MIN_DELAY (15 * 60)

// No matter what, don't schedule this to run less often than once a day
#define PHANTOM_DAEMON_MAX_DELAY (24 * 60 * 60)

#define SECONDS_PER_DAY (24 * 60 * 60)

// How many days will we take to scan the whole DIT?
#define DEFAULT_PHANTOM_SCAN_RATE 2

// We should really try and scan the whole DIT once a year
#define MAX_PHANTOM_SCAN_RATE 365

// The following variable is set to TRUE when we think we are the phantom
// cleanup master AND we think we have managed to schedule the normal phantom
// cleanup task.
DWORD gfIsPhantomMaster = FALSE;

VOID
LogPhantomCleanupFailed(
    IN DWORD ErrCode,
    IN DWORD ExtError,
    IN DWORD DsId,
    IN DWORD Problem,
    IN DWORD ExtData
    )
{
    LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
              DS_EVENT_SEV_VERBOSE,
              DIRLOG_STALE_PHANTOM_CLEANUP_ADD_FAILED,
              szInsertUL(ErrCode),
              szInsertHex(ExtError),
              szInsertUL(DsId),
              szInsertUL(Problem),
              szInsertUL(ExtData),
              NULL, NULL, NULL);

} // LogPhantomCleanupFailed

VOID
spcAddCarrierObject (
        THSTATE *pTHS,
        DSNAME  *pInfrObjName,
        DWORD    count,
        PDSNAME *pFreshNames
        )
/*++
  Description:
      Given the name of an object and a list of dsnames, add a new object under
      the given object.  The RDN is a guid.  The new object is an
      INFRASTRUCTURE_UPDATE object, and the list of DNTs are added as values of
      the attribute DN_REFERENCE_UPDATE.  After successfully adding the object,
      it is deleted.  This leaves a tombstone that will replicate around,
      carrying the values of DN_REFERENCE_UPDATE, but that will dissappear after
      the tombstone lifetime.

      This is called by the phantom update daemon, below.

  Return values:
      None.  The object is added if it can be, otherwise an error is logged.
--*/
{
    REMOVEARG      RemoveArg;
    REMOVERES      RemoveRes;
    ADDARG         AddArg;
    ADDRES         AddRes;
    GUID           NewRDNGuid;
    WCHAR         *pNewRDN=NULL;
    DSNAME        *pNewName;
    ATTRTYP        InfrastructureObjClass=CLASS_INFRASTRUCTURE_UPDATE;
    ATTRVAL        classVal;
    ATTR          *pAttrs = NULL;
    DWORD          i;
    ATTRVAL       *pNewNamesAttr;
    DWORD          newNamesCount;
    ULONG          dwException, ulErrorCode, dsid;
    PVOID          dwEA;

    Assert(count);

    if (!gUpdatesEnabled) {
        // Can't add anything yet.
        LogPhantomCleanupFailed(0,
                                DIRERR_SCHEMA_NOT_LOADED,
                                DSID(FILENO, __LINE__),
                                0,
                                0);
        return;
    }

    if (eServiceShutdown) {
        return;
    }

    // Make the name of the new object.  It's the name of the domain
    // infrastructure object with an RDN based on a guid tacked on.

    pNewName = THAllocEx(pTHS, pInfrObjName->structLen + 128);

    DsUuidCreate(&NewRDNGuid);
    DsUuidToStringW(&NewRDNGuid, &pNewRDN);
    AppendRDN(pInfrObjName,
              pNewName,
              pInfrObjName->structLen + 128,
              pNewRDN,
              0,
              ATT_COMMON_NAME);
    RpcStringFreeW(&pNewRDN);

    // Now, the attrblock.  Start by building the attrval array for the new
    // names.
    pNewNamesAttr = THAllocEx(pTHS, count * sizeof(ATTRVAL));
    newNamesCount = 0;
    for(i=0;i<count;i++) {
        pNewNamesAttr[i].valLen = pFreshNames[i]->structLen;
        pNewNamesAttr[i].pVal = (PUCHAR)pFreshNames[i];
    }

    // pAttrs must be THAlloced, it is asserted by CheckAddSecurity which is
    // called via the DirAddEntry below.
    pAttrs = THAllocEx(pTHS, 2 * sizeof(ATTR));

    pAttrs[0].attrTyp = ATT_OBJECT_CLASS;
    pAttrs[0].AttrVal.valCount = 1;
    pAttrs[0].AttrVal.pAVal = &classVal;

    classVal.valLen = sizeof(ATTRTYP);
    classVal.pVal = (PUCHAR)&InfrastructureObjClass;

    pAttrs[1].attrTyp = ATT_DN_REFERENCE_UPDATE;
    pAttrs[1].AttrVal.valCount = count;
    pAttrs[1].AttrVal.pAVal = pNewNamesAttr;

    // Make the addarg
    memset(&AddArg, 0, sizeof(ADDARG));
    AddArg.pObject = pNewName;
    AddArg.AttrBlock.attrCount = 2;
    AddArg.AttrBlock.pAttr = pAttrs;
    InitCommarg(&AddArg.CommArg);
    AddArg.CommArg.Svccntl.dontUseCopy = TRUE;

    // Make the remarg
    memset(&RemoveArg, 0, sizeof(REMOVEARG));
    RemoveArg.pObject = pNewName;
    InitCommarg(&RemoveArg.CommArg);
    RemoveArg.CommArg.Svccntl.dontUseCopy = TRUE;

    __try {
        // GC verification intentially performed outside transaction scope.
        SYNC_TRANS_WRITE();       /* Set Sync point*/
        __try {

            if(DoNameRes(pTHS,
                         0,
                         pInfrObjName,
                         &AddArg.CommArg,
                         &AddRes.CommRes,
                         &AddArg.pResParent)) {
    	// Name Res failed.  But, we were looking for the infrastructure
                // update object, so it should never fail.
                __leave;
            }
            else{
                // Ok, we're adding a normal object inside an NC
                // that we hold a master copy of.  Let'er rip
                if ( LocalAdd(pTHS, &AddArg, FALSE) ) {
                    __leave;
                }
            }

            // Now, the delete.
            // Perform name resolution to locate object.  If it fails,
            // just return an error, which may be a referral. Note that
            // we must demand a writable copy of the object.


            if(DoNameRes(pTHS,
                         0,
                         pNewName,
                         &RemoveArg.CommArg,
                         &RemoveRes.CommRes,
                         &RemoveArg.pResObj)) {
                // Name Res failed, but we just successfully added this thing,
                // so it should never fail.
                __leave;
            }
            else {
                LocalRemove(pTHS, &RemoveArg);
            }
        }
        __finally {
                DWORD dsid=0, extendedErr=0, extendedData=0, problem=0;

                Assert(pTHS->errCode != securityError);

                switch(pTHS->errCode) {
                case attributeError:
                    dsid = pTHS->pErrInfo->AtrErr.FirstProblem.intprob.dsid;
                    extendedErr =
                        pTHS->pErrInfo->AtrErr.FirstProblem.intprob.extendedErr;
                    extendedData =
                        pTHS->pErrInfo->AtrErr.FirstProblem.intprob.extendedData;
                    problem =
                        pTHS->pErrInfo->AtrErr.FirstProblem.intprob.problem;
                    break;

                case 0:
                    // No error.
                    if(AbnormalTermination()) {
                        dsid=DSID(FILENO, __LINE__);
                        extendedErr = ERROR_DS_UNKNOWN_ERROR;
                    }
                    break;

                default:
                    // Just assume it was an update error, the rest of the
                    // structures are all alike.
                    dsid = pTHS->pErrInfo->UpdErr.dsid;
                    extendedErr = pTHS->pErrInfo->UpdErr.extendedErr;
                    extendedData = pTHS->pErrInfo->UpdErr.extendedData;
                    problem = pTHS->pErrInfo->UpdErr.problem;
                    break;
                }

                if (pTHS->errCode || AbnormalTermination()) {
                    LogPhantomCleanupFailed(
                                pTHS->errCode,
                                extendedErr,
                                dsid,
                                problem,
                                extendedData);
                }

            CLEAN_BEFORE_RETURN(pTHS->errCode); // This closes the transaction
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                    &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }

    THFreeEx(pTHS, pNewName);
    THFreeEx(pTHS, pNewNamesAttr);
    // Explicitly DON'T free pAttrs.  CheckAddSecurity() realloc'ed it in order
    // to add a security descriptor to the list.  Instead, free the realloc'ed
    // block, which was put back into the add arg.
    THFreeEx(pTHS, AddArg.AttrBlock.pAttr);

    return;
}

BOOL
GetBetterPhantomMaster(
        THSTATE *pTHS,
        DSNAME **ppDN
        )
/*++
  Description:
      See if we can find a DC that we think would be a better candidate for
      holding the phantom master fsmo. We're looking for a replica of our domain
      that is not a DC.


     Issue a search from the sites container.
     Filter is
       (& (objectCategory=NTDS-Settings)
                                          // One of two filters is used:
          (msDS-HasMasterNCs=<MyNC>)        // for .NET forest mode
                                                // or
          (| (msDS-HasMasterNCs=<MyNC>)     // Win2k compatibility
             (hasMasterNCs=<MyNC) )

          (!(Options.bitOr.ISGC)))

     Size limit 1.
     Atts selected = NONE

     Any object found by this search would be a better server to hold the FSMO.
--*/
{
    DWORD                  Opts;
    FILTER                 Filter;
    FILTER                 FilterClauses[3];
    FILTER                 FilterNot;
    FILTER                 NewHasNcFilter, OldHasNcFilter;
    SEARCHARG              SearchArg;
    SEARCHRES             *pSearchRes;
    CLASSCACHE            *pCC;
    ENTINFSEL              eiSel;
    DSNAME                *pSitesContainer;


    // build search argument

    // Sites container is the parent of our site object.
    pSitesContainer = THAllocEx(pTHS, gAnchor.pSiteDN->structLen);
    TrimDSNameBy(gAnchor.pSiteDN, 1, pSitesContainer);

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = pSitesContainer;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.bOneNC = TRUE;
    SearchArg.pSelection = &eiSel;
    InitCommarg(&(SearchArg.CommArg));
    SearchArg.CommArg.ulSizeLimit = 1;
    SearchArg.CommArg.Svccntl.localScope = TRUE;

    // Get the class cache to get hold of the object category.
    pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA);
    Assert(pCC);

    // build filter
    memset (&Filter, 0, sizeof (Filter));
    Filter.pNextFilter = NULL;
    Filter.choice = FILTER_CHOICE_AND;
    Filter.FilterTypes.And.count = 3;
    Filter.FilterTypes.And.pFirstFilter = FilterClauses;

    memset (&FilterClauses, 0, sizeof (FilterClauses));
    FilterClauses[0].pNextFilter = &FilterClauses[1];
    FilterClauses[0].choice = FILTER_CHOICE_ITEM;
    FilterClauses[0].FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FilterClauses[0].FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    FilterClauses[0].FilterTypes.Item.FilTypes.ava.Value.valLen =
        pCC->pDefaultObjCategory->structLen;
    FilterClauses[0].FilterTypes.Item.FilTypes.ava.Value.pVal =
        (PUCHAR) pCC->pDefaultObjCategory;

    // This fills the Filters for getting a DC with the correct NC in it's Master NCs.
    FillHasMasterNCsFilters(gAnchor.pDomainDN,
                            &(FilterClauses[1]),
                            &NewHasNcFilter,
                            &OldHasNcFilter);
    FilterClauses[1].pNextFilter = &FilterClauses[2];

    FilterClauses[2].pNextFilter = NULL;
    FilterClauses[2].choice = FILTER_CHOICE_NOT;
    FilterClauses[2].FilterTypes.pNot = &FilterNot;


    memset (&FilterNot, 0, sizeof (FilterNot));
    FilterNot.pNextFilter = NULL;
    FilterNot.choice = FILTER_CHOICE_ITEM;
    FilterNot.FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
    FilterNot.FilterTypes.Item.FilTypes.ava.type = ATT_OPTIONS;
    FilterNot.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(Opts);
    FilterNot.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR) &Opts;
    Opts = NTDSDSA_OPT_IS_GC;

    // build selection
    eiSel.attSel = EN_ATTSET_LIST;
    eiSel.infoTypes = EN_INFOTYPES_TYPES_ONLY;
    eiSel.AttrTypBlock.attrCount = 0;
    eiSel.AttrTypBlock.pAttr = NULL;


    // Search for all Address Book objects.
    pSearchRes = (SEARCHRES *)THAllocEx(pTHS, sizeof(SEARCHRES));
    SearchBody(pTHS, &SearchArg, pSearchRes,0);

    THFreeEx(pTHS, pSitesContainer);

    if(!pSearchRes->count) {
        *ppDN = NULL;
    }
    else {
        *ppDN = pSearchRes->FirstEntInf.Entinf.pName;
    }

    THFreeEx(pTHS, pSearchRes);

    return ((BOOL)(*ppDN != NULL));
}

BOOL
InitPhantomCleanup (
        IN  THSTATE  *pTHS,
        OUT BOOL     *pIsPhantomMaster,
        OUT DSNAME  **ppInfrObjName
        )
/*++

  Description:
      Verifies that we shoudl be running the phantom cleanup task by
      1) Checking that we are the FSMO role holder.
      2) Checking that we are NOT a GC.
      3) Checking that the phantom index exists.
      4) Checking that we can successfully create the phantom index if it
      doesn't exist.

  Return Values:
      Returns TRUE if we passed all the checks.  In that case, the dsname of the
      infrastructure update object is also returned.

--*/
{
    BOOL    rtn = FALSE;
    BOOL    fCommit = FALSE;
    DWORD   i;
    DWORD   InBuffSize;
    DWORD   outSize;
    DSNAME *pTempDN = NULL;
    DWORD   err;

    if(!gAnchor.pInfraStructureDN) {
        // This machine isn't set up to do this.  We don't support stale
        // phantoms here.
        return FALSE;
    }

    Assert(!pTHS->pDB);
    DBOpen(&pTHS->pDB);
    __try {


        // First, find out if I'm really the phantom cleanup master
        if((DBFindDSName(pTHS->pDB, gAnchor.pInfraStructureDN))  ||
           (DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_FSMO_ROLE_OWNER,
                        DBGETATTVAL_fREALLOC | DBGETATTVAL_fSHORTNAME,
                        0,
                        &outSize,
                        (PUCHAR *)&pTempDN))) {
            // I couldn't verify who the phantom master is.
            __leave;
        }

        // OK, I know who the phantom master is.
        if(!NameMatched(pTempDN, gAnchor.pDSADN)) {
            // It's not me.
            *pIsPhantomMaster = FALSE;
            __leave;
        }

        THFreeEx(pTHS, pTempDN);

        // I am the FSMO role holder.
        *pIsPhantomMaster = TRUE;

        // Do we need to worry about any of this?
        if(gAnchor.uDomainsInForest <= 1) {
            // Only one domain exists.  That means two things
            // 1) We aren't going to find any phantoms to remove
            // 2) No one else is either.
            // So, return from this routine with the code saying to not bother
            // doing any phantom cleanup, but don't bother looking for anyone
            // else to hold the phantom cleanup role.
            __leave;
        }

        // OK, now find out if we are a GC (in which case we won't find any
        // phantoms, so we don't need to do any phantom cleanup.)
        if (gAnchor.fAmGC) {
            DSNAME *pDN = NULL;
            // Yes.  The stale phantom stuff doesn't do anything on a GC.
            if(GetBetterPhantomMaster(pTHS, &pDN)) {
                // Complain, and tell them to move the role to a non-GC.
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_STALE_PHANTOM_CLEANUP_MACHINE_IS_GC,
                         szInsertDN(pDN),
                         NULL,
                         NULL);

                THFreeEx(pTHS, pDN);
            }
            // ELSE
            //   No better machine exists to hold this role.  Just shut up.
            //
            __leave;
        }


        // Get a copy of the current string name of the infrastrucutre update
        // object while we are here.  We might need it later if we need to add a
        // child object.
        *ppInfrObjName = NULL;
        DBGetAttVal(pTHS->pDB,
                    1,
                    ATT_OBJ_DIST_NAME,
                    0,0,&outSize, (PUCHAR *)ppInfrObjName);
        Assert(*ppInfrObjName);

        // Next, make sure the index we need is here
        if(DBSetCurrentIndex(pTHS->pDB, Idx_Phantom, NULL, FALSE)) {
            // Failed to just set to the index, so try to create it.
            if(err = DBCreatePhantomIndex(pTHS->pDB)) {
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_CANT_MAKE_INDEX,
                         szInsertInt(err),
                         szInsertWin32Msg(err),
                         NULL);
                __leave;
            }
            // We seem to have created it, so try setting to it.
            if(err = DBSetCurrentIndex(pTHS->pDB, Idx_Phantom,
                                       NULL, FALSE)) {
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_CANT_USE_INDEX,
                         szInsertInt(err),
                         szInsertWin32Msg(err),
                         NULL);
                __leave;
            }
        }
        rtn = TRUE;
        fCommit = TRUE;
    }
    __finally {
        DBClose(pTHS->pDB, fCommit);
    }

    return rtn;
}


void
PhantomCleanupLocal (
        OUT DWORD * pcSecsUntilNextIteration,
        OUT BOOL  * pIsPhantomMaster
        )
/*++
  Description:
       Routine to run the phantom cleanup task.  Looks through the
       DIT for phantoms, verifies their string names against a GC, and writes
       corrected string names into the DIT for any names which are incorrect.

   Parameter:
       pcSecsUntilNextIteration - Fills in the number of seconds in the future
            that we should reschedule in order to keep up with our stated rate
            goal. If Null is passed in, we ignore this and don't figure out when
            to reschedule.

       pIsPhantomMaster - on return is TRUE if we could verify that we are the
            phantom master, is FALSE is we could verify that we are NOT the
            phantom master, and is untouched if we could not verify either way.

   Return values:
       None.

--*/
{
    THSTATE *pTHS = pTHStls;
    BOOL     fCommit = FALSE;
    PDSNAME  objNames[NAMES_PER_GC_TRIP];
    PDSNAME  verifiedNames[NAMES_PER_GC_TRIP];
    PDSNAME  freshNames[MAX_STALE_PHANTOMS];
    DWORD    err;
    BOOL     fInited;
    DWORD    DNTStart = INVALIDDNT;
    DWORD    i, count = 0;
    DSNAME  *pInfrObjName=NULL;
    DWORD    freshCount = 0;
    BOOL     fGatheringStalePhantoms;
    DWORD    dwGCTrips = 0;
    DWORD    numPhantoms = 0;
    DWORD    numVisited = 0;
    DWORD    calculatedDelay = 0;

    pTHS->fDSA = TRUE;
    pTHS->fPhantomDaemon = TRUE;


    if(pcSecsUntilNextIteration) {
        *pcSecsUntilNextIteration = PHANTOM_DAEMON_MAX_DELAY;
    }

    Assert(!pTHS->pDB);
    // InitPhantomCleanup
    if(InitPhantomCleanup(pTHS, pIsPhantomMaster, &pInfrObjName)) {
        // OK, we're supposed to clean up stale phantoms.  Do so.

        // For now, we will continue to look for stale phantoms until
        // 0) We have made MAX_GC_TRIPS to the GC. OR
        // 1) We look at all the phantoms on the machine. OR
        // 2) We find between X stale phantom names (i.e. names we need to write
        //    to the carrier object in order to get the DB up to date).
        //    (MAX_STALE_PHANTOMS - NAMES_PER_GC_TRIP) <= X <=
        //                                         MAX_STALE_PHANTOMS.
        //
        //
        // Especially note: we don't have any way yet of throttling this from
        // looking at every phantom if nothing has changed.

        fGatheringStalePhantoms = TRUE;
        while(fGatheringStalePhantoms &&
              ((freshCount + NAMES_PER_GC_TRIP) <= MAX_STALE_PHANTOMS)) {
            // First, find a batch of names to be verified,
            Assert(!pTHS->pDB);
            DBOpen(&pTHS->pDB);
            __try {
                DBSetCurrentIndex(pTHS->pDB, Idx_Phantom, NULL, FALSE);
                count = 0;
                if(!(err = DBMove(pTHS->pDB, FALSE, DB_MoveFirst))) {
                    // Only do this the very first time we come through here.
                    if(DNTStart == INVALIDDNT) {
                        if (pcSecsUntilNextIteration) {
                            // We need to figure out when to reschedule.  That
                            // requires we know how big the index is.
                            // Use a rough estimate -- we don't need the exact number here.
                            // The estimate
                            DBGetIndexSizeEx(pTHS->pDB, pTHS->pDB->JetObjTbl, &numPhantoms, TRUE);
                            // reposition to the beginning
                            DBMove(pTHS->pDB, FALSE, DB_MoveFirst);
                        }
                        // See what the DNT of the first object is so we can
                        // stop if we see it twice.
                        DNTStart = pTHS->pDB->DNT;
                    }
                    do {
                        objNames[count] = DBGetCurrentDSName(pTHS->pDB);
                        numVisited++;

                        // we cannot assume that we will get a DSNAME here because
                        // a database exception could cause a NULL to be returned
                        // on an otherwise ordinary DIT.  if we don't then just
                        // skip past this entry.  also, do not move it in the index
                        // or else we could get stuck in an infinite loop
                        if (objNames[count]) {

                            // Now, update the USN changed of this object to
                            // indicate we are examining it for staleness (which
                            // moves it to the end of the index)
                            DBUpdateUsnChanged(pTHS->pDB);
                            count++;
                        }

                        err = DBMove(pTHS->pDB, FALSE, 1);
                    } while(!err &&               // all is ok.
                            (pTHS->pDB->DNT != DNTStart) && // haven't wrapped
                            // the list
                            (count < NAMES_PER_GC_TRIP )); // we've not done too
                                                           // much work already
                    if(pTHS->pDB->DNT == DNTStart) {
                        // We wrapped completely through the list.
                        fGatheringStalePhantoms = FALSE;
                    }
                }
                fCommit = TRUE;
            }
            __finally {
                DBClose(pTHS->pDB, fCommit);
            }

            if(!fCommit) {
                // Failed to talk to the DIT for some reason.  Complain, but
                // continue in order to deal with the stalePhantoms we already
                // got (if any)

                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_LOCATE_PHANTOMS_FAILED,
                         NULL,
                         NULL,
                         NULL);

                fGatheringStalePhantoms = FALSE;
            }
            else if(count) {

                // All is going well, and we found some names we need to verify
                // against the GC.  Do so now.
                dwGCTrips++;
                if(dwGCTrips >= MAX_GC_TRIPS) {
                    // Each pass through here will only do so many trips to the
                    // GC (we don't want to tie up the task queue for too
                    // long), and we've hit that limit.
                    fGatheringStalePhantoms = FALSE;
                }
                if(!GCGetVerifiedNames(pTHS,
                                       count,
                                       objNames,
                                       verifiedNames)) {
                    // Got the verified names from the GC, find which ones are
                    // stale.
                    // We demand byte for byte equality of names here.
                    for(i=0;i<count;i++) {
                        if(verifiedNames[i] &&
                           ((verifiedNames[i]->structLen   !=
                             objNames[i]->structLen           ) ||
                            memcmp(verifiedNames[i],
                                   objNames[i],
                                   objNames[i]->structLen))) {
                            freshNames[freshCount] = verifiedNames[i];
                            freshCount++;
                        }

                        // Don't need these no more.
                        THFreeEx(pTHS, objNames[i]);
                        objNames[i] = NULL;
                        verifiedNames[i] = NULL;
                    }
                }
                else {
                    // Hmm.  failed to get to the GC for some reason. Complain,
                    // but continue in order to deal with the stalePhantoms we
                    // already got (if any)

                    LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                             DS_EVENT_SEV_VERBOSE,
                             DIRLOG_STALE_PHANTOM_CLEANUP_GC_COMM_FAILED,
                             NULL,
                             NULL,
                             NULL);

                    fGatheringStalePhantoms = FALSE;
                }
            }
            else {
                // No more phantoms found.  We're done.
                fGatheringStalePhantoms = FALSE;
            }
        }

        // Now, pass the array of stale phantom names
        if(freshCount) {
            spcAddCarrierObject(pTHS, pInfrObjName, freshCount, freshNames);
            for(i=0;i<freshCount;i++) {
                THFreeEx(pTHS, freshNames[i]);
            }
        }
    }

    THFreeEx(pTHS, pInfrObjName);

    // Figure out when to reschedule.

    if(pcSecsUntilNextIteration && !eServiceShutdown) {
        // We need to figure out when to reschedule

        // We must always have some positive rate that we wish to achieve.
        DWORD daysPerPhantomScan;

        if (GetConfigParam(PHANTOM_SCAN_RATE,
                           &daysPerPhantomScan,
                           sizeof(daysPerPhantomScan))) {
            daysPerPhantomScan = DEFAULT_PHANTOM_SCAN_RATE;
        }
        daysPerPhantomScan = min(daysPerPhantomScan, MAX_PHANTOM_SCAN_RATE);

        if(!numVisited) {
            // Didn't actually look at any this time.
            if(numPhantoms) {
                // but there were some
                calculatedDelay = PHANTOM_DAEMON_MIN_DELAY;
            }
            else {
                // but we don't think there are any.
                calculatedDelay = PHANTOM_DAEMON_MAX_DELAY;
            }
        }
        else {
            // The estimate for the number of phantoms that we
            // obtained is quite rough. It can even be less
            // than the actual count.
            if (numPhantoms < numVisited) {
                numPhantoms = numVisited;
            }

            //   Seconds   Days     Objects
            //   ------- * ----- * --------
            //    Day       Dit      Pass           Seconds
            // ------------------------------ =   -----------
            //           objects                     Pass
            //           --------
            //             Dit
            //
            // SECONDS_PER_DAY constant,
            // daysPerPhantomScan is a configurable value from the registry.
            // numVisited is the objects we visited on this pass.
            // numPhantoms is the number of phantom objects in this dit.
            //
            // So, the result of this calculation is how long we can wait before
            // we do a pass just like this one and still maintain the rate we
            // wish to maintain.
            //
            calculatedDelay = MulDiv(SECONDS_PER_DAY * daysPerPhantomScan,
                                     numVisited,
                                     numPhantoms);


            if(calculatedDelay < PHANTOM_DAEMON_MIN_DELAY) {
                // At this pace, we need to be looking at the GC way to often.
                // Log to let the world know, and slow down a bit.  This means
                // we will fall behind, but at least we won't bring this DS to
                // its knees.
                LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_STALE_PHANTOM_CLEANUP_TOO_BUSY,
                         szInsertUL(calculatedDelay),
                         szInsertUL(PHANTOM_DAEMON_MIN_DELAY),
                         szInsertUL(daysPerPhantomScan));
                calculatedDelay = PHANTOM_DAEMON_MIN_DELAY;
            }
            else if(calculatedDelay > PHANTOM_DAEMON_MAX_DELAY) {
                // At this rate, we don't actually need to look for a long time,
                // but there is no sense in actually waiting that long.
                calculatedDelay = PHANTOM_DAEMON_MAX_DELAY;
            }
        }

        *pcSecsUntilNextIteration = calculatedDelay;

        if(*pIsPhantomMaster) {
            LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_STALE_PHANTOM_CLEANUP_SUCCESS_AS_MASTER,
                      szInsertUL(numVisited),
                      szInsertUL(numPhantoms),
                      szInsertUL(freshCount),
                      szInsertUL(calculatedDelay),
                      NULL, NULL, NULL, NULL);
        }
        else {
            LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_STALE_PHANTOM_CLEANUP_SUCCESS_NOT_AS_MASTER,
                     szInsertUL(calculatedDelay), NULL, NULL);
        }

    }

    return;

}



void
PhantomCleanupMain (
        void *  pv,
        void ** ppvNext,
        DWORD * pcSecsUntilNextIteration
        )
/*++
  Description:
      Task queue routine to run the phantom cleanup task.
      Can be invoked in two ways.  If PHANTOM_CHECK_FOR_FSMO, then we don't
      already think we are the FSMO role holder, and we're just looking to see
      if we have siezed the role.  If we notice we have siezed the role, we
      change our state to PHANTOM_IS_PHANTOM_MASTER, and schedule much more
      aggressively.  Also, if PHANTOM_CHECK_FOR_FSMO and we notice thet
      gfIsPhantomCleanupMaster is true, then we have been made the role holder
      via normal become_foo_master means, and while doing that, we scheduled
      another task wiht PHANTOM_IS_PHANTOM_MASTER, so in that case (to avoid
      multiple task queue items to deal with phantomness), simply don't
      reschedule ourselves.

      If PHANTOM_IS_PHANTOM_MASTER, then do normal cleanup. If we notice during
      that that we are no longer the phantom master, just drop the state back to
      PHANTOM_CHECK_FOR_FSMO.

      Normally, at boot, we put a CHECK_FOR_FSMO in the task queue.  If that
      first task notices it is the role holder, it reschedules itself and morphs
      its state to PHANTOM_IS_PHANTOM_MASTER.  If it notices it is not the
      phantom master, it reschedules itself and stays in the CHECK_FOR_FSMO
      state.  If this machine later siezes the role, then when we wake up and
      check check, we notice we are the role holder and so do the same state
      change and reschedule.

   Return values:
       None.
--*/
{
    DWORD secsUntilNextIteration = PHANTOM_DAEMON_MAX_DELAY;
    BOOL  fIsMaster;

    __try {
        switch(PtrToUlong(pv)) {
        case PHANTOM_CHECK_FOR_FSMO:
            // Last time I checked, I wasn't the fsmo role holder for phantom
            // cleanup.  See if I am now.
            if(gfIsPhantomMaster) {
                // But I think I am now. So, simply don't reschedule
                // myself, since the normal phantom cleanup task is already in
                // the queue.
                secsUntilNextIteration = TASKQ_DONT_RESCHEDULE;
                return;
            }
            else {
                // No, I still don't think I am.  Try to cleanup anyway.
                fIsMaster = FALSE;
                PhantomCleanupLocal(&secsUntilNextIteration, &fIsMaster);
                if(fIsMaster) {
                    // hey, I just noticed that I am the phantom master.  Change
                    // my state to indicate this.
                    pv = (void *) PHANTOM_IS_PHANTOM_MASTER;
                }
            }
            break;

        case PHANTOM_IS_PHANTOM_MASTER:
            // I think I am the phantom master.
            fIsMaster = TRUE;
            PhantomCleanupLocal(&secsUntilNextIteration, &fIsMaster);
            if(!fIsMaster) {
                // Hey, I'm not the phantom master anymore.  Change my state to
                // reflect this.
                pv = (void *) PHANTOM_CHECK_FOR_FSMO;
            }
        }
    }
    __finally {
        *pcSecsUntilNextIteration = secsUntilNextIteration;
        *ppvNext = pv;
        if(PtrToUlong(pv) == PHANTOM_IS_PHANTOM_MASTER) {
            // We are about to reschedule based on the assumption that we are
            // the phantom master.
            gfIsPhantomMaster = TRUE;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\quota.c ===
#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <scache.h>					//	schema cache
#include <dbglobal.h>				//	The header for the directory database
#include <mdglobal.h>				//	MD global definition header
#include <mdlocal.h>				//	MD local definition header
#include <dsatools.h>				//	needed for output allocation

#include <objids.h>					//	Defines for selected atts
#include <dsjet.h>
#include <dbintrnl.h>
#include <dsevent.h>
#include <mdcodes.h>
#include <anchor.h>
#include <quota.h>

#include "debug.h"					//	standard debugging header
#define DEBSUB		"QUOTA:"		//	define the subsystem for debugging

#include <fileno.h>
#define FILENO		FILENO_QUOTA


const ULONG		g_csecQuotaNextRebuildPeriod		= 60;		//	on async rebuild of Quota table, interval in seconds between rebuild tasks


//	XML template used for results of Quota Top Usage query
//
const WCHAR		g_szQuotaTopUsageTemplate[]		=
						L"\r\n<MS_DS_TOP_QUOTA_USAGE>\r\n"
						L"\t<partitionDN> %s </partitionDN>\r\n"
						L"\t<ownerSID> %s </ownerSID>\r\n"
						L"\t<quotaUsed> %d </quotaUsed>\r\n"
						L"\t<tombstonedCount> %d </tombstonedCount>\r\n"
						L"\t<liveCount> %d </liveCount>\r\n"
						L"</MS_DS_TOP_QUOTA_USAGE>\r\n";


#ifdef AUDIT_QUOTA_OPERATIONS

//	Quota Audit table
//
JET_COLUMNID	g_columnidQuotaAuditNcdnt;
JET_COLUMNID	g_columnidQuotaAuditSid;
JET_COLUMNID	g_columnidQuotaAuditDnt;
JET_COLUMNID	g_columnidQuotaAuditOperation;

//	keep an audit trail of all operations on the Quota table
//
VOID QuotaAudit_(
	JET_SESID		sesid,
	JET_DBID		dbid,
	DWORD			dnt,
	DWORD			ncdnt,
	PSID			psidOwner,
	const ULONG		cbOwnerSid,
	const DWORD		fUpdatedTotal,
	const DWORD		fUpdatedTombstoned,
	const DWORD		fIncrementing,
	const DWORD		fAdding,
	const CHAR		fRebuild )
	{
	JET_TABLEID		tableidQuotaAudit	= JET_tableidNil;
	JET_SETCOLUMN	rgsetcol[4];
	const ULONG		isetcolNcdnt		= 0;
	const ULONG		isetcolSid			= 1;
	const ULONG		isetcolDnt			= 2;
	const ULONG		isetcolOperation	= 3;
	CHAR			szOperation[8];

	if ( fUpdatedTotal )
		{
		strcpy( szOperation, ( fUpdatedTombstoned ? "TB" : "T" ) );
		}
	else if ( fUpdatedTombstoned )
		{
		strcpy( szOperation, "B" );
		}
	else
		{
		//	didn't update counts, so just bail
		//
		return;
		}

	//	fill in szOperation string with what happened to this object
	//
	if ( fIncrementing )
		{
		strcat( szOperation, ( fAdding ? "++" : "+" ) );
		}
	else
		{
		strcat( szOperation, "-" );
		}

	if ( fRebuild )
		{
		strcat( szOperation, "R" );
		}

	//	initialise SetColumn structures
	//
	memset( rgsetcol, 0, sizeof(rgsetcol) );

	rgsetcol[isetcolNcdnt].columnid = g_columnidQuotaAuditNcdnt;
	rgsetcol[isetcolNcdnt].pvData = &ncdnt;
	rgsetcol[isetcolNcdnt].cbData = sizeof(ncdnt);

	rgsetcol[isetcolSid].columnid = g_columnidQuotaAuditSid;
	rgsetcol[isetcolSid].pvData = psidOwner;
	rgsetcol[isetcolSid].cbData = cbOwnerSid;

	rgsetcol[isetcolDnt].columnid = g_columnidQuotaAuditDnt;
	rgsetcol[isetcolDnt].pvData = &dnt;
	rgsetcol[isetcolDnt].cbData = sizeof(dnt);

	rgsetcol[isetcolOperation].columnid = g_columnidQuotaAuditOperation;
	rgsetcol[isetcolOperation].pvData = szOperation;
	rgsetcol[isetcolOperation].cbData = strlen( szOperation );

	//	open cursor on Quota Audit table
	//
	JetOpenTableEx(
			sesid,
			dbid,
			g_szQuotaAuditTable,
			NULL,
			0,
			NO_GRBIT,
			&tableidQuotaAudit );
	Assert( JET_tableidNil != tableidQuotaAudit );

	__try
		{
		//	add new audit record
		//
		JetPrepareUpdateEx( sesid, tableidQuotaAudit, JET_prepInsert );
		JetSetColumnsEx( sesid, tableidQuotaAudit, rgsetcol, sizeof(rgsetcol)/sizeof(rgsetcol[0]) );
		JetUpdateEx( sesid, tableidQuotaAudit, NULL, 0, NULL );
		}

	__finally
		{
		//	close cursor on Quota Audit table
		//
		Assert( JET_tableidNil != tableidQuotaAudit );
		JetCloseTableEx( sesid, tableidQuotaAudit );
		}
	}

#endif	//	AUDIT_QUOTA_OPERATIONS


INT ErrQuotaGetOwnerSID_(
	THSTATE *				pTHS,
	PSECURITY_DESCRIPTOR	pSD,
	PSID *					ppOwnerSid,
	ULONG *					pcbOwnerSid )
	{
	DWORD					err;
	BOOL					fUnused;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	caller should have verified the SD
	//
	Assert( IsValidSecurityDescriptor( pSD ) );

	//	extract owner SID from security descriptor
	//
	Assert( NULL != pSD );
	if ( !GetSecurityDescriptorOwner( pSD, ppOwnerSid, &fUnused ) )
		{
		//	couldn't extract owner SID
		//
		err = GetLastError();
		DPRINT2( 0, "Error %d (0x%x) extracting owner SID.\n", err, err );
		SetSvcErrorEx(  SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, err );
		goto HandleError;
		}
	else if ( NULL == *ppOwnerSid )
		{
		//	missing owner SID
		//
		Assert( !"An SD is missing an owner SID." );
		DPRINT( 0, "Error: owner SID was NULL.\n" );
		SetSvcError(  SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR );
		goto HandleError;
		}
	else
		{
		//	at this point, shouldn't be possible to have an invalid SID
		//
		Assert( IsValidSid( *ppOwnerSid ) );

		//	assuming a valid SID, this will always return a valid value
		//
		*pcbOwnerSid = GetLengthSid( *ppOwnerSid );
		}

HandleError:
	return pTHS->errCode;
	}


INT ErrQuotaAddToCache_(
	THSTATE *					pTHS,
	const DWORD					ncdnt,
	const ULONG					ulEffectiveQuota )
	{
	DWORD						err;
	PAUTHZ_CLIENT_CONTEXT_INFO	pAuthzContextInfo		= NULL;
	PEFFECTIVE_QUOTA *			ppEffectiveQuota;
	PEFFECTIVE_QUOTA 			pEffectiveQuotaNew		= NULL;
	BOOL						fAddedToCache			= FALSE;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );


	err = GetAuthzContextInfo( pTHS, &pAuthzContextInfo );
	if ( 0 != err )
		{
		//	something is horribly wrong, no client context
		//
		DPRINT2( 0, "GetAuthzContextInfo failed with error %d (0x%x).\n", err, err );
		SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE, err );
		goto HandleError;
		}

	while ( !fAddedToCache )
		{
		for ( ppEffectiveQuota = &( pAuthzContextInfo->pEffectiveQuota );
			NULL != *ppEffectiveQuota;
			ppEffectiveQuota = &( (*ppEffectiveQuota)->pEffectiveQuotaNext ) )
			{
			if ( ncdnt == (*ppEffectiveQuota)->ncdnt )
				{
				//	this NC is already in the cache
				//
				fAddedToCache = TRUE;
				break;
				}
			}

		//	should always have a pointer to the pointer to the last
		//	last element in the list
		//
		Assert( NULL != ppEffectiveQuota );

		if ( !fAddedToCache )
			{
			//	see if previous iteration already allocated a new list object
			//
			if ( NULL == pEffectiveQuotaNew )
				{
				//	allocate new list object to store this quota
				//
				pEffectiveQuotaNew = (PEFFECTIVE_QUOTA)malloc( sizeof(EFFECTIVE_QUOTA) );
				if ( NULL == pEffectiveQuotaNew )
					{
					//
					//	QUOTA_UNDONE
					//
					//	emit a warning that we're low on memory and bail,
					//	but don't err out (future operations are just going
					//	to perform sub-optimally because we couldn't cache
					//	this user's effective quota, but it will still work)
					//
					DPRINT( 0, "Failed caching effective quota due to OutOfMemory.\n" );
					Assert( ERROR_SUCCESS == pTHS->errCode );
					goto HandleError;
					}

				pEffectiveQuotaNew->ncdnt = ncdnt;
				pEffectiveQuotaNew->ulEffectiveQuota = ulEffectiveQuota;
				pEffectiveQuotaNew->pEffectiveQuotaNext = NULL;
				}

			if ( NULL == InterlockedCompareExchangePointer( ppEffectiveQuota, pEffectiveQuotaNew, NULL ) )
				{
				//	successfully added to the list, so reset
				//	local pointer so we won't free it on exit
				//
				pEffectiveQuotaNew = NULL;
				fAddedToCache = TRUE;
				}
			else
				{
				//	someone modified the list from underneath us, so we need to
				//	rescan the list and see if someone also beat us to the insertion
				//	of the effective quota for this NC
				}
			}
		}

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

HandleError:
	if ( NULL != pEffectiveQuotaNew )
		{
		free( pEffectiveQuotaNew );
		}

	return pTHS->errCode;
	}


//	determine the sid of the current user
//
//	QUOTA_UNDONE: surely there's gotta be existing functionality to do this??
//
INT ErrQuotaGetUserToken_(
	THSTATE *					pTHS,
	PTOKEN_USER					pTokenUser )
	{
	DWORD						err;
	AUTHZ_CLIENT_CONTEXT_HANDLE	hAuthzClientContext;
	ULONG						cbTokenUser		= sizeof(TOKEN_USER) + sizeof(NT4SID);

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	get our context handle
	//
	err = GetAuthzContextHandle( pTHS, &hAuthzClientContext );
	if ( 0 != err )
		{
		DPRINT2(
			0,
			"GetAuthzContextHandle failed with error %d (0x%x).\n",
			err,
			err );
		SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE, err );
		goto HandleError;
		}

	//	fetch the user
	//
	if ( !AuthzGetInformationFromContext(
						hAuthzClientContext,
						AuthzContextInfoUserSid,
						cbTokenUser,
						&cbTokenUser,
						pTokenUser ) )
		{
		err = GetLastError();
		DPRINT2( 0, "AuthzGetInformationFromContext failed with error %d (0x%x).\n", err, err );
		SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, err );
		goto HandleError;
		}
	Assert( cbTokenUser <= sizeof(TOKEN_USER) + sizeof(NT4SID) );

HandleError:
	return pTHS->errCode;
	}


//	determine the transitive group membership of the specified user
//
//	QUOTA_UNDONE: surely there's gotta be existing functionality to do this??
//
INT ErrQuotaGetUserGroups_(
	THSTATE *					pTHS,
	PSID						pUserSid,
	const ULONG					cbUserSid,
	const BOOL					fSidMatchesUserSidInToken,
	PTOKEN_GROUPS *				ppGroups )
	{
	DWORD						err;
	AUTHZ_CLIENT_CONTEXT_HANDLE	hAuthzClientContext		= NULL;
    PTOKEN_GROUPS				pGroups					= NULL;
    ULONG						cbGroups;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	if ( fSidMatchesUserSidInToken )
		{
		//	we should have already previously verified that the
		//	specified user sid matches the user in the token
		//
		Assert( ERROR_SUCCESS == SidMatchesUserSidInToken( pUserSid, cbUserSid, (BOOL *)&err ) );
		Assert( err );

		err = GetAuthzContextHandle( pTHS, &hAuthzClientContext );
		if ( 0 != err )
			{
			DPRINT2(
				0,
				"GetAuthzContextHandle failed with error %d (0x%x).\n",
				err,
				err );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE, err );
			goto HandleError;
			}
		}
	else
		{
		LUID	luidFake	= { 0, 0 };			//	currently unsupported, but needed as a param

		//	user sid doesn't match user sid in token, so must create a client
		//	context for the specified user sid
		//
		//	QUOTA_UNDONE: I think this may go off-machine, so do I need to
		//	end the current transaction first and restart a new one after?
		//
		Assert( NULL != ghAuthzRM );
		if ( !AuthzInitializeContextFromSid(
						0,			//	flags
						pUserSid,
						ghAuthzRM,
						NULL,		//	token expiration time
						luidFake,	//	identifier [unused]
						NULL,		//	dynamic groups callback
						&hAuthzClientContext ) )
			{
			err = GetLastError();
			DPRINT2(
				0,
				"AuthzInitializeContextFromSid failed with error %d (0x%x).\n",
				err,
				err );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, err );
			goto HandleError;
			}
		}

	//	should now have a client context
	//
	Assert( NULL != hAuthzClientContext );

	//	first call is just to determine the size of the buffer
	//	needed to hold all the groups
	//
	if ( AuthzGetInformationFromContext(
						hAuthzClientContext,
						AuthzContextInfoGroupsSids,
						0,								//	no buffer yet
						&cbGroups,						//	required size of buffer
						NULL ) )						//	buffer
		{
		//	initial call shouldn't succeed
		//
		DPRINT1(
			0,
			"AuthzGetInformationFromContext returned success, expected ERROR_INSUFFICIENT_BUFFER (0x%x).\n",
			ERROR_INSUFFICIENT_BUFFER );
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR );
		goto HandleError;
		}
	else
		{
		err = GetLastError();
		if ( ERROR_INSUFFICIENT_BUFFER != err )
			{
			DPRINT2( 0, "AuthzGetInformationFromContext failed with error %d (0x%x).\n", err, err );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, err );
			goto HandleError;
			}
		}

	//	QUOTA_UNDONE: don't know if it's ever possible to return 0
	//	for the size of the needed TOKEN_GROUPS structure, but handle
	//	it just in case
	//
	if ( cbGroups > 0 )
		{
		//	allocate memory for all the groups
		//	(NOTE: the memory will be freed by the caller)
		//
		pGroups = (PTOKEN_GROUPS)THAllocEx( pTHS, cbGroups );

		//	now that we've allocated a buffer,
		//	really fetch the groups
		//
		if ( !AuthzGetInformationFromContext(
							hAuthzClientContext,
							AuthzContextInfoGroupsSids,
							cbGroups,
							&cbGroups,
							pGroups ) )
			{
			err = GetLastError();
			DPRINT2( 0, "AuthzGetInformationFromContext failed with error %d (0x%x).\n", err, err );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, err );
			goto HandleError;
			}
		}

	//	transfer ownership to caller (who
	//	will now be responsible for freeing
	//	this memory)
	//
	*ppGroups = pGroups;
	pGroups = NULL;

HandleError:
	if ( NULL != pGroups )
		{
		//	only way to get here is if we err'd out
		//	after allocating the memory but before
		//	transferring ownership to the caller
		//
		Assert( ERROR_SUCCESS != pTHS->errCode );
		THFreeEx( pTHS, pGroups );
		}

	//	free AuthzClientContext handle if necessary
	//
	if ( !fSidMatchesUserSidInToken
		&& NULL != hAuthzClientContext )
		{
		if ( !AuthzFreeContext( hAuthzClientContext )
			&& ERROR_SUCCESS == pTHS->errCode )
			{
			//	only trap the error from freeing the
			//	AuthzClientContext handle if no other
			//	errors were encountered
			//
			err = GetLastError();
			DPRINT2( 0, "AuthzFreeContext failed with error %d (0x%x).\n", err, err );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, err );
			}
		}

	return pTHS->errCode;
	}


//	search for all objects in the specified Quotas container
//	for the specified user and groups
//
INT ErrQuotaSearchContainer_(
	THSTATE *		pTHS,
	DSNAME *		pNtdsQuotasContainer,
	PSID			pOwnerSid,
	const ULONG		cbOwnerSid,
	PTOKEN_GROUPS	pGroups,
	SEARCHRES *		pSearchRes )
	{
	DBPOS *			pDBSave;
	BOOL			fDSASave;
	SEARCHARG		SearchArg;
	ENTINFSEL		Selection;
	ATTR			Attr;
	FILTER			Filter;
	FILTER			UserFilter;
	PFILTER			pGroupFilters		= NULL;
	PFILTER			pFilterCurr;
	ULONG			i;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	verify we have a container to search
	//
	Assert( NULL != pNtdsQuotasContainer );

	//	initialise search criteria
	//
	memset( &SearchArg, 0, sizeof(SearchArg) );
	SearchArg.pObject = pNtdsQuotasContainer;
	SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
	SearchArg.bOneNC = TRUE;
	SearchArg.pSelection = &Selection;
	SearchArg.pFilter = &Filter;
	InitCommarg( &SearchArg.CommArg );

	//	set up to retrieve just one attribute
	//
	Selection.attSel = EN_ATTSET_LIST;
	Selection.infoTypes = EN_INFOTYPES_TYPES_VALS;
	Selection.AttrTypBlock.attrCount = 1;
	Selection.AttrTypBlock.pAttr = &Attr;

	//	set up to retrieve ATT_MS_DS_QUOTA_AMOUNT
	//
	Attr.attrTyp = ATT_MS_DS_QUOTA_AMOUNT;
	Attr.AttrVal.valCount = 0;
	Attr.AttrVal.pAVal = NULL;

	//	set up filter for the user
	//
	Filter.pNextFilter = NULL;
	Filter.choice = FILTER_CHOICE_OR;
	Filter.FilterTypes.Or.count = 1;
	Filter.FilterTypes.Or.pFirstFilter = &UserFilter;

	memset( &UserFilter, 0, sizeof(UserFilter) );
	UserFilter.pNextFilter = NULL;
	UserFilter.choice = FILTER_CHOICE_ITEM;
	UserFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
	UserFilter.FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_QUOTA_TRUSTEE;
	UserFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = cbOwnerSid;
	UserFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = pOwnerSid;

	//	set up filters for the groups
	//
	if ( NULL != pGroups && pGroups->GroupCount > 0 )
		{
		pGroupFilters = (PFILTER)THAllocEx( pTHS, sizeof(FILTER) * pGroups->GroupCount );
		UserFilter.pNextFilter = pGroupFilters;

		for ( i = 0; i < pGroups->GroupCount; i++ )
			{
			Assert( IsValidSid( pGroups->Groups[i].Sid ) );

			Filter.FilterTypes.Or.count++;

			pFilterCurr = pGroupFilters + i;
			pFilterCurr->pNextFilter = pFilterCurr + 1;
			pFilterCurr->choice = FILTER_CHOICE_ITEM;
			pFilterCurr->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
			pFilterCurr->FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_QUOTA_TRUSTEE;
			pFilterCurr->FilterTypes.Item.FilTypes.ava.Value.valLen = GetLengthSid( pGroups->Groups[i].Sid );
			pFilterCurr->FilterTypes.Item.FilTypes.ava.Value.pVal = pGroups->Groups[i].Sid;
			}

		//	fix up last pointer to terminate the list
		//
		Assert( pFilterCurr == pGroupFilters + pGroups->GroupCount - 1 );
		pFilterCurr->pNextFilter = NULL;
		}

	//	save off current DBPOS and fDSA
	//
	pDBSave = pTHS->pDB;
	fDSASave = pTHS->fDSA;

	//	set fDSA to ensure security checks
	//	don't get in our way
	//
	pTHS->pDB = NULL;
    pTHS->fDSA = TRUE;

	__try
		{
		//	open a new DBPOS for the search
		//
		DBOpen( &pTHS->pDB );
		Assert( NULL != pTHS->pDB );

		//	now do the actual query
		//
		SearchBody( pTHS, &SearchArg, pSearchRes, 0 );
		}
	__finally
		{
		if ( NULL != pTHS->pDB )
			{
			//	only doing a search, so should be safe to always commit
			//
			DBClose( pTHS->pDB, TRUE );
			}

		//	reinstate original DBPOS and fDSA
		//
		pTHS->pDB = pDBSave;
		pTHS->fDSA = fDSASave;

		if ( NULL != pGroupFilters )
			{
			THFreeEx( pTHS, pGroupFilters );
			}
		}

	return pTHS->errCode;
	}


//	compute the effective quota for the specified security principle
//	by performing expensive query of the Quotas container
//
INT ErrQuotaComputeEffectiveQuota_(
	THSTATE *					pTHS,
	const DWORD					ncdnt,
	PSID						pOwnerSid,
	const ULONG					cbOwnerSid,
	const BOOL					fUserIsOwner,
	ULONG *						pulEffectiveQuota )
	{
	ULONG						ulEffectiveQuota	= 0;
	NAMING_CONTEXT_LIST *		pNCL;
    PTOKEN_GROUPS				pGroups				= NULL;
	SEARCHRES					SearchRes;
	ENTINFLIST *				pentinflistCurr;
	ULONG						ulQuotaCurr;
	ULONG						i;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	initialise results of container search
	//
	memset( &SearchRes, 0, sizeof(SearchRes) );

	//	retrieve NCL for this ncdnt
	//
	pNCL = FindNCLFromNCDNT( ncdnt, TRUE );
	if ( NULL == pNCL )
		{
		//	something is horribly wrong, this NCDNT is not in Master NCL
		//
		DPRINT2(
			0,
			"Couldn't find NCDNT %d (0x%x) in Master Naming Context List.\n",
			ncdnt,
			ncdnt );
		Assert( !"Couldn't find NCDNT in Master NCL." );
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE );
		goto HandleError;
		}

	//	before we search it, must determine if
	//	the Quotas container even exists
	//
	if ( NULL == pNCL->pNtdsQuotasDN )
		{
		//	Quotas container may not exist for
		//	certain NC's (eg. schema) or if
		//	this is a legacy database
		//
		Assert( 0 == SearchRes.count );
		}

	//	retrieve transitive group membership for
	//	the object owner
	//
	else if ( ErrQuotaGetUserGroups_(
						pTHS,
						pOwnerSid,
						cbOwnerSid,
						fUserIsOwner,
						&pGroups ) )
		{
		DPRINT( 0, "Failed retrieving user groups in order to compute effective quota.\n" );
		goto HandleError;
		}

	//	search for all objects in the appropriate
	//	NTDS Quotas container for this user
	//	(including transitive group membership)
	//
	else if ( ErrQuotaSearchContainer_(
						pTHS,
						pNCL->pNtdsQuotasDN,
						pOwnerSid,
						cbOwnerSid,
						pGroups,
						&SearchRes ) )
		{
		DPRINT2(
			0,
			"Failed searching Quotas container of ncdnt %d (0x%x).\n",
			ncdnt,
			ncdnt )
		goto HandleError;
		}

	//	process result set, if any
	//
	if ( 0 == SearchRes.count )
		{
		//	no specific quotas, so use default quota for this NC
		//
		ulEffectiveQuota = pNCL->ulDefaultQuota;
		Assert( ulEffectiveQuota >= 0 );
		}
	else
		{
		//	can have at most one record for the user and for each group
		//
		Assert( NULL != pGroups ?
					SearchRes.count <= pGroups->GroupCount + 1 :
					1 == SearchRes.count );
		for ( pentinflistCurr = &SearchRes.FirstEntInf, i = 0;
			i < SearchRes.count;
			pentinflistCurr = pentinflistCurr->pNextEntInf, i++ )
			{
			//	count indicates there should be another element in the list
			//
			Assert( NULL != pentinflistCurr );

			//	we only requested one attribute to be returned
			//
			Assert( 1 == pentinflistCurr->Entinf.AttrBlock.attrCount );

			//	we only requested the quota attribute to be returned
			//
			Assert( ATT_MS_DS_QUOTA_AMOUNT == pentinflistCurr->Entinf.AttrBlock.pAttr->attrTyp );

			//	this attribute should be single-valued
			//
			Assert( 1 == pentinflistCurr->Entinf.AttrBlock.pAttr->AttrVal.valCount );

			//	this attribute must be a dword
			//
			Assert( sizeof(DWORD) == pentinflistCurr->Entinf.AttrBlock.pAttr->AttrVal.pAVal->valLen );

			//	effective quota is the maximum of all the quotas
			//	this user is subject to
			//
			ulQuotaCurr = *(ULONG *)( pentinflistCurr->Entinf.AttrBlock.pAttr->AttrVal.pAVal->pVal );
			if ( ulQuotaCurr > ulEffectiveQuota )
				{
				ulEffectiveQuota = ulQuotaCurr;
				}
			}

		//	verify count matches actual list
		//
		Assert( NULL == pentinflistCurr );
		}
	
	*pulEffectiveQuota = ulEffectiveQuota;

HandleError:
	if ( NULL != pGroups )
		{
		THFreeEx( pTHS, pGroups );
		}

	return pTHS->errCode;
	}


//	get the effective quota for the specified security principle
//
INT ErrQuotaGetEffectiveQuota_(
	THSTATE *						pTHS,
	const DWORD						ncdnt,
	PSID							pOwnerSid,
	const ULONG						cbOwnerSid,
	const BOOL						fPermitBypassQuotaIfUserDoesntMatchOwner,
	ULONG *							pulEffectiveQuota )
	{
	DWORD							err;
	ULONG							ulEffectiveQuota;
	PEFFECTIVE_QUOTA				pEffectiveQuota;
	PAUTHZ_CLIENT_CONTEXT_INFO		pAuthzContextInfo	= NULL;
	BOOL							fUserIsOwner		= FALSE;
	BOOL							fBypassQuota		= FALSE;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	if ( !gAnchor.fQuotaTableReady )
		{
		//	if Quota table is still being rebuilt,
		//	then quota will not be enforced
		//
		fBypassQuota = TRUE;
		}

	else if ( fPermitBypassQuotaIfUserDoesntMatchOwner
		&& ( pTHS->fDRA || pTHS->fDSA ) )
		{
		//	internal operation, so bypass quota enforement
		//
		fBypassQuota = TRUE;
		}
	else
		{
		//	only enforce quota if the user sid matches the
		//	owner sid of the object (the rationale being
		//	if they don't match, then the user likely
		//	has high enough privilege that they'd want
		//	quota to be ignored
		//
		//	QUOTA_UNDONE: the real reason we don't enforce
		//	quota if the user sid doesn't match the owner
		//	sid is because it's a huge pain to calculate
		//	transitive group membership for the owner sid)
		//
		err = SidMatchesUserSidInToken(
						pOwnerSid,
						cbOwnerSid,
						&fUserIsOwner );
		if ( 0 != err )
			{
			DPRINT2( 0, "SidMatchesUserSidInToken failed with error %d (0x%x).\n", err, err );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, err );
			goto HandleError;
			}

		//	if user is not owner, then bypass quota if permitted
		//
		if ( !fUserIsOwner && fPermitBypassQuotaIfUserDoesntMatchOwner )
			{
			fBypassQuota = TRUE;
			}
		}

	if ( fBypassQuota )
		{
		//	the way we bypass enforcing quota is to set the
		//	quota to the maximum theoretical possible value,
		//	which will allow us to succeed any subsequent
		//	quota checks
		//
		ulEffectiveQuota = g_ulQuotaUnlimited;
		}
	else if ( fUserIsOwner )
		{
		err = GetAuthzContextInfo( pTHS, &pAuthzContextInfo );
		if ( 0 != err )
			{
			//	couldn't obtain client context info
			//
			DPRINT2( 0, "GetAuthzContextInfo failed with error %d (0x%x).\n", err, err );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE, err );
			goto HandleError;
			}

		//	see if effective quota for this NC is cached for this user
		//
		for ( pEffectiveQuota = pAuthzContextInfo->pEffectiveQuota;
			NULL != pEffectiveQuota && ncdnt != pEffectiveQuota->ncdnt;
			pEffectiveQuota = pEffectiveQuota->pEffectiveQuotaNext )
			{
			NULL;
			}

		if ( NULL != pEffectiveQuota )
			{
			//	use cached effective quota
			//
			ulEffectiveQuota = pEffectiveQuota->ulEffectiveQuota;
			}
		else
			{
			//	this NC is not currently cached, so must perform expensive
			//	effective quota calculation
			//
			if ( ErrQuotaComputeEffectiveQuota_( pTHS, ncdnt, pOwnerSid, cbOwnerSid, TRUE, &ulEffectiveQuota ) )
				{
				DPRINT( 0, "Failed computing effective quota (user is owner).\n" );
				goto HandleError;
				}

			//	add to cache of effective quotas
			//
			else if ( ErrQuotaAddToCache_( pTHS, ncdnt, ulEffectiveQuota ) )
				{
				DPRINT( 0, "Failed caching effective quota.\n" );
				goto HandleError;
				}
			}
		}
	else
		{
		//	user doesn't match owner, so effective quota won't be cached anywhere,
		//	so must compute it
		//
		if ( ErrQuotaComputeEffectiveQuota_( pTHS, ncdnt, pOwnerSid, cbOwnerSid, FALSE, &ulEffectiveQuota ) )
			{
			DPRINT( 0, "Failed computing effective quota (user is NOT owner).\n" );
			goto HandleError;
			}
		}

	*pulEffectiveQuota = ulEffectiveQuota;

HandleError:
	return pTHS->errCode;
	}


//	find the record in the Quota table corresponding to the
//	specified security principle
//
BOOL FQuotaSeekOwner_(
	JET_SESID		sesid,
	JET_TABLEID		tableidQuota,
	DWORD			ncdnt,
	PSID			pOwnerSid,
	const ULONG		cbOwnerSid )
	{
	JET_ERR			err;

	JetMakeKeyEx(
			sesid,
			tableidQuota,
			&ncdnt,
			sizeof(ncdnt),
			JET_bitNewKey );
	JetMakeKeyEx(
			sesid,
			tableidQuota,
			pOwnerSid,
			cbOwnerSid,
			NO_GRBIT );
	err = JetSeekEx(
			sesid,
			tableidQuota,
			JET_bitSeekEQ );

	Assert( JET_errSuccess == err || JET_errRecordNotFound == err );
	return ( JET_errSuccess == err );
	}


//	compute total consumed quota, factoring in 
//	the weight of tombstoned objects
//
__inline ULONG UlQuotaTotalWeighted_(
	const ULONG				cLive,
	const ULONG				cTombstoned,
	const ULONG				ulTombstonedWeight )
	{
    // weighted total is rounded up to the nearest integer
    //
	return ( cLive
			+ ( 100 == ulTombstonedWeight ?		//	optimise for 100%, which is the default
					cTombstoned :
					(ULONG)( ( ( (ULONGLONG)cTombstoned * (ULONGLONG)ulTombstonedWeight ) + 99 ) / 100 ) ) );
	}


//	determine whether the specified number of
//	tombstoned and live objects would result
//	in a violation of quota constraints
//
INT ErrQuotaEnforce_(
	THSTATE *				pTHS,
	const DWORD				ncdnt,
	const ULONG				cTotal,
	const ULONG				cTombstoned,
	const ULONG				ulEffectiveQuota )
	{
	const ULONG				cLive			= cTotal - cTombstoned;		//	derive count of live objects
	ULONG					cTotalWeighted;
	NAMING_CONTEXT_LIST *	pNCL;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	in the common case, the quota will likely be
	//	unlimited, so lets optimise for that case
	//
	if ( g_ulQuotaUnlimited == ulEffectiveQuota )
		{
		return ERROR_SUCCESS;
		}

	//	counts should have been prevalidated
	//	relative to each other
	//
	Assert( cTombstoned <= cTotal );

	//	find NCL entry for the specified NCDNT, 'cause that's where
	//	the tombstone weight for each NC is stored
	//
	pNCL = FindNCLFromNCDNT( ncdnt, TRUE );
	if ( NULL == pNCL )
		{
		//	something is horribly wrong, this NCDNT is not in Master NCL
		//
		DPRINT2(
			0,
			"Couldn't find NCDNT %d (0x%x) in Master Naming Context List.\n",
			ncdnt,
			ncdnt );
		Assert( !"Couldn't find NCDNT in Master NCL." );
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE );
		goto HandleError;
		}

	//	compute weighted total
	//
	cTotalWeighted = UlQuotaTotalWeighted_( cLive, cTombstoned, pNCL->ulTombstonedQuotaWeight );

	if ( cTotalWeighted > ulEffectiveQuota )
		{
		//	quota exceeded, so must err out appropriately
		//	(any escrow update will be rolled-back when transaction
		//	is rolled back)
		//
		Assert( !pTHS->fDRA );
		Assert( !pTHS->fDSA );
		DPRINT( 0, "Object quota limit exceeded.\n" );
		SetSvcError( SV_PROBLEM_ADMIN_LIMIT_EXCEEDED, STATUS_QUOTA_EXCEEDED );
		goto HandleError;
		}

HandleError:
	return pTHS->errCode;
	}


//	inserts a new record into the Quota table for
//	the specified security principle (NCDNT+OwnerSID)
//
INT ErrQuotaAddSecurityPrinciple_(
	DBPOS * const	pDB,
	JET_TABLEID		tableidQuota,
	DWORD			ncdnt,
	PSID			pOwnerSid,
	const ULONG		cbOwnerSid,
	const ULONG		ulEffectiveQuota,
	const BOOL		fIsTombstoned )
	{
	THSTATE * const	pTHS			= pDB->pTHS;
	JET_SESID		sesid			= pDB->JetSessID;
	JET_SETCOLUMN	rgsetcol[2];

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	set up JET_SETCOLUMN structures for new record
	//
	memset( rgsetcol, 0, sizeof(rgsetcol) );

	rgsetcol[0].columnid = g_columnidQuotaNcdnt;
	rgsetcol[0].pvData = &ncdnt;
	rgsetcol[0].cbData = sizeof(ncdnt);

	rgsetcol[1].columnid = g_columnidQuotaSid;
	rgsetcol[1].pvData = pOwnerSid;
	rgsetcol[1].cbData = cbOwnerSid;

	//	add new quota record for this security principle
	//	(its initial total will automatically be set to 1,
	//	so no need to perform escrow update)
	//
	JetPrepareUpdateEx(
				sesid,
				tableidQuota,
				JET_prepInsert );
	JetSetColumnsEx(
				sesid,
				tableidQuota,
				rgsetcol,
				sizeof(rgsetcol) / sizeof(rgsetcol[0]) );

	if ( fIsTombstoned )
		{
		LONG	lDelta	= 1;

		//	adding tombstoned object, so must
		//	update tombstoned count as well
		//
		JetSetColumnEx(
				sesid,
				tableidQuota,
				g_columnidQuotaTombstoned,
				&lDelta,
				sizeof(lDelta),
				NO_GRBIT,
				NULL );		//	&setinfo
		}

	//	NOTE: if someone beat us to it, the call
	//	to JetUpdate will return JET_errKeyDuplicate,
	//	which will raise an exception and we will
	//	end up retrying at a higher level
	//
	JetUpdateEx(
			sesid,
			tableidQuota,
			NULL,		//	pvBookmark
			0,			//	cbBookmark
			NULL );		//	&cbBookmarkActual

	//	only way quota validation would fail here
	//	is if this security principle wasn't even
	//	allowed to add a single object
	//
	if ( ErrQuotaEnforce_(
				pTHS,
				ncdnt,
				1,			//	this is the first object added for this security principle
				( fIsTombstoned ? 1 : 0 ),
				ulEffectiveQuota ) )
		{
		DPRINT( 0, "Failed validating effective quota for object insertion.\n" );
		goto HandleError;
		}

HandleError:
	return pTHS->errCode;
	}


//	for the current security principle, update the
//	total object count and verify that the effective
//	quote is not exceeded
//
INT ErrQuotaAddObject_(
	DBPOS * const	pDB,
	JET_TABLEID		tableidQuota,
	const DWORD		ncdnt,
	const ULONG		ulEffectiveQuota,
	const BOOL		fIsTombstoned )
	{
	THSTATE * const	pTHS			= pDB->pTHS;
	JET_SESID		sesid			= pDB->JetSessID;
	LONG			lDelta			= 1;
	ULONG			cLive;
	ULONG			cTombstonedOld;
	ULONG			cTotalOld;
	ULONG			cTotalWeighted;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	increment total count to reflect
	//	addition of object
	//
	JetEscrowUpdateEx(
			sesid,
			tableidQuota,
			g_columnidQuotaTotal,
			&lDelta,
			sizeof(lDelta),
			&cTotalOld,
			sizeof(cTotalOld),
			NULL,			//	&cbOldActual
			NO_GRBIT );

	if ( fIsTombstoned )
		{
		//	adding tombstoned object, so must
		//	update tombstoned count as well
		//
		JetEscrowUpdateEx(
				sesid,
				tableidQuota,
				g_columnidQuotaTombstoned,
				&lDelta,
				sizeof(lDelta),
				&cTombstonedOld,
				sizeof(cTombstonedOld),
				NULL,			//	&cbOldActual
				NO_GRBIT );
		}
	else
		{
		//	retrieve tombstoned count so that we can
		//	compute whether we've exceeded the
		//	effective quota
		//
		JetRetrieveColumnSuccess(
				sesid,
				tableidQuota,
				g_columnidQuotaTombstoned,
				&cTombstonedOld,
				sizeof(cTombstonedOld),
				NULL,			//	&cbActual
				NO_GRBIT,
				NULL );			//	&retinfo
		}

	//	verify valid quota counts
	//
	if ( cTombstonedOld > cTotalOld )
		{
		DPRINT2(
			0,
			"Corruption in Quota table: tombstoned count (0x%x) exceeds total count (0x%x).\n",
			cTombstonedOld,
			cTotalOld );
		Assert( !"Corruption in Quota table: tombstoned count exceeds total count." );

	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_QUOTA_CORRUPT_COUNTS,
			szInsertUL( ncdnt ),
			szInsertUL( cTombstonedOld ),
			szInsertUL( cTotalOld ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#endif

		goto HandleError;
		}

	else if ( ErrQuotaEnforce_(
				pTHS,
				ncdnt,
				cTotalOld + 1,
				cTombstonedOld + ( fIsTombstoned ? 1 : 0 ),
				ulEffectiveQuota ) )
		{
		DPRINT( 0, "Failed validating effective quota for object insertion.\n" );
		goto HandleError;
		}
	
HandleError:
	return pTHS->errCode;
	}


//	update quota for tombstoned object
//
INT ErrQuotaTombstoneObject_(
	DBPOS * const		pDB,
	JET_TABLEID			tableidQuota,
	const DWORD			ncdnt )
	{
	THSTATE * const		pTHS			= pDB->pTHS;
	JET_SESID			sesid			= pDB->JetSessID;
	LONG				lDelta			= 1;
	ULONG				cTombstonedOld;
	ULONG				cTotal;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	increment tombstone count to reflect
	//	tombstoning of object
	//
	JetEscrowUpdateEx(
			sesid,
			tableidQuota,
			g_columnidQuotaTombstoned,
			&lDelta,
			sizeof(lDelta),
			&cTombstonedOld,
			sizeof(cTombstonedOld),
			NULL,			//	&cbOldActual
			NO_GRBIT );

	JetRetrieveColumnSuccess(
			sesid,
			tableidQuota,
			g_columnidQuotaTotal,
			&cTotal,
			sizeof(cTotal),
			NULL,			//	&cbActual
			NO_GRBIT,
			NULL );			//	&retinfo

	//	verify valid quota counts
	//
	if ( cTombstonedOld >= cTotal )
		{
		DPRINT2(
			0,
			"Corruption in Quota table: tombstoned count (0x%x) exceeds total count (0x%x).\n",
			cTombstonedOld + 1,
			cTotal );
		Assert( !"Corruption in Quota table: tombstoned count exceeds total count." );

	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_QUOTA_CORRUPT_COUNTS,
			szInsertUL( ncdnt ),
			szInsertUL( cTombstonedOld ),
			szInsertUL( cTotal ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#endif

		goto HandleError;
		}

HandleError:
	return pTHS->errCode;
	}


//	update quota for deleted object
//
INT ErrQuotaDeleteObject_(
	DBPOS * const		pDB,
	JET_TABLEID			tableidQuota,
	const DWORD			ncdnt,
	const BOOL			fIsTombstoned )
	{
	THSTATE * const		pTHS			= pDB->pTHS;
	JET_SESID			sesid			= pDB->JetSessID;
	LONG				lDelta			= -1;
	ULONG				cTombstonedOld;
	ULONG				cTotalOld;
	ULONG				cLive;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	if object was tombstoned, decrement
	//	tombstoned count
	//
	if ( fIsTombstoned )
		{
		JetEscrowUpdateEx(
				sesid,
				tableidQuota,
				g_columnidQuotaTombstoned,
				&lDelta,
				sizeof(lDelta),
				&cTombstonedOld,
				sizeof(cTombstonedOld),
				NULL,			//	&cbOldActual
				NO_GRBIT );

		if ( cTombstonedOld < 1 )
			{
			DPRINT1(
				0,
				"Corruption in Quota table: tombstoned count (0x%x) is invalid.\n",
				cTombstonedOld );
			Assert( !"Corruption in Quota table: tombstoned count is invalid." );

			JetRetrieveColumnSuccess(
					sesid,
					tableidQuota,
					g_columnidQuotaTotal,
					&cTotalOld,
					sizeof(cTotalOld),
					NULL,		//	&cbActual
					NO_GRBIT,
					NULL );		//	&retinfo
		    LogEvent(
				DS_EVENT_CAT_INTERNAL_PROCESSING,
				DS_EVENT_SEV_ALWAYS,
				DIRLOG_QUOTA_CORRUPT_TOMBSTONED_COUNT,
				szInsertUL( ncdnt ),
				szInsertUL( cTombstonedOld ),
				szInsertUL( cTotalOld ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
			SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );

			goto HandleError;
#else
			//	undo escrow update to bring count back to zero
			//
			lDelta = 1;
			JetEscrowUpdateEx(
					sesid,
					tableidQuota,
					g_columnidQuotaTombstoned,
					&lDelta,
					sizeof(lDelta),
					&cTombstonedOld,
					sizeof(cTombstonedOld),
					NULL,			//	&cbOldActual
					NO_GRBIT );

			//	despite this error, continue on and update total count
			//
#endif
			}
		}
	else
		{
		JetRetrieveColumnSuccess(
				sesid,
				tableidQuota,
				g_columnidQuotaTombstoned,
				&cTombstonedOld,
				sizeof(cTombstonedOld),
				NULL,		//	&cbActual
				NO_GRBIT,
				NULL );		//	&retinfo
		}

	//	decrement total count to reflect object deletion
	//
	JetEscrowUpdateEx(
			sesid,
			tableidQuota,
			g_columnidQuotaTotal,
			&lDelta,
			sizeof(lDelta),
			&cTotalOld,
			sizeof(cTotalOld),
			NULL,			//	&cbOldActual
			NO_GRBIT );

	//	verify valid quota counts
	//
	if ( cTotalOld < 1 )
		{
		DPRINT1(
			0,
			"Corruption in Quota table: total count (0x%x) is invalid.\n",
			cTotalOld );
		Assert( !"Corruption in Quota table: total count is invalid." );

	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_QUOTA_CORRUPT_TOTAL_COUNT,
			szInsertUL( ncdnt ),
			szInsertUL( cTombstonedOld ),
			szInsertUL( cTotalOld ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#else
		//	undo escrow update to bring count back to zero
		//
		lDelta = 1;
		JetEscrowUpdateEx(
				sesid,
				tableidQuota,
				g_columnidQuotaTotal,
				&lDelta,
				sizeof(lDelta),
				&cTotalOld,
				sizeof(cTotalOld),
				NULL,			//	&cbOldActual
				NO_GRBIT );
#endif

		goto HandleError;
		}

	else if ( cTombstonedOld > cTotalOld )
		{
		DPRINT2(
			0,
			"Corruption in Quota table: tombstoned count (0x%x) exceeds total count (0x%x).\n",
			cTombstonedOld,
			cTotalOld );
		Assert( !"Corruption in Quota table: tombstoned count exceeds total count." );

	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_QUOTA_CORRUPT_COUNTS,
			szInsertUL( ncdnt ),
			szInsertUL( cTombstonedOld ),
			szInsertUL( cTotalOld ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#endif

		goto HandleError;
		}

HandleError:
	return pTHS->errCode;
	}


//	update quota for resurrected object
//
INT ErrQuotaResurrectObject_(
	DBPOS * const	pDB,
	JET_TABLEID		tableidQuota,
	const DWORD		ncdnt,
	const ULONG		ulEffectiveQuota )
	{
	THSTATE * const	pTHS			= pDB->pTHS;
	JET_SESID		sesid			= pDB->JetSessID;
	LONG			lDelta			= -1;
	ULONG			cTombstonedOld;
	ULONG			cTotal;
	ULONG			cLive;

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	retrieve total count so we can recompute whether
	//	resurrecting would exceed the effective quota
	//
	JetRetrieveColumnSuccess(
			sesid,
			tableidQuota,
			g_columnidQuotaTotal,
			&cTotal,
			sizeof(cTotal),
			NULL,			//	&cbActual
			NO_GRBIT,
			NULL );			//	&retinfo

	//	decrement tombstoned count to reflect
	//	object resurrection
	//
	JetEscrowUpdateEx(
			sesid,
			tableidQuota,
			g_columnidQuotaTombstoned,
			&lDelta,
			sizeof(lDelta),
			&cTombstonedOld,
			sizeof(cTombstonedOld),
			NULL,			//	&cbOldActual
			NO_GRBIT );

	//	verify valid quota counts
	//
	if ( cTombstonedOld < 1 )
		{
		DPRINT1(
			0,
			"Corruption in Quota table: tombstoned count (0x%x) is invalid.\n",
			cTombstonedOld );
		Assert( !"Corruption in Quota table: tombstoned count is invalid." );

	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_QUOTA_CORRUPT_TOMBSTONED_COUNT,
			szInsertUL( ncdnt ),
			szInsertUL( cTombstonedOld ),
			szInsertUL( cTotal ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#else
		//	undo escrow update to bring count back to zero
		//
		lDelta = 1;
		JetEscrowUpdateEx(
				sesid,
				tableidQuota,
				g_columnidQuotaTombstoned,
				&lDelta,
				sizeof(lDelta),
				&cTombstonedOld,
				sizeof(cTombstonedOld),
				NULL,			//	&cbOldActual
				NO_GRBIT );
#endif

		goto HandleError;
		}

	else if ( cTombstonedOld > cTotal )
		{
		DPRINT2(
			0,
			"Corruption in Quota table: tombstoned count (0x%x) exceeds total count (0x%x).\n",
			cTombstonedOld,
			cTotal );
		Assert( !"Corruption in Quota table: tombstoned count exceeds total count." );

	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_QUOTA_CORRUPT_COUNTS,
			szInsertUL( ncdnt ),
			szInsertUL( cTombstonedOld ),
			szInsertUL( cTotal ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
		SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#endif

		goto HandleError;
		}

	if ( ErrQuotaEnforce_( pTHS, ncdnt, cTotal, cTombstonedOld - 1, ulEffectiveQuota ) )
		{
		DPRINT( 0, "Failed validating quota for object resurrection.\n" );
		goto HandleError;
		};

HandleError:
	return pTHS->errCode;
	}


//	scan Quota table for records for specified direction
//	partition and copy them to a temp table
//
INT ErrQuotaBuildTopUsageTable_(
	DBPOS * const			pDB,
	DWORD					ncdnt,
	JET_TABLEID				tableidQuota,
	JET_TABLEID				tableidTopUsage,
	JET_COLUMNID *			rgcolumnidTopUsage,
	ULONG *					pcRecords )
	{
	JET_ERR					err;
	THSTATE * const			pTHS					= pDB->pTHS;
	JET_SESID				sesid					= pDB->JetSessID;
	NAMING_CONTEXT_LIST *	pNCL					= NULL;
	DWORD					ncdntLast				= 0;
	BYTE					rgbSid[sizeof(NT4SID)];
	ULONG					cTombstoned;
	ULONG					cLive;
	ULONG					cTotal;
	ULONG					cWeightedTotal;
	const ULONG				iretcolNcdnt			= 0;
	const ULONG				iretcolSid				= 1;
	const ULONG				iretcolTombstoned		= 2;
	const ULONG				iretcolTotal			= 3;
	JET_RETRIEVECOLUMN		rgretcol[4];
	const ULONG				isetcolNcdnt			= 0;
	const ULONG				isetcolSid				= 1;
	const ULONG				isetcolWeightedTotal	= 2;
	const ULONG				isetcolTombstoned		= 3;
	const ULONG				isetcolLive				= 4;
	const ULONG				isetcolDummy			= 5;
	JET_SETCOLUMN			rgsetcol[6];

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	set up structures for JetSet/RetrieveColumns
	//
	memset( rgretcol, 0, sizeof(rgretcol) );
	memset( rgsetcol, 0, sizeof(rgsetcol) );

	//	QUOTA_UNDONE: if only traversing index range (instead of entire table),
	//	we don't really need to retrieve ncdnt
	//
	rgretcol[iretcolNcdnt].columnid = g_columnidQuotaNcdnt;
	rgretcol[iretcolNcdnt].pvData = &ncdnt;
	rgretcol[iretcolNcdnt].cbData = sizeof(ncdnt);
	rgretcol[iretcolNcdnt].itagSequence = 1;

	rgretcol[iretcolSid].columnid = g_columnidQuotaSid;
	rgretcol[iretcolSid].pvData = rgbSid;
	rgretcol[iretcolSid].cbData = sizeof(rgbSid);
	rgretcol[iretcolSid].itagSequence = 1;

	rgretcol[iretcolTombstoned].columnid = g_columnidQuotaTombstoned;
	rgretcol[iretcolTombstoned].pvData = &cTombstoned;
	rgretcol[iretcolTombstoned].cbData = sizeof(cTombstoned);
	rgretcol[iretcolTombstoned].itagSequence = 1;

	rgretcol[iretcolTotal].columnid = g_columnidQuotaTotal;
	rgretcol[iretcolTotal].pvData = &cTotal;
	rgretcol[iretcolTotal].cbData = sizeof(cTotal);
	rgretcol[iretcolTotal].itagSequence = 1;

	rgsetcol[isetcolNcdnt].columnid = rgcolumnidTopUsage[isetcolNcdnt];
	rgsetcol[isetcolNcdnt].pvData = &ncdnt;
	rgsetcol[isetcolNcdnt].cbData = sizeof(ncdnt);

	rgsetcol[isetcolSid].columnid = rgcolumnidTopUsage[isetcolSid];
	rgsetcol[isetcolSid].pvData = rgbSid;
	rgsetcol[isetcolSid].cbData = sizeof(rgbSid);

	rgsetcol[isetcolWeightedTotal].columnid = rgcolumnidTopUsage[isetcolWeightedTotal];
	rgsetcol[isetcolWeightedTotal].pvData = &cWeightedTotal;
	rgsetcol[isetcolWeightedTotal].cbData = sizeof(cWeightedTotal);

	rgsetcol[isetcolTombstoned].columnid = rgcolumnidTopUsage[isetcolTombstoned];
	rgsetcol[isetcolTombstoned].pvData = &cTombstoned;
	rgsetcol[isetcolTombstoned].cbData = sizeof(cTombstoned);

	rgsetcol[isetcolLive].columnid = rgcolumnidTopUsage[isetcolLive];
	rgsetcol[isetcolLive].pvData = &cLive;
	rgsetcol[isetcolLive].cbData = sizeof(cLive);

	rgsetcol[isetcolDummy].columnid = rgcolumnidTopUsage[isetcolDummy];
	rgsetcol[isetcolDummy].pvData = pcRecords;
	rgsetcol[isetcolDummy].cbData = sizeof(*pcRecords);

	if ( 0 == ncdnt )
		{
		//	special-case: compute top quota usage across all directory partitions
		//
		err = JetMoveEx( sesid, tableidQuota, JET_MoveFirst, NO_GRBIT );
		}
	else
		{
		//	compute top quota usage against specified directory partition
		//	by establishing an index range on that directory partition
		//
		JetMakeKeyEx(
				sesid,
				tableidQuota,
				&ncdnt,
				sizeof(ncdnt),
				JET_bitNewKey|JET_bitFullColumnStartLimit );
		err = JetSeekEx(
				sesid,
				tableidQuota,
				JET_bitSeekGT );
		if ( JET_errSuccess == err )
			{
			JetMakeKeyEx(
					sesid,
					tableidQuota,
					&ncdnt,
					sizeof(ncdnt),
					JET_bitNewKey|JET_bitFullColumnEndLimit );
			err = JetSetIndexRangeEx(
					sesid,
					tableidQuota,
					JET_bitRangeUpperLimit );
				
			}
#ifdef DBG
		//	in the pathological case of an empty quota table
		//	(must be because it's being rebuilt) transform
		//	RecordNotFound to NoCurrentRecord purely to 
		//	satisfy asserts below
		//
		else if ( JET_errRecordNotFound == err )
			{
			//	QUOTA_UNDONE: it's remotely possible this
			//	assert could fire if the seek above
			//	initially found the quota table empty but
			//	between then and this assert, the async
			//	quota rebuild task was able to completely
			//	rebuild the table, but I doubt that will
			//	ever happen
			//
			Assert( !gAnchor.fQuotaTableReady );
			err = JET_errNoCurrentRecord;
			}
#endif
		}

	//	the result of our preliminary navigation should always
	//	be either success or no record
	//
	Assert( JET_errSuccess == err || JET_errNoCurrentRecord == err );

	//	traverse the index range and copy each record to the sort
	//
	//	QUOTA_UNDONE: there may be perf problems here if the index
	//	range is really big or we're traversing the entire table
	//	and it's really big
	//
	for ( (*pcRecords) = 0;
		JET_errSuccess == err;
		err = JetMoveEx( sesid, tableidQuota, JET_MoveNext, NO_GRBIT ) )
		{
		//	retrieve record data from the current Quota table record
		//
		JetRetrieveColumnsSuccess(
				sesid,
				tableidQuota,
				rgretcol,
				sizeof(rgretcol) / sizeof(rgretcol[0]) );

		//	validate current counts
		//
		if ( cTombstoned > cTotal )
			{
			DPRINT2(
				0,
				"Corruption in Quota table: tombstoned count (0x%x) exceeds total count (0x%x).\n",
				cTombstoned,
				cTotal );
			Assert( !"Corruption in Quota table: tombstoned count exceeds total count." );

		    LogEvent(
				DS_EVENT_CAT_INTERNAL_PROCESSING,
				DS_EVENT_SEV_ALWAYS,
				DIRLOG_QUOTA_CORRUPT_COUNTS,
				szInsertUL( ncdnt ),
				szInsertUL( cTombstoned ),
				szInsertUL( cTotal ) );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
			SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
			goto HandleError;
#endif
			}

		if ( 0 == cTotal )
			{
			//	ignore records with a count of 0 objects
			//	(Jet should delete those at some point anyway)
			//
			continue;
			}

		//	cache this partition if different from
		//	previous iteration
		//
		Assert( 0 != ncdnt );
		if ( ncdnt != ncdntLast )
			{
			pNCL = FindNCLFromNCDNT( ncdnt, TRUE );
			if ( NULL == pNCL )
				{
				//	something is horribly wrong, this NCDNT is not in Master NCL
				//
				DPRINT2(
					0,
					"Couldn't find NCDNT %d (0x%x) in Master Naming Context List.\n",
					ncdnt,
					ncdnt );
				Assert( !"Couldn't find NCDNT in Master NCL." );
				SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE );
				goto HandleError;
				}

			ncdntLast = ncdnt;
			}

		Assert( NULL != pNCL );

		//	skip partitions without a Quotas container
		//	(this should only happen if 0 was originally
		//	passed in for the ncdnt, so it would be nice
		//	to assert as such, but the variable is
		//	re-used for the current ncdnt, so I can't
		//	without introducing other variables)
		//
		if ( NULL == pNCL->pNtdsQuotasDN )
			{
			continue;
			}

		//	sid is variable size, so adjust accordingly
		//
		rgsetcol[isetcolSid].cbData = rgretcol[isetcolSid].cbActual;

		//	compute data to be put into the sort
		//
		cLive = cTotal - cTombstoned;
		cWeightedTotal = UlQuotaTotalWeighted_(
									cLive,
									cTombstoned,
									pNCL->ulTombstonedQuotaWeight );
		Assert( cWeightedTotal >= 0 );

		//	insert copy of record into our sort
		//
		JetPrepareUpdateEx( sesid, tableidTopUsage, JET_prepInsert );
		JetSetColumnsEx(
				sesid,
				tableidTopUsage,
				rgsetcol,
				sizeof(rgsetcol) / sizeof(rgsetcol[0]) );
		JetUpdateEx( sesid, tableidTopUsage, NULL, 0, NULL );

		(*pcRecords)++;
		}

	Assert( JET_errNoCurrentRecord == err );

HandleError:
	return pTHS->errCode;
	}


//	sort the Top-Usage temp table and export the results
//
INT ErrQuotaBuildTopUsageResults_(
	DBPOS *	const			pDB,
	JET_TABLEID				tableidTopUsage,
	JET_COLUMNID *			rgcolumnidTopUsage,
	const ULONG				cRecords,
	const ULONG				ulRangeStart,
	ULONG * const			pulRangeEnd,	//	IN: max number of entries to return, OUT: index of last entry returned
	ATTR *					pAttr )
	{
	JET_ERR					err;
	THSTATE * const			pTHS					= pDB->pTHS;
	JET_SESID				sesid					= pDB->JetSessID;
	NAMING_CONTEXT_LIST *	pNCL					= NULL;
	DWORD					ncdntLast				= 0;
	ULONG					cRecordsToReturn;
	LONG					imv;
	ATTRVAL *				pAVal					= NULL;
	DWORD					ncdnt;
	BYTE					rgbSid[sizeof(NT4SID)];
	WCHAR					rgchSid[128];			//	QUOTA_UNDONE: everyone seems to hard-code 128 whenever they need a buffer for the Unicode string representation of a SID, so I've done the same
	UNICODE_STRING			usSid					= { 0, sizeof(rgchSid) / sizeof(WCHAR), rgchSid };
	ULONG					cTombstoned;
	ULONG					cLive;
	ULONG					cWeightedTotal;
	const ULONG				iretcolNcdnt			= 0;
	const ULONG				iretcolSid				= 1;
	const ULONG				iretcolWeightedTotal	= 2;
	const ULONG				iretcolTombstoned		= 3;
	const ULONG				iretcolLive				= 4;
	JET_RETRIEVECOLUMN		rgretcol[5];

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	set up structures for JetRetrieveColumns
	//
	memset( rgretcol, 0, sizeof(rgretcol) );

	//	QUOTA_UNDONE: if only traversing index range (instead of entire table),
	//	we don't really need to retrieve ncdnt
	//
	rgretcol[iretcolNcdnt].columnid = rgcolumnidTopUsage[iretcolNcdnt];
	rgretcol[iretcolNcdnt].pvData = &ncdnt;
	rgretcol[iretcolNcdnt].cbData = sizeof(ncdnt);
	rgretcol[iretcolNcdnt].itagSequence = 1;

	rgretcol[iretcolSid].columnid = rgcolumnidTopUsage[iretcolSid];
	rgretcol[iretcolSid].pvData = rgbSid;
	rgretcol[iretcolSid].cbData = sizeof(rgbSid);
	rgretcol[iretcolSid].itagSequence = 1;

	rgretcol[iretcolWeightedTotal].columnid = rgcolumnidTopUsage[iretcolWeightedTotal];
	rgretcol[iretcolWeightedTotal].pvData = &cWeightedTotal;
	rgretcol[iretcolWeightedTotal].cbData = sizeof(cWeightedTotal);
	rgretcol[iretcolWeightedTotal].itagSequence = 1;

	rgretcol[iretcolTombstoned].columnid = rgcolumnidTopUsage[iretcolTombstoned];
	rgretcol[iretcolTombstoned].pvData = &cTombstoned;
	rgretcol[iretcolTombstoned].cbData = sizeof(cTombstoned);
	rgretcol[iretcolTombstoned].itagSequence = 1;

	rgretcol[iretcolLive].columnid = rgcolumnidTopUsage[iretcolLive];
	rgretcol[iretcolLive].pvData = &cLive;
	rgretcol[iretcolLive].cbData = sizeof(cLive);
	rgretcol[iretcolLive].itagSequence = 1;

	if ( ulRangeStart < cRecords )
		{
		//	determine number of entries to return after accounting
		//	for any range limits
		//
		cRecordsToReturn = min( cRecords - ulRangeStart, *pulRangeEnd );
		}
	else
		{
		//	starting range limit is beyond end of list,
		//	so don't return any values
		//
		cRecordsToReturn = 0;
		}

	if ( cRecordsToReturn > 0 )
		{
		//	allocate space for return values
		//
		pAVal = (ATTRVAL *)THAllocEx( pTHS, cRecordsToReturn * sizeof(ATTRVAL) );

		//	traverse the sort for the specified range (it will be ordered
		//	by our specified sort order, which was weighted total)
		//
		err = JetMoveEx( sesid, tableidTopUsage, JET_MoveFirst, NO_GRBIT );
		Assert( JET_errSuccess == err || JET_errNoCurrentRecord == err );
		if ( JET_errSuccess == err && ulRangeStart > 0 )
			{
			err = JetMoveEx( sesid, tableidTopUsage, ulRangeStart, NO_GRBIT );
			}
		}
	else
		{
		//	nothing to return, force to end of range
		//
		Assert( NULL == pAVal );
		err = JET_errNoCurrentRecord;
		}

	//	HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK!
	//	we are going to build up the multi-values in reverse order
	//	because the ldap head will later reverse the list again
	//	(see LDAP_AttrBlockToPartialAttributeList() for details)
	//
	for ( imv = cRecordsToReturn - 1;
		JET_errSuccess == err && imv >= 0;
		imv-- )
		{
		NTSTATUS		status;
		WCHAR *			wszXML;
		const ULONG		cbDword		= 12;	//	assumes DWORD in string format is not going to take more than this many characters
		ULONG			cbAlloc		= ( wcslen( g_szQuotaTopUsageTemplate )
										+ ( cbDword * 3 ) );	//	for Tombstoned, Live, and WeightedTotal counts

		//	retrieve the next record in the sort
		//
		JetRetrieveColumnsSuccess(
					sesid,
					tableidTopUsage,
					rgretcol,
					sizeof(rgretcol) / sizeof(rgretcol[0]) );

		//	cache this partition if different from
		//	previous iteration
		//
		Assert( 0 != ncdnt );
		if ( ncdnt != ncdntLast )
			{
			pNCL = FindNCLFromNCDNT( ncdnt, TRUE );
			if ( NULL == pNCL )
				{
				//	something is horribly wrong, this NCDNT is not in Master NCL
				//
				DPRINT2(
					0,
					"Couldn't find NCDNT %d (0x%x) in Master Naming Context List.\n",
					ncdnt,
					ncdnt );
				Assert( !"Couldn't find NCDNT in Master NCL." );
				SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE );
				goto HandleError;
				}

			ncdntLast = ncdnt;
			}

		//	account for space needed for partition DN
		//
		Assert( NULL != pNCL );
		Assert( NULL != pNCL->pNC );
		cbAlloc += pNCL->pNC->NameLen;

		//	normalise to bytes (still need to fetch SID,
		//	but its length will be expressed in bytes)
		//
		cbAlloc *= sizeof(WCHAR);

		//	convert owner SID to Unicode
		//
		Assert( usSid.Buffer == rgchSid );
		Assert( usSid.MaximumLength == sizeof(rgchSid) / sizeof(WCHAR) );
		usSid.Length = 0;
		status = RtlConvertSidToUnicodeString( &usSid, rgbSid, FALSE );
		if ( !NT_SUCCESS( status ) )
			{
			DPRINT1( 0, "Failed converting SID to Unicode with status code 0x%x.\n", status );
			SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE, status );
			goto HandleError;
			}

		//	account for space needed for owner SID
		//	(WARNING: the size is returned in BYTES)
		//
		cbAlloc += usSid.Length;

		//	counts should have been validated when we built the sort
		//
		Assert( 0 != cTombstoned || 0 != cLive );
		Assert( cWeightedTotal >= 0 );

		//	allocate space for the XML text string to be returned
		//
		wszXML = (WCHAR *)THAllocEx( pTHS, cbAlloc );

		//	generate the XML text string to return
		//
		swprintf(
			wszXML,
			g_szQuotaTopUsageTemplate,
			pNCL->pNC->StringName,
			usSid.Buffer,
			cWeightedTotal,
			cTombstoned,
			cLive );

		//	record the XML string in our
		//	return structure
		//
		Assert( NULL != pAVal );
		pAVal[imv].valLen = wcslen( wszXML ) * sizeof(WCHAR);
		pAVal[imv].pVal = (UCHAR *)wszXML;

		//	move to next entry
		//
		err = JetMoveEx( sesid, tableidTopUsage, JET_MoveNext, NO_GRBIT );
		Assert( JET_errSuccess == err || JET_errNoCurrentRecord == err );
		}

	//	whether we lit the limit or we hit the end of the table,
	//	in either case, we should have sized the result set correctly
	//
	Assert( -1 == imv );

	if ( JET_errNoCurrentRecord == err )
		{
		//	indicate that we reached the end
		//
		*pulRangeEnd = 0xFFFFFFFF;
		}
	else
		{
		//	hit limit, so return index of last entry we processed
		//
		Assert( JET_errSuccess == err );
		*pulRangeEnd = ulRangeStart + cRecordsToReturn - ( imv + 1 ) - 1;
		}

	//	return final results
	//
	pAttr->AttrVal.valCount = cRecordsToReturn;
	pAttr->AttrVal.pAVal = pAVal;

HandleError:
	return pTHS->errCode;
	}



//
//	EXTERNAL FUNCTIONS
//


//	enforce/update quota for addition of specified object
//
INT ErrQuotaAddObject(
	DBPOS *	const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD,
	const BOOL				fIsTombstoned )
	{
	THSTATE * const			pTHS			= pDB->pTHS;
	JET_SESID				sesid			= pDB->JetSessID;
	JET_TABLEID				tableidQuota	= JET_tableidNil;
	PSID					pOwnerSid		= NULL;
	ULONG					cbOwnerSid;
	ULONG					ulEffectiveQuota;

	Assert( VALID_DBPOS( pDB ) );
	Assert( VALID_THSTATE( pTHS ) );

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt just after DCPromo)
	//
	if ( DsaIsInstalling() && !DsaIsInstallingFromMedia() )
		{
		return ERROR_SUCCESS;
		}

	//	if Quota table is being rebuilt, then
	//	only update quota counts if the rebuild
	//	task will not be doing so
	//
	if ( !gAnchor.fQuotaTableReady
		&& pDB->DNT > gAnchor.ulQuotaRebuildDNTLast
		&& pDB->DNT <= gAnchor.ulQuotaRebuildDNTMax )
		{
		return ERROR_SUCCESS;
		}

	//	open cursor on Quota table
	//
	JetOpenTableEx(
			sesid,
			pDB->JetDBID,
			g_szQuotaTable,
			NULL,
			0,
			NO_GRBIT,
			&tableidQuota );
	Assert( JET_tableidNil != tableidQuota );

	__try
		{
		//	retrieve owner SID from specified SD
		//
		if ( ErrQuotaGetOwnerSID_( pTHS, pSD, &pOwnerSid, &cbOwnerSid ) )
			{
			DPRINT( 0, "Could not determine owner SID for object insertion.\n" );
			}

		//	compute effective quota for this security principle
		//
		else if ( ErrQuotaGetEffectiveQuota_( pTHS, ncdnt, pOwnerSid, cbOwnerSid, TRUE, &ulEffectiveQuota ) )
			{
			DPRINT( 0, "Failed computing effective quota for object insertion.\n" );
			}

		//	find the quota record for this security principle
		//
		else if ( FQuotaSeekOwner_( sesid, tableidQuota, ncdnt, pOwnerSid, cbOwnerSid ) )
			{
			//	update quota for objection insertion, ensuring that
			//	effective quota is respected
			//
			if ( ErrQuotaAddObject_( pDB, tableidQuota, ncdnt, ulEffectiveQuota, fIsTombstoned ) )
				{
				DPRINT( 0, "Failed updating quota counts for object insertion.\n" );
				}
			else
				{
				QuotaAudit_(
						sesid,
						pDB->JetDBID,
						pDB->DNT,
						ncdnt,
						pOwnerSid,
						cbOwnerSid,
						TRUE,			//	fUpdatedTotal
						fIsTombstoned,
						TRUE,			//	fIncrementing
						FALSE,			//	fAdding
						FALSE );		//	fRebuild
				}
			}

		//	no quota record yet for this security principle, so add one
		//	(and update quota for object insertion, ensuring that
		//	effective quota is respected)
		//
		else if ( ErrQuotaAddSecurityPrinciple_(
							pDB,
							tableidQuota,
							ncdnt,
							pOwnerSid,
							cbOwnerSid,
							ulEffectiveQuota,
							fIsTombstoned ) )
			{
			DPRINT( 0, "Failed adding new security principle to Quota table.\n" );
			}

		else
			{
			QuotaAudit_(
					sesid,
					pDB->JetDBID,
					pDB->DNT,
					ncdnt,
					pOwnerSid,
					cbOwnerSid,
					TRUE,			//	fUpdatedTotal
					fIsTombstoned,
					TRUE,			//	fIncrementing
					TRUE,			//	fAdding
					FALSE );		//	fRebuild
			}
		}

	__finally
		{
		Assert( JET_tableidNil != tableidQuota );
		JetCloseTableWithErr( sesid, tableidQuota, pTHS->errCode );
		}

	return pTHS->errCode;
	}


//	update quota for tombstoned object
//
INT ErrQuotaTombstoneObject(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD )
	{
	DWORD					err;
	THSTATE * const			pTHS			= pDB->pTHS;
	JET_SESID				sesid			= pDB->JetSessID;
	JET_TABLEID				tableidQuota	= JET_tableidNil;
	PSID					pOwnerSid		= NULL;
	ULONG					cbOwnerSid;

	Assert( VALID_DBPOS( pDB ) );
	Assert( VALID_THSTATE( pTHS ) );

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt just after DCPromo)
	//
	if ( DsaIsInstalling() && !DsaIsInstallingFromMedia() )
		{
		return ERROR_SUCCESS;
		}

	//	if Quota table is being rebuilt, then
	//	only update quota counts if the rebuild
	//	task will not be doing so
	//
	if ( !gAnchor.fQuotaTableReady
		&& pDB->DNT > gAnchor.ulQuotaRebuildDNTLast
		&& pDB->DNT <= gAnchor.ulQuotaRebuildDNTMax )
		{
		return ERROR_SUCCESS;
		}

	//	open cursor on Quota table
	//
	JetOpenTableEx(
			sesid,
			pDB->JetDBID,
			g_szQuotaTable,
			NULL,
			0,
			NO_GRBIT,
			&tableidQuota );
	Assert( JET_tableidNil != tableidQuota );

	__try
		{
		//	retrieve owner SID from specified SD
		//
		if ( ErrQuotaGetOwnerSID_( pTHS, pSD, &pOwnerSid, &cbOwnerSid ) )
			{
			DPRINT( 0, "Could not determine owner SID for tombstoned object.\n" );
			}

		//	find the quota record for this security principle
		//
		else if ( FQuotaSeekOwner_( sesid, tableidQuota, ncdnt, pOwnerSid, cbOwnerSid ) )
			{
			//	update quota for tombstoned object
			//
			if ( ErrQuotaTombstoneObject_( pDB, tableidQuota, ncdnt ) )
				{
				DPRINT( 0, "Failed updating quota counts for tombstoned object.\n" );
				}
			else
				{
				QuotaAudit_(
						sesid,
						pDB->JetDBID,
						pDB->DNT,
						ncdnt,
						pOwnerSid,
						cbOwnerSid,
						FALSE,			//	fUpdatedTotal
						TRUE,			//	fTombstoned
						TRUE,			//	fIncrementing
						FALSE,			//	fAdding
						FALSE );		//	fRebuild
				}
			}

		//	couldn't find quota record, something is horribly wrong
		//
		else
			{
			DPRINT( 0, "Corruption in Quota table: expected object doesn't exist in Quota table.\n" );
			Assert( !"Corruption in Quota table: expected object doesn't exist in Quota table." );

		    LogEvent8WithData(
				DS_EVENT_CAT_INTERNAL_PROCESSING,
				DS_EVENT_SEV_ALWAYS,
				DIRLOG_QUOTA_RECORD_MISSING,
				szInsertUL( ncdnt ),
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				cbOwnerSid,
				pOwnerSid );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
			SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#endif
			}
		}

	__finally
		{
		Assert( JET_tableidNil != tableidQuota );
		JetCloseTableWithErr( sesid, tableidQuota, pTHS->errCode );
		}

	return pTHS->errCode;
	}


//	update quota for deleted object
//
INT ErrQuotaDeleteObject(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD,
	const BOOL				fIsTombstoned )
	{
	THSTATE * const			pTHS			= pDB->pTHS;
	JET_SESID				sesid			= pDB->JetSessID;
	JET_TABLEID				tableidQuota	= JET_tableidNil;
	PSID					pOwnerSid		= NULL;
	ULONG					cbOwnerSid;

	Assert( VALID_DBPOS( pDB ) );
	Assert( VALID_THSTATE( pTHS ) );

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt just after DCPromo)
	//
	if ( DsaIsInstalling() && !DsaIsInstallingFromMedia() )
		{
		return ERROR_SUCCESS;
		}

	//	if Quota table is being rebuilt, then
	//	only update quota counts if the rebuild
	//	task will not be doing so
	//
	if ( !gAnchor.fQuotaTableReady
		&& pDB->DNT > gAnchor.ulQuotaRebuildDNTLast
		&& pDB->DNT <= gAnchor.ulQuotaRebuildDNTMax )
		{
		return ERROR_SUCCESS;
		}

	//	open cursor on Quota table
	//
	JetOpenTableEx(
			sesid,
			pDB->JetDBID,
			g_szQuotaTable,
			NULL,
			0,
			NO_GRBIT,
			&tableidQuota );
	Assert( JET_tableidNil != tableidQuota );

	__try
		{
		//	retrieve owner SID from specified SD
		//
		if ( ErrQuotaGetOwnerSID_( pTHS, pSD, &pOwnerSid, &cbOwnerSid ) )
			{
			DPRINT( 0, "Could not determine owner SID for object deletion.\n" );
			}

		//	find the quota record for this security principle
		//
		else if ( FQuotaSeekOwner_( sesid, tableidQuota, ncdnt, pOwnerSid, cbOwnerSid ) )
			{
			//	update quota counts for deleted object
			//
			if ( ErrQuotaDeleteObject_( pDB, tableidQuota, ncdnt, fIsTombstoned ) )
				{
				DPRINT( 0,  "Failed updating quota counts for object deletion.\n" );
				}
			else
				{
				QuotaAudit_(
						sesid,
						pDB->JetDBID,
						pDB->DNT,
						ncdnt,
						pOwnerSid,
						cbOwnerSid,
						TRUE,			//	fUpdatedTotal
						fIsTombstoned,
						FALSE,			//	fIncrementing
						FALSE,			//	fAdding
						FALSE );		//	fRebuild
				}
			}

		//	couldn't find quota record, something is horribly wrong
		//
		else
			{
			DPRINT( 0, "Corruption in Quota table: expected doesn't exist in Quota table.\n" );
			Assert( !"Corruption in Quota table: expected object doesn't exist in Quota table." );

		    LogEvent8WithData(
				DS_EVENT_CAT_INTERNAL_PROCESSING,
				DS_EVENT_SEV_ALWAYS,
				DIRLOG_QUOTA_RECORD_MISSING,
				szInsertUL( ncdnt ),
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				cbOwnerSid,
				pOwnerSid );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
			SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#endif
			}
		}

	__finally
		{
		Assert( JET_tableidNil != tableidQuota );
		JetCloseTableWithErr( sesid, tableidQuota, pTHS->errCode );
		}

	return pTHS->errCode;
	}


//	enforce/update quota for resurrected (undeleted) object
//
INT ErrQuotaResurrectObject(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD )
	{
	THSTATE * const			pTHS				= pDB->pTHS;
	JET_SESID				sesid				= pDB->JetSessID;
	JET_TABLEID				tableidQuota		= JET_tableidNil;
	PSID					pOwnerSid			= NULL;
	ULONG					cbOwnerSid;
	ULONG					ulEffectiveQuota;

	Assert( VALID_DBPOS( pDB ) );
	Assert( VALID_THSTATE( pTHS ) );

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt just after DCPromo), but shouldn't
	//	be resurrecting objects during DCPromo anyway
	//
	Assert( !DsaIsInstalling() );

	//	if Quota table is being rebuilt, then
	//	only update quota counts if the rebuild
	//	task will not be doing so
	//
	if ( !gAnchor.fQuotaTableReady
		&& pDB->DNT > gAnchor.ulQuotaRebuildDNTLast
		&& pDB->DNT <= gAnchor.ulQuotaRebuildDNTMax )
		{
		return ERROR_SUCCESS;
		}

	//	open cursor on Quota table
	//
	JetOpenTableEx(
			sesid,
			pDB->JetDBID,
			g_szQuotaTable,
			NULL,
			0,
			NO_GRBIT,
			&tableidQuota );
	Assert( JET_tableidNil != tableidQuota );

	__try
		{
		//	retrieve owner SID from specified SD
		//
		if ( ErrQuotaGetOwnerSID_( pTHS, pSD, &pOwnerSid, &cbOwnerSid ) )
			{
			DPRINT( 0, "Could not determine owner SID for object resurrection.\n" );
			}

		//	find the quota record for this security principle
		//
		else if ( FQuotaSeekOwner_( sesid, tableidQuota, ncdnt, pOwnerSid, cbOwnerSid ) )
			{
			//	compute effective quota for this security principle
			//
			if ( ErrQuotaGetEffectiveQuota_( pTHS, ncdnt, pOwnerSid, cbOwnerSid, TRUE, &ulEffectiveQuota ) )
				{
				DPRINT( 0, "Failed computing effective quota for object resurrection.\n" );
				}

			//	update quota for object resurrection, ensuring that
			//	effective quota is respected
			//
			else if ( ErrQuotaResurrectObject_( pDB, tableidQuota, ncdnt, ulEffectiveQuota ) )
				{
				DPRINT( 0, "Failed updating quota counts for object resurrection.\n" );
				}
			else
				{
				QuotaAudit_(
						sesid,
						pDB->JetDBID,
						pDB->DNT,
						ncdnt,
						pOwnerSid,
						cbOwnerSid,
						FALSE,			//	fUpdatedTotal
						TRUE,			//	fUpdatedTombstoned
						FALSE,			//	fIncrementing
						FALSE,			//	fAdding
						FALSE );		//	fRebuild
				}
			}

		//	no quota record for this security principle, something is
		//	horribly wrong
		//
		else
			{
			DPRINT( 0, "Corruption in Quota table: expected doesn't exist in Quota table.\n" );
			Assert( !"Corruption in Quota table: expected object doesn't exist in Quota table." );

		    LogEvent8WithData(
				DS_EVENT_CAT_INTERNAL_PROCESSING,
				DS_EVENT_SEV_ALWAYS,
				DIRLOG_QUOTA_RECORD_MISSING,
				szInsertUL( ncdnt ),
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				cbOwnerSid,
				pOwnerSid );

#ifdef FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE
			SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_DATABASE_ERROR );
#endif
			}
		}

	__finally
		{
		Assert( JET_tableidNil != tableidQuota );
		JetCloseTableWithErr( sesid, tableidQuota, pTHS->errCode );
		}

	return pTHS->errCode;
	}


// compute Effective-Quota constructed attribute
//
INT ErrQuotaQueryEffectiveQuota(
	DBPOS *	const	pDB,
	const DWORD		ncdnt,
	PSID			pOwnerSid,
	ULONG *			pulEffectiveQuota )
	{
	THSTATE * const	pTHS			= pDB->pTHS;
	BYTE			rgbToken[sizeof(TOKEN_USER)+sizeof(NT4SID)];
	PTOKEN_USER		pTokenUser		= (PTOKEN_USER)rgbToken;
	PSID			psid;

	Assert( VALID_DBPOS( pDB ) );
	Assert( VALID_THSTATE( pTHS ) );

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt just after DCPromo), but shouldn't
	//	be searching quota during DCPromo anyway
	//
	Assert( !DsaIsInstalling() );

	//	initialise return value
	//
	*pulEffectiveQuota = 0;

	if ( NULL == pOwnerSid )
		{
		//	no owner specified, use user sid
		//
		if ( ErrQuotaGetUserToken_( pTHS, pTokenUser ) )
			{
			DPRINT( 0, "Failed retrieving user sid for query on effective quota.\n" );
			goto HandleError;
			}

		psid = pTokenUser->User.Sid;
		Assert( IsValidSid( psid ) );
		}

	else if ( IsValidSid( pOwnerSid ) )
		{
		psid = pOwnerSid;
		}

	else
		{
		DPRINT( 0, "Invalid owner SID specified for query on effective quota.\n" );
		SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, ERROR_INVALID_SID );
		goto HandleError;
		}

	if ( ErrQuotaGetEffectiveQuota_( pTHS, ncdnt, psid, GetLengthSid( psid ), FALSE, pulEffectiveQuota ) )
		{
		DPRINT( 0, "Failed query on effective quota.\n" );
		goto HandleError;
		}

HandleError:
	return pTHS->errCode;
	}


// compute Quota-Used constructed attribute
//
INT ErrQuotaQueryUsedQuota(
	DBPOS * const	pDB,
	const DWORD		ncdnt,
	PSID			pOwnerSid,
	ULONG *			pulQuotaUsed )
	{
	DWORD			err;
	THSTATE * const	pTHS			= pDB->pTHS;
	JET_SESID		sesid			= pDB->JetSessID;
	JET_TABLEID		tableidQuota	= JET_tableidNil;
	BYTE			rgbToken[sizeof(TOKEN_USER)+sizeof(NT4SID)];
	PTOKEN_USER		pTokenUser		= (PTOKEN_USER)rgbToken;
	PSID			psid;

	Assert( VALID_DBPOS( pDB ) );
	Assert( VALID_THSTATE( pTHS ) );

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt just after DCPromo), but shouldn't
	//	be searching quota during DCPromo anyway
	//
	Assert( !DsaIsInstalling() );

	//	initialise return value
	//
	*pulQuotaUsed = 0;

	//	determine sid of user for which we'll be checking
	//	quota used
	//
	if ( NULL == pOwnerSid )
		{
		//	no owner specified, use user sid
		//
		if ( ErrQuotaGetUserToken_( pTHS, pTokenUser ) )
			{
			DPRINT( 0, "Failed retrieving user sid for query on effective quota.\n" );
			goto HandleError;
			}

		psid = pTokenUser->User.Sid;
		Assert( IsValidSid( psid ) );
		}

	else if ( IsValidSid( pOwnerSid ) )
		{
		psid = pOwnerSid;
		}

	else
		{
		DPRINT( 0, "Invalid owner SID specified for query on effective quota.\n" );
		SetSvcErrorEx( SV_PROBLEM_DIR_ERROR, DIRERR_SECURITY_CHECKING_ERROR, ERROR_INVALID_SID );
		goto HandleError;
		}

	//	open cursor on Quota table
	//
	JetOpenTableEx(
			sesid,
			pDB->JetDBID,
			g_szQuotaTable,
			NULL,
			0,
			NO_GRBIT,
			&tableidQuota );
	Assert( JET_tableidNil != tableidQuota );

	__try
		{
		//	find the quota record for this security principle
		//
		if ( FQuotaSeekOwner_( sesid, tableidQuota, ncdnt, psid, GetLengthSid( psid ) ) )
			{
			ULONG					cTombstoned;
			ULONG					cTotal;
			NAMING_CONTEXT_LIST *	pNCL		= FindNCLFromNCDNT( ncdnt, TRUE );

			//	find Master NCL, which we'll need for the quota weight
			//	of tombstoned objects
			//
			if ( NULL == pNCL )
				{
				//	something is horribly wrong, this NCDNT is not in Master NCL
				//
				DPRINT2(
					0,
					"Couldn't find NCDNT %d (0x%x) in Master Naming Context List.\n",
					ncdnt,
					ncdnt );
				Assert( !"Couldn't find NCDNT in Master NCL." );
				SetSvcError( SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE );
				}

			//	retrieve counts and calculate weighted total
			//
			else
				{
				JetRetrieveColumnSuccess(
							sesid,
							tableidQuota,
							g_columnidQuotaTombstoned,
							&cTombstoned,
							sizeof(cTombstoned),
							NULL,			//	pcbActual
							NO_GRBIT,
							NULL );			//	pretinfo
				JetRetrieveColumnSuccess(
							sesid,
							tableidQuota,
							g_columnidQuotaTotal,
							&cTotal,
							sizeof(cTotal),
							NULL,			//	pcbActual
							NO_GRBIT,
							NULL );			//	pretinfo

				Assert( cTombstoned <= cTotal );
				*pulQuotaUsed = UlQuotaTotalWeighted_(
										cTotal - cTombstoned,
										cTombstoned,
										pNCL->ulTombstonedQuotaWeight );
				}
			}
		}

	__finally
		{
		Assert( JET_tableidNil != tableidQuota );
		JetCloseTableWithErr( sesid, tableidQuota, pTHS->errCode );
		}

HandleError:	
	return pTHS->errCode;
	}


//	compute Top-Usage constructed attribute
//
//	HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK!
//	we want the list in DESCENDING weighted quota total order,
//	but this function will return it in ASCENDING order because
//	the ldap head will later reverse the list again (see
//	LDAP_AttrBlockToPartialAttributeList() for details)
//
//	QUOTA_UNDONE: The general algorithm here is to traverse the
//	Quota table and pump all records with the specified NCDNT
//	(or all records if NCDNT==0) into a sort, sort by weighted
//	total, and then return the range requested.  However, this
//	will be incredibly inefficient if in the common case, the
//	query is something like "return the top n quota usage values",
//	where n is usually a small number, say a dozen or less
//
INT ErrQuotaQueryTopQuotaUsage(
	DBPOS *	const			pDB,
	const DWORD				ncdnt,
	const ULONG				ulRangeStart,
	ULONG * const			pulRangeEnd,	//	IN: max number of entries to return, OUT: index of last entry returned
	ATTR *					pAttr )
	{
	THSTATE * const			pTHS					= pDB->pTHS;
	JET_SESID				sesid					= pDB->JetSessID;
	JET_TABLEID				tableidQuota			= JET_tableidNil;
	JET_TABLEID				tableidTopUsage			= JET_tableidNil;
	ULONG					cRecords;
	JET_COLUMNID			rgcolumnidTopUsage[6];
	JET_COLUMNDEF			rgcolumndefTopUsage[6]	= {
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, NO_GRBIT },										//	ncdnt
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypBinary, 0, 0, 0, 0, 0, NO_GRBIT },										//	owner sid
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnTTKey|JET_bitColumnTTDescending },	//	weighted total count
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, NO_GRBIT },										//	tombstoned count
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnTTKey|JET_bitColumnTTDescending },	//	live count
		{ sizeof( JET_COLUMNDEF ), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnTTKey } };							//	uniquifier

	Assert( VALID_DBPOS( pDB ) );
	Assert( VALID_THSTATE( pTHS ) );

	//	verify no lingering thstate errors
	//
	Assert( ERROR_SUCCESS == pTHS->errCode );

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt just after DCPromo), but shouldn't
	//	be searching quota during DCPromo anyway
	//
	Assert( !DsaIsInstalling() );

	//	open cursor on Quota table
	//
	JetOpenTableEx(
			sesid,
			pDB->JetDBID,
			g_szQuotaTable,
			NULL,
			0,
			JET_bitTableSequential,
			&tableidQuota );
	Assert( JET_tableidNil != tableidQuota );

	__try
		{
		//	open a sort to sort the results by weighted total
		//
		JetOpenTempTableEx(
				sesid,
				rgcolumndefTopUsage,
				sizeof(rgcolumndefTopUsage) / sizeof(rgcolumndefTopUsage[0]),
				NO_GRBIT,
				&tableidTopUsage,
				rgcolumnidTopUsage );

		//	traverse Quota table and build sort
		//
		if ( ErrQuotaBuildTopUsageTable_(
							pDB,
							ncdnt,
							tableidQuota,
							tableidTopUsage,
							rgcolumnidTopUsage,
							&cRecords ) )
			{
			DPRINT( 0, "Failed building Top Quota Usage temporary table.\n" );
			}

		//	build results from the sort
		//
		else if ( ErrQuotaBuildTopUsageResults_(
							pDB,
							tableidTopUsage,
							rgcolumnidTopUsage,
							cRecords,
							ulRangeStart,
							pulRangeEnd,
							pAttr ) )
			{
			DPRINT( 0, "Failed building Top Quota Usage results.\n" );
			}
		}

	__finally
		{
		if ( JET_tableidNil != tableidTopUsage )
			{
			JetCloseTableWithErr( sesid, tableidTopUsage, pTHS->errCode );
			}

		Assert( JET_tableidNil != tableidQuota );
		JetCloseTableWithErr( sesid, tableidQuota, pTHS->errCode );
		}

	return pTHS->errCode;
	}


//	rebuild Quota table
//
VOID QuotaRebuildAsync(
	VOID *			pv,
	VOID **			ppvNext,
	DWORD *			pcSecsUntilNextIteration )
	{
	JET_ERR			err;
	JET_SESID		sesid							= JET_sesidNil;
	JET_DBID		dbid							= JET_dbidNil;
	JET_TABLEID		tableidQuota					= JET_tableidNil;
	JET_TABLEID		tableidQuotaRebuildProgress		= JET_tableidNil;
	JET_TABLEID		tableidObj						= JET_tableidNil;
	JET_TABLEID		tableidSD						= JET_tableidNil;

	//	not tracking quota during DCPromo (quota table 
	//	is rebuilt on first startup after DCPromo),
	//	so shouldn't be calling this routine
	//
	Assert( !DsaIsInstalling() );

	//	shouldn't be dispatching Quota rebuild task if not necessary,
	//	but handle it just in case something went inexplicably wrong
	//
	Assert( !gAnchor.fQuotaTableReady );
	if ( gAnchor.fQuotaTableReady )
		{
		return;
		}

	//	open local Jet resources
	//
	Call( JetBeginSession( jetInstance, &sesid, szUser, szPassword ) );
	Assert( JET_sesidNil != sesid );

	Call( JetOpenDatabase( sesid, szJetFilePath, "", &dbid, NO_GRBIT ) );
	Assert( JET_dbidNil != dbid );

	Call( JetOpenTable(
				sesid,
				dbid,
				g_szQuotaTable,
				NULL,		//	pvParameters
				0,			//	cbParameters
				NO_GRBIT,
				&tableidQuota ) );
	Assert( JET_tableidNil != tableidQuota );

	Call( JetOpenTable(
				sesid,
				dbid,
				g_szQuotaRebuildProgressTable,
				NULL,		//	pvParameters
				0,			//	cbParameters
				JET_bitTableDenyRead,		//	no one else should ever have reason to open this table
				&tableidQuotaRebuildProgress ) );
	Assert( JET_tableidNil != tableidQuotaRebuildProgress );

	Call( ErrQuotaRebuild_(
					sesid,
					dbid,
					tableidQuota,
					tableidQuotaRebuildProgress,
					gAnchor.ulQuotaRebuildDNTLast,
					g_columnidQuotaNcdnt,
					g_columnidQuotaSid,
					g_columnidQuotaTombstoned,
					g_columnidQuotaTotal,
					TRUE,			//	fAsync
					FALSE )	);		//	fCheckOnly

HandleError:
	if ( JET_tableidNil != tableidQuotaRebuildProgress )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidQuotaRebuildProgress, err );
		}

	if ( JET_tableidNil != tableidQuota )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidQuota, err );
		}

	if ( JET_dbidNil != dbid )
		{
		err = JetCloseDatabaseWithErrUnhandled( sesid, dbid, err );
		}

	if ( JET_sesidNil != sesid )
		{
		err = JetEndSessionWithErrUnhandled( sesid, err );
		}

	if ( !gAnchor.fQuotaTableReady )
		{
		*pcSecsUntilNextIteration = g_csecQuotaNextRebuildPeriod;

		if ( JET_errSuccess != err )
			{
			//	generate an event indicating that the Quota table
			//	rebuild task failed and that another attempt
			//	will be made
			//
		    LogEvent8(
				DS_EVENT_CAT_INTERNAL_PROCESSING,
				DS_EVENT_SEV_ALWAYS,
				DIRLOG_ASYNC_QUOTA_REBUILD_FAILED,
				szInsertJetErrCode( err ),
				szInsertHex( err ),
				szInsertJetErrMsg( err ),
				g_csecQuotaNextRebuildPeriod,
				NULL,
				NULL,
				NULL,
				NULL );
			}
		}

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\parsedn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       parsedn.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file is compiled into ntdsa.dll and is included in ntdsapi\parsedn.c.

    This module collects in one place all DN parsing and helper routines
    so that they can be used by the core and compiled in src\ntdsapi.
    As such, these routines should not log events, depend on THSTATE, etc.
    They should stand on their own with no environmental dependencies.

    Routine that are exported out of the core dll are marked as follows:
N.B. This routine is exported to in-process non-module callers

Author:

    Dave Straube    (davestr)   26-Oct-97

Revision History:

    Dave Straube    (davestr)   26-Oct-97
        Genesis - no new code, just repackaging from mdname.c.
    Aaron Siegel    (t-asiege)  24-Jul-98
        Brought NameMatched () here from mdname.c.

--*/

#include <NTDSpch.h>
#pragma  hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    // header Audit\Alert logging
#include "dsexcept.h"                   // exception filters
#include "mdcodes.h"                    // header for error codes

// Assorted DSA headers.
#include "objids.h"                     // Defines for selected classes and atts
#include "anchor.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB     "PARSEDN:"           // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_PARSEDN


#define KEY_COMMONNAME L"CN"
#define KEY_LOCALITYNAME L"L"
#define KEY_STATEORPROVINCENAME L"ST"
#define KEY_ORGANIZATIONNAME L"O"
#define KEY_ORGANIZATIONALUNITNAME L"OU"
#define KEY_COUNTRYNAME L"C"
#define KEY_STREETADDRESS L"STREET"
#define KEY_DOMAINCOMPONENT L"DC"

#define WCCNT(x) ((sizeof(x) - sizeof(WCHAR))/sizeof(WCHAR))

// Size in characters of tags (e.g., "DEL", "CNF") embedded in mangled RDNs.
#define MANGLE_TAG_LEN  (3)

// Size in characters of string (e.g.,
// "#DEL:a746b716-0ac0-11d2-b376-0000f87a46c8", where # is BAD_NAME_CHAR)
// appended to an RDN by MangleRDN().
#define MANGLE_APPEND_LEN   (1 + MANGLE_TAG_LEN + 1 + 36)

// This constant is the number of characters of an RDN that we will keep when we
// mangle an RDN.
// (MAX_MANGLE_RDN_BASE + MANGLE_APPEND_LEN)*sizeof(WCHAR) + JET_CRUD <=
//                                           JET_cbKeyMost
// JET_CRUD is space for a DWORD overhead for constructing a key.  This is
// necessary because mangled names have to be used as RDNs, and RDNs must have
// unique keys in the PDNT-RNDN index.
#define MAX_MANGLE_RDN_BASE 75

unsigned
AttrTypeToKeyLame (
        ATTRTYP attrtyp,
        WCHAR *pOutBuf
        )
/*++
Routine Description:
    Translates an attrtype to a well known key value (primarily used in string
    representations of DNs e.g. O or OU of OU=Foo,O=Bar).

Arguments
    attrtyp - the attrtyp to translate from.
    pOutBuf - preallocated buffer to copy the key to.  Must be long enough
              for (MAX_RDN_KEY_SIZE - 1) wchars.

Return Values
    the count of charactes in the key the attrtyp implied, or 0 if the attrtyp
    did not have a known key.
--*/
{

#ifndef CLIENT_SIDE_DN_PARSING
#ifdef INCLUDE_UNIT_TESTS
{
    extern DWORD dwUnitTestIntId;
    // always generate IID-syntaxed DNs
    if (dwUnitTestIntId == 1) {
        return (AttrTypeToIntIdString(attrtyp, pOutBuf, MAX_RDN_KEY_SIZE));
    }
}
#endif INCLUDE_UNIT_TESTS
#endif !CLIENT_SIDE_DN_PARSING

    switch (attrtyp) {
        case ATT_COMMON_NAME:
            memcpy(pOutBuf,
                   KEY_COMMONNAME,
                   sizeof(WCHAR)*WCCNT(KEY_COMMONNAME));
            return WCCNT(KEY_COMMONNAME);
            break;

        case ATT_LOCALITY_NAME:
            memcpy(pOutBuf,
                   KEY_LOCALITYNAME,
                   sizeof(WCHAR)*WCCNT(KEY_LOCALITYNAME));
            return WCCNT(KEY_LOCALITYNAME);
            break;

        case ATT_STATE_OR_PROVINCE_NAME:
            memcpy(pOutBuf,
                   KEY_STATEORPROVINCENAME,
                   sizeof(WCHAR)*WCCNT(KEY_STATEORPROVINCENAME));
            return WCCNT(KEY_STATEORPROVINCENAME);
            break;

        case ATT_STREET_ADDRESS:
            memcpy(pOutBuf,
                   KEY_STREETADDRESS,
                   sizeof(WCHAR)*WCCNT(KEY_STREETADDRESS));
            return WCCNT(KEY_STREETADDRESS);
            break;

        case ATT_ORGANIZATION_NAME:
            memcpy(pOutBuf,
                   KEY_ORGANIZATIONNAME,
                   sizeof(WCHAR)*WCCNT(KEY_ORGANIZATIONNAME));
            return WCCNT(KEY_ORGANIZATIONNAME);
            break;

        case ATT_ORGANIZATIONAL_UNIT_NAME:
            memcpy(pOutBuf,
                   KEY_ORGANIZATIONALUNITNAME,
                   sizeof(WCHAR)*WCCNT(KEY_ORGANIZATIONALUNITNAME));
            return WCCNT(KEY_ORGANIZATIONALUNITNAME);
            break;

        case ATT_COUNTRY_NAME:
            memcpy(pOutBuf,
                   KEY_COUNTRYNAME,
                   sizeof(WCHAR)*WCCNT(KEY_COUNTRYNAME));
            return WCCNT(KEY_COUNTRYNAME);
            break;

        case ATT_DOMAIN_COMPONENT:
            memcpy(pOutBuf,
                   KEY_DOMAINCOMPONENT,
                   sizeof(WCHAR)*WCCNT(KEY_DOMAINCOMPONENT));
            return(WCCNT(KEY_DOMAINCOMPONENT));
            break;

        default:;
    }
    return 0;
}

unsigned
AttrTypeToKey (
        ATTRTYP attrtyp,
        WCHAR *pOutBuf
        )
/*++
Routine Description:
    Translates an attrtype to a key value (primarily used in string
    representations of DNs e.g. O or OU of OU=Foo,O=Bar). Note that if no string
    key is known, this routine builds a key of the format "OID.X.Y.Z" where
    X.Y.Z is the unencoded OID.

Arguments
    attrtyp - the attrtyp to translate from.
    pOutBuf - preallocated buffer to copy the key to. Must be at
              least MAX_RDN_KEY_SIZE wide chars in length.

Return Values
    the count of charactes in the key the attrtyp implied, or 0 if the attrtyp
    did not have a known key.

N.B. This routine is exported to in-process non-module callers
--*/
{
    DWORD       nChars;
    ATTCACHE    *pAC;
    THSTATE     *pTHS;

    if (0 != (nChars = AttrTypeToKeyLame(attrtyp, pOutBuf))) {
        return nChars;
    }
#ifdef CLIENT_SIDE_DN_PARSING
    return 0;
#else CLIENT_SIDE_DN_PARSING

    // Legacy check. Is this possible?
    if (NULL == (pTHS = pTHStls)) {
        return 0;
    }

    // Ok, this is an att that we have no tag for.
    // Try to fetch the ldap display name from the scache.
    //
    // Handle DNs of the form foo=xxx,bar=yyy, where foo and bar are the
    // LdapDisplayNames of arbitrary attributes that may or may not be
    // defined in the schema. KeyToAttrType is enhanced to call
    // SCGetAttByName if KeyToAttrTypeLame fails, and before trying the
    // OID decode.  The rest of this change consists of enhancing the
    // default clause of AttrTypeToKey to call SCGetAttById and to return
    // a copy of the pAC->name (LdapDisplayName).
    if (   (pAC = SCGetAttById(pTHS, attrtyp))
        && (pAC->nameLen)
        && (pAC->name) ) {
        // Convert cached ldap display name (UTF8) into UNICODE
        // Note: the scache is kept in UTF8 format for the ldap head.
        if (0 != (nChars = MultiByteToWideChar(CP_UTF8,
                                               0,
                                               pAC->name,
                                               pAC->nameLen,
                                               pOutBuf,
                                               MAX_RDN_KEY_SIZE))) {
            return nChars;
        }
        // LDN too long; FALL THRU
    }

    // Express in IID format
    // Never too long because "IID.32bit-decimal" fits in MAX_RDN_KEY_SIZE
    return (AttrTypeToIntIdString(attrtyp, pOutBuf, MAX_RDN_KEY_SIZE));
#endif CLIENT_SIDE_DN_PARSING
}


ATTRTYP
KeyToAttrTypeLame(
        WCHAR * pKey,
        unsigned cc
        )
/*++
Routine Description:
    Translates a key value (primarily used in string representations of DNs
    e.g. O or OU of OU=Foo,O=Bar) to the attrtype for the attribute it implies.

    Doesn't handle OID.X.Y.Z or IID.X

Arguments
    pKey - pointer to the key to be translated from.
    cc - count of charactes in the key.

Return Values
    the attrtyp implied, or 0 if the key did not correspond to a known attrtyp.
--*/
{
    WCHAR wch;

    if (cc ==0 || pKey == NULL) {
        return 0;
    }

    // ignore trailing spaces
    while (cc && pKey[cc-1] == L' ') {
	    --cc;
    }

    switch (*pKey) {
    case L'C':        // C or CN
    case L'c':

        // KEY_COMMONNAME: CN
        if ((cc == WCCNT(KEY_COMMONNAME)) &&
                 ((wch = *(++pKey)) == L'N' || (wch == L'n')) )  {
            return ATT_COMMON_NAME;
        }
        // KEY_COUNTRYNAME: C
        else if ( cc == WCCNT(KEY_COUNTRYNAME) ) {
            return ATT_COUNTRY_NAME;
        }

        return 0;

    case L'D':        // DC
    case L'd':

        // KEY_DOMAINCOMPONENT: DC
        if ((cc == WCCNT(KEY_DOMAINCOMPONENT)) &&
            ((wch = *(++pKey)) == L'C' || (wch == L'c')) )  {

            return(ATT_DOMAIN_COMPONENT);
        }

        return 0;
	
    case L'O':        // O, OU, or OID
    case L'o':

        // KEY_ORGANIZATIONALUNITNAME: OU
        if ((cc == WCCNT(KEY_ORGANIZATIONALUNITNAME)) &&
                 ((wch = *(++pKey)) == L'U' || (wch == L'u')) ) {
            return ATT_ORGANIZATIONAL_UNIT_NAME;
        }
        // KEY_ORGANIZATIONNAME: O
        else if (cc == WCCNT(KEY_ORGANIZATIONNAME)) {
            return ATT_ORGANIZATION_NAME;
        }

        // Note that this could have been an OID, which the real
        // KeyToAttrType must handle
        return 0;

    case L'S':        // ST or STREET
    case L's':
	
        if ( (cc == WCCNT(KEY_STATEORPROVINCENAME)) &&
              ((wch = *(++pKey)) == L'T' || (wch == L't')) ) {
                return ATT_STATE_OR_PROVINCE_NAME;
        }
        else if ( (cc == WCCNT(KEY_STREETADDRESS)) &&
                  (CSTR_EQUAL == CompareStringW(DS_DEFAULT_LOCALE,
                                    DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                    pKey,
                                    cc,
                                    KEY_STREETADDRESS,
                                    cc) ) ) {

            return ATT_STREET_ADDRESS;
        }

        return 0;

    case L'L':        // L
    case L'l':
        if (cc == 1) {
            return ATT_LOCALITY_NAME;
        }
    }

    return 0;           // failure case
}


// A collection of macros, tiny functions, and definitions to help
// collect all DN special character processing.

/*++IsSpecial
 *
 * Returns TRUE if the character passed in is one of the designated
 * "special" characters in string DNs.
 *
 * N.B.  This routine must be kept in sync with the definition of
 *       DN_SPECIAL_CHARS in dsatools.h.
 *
 * The special characters are: \n \r \" # + , ; < = > \\
 *
 */

static char ___isspecial[128] =
//   0  1  2  3  4  5  6  7  8  9
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   0
     1, 0, 0, 1, 0, 0, 0, 0, 0, 0,  //   1
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   2
     0, 0, 0, 0, 1, 1, 0, 0, 0, 0,  //   3
     0, 0, 0, 1, 1, 0, 0, 0, 0, 0,  //   4
     0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  //   5
     1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  //   6
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   7
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   8
     0, 0, 1, 0, 0, 0, 0, 0, 0, 0,  //   9
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   10
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  //   11
     0, 0, 0, 0, 0, 0, 0, 0 };      //   12

//clearer define but with more cycles per execution.
//#define ISSPECIAL(cc) ( ((cc) > L'\\') ? FALSE : ___isspecial[(cc)] )
//less clear but the fastest!
#define ISSPECIAL(cc) (((cc) & 0xff80) ? FALSE : ___isspecial[(cc)])

__forceinline BOOL
IsUnescapedDNSepChar (
        const WCHAR *pBase,
        const WCHAR *pCurrent
        )
/*++

Description:
    Returns TRUE if the character pointed at by pCurrent is an unescaped DN
    separator character.


Assumptions:
    pBase is the beginning of a DSName string, pCurrent points somewhere in that
    string.  pBase cannot begin with an escape character.

--*/
{
    DWORD numEscapes=0;

    if(!IsDNSepChar(*pCurrent)) {
        // Not even a separator, much less an escaped one.
        return FALSE;
    }

    // OK, it's a separator character.  Let's see if it is escaped.
    pCurrent--;
    while(pCurrent >= pBase && *pCurrent == L'\\') {
        // yet another escape character
        numEscapes++;
        pCurrent--;
    }
    if(pCurrent < pBase) {
        // Huh? escapes all the way back to the beginning of the string?
        // That isn't legal, since we need a tag, not just a value.
        return FALSE;
    }

    // An odd number of escapes means that the last escape pairs with the
    // DNSepChar we found.  An even number of escapes means that the escapes
    // pair up with themselves, so the DNSepChar we found is real.
    return (!(numEscapes & 1));
}

__forceinline BOOL
IsUnescapedChar (
        const WCHAR *pBase,
        const WCHAR *pCurrent,
        const WCHAR CharToCheck
        )
/*++

Description:
    Returns TRUE if the character pointed at by pCurrent is an unescaped 
    CharToCheck (quote or space or \n)


Assumptions:
    pBase is the beginning of a DSName string, pCurrent points somewhere in that
    string.

--*/
{
    DWORD numEscapes=0;

    Assert(pCurrent >= pBase);
    if(*pCurrent != CharToCheck) {
        // Not even a quote, much less an escaped one.
        return FALSE;
    }

    // OK, it's a char we are looking for.  Let's see if it is escaped.
    pCurrent--;
    while(pCurrent >= pBase && *pCurrent == L'\\') {
        // yet another escape character
        numEscapes++;
        pCurrent--;
    }
    if(pCurrent < pBase) {
        // Huh? escapes all the way back to the beginning of the string?
        // That isn't legal, since we need a tag, not just a value.
        return FALSE;
    }

    // An odd number of escapes means that the last escape pairs with the
    // char we found.  An even number of escapes means that the escapes
    // pair up with themselves, so the char we found is real.
    return (!(numEscapes & 1));
}

/*++ StepToNextDNSep
 *
 * Given a pointer into string DN, this routine returns a pointer to the
 * next DN separator, paying attention to quoted values.  It also skips the
 * first character if it is a separator.
 *
 * INPUT:
 *    pString   - pointer into string DN
 *    pLastChar - Last non-NULL character of the string
 *    ppNextSep - pointer to pointer to receive pointer to next sep
 * OUTPUT:
 *    ppNextSep filled in
 * RETURN VALUE:
 *    0         - success
 *    non-0     - DIRERR code
 */
unsigned StepToNextDNSep(const WCHAR * pString,
                         const WCHAR * pLastChar,
                         const WCHAR **ppNextSep,
                         const WCHAR **ppStartOfToken,
                         const WCHAR **ppEqualSign)
{
    const WCHAR * p;
    BOOL inQuote = FALSE;
    BOOL fDone = FALSE;

    p = pString;

    if((*p == L',') || (*p == L';')) {
        p++;                            // we want to step past this sep
    }

    // Skip leading spaces.
    while (*p == L' ' || *p == L'\n') {
        p++;
    }

    if(ppStartOfToken) {
        *ppStartOfToken = p;
    }
    if(ppEqualSign) {
        *ppEqualSign = NULL;
    }

    while ((fDone == FALSE) && (p <= pLastChar)) {
        switch (*p) {
          case L'"':            // start (or end) of a quoted chunk
            inQuote = !inQuote;
            ++p;
            break;

          case L'\\':           // one off escape
            ++p;                // so skip an extra character
            if (p > pLastChar) {
                return DIRERR_NAME_UNPARSEABLE;
            }
            ++p;
            break;

          case L',':            // a DN separator
          case L';':
            if (inQuote) {
                ++p;
            }
            else {
                fDone = TRUE;
            }
            break;

          case L'=':            // maybe an equal separating tag and value
            if (!inQuote && ppEqualSign) {
                *ppEqualSign = p;
            }
            ++p;
            break;

          case L'\0':

            if ( inQuote ) {
                p++;
            } else {
                // we don't allow unescaped/unquoted NULL chars in DNs
                return DIRERR_NAME_UNPARSEABLE;
            }
            break;

          default:
            ++p;
        }
    }

    Assert(p <= (pLastChar+1));

    if (inQuote) {              // did we end inside a quote?
        return DIRERR_NAME_UNPARSEABLE;
    }
    else {                      // otherwise things were ok
        *ppNextSep = p;
        return 0;
    }
} // StepToNextDNSep


DWORD
TrimDSNameBy(
       DSNAME *pDNSrc,
       ULONG cava,
       DSNAME *pDNDst
       )
/*++

Routine Description:

    Takes in a dsname and copies the first part of the dsname to the
    dsname it returns.  The number of AVAs to remove are specified as an
    argument.

Arguments:

    pDNSrc - the source Dsname

    cava - the number of AVAs to remove from the first name

    pDNDst - the destination Dsname

Return Values:

    0 if all went well, the number of AVAs we were unable to remove if not

 N.B. This routine is exported to in-process non-module callers
--*/
{
    PWCHAR pTmp, pSep, pLast;
    unsigned len;
    unsigned err;

    // If they're trying to shorten a nameless DN (i.e. the root or guid- or sid-based DN), bail out
    if (pDNSrc->NameLen == 0) {
        return cava;
    }

    memset(pDNDst, 0, sizeof(DSNAME));

    pTmp = pDNSrc->StringName;
    pLast = pTmp + pDNSrc->NameLen - 1;
    len = 0;

    do {
        err = StepToNextDNSep(pTmp, pLast, &pSep, NULL, NULL);
        if (err) {
            return cava;        // this was as far as we got
        }
        pTmp = pSep;
        --cava;
    } while (cava && *pSep);

    if (cava) {
        // We ran out of name before we ran out of AVAs
        return cava;
    }

    if (*pTmp == L'\0') {
        // we threw away everything, so now we have the root
        pDNDst->NameLen = 0;
    }
    else {

        //
        // skip separator
        //

        ++pTmp;

        //
        // remove white spaces
        //

        while ((*pTmp == L' ') || (*pTmp == L'\n')) {
            pTmp++;
        }

        len = (unsigned int)(pTmp - pDNSrc->StringName);
        pDNDst->NameLen = pDNSrc->NameLen - len;
        memcpy(pDNDst->StringName, pTmp, pDNDst->NameLen*sizeof(WCHAR));
        pDNDst->StringName[pDNDst->NameLen] = L'\0';
    }

    pDNDst->structLen = DSNameSizeFromLen(pDNDst->NameLen);

    return 0;
}

// Returns TRUE if this is the root
// In a perfect world root would always have a name length of 0
BOOL IsRoot(const DSNAME *pName)
{
    if (    (   (0 == pName->NameLen)
             || ((1 == pName->NameLen) && (L'\0' == pName->StringName[0])) )
         && fNullUuid(&pName->Guid)
         && (0 == pName->SidLen) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

unsigned
CountNameParts(
            const DSNAME *pName,
            unsigned *pCount
            )
/*++

Routine Description:

    Returns a count of name parts (i.e., the level).

Arguments:

    pName - pointer to DSNAME to evaluate
    pCount - pointer to be filled with part count

Return Values:

    0 - success, non-zero DIRERR error code

    N.B. This routine is exported to in-process non-module callers
--*/
{
    unsigned c;
    const WCHAR *p, *q, *pLast;
    PWCHAR tokenStart;
    unsigned err;

    if (IsRoot(pName)) {
        *pCount = 0;
        return 0;
    }

    c = 0;
    p = pName->StringName;
    pLast = p + pName->NameLen - 1;

    do {
        err = StepToNextDNSep(p, pLast, &q, &tokenStart, NULL);
        if (err) {
            // couldn't find a separator
            return err;
        }

        //
        // empty name part (should never have sequential separators)
        //

        if ( tokenStart == q ) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        ++c;
        p = q;
    } while (*p);

    *pCount = c;
    return 0;

} // CountNameParts


/*++ GetRDNInfo
 *
 *  Given a pointer to a string DN, returns type and value information
 *  about the RDN.  The caller must provide a buffer that is MAX_RDN_SIZE
 *  long in order to receive the RDN value.
 *
 * INPUT
 *   pDN      - pointer to string DN
 *   pRDNVal  - pointer to a buffer to fill in with the RDN value
 * OUTPUT
 *   pRDNVal  - filled in with address of start of value portion of RDN
 *              in the input string DN
 *   pRDNlen  - filled in with the count of characters in the RDN value
 *   pRDNtype - filled in with the attribute type of the RDN
 * RETURN VALUE
 *   0 on success, DIRERR code on error
 */
#ifdef CLIENT_SIDE_DN_PARSING
unsigned GetRDNInfoLame(
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype)
{
    WCHAR * pTmp, *pRDNQuotedVal, *pLast;
    unsigned i;
    unsigned ccKey, ccQuotedVal;
    unsigned err;

    Assert(!IsRoot(pDN));

    i = 0;

    // Determine length of RDN

    pLast = (PWCHAR)pDN->StringName + pDN->NameLen - 1;
    err = StepToNextDNSep(pDN->StringName, pLast, &pTmp, NULL, NULL);
    if (err) {
        return err;
    }

    i = (unsigned)(pTmp - pDN->StringName);
    Assert(i <= pDN->NameLen);

    // Use existing routine to parse out key and value

    err = GetTopNameComponent(pDN->StringName,
                              i,
                              &pTmp,
                              &ccKey,
                              &pRDNQuotedVal,
                              &ccQuotedVal);
    if (err) {
        return err;
    }

    // Convert the key string into an ATTRTYP.  Caller could
    // be trying to parse a garbage name in which case name component
    // pointer is NULL and/or name component count is zero.

    if ( (NULL == pTmp) || (0 == ccKey) )
    {
        return DIRERR_NAME_UNPARSEABLE;
    }
    else
    {
        // Caller may want the RDN, not the type. For example,
        // when syntactically cracking a FQDN into a canonical name.
        if (pRDNtype) {
            *pRDNtype = KeyToAttrTypeLame(pTmp, ccKey);
            if (*pRDNtype == 0) {
                return DIRERR_NAME_TYPE_UNKNOWN;
            }
        }

        // Unquote the value
        if(!ccQuotedVal) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        // caller may want the rdnType, not the RDN
        if (pRDNVal) {
            *pRDNlen = UnquoteRDNValue(pRDNQuotedVal, ccQuotedVal, pRDNVal);
            if (*pRDNlen == 0) {
                return DIRERR_NAME_UNPARSEABLE;
            }
        }
    }

    return 0;
}
#else
unsigned GetRDNInfo(THSTATE *pTHS,
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype)
/*++

Description:

    Gets the RDN Value, RDN Length of the RDN Value, and the 
    ATTRTYP of the top most (i.e. first RDN) from the given
    DN.

Arguments:
    pTHS (IN) - 
    pDN (IN) - DSNAME of DN to get the first RDN info of
    pRDNVal (OUT) -  pointer to a buffer large enough for the RDN
        value.  Usually an array of MAX_RDN_SIZE size is used.
    pRDNlen (OUT) - count of characters used in pRDNVal 
    pRDNtype (OUT) - ATTRTYP for the RDN.

Return Value:

    Win32 Error

--*/
{
    WCHAR * pTmp, *pRDNQuotedVal, *pLast;
    unsigned i;
    unsigned ccKey, ccQuotedVal;
    unsigned err;

    Assert(!IsRoot(pDN));

    i = 0;

    // Determine length of RDN

    pLast = (PWCHAR)pDN->StringName + pDN->NameLen - 1;
    err = StepToNextDNSep(pDN->StringName, pLast, &pTmp, NULL, NULL);
    if (err) {
        return err;
    }

    i = (unsigned)(pTmp - pDN->StringName);
    Assert(i <= pDN->NameLen);

    // Use existing routine to parse out key and value

    err = GetTopNameComponent(pDN->StringName,
                              i,
                              &pTmp,
                              &ccKey,
                              &pRDNQuotedVal,
                              &ccQuotedVal);
    if (err) {
        return err;
    }

    // Convert the key string into an ATTRTYP.  Caller could
    // be trying to parse a garbage name in which case name component
    // pointer is NULL and/or name component count is zero.

    if ( (NULL == pTmp) || (0 == ccKey) )
    {
        return DIRERR_NAME_UNPARSEABLE;
    }
    else
    {
        *pRDNtype = KeyToAttrType(pTHS, pTmp, ccKey);
        if (*pRDNtype == 0) {
            return DIRERR_NAME_TYPE_UNKNOWN;
        }

        // Unquote the value
        if(!ccQuotedVal) {
            return DIRERR_NAME_UNPARSEABLE;
        }

        // caller may want the rdnType, not the RDN
        if (pRDNVal) {
            *pRDNlen = UnquoteRDNValue(pRDNQuotedVal, ccQuotedVal, pRDNVal);
            if (*pRDNlen == 0) {
                return DIRERR_NAME_UNPARSEABLE;
            }
        }
    }

    return 0;
}
#endif

unsigned GetRDNInfoExternal(
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype)
{

#ifndef CLIENT_SIDE_DN_PARSING
    THSTATE *pTHS = (THSTATE*)pTHStls;

    return GetRDNInfo(pTHS,
                      pDN,
                      pRDNVal,
                      pRDNlen,
                      pRDNtype);
#else
    return GetRDNInfoLame(
                      pDN,
                      pRDNVal,
                      pRDNlen,
                      pRDNtype);
#endif
} // GetRDNInfoExternal


/*++ GetRDN
 *
 * Return the address and length of the first RDN in the specified DN
 * and the address and length of the rest of the DN.
 *
 * The RDN values are assumed to be quoted. Use UnQuoteRDN to create
 * a printable value.
 *
 * INPUT
 *   ppDN   - pointer to pointer to DN
 *   pccVal - pointer to count of characters in DN
 *
 * OUTPUT
 *   ppDN   - ponter to pointer to rest of DN; undefined if *pccDN is 0
 *   pccDN  - ponter to count of rest of characters in DN
 *   ppKey  - pointer to pointer to Key in DN; undefined if *pccKey is 0
 *   pccKey - pointer to count of characters in Key
 *   ppVal  - pointer to pointer to Val in DN; undefined if *pccVal is 0
 *   pccVal - pointer to count of characters in Val
 *
 * RETURN VALUE
 *   0      - OKAY, output params are defined
 *   non-0  - ERROR, output params are undefined.
 *
 * N.B. This routine is exported to in-process non-module callers
 */

unsigned GetRDN(const WCHAR **ppDN,
                unsigned    *pccDN,
                const WCHAR **ppKey,
                unsigned    *pccKey,
                const WCHAR **ppVal,
                unsigned    *pccVal)
{
    unsigned dwErr;
    unsigned ccRDN;
    WCHAR *pToken;
    WCHAR *pLast;

    // initialize output params
    *pccKey = 0;
    *pccVal = 0;

    // nothing to do
    if (*pccDN == 0) {
        return 0;
    }

    // determine length of RDN (skipping leading separators)
    pLast = (WCHAR *)(*ppDN + (*pccDN - 1));
    dwErr = StepToNextDNSep(*ppDN, pLast, ppDN, &pToken, NULL);
    if (dwErr) {
        return dwErr;
    }
    ccRDN = (unsigned)(*ppDN - pToken);

    // Use existing routine to parse out key and value
    dwErr = GetTopNameComponent(pToken,
                                ccRDN,
                                ppKey,
                                pccKey,
                                ppVal,
                                pccVal);
    if (dwErr) {
        return dwErr;
    }

    *pccDN = (unsigned)(pLast - *ppDN) + 1;
    return 0;
}


/*++ AppendRDN - Append an RDN to an existing DSNAME
 *
 * INPUT:
 *   pDNBase - name to append to
 *   pDNNew  - pointer to buffer to fill in with new name, must be preallocated
 *   ulBufSize - size of pDNNew buffer, in bytes
 *   pRDNVal - RDN value, in raw unquoted form
 *   RDNlen  - length of RDN value in wchars, 0 means null terminated
 *   AttId   - id of attribute in RDN
 *
 * RETURN VALUE
 *   0       - no error
 *   -1      - invalid argument
 *   non-0   - minimum size required for output buffer.
 *
 * N.B. This routine is exported to in-process non-module callers
 */
unsigned AppendRDN(DSNAME *pDNBase,
                   DSNAME *pDNNew,
                   ULONG  ulBufSize,
                   WCHAR *pRDNVal,
                   ULONG RDNlen,
                   ATTRTYP AttId)
{
    WCHAR * pTmp;
    int i;
    int quotesize;
    ULONG ulBufNeeded, ccRemaining;

    // make sure people don't pass GUID or SID-based DNs
    Assert(IsRoot(pDNBase) || pDNBase->NameLen > 0);
    Assert(pDNBase->StringName[pDNBase->NameLen] == L'\0');

    if (RDNlen == 0) {
        RDNlen = wcslen(pRDNVal);
    }

    ulBufNeeded = pDNBase->structLen + (RDNlen + 4) * sizeof(WCHAR);
    if (ulBufSize < ulBufNeeded) {
        return ulBufNeeded;
    }

    memset(pDNNew, 0, sizeof(DSNAME));

    i = AttrTypeToKey(AttId, pDNNew->StringName);
    if (i != 2) {
        if (i == 0) {
            // unknown attrtype
            return -1;
        }
        ulBufNeeded += (i - 2)*sizeof(WCHAR);
        if (ulBufSize < ulBufNeeded) {
            return ulBufNeeded;
        }
    }
    pDNNew->StringName[i++] = L'=';

    Assert(ulBufSize > DSNameSizeFromLen(i));
    ccRemaining = (ulBufSize - DSNameSizeFromLen(i)) / sizeof(WCHAR);
    quotesize = QuoteRDNValue(pRDNVal,
                              RDNlen,
                              &pDNNew->StringName[i],
                              ccRemaining);

    if ((unsigned)quotesize <= ccRemaining) {
        i += quotesize;
    } else {
        return DSNameSizeFromLen(pDNBase->NameLen + quotesize + 2);
    }

    if (IsRoot(pDNBase)) {
        pDNNew->StringName[i] = L'\0';
        pDNNew->NameLen = i;
    }
    else {
        Assert(   (0 == pDNBase->NameLen)
               || (pDNBase->StringName[pDNBase->NameLen-1] != L'\0'));

        if ( 0 != pDNBase->NameLen )
            pDNNew->StringName[i++] = L',';

        ulBufNeeded = DSNameSizeFromLen(i + pDNBase->NameLen);
        if (ulBufSize < ulBufNeeded) {
            return ulBufNeeded;
        }

        memcpy(&pDNNew->StringName[i],
               pDNBase->StringName,
               (pDNBase->NameLen+1)*sizeof(WCHAR));
        pDNNew->NameLen = i + pDNBase->NameLen;
        // pDNNew->StringName was copied with the terminating NULL
    }

    pDNNew->structLen = DSNameSizeFromLen(pDNNew->NameLen);
    return 0;
}

/*++GetTopNameComponent
 *
 * Given a pointer to a string name, returns the information about the
 * key string and quoted value for the top level naming RDN.  The pointers
 * returned are pointers into the DN string.  Note that the RDN value
 * must be unquoted before being used.
 *
 * INPUT
 *    pName  - pointer to the string name
 *    ccName - count of characters in the name
 * OUTPUT
 *    ppKey  - filled in with pointer to the Key portion of the top RDN
 *    pccKey - filled in with count of characters in Key
 *    ppVal  - filled in with pointer to the Value portion of the top RDN
 *    pccVal - filled in with count of characters in Value
 * RETURN VALUE
 *    0      - success
 *    0, but all output parameters also 0 - name is root
 *    non-0  - name is unparseable, value is direrr extended error
 */
unsigned
GetTopNameComponent(const WCHAR * pName,
                    unsigned ccName,
                    const WCHAR **ppKey,
                    unsigned *pccKey,
                    const WCHAR **ppVal,
                    unsigned *pccVal)
{
    const WCHAR *pTmp;
    unsigned len, lTmp;

    *pccKey = *pccVal = 0;
    *ppKey = *ppVal = NULL;

    if (ccName == 0) {
        // root
        return 0;
    }

    // Set up a pointer to the end of the string dsname.
    pTmp = pName + ccName - 1;

    // First, skip any trailing space, as it can never be interesting
    while (ccName > 0 &&
           (IsUnescapedChar(pName, pTmp, L' ') ||
            IsUnescapedChar(pName, pTmp, L'\n'))) {
        --pTmp;
        --ccName;
    }

    if(!ccName) {
        // Only spaces, this is also root.
        return 0;
    }
    if (*pTmp == L'\0') {
        // We don't allow unescaped NULL chars inside DNs
        return DIRERR_NAME_UNPARSEABLE;
    }

    // Now, see if those spaces were spaces after a separator, and skip the
    // separator if they were.
    if (IsUnescapedDNSepChar(pName,pTmp)) {
        // OK, the next character is also uninteresting to us, and we should
        // ignore it.
        --ccName;
        --pTmp;

        // Since we just ate a separator, we should now skip trailing spaces
        // (these spaces must be in between an RDN value and an RDN separator in
        // a valid DSName, i.e. "cn=foo  ,"

        while (ccName > 0 &&        // ignore trailing spaces
               (IsUnescapedChar(pName, pTmp, L' ') ||
                IsUnescapedChar(pName, pTmp, L'\n'))) {
            --pTmp;
            --ccName;
        }

        if (ccName == 0) {
            // Return success, even for strings like "    ,    ".
            return 0;
        }
    }


    if(pTmp == pName) {
        // Case where all we had was a single character + 0 or more whitespace.
        // This is unparsable.
        return DIRERR_NAME_UNPARSEABLE;
    }

    Assert(pTmp > pName);

    // step backwards to find the previous DN separator, paying attention
    // to the possibility of escaped or quoted values, and the possibility
    // that this is first component, and hence we'll run out of string
    // without encountering a separator.

    len = 1;
    do {
        if (IsUnescapedChar(pName, pTmp, L'"')) {
            // this should be the end of a quoted string, so walk back
            // looking for the start of the quote, ignoring everything
            // else along the way
            do {
                --pTmp;
                ++len;
                if (pTmp <= pName) {
                    // we walked till the beginning of the string.
                    // Even if the current char is a quote, it is still
                    // a bad DN, since we also need a key and a '='
                    return DIRERR_NAME_UNPARSEABLE;
                }
            } while (!IsUnescapedChar(pName, pTmp, L'"'));
        }
        --pTmp;
        ++len;
        if (IsUnescapedDNSepChar(pName,pTmp)) {
            if (pTmp <= pName) {
                // first char in name is a separator?  get real
                return DIRERR_NAME_UNPARSEABLE;
            }
            else {
                // we must be sitting directly on top of a separator char,
                // so step forward one to get to the first char after.
                ++pTmp;
                --len;
                // and break out of the loop -- we have found the beginning
                // of the AVA pair
                break;
            }
        }
    } while (pTmp > pName);

    // Now, we have found the beginning of the key=value pair.
    // Step forward and parse key, equal sign and the value.

    // step over any leading spaces
    // Not checking len>0 since we know the DN is NULL-terminated
    while (*pTmp == L' ' || *pTmp == L'\n') {
        ++pTmp;
        --len;
    }

    // Ok, pTmp is now pointing to the start of the AVA, and len is the
    // count of characters remaining until the last non-blank.  Step forward
    // until we find the equal sign that marks the break between the
    // key and the value.

    *ppKey = pTmp;

    lTmp = 0;
    while (!ISSPECIAL(*pTmp) && len) {
        ++pTmp;
        --len;
        ++lTmp;
    }

    if (len == 0 || lTmp == 0 || *pTmp != L'=') {
        // Either we ran all the way through the component string without
        // finding an equal, or the very first character we encountered was
        // an equal, or we encountered some special character other than
        // an equal that is not allowed in the key component.  In any case,
        // this is bad, and we'll complain.
        return DIRERR_NAME_UNPARSEABLE;
    }

    *pccKey = lTmp;

    // step over the equal separator
    Assert(*pTmp == L'=');
    ++pTmp;
    --len;

    // step over leading whitespace in the value
    // not checking for len>0 since DN is NULL-terminated
    while (*pTmp == L' ' || *pTmp == L'\n') {
        ++pTmp;
        --len;
    }

    if (len == 0) {
        // we ran out of component without ever encountering a non-blank
        return DIRERR_NAME_UNPARSEABLE;
    }
    
    *ppVal = pTmp;
    *pccVal = len;

    return 0;
}

/*++ QuoteRDNValue
 *
 * This routine will perform adequate quoting of a value so that it
 * can be embedded as an RDN value in a string DN.  The output buffer
 * must be preallocated.
 *
 * INPUT
 *   pVal   - pointer to raw value
 *   ccVal  - count of characters in value
 *   pQuote - pointer to output buffer
 *   ccQuoteBufMax - size of output buffer in chars
 * OUTPUT
 *   pQuote - filled in with quoted value
 * RETURN VALUE
 *   0      - invalid input
 *   non-0  - count of characters used in quoted string.  If larger than
 *            ccQuoteBufMax then the quoting was incomplete, and the
 *            routine must be called again with a larger buffer
 *
 * N.B. This routine is exported to in-process non-module callers
 */
unsigned QuoteRDNValue(const WCHAR * pVal,
                       unsigned ccVal,
                       WCHAR * pQuote,
                       unsigned ccQuoteBufMax)
{
    unsigned u;
    const WCHAR *pVCur;
    WCHAR *pQCur;
    int iBufLeft;

    //
    // No input params? Return error.
    //
    if( (pVal == NULL) || (ccVal == 0) ) {
        return 0;
    }

    //
    // Spaces at the beginning or end of the RDN require escaping.
    //
    if( (*pVal == L' ') || (*(pVal+ccVal-1) == L' ') ) {
        goto FullQuote;
    }

    //
    // Assume no escaping is needed and move RDN into the output buffer
    //
    pVCur = pVal;
    pQCur = pQuote;
    iBufLeft = (int) ccQuoteBufMax;

    for (u=0; u < ccVal; u++) {

        if (   (*pVCur == L'\0')
            || ISSPECIAL(*pVCur)) {
            goto FullQuote;
        }
        if (iBufLeft > 0) {
            *pQCur = *pVCur;
            --iBufLeft;
        }
        ++pQCur;
        ++pVCur;
    }

    //
    // If there is space, add a terminating NULL so that the returned
    // value can be printed. As a courtesy to the caller.
    //
    if (iBufLeft > 0) {
        *pQCur = L'\0';
    }

    // If we get to here, we have transcribed the value, which did not
    // need any escaping;
    return ccVal;

FullQuote:

    // If we get to here, we have discovered that at least one character
    // in the value needs escaping.

    pQCur = pQuote;
    pVCur = pVal;
    iBufLeft = (int) ccQuoteBufMax;

    // escape the first leading space if any.
    if (L' ' == *pVCur && iBufLeft > 1 && ccVal > 1) {
            *pQCur++ = L'\\';
            *pQCur++ = L' ';
            iBufLeft -= 2;
            pVCur++;
            ccVal--;
    }
    for (u=0; u<ccVal; u++) {
        if (ISSPECIAL(*pVCur)) {
            if (iBufLeft > 0) {
                *pQCur = L'\\';
                --iBufLeft;
            }
            ++pQCur;
        }
        if (L'\n' == *pVCur || L'\r' == *pVCur) {
            // escape newlines and carriage returns because
            // it makes life easier on applications like
            // ldifde that need to represent DN's in text files
            // where these characters are delimiters.  Since
            // this is not one of the special characters
            // listed in RFC2253 it must be escaped with its
            // hex character code.
            if (iBufLeft > 0) {
                *pQCur++ = L'0';
                --iBufLeft;
            }
            if (iBufLeft > 0) {
                if (L'\n' == *pVCur) {
                    *pQCur = L'A';
                } else {
                    *pQCur = L'D';
                }
                --iBufLeft;
            }
        } else {
            if (iBufLeft > 0) {
                *pQCur = *pVCur;
                --iBufLeft;
            }
        }
        ++pQCur;
        ++pVCur;
    }
    // Check for a trailing space that requires escaping.
    if (L' ' == *(pVCur-1)) {
        if (iBufLeft > 0) {
            *(pQCur-1) = L'\\';
            *pQCur = L' ';
            --iBufLeft;
        }
        ++pQCur;
    }

    //
    // If there is space, add a terminating NULL so that the returned
    // value can be printed. As a courtesy to the caller.
    //
    if (iBufLeft > 0) {
        *pQCur = L'\0';
    }

    return (unsigned)(pQCur - pQuote);

}


/*++ UnquoteRDNValue
 *
 * This routine will perform adequate unquoting of a value so that it
 * cannot be embedded as an RDN value in a string DN.  The output buffer
 * must be preallocated and is assumed to be at least MAX_RDN_SIZE chars
 * in length.
 *
 * INPUT
 *   pQuote  - pointer to quoted value
 *   ccQuote - count of characters in quoted value
 *   pVal    - pointer to output buffer
 * OUTPUT
 *   pVal    - filled in with raw value
 * RETURN VALUE
 *   0       - failure
 *   non-0   - count of chars in value
 */
unsigned UnquoteRDNValue(const WCHAR * pQuote,
                         unsigned ccQuote,
                         WCHAR * pVal)
{
    const WCHAR * pQCur;
    WCHAR *pVCur;
    unsigned u = 0;
    unsigned vlen = 0;
    unsigned unencodedLen;
    WCHAR szHexVal[3];
    

    //
    // Invalid params. Return error (or assert in CHK builds).
    //
    Assert(pQuote);
    Assert(pVal);
    if (pQuote == NULL || pVal == NULL) {
        return 0;
    }

    if ( !ccQuote )
        return 0;

    pQCur = pQuote;
    pVCur = pVal;

    while (*pQCur == L' '  ||
           *pQCur == L'\n' ||
           *pQCur == L'\r'   ) {
        ++pQCur;                // step over leading spaces
        if (++u > ccQuote) {
            return 0;
        }
    }

    if (*pQCur == L'"') {       // "quoted values"
        ++pQCur;                // step over open quote
        if (++u > ccQuote) {
            return 0;
        }
        do {
            if (*pQCur == L'\\') {
                ++pQCur;
                if (++u > ccQuote) {
                    return 0;
                }
            }
            if(vlen == MAX_RDN_SIZE) {
                // Oops, we were already maxed out.
                return 0;
            }
            *pVCur++ = *pQCur++;
            if (++u > ccQuote) {
                return 0;
            }
            ++vlen;
        } while (*pQCur != L'"');

        ++pQCur;
        ++u;
        while (u < ccQuote) {
            switch (*pQCur) {
              case L' ':        // extra whitespace is ok
              case L'\n':
              case L'\r':
                break;

              default:          // more junk after the value is not
                return 0;
            }
            ++pQCur;
            ++u;
        }

        //
        // Unsuccessful conversion; give up
        //
        if (vlen != (unsigned)(pVCur - pVal)) {
            return 0;
        }

    }
    else if (*pQCur == L'#') {  // #hex string
        WCHAR acTmp[3];
        UCHAR * pTmpBuf = (PUCHAR)malloc(ccQuote); // more than needed
        UCHAR * pUTF = pTmpBuf;
        if (!pUTF) {
            return 0;       //fail to malloc
        }
        vlen = 0;
        acTmp[2] = 0;
        ++pQCur;                // step over #
        ++u;
        while (u < ccQuote) {
            if (u == ccQuote-1) {
                free(pTmpBuf);
                return 0;       // odd char count
            }

            acTmp[0] = towlower(*pQCur++);
            acTmp[1] = towlower(*pQCur++);
            u += 2;
            if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                pUTF[vlen++] = (char) wcstol(acTmp, NULL, 16);
            }
            else {
                free(pTmpBuf);
                return 0;  // non-hex digit
            }

        }

        // ok, we now have a buffer of <vlen> characters which must be an ASN.1
        // BER encoding of a string.  Let's verify.

        if(vlen < 3) {
            // we need at least three bytes of vlen, one for the magic 4, one
            // for a length, and one for a value.
            free(pTmpBuf);
            return 0;
        }

        // First byte must be 4, which is the magical value saying that this is
        // a BER encoded string
        if(*pUTF != 4) {
            free(pTmpBuf);
            return 0;
        }

        // OK, first byte was 4.  Skip the first byte.
        vlen--;
        pUTF++;
        // Now, the next part must encode a length.
        if(*pUTF & 0x80) {
            unsigned bytesInLen;
            // Because this byte has the high bit set, the low order bits tell
            // me how many of the following bytes are the length
            bytesInLen = *pUTF & 0x7f;
            pUTF++;
            vlen--;

            if((!bytesInLen) ||
               (bytesInLen > vlen) ||
               (bytesInLen > 4 )       ) {
                // Either this value is not one we can handle (we don't
                // handle values bigger than a DWORD or smaller than a byte)
                // -or- the buffer passed in doesn't have enough bytes to
                // actually hold the length we were told to expect.
                // In either case, we're sunk.
                free(pTmpBuf);
                return 0;
            }

            unencodedLen = 0;
            // OK, build the value, dealing with the byte-reversal
            for(;bytesInLen; bytesInLen--) {
                unencodedLen = (unencodedLen << 8) + *pUTF;
                pUTF++;
                vlen--;
            }
        }
        else {
            // Since the high order bit is not set, then this byte is the
            // length.
            unencodedLen = *pUTF;
            pUTF++;
            vlen--;
        }

        if((!vlen) ||
            // No length left for the buffer.  Bail
           (vlen != unencodedLen)) {
            // The decoded length didn't match the bytes we have left
            free(pTmpBuf);
            return 0;
        }

        // ok, we now have a value of <vlen> characters, presumably in
        // UTF8, which we now need to convert into Unicode, because all
        // we can deal with are strings.

        // Note that if the WideChar version is > MAX_RDN_SIZE, the call will
        // fail, and vlen == 0
        vlen = MultiByteToWideChar(CP_UTF8,
                                   0,
                                   pUTF,
                                   vlen,
                                   pVal,
                                   MAX_RDN_SIZE);
        free(pTmpBuf);
    }
    else {                      // normal value
        // step along, copying characters
        do {
            if (*pQCur == L'\\') { // char is a pair
                ++pQCur;
                ++u;
                if ( (u < ccQuote) &&
                    ( ISSPECIAL(*pQCur)     //It's a special character
                      || ( (*pQCur == L' ') &&//It's a leading or trailing space
                    ((pQCur==pQuote + 1) ||(pQCur==pQuote + ccQuote - 1)) ) )) {
                    if(vlen == MAX_RDN_SIZE) {
                        // Oops, we were already maxed out.
                        return 0;
                    }
                    *pVCur++ = *pQCur++;
                    ++u;
                    ++vlen;
                }
                else {
                    //Check to see if there are two hex digits
                    if( ((u + 1) < ccQuote) &&
                        iswxdigit( *pQCur ) &&
                        iswxdigit( *(pQCur + 1) ) )
                    {
                        int iByte;

                        if(vlen == MAX_RDN_SIZE) {
                            // Oops, we were already maxed out.
                            return 0;
                        }

                        // Copy into NULL terminated string of hex numbers.
                        szHexVal[0] = pQCur[0];
                        szHexVal[1] = pQCur[1];
                        szHexVal[2] = L'\0';
                        iByte = wcstoul( szHexVal, NULL, 16);
                        
                        *pVCur++ = (WCHAR)iByte;
                        pQCur += 2;
                        u += 2;
                        ++vlen;
                    }
                    else
                        return 0;   // unacceptable escape sequence
                }
            }
            else {              // char is normal stringchar
                if((vlen == MAX_RDN_SIZE) || // Oops, we were already maxed out.
                   ((ISSPECIAL(*pQCur)) &&   // char is special   
                   (L'#' != *pQCur))) {      // and is not a # which only matters
                                             // at the beginning of the value.

                    return 0;
                }
                *pVCur++ = *pQCur++;
                ++u;
                ++vlen;
            }
        } while (u < ccQuote);

        //
        // Unsuccessful conversion; give up
        //
        if (vlen != (unsigned)(pVCur - pVal)) {
            return 0;
        }

    }

    return vlen;

}

/* This function compares two DN's and returns TRUE if they match
 * N.B. This routine is exported to in-process non-module callers
 *
 * Moved here from mdname.c by Aaron Siegel (t-asiege)
 * CLIENT_SIDE_DN_PARSING #ifdefs also added by t-asiege
 */

int
NameMatched(const DSNAME *pDN1, const DSNAME *pDN2)
{
    // Check for an easily detected match, either because the GUIDs match
    // or because the string names are identical (modulo case).

    if (memcmp(&gNullUuid, &pDN1->Guid, sizeof(GUID)) &&
	memcmp(&gNullUuid, &pDN2->Guid, sizeof(GUID))) {
	// Both DNs have GUIDs...
	if (memcmp(&pDN1->Guid, &pDN2->Guid, sizeof(GUID))) {
	    // ...and they don't match
	    return FALSE;
	}
	else {
	    // ...and they match
	    return TRUE;
	}
    }

    // Check to see if the SIDs match, but only if we can't compare stringnames
    if (pDN1->SidLen &&
	pDN2->SidLen &&
	((0 == pDN1->NameLen) || (0 == pDN2->NameLen))) {
	// Both DNs have SIDs...
	if ((pDN1->SidLen != pDN2->SidLen) ||
	    memcmp(&pDN1->Sid, &pDN2->Sid, pDN1->SidLen)) {
	    // ...and they don't match
	    return FALSE;
	}
	else {
	    // ...and they match
	    return TRUE;
	}
    }

    return(NameMatchedStringNameOnly(pDN1, pDN2));
}

// N.B. This routine is exported to in-process non-module callers
int
NameMatchedStringNameOnly(const DSNAME *pDN1, const DSNAME *pDN2)
{
    unsigned count1, count2;
    WCHAR rdn1[MAX_RDN_SIZE], rdn2[MAX_RDN_SIZE];
    ATTRTYP type1, type2;
    ULONG rdnlen1, rdnlen2;
    ULONG len1, len2;
    WCHAR *pKey, *pQVal;
    DWORD ccKey, ccQVal;
    PVOID thsBlob = NULL;
    int i;

#ifndef CLIENT_SIDE_DN_PARSING
    THSTATE* pTHS = pTHStls;
#endif


    // Check to see if the string names are identical
    if ((pDN1->NameLen == pDN2->NameLen) &&
        (0 == memcmp(pDN1->StringName,pDN2->StringName, pDN1->NameLen*sizeof(WCHAR)))) {
        return TRUE;
    }

    // If we get to this point we are unable to determine name matching by
    // comparing fixed size DSNAME fields, and have determined that the
    // quoted strings for the two names are not identical.  However, since
    // the quoting mechanism is not one-to-one, there can be multiple
    // quoted representations for a single DN.  Therefore we now need to
    // check for less-obvious matches by breaking out the individual
    // name components and comparing them.  We try to do this in the most
    // efficient manner possible, by trying the most likely to fail comparisons
    // first.  Before any of that we've got to verify that we've really got
    // two string names to work with, though.
    if ((0 == pDN1->NameLen) || (0 == pDN2->NameLen)) {
        return FALSE;
    }

    // Check to see if the number of name parts differs.
    if (CountNameParts(pDN1, &count1) ||
        CountNameParts(pDN2, &count2) ||
        (count1 != count2)) {
        return FALSE;
    }
    // A quick extra check.  If the names have no parts (just blanks?) then
    // they match by definition
    if (0 == count1) {
        return TRUE;
    }

    // Check to see if the RDNs differ (names are more likely to differ
    // in RDN than in topmost component)
    if (GetRDNInfoExternal(pDN1, rdn1, &rdnlen1, &type1) ||
        GetRDNInfoExternal(pDN2, rdn2, &rdnlen2, &type2) ||
        (type1 != type2) ||
        (CSTR_EQUAL != CompareStringW(DS_DEFAULT_LOCALE,
                                      DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                      rdn1,
                                      rdnlen1,
                                      rdn2,
                                      rdnlen2))) {
        return FALSE;
    }

    // Sheesh.  These names aren't GUID comparable and the full strings
    // don't match, but they have the same number of name components and
    // their RDNs match.  Now we need to walk through the rest of the
    // components one by one to see if they match.  We walk from the top
    // down because that's the way the support routines work.  Note that
    // we only have to look at count1-1 components, because we already
    // compared the least significant RDN.  If the names have only one
    // component then this will be a zero trip loop.
    len1 = pDN1->NameLen;
    len2 = pDN2->NameLen;
    for (i=count1-1; i>0; i--) {
	// First one
	if (GetTopNameComponent(pDN1->StringName,
				len1,
				&pKey,
				&ccKey,
				&pQVal,
				&ccQVal)) {
	    // Can't be parsed? no match
	    return FALSE;
	}
	len1 = (ULONG)(pKey - pDN1->StringName);
#ifdef CLIENT_SIDE_DN_PARSING
	type1 = KeyToAttrTypeLame(pKey, ccKey);
#else
	type1 = KeyToAttrType (pTHS, pKey, ccKey);
#endif
	rdnlen1 = UnquoteRDNValue(pQVal, ccQVal, rdn1);

	// then the other
	if (GetTopNameComponent(pDN2->StringName,
				len2,
				&pKey,
				&ccKey,
				&pQVal,
				&ccQVal)) {
	    // Can't be parsed? no match
	    return FALSE;
	}
	len2 = (ULONG)(pKey - pDN2->StringName);
#ifdef CLIENT_SIDE_DN_PARSING
	type2 = KeyToAttrTypeLame(pKey, ccKey);
#else
	type2 = KeyToAttrType (pTHS, pKey, ccKey);
#endif
	rdnlen2 = UnquoteRDNValue(pQVal, ccQVal, rdn2);

	if ((type1 != type2) ||
            (CSTR_EQUAL != CompareStringW(DS_DEFAULT_LOCALE,
                                          DS_DEFAULT_LOCALE_COMPARE_FLAGS,
        				  rdn1,
        				  rdnlen1,
        				  rdn2,
        				  rdnlen2))) {
	    // RDNs don't match
	    return FALSE;
	}
    }

    // Well, we've exhausted every known way in which the names could
    // differ, so they must be the same
    return TRUE;
}

DWORD
MangleRDNWithStatus(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    )
/*++

Routine Description:

    Transform an RDN in-place into a unique RDN based on the associated
    object's GUID in order to eliminate name conflicts.

    Example:
        GUID = a746b716-0ac0-11d2-b376-0000f87a46c8
        Original RDN = "SomeName"

        New RDN = "SomeName#TAG:a746b716-0ac0-11d2-b376-0000f87a46c8", where
            '#' is the BAD_NAME_CHAR and TAG varies depending on eMangleFor.

    The BAD_NAME_CHAR is used to guarantee that no user-generated name could be
    in conflict, and the GUID is used to guarantee no system-generated name
    could be in conflict.

Arguments:

    eMangleFor (IN) - Reason for mangling the RDN; one of 
        MANGLE_OBJECT_RDN_FOR_DELETION, MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
        MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT, or MANGLE_PHANTOM_RDN_FOR_DELETION.

    pGuid (IN) - GUID of the object to rename.
    
    pszRDN (IN/OUT) - the RDN.  Buffer must be large enough to hold MAX_RDN_SIZE
        WCHARs.
    
    pcchRDN (IN/OUT) - size in characters of the RDN.

Return Values:

    DWORD - Win32 error status

--*/
{
    RPC_STATUS  rpcStatus;
    LPWSTR      pszGuid;
    LPWSTR      pszTag;
    LPWSTR      pszAppend;
    GUID        EmbeddedGuid;

    Assert(!fNullUuid(pGuid));

    rpcStatus = UuidToStringW(pGuid, &pszGuid);
    if (RPC_S_OK != rpcStatus) {
        Assert(RPC_S_OUT_OF_MEMORY == rpcStatus);
        return rpcStatus;
    }

    switch (eMangleFor) {
    default:
        Assert(!"Logic Error");
        // Fall through...
    case MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
    case MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT:
        pszTag = L"CNF";
        break;

    case MANGLE_OBJECT_RDN_FOR_DELETION:
    case MANGLE_PHANTOM_RDN_FOR_DELETION:
        pszTag = L"DEL";
        break;
    }
    
    if (IsMangledRDN(pszRDN, *pcchRDN, &EmbeddedGuid, NULL)) {
        // RDN is already mangled (but perhaps with a different tag).
        // Un-mangle it just before we mangle it again, so we don't end up
        // with mutliple manglings on the same RDN (e.g.,
        // "SomeName#CNF:a746b716-0ac0-11d2-b376-0000f87a46c8" \
        //      "#DEL:a746b716-0ac0-11d2-b376-0000f87a46c8").
        Assert(0 == memcmp(pGuid, &EmbeddedGuid, sizeof(GUID)));
        Assert(*pcchRDN > MANGLE_APPEND_LEN);
        *pcchRDN -= MANGLE_APPEND_LEN;
    }
    
    // Chop off trailing characters of RDN if necessary to hold appended data.
    Assert(MAX_MANGLE_RDN_BASE + MANGLE_APPEND_LEN <= MAX_RDN_SIZE);
    
    pszAppend = pszRDN + min(MAX_MANGLE_RDN_BASE, *pcchRDN);

    _snwprintf(pszAppend,
               MANGLE_APPEND_LEN,
               L"%c%s:%s",
               BAD_NAME_CHAR,
               pszTag,
               pszGuid);

    *pcchRDN = (DWORD)(pszAppend - pszRDN + MANGLE_APPEND_LEN);

    RpcStringFreeW(&pszGuid);

    return ERROR_SUCCESS;
}


BOOL
IsMangledRDN(
        IN  WCHAR * pszRDN,
        IN  DWORD   cchRDN,
        OUT GUID *  pGuid,
        OUT MANGLE_FOR *peMangleFor
    )
/*++

Routine Description:

    Detect whether an RDN has been mangled by a prior call to MangleRDN().
    If so, decode the embedded GUID and return it to the caller.

Arguments:

    pszRDN (IN) - The RDN.
    
    cchRDN (IN) - Size in characters of the RDN.

    pGuid (OUT) - On return, holds the decoded GUID if found.
    
    peMangleFor (OUT, OPTIONAL) - On return holds the type of mangling

Return Values:

    TRUE - RDN was mangled; *pGuid holds the GUID passed to MangleRDN().
    
    FALSE - The RDN was not mangled.

--*/
{
    BOOL        fDecoded = FALSE;
    LPWSTR      pszGuid;
    RPC_STATUS  rpcStatus;

#define SZGUIDLEN (36)
    if ((cchRDN > MANGLE_APPEND_LEN)
        && (BAD_NAME_CHAR == pszRDN[cchRDN - MANGLE_APPEND_LEN])) {
        WCHAR szGuid[SZGUIDLEN + 1];

        // The RDN has indeed been mangled; decode it.
        pszGuid = pszRDN + cchRDN - MANGLE_APPEND_LEN + 1 + MANGLE_TAG_LEN + 1;
        
        // Unfortunately the RDN is not null-terminated, so we need to copy and
        // null-terminate it before we can hand it to RPC.
        memcpy(szGuid, pszGuid, SZGUIDLEN * sizeof(szGuid[0]));
        szGuid[SZGUIDLEN] = L'\0';

        rpcStatus = UuidFromStringW(szGuid, pGuid);
        
        if (RPC_S_OK == rpcStatus) {
            if(peMangleFor) {
                LPWSTR pTag = pszRDN + cchRDN - MANGLE_APPEND_LEN + 1;
                if(!memcmp(pTag,
                           L"CNF",
                           MANGLE_TAG_LEN)) {
                    // Note: On a request to mangle for either
                    // MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT or
                    // MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT, 
                    // we use the string "CNF".  If you ask why here, we always
                    // map back to  MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT:
                    *peMangleFor= MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT;
                }
                else {
                    //pszTag = L"DEL";           
                    // MANGLE_OBJECT_RDN_FOR_DELETION
                    // MANGLE_PHANTOM_RDN_FOR_DELETION
                    *peMangleFor = MANGLE_OBJECT_RDN_FOR_DELETION;
                }
            }
            fDecoded = TRUE;
        }
        else {
#ifndef CLIENT_SIDE_DN_PARSING
            // Only report this when this code is used in the core, when all the callers
            // are expected to be well behaved
            Assert(RPC_S_OK == rpcStatus);
#endif
        }
    }

    return fDecoded;
}

BOOL IsMangledRDNExternal(
          WCHAR * pszRDN,
          ULONG   cchRDN,
          PULONG  pcchUnMangled OPTIONAL
          )
{
   GUID GuidToIgnore;
   MANGLE_FOR MangleForToIgnore;
   BOOL IsMangled = FALSE;


   IsMangled = IsMangledRDN(pszRDN,cchRDN,&GuidToIgnore,&MangleForToIgnore);

   if (ARGUMENT_PRESENT(pcchUnMangled)) {
       if (IsMangled) {
           *pcchUnMangled = cchRDN - MANGLE_APPEND_LEN;
       }
       else {
           *pcchUnMangled = cchRDN;
       }
   }

   return(IsMangled);
}


BOOL
IsMangledDSNAME(
    DSNAME *     IN   pDSName,
    MANGLE_FOR * OUT  peMangleFor
    )

/*++

Routine Description:

    Detect whether a DSNAME has a mangled component ANYWHERE in the name

Arguments:

    pDSName - 
    peMangleFor - (IN, OPTIONAL) If passed NULL, the routine will just 
        return whether or not the name is mangled at all, but if a pointer
        is passed, we'll return the type of mangling we found first.
        
Return Value:

    BOOL - TRUE for mangled, FALSE for unmangled, and 
        DIRERR_NAME_UNPARSEABLE if there is an error.

--*/

{
    ULONG cAVA=0,len,i;
    unsigned curlen = pDSName->NameLen;
    WCHAR * pKey, *pQVal;
    unsigned ccKey, ccQVal;
    WCHAR rdnbuf[MAX_RDN_SIZE];
    unsigned err;
    GUID EmbeddedGuid;

    err = CountNameParts(pDSName, &cAVA);
    if (err) {
        return FALSE;
    }
    if (cAVA == 0) {
        Assert(IsRoot(pDSName));
        return FALSE;
    }
    for (i=0; i<cAVA; i++) {
        Assert(curlen);

        // extract the most significant remaining name component
        err = GetTopNameComponent(pDSName->StringName,
                                  curlen,
                                  &pKey,
                                  &ccKey,
                                  &pQVal,
                                  &ccQVal);
        if (err) {
            return FALSE;
        }
        if (NULL == pKey) {
            // BUGBUG We return FALSE, even though we don't know,
            // if it's mangled or not.  Is this the safest thing?
            // We used to return ERROR_DS_NAME_UNPARSEABLE.
            return FALSE;
        }

        // shorten our view of the string name, which removes the
        // name component we got above
        curlen = (unsigned)(pKey - pDSName->StringName);

        len = UnquoteRDNValue(pQVal, ccQVal, rdnbuf);
        if (len == 0 || len > MAX_RDN_SIZE) {
            return FALSE;
        }

        if (IsMangledRDN(rdnbuf, len, &EmbeddedGuid, peMangleFor)) {
            // In the future, if the caller needs to know which component,
            // the embedded guid or the mangle type, we can return those

            return TRUE;
        }   
    }

    return FALSE;
} /* IsMangledDSNAME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\refcount.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       refcount.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <sddl.h>               // ConvertStringSecurityDescriptor...()

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>
#include <dsatools.h>           // needed for output allocation
#include <dsexcept.h>
#include <drs.h>
#include <filtypes.h>
#include <winsock2.h>
#include <lmaccess.h>                   // UF_* constants
#include <crypt.h>                      // password encryption routines
#include <cracknam.h>

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include <dsconfig.h>
#include <gcverify.h>
#include <ntdskcc.h>
#include "drautil.h"

// SAM interoperability headers
#include <mappings.h>
#include <samsrvp.h>            // for SampAcquireWriteLock()
#include <lmaccess.h>           // UF_ACCOUNT_TYPE_MASK

// Logging headers.
#include "dsevent.h"            // header Audit\Alert logging
#include "mdcodes.h"            // header for error codes

// Assorted DSA headers.
#include "objids.h"             // Defines for selected atts
#include "debug.h"              // standard debugging header
#define DEBSUB "REFCOUNT:"      // define the subsystem for debugging

// DRA headers.
#include <drameta.h>

#include <fileno.h>
#define  FILENO FILENO_LOOPBACK

#ifdef INCLUDE_UNIT_TESTS

// Exported from dbsubj.c.
extern GUID gLastGuidUsedToCoalescePhantoms;
extern GUID gLastGuidUsedToRenamePhantom;

// Note, these variables have the OPPOSITE name from what they really are.
// This is compensated for in Get/Remove/Add Property
ATTRTYP gLinkedAttrTyp = ATT_FSMO_ROLE_OWNER;
ATTRTYP gNonLinkedAttrTyp = ATT_MANAGER;

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Prototypes for routines from which to construct various tests.   //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
NewTest(
    CHAR            *TestName);

void
ReportTest(
    CHAR            *TestName);

typedef enum PropertyType {
    LinkedProperty,
    NonLinkedProperty
} PropertyType;

void
AddObject(
    DSNAME          *Name);

void
AddCrossRef(
    DSNAME  *pObject,
    DSNAME  *pNcName,
    LPWSTR   pszDnsRoot
    );

void
ModifyCrossRef(
    DSNAME  *pObject
    );

void
AddPropertyHost(
    DSNAME          *Name,
    PropertyType    type);

void
CommonAddObject(
    DSNAME  *pObject,
    ATTRTYP  ObjectClass);

void
AddProperty(
    DSNAME          *HostName, 
    DSNAME          *LinkedObjectName,
    PropertyType    type);

void
RemoveProperty(
    DSNAME          *HostName, 
    DSNAME          *LinkedObjectName,
    PropertyType    type);

DSNAME *
GetProperty(
    DSNAME *     pdnHost, 
    DWORD        iValue,
    PropertyType type);

DSNAME *
GetObjectName(
    DSNAME * pdn);

void
LogicallyDeleteObject(
    DSNAME          *Name);

void
PhysicallyDeleteObjectEx(
        DSNAME          *Name,
        DWORD           dwLine);

#define PhysicallyDeleteObject(a) PhysicallyDeleteObjectEx(a, __LINE__);

#define MakeObjectName(RDN) MakeObjectNameEx(RDN,TestRoot)
    
DSNAME *
MakeObjectNameEx(
    CHAR    *RDN,
    DSNAME  *pdnParent);

DSNAME *
MakeObjectNameEx2(
    CHAR    *RDN,
    DSNAME  *pdnParent);

DSNAME *
MakeObjectNameEx3(
    CHAR    *RDN
    );

void
FreeObjectName(
    DSNAME  *pDSName);

#define REAL_OBJECT         1
#define TOMBSTONE           2
#define PHANTOM             3
#define DOESNT_EXIST        4

void
VerifyStringNameEx(
        DSNAME *pObject,
        DWORD dwLine);

#define VerifyStringName(a) VerifyStringNameEx(a, __LINE__);

void
VerifyRefCountEx(
    DSNAME          *pObject, 
    DWORD           ObjectType, 
    DWORD           ExpectedRefCount,
    DWORD           dwLine);

#define VerifyRefCount(a,b,c) VerifyRefCountEx(a,b,c,__LINE__)

DWORD
GetTestRootRefCount();

BOOL
CheckRole(
    DSNAME *pRole
    );

void
_Fail(
    CHAR    *msg,
    DWORD   line);

#define Fail(msg) _Fail(msg, __LINE__);

#define DSNAME_SAME_STRING_NAME(a,b)                    \
    ((NULL != (a)) && (NULL != (b))                     \
     && !lstrcmpW((a)->StringName, (b)->StringName))

#define DSNAME_SAME_GUID_SID(a,b)                       \
    ((NULL != (a)) && (NULL != (b))                     \
     && !memcmp(&(a)->Guid, &(b)->Guid, sizeof(GUID))   \
     && ((a)->SidLen == (b)->SidLen)                    \
     && !memcmp(&(a)->Sid, &(b)->Sid, (a)->SidLen))

#define DSNAME_IDENTICAL(a,b) \
    (DSNAME_SAME_STRING_NAME(a,b) && DSNAME_SAME_GUID_SID(a,b))


//////////////////////////////////////////////////////////////////////
//                                                                  //
// Globals                                                          //
//                                                                  //
//////////////////////////////////////////////////////////////////////

#define TEST_ROOT_SIZE 2048
CHAR    TestRootBuffer[TEST_ROOT_SIZE];
DSNAME  *TestRoot = (DSNAME *) TestRootBuffer;
BOOL    fTestPassed;
BOOL    fVerbose = FALSE;

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Reference counting test routines.                                //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
ParentChildRefCountTest(void)
{
    DWORD   cRefsInitial;
    DSNAME *pdnObject = MakeObjectName("object");

    // This routine verifies that adding a child addref's the parent, 
    // and remocing the child deref's the parent.
    // Note that as of 4/3/01, when an object is deleted, the lastKnownParent attribute
    // is set to the old parent, before possible move to DeletedObjects. Note that the
    // attribute is set whether the object is moved or not.

    NewTest("ParentChildRefCountTest");

    cRefsInitial = GetTestRootRefCount();
    
    AddObject(pdnObject);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    if ( (cRefsInitial + 1) != GetTestRootRefCount() )
    {
        Fail("ParentChildRefCount failure on AddObject");
    }

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    // The logical deletion moved the object, so the refcount has dropped.
    // BUT, the refcount is also raised by virtue of LKP
    if ( (cRefsInitial + 1) != GetTestRootRefCount() )
    {
        Fail("ParentChildRefCount failure on LogicallyDeleteObject");
    }

    PhysicallyDeleteObject(pdnObject);

    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Ref on old parent is now reduced because LKP is stripped
    if ( cRefsInitial != GetTestRootRefCount() )
    {
        Fail("ParentChildRefCount failure on PhysicallyDeleteObject");
    }

    FreeObjectName(pdnObject);

    ReportTest("ParentChildRefCountTest");
}

void
ObjectCleaningRefCountTest(void)
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *pdnObject = MakeObjectName("object");
    DWORD err;

    // This routine verifies that marking an object for cleaning addref's
    // the object, and that unmarking an object for cleaning deref's
    // the object.

    NewTest("ObjectCleaningRefCountTest");

    // Object has one reference for its own name
    AddObject(pdnObject);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);


    // Add a reference for the cleaning flag
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnObject);
        if (err) Fail("Can't find Object");

        DBSetObjectNeedsCleaning( pTHS->pDB, 1 );

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Object");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnObject, REAL_OBJECT, 2);


    // Remove a reference for the cleaning flag
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnObject);
        if (err) Fail("Can't find Object");

        DBSetObjectNeedsCleaning( pTHS->pDB, 0 );

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Object");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Delete the object
    // Ref count stays the same
    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnObject);

    ReportTest("ObjectCleaningRefCountTest");
}

void
AttributeTestForRealObject(
    PropertyType    type)
{
    THSTATE     *pTHS = pTHStls;
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("AttributeTestForRealObject(LinkedProperty)");
    else
        NewTest("AttributeTestForRealObject(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);






    // Linked value replication specific part of test
    // Remove a value that does not exist
    // Replicator should be able to create a value in the absent state.
    if ( (type == LinkedProperty) && (pTHS->fLinkedValueReplication) ) {
        // Remove a property that does not exist
        // We expect this to fail
        DPRINT( 0, "START of expected failures\n" );
        RemoveProperty(pdnHost, pdnObject, type);
        DPRINT( 0, "END of expected failures\n" );
        if (fTestPassed) {
            Fail( "Remove of non-existing property should fail" );
        } else {
            fTestPassed = TRUE;
        }
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);

        Assert( !pTHS->fDRA );
        // Pretend to be the replicator
        // Replicator should be able to create value in absent state
        pTHS->fDRA = TRUE;
        RemoveProperty(pdnHost, pdnObject, type);
        pTHS->fDRA = FALSE;
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
    }

    // Add "object" as the value of a property on "host".
    // For a linked value, this will have the effect of making the
    // absent value present, but the count will not change

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Remove "object" as the value of a property on "host".
        
    RemoveProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if (type == LinkedProperty) {
        if (pTHS->fLinkedValueReplication) {
            // When a linked value is "removed", it is made absent. It disappears
            // off the index, but is actually still present for ref-counting
            // purposes. The absent value still holds a reference to the object
            // to which it refers. The ref-count is actually decremented when
            // 1. The hosting object is deleted (forward link clean up)
            // 2. The target object is deleted (backward link clean up)
            // 3. Absent link value gargage collection, after a tombstone lifetime
            VerifyRefCount(pdnObject, REAL_OBJECT, 2);
        } else {
            VerifyRefCount(pdnObject, REAL_OBJECT, 1);
        }
    } else {
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
    }

    // Linked value replication specific part of test
    // Remove a value that is already absent
    // Replicator should be able to touch a value,
    // changing only its metadata.
    if ( (type == LinkedProperty) && (pTHS->fLinkedValueReplication) ) {
        // Remove a property that is already absent
        // We expect this to fail
        DPRINT( 0, "START of expected failures\n" );
        RemoveProperty(pdnHost, pdnObject, type);
        DPRINT( 0, "END of expected failures\n" );
        if (fTestPassed) {
            Fail( "Re-remove of existing absent property should fail" );
        } else {
            fTestPassed = TRUE;
        }
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);

        Assert( !pTHS->fDRA );
        // Pretend to be the replicator
        // Replicator should be able to touch existing value
        pTHS->fDRA = TRUE;
        RemoveProperty(pdnHost, pdnObject, type);
        pTHS->fDRA = FALSE;
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
    }

    // Re-Add "object" as the value of a property on "host".
    // For a linked attribute, the value already exists in absent form.
    // Test making it present without changing the count.

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Linked value replication specific part of test
    // Add a value that is alreay present
    // Replicator should be able to touch a value,
    // changing only its metadata.
    if ( (type == LinkedProperty) && (pTHS->fLinkedValueReplication) ) {
        // Add a property that is already present
        // We expect this to fail
        DPRINT( 0, "START of expected failures\n" );
        AddProperty(pdnHost, pdnObject, type);
        DPRINT( 0, "END of expected failures\n" );
        if (fTestPassed) {
            Fail( "Re-add of existing present property should fail" );
        } else {
            fTestPassed = TRUE;
        }
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);

        Assert( !pTHS->fDRA );
        // Pretend to be the replicator
        // Replicator should be able to touch existing value
        pTHS->fDRA = TRUE;
        AddProperty(pdnHost, pdnObject, type);
        pTHS->fDRA = FALSE;
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
    }

    // Remove "object" as the value of a property on "host".
        
    RemoveProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if (type == LinkedProperty) {
        if (pTHS->fLinkedValueReplication) {
            // When a linked value is "removed", it is made absent. It disappears
            // off the index, but is actually still present for ref-counting
            // purposes. The absent value still holds a reference to the object
            // to which it refers. The ref-count is actually decremented when
            // 1. The hosting object is deleted (forward link clean up)
            // 2. The target object is deleted (backward link clean up)
            // 3. Absent link value gargage collection, after a tombstone lifetime
            VerifyRefCount(pdnObject, REAL_OBJECT, 2);
        } else {
            VerifyRefCount(pdnObject, REAL_OBJECT, 1);
        }
    } else {
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
    }

    // Logically delete "object".
    // The following is true for non-linked attributes or linked attributes
    // when not running in linked value replication mode:
    // At this point in time, there
    // should be no relationship between "host" and "object".  So
    // the only effect is that "object" becomes a tombstone which
    // retains its refcount for itself.
    // For link value replication, host still holds an absent value
    // referring to object, and host has a ref-count on object. When
    // object is tombstoned, its forward and backward links are cleaned up
    // (see DBRemoveLinks), and the ref-count is removed.
    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    // Physically delete "object".  Again, no effect on "host".

    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Logically delete "host".

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Physically delete "host".

    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);


    // For a non-linked attribute, verify that deleting a referent DOES NOT
    // reduce the reference count
    if (type == NonLinkedProperty) {
        VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Add "host" object which will host the property value.
        AddPropertyHost(pdnHost, type);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Add "object" object which will be the property value.
        AddObject(pdnObject);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
        // Add "object" as the value of a property on "host".
        AddProperty(pdnHost, pdnObject, type);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, REAL_OBJECT, 2);
        // Logically delete "object".
        LogicallyDeleteObject(pdnObject);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, TOMBSTONE, 2);
        // Remove "object" as the value of a property on "host".
        RemoveProperty(pdnHost, pdnObject, type);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, TOMBSTONE, 1);
        // Physically delete "object".  Again, no effect on "host".
        PhysicallyDeleteObject(pdnObject);
        VerifyRefCount(pdnHost, REAL_OBJECT, 1);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Logically delete "host".
        LogicallyDeleteObject(pdnHost);
        VerifyRefCount(pdnHost, TOMBSTONE, 1);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
        // Physically delete "host".
        PhysicallyDeleteObject(pdnHost);
        VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    }


    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("AttributeTestForRealObject(LinkedProperty)");
    else
        ReportTest("AttributeTestForRealObject(NonLinkedProperty)");
}

void
AttributeTestForDeletedObject(
    PropertyType    type)
{
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("AttributeTestForDeletedObject(LinkedProperty)");
    else
        NewTest("AttributeTestForDeletedObject(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Add "object" as the value of a property on "host".

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Logically delete "object".  Logical deletion strips all linked
    // attributes.  So in the linked case, "object" will get deref'd.
    // In the non-linked case, the tombstone for "object" retains the ref
    // count representing the fact that is referenced by a property on "host".

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, TOMBSTONE, 1);
    else
        VerifyRefCount(pdnObject, TOMBSTONE, 2);

    // Physically delete "object".  In the linked attribute case, 
    // "object" and "host" already have no relationship, thus "host" 
    // is unchanged and "object" can lose its refcount for itself.
    // In the non-linked case, "object" still has a reference back to
    // "host", thus it cannot really be deleted yet.  Instead, it
    // is morphed to a phantom, maintains the reference from "host", but
    // loses its refcount for itself.
    
    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 1);

    // Logically delete "host" such that it becomes a tombstone.  In 
    // both cases, "object" loses its reference to "host" as both
    // gLinkedAttrTyp and gNonLinkedAttrTyp are stripped on deletion.

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "host".  This derefs "object" since it still
    // refers to "host" which brings its refcount down to zero - but the
    // phantom still exists pending physical deletion.
    
    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "object", if it still exists.  "object" should
    // really disappear now since it has no refcount at all any more.

    if ( LinkedProperty != type )
        PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("AttributeTestForDeletedObject(LinkedProperty)");
    else
        ReportTest("AttributeTestForDeletedObject(NonLinkedProperty)");
}


void
AttributeTestForDeletedObjectProperty(
    PropertyType    type)
{
    // Verify that if you add a deleted dn as a property, the right thing happens
    THSTATE *   pTHS = pTHStls;
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("AttributeTestForDeletedObjectProperty(LinkedProperty)");
    else
        NewTest("AttributeTestForDeletedObjectProperty(NonLinkedProperty)");

    DsUuidCreate( &pdnHost->Guid );
    DsUuidCreate( &pdnObject->Guid );

    // Verify initial state.
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Turn object into a tombstone
    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    // Add tombstone "object" as the value of a property on "host".
    // For a replicated linked attribute, the addition is silently dropped.

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( pTHS->fDRA && ( LinkedProperty == type ) )
        VerifyRefCount(pdnObject, TOMBSTONE, 1);
    else
        VerifyRefCount(pdnObject, TOMBSTONE, 2);

    // TODO, we also want to verify that the attribute count of the property is
    // correct and that the property is not corrupted in any cases.

    // Remove tombstone
    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( pTHS->fDRA && ( LinkedProperty == type ) )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 1);

    // Get rid of the host
    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    // Property reference to object should have been stripped
    if (!( pTHS->fDRA && ( LinkedProperty == type ) )) {
        VerifyRefCount(pdnObject, PHANTOM, 0);
        PhysicallyDeleteObject(pdnObject);
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    }

    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("AttributeTestForDeletedObjectProperty(LinkedProperty)");
    else
        ReportTest("AttributeTestForDeletedObjectProperty(NonLinkedProperty)");
}

void
AttributeTestForDeletedHost(
    PropertyType    type)
{
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("AttributeTestForDeletedHost(LinkedProperty)");
    else
        NewTest("AttributeTestForDeletedHost(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Add "object" as the value of a property on "host".

    AddProperty(pdnHost, pdnObject, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Logically delete "host".  Logical deletion strips both gLinkedAttrTyp
    // and gNonLinkedAttrTyp.  Therefore "object" will get deref'd in both
    // the linked and non-linked case.

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);
    else
        VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Physically delete "host".  In the linked attribute case, 
    // "object" and "host" already have no relationship, , thus
    // "host" disappears and "object" stays as is.  In the non-linked
    // case, "object" holds a reference from "host" which is removed
    // when "host" is physically deleted.  Thus "object" is deref'd
    // by 1.

    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, REAL_OBJECT, 1);

    // Logically delete "object". "object" and "host" have no relationship
    // at this point in either the linked or non-linked case, thus "host"
    // stays the same and "object" becomes a tombstone.

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, TOMBSTONE, 1);

    // Physically delete "object".  "object" and "host" have no relationship
    // thus "object" is removed for real.

    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("AttributeTestForDeletedHost(LinkedProperty)");
    else
        ReportTest("AttributeTestForDeletedHost(NonLinkedProperty)");
}

void
PhantomPromotionDemotionTest(
    PropertyType    type)
{
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME * pdnObject = MakeObjectName( "object" );

    if ( LinkedProperty == type )
        NewTest("PhantomPromotionDemotionTest(LinkedProperty)");
    else
        NewTest("PhantomPromotionDemotionTest(NonLinkedProperty)");

    // Verify initial state.

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "host" object which will host the property value.

    AddPropertyHost(pdnHost, type);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    // Add "object" object which will be the property value.  We bypass
    // GC verification of a DSNAME'd attribute value thereby insuring
    // that "object" is created as a phantom. Since "object" is a phantom
    // it doesn't have a reference for itself, thus it always has a refcount
    // of 1.

    DsaSetIsInstalling();
    AddProperty(pdnHost, pdnObject, type);
    DsaSetIsRunning();
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, PHANTOM, 1);

    // Promote "object" from phantom to a real object.  Do this by adding
    // a real object with the same name.  "object" now gets a refcount for
    // itself as well.

    AddObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnObject, REAL_OBJECT, 2);

    // Logically delete "object".  This should result in a phantom whose
    // refcount reflects whether this was a linked attribute or not.

    LogicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, TOMBSTONE, 1);
    else
        VerifyRefCount(pdnObject, TOMBSTONE, 2);

    // Physically delete "object".  In the linked attribute case, "object"
    // and "host" have no relationship at this point in time because linked
    // attributes were stripped during logical deletion.  Thus "object"
    // really goes away.  In the non-linked case, "object" still has a 
    // reference from "host", thus it turns into a phantom.
    
    PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 1);

    // Logically delete "host".

    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "host".  In neither the linked nor non-linked
    // case does "host" have a reference from "object", so it goes away
    // for real.  In the linked case, "object" has no reference from "host"
    // so it stays the same.  In the non-linked case, the physical
    // delete of "host" deref's all objects it references, thus
    // "object" is deref'd by 1.

    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    if ( LinkedProperty == type )
        VerifyRefCount(pdnObject, DOESNT_EXIST, 0);
    else
        VerifyRefCount(pdnObject, PHANTOM, 0);

    // Physically delete "object", if it still exists.  Neither "host" nor
    // "object" references the other at this point in time, so "object"
    // disappears for real.

    if ( LinkedProperty != type )
        PhysicallyDeleteObject(pdnObject);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObject, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnObject);

    if ( LinkedProperty == type )
        ReportTest("PhantomPromotionDemotionTest(LinkedProperty)");
    else
        ReportTest("PhantomPromotionDemotionTest(NonLinkedProperty)");
}

void
PhantomRenameOnPromotionTest(void)
/*++

Routine Description:

    Refcounting is based on GUID, if one is available, as is phantom promotion.
    Therefore, it's possible that between the time a phantom is created and
    if/when it's promoted to the corresponding real object that it has been
    renamed or moved.

    This test stresses this code path by first creating a phantom with string
    name S1 and GUID G, then instantiating the real object S2 with GUID G.
    The result should be that the DNT created for the phantom S1 is promoted to
    the real object and is simultaneously renamed to S2.

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnContainer;
    DSNAME *    pdnRef;
    DSNAME *    pdnRefUnderContainer;
    DSNAME *    pdnHost;
    DWORD       err;

    NewTest("PhantomRenameOnPromotionTest");

    pdnContainer = MakeObjectNameEx( "Container", TestRoot );
    pdnHost = MakeObjectNameEx( "Host", TestRoot );
    pdnRef = MakeObjectNameEx( "Ref", TestRoot );
    pdnRefUnderContainer = MakeObjectNameEx( "RefUnderContainer", pdnContainer);

    DsUuidCreate( &pdnRef->Guid );
    pdnRefUnderContainer->Guid = pdnRef->Guid;


    // Create the following structure:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gLinkedAttrTyp = RefUnderContainer
    //  |
    //  |--Container
    //      |
    //      |--RefUnderContainer {Phantom}

    CommonAddObject( pdnContainer, CLASS_CONTAINER );
    AddPropertyHost( pdnHost, NonLinkedProperty );

    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost );
        if ( err ) Fail( "Can't find host" );

        err = DBAddAttVal( pTHS->pDB, gLinkedAttrTyp,
                           pdnRefUnderContainer->structLen,
                           pdnRefUnderContainer );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 2 );
    VerifyRefCount( pdnRefUnderContainer, PHANTOM, 1 );


    // Rename RefUnderContainer to Ref, and change its parent to TestRoot, all
    // in the context of promoting it from a phantom to a real object.  The
    // resulting structure should be the following:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gLinkedAttrTyp = Ref
    //  |
    //  |--Container
    //  |
    //  |--Ref

    AddObject( pdnRef );

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 1 );

    memset( &pdnRef->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRef, REAL_OBJECT, 2 );

    memset( &pdnRefUnderContainer->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRefUnderContainer, DOESNT_EXIST, 0 );


    // Remove our test objects.

    LogicallyDeleteObject( pdnHost );
    LogicallyDeleteObject( pdnContainer );
    LogicallyDeleteObject( pdnRef );

    PhysicallyDeleteObject( pdnHost );
    PhysicallyDeleteObject( pdnContainer );
    PhysicallyDeleteObject( pdnRef );


    FreeObjectName( pdnHost );
    FreeObjectName( pdnContainer );
    FreeObjectName( pdnRef );
    FreeObjectName( pdnRefUnderContainer);

    ReportTest("PhantomRenameOnPromotionTest");
}

void
PhantomRenameOnPhantomRDNConflict(void)
/*++

Routine Description:
    When we are trying to add a phantom A under parent B, 
    and there is an existing structural phantom C (no guid) under
    parent B with the same RDN as A but different RDNType,
    we should rename C (mangle) using a random guid.
    
    This unit test exersises this code path (in CheckNameForAdd).

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnContainer;
    DSNAME *    pdnRefUnderSubContainer;
    DSNAME *    pdnRefUnderContainer;
    DSNAME *    pdnRefUnderContainerOld;
    DSNAME *    pdnHost;
    DWORD       err;
    WCHAR       szMangledRefUnderContainer[MAX_RDN_SIZE] = L"RefUnderContainer";
    DWORD       cchMangledRefUnderContainer = wcslen(szMangledRefUnderContainer);
    DWORD       cb;

    NewTest("PhantomRenameOnPhantomRDNConflict");

    pdnContainer = MakeObjectNameEx2( "OU=Container", TestRoot );
    pdnHost = MakeObjectNameEx( "Host", TestRoot );
    pdnRefUnderContainerOld = MakeObjectNameEx( "RefUnderContainer", pdnContainer);
    pdnRefUnderSubContainer = MakeObjectNameEx2( "CN=RefUnderSubContainer,CN=RefUnderContainer", pdnContainer);
    pdnRefUnderContainer = MakeObjectNameEx2( "OU=RefUnderContainer", pdnContainer);

    DsUuidCreate( &pdnRefUnderContainer->Guid );
    DsUuidCreate( &pdnRefUnderSubContainer->Guid );

    // Create the following structure:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gLinkedAttrTyp = CN=RefUnderSubContainer
    //  |
    //  |--OU=Container
    //      |
    //      |--CN=RefUnderContainer            {Phantom}
    //           |
    //           |--CN=RefUnderSubContainer {Phantom}

    CommonAddObject( pdnContainer, CLASS_ORGANIZATIONAL_UNIT );
    AddPropertyHost( pdnHost, NonLinkedProperty );

    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost );
        if ( err ) Fail( "Can't find host" );

        err = DBAddAttVal( pTHS->pDB, gLinkedAttrTyp,
                           pdnRefUnderSubContainer->structLen,
                           pdnRefUnderSubContainer );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 2 );
    VerifyRefCount( pdnRefUnderContainerOld, PHANTOM, 1 );
    VerifyRefCount( pdnRefUnderSubContainer, PHANTOM, 1 );

    // now add OU=RefUnderContainer 
    // the resulting structure should be the following:
    // 
    //  |--OU=Container
    //      |
    //      |--OU=RefUnderContainer
    //      |
    //      |--CN=RefUnderContainer#CNF:GUID       {Phantom}
    //           |
    //           |--CN=RefUnderSubContainer        {Phantom}

    CommonAddObject(pdnRefUnderContainer, CLASS_ORGANIZATIONAL_UNIT);

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 3 );

    // this is the new object (OU)
    VerifyStringName( pdnRefUnderContainer );
    memset( &pdnRefUnderContainer->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRefUnderContainer, REAL_OBJECT, 1 );

    // this is the old object (was renamed)
    memset( &pdnRefUnderContainerOld->Guid, 0, sizeof( GUID ) );
    VerifyRefCount( pdnRefUnderContainerOld, DOESNT_EXIST, 0 );
    
    // Reconstruct the munged name of pdnRefUnderContainerOld using the guid exported
    // from mdadd.c specifically for our test.
    // (This test hook exists only #ifdef INCLUDE_UNIT_TESTS on DBG builds.)
    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              &gLastGuidUsedToRenamePhantom, 
              szMangledRefUnderContainer, 
              &cchMangledRefUnderContainer);

    cb = pdnRefUnderContainerOld->structLen + 100;
    pdnRefUnderContainerOld = THReAllocEx(pTHStls, pdnRefUnderContainerOld, cb);
    AppendRDN(pdnContainer, 
              pdnRefUnderContainerOld, 
              cb, 
              szMangledRefUnderContainer, 
              cchMangledRefUnderContainer,
              ATT_COMMON_NAME);
    
    DPRINT1 (3, "Renamed object: %ws\n", pdnRefUnderContainerOld->StringName);

    VerifyRefCount( pdnRefUnderContainerOld, PHANTOM, 1 );


    // Remove our test objects. These operations are order dependent,
    // since some phantoms don't have a guid, 
    // so they have to be removed first

    PhysicallyDeleteObject( pdnRefUnderContainerOld );

    LogicallyDeleteObject( pdnHost );
    LogicallyDeleteObject( pdnRefUnderContainer );
    LogicallyDeleteObject( pdnContainer );

    PhysicallyDeleteObject( pdnHost );
    PhysicallyDeleteObject( pdnRefUnderSubContainer );
    PhysicallyDeleteObject( pdnRefUnderContainer );
    PhysicallyDeleteObject( pdnContainer );

    FreeObjectName( pdnHost );
    FreeObjectName( pdnContainer );
    FreeObjectName( pdnRefUnderSubContainer );
    FreeObjectName( pdnRefUnderContainer );
    FreeObjectName( pdnRefUnderContainerOld );

    ReportTest("PhantomRenameOnPhantomRDNConflict");
}




void
NestedTransactionEscrowedUpdateTest(void)
{
#define NUM_NESTED_XACTS ( 6 )
    THSTATE *   pTHS = pTHStls;
    CHAR        szHost[] = "Host#";
    DSNAME *    rgpdnHost[ NUM_NESTED_XACTS ];
    DBPOS *     rgpDB[ NUM_NESTED_XACTS ] = { 0 };
    DSNAME *    pdnObject;
    DWORD       err;
    DWORD       cRef = 1;
    int         iXactLevel;
    BOOL        fCommit;

    NewTest( "NestedTransactionEscrowedUpdateTest" );

    // Create 8 HostN's.
    for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
    {
        szHost[ strlen( "Host" ) ] = (char)('0' + iXactLevel);

        rgpdnHost[ iXactLevel ] = MakeObjectNameEx( szHost, TestRoot );
        VerifyRefCount( rgpdnHost[ iXactLevel ], DOESNT_EXIST, 0 );

        AddPropertyHost( rgpdnHost[ iXactLevel ], NonLinkedProperty );
        VerifyRefCount( rgpdnHost[ iXactLevel ], REAL_OBJECT, 1 );
    }

    // Create Object.
    pdnObject = MakeObjectNameEx( "Object", TestRoot );
    VerifyRefCount( pdnObject, DOESNT_EXIST, 0 );

    AddObject( pdnObject );
    VerifyRefCount( pdnObject, REAL_OBJECT, 1 );

    srand((unsigned int) time(NULL));

    __try
    {
        SYNC_TRANS_WRITE();

        __try
        {
            // Open nested transactions, top to bottom.  In each transaction,
            // add a reference to Object.

            for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
            {
                if ( iXactLevel )
                {
                    DBOpen( &rgpDB[ iXactLevel ] );
                }
                else
                {
                    rgpDB[ iXactLevel ] = pTHS->pDB;
                }

                err = DBFindDSName( rgpDB[ iXactLevel ],
                                    rgpdnHost[ iXactLevel ] );
                if ( err ) Fail( "Can't find host" );

                err = DBAddAttVal( rgpDB[ iXactLevel ], gLinkedAttrTyp,
                                   pdnObject->structLen, pdnObject );
                if ( err ) Fail( "Can't add reference" );

                err = DBRepl( rgpDB[ iXactLevel ], FALSE, 0, NULL, META_STANDARD_PROCESSING );
                if ( err ) Fail( "Can't replace host" );
            }

            // Close the nested transactions, bottom to top, randomly committing
            // or aborting them.

            for ( iXactLevel = NUM_NESTED_XACTS - 1;
                  iXactLevel > -1;
                  iXactLevel--
                )
            {
                fCommit = rand() > RAND_MAX / 4;

                if ( iXactLevel )
                {
                    err = DBClose( rgpDB[ iXactLevel ], fCommit );

                    if ( err )
                    {
                        Fail( "DBClose() failed" );
                    }
                    else
                    {
                        rgpDB[ iXactLevel ] = NULL;
                    }
                }

                // If we abort, we abort all the transactions beneath us, too,
                // implying the refcount on Objectdrops back to 1 (the single
                // refcount for its own ATT_OBJ_DISTNAME).

                cRef = fCommit ? cRef+1 : 1;

                DPRINT3( 3, "%s level %d, cRef = %d.\n",
                         fCommit ? "Commit" : "Abort", iXactLevel,
                         cRef );
            }
        }
        __finally
        {
            CLEAN_BEFORE_RETURN( !fCommit );
            rgpDB[ 0 ] = NULL;
        }

        VerifyRefCount( pdnObject, REAL_OBJECT, cRef );
        for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
        {
            VerifyRefCount( rgpdnHost[ iXactLevel ], REAL_OBJECT, 1 );

            LogicallyDeleteObject( rgpdnHost[ iXactLevel ] );
            VerifyRefCount( rgpdnHost[ iXactLevel ], TOMBSTONE, 1 );

            PhysicallyDeleteObject( rgpdnHost[ iXactLevel ] );
            VerifyRefCount( rgpdnHost[ iXactLevel ], DOESNT_EXIST, 0 );

            FreeObjectName( rgpdnHost[ iXactLevel ] );
        }

        LogicallyDeleteObject( pdnObject );
        VerifyRefCount( pdnObject, TOMBSTONE, 1 );

        PhysicallyDeleteObject( pdnObject );
        VerifyRefCount( pdnObject, DOESNT_EXIST, 0 );

        FreeObjectName( pdnObject );
    }
    __finally
    {
        for ( iXactLevel = 0; iXactLevel < NUM_NESTED_XACTS; iXactLevel++ )
        {
            if ( NULL != rgpDB[ iXactLevel ] )
            {
                DPRINT1( 0, "Forcing level %d pDB closed...\n", iXactLevel );

                DBClose( rgpDB[ iXactLevel ], FALSE );

                DPRINT1( 0, "...level %d pDB closed successfully.\n",
                         iXactLevel );
            }
        }
    }

    ReportTest( "NestedTransactionEscrowedUpdateTest" );
}

void NameCollisionTest(void)
/*++

Routine Description:

    This test exercises the name collision handling code.

    Name collisions occur when we're adding a reference to an object
    with a GUID, but when adding that reference we determine that there
    already exists an object or phantom with the same string name but a
    different GUID (hence referring to a different object).

    Unfortunately we're confined to guarantee uniqueness of string names,
    so at least one of the names must be changed to allow the reference to
    be added.

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRef1;
    DSNAME *    pdnRef2;
    DSNAME *    pdnHost;
    DSNAME *    pdnCurrRef1;
    DSNAME *    pdnCurrRef2;
    DWORD       err;
    DWORD       iPassForRef1Object;
    DWORD       iPassToAddObject;
    DWORD       iPass;
    DSNAME *    pdnObj;
    DSNAME *    pdnPhantom;
    DSNAME *    pdnCurrObj;
    DSNAME *    pdnCurrPhantom;

    NewTest("NameCollisionTest");

    pdnHost = MakeObjectNameEx("Host", TestRoot);
    pdnRef1 = MakeObjectNameEx("Ref", TestRoot);
    pdnRef2 = MakeObjectNameEx("Ref", TestRoot);

    // Ref1 and Ref2 have the same string name, but different GUIDs.
    DsUuidCreate(&pdnRef1->Guid);
    DsUuidCreate(&pdnRef2->Guid);

    // Create host object.
    AddPropertyHost(pdnHost, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add Ref1 and Ref2 references and make sure the last one added (i.e.,
    // Ref2) "wins" the string name.

    // Add reference to Ref1.
    AddProperty(pdnHost, pdnRef1, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 1);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add reference to Ref2.
    AddProperty(pdnHost, pdnRef2, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 1);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    pdnCurrRef1 = GetProperty(pdnHost, 1, NonLinkedProperty);
    pdnCurrRef2 = GetProperty(pdnHost, 2, NonLinkedProperty);

    if (DSNAME_SAME_STRING_NAME(pdnCurrRef1, pdnCurrRef2))
        Fail("String names identical!");
    if (!DSNAME_SAME_GUID_SID(pdnCurrRef1, pdnRef1))
        Fail("GUID/SID of ref 1 incorrect!");
    if (!DSNAME_IDENTICAL(pdnCurrRef2, pdnRef2))
        Fail("Ref 2 changed!");

    // Remove Ref1 reference.
    RemoveProperty(pdnHost, pdnRef1, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 0);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    // Remove Ref2 reference.
    RemoveProperty(pdnHost, pdnRef2, NonLinkedProperty);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 0);
    VerifyRefCount(pdnRef2, PHANTOM, 0);

    // Remove ref phantoms.
    PhysicallyDeleteObject(pdnRef1);
    PhysicallyDeleteObject(pdnRef2);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add object and phantom with same string name but different GUIDs and make
    // sure that the object always "wins" the string name.  Add Ref1 and Ref2
    // in different orders and each taking turns as to who is the phantom and
    // who is the object.

    for (iPassForRef1Object = 0; iPassForRef1Object < 2; iPassForRef1Object++) {
        if (iPassForRef1Object) {
            pdnObj = pdnRef2;
            pdnPhantom = pdnRef1;
        }
        else {
            pdnObj = pdnRef1;
            pdnPhantom = pdnRef2;
        }

        for (iPassToAddObject = 0; iPassToAddObject < 2; iPassToAddObject++) {
            for (iPass = 0; iPass < 2; iPass++) {
                if (iPass == iPassToAddObject) {
                    AddObject(pdnObj);
                }
                else {
                    AddProperty(pdnHost, pdnPhantom, NonLinkedProperty);
                }
            }

            pdnCurrPhantom = GetProperty(pdnHost, 1, NonLinkedProperty);
            pdnCurrObj = GetObjectName(pdnObj);

            if (!DSNAME_IDENTICAL(pdnCurrObj, pdnObj)) 
                Fail("Object name changed!");
            if (!DSNAME_SAME_GUID_SID(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom name has different GUID/SID!");
            if (DSNAME_SAME_STRING_NAME(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom string name not changed!");

            FreeObjectName(pdnCurrPhantom);
            FreeObjectName(pdnCurrObj);

            RemoveProperty(pdnHost, pdnPhantom, NonLinkedProperty);
            LogicallyDeleteObject(pdnObj);

            PhysicallyDeleteObject(pdnObj);
            PhysicallyDeleteObject(pdnPhantom);

            VerifyRefCount(pdnHost, REAL_OBJECT, 1);
            VerifyRefCount(pdnObj, DOESNT_EXIST, 0);
            VerifyRefCount(pdnPhantom, DOESNT_EXIST, 0);
        }
    }

    // Add Ref1 and Ref2 references (in both orders), then promote one to a real
    // object.  Make sure that the promoted phantom "wins" the string name.

    for (iPassForRef1Object = 0; iPassForRef1Object < 2; iPassForRef1Object++) {
        if (iPassForRef1Object) {
            pdnObj = pdnRef2;
            pdnPhantom = pdnRef1;
        }
        else {
            pdnObj = pdnRef1;
            pdnPhantom = pdnRef2;
        }

        for (iPassToAddObject = 0; iPassToAddObject < 2; iPassToAddObject++) {
            for (iPass = 0; iPass < 2; iPass++) {
                if (iPass == iPassToAddObject) {
                    AddProperty(pdnHost, pdnObj, NonLinkedProperty);
                }
                else {
                    AddProperty(pdnHost, pdnPhantom, NonLinkedProperty);
                }
            }

            AddObject(pdnObj);

            pdnCurrRef1 = GetProperty(pdnHost, 1, NonLinkedProperty);
            pdnCurrRef2 = GetProperty(pdnHost, 2, NonLinkedProperty);
            pdnCurrObj = GetObjectName(pdnObj);

            if (DSNAME_IDENTICAL(pdnCurrRef1, pdnObj))
                pdnCurrPhantom = pdnCurrRef2;
            else if (DSNAME_IDENTICAL(pdnCurrRef2, pdnObj))
                pdnCurrPhantom = pdnCurrRef1;
            else
                Fail("Object name changed!");

            if (!DSNAME_SAME_GUID_SID(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom name has different GUID/SID!");
            if (DSNAME_SAME_STRING_NAME(pdnCurrPhantom, pdnPhantom))
                Fail("Phantom string name not changed!");

            FreeObjectName(pdnCurrPhantom);
            FreeObjectName(pdnCurrObj);

            RemoveProperty(pdnHost, pdnPhantom, NonLinkedProperty);
            RemoveProperty(pdnHost, pdnObj, NonLinkedProperty);
            LogicallyDeleteObject(pdnObj);

            PhysicallyDeleteObject(pdnObj);
            PhysicallyDeleteObject(pdnPhantom);

            VerifyRefCount(pdnHost, REAL_OBJECT, 1);
            VerifyRefCount(pdnObj, DOESNT_EXIST, 0);
            VerifyRefCount(pdnPhantom, DOESNT_EXIST, 0);
        }
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost);
    PhysicallyDeleteObject(pdnHost);

    FreeObjectName(pdnHost);
    FreeObjectName(pdnRef1);
    FreeObjectName(pdnRef2);

    ReportTest("NameCollisionTest");
}

void RefPhantomSidUpdateTest(void)
/*++

Routine Description:

    When adding a reference to an existing reference phantom (which by
    definition must have a GUID), the DS verifies that if the new reference to
    that phantom has a SID, that the reference phantom has the same SID.  If
    not, the reference phantom is update with the SID in the reference (i.e.,
    the inbound reference is asumed to be more recent).

    This test stresses this code path.

Arguments:

    None.

Return Values:

    None.

--*/
{
    static BYTE rgbSid1[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xea, 0x03, 0x00, 0x00};
    static BYTE rgbSid2[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xeb, 0x03, 0x00, 0x00};

    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefSid1;
    DSNAME *    pdnRefSid2;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    DSNAME *    pdnCurrRef = NULL;
    DWORD       cbCurrRef = 0;
    DWORD       err;

    NewTest("RefPhantomSidUpdateTest");

    // pdnHost1 and pdnHost2 are seperate objects.
    pdnHost1 = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2 = MakeObjectNameEx("Host2", TestRoot);

    // pdnRefSid1 and pdnRefSid2 refer to the same object (same GUID and string
    // name), but have different SIDs.
    pdnRefSid1 = MakeObjectNameEx("Ref", TestRoot);
    pdnRefSid2 = MakeObjectNameEx("Ref", TestRoot);

    DsUuidCreate(&pdnRefSid1->Guid);
    pdnRefSid2->Guid = pdnRefSid1->Guid;
    
    memcpy(&pdnRefSid1->Sid, rgbSid1, sizeof(rgbSid1));
    pdnRefSid1->SidLen = sizeof(rgbSid1);

    memcpy(&pdnRefSid2->Sid, rgbSid2, sizeof(rgbSid2));
    pdnRefSid2->SidLen = sizeof(rgbSid2);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);

    // Create host objects.
    AddPropertyHost(pdnHost1, NonLinkedProperty);
    AddPropertyHost(pdnHost2, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);

    // Add reference on Host1 to Ref with first SID.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRefSid1->structLen, pdnRefSid1);
        if (err) Fail("Can't add reference with first SID");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host1");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, PHANTOM, 1);
    VerifyRefCount(pdnRefSid2, PHANTOM, 1);

    // Verify SID on Ref.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host1");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref on Host1 is not pdnRefSid1");
            }
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Add reference on Host2 to Ref with second SID.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost2);
        if (err) Fail("Can't find Host2");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRefSid2->structLen, pdnRefSid2);
        if (err) Fail("Can't add reference with second SID");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host2");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, PHANTOM, 2);
    VerifyRefCount(pdnRefSid2, PHANTOM, 2);

    // Verify SID on Ref.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host1");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid2->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid2, cbCurrRef))
            {
                Fail("Ref on Host1 is not pdnRefSid2");
            }
        }

        err = DBFindDSName(pTHS->pDB, pdnHost2);
        if (err) Fail("Can't find Host2");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host2");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid2->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid2, cbCurrRef))
            {
                Fail("Ref on Host2 is not pdnRefSid2");
            }
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);

    VerifyRefCount(pdnHost1, TOMBSTONE, 1);
    VerifyRefCount(pdnHost2, TOMBSTONE, 1);
    VerifyRefCount(pdnRefSid1, PHANTOM, 0);
    VerifyRefCount(pdnRefSid2, PHANTOM, 0);
    
    PhysicallyDeleteObject(pdnHost1);
    {
        VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
        VerifyRefCount(pdnHost2, TOMBSTONE, 1);
        VerifyRefCount(pdnRefSid1, PHANTOM, 0);
        VerifyRefCount(pdnRefSid2, PHANTOM, 0);
    }
    PhysicallyDeleteObject(pdnHost2);
    {
        VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
        VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
        VerifyRefCount(pdnRefSid1, PHANTOM, 0);
        VerifyRefCount(pdnRefSid2, PHANTOM, 0);
    }
    PhysicallyDeleteObject(pdnRefSid1);
    
    
    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);


    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnRefSid1);
    FreeObjectName(pdnRefSid2);

    if (NULL != pdnCurrRef) THFree(pdnCurrRef);

    ReportTest("RefPhantomSidUpdateTest");
}

void StructPhantomGuidSidUpdateTest(void)
/*++

Routine Description:

    When adding a reference to an existing structural phantom (which by
    definition lacks a GUID and SID), the DS adds the GUID/SID from the
    reference to the exisiting structural phantom.

    This test stresses this code path.

Arguments:

    None.

Return Values:

    None.

--*/
{
    static BYTE rgbSid1[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xec, 0x03, 0x00, 0x00};
    static BYTE rgbSid2[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xed, 0x03, 0x00, 0x00};

    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRef1;
    DSNAME *    pdnRef2;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    BYTE *      pb;
    DWORD       cb;
    GUID        guid;
    NT4SID      sid;
    DWORD       err;

    NewTest("StructPhantomGuidSidUpdateTest");

    // Host1 and Host2 are sibling objects.
    pdnHost1 = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2 = MakeObjectNameEx("Host2", TestRoot);

    // Ref2 is a child of Ref1.
    pdnRef1 = MakeObjectNameEx("Ref1", TestRoot);
    pdnRef2 = MakeObjectNameEx("Ref2", pdnRef1);

    DsUuidCreate(&pdnRef1->Guid);
    DsUuidCreate(&pdnRef2->Guid);
    
    memcpy(&pdnRef1->Sid, rgbSid1, sizeof(rgbSid1));
    pdnRef1->SidLen = sizeof(rgbSid1);

    memcpy(&pdnRef2->Sid, rgbSid2, sizeof(rgbSid2));
    pdnRef2->SidLen = sizeof(rgbSid2);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Create host objects.
    AddPropertyHost(pdnHost1, NonLinkedProperty);
    AddPropertyHost(pdnHost2, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    // Add reference on Host2 to Ref2.  This will implicitly create a structural
    // phantom for Ref1 as well, since it does not yet exist and is a parent of
    // Ref2.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost2);
        if (err) Fail("Can't find Host2");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRef2->structLen, pdnRef2);
        if (err) Fail("Can't add reference to Ref2");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host2");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 1);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    // Verify GUIDs/SIDs on Ref1 and Ref2.  Ref2 should have a GUID and SID;
    // Ref1 should have neither.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnRef1);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref1");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err != DB_ERR_NO_VALUE) {
            Fail("Unexpected error reading GUID of Ref1");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err != DB_ERR_NO_VALUE) {
            Fail("Unexpected error reading SID of Ref1");
        }

        err = DBFindDSName(pTHS->pDB, pdnRef2);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref2");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading GUID of Ref2");
        }
        else if (memcmp(&guid, &pdnRef2->Guid, sizeof(GUID))) {
            Fail("Wrong GUID on Ref2");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading SID of Ref2");
        }
        else if ((cb != pdnRef2->SidLen) || memcmp(&sid, &pdnRef2->Sid, cb)) {
            Fail("Wrong SID on Ref2");
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Add reference on Host1 to Ref1.  This should populate the GUID and SID on
    // Ref1.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost1);
        if (err) Fail("Can't find Host1");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRef1->structLen, pdnRef1);
        if (err) Fail("Can't add reference to Ref1");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host1");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRef1, PHANTOM, 2);
    VerifyRefCount(pdnRef2, PHANTOM, 1);

    // Verify GUIDs/SIDs on Ref1 and Ref2.  Both should now have GUIDs and
    // SIDs.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnRef1);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref1");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading GUID of Ref1");
        }
        else if (memcmp(&guid, &pdnRef1->Guid, sizeof(GUID))) {
            Fail("Wrong GUID on Ref1");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading SID of Ref1");
        }
        else if ((cb != pdnRef1->SidLen) || memcmp(&sid, &pdnRef1->Sid, cb)) {
            Fail("Wrong SID on Ref1");
        }

        err = DBFindDSName(pTHS->pDB, pdnRef2);
        if (DIRERR_NOT_AN_OBJECT != err) Fail("Failed to find phantom Ref2");

        pb = (BYTE *) &guid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID, DBGETATTVAL_fCONSTANT,
                          sizeof(guid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading GUID of Ref2");
        }
        else if (memcmp(&guid, &pdnRef2->Guid, sizeof(GUID))) {
            Fail("Wrong GUID on Ref2");
        }

        pb = (BYTE *) &sid;
        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID, DBGETATTVAL_fCONSTANT,
                          sizeof(sid), &cb, &pb);
        if (err) {
            Fail("Unexpected error reading SID of Ref2");
        }
        else if ((cb != pdnRef2->SidLen) || memcmp(&sid, &pdnRef2->Sid, cb)) {
            Fail("Wrong SID on Ref2");
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);

    PhysicallyDeleteObject(pdnHost1);
    PhysicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnRef2);
    PhysicallyDeleteObject(pdnRef1);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRef2, DOESNT_EXIST, 0);

    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnRef1);
    FreeObjectName(pdnRef2);

    ReportTest("StructPhantomGuidSidUpdateTest");
}

void ObjectSidNoUpdateTest(void)
/*++

Routine Description:

    When adding a reference to an existing object, make sure that we *don't*
    update the SID if a reference to that object has a different SID than
    that already present (as opposed to what we'd do if it were a phantom).

Arguments:

    None.

Return Values:

    None.

--*/
{
    static BYTE rgbSid1[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xee, 0x03, 0x00, 0x00};
    static BYTE rgbSid2[] = {0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
        0x15, 0x00, 0x00, 0x00, 0xbb, 0xcf, 0xdd, 0x81, 0xbc, 0xcf, 0xdd, 0x81,
        0xbd, 0xcf, 0xdd, 0x81, 0xef, 0x03, 0x00, 0x00};

    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefSid1;
    DSNAME *    pdnRefSid2;
    DSNAME *    pdnHost;
    DSNAME *    pdnCurrRef = NULL;
    DWORD       cbCurrRef = 0;
    DWORD       err;

    NewTest("ObjectSidNoUpdateTest");

    pdnHost = MakeObjectNameEx("Host", TestRoot);

    // pdnRefSid1 and pdnRefSid2 refer to the same object (same GUID and string
    // name), but have different SIDs.
    pdnRefSid1 = MakeObjectNameEx("Ref", TestRoot);
    pdnRefSid2 = MakeObjectNameEx("Ref", TestRoot);

    DsUuidCreate(&pdnRefSid1->Guid);
    pdnRefSid2->Guid = pdnRefSid1->Guid;
    
    memcpy(&pdnRefSid1->Sid, rgbSid1, sizeof(rgbSid1));
    pdnRefSid1->SidLen = sizeof(rgbSid1);

    memcpy(&pdnRefSid2->Sid, rgbSid2, sizeof(rgbSid2));
    pdnRefSid2->SidLen = sizeof(rgbSid2);

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);

    // Create host objects.
    AddPropertyHost(pdnHost, NonLinkedProperty);
    AddObject(pdnRefSid1);

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid2, REAL_OBJECT, 1);

    // Add SID to Ref.
    SYNC_TRANS_WRITE();
    
    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnRefSid1);
        if (err) Fail("Can't find Ref");
    
        err = DBAddAttVal(pTHS->pDB, ATT_OBJECT_SID,
                          pdnRefSid1->SidLen, &pdnRefSid1->Sid);
        if (err) {
            DPRINT1(0, "DBAddAttVal() failed with error %d.\n", err);
            Fail("Can't add SID to Ref");
        }
    
        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Ref");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Add reference on Host1 to Ref with different SID.
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost);
        if (err) Fail("Can't find Host");

        err = DBAddAttVal(pTHS->pDB, gLinkedAttrTyp,
                          pdnRefSid2->structLen, pdnRefSid2);
        if (err) Fail("Can't add reference with second SID");

        err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
        if (err) Fail("Can't replace Host1");
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    VerifyRefCount(pdnHost, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefSid1, REAL_OBJECT, 2);
    VerifyRefCount(pdnRefSid2, REAL_OBJECT, 2);

    // Verify SID on Ref.
    SYNC_TRANS_READ();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pdnHost);
        if (err) Fail("Can't find Host1");

        err = DBGetAttVal(pTHS->pDB, 1, gLinkedAttrTyp,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read current ref on Host1");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref on Host1 is not pdnRefSid1");
            }
        }

        err = DBFindDSName(pTHS->pDB, pdnRefSid1);
        if (err) Fail("Can't find Ref");

        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read name of Ref");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref name is not pdnRefSid1");
            }
        }

        err = DBFindDSName(pTHS->pDB, pdnRefSid2);
        if (err) Fail("Can't find Ref");

        err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                          DBGETATTVAL_fREALLOC, cbCurrRef, &cbCurrRef,
                          (BYTE **) &pdnCurrRef);
        if (err)
        {
            Fail("Can't read name of Ref");
        }
        else
        {
            if (   (cbCurrRef != pdnRefSid1->structLen)
                 || memcmp(pdnCurrRef, pdnRefSid1, cbCurrRef))
            {
                Fail("Ref name is not pdnRefSid1");
            }
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost);
    LogicallyDeleteObject(pdnRefSid1);

    PhysicallyDeleteObject(pdnHost);
    PhysicallyDeleteObject(pdnRefSid1);

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefSid2, DOESNT_EXIST, 0);


    FreeObjectName(pdnHost);
    FreeObjectName(pdnRefSid1);
    FreeObjectName(pdnRefSid2);

    if (NULL != pdnCurrRef) THFree(pdnCurrRef);

    ReportTest("ObjectSidNoUpdateTest");
}


void UnmangleRDNTest(void)
/*++

Routine Description:

    This test exercises the name collision handling code, focusing on encoding
    and decoding GUIDs embedded in RDNs.  Following is the text of the bug that
    prompted this functionality:
    
    === Opened by jeffparh on 06/19/98; AssignedTo = JEFFPARH; Priority = 1 ===
    This problem bit ntwksta1, and is causing inbound replication to halt:
    
    We're trying to apply the inbound object 
    CN=CHILDDEV,CN=Partitions,CN=Configuration,DC=ntdev,DC=microsoft,DC=com,
    with an ncName attribute that references the domain:
    
        DSNAME
          total size: 138, name len: 40
          Guid: e15d7046-054e-11d2-a80f-bfbc8c2bf64e
          SID: S-1-5-21-49504375-1957592189-1205755695
          Name: DC=childdev,DC=ntdev,DC=microsoft,DC=com
    
    This domain has been reinstalled at least twice.  There are currently a few
    references in the database to objects that once had this string name:
    
       DNT   PDNT  NCDNT RefCnt V O IT Deletion Time     RdnTyp  CC  RDN                  GUID
     46584   1795      -      2 - 0  - 98-05-27 09:35.06 1376281 082 childdev#b7f63eb515f5d1118a04d68dc9e4b639 b53ef6b7-f515-11d1-8a04-d68dc9e4b639
     47093   1795      -      1 - 0  - 98-05-29 11:39.45 1376281 016 childdev             f622b2e9-f720-11d1-97a7-debcc966ba39
     51287   1795      -      1 - 0  - 98-06-18 16:41.11 1376281 082 childdev#e9b222f620f7d11197a7debcc966ba39 no guid
    
    (Note that # is actually BAD_NAME_CHAR -- a linefeed.)
    
    Of particular interest is the fact that the last 2 are aliases for the same
    object -- i.e., childdev#e9b222f620f7d11197a7debcc966ba39 is a name-munged
    version of a reference to childdev with guid
    f622b2e9-f720-11d1-97a7-debcc966ba39 = e9b222f620f7d11197a7debcc966ba39.
    
    The name-munged reference replicated in from another server as part of
    adding a reference to the object
    CN=IMRBS1,CN=Computers,DC=childdev#e9b222f620f7d11197a7debcc966ba39,
    DC=ntdev,DC=microsoft,DC=com -- undoubtedly by adding the server object for
    the newly-reinstalled IMRBS1.  The reference was name-munged on the source
    server to resolve a conflict there -- a conflict generated by adding a
    reference to this newest version of childdev (the one with guid
    e15d7046-054e-11d2-a80f-bfbc8c2bf64e).  The reference has a guid only for
    the leaf -- it doesn't carry the guid for the
    DC=childdev#e9b222f620f7d11197a7debcc966ba39 part -- so when we add the
    reference we don't realize that DC=childdev#e9b222f620f7d11197a7debcc966ba39
    with no guid should be the same record as DC=childdev with guid
    f622b2e9-f720-11d1-97a7-debcc966ba39.
    
    At any rate, having two phantoms that really correspond to the same object
    is the root of the problem.
    
    This causes the downstream effect we're seeing because when we go to add a
    reference to the latest version of childdev, we note the phantom conflict
    for the name childdev (DNT 47093 already owns that name), and decide to
    rename DNT 47093.  However, the new name we try to give it in order to
    eliminate the conflict is childdev#e9b222f620f7d11197a7debcc966ba39, which 
    is already owned by DNT 51287.
    
    The solution seems to be to parse out the guids of what would otherwise be
    structural phantoms when we replicate in references like
    CN=IMRBS1,CN=Computers,DC=childdev#e9b222f620f7d11197a7debcc966ba39,
    DC=ntdev,DC=microsoft,DC=com.  This would ensure that the record at DNT
    51287 was never created (the reference would include 47093 instead), and
    we'd avoid this symptom.
    ============================================================================    

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefWithGuid;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    WCHAR       szMangledRef[MAX_RDN_SIZE] = L"Ref";
    DWORD       cchMangledRef = wcslen(szMangledRef);
    DSNAME *    pdnMangledRef;
    DSNAME *    pdnRefChild;
    DSNAME *    pdnMangledRefChild;
    DSNAME *    pdnMangledRefChildWithGuid;
    DSNAME *    pdn;

    NewTest("UnmangleRDNTest");

    // Create a reference to CN=ref on host1.  Then create a reference to
    // CN=ref-child,CN=<munged ref> on host2.  The parent of ref-child
    // should be the pre-existing record CN=ref (not a new record with the
    // ref's munged name).
    
    // Derive DNs.
    pdnHost1       = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2       = MakeObjectNameEx("Host2", TestRoot);
    pdnRefWithGuid = MakeObjectNameEx("Ref", TestRoot);
    pdnRefChild    = MakeObjectNameEx("RefChild", pdnRefWithGuid);

    DsUuidCreate(&pdnRefWithGuid->Guid);
    
    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              &pdnRefWithGuid->Guid, szMangledRef, &cchMangledRef);
    DPRINT3(2, "Mangled ref RDN is \"%*.*ls\".\n", cchMangledRef, cchMangledRef,
            szMangledRef);
    pdnMangledRef = THAllocEx(pTHS, pdnRefWithGuid->structLen + 100);
    AppendRDN(TestRoot,
              pdnMangledRef,
              pdnRefWithGuid->structLen + 100,
              szMangledRef,
              cchMangledRef,
              ATT_COMMON_NAME);

    pdnMangledRefChild         = MakeObjectNameEx("RefChild", pdnMangledRef);
    pdnMangledRefChildWithGuid = MakeObjectNameEx("RefChild", pdnMangledRef);
    
    DsUuidCreate(&pdnMangledRefChildWithGuid->Guid);
    
    // Create host objects.
    AddPropertyHost(pdnHost1, NonLinkedProperty);
    AddPropertyHost(pdnHost2, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefWithGuid, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, DOESNT_EXIST, 0);

    // Add reference to Ref.
    AddProperty(pdnHost1, pdnRefWithGuid, NonLinkedProperty);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefWithGuid, PHANTOM, 1);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, DOESNT_EXIST, 0);

    // Add reference to MangledRefChild.
    AddProperty(pdnHost2, pdnMangledRefChildWithGuid, NonLinkedProperty);

    // We just added a ref to CN=RefChild,CN=Ref%CNF:xyz,....
    // CN=REF%CNF:xyz should have been resolved to the CN=Ref record with guid
    // xyz, and CN=RefChild should have been added underneath it.
    // Therefore, CN=Ref should add a refcount and CN=RefChild should now be
    // present with a refcount of 1.

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnRefWithGuid, PHANTOM, 2);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, PHANTOM, 1);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, PHANTOM, 1);

    // Verify properties have right DNs/GUIDs.
    pdn = GetProperty(pdnHost1, 1, NonLinkedProperty);
    if (!DSNAME_IDENTICAL(pdn, pdnRefWithGuid))
        Fail("Wrong ref on Host1!");
    
    pdn = GetProperty(pdnHost2, 1, NonLinkedProperty);
    if (!DSNAME_SAME_GUID_SID(pdn, pdnMangledRefChildWithGuid))
        Fail("RefChild has wrong GUID/SID!");
    if (!DSNAME_SAME_STRING_NAME(pdn, pdnRefChild))
        Fail("RefChild has wrong string name!");

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnHost1);
    PhysicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnRefChild);
    PhysicallyDeleteObject(pdnRefWithGuid);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefWithGuid, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRef, DOESNT_EXIST, 0);
    VerifyRefCount(pdnRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChild, DOESNT_EXIST, 0);
    VerifyRefCount(pdnMangledRefChildWithGuid, DOESNT_EXIST, 0);
    
    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnRefWithGuid);
    FreeObjectName(pdnMangledRef);
    FreeObjectName(pdnRefChild);
    FreeObjectName(pdnMangledRefChild);
    FreeObjectName(pdnMangledRefChildWithGuid);

    ReportTest("UnmangleRDNTest");
}


void
PhantomRenameOnPromotionWithStructuralCollision(
    IN  PropertyType    type
    )
/*++

Routine Description:

    Assume the existence of the following records:
    
    DNT 10 = phantom, CN=foo,DC=corp,DC=com, guid n/a
    DNT 11 = phantom, CN=bar,CN=foo,DC=corp,DC=com, guid 1
    DNT 20 = phantom, CN=baz,DC=corp,DC=com, guid 2
    
    Replication now attempts to apply the object CN=foo,DC=corp,DC=com with guid
    2.  I.e., the guid matches that of the reference phantom at DNT 20, and the
    string name matches that of the structural phantom at DNT 10.
    
    In this case we want to promote the record that has the proper guid (at DNT
    20) to be a real object and rename the record to have the correct string
    name, but another record (DNT 10) has already laid claim to that string
    name.  So, we will essentially collapse DNT 10 and DNT 20 into DNT 20 first
    by reparenting all of DNT 10's children to DNT 20 then name munging DNT 10
    to avoid the name collision induced by changing the string name of DNT 20
    to be that of the object we're trying to add.
    
    Note that since DNT 10 has no associated guid, when we munge its name we
    have to invent a guid to do it with.  This violates the normal rule that
    you should be able to unmunge a munged name to produce the corresponding
    object guid, but note that since (1) this DNT has no direct references,
    since it is a structural phantom only and (2) we have reparented all of its
    children, this DNT should have no remaining references, ergo the ability
    to unmunge its name is unnecessary.
    
Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DSNAME *    pdnRefWithGuid;
    DSNAME *    pdnHost1;
    DSNAME *    pdnHost2;
    WCHAR       szMangledFoo[MAX_RDN_SIZE] = L"Foo";
    DWORD       cchMangledFoo = wcslen(szMangledFoo);
    DSNAME *    pdnStructuralFoo;
    DSNAME *    pdnBar;
    DSNAME *    pdnBaz;
    DSNAME *    pdnObjectFoo;
    DSNAME *    pdn;
    DWORD       cb;
    LPSTR       pszTestName = (NonLinkedProperty == type)
                                ? "PhantomRenameOnPromotionWithStructuralCollision(NonLinkedProperty)"
                                : "PhantomRenameOnPromotionWithStructuralCollision(LinkedProperty)";


    NewTest(pszTestName);

    // Derive DNs.
    pdnHost1         = MakeObjectNameEx("Host1", TestRoot);
    pdnHost2         = MakeObjectNameEx("Host2", TestRoot);
    pdnStructuralFoo = MakeObjectNameEx("foo", TestRoot);
    pdnBar           = MakeObjectNameEx("bar", pdnStructuralFoo);
    pdnBaz           = MakeObjectNameEx("baz", TestRoot);
    pdnObjectFoo     = MakeObjectNameEx("foo", TestRoot);

    DsUuidCreate(&pdnBar->Guid);
    DsUuidCreate(&pdnBaz->Guid);
    pdnObjectFoo->Guid = pdnBaz->Guid;
    
    // Create host objects.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |
    //  |--Host2 (obj, ref=1)
    AddPropertyHost(pdnHost1, type);
    AddPropertyHost(pdnHost2, type);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBar, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBaz, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObjectFoo, DOESNT_EXIST, 0);

    // Add reference to CN=Bar,CN=Foo,<TestRoot> on Host1.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Bar
    //  |
    //  |--Host2 (obj, ref=1)
    //  |
    //  |--Foo (phantom, ref=1, no guid)
    //      |
    //      |--Bar (phantom, ref=1, guid X)
    AddProperty(pdnHost1, pdnBar, type);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, PHANTOM, 1);
    VerifyRefCount(pdnBar, PHANTOM, 1);
    VerifyRefCount(pdnBaz, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObjectFoo, PHANTOM, 1); // same name as pdnStructuralFoo

    // Add reference to CN=Baz,<TestRoot> on Host2.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Bar
    //  |
    //  |--Host2 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Baz
    //  |
    //  |--Foo (phantom, ref=1, no guid)
    //  |   |
    //  |   |--Bar (phantom, ref=1, guid X)
    //  |
    //  |--Baz (phantom, ref=1, guid Y)
    AddProperty(pdnHost2, pdnBaz, type);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, PHANTOM, 1);
    VerifyRefCount(pdnBar, PHANTOM, 1);
    VerifyRefCount(pdnBaz, PHANTOM, 1);
    VerifyRefCount(pdnObjectFoo, PHANTOM, 1); // same guid as pdnBaz

    // Promote CN=Baz,<TestRoot> phantom to be real object CN=Foo,<TestRoot>,
    // requiring the DS to first rename the existing structural phantom
    // CN=Foo,<TestRoot>.
    //
    // TestRoot
    //  |
    //  |--Host1 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Bar
    //  |
    //  |--Host2 (obj, ref=1)
    //  |   >> gNonLinkedAttrTyp = Foo
    //  |
    //  |--Foo#CNF:xxx (phantom, ref=0, no guid)
    //  |
    //  |--Foo (obj, ref=3, guid Y)
    //      |
    //      |--Bar (phantom, ref=1, guid X)
    AddPropertyHost(pdnObjectFoo, type);

    // Reconstruct the munged name of pdnStructuralFoo using the guid exported
    // from dbsubj.c specifically for our test.
    // (This test hook exists only #ifdef INCLUDE_UNIT_TESTS on DBG builds.)
    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              &gLastGuidUsedToCoalescePhantoms, szMangledFoo, &cchMangledFoo);
    cb = pdnStructuralFoo->structLen + 100;
    pdnStructuralFoo = THReAllocEx(pTHStls, pdnStructuralFoo, cb);
    AppendRDN(TestRoot, pdnStructuralFoo, cb, szMangledFoo, cchMangledFoo,
              ATT_COMMON_NAME);

    VerifyRefCount(pdnHost1, REAL_OBJECT, 1);
    VerifyRefCount(pdnHost2, REAL_OBJECT, 1);
    VerifyRefCount(pdnStructuralFoo, PHANTOM, 0);
    VerifyRefCount(pdnBar, PHANTOM, 1); // has been reparented, but same guid/name
    VerifyRefCount(pdnBaz, REAL_OBJECT, 3); // same guid as pdnObjectFoo
    VerifyRefCount(pdnObjectFoo, REAL_OBJECT, 3); // 1 ref by pdnHost1, 1 ref from self, 1 ref as parent of bar
    
    // Verify properties have right DNs/GUIDs.
    pdn = GetProperty(pdnHost1, 1, type);
    if (!DSNAME_IDENTICAL(pdn, pdnBar))
        Fail("Wrong ref on Host1!");
    
    pdn = GetProperty(pdnHost2, 1, type);
    if (!DSNAME_IDENTICAL(pdn, pdnObjectFoo))
        Fail("Wrong ref on Host2!");
    if (!DSNAME_SAME_GUID_SID(pdn, pdnBaz))
        Fail("pdnObjectFoo has different GUID/SID from pdnBaz!");

    // Remove our test objects.
    LogicallyDeleteObject(pdnHost1);
    LogicallyDeleteObject(pdnHost2);
    LogicallyDeleteObject(pdnObjectFoo);
    PhysicallyDeleteObject(pdnStructuralFoo);
    PhysicallyDeleteObject(pdnBar);
    PhysicallyDeleteObject(pdnHost1);
    PhysicallyDeleteObject(pdnHost2);
    PhysicallyDeleteObject(pdnObjectFoo);

    VerifyRefCount(pdnHost1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnHost2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnStructuralFoo, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBar, DOESNT_EXIST, 0);
    VerifyRefCount(pdnBaz, DOESNT_EXIST, 0);
    VerifyRefCount(pdnObjectFoo, DOESNT_EXIST, 0);
    
    FreeObjectName(pdnHost1);
    FreeObjectName(pdnHost2);
    FreeObjectName(pdnStructuralFoo);
    FreeObjectName(pdnBar);
    FreeObjectName(pdnBaz);
    FreeObjectName(pdnObjectFoo);

    ReportTest(pszTestName);
}


void
ConflictedNcNameFixupTest(
    BOOL fSubref
    )

/*++

Routine Description:

    Test whether conflicted nc name fixup works. This feature is that when a cross ref
    is deleted, if there is another cross ref with a mangled version of the same nc name,
    we will mangle the old user of the nc name, and unmangle the new user of the nc name.

Arguments:

    fSubref - Whether this is testing the case case of the nc name being a phantom
              or the nc name being a subref.

Return Value:

    None

--*/

{
    THSTATE *pTHS = pTHStls;
    DSNAME *pdnNcName1, *pdnNcName2;
    DSNAME *pdnNewNcName1, *pdnNewNcName2;
    DSNAME *pdnCR1 = MakeObjectNameEx("refcounttestcr1", gAnchor.pPartitionsDN );
    DSNAME *pdnCR2 = MakeObjectNameEx("refcounttestcr2", gAnchor.pPartitionsDN );
    CROSS_REF_LIST * pCRL;
    BOOL fCR1Seen = FALSE, fCR2Seen = FALSE;

    if (!CheckRole( gAnchor.pPartitionsDN )) {
        return;
    }

    NewTest("ConflictedNcNameFixupTest");

    // establish nc name references
    if (fSubref) {
        // Child nc under domain this dsa holds
        pdnNcName1 = MakeObjectNameEx2("dc=child", gAnchor.pDomainDN);
        pdnNcName2 = MakeObjectNameEx2("dc=child", gAnchor.pDomainDN);
    } else {
        // Phantom references to new tree
        pdnNcName1 = MakeObjectNameEx3("dc=tree,dc=external");
        pdnNcName2 = MakeObjectNameEx3("dc=tree,dc=external");
    }

    DsUuidCreate( &pdnCR1->Guid );
    DsUuidCreate( &pdnCR2->Guid );

    DsUuidCreate( &pdnNcName1->Guid );
    DsUuidCreate( &pdnNcName2->Guid );

    // Pre-existential state
    VerifyRefCount(pdnCR1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnCR2, DOESNT_EXIST, 0);
    VerifyRefCount(pdnNcName1, DOESNT_EXIST, 0);
    VerifyRefCount(pdnNcName2, DOESNT_EXIST, 0);

    __try {
        // Create two cross-refs with conflicting nc name attributes

        AddCrossRef( pdnCR1, pdnNcName1, L"tree1.external" );

        AddCrossRef( pdnCR2, pdnNcName2, L"tree2.external" );

    // Force cross-ref cache to update so conflicted name appears
        ModifyCrossRef( pdnCR1 );
        ModifyCrossRef( pdnCR2 );

    // In the Cross-ref cache, we should now find two entries,
    // one with a conflicted name

        for( pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR ) {
            if (NameMatched(pCRL->CR.pObj, pdnCR1)) {
                Assert( NameMatched( pCRL->CR.pNC, pdnNcName1 ) );
                fCR1Seen = TRUE;
                pdnNewNcName1 = pCRL->CR.pNC;
            }
            if (NameMatched(pCRL->CR.pObj, pdnCR2)) {
                Assert( NameMatched( pCRL->CR.pNC, pdnNcName2 ) );
                fCR2Seen = TRUE;
                pdnNewNcName2 = pCRL->CR.pNC;
            }
        }
        if (!fCR1Seen || !fCR2Seen) {
            Fail("Crossref's not in initial state");
        }

        if (fSubref) {
            // In the subref case, name2 is mangled
            Assert( NameMatchedStringNameOnly( pdnNewNcName1, pdnNcName1 ) );
            Assert( !NameMatchedStringNameOnly( pdnNewNcName2, pdnNcName2 ) );
            DPRINT1( 0, "Subref Mangled name: %ws\n", pdnNewNcName2->StringName );
        } else {
            // In the phantom case, name1 is mangled
            Assert( !NameMatchedStringNameOnly( pdnNewNcName1, pdnNcName1 ) );
            DPRINT1( 0, "Phantom Mangled name: %ws\n", pdnNewNcName1->StringName );
            Assert( NameMatchedStringNameOnly( pdnNewNcName2, pdnNcName2 ) );
        }

        VerifyRefCount(pdnCR1, REAL_OBJECT, 1);
        if (fSubref) {
            VerifyRefCount(pdnNcName1, REAL_OBJECT, 3);
        } else {
            VerifyRefCount(pdnNcName1, PHANTOM, 1);
        }

        VerifyRefCount(pdnCR2, REAL_OBJECT, 1);
        if (fSubref) {
            VerifyRefCount(pdnNcName2, REAL_OBJECT, 3);
        } else {
            VerifyRefCount(pdnNcName2, PHANTOM, 1);
        }

        // Get rid of the cross-ref owning the good name
        // The act of deleting the cross ref will cause the name ownership
        // code to be executed, renaming the other reference
        // CheckNCNameRootOwnership => ModCrossRefCaching => AddObjCaching =>
        // MakeStoreableCRL expects fDSA/fDRA in this situation

        if (fSubref) {
            // name 1 is the good one

            pTHS->fDSA = TRUE;
            __try {
                LogicallyDeleteObject(pdnCR1);
            } __finally {
                pTHS->fDSA = FALSE;
            }
            VerifyRefCount(pdnCR1, TOMBSTONE, 1);
            VerifyRefCount(pdnNcName1, TOMBSTONE, 2);
            // Force cross-ref cache to update so conflicted name disappears appears
            ModifyCrossRef( pdnCR2 );
        } else {
            // name 2 is the good one
            pTHS->fDSA = TRUE;
            __try {
                LogicallyDeleteObject(pdnCR2);
            } __finally {
                pTHS->fDSA = FALSE;
            }
            VerifyRefCount(pdnCR2, TOMBSTONE, 1);
            VerifyRefCount(pdnNcName2, PHANTOM, 1);
            // Force cross-ref cache to update so conflicted name disappears appears
            ModifyCrossRef( pdnCR1 );
        }

        // In the Cross-ref cache, we should now find one entry with
        // the right name
        fCR1Seen = FALSE; fCR2Seen = FALSE;
        pdnNewNcName1 = NULL; pdnNewNcName2 = NULL;
        for( pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR ) {
            if (NameMatched(pCRL->CR.pObj, pdnCR1)) {
                Assert( NameMatched( pCRL->CR.pNC, pdnNcName1 ) );
                fCR1Seen = TRUE;
                pdnNewNcName1 = pCRL->CR.pNC;
            }
            if (NameMatched(pCRL->CR.pObj, pdnCR2)) {
                Assert( NameMatched( pCRL->CR.pNC, pdnNcName2 ) );
                fCR2Seen = TRUE;
                pdnNewNcName2 = pCRL->CR.pNC;
            }
        }
        if (fSubref) {
            // subref: name 2 is left
            if ( !fCR2Seen ) {
                Fail("Crossref's not in final state");
            }
            Assert( NameMatchedStringNameOnly( pdnNewNcName2, pdnNcName2 ) );
        
        } else {
            // phantom: name 1 is left
            if ( !fCR1Seen ) {
                Fail("Crossref's not in final state");
            }
            Assert( NameMatchedStringNameOnly( pdnNewNcName1, pdnNcName1 ) );
        }

    } __except (HandleAllExceptions(GetExceptionCode())) {
        NOTHING;
    }

    // Cleanup
    if (fSubref) {
        // subref: name 2 is left
        LogicallyDeleteObject(pdnCR2);
        VerifyRefCount(pdnCR2, TOMBSTONE, 1);
        VerifyRefCount(pdnNcName2, TOMBSTONE, 2);
    } else {
        // phantom: name 1 is left
        LogicallyDeleteObject(pdnCR1);
        VerifyRefCount(pdnCR1, TOMBSTONE, 1);
        VerifyRefCount(pdnNcName1, PHANTOM, 1);
    }

    ReportTest("ConflictedNcNameFixupTest");
} /* ConflictedNcNameFixupTest */


VOID
CrossRefAddNcNameFixupTest(
    BOOL fSubref
    )

/*++

Routine Description:

    This tests the case where a cross ref is added, and the nc name refers to an object
    which is deleted locally.

Arguments:

    fSubref - ncname refers to a subref or phantom

Return Value:

    None

--*/

{
    THSTATE *pTHS = pTHStls;
    DSNAME *pdnNcName1, *pdnNcName2, *pdnNcName3;
    DSNAME *pdnNewNcName1;
    DSNAME * pdnHost = MakeObjectName( "host" );
    DSNAME *pdnCR1;
    CROSS_REF_LIST * pCRL;
    BOOL fCR1Seen = FALSE;
    DWORD err, cb;
    WCHAR szMangledName[MAX_RDN_SIZE] = L"child";
    DWORD cchMangledName = wcslen(szMangledName);
    GUID guid;

    if (!CheckRole( gAnchor.pPartitionsDN )) {
        return;
    }

    NewTest("CrossRefAddNcNameFixupTest");

    // Create a host object

    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);
    AddPropertyHost(pdnHost, NonLinkedProperty);
    VerifyRefCount(pdnHost, REAL_OBJECT, 1);

    // Create a mangled reference to a child object

    DsUuidCreate( &guid );

    MangleRDN(MANGLE_OBJECT_RDN_FOR_DELETION,
              &guid, 
              szMangledName, 
              &cchMangledName);

    pdnNcName3 = MakeObjectNameEx3( "dc=tree" );

    cb = DSNameSizeFromLen( 20 + cchMangledName + gAnchor.pDomainDN->NameLen );
    pdnNcName1 = THAllocEx( pTHS, cb );
    err = AppendRDN( fSubref ? gAnchor.pDomainDN : pdnNcName3, 
                     pdnNcName1, 
                     cb, 
                     szMangledName, 
                     cchMangledName,
                     ATT_COMMON_NAME);
    Assert(!err);
    memcpy( &(pdnNcName1->Guid), &guid, sizeof(GUID) );

    VerifyRefCount(pdnNcName1, DOESNT_EXIST, 0);

    // Cause it to become a phantom

    AddProperty(pdnHost, pdnNcName1, NonLinkedProperty);
    VerifyRefCount(pdnNcName1, PHANTOM, 1);

    DPRINT1( 0, "Before name: %ws\n", pdnNcName1->StringName );

    // An unmangled reference to the same
    pdnNcName2 = MakeObjectNameEx( "child", fSubref ? gAnchor.pDomainDN : pdnNcName3 );
    memcpy( &(pdnNcName2->Guid), &guid, sizeof(GUID) );
    VerifyRefCount(pdnNcName2, PHANTOM, 1);

    // Try to create a cross-ref referencing this deleted phantom/subref
    pdnCR1 = MakeObjectNameEx("refcounttestcr3", gAnchor.pPartitionsDN );
    DsUuidCreate( &pdnCR1->Guid );

    VerifyRefCount(pdnCR1, DOESNT_EXIST, 0);

    __try {
        // In order to get this to work, the name incoming in the stream must be unmangled,
        // but the resulting name from resolving in the database must be mangled.
        AddCrossRef( pdnCR1, pdnNcName2, L"tree3.external" );

        // First the delete mangled name reference is found as a phantom.
        // Then it was unmangled, but still a phantom.
        // Then it was promoted to an auto subref.  Whether the target of NCName is a phantom
        // or subref depends on where the name sits in the namespace.
        if (fSubref) {
            // The name reference should be a object
            // Ref count: 1 for self, 1 for ncname, 1 for host, 1 for catalog
            VerifyRefCount(pdnNcName1, REAL_OBJECT, 4);
        } else {
            // Ref count: 1 for ncname, 1 for host
            VerifyRefCount(pdnNcName1, PHANTOM, 2);
        }

        // Phantom should no longer be mangled
        pdnNewNcName1 = NULL;
        SYNC_TRANS_READ();
        __try {
            err = DBFindDSName(pTHS->pDB, pdnNcName1);
            if ( (err != 0) && (err!=DIRERR_NOT_AN_OBJECT) ) {
                Fail("Can't find object/phantom");
            } else {
                pdnNewNcName1 = DBGetCurrentDSName(pTHS->pDB);
            }
        } __finally {
            CLEAN_BEFORE_RETURN(0);
        }
        if (pdnNewNcName1) {
            DPRINT1( 0, "After name: %ws\n", pdnNewNcName1->StringName );
            if (DSNAME_SAME_STRING_NAME(pdnNcName1, pdnNewNcName1)) {
                Fail("Name not unmangled!");
            }
            FreeObjectName(pdnNewNcName1);
            pdnNewNcName1 = NULL;
        } else {
            Fail("Couldn't fetch object/phantom dsname!");
        }

        // The cross ref cache should show the correct name
        fCR1Seen = FALSE;
        pdnNewNcName1 = NULL;
        for( pCRL = gAnchor.pCRL; pCRL != NULL; pCRL = pCRL->pNextCR ) {
            if (NameMatched(pCRL->CR.pObj, pdnCR1)) {
                Assert( NameMatched( pCRL->CR.pNC, pdnNcName1 ) );
                fCR1Seen = TRUE;
                pdnNewNcName1 = pCRL->CR.pNC;
            }
        }

        if ( !fCR1Seen ) {
            Fail("Crossref's not in final state");
        } else {
            DPRINT1( 0, "Cross ref ncName: %ws\n", pdnNewNcName1->StringName );
            Assert( !(NameMatchedStringNameOnly( pdnNcName1, pdnNewNcName1 ) ) );
        }
    } __except (HandleAllExceptions(GetExceptionCode())) {
        NOTHING;
    }

    if (fSubref) {
        // The name reference should be a object
        // 1 for self, 1 for ncname, 1 for host, 1 for catalog
        VerifyRefCount(pdnNcName1, REAL_OBJECT, 4);
    } else {
        // Ref count: 1 for ncname, 1 for host
        VerifyRefCount(pdnNcName1, PHANTOM, 2);
    }

    // Clean up the host
    LogicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, TOMBSTONE, 1);
    if (fSubref) {
        // 1 for self, 1 for ncname, 1 for catalog
        VerifyRefCount(pdnNcName1, REAL_OBJECT, 3);
    } else {
        // Ref count: 1 for ncname
        VerifyRefCount(pdnNcName1, PHANTOM, 1);
    }

    // Get rid of the cross ref
    // This will call DelAutoSubref to get rid of the catalog ref
    LogicallyDeleteObject(pdnCR1);
    VerifyRefCount(pdnCR1, TOMBSTONE, 1);
    if (fSubref) {
        // 1 for self, 1 for ncname still on cr tombstone
        VerifyRefCount(pdnNcName1, TOMBSTONE, 2);
    } else {
        // Ref count: 1 for ncname
        VerifyRefCount(pdnNcName1, PHANTOM, 1);
    }

    // Get rid of cr
    PhysicallyDeleteObject(pdnCR1);
    VerifyRefCount(pdnCR1, DOESNT_EXIST, 0);
    if (fSubref) {
        // 1 for self
        VerifyRefCount(pdnNcName1, TOMBSTONE, 1);
    } else {
        VerifyRefCount(pdnNcName1, PHANTOM, 0);
    }

    // Get rid of subref
    PhysicallyDeleteObject(pdnNcName1);
    VerifyRefCount(pdnNcName1, DOESNT_EXIST, 0);

    // Get rid of host
    PhysicallyDeleteObject(pdnHost);
    VerifyRefCount(pdnHost, DOESNT_EXIST, 0);

    FreeObjectName(pdnNcName1);

    ReportTest("CrossRefAddNcNameFixupTest");

} /* CrossRefAddNcNameFixupTest */

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Local helper routines.                                           //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
NewTest(
    CHAR    *TestName)
{
    fTestPassed = TRUE;

    DPRINT1( 0, "%s ...\n", TestName );
}

void
ReportTest(
    CHAR    *TestName)
{
    DPRINT2( 0, "%s - %s\n\n", TestName, (fTestPassed ? "PASS" : "FAIL") );
}

void
_Fail(
    CHAR    *msg,
    DWORD   line)
{
    fTestPassed = FALSE;
    DPRINT2( 0, "Refcount test error: %s - line(%d)\n", msg, line );
}

CHAR PrintGuidBuffer[100];

CHAR *
GuidToString(
    GUID    *Guid)
{
    DWORD   i;
    BYTE    *pb, low, high;

    if ( !Guid )
    {
        strcpy(PrintGuidBuffer, "NULL");
    }
    else
    {
        memset(PrintGuidBuffer, 0, sizeof(PrintGuidBuffer));

        pb = (BYTE *) Guid;

        for ( i = 0; i < sizeof(GUID); i++ )
        {
            low = pb[i] & 0xf;
            high = (pb[i] & 0xf0) >> 4;

            if ( low <= 0x9 )
            {
                PrintGuidBuffer[2*i] = '0' + low;
            }
            else
            {
                PrintGuidBuffer[2*i] = 'A' + low - 0x9;
            }

            if ( high <= 0x9 )
            {
                PrintGuidBuffer[(2*i)+1] = '0' + high;
            }
            else
            {
                PrintGuidBuffer[(2*i)+1] = 'A' + high - 0x9;
            }
        }
    }

    return(PrintGuidBuffer);
}

void
FreeObjectName(
    DSNAME  *pDSName)
{
    THFree(pDSName);
}

DSNAME *
MakeObjectNameEx(
    CHAR    *RDN,
    DSNAME  *pdnParent)
{
    THSTATE *pTHS=pTHStls;
    DWORD   cBytes;
    DWORD   len;
    DSNAME  *pDSName;

    len = strlen("CN=") +
          strlen(RDN) +
          strlen(",") +
          wcslen(pdnParent->StringName);
    cBytes = DSNameSizeFromLen(len);

    pDSName = (DSNAME *) THAllocEx(pTHS, cBytes);
    memset(pDSName, 0, cBytes);
    wcscpy(pDSName->StringName, L"CN=");
    mbstowcs(&pDSName->StringName[3], RDN, strlen(RDN));
    wcscat(pDSName->StringName, L",");
    wcscat(pDSName->StringName, pdnParent->StringName);
    pDSName->NameLen = len;
    pDSName->structLen = cBytes;

    return(pDSName);
}
    
DSNAME *
MakeObjectNameEx2(
    CHAR    *RDN,
    DSNAME  *pdnParent)
{
    THSTATE *pTHS=pTHStls;
    DWORD   cBytes;
    DWORD   len;
    DSNAME  *pDSName;

    len = strlen(RDN) +
          strlen(",") +
          wcslen(pdnParent->StringName);
    cBytes = DSNameSizeFromLen(len);

    pDSName = (DSNAME *) THAllocEx(pTHS, cBytes);
    memset(pDSName, 0, cBytes);
    mbstowcs(pDSName->StringName, RDN, strlen(RDN));
    wcscat(pDSName->StringName, L",");
    wcscat(pDSName->StringName, pdnParent->StringName);
    pDSName->NameLen = len;
    pDSName->structLen = cBytes;

    return(pDSName);
}

DSNAME *
MakeObjectNameEx3(
    CHAR    *RDN
    )
{
    THSTATE *pTHS=pTHStls;
    DWORD   cBytes;
    DWORD   len;
    DSNAME  *pDSName;

    len = strlen(RDN);
    cBytes = DSNameSizeFromLen(len);

    pDSName = (DSNAME *) THAllocEx(pTHS, cBytes);
    memset(pDSName, 0, cBytes);
    mbstowcs(pDSName->StringName, RDN, strlen(RDN));
    pDSName->NameLen = len;
    pDSName->structLen = cBytes;

    return(pDSName);
}


void
VerifyRefCountHelper(
    DWORD   ExpectedRefCount,
    DWORD   dwLine)
{
    DWORD   cRefs;
    DWORD   cRead;

    if ( DBGetSingleValue(pTHStls->pDB,
                          FIXED_ATT_REFCOUNT,
                          &cRefs,
                          sizeof(cRefs),
                          &cRead) )
    {
        _Fail("Can't read ref count", dwLine);
        return;
    }

    Assert(sizeof(cRefs) == cRead);

    if ( cRefs != ExpectedRefCount )
    {
        _Fail("Reference count mismatch", dwLine);
        DPRINT2( 0, "ExpectedRefCount(%d) - ActualRefCount(%d)\n",
                 ExpectedRefCount, cRefs );
        return;
    }
}

BOOL
IsDeletedHelper(void)
{
    BOOL    fDeleted = FALSE;
    DWORD   cRead;

    if ( DBGetSingleValue(pTHStls->pDB,
                          ATT_IS_DELETED,
                          &fDeleted,
                          sizeof(fDeleted),
                          &cRead) )
    {
        return(FALSE);
    }
    
    Assert(sizeof(fDeleted) == cRead);

    DPRINT1( 3, "IsDeleted(%s)\n", (fDeleted ? "TRUE" : "FALSE") );

    return(fDeleted);
}

void
VerifyRefCountEx(
    DSNAME  *pObject, 
    DWORD   ObjectType, 
    DWORD   ExpectedRefCount,
    DWORD   dwLine)
{
    DWORD   dwErr;
    BOOL    fDeleted;
    DWORD   i;
    CHAR    *pszType;

    switch ( ObjectType )
    {
    case TOMBSTONE:

        // Tombstones can only be looked up by guid.
        Assert(!fNullUuid(&pObject->Guid));
        pszType = "TOMBSTONE";
        break;

    case DOESNT_EXIST:

        // Non-existence test can be by name and/or guid.
        pszType = "DOESNT_EXIST";
        break;

    case PHANTOM:

        // Phantoms can be looked up by name or guid.
        // Guid case is for when TOMBSTONE reverts to a PHANTOM
        // but name stays as te TOMBSTONE name which is based
        // on the guid.
        pszType = "PHANTOM";
        break;

    case REAL_OBJECT:

        // Real objects can only be looked up by name.
        pszType = "REAL_OBJECT";
        break;

    default:

        pszType = "UNKNOWN";
        break;
    }

    DPRINT3( 3, "VerifyRefCount(%ls, %s, %s)\n", 
             (pObject->NameLen ? pObject->StringName : L"NULL"),
             GuidToString(&pObject->Guid), pszType );
            
    SYNC_TRANS_READ();
    
    __try
    {
        switch ( ObjectType )
        {
        case REAL_OBJECT:

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( dwErr )
            {
                _Fail("REAL_OBJECT not found", dwLine);
                leave;
            }

            if ( IsDeletedHelper() )
            {
                _Fail("REAL_OBJECT is deleted", dwLine);
                leave;
            }

            VerifyRefCountHelper(ExpectedRefCount, dwLine);
            leave;

        case TOMBSTONE:

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( dwErr )
            {
                _Fail("TOMBSTONE not found", dwLine);
                leave;
            }

            if ( !IsDeletedHelper() )
            {
                _Fail("TOMBSTONE is not deleted", dwLine);
                leave;
            }

            VerifyRefCountHelper(ExpectedRefCount, dwLine);
            leave;

        case PHANTOM:

            dwErr = DIRERR_OBJ_NOT_FOUND;

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( DIRERR_NOT_AN_OBJECT != dwErr )
            {
                _Fail("PHANTOM not found", dwLine);
                leave;
            }

            if ( IsDeletedHelper() )
            {
                _Fail("PHANTOM is deleted", dwLine);
                leave;
            }

            VerifyRefCountHelper(ExpectedRefCount, dwLine);
            leave;

        case DOESNT_EXIST:

            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( DIRERR_OBJ_NOT_FOUND != dwErr )
            {
                _Fail("DOESNT_EXIST exists", dwLine);
                leave;
            }

            leave;

        default:

            _Fail("Unsupported object type", dwLine);
            leave;
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }
}

// stolen #defines etc. from ..\dblayer\dbintrnl.h
#define DBSYN_INQ       0
int
IntExtDist(DBPOS FAR *pDB, USHORT extTableOp,
           ULONG intLen, UCHAR *pIntVal,
           ULONG *pExtLen, UCHAR **ppExtVal,
           ULONG ulUpdateDnt, JET_TABLEID jTbl,
           ULONG flags);
void
VerifyStringNameEx(
    DSNAME  *pObject, 
    DWORD   dwLine)
{
    DWORD   dwErr;
    DWORD   cbName=0;
    CHAR    *pszType;
    DSNAME   GuidOnlyName, *pNewDN=NULL;
    THSTATE  *pTHS = pTHStls;

    memcpy(&GuidOnlyName, pObject, sizeof(DSNAME));

    GuidOnlyName.NameLen = 0;
    GuidOnlyName.structLen = DSNameSizeFromLen(0);
    Assert(GuidOnlyName.structLen <= sizeof(DSNAME));
    Assert(!fNullUuid(&GuidOnlyName.Guid));

    SYNC_TRANS_READ();
    
    __try
    {
        __try {
            dwErr = DBFindDSName(pTHS->pDB, &GuidOnlyName);
        }
        __except (HandleMostExceptions(GetExceptionCode())) {
            dwErr = DIRERR_OBJ_NOT_FOUND;
        }

        switch(dwErr) {
        case 0:
        case DIRERR_NOT_AN_OBJECT:
            // Normal object, or phantom.
            // Turn the DNT into the dsname (don't just read the name off
            // the object, phantoms don't have such a thing.
            
            if(IntExtDist(pTHS->pDB, DBSYN_INQ, sizeof(DWORD),
                          (PUCHAR)&pTHS->pDB->DNT,
                          &cbName, (PUCHAR *)&pNewDN, 0, pTHS->pDB->JetObjTbl,
                          0)) { 
                Fail("Can't read name for string name compare");                
            }
            else {
                if(!NameMatchedStringNameOnly(pObject, pNewDN)) {
                    _Fail("String Name didn't match", dwLine);
                }
            }
            break;
        default:
            _Fail("Obj not found for string name verify", dwLine);
            leave;
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }
}

void
CommonAddObject(
    DSNAME  *pObject,
    ATTRTYP  ObjectClass)
{
    THSTATE *               pTHS = pTHStls;
    ADDARG                  addArg;
    ADDRES                  *pAddRes = NULL;
    ATTRVAL                 ObjectClassVal = {sizeof(ObjectClass),
                                              (UCHAR *) &ObjectClass};
    ATTRVAL                 SDVal = { 0 };
    ATTR                    Attrs[2] =
                                { {ATT_OBJECT_CLASS, {1, &ObjectClassVal}},
                                  {ATT_NT_SECURITY_DESCRIPTOR, {1, &SDVal}}
                                };
    ATTRBLOCK               AttrBlock = { 2, Attrs };
    BOOL                    fDsaSave;
    DWORD                   winError;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    DPRINT1( 3, "CommonAddObject(%ls)\n", pObject->StringName );

    // Create a security descriptor.

    #define DEFAULT_SD \
        L"O:DAG:DAD:(A;CI;RPWPCCDCLCSWSD;;;DA)S:(AU;FA;RPWPCCDCLCSWSD;;;DA)"

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            DEFAULT_SD, SDDL_REVISION_1, &pSD, &SDVal.valLen)) {
        winError = GetLastError();
        Fail("SD conversion failed");
        DPRINT1(0, "SD conversion returned %u\n", winError);
    }

    SDVal.pVal = (BYTE *) pSD;
    Assert(SDVal.pVal && SDVal.valLen);

    // Perform as fDSA so we can predefine GUIDs if we like.

    fDsaSave = pTHS->fDSA;
    pTHS->fDSA = TRUE;

    __try
    {
        // Construct add arguments.

        memset(&addArg, 0, sizeof(ADDARG));
        addArg.pObject = pObject;
        addArg.AttrBlock = AttrBlock;
        InitCommarg(&addArg.CommArg);

        // Core re-allocs the ATTR array - so we need to THAlloc it.

        addArg.AttrBlock.pAttr = (ATTR *) THAllocEx(pTHS, sizeof(Attrs));
        memcpy(addArg.AttrBlock.pAttr, Attrs, sizeof(Attrs));

        // Do the add.

        if ( DirAddEntry(&addArg, &pAddRes) )
        {
            Fail("CommonAddObject");
        }
    }
    __finally
    {
        pTHS->fDSA = fDsaSave;

        if (pSD)
        {
            LocalFree(pSD);
        }
    }
}

void
AddCrossRef(
    DSNAME  *pObject,
    DSNAME  *pNcName,
    LPWSTR   pszDnsRoot
    )
/*
 We need to local cross-ref's on this machine. How hard can it be?
 */
{
    DWORD                   bEnabled = TRUE;
    DWORD                   ulSystemFlags = 0;  // External, fewer checks that way!
    ATTRTYP                 ObjectClass = CLASS_CROSS_REF;
    THSTATE *               pTHS = pTHStls;
    ADDARG                  addArg;
    ADDRES                  *pAddRes = NULL;
    ATTRVAL                 ObjectClassVal = {sizeof(ObjectClass),
                                              (UCHAR *) &ObjectClass};
    ATTRVAL                 SDVal = { 0 };
    ATTRVAL                 NcNameVal = { pNcName->structLen, (UCHAR *) pNcName };
    ATTRVAL                 DnsRootVal = { wcslen( pszDnsRoot ) * sizeof(WCHAR),
                                               (UCHAR *) pszDnsRoot };
    ATTRVAL                 EnabledVal = {sizeof(bEnabled),
                                              (UCHAR *) &bEnabled};
    ATTRVAL                 SystemFlagsVal = {sizeof(ulSystemFlags),
                                              (UCHAR *) &ulSystemFlags};
    ATTR                    Attrs[6] = {
        {ATT_OBJECT_CLASS, {1, &ObjectClassVal}},
        {ATT_NT_SECURITY_DESCRIPTOR, {1, &SDVal}},
        {ATT_NC_NAME, {1, &NcNameVal}},
        {ATT_DNS_ROOT, {1, &DnsRootVal}},
        {ATT_ENABLED, {1, &EnabledVal }},
        {ATT_SYSTEM_FLAGS, {1, &SystemFlagsVal }}
    };
    ATTRBLOCK               AttrBlock = { 6, Attrs };
    DWORD                   winError, err;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    ADDCROSSREFINFO *   pCRInfo;
    COMMRES CommRes;
    ENTINF *pEI = NULL;

    DPRINT1( 3, "AddCrossRef(%ls)\n", pObject->StringName );

    // Create a security descriptor.

    #define DEFAULT_SD \
        L"O:DAG:DAD:(A;CI;RPWPCCDCLCSWSD;;;DA)S:(AU;FA;RPWPCCDCLCSWSD;;;DA)"

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            DEFAULT_SD, SDDL_REVISION_1, &pSD, &SDVal.valLen)) {
        winError = GetLastError();
        Fail("SD conversion failed");
        DPRINT1(0, "SD conversion returned %u\n", winError);
    }

    SDVal.pVal = (BYTE *) pSD;
    Assert(SDVal.pVal && SDVal.valLen);

#if 0
    // Taken from AddNewDomainCrossRef - do we need it?
    // Add NC-Name value to GC verify cache else VerifyDSNameAtts will
    // claim this DN doesn't correspond to an existing object.
    pEI = THAllocEx(pTHS, sizeof(ENTINF));
    pEI->pName = pNcName;
    GCVerifyCacheAdd(NULL,pEI);

    // Set up cross ref info needed for creation
    // This gets freed by VerifyNcName in LocalAdd...
    pCRInfo = THAllocEx(pTHS, sizeof(ADDCROSSREFINFO));
    pCRInfo->pdnNcName = pNcName;
    pCRInfo->bEnabled = bEnabled;
    pCRInfo->ulSysFlags = ulSystemFlags;

    PreTransVerifyNcName(pTHS, pCRInfo);
    if(pTHS->errCode){
        Fail("PreTransVerifyNcName");
        return;
    }
#endif

    // Perform as fDRA so we can skip checks
    pTHS->fDRA = TRUE;

    SYNC_TRANS_WRITE();

    __try
    {
        // Construct add arguments.

        memset(&addArg, 0, sizeof(ADDARG));
        addArg.pObject = pObject;
        addArg.AttrBlock = AttrBlock;
//        addArg.pCRInfo = pCRInfo;
        InitCommarg(&addArg.CommArg);

        // Core re-allocs the ATTR array - so we need to THAlloc it.

        addArg.AttrBlock.pAttr = (ATTR *) THAllocEx(pTHS, sizeof(Attrs));
        memcpy(addArg.AttrBlock.pAttr, Attrs, sizeof(Attrs));

        // Set up the parent
        err = DoNameRes(pTHS,
                        0,
                        gAnchor.pPartitionsDN,
                        &addArg.CommArg,
                        &CommRes,
                        &addArg.pResParent);
        if (err) {
            Fail("DoNameRes parent");
            __leave;
        }

        // Do the add.

        err = LocalAdd(pTHS, &addArg, FALSE);
        if (err) {
            Fail("AddCrossRef");
            __leave;
        }
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( err );

        pTHS->fDRA = FALSE;

        if (pSD)
        {
            LocalFree(pSD);
        }
    }
}


void
ModifyCrossRef(
    DSNAME *pObject
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD err;
    DWORD bEnabled = TRUE;
    MODIFYARG       modarg;
    THSTATE *               pTHS = pTHStls;

    // Perform as fDRA so we can skip checks
    // Otherwise, we'd need to be the domain naming fsmo master
    pTHS->fDRA = TRUE;

    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName(pTHS->pDB, pObject);
        if (err) Fail("Can't find Object");

        memset(&modarg, 0, sizeof(modarg));
        modarg.pObject = pObject;
        modarg.count = 1;
        InitCommarg(&modarg.CommArg);
        modarg.CommArg.Svccntl.fPermissiveModify = TRUE;
        modarg.pResObj = CreateResObj(pTHS->pDB, modarg.pObject);

        modarg.FirstMod.choice = AT_CHOICE_REMOVE_ATT;
        modarg.FirstMod.AttrInf.attrTyp = ATT_ENABLED;
        modarg.FirstMod.AttrInf.AttrVal.valCount = 0;
        modarg.FirstMod.pNextMod = NULL;

        err = LocalModify(pTHS, &modarg);
        if (err) {
            Fail("Modify Cross Ref");
            __leave;
        }
    }
    __finally
    {
        // Restore
        pTHS->fDRA = FALSE;

        CLEAN_BEFORE_RETURN( err );
    }
}


void
AddObject(
    DSNAME  *pObject)
{
    CommonAddObject(pObject, CLASS_CONTACT);
}

void
AddPropertyHost(
    DSNAME         *pObject,
    PropertyType    type)
{
    // CLASS_CONTACT can have both linked and non-linked DSNAME-valued
    // properties.  The linked property is gNonLinkedAttrTyp.  The non-linked
    // property is gLinkedAttrTyp.

    CommonAddObject(pObject, CLASS_CONTACT);
}

void
CommonAddProperty(
    DSNAME  *pHost, 
    DSNAME  *pObject,
    ATTRTYP attrTyp)
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err = 0;
                                        
    DPRINT3( 3, "CommonAddProperty(%ls, %ls, %s)\n",
             pHost->StringName, pObject->StringName,
             (attrTyp == gNonLinkedAttrTyp ? "Linked" : "NotLinked") );

    SYNC_TRANS_WRITE();
    __try {
        err = DBFindDSName(pTHS->pDB, pHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBAddAttVal(pTHS->pDB, attrTyp, pObject->structLen, pObject);
            if (err) {
                Fail("Can't add value!");
            }
            else {
                err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
                if (err) {
                    Fail("Can't replace host!");
                }
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(err);
    }
}


void
AddProperty(
    DSNAME          *pHost, 
    DSNAME          *pLinkedObject,
    PropertyType    type)
{
    if ( LinkedProperty == type )
        CommonAddProperty(pHost, pLinkedObject, gNonLinkedAttrTyp);
    else
        CommonAddProperty(pHost, pLinkedObject, gLinkedAttrTyp);
}

void
CommonRemoveProperty(
    DSNAME  *pHost, 
    DSNAME  *pObject,
    ATTRTYP attrTyp)
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err = 0;
                                        
    DPRINT3( 3, "CommonRemoveProperty(%ls, %ls, %s)\n", 
             pHost->StringName, pObject->StringName,
             (attrTyp == gNonLinkedAttrTyp ? "Linked" : "NotLinked") );

    SYNC_TRANS_WRITE();
    __try {
        err = DBFindDSName(pTHS->pDB, pHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBRemAttVal(pTHS->pDB, attrTyp, pObject->structLen, pObject);
            if (err) {
                Fail("Can't remove value!");
            }
            else {
                err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
                if (err) {
                    Fail("Can't replace host!");
                }
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(err);
    }
}

void
CommonRemoveAttribute(
    DSNAME  *pHost, 
    ATTRTYP attrTyp)
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err = 0;
                                        
    DPRINT1( 3, "CommonRemoveAttribute(%ls)\n", pHost->StringName );

    SYNC_TRANS_WRITE();
    __try {
        err = DBFindDSName(pTHS->pDB, pHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBRemAtt(pTHS->pDB, attrTyp );
            if (err) {
                Fail("Can't remove attribute!");
            }
            else {
                err = DBRepl(pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
                if (err) {
                    Fail("Can't replace host!");
                }
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(err);
    }
}

void
RemoveProperty(
    DSNAME          *pHost, 
    DSNAME          *pLinkedObject,
    PropertyType    type)
{
    if ( LinkedProperty == type )
        CommonRemoveProperty(pHost, pLinkedObject, gNonLinkedAttrTyp);
    else
        CommonRemoveProperty(pHost, pLinkedObject, gLinkedAttrTyp);
}

DSNAME *
CommonGetProperty(
    DSNAME * pdnHost, 
    DWORD    iValue,
    ATTRTYP  attrTyp
    )
{
    THSTATE * pTHS = pTHStls;
    DSNAME *  pdn = NULL;
    DWORD     cb;
    DWORD     err;

    DPRINT3( 3, "CommonGetProperty(%ls, %d, %s)\n", 
             pdnHost->StringName, iValue,
             (attrTyp == gNonLinkedAttrTyp ? "Linked" : "NotLinked") );

    if (!iValue) {
        Fail("iValue is 1-based, not 0-based!");
    }

    SYNC_TRANS_READ();
    __try {
        err = DBFindDSName(pTHS->pDB, pdnHost);
        if (err) {
            Fail("Can't find host!");
        }
        else {
            err = DBGetAttVal(pTHS->pDB, iValue, attrTyp, 0, 0, &cb,
                              (BYTE **) &pdn);
            if (err) {
                Fail("Can't read value!");
            }
        }
    }
    __finally {
        CLEAN_BEFORE_RETURN(0);
    }

    return pdn;
}

DSNAME *
GetProperty(
    DSNAME *     pdnHost, 
    DWORD        iValue,
    PropertyType type
    )
{
    if (LinkedProperty == type)
        return CommonGetProperty(pdnHost, iValue, gNonLinkedAttrTyp);
    else
        return CommonGetProperty(pdnHost, iValue, gLinkedAttrTyp);
}

DSNAME *
GetObjectName(
    DSNAME * pdn 
    )
{
    return CommonGetProperty(pdn, 1, ATT_OBJ_DIST_NAME);
}

void
LogicallyDeleteObject(
    DSNAME  *pObject)
{
    REMOVEARG           removeArg;
    REMOVERES           *pRemoveRes = NULL;
    DWORD               dwErr;
    ULONG               cbGuid;
    GUID *              pGuid;

    DPRINT1( 3, "LogicallyDeleteObject(%ls)\n", pObject->StringName );

    if (fNullUuid(&pObject->Guid))
    {
        // First get the object's GUID.

        SYNC_TRANS_WRITE();

        __try
        {
            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( dwErr )
            {
                Fail("Can't find object to logically delete");
                leave;
            }

            pGuid = &pObject->Guid;

            dwErr = DBGetAttVal(pTHStls->pDB,
                                1,
                                ATT_OBJECT_GUID,
                                DBGETATTVAL_fCONSTANT,
                                sizeof(GUID),
                                &cbGuid,
                                (BYTE **) &pGuid);

            if ( dwErr )
            {
                Fail("Can't get object guid");
                leave;
            }

            if ( IsDeletedHelper() )
            {
                Fail("Object already logically deleted");
                leave;
            }

            Assert(sizeof(GUID) == cbGuid);
        }
        __finally
        {
            CLEAN_BEFORE_RETURN(0);
        }

        DPRINT1( 3, "\tGuid(%s)\n", GuidToString(&pObject->Guid) );
    }

    // Now delete the object.

    // Construct remove arguments.

    memset(&removeArg, 0, sizeof(REMOVEARG));
    removeArg.pObject = pObject;
    InitCommarg(&removeArg.CommArg);

    // Do the remove.

    if ( DirRemoveEntry(&removeArg, &pRemoveRes) )
    {
        Fail("LogicallyDeleteObject");
    }
}

void
PhysicallyDeleteObjectEx(
        DSNAME  *pObject,
        DWORD    dwLine)
{
    DWORD   dwErr = 0;
    DWORD   i;

    DPRINT1( 3, "PhysicallyDeleteObject(%s)\n", GuidToString(&pObject->Guid) );

    // NOTE: If the object is currently a tombstone, we must perform the
    // DBPhysDel() twice, in two distinct transacations.
    //
    // This is because part of physically deleting the object
    // is removing most of its remaining attributes, which, if this object is
    // currently a tombstone, includes ATT_OBJ_DIST_NAME.  ATT_OBJ_DIST_NAME
    // carries a refcount on the DNT we're trying to physically delete.
    // We physically delete the DNT only if its refcount is 0, so since we
    // don't apply escrowed updates until we're committing the transaction,
    // the refcount we read will still include the one for ATT_OBJ_DIST_NAME.
    // Thus, we must first commit the escrowed update, after which we can
    // physically delete the DNT on the next pass (assuming it has no other
    // references).

    for ( i = 0; (0 == dwErr) && (i < 2); i++ )
    {
        SYNC_TRANS_WRITE();
                                            
        __try
        {
            __try
            {
                dwErr = DBFindDSName(pTHStls->pDB, pObject);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            // Allow for deletion of REAL_OBJECTs and PHANTOMs.

            if ( (0 != dwErr) && (DIRERR_NOT_AN_OBJECT != dwErr) )
            {
                if (0 == i)
                {
                    _Fail("Can't find object to physically delete", dwLine);
                }

                leave;
            }

            if ( DBPhysDel(pTHStls->pDB, TRUE, NULL) )
            {
                _Fail("PhysicallyDeleteObject", dwLine);
                leave;
            }
        }
        __finally
        {
            CLEAN_BEFORE_RETURN(0);
        }
    }
}

void
RefCountTestSetup(void)
{
    THSTATE     *pTHS = pTHStls;
    DWORD       cbDomainRoot = 0;
    DSNAME *    pdnDomainRoot = NULL;
    UUID        uuid;
    LPWSTR      pwszUuid;
    NTSTATUS    NtStatus;

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot);
    if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
        pdnDomainRoot = (DSNAME *)THAllocEx(pTHS, cbDomainRoot);
    } else {
        Fail("GetConfigurationName");
        return;
    }

    if (GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot))
    {
        THFree(pdnDomainRoot);
        Fail("GetConfigurationName");
        return;
    }

    DsUuidCreate( &uuid );
    UuidToStringW( &uuid, &pwszUuid );

    AppendRDN(
        pdnDomainRoot,
        TestRoot,
        TEST_ROOT_SIZE,
        pwszUuid,
        lstrlenW( pwszUuid ),
        ATT_COMMON_NAME
        );

    RpcStringFreeW( &pwszUuid );
    THFree(pdnDomainRoot);

    CommonAddObject( TestRoot, CLASS_CONTAINER );
}
    

// this test setup created an organizational Unit as the test container
// this allows us to create other OU's under this.
void
RefCountTestSetup2(void)
{
    THSTATE     *pTHS = pTHStls;
    DWORD       cbDomainRoot = 0;
    DSNAME *    pdnDomainRoot = NULL;
    UUID        uuid;
    LPWSTR      pwszUuid;
    NTSTATUS    NtStatus;

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot);
    if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
        pdnDomainRoot = (DSNAME *)THAllocEx(pTHS, cbDomainRoot);
    } else {
        Fail("GetConfigurationName");
        return;
    }

    if (GetConfigurationName(DSCONFIGNAME_DOMAIN, &cbDomainRoot, pdnDomainRoot))
    {
        THFree(pdnDomainRoot);
        Fail("GetConfigurationName");
        return;
    }

    DsUuidCreate( &uuid );
    UuidToStringW( &uuid, &pwszUuid );

    AppendRDN(
        pdnDomainRoot,
        TestRoot,
        TEST_ROOT_SIZE,
        pwszUuid,
        lstrlenW( pwszUuid ),
        ATT_ORGANIZATIONAL_UNIT_NAME
        );

    RpcStringFreeW( &pwszUuid );
    THFree(pdnDomainRoot);

    CommonAddObject( TestRoot, CLASS_ORGANIZATIONAL_UNIT );
}

void
RefCountTestCleanup(void)
{
    LogicallyDeleteObject( TestRoot );
    PhysicallyDeleteObject( TestRoot );
    VerifyRefCount( TestRoot, DOESNT_EXIST, 0 );
}
    
DWORD
GetTestRootRefCount()
{
    DWORD   cRefs = 0xffffffff;
    DWORD   cRead;
    DWORD   dwErr;

    SYNC_TRANS_READ();

    __try
    {
        __try
        {
            dwErr = DBFindDSName(pTHStls->pDB, TestRoot);
        }
        __except (HandleMostExceptions(GetExceptionCode()))
        {
            dwErr = DIRERR_OBJ_NOT_FOUND;
        }

        if ( dwErr )
        {
            Fail("Can't find test root");
            leave;
        }

        if ( DBGetSingleValue(pTHStls->pDB,
                              FIXED_ATT_REFCOUNT,
                              &cRefs,
                              sizeof(cRefs),
                              &cRead) )
        {
            Fail("Can't read ref count");
            leave;
        }

        Assert(sizeof(cRefs) == cRead);
    }
    __finally
    {
        CLEAN_BEFORE_RETURN(0);
    }

    return(cRefs);
}


BOOL
CheckRole(
    DSNAME *pRole
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    THSTATE *pTHS = pTHStls;
    BOOL fResult = FALSE;
    DWORD   outSize;
    DSNAME *pTempDN = NULL;

    SYNC_TRANS_READ();

    __try
    {
        // First, find out if I'm really the cleanup master
        if((DBFindDSName(pTHS->pDB, pRole))  ||
           (DBGetAttVal(pTHS->pDB,
                        1,
                        ATT_FSMO_ROLE_OWNER,
                        DBGETATTVAL_fREALLOC | DBGETATTVAL_fSHORTNAME,
                        0,
                        &outSize,
                        (PUCHAR *)&pTempDN))) {
            // I couldn't verify who the master is.
            __leave;
        }

        // OK, I know who the master is.
        if(!NameMatched(pTempDN, gAnchor.pDSADN)) {
            // It's not me.
            DPRINT1( 0, "Skipping test because I am not the master for this role: %ws\n",
                    pRole->StringName );
            __leave;
        }

        THFreeEx(pTHS, pTempDN);

        // I am the FSMO role holder.
        fResult = IsFSMOSelfOwnershipValid( pRole );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    return fResult;
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
// Phantom update refcount test
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
PhantomUpdateTest(void)
/*++

Routine Description:

    If we add a value to the ATT_DN_REFERENCE_UPDATE attribute, and the DN being
    added has a GUID and a string name in it, we will compare the string name in
    the DN to the string name of the real object in the DIT.  If it is
    different, we will update whatever changed: The RDN, the PDNT, and/or the
    SID.

    In the cases where we don't change the PDNT, the refcount should just go up
    by one on the phantom (since we are adding the DSNAME as a value.)  If we do
    change the PDNT, then we need to make sure the refcount of the old parent
    goes down by one and the refcount of the new parent goes up by one.  There
    are two interesting cases.  The new parent may already exist, or it may
    not.  If it doesn't we create a new structural phantom.

    This test stresses this code path by first creating a phantom with string
    name S1 and GUID G.  We then write a value of the ATT_DN_REFERENCE_UPDATE
    attribute with S2 (where S2 just has an RDN change) and check refcounts.
    Then, S3 (where S3 has a PDNT change to an existing object, but no RDN
    change).  Then S4 (where S4 has a PDNT change and an RDN change), then
    S5(where S5 changes PDNT to a non-existant object, and has no RDN change).
    Finally, to S6 (where S6 changes PDNT to a non-existant object and has an
    RDN change).

    When an object is deleted, a ref is added on the parent by virtue of LKP attribute.

Arguments:

    None.

Return Values:

    None.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DWORD       err, cb;
    DSNAME *    pdnContainer;
    DSNAME *    pdnFakeSubContainer1;
    DSNAME *    pdnFakeSubContainer2;
    DSNAME *    pdnHost;
    DSNAME *    pdnHost2;
    DSNAME *    pdnHost3;
    DSNAME *    pdnRealSubContainer;
    DSNAME *    pdnRefConflict;
    DSNAME *    pdnRefConflict2;
    DSNAME *    pdnRef1;
    DSNAME *    pdnRef2;
    DSNAME *    pdnRef3;
    DSNAME *    pdnRef4;
    DSNAME *    pdnRef5;
    DSNAME *    pdnRef6;
    DSNAME *    pdnRef7;
    DSNAME *    pdnRef8;
    DSNAME *    pdnRef1Conflict;
    DSNAME *    pdnUpdateObj;
    DSNAME *    pdnRefStructContainer;
    DSNAME *    pdnRefStruct;

    WCHAR       szMangledStruct[MAX_RDN_SIZE] = L"RefStruct1";
    DWORD       cchMangledStruct = wcslen(szMangledStruct);

    NewTest("PhantomUpdateTest");

    pdnHost = MakeObjectNameEx( "Host", TestRoot );
    pdnHost2 = MakeObjectNameEx( "Host2", TestRoot );
    pdnHost3 = MakeObjectNameEx( "Host3", TestRoot );
    pdnUpdateObj = MakeObjectNameEx( "UpdateObj", TestRoot );
    pdnContainer = MakeObjectNameEx2( "OU=Container", TestRoot );
    pdnRealSubContainer = MakeObjectNameEx( "RealSubContainer", pdnContainer );
    pdnFakeSubContainer1 =MakeObjectNameEx( "FakeSubContainer1", pdnContainer );
    pdnFakeSubContainer2 =MakeObjectNameEx( "FakeSubContainer2", pdnContainer );
    pdnRef1 = MakeObjectNameEx( "RefVer1", pdnContainer); // Original
    pdnRef2 = MakeObjectNameEx( "RefVer2", pdnContainer); // RDN change
    pdnRef3 = MakeObjectNameEx( "RefVer2", pdnRealSubContainer); // PDNT change
    pdnRef4 = MakeObjectNameEx( "RefVer3", pdnContainer); // PDNT, RDN
    pdnRef5 = MakeObjectNameEx( "RefVer3", pdnFakeSubContainer1);
    pdnRef6 = MakeObjectNameEx( "RefVer4", pdnFakeSubContainer2);
    pdnRef7 = MakeObjectNameEx2( "OU=RefVer1", pdnContainer); // RDN type change
    pdnRef8 = MakeObjectNameEx( "RefStruct1", pdnContainer); // structural collision
    pdnRef1Conflict = MakeObjectNameEx( "RefConflict", pdnContainer);
    
    pdnRefConflict = MakeObjectNameEx( "RefConflict", pdnContainer);
    pdnRefConflict2 = MakeObjectNameEx( "RefVer1", pdnContainer);

    pdnRefStructContainer = MakeObjectNameEx( "RefStruct1", pdnContainer); // Structural
    pdnRefStruct = MakeObjectNameEx( "RefStruct2", pdnRefStructContainer); // Structural
    
    DsUuidCreate( &pdnRef1->Guid );
    pdnRef2->Guid = pdnRef1->Guid;
    pdnRef3->Guid = pdnRef1->Guid;
    pdnRef4->Guid = pdnRef1->Guid;
    pdnRef5->Guid = pdnRef1->Guid;
    pdnRef6->Guid = pdnRef1->Guid;
    pdnRef7->Guid = pdnRef1->Guid;
    pdnRef1Conflict->Guid = pdnRef1->Guid;
    pdnRef8->Guid = pdnRef1->Guid;
    
    DsUuidCreate( &pdnRefConflict->Guid );
    pdnRefConflict2->Guid = pdnRefConflict->Guid;

    // pdnRefStructContainer has no guid, it's structural
    // pdnRefStruct has no guid, it's structural

    // Create the following structure:
    //
    // TestRoot
    //  |
    //  |--Host
    //  |   >> gNonLinkedAttrTyp = RefUnderContainer
    //  |
    //  |--Host2
    //  |   >> gNonLinkedAttrTyp = RefUnderContainer2
    //  |
    //  |--UpdateObj
    //  |
    //  |--OU=Container
    //      |
    //      |--RealSubContainer
    //      |
    //      |--RefUnderContainer {Phantom}
    //      |
    //      |--RefUnderContainer2 {Phantom}

    CommonAddObject( pdnContainer, CLASS_ORGANIZATIONAL_UNIT );
    CommonAddObject( pdnRealSubContainer, CLASS_CONTAINER );
    CommonAddObject( pdnUpdateObj, CLASS_CONTAINER );
    AddPropertyHost( pdnHost, NonLinkedProperty );
    AddPropertyHost( pdnHost2, NonLinkedProperty );
    AddPropertyHost( pdnHost3, NonLinkedProperty );

    // Write host 2 
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost2 );
        if ( err ) Fail( "Can't find host2" );

        err = DBAddAttVal( pTHS->pDB, gNonLinkedAttrTyp,
                           pdnRefConflict->structLen,
                           pdnRefConflict );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 1 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 3 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    // Write host 3
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost3 );
        if ( err ) Fail( "Can't find host2" );

        err = DBAddAttVal( pTHS->pDB, gNonLinkedAttrTyp,
                           pdnRefStruct->structLen,
                           pdnRefStruct );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefStruct, PHANTOM, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 1 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 4 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );



    // Write S1
    SYNC_TRANS_WRITE();

    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnHost );
        if ( err ) Fail( "Can't find host" );

        err = DBAddAttVal( pTHS->pDB, gNonLinkedAttrTyp,
                           pdnRef1->structLen,
                           pdnRef1 );
        if ( err ) Fail( "Can't add reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't replace host" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 1 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    
    // Write S2
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);
        // Note, value not present

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef2->structLen,
                          pdnRef2);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef2 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    // Write S3
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the PDNT.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef2->structLen,
                          pdnRef2);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef3->structLen,
                          pdnRef3);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    
    VerifyStringName( pdnRef3 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 2 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 4 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    // Write S4
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN and PDNT
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef3->structLen,
                          pdnRef3);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef4->structLen,
                          pdnRef4);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    
    VerifyStringName( pdnRef4 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    // Write S5
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the PDNT to a newly create
    // phantom. 
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef4->structLen,
                          pdnRef4);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef5->structLen,
                          pdnRef5);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyStringName( pdnRef5 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 1 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    // Rember that pdnContainer lost a direct phantom child, but gained a new
    // phantom child via the newly created phantom container.
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    // Write S6
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN and the PDNT to a newly
    // created phantom.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef5->structLen,
                          pdnRef5);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef6->structLen,
                          pdnRef6);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    VerifyStringName( pdnRef6 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 1 );
    // Rember that pdnContainer gained another new phantom child via the newly
    // created phantom container. 
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    // Now, move pdnRef1 back to being directly under the container
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef6->structLen,
                          pdnRef6);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef1 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    // Write S7
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to change the RDN type.
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef7->structLen,
                          pdnRef7);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef7 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef7, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );



    // Now, move pdnRef1 back to being directly under the container
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef7->structLen,
                          pdnRef7);

        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }


    VerifyStringName( pdnRef1 );
    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );



    // Name conflict test
    // The names should NOT be mangled after this test
    //
    // The dn's:
    //     pdnRef1Conflict = cn=RefConflict, ou=container (Ref1 guid)
    //     pdnRefConflict = cn=RefConflict, ou=container (guid2)
    //     pdnRefConflict2 = cn=RefVer1, ou=container (guid2)
    // Before:
    // host2
    //    attribute = cn=RefConflict, ou=container (guid2)
    // ou=container
    //     cn=RefVer1 (Ref1 guid, phantom)
    //     cn=RefConflict (guid2, phantom)
    //
    // After part 1:
    // ou=container
    //     cn=RefConflict (rdn updated, Ref1 guid, phantom)
    //     cn=RefConflict\nCNF:guid2 (guid2, phantom)
    // After part 2:
    // ou=container
    //     cn=RefConflict (Ref1 guid, phantom)
    //     cn=RefVer1 (rdn updated, guid2, phantom)

    // Now, swap string names between pdnRef1 and pdnRefConflict

    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );

    // Part 1 - Change the RDN of the Ref1 guid, causing a conflict
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1->structLen,
                          pdnRef1);

        // We can add two references because dn-reference-update is multi-valued
        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1Conflict->structLen,
                          pdnRef1Conflict);

        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    // Verify temporary mangled state
    {
        WCHAR       szMangledRef[MAX_RDN_SIZE] = L"RefConflict";
        DWORD       cchMangledRef = wcslen(szMangledRef);
        DSNAME *    pdnMangledRef;

        MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
                  &pdnRefConflict->Guid, szMangledRef, &cchMangledRef);
        pdnMangledRef = THAllocEx(pTHS, pdnRefConflict->structLen + 100);
        AppendRDN(pdnContainer,
                  pdnMangledRef,
                  pdnRefConflict->structLen + 100,
                  szMangledRef,
                  cchMangledRef,
                  ATT_COMMON_NAME);

        // This dn has no guid in it, so lookup will be by name
        VerifyRefCount( pdnMangledRef, PHANTOM, 1 );

        pdnMangledRef->Guid = pdnRefConflict->Guid;
        VerifyStringName( pdnMangledRef );
    }

    // Part 2 - Change the RDN of the guid2 phantom, fixing the conflict
    SYNC_TRANS_WRITE();
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        // We can add two references because dn-reference-update is multi-valued
        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRefConflict2->structLen,
                          pdnRefConflict2);

        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }



    VerifyStringName( pdnRef1Conflict );
    VerifyStringName( pdnRefConflict2 );

    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRef1Conflict, PHANTOM, 2 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 2 );
    VerifyRefCount( pdnRefConflict2, PHANTOM, 2 );

    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 2 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefStruct, PHANTOM, 1 );


    // Host3
    //    property = cn=RefStruct2,cn=RefStruct1,ou=container
    // ou=container
    //     cn=RefVer1 (guidded phantom)
    //     cn=RefStruct1 (structural phantom)
    //         cn=RefStruct2 (structural phantom)
    //
    // There exists a phantom, Ref1
    // Initial Ref 1 name: cn=RefVer1,cn=container  (guidded phantom)
    // New Ref 8 name:     cn=RefStruct1,cn=container  (guidded phantom)

    // Test a structural collision
    SYNC_TRANS_WRITE();
    // Now, add a reference designed to cause a structural collision
    __try
    {
        err = DBFindDSName( pTHS->pDB, pdnUpdateObj );
        if ( err ) Fail( "Can't find update object" );

        // Clean up previous
        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef1Conflict->structLen,
                          pdnRef1Conflict);

        err = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRefConflict2->structLen,
                          pdnRefConflict2);

        // Add new reference
        err = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                          pdnRef8->structLen,
                          pdnRef8);
        
        if ( err ) Fail( "Can't add update reference" );

        err = DBRepl( pTHS->pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
        if ( err ) Fail( "Can't update update object" );
    }
    __finally
    {
        CLEAN_BEFORE_RETURN( 0 );
    }

    // We should now find that we have
    // 1. guided phantom: RefStruct1, pdnContainer
    // 2. structual phantom mangled with random guid
    // 3. child of structual phantom moved under guided phantom
    //
    // This should cause the following new state:
    // Host3
    //    property = cn=RefStruct2,cn=RefStruct1,ou=container
    // ou=container
    //     cn=RefStruct1 (guidded phantom)
    //         cn=RefStruct2 (structural phantom)
    //     cn=RefStruct1/CNF:(random guid) (structural phantom)
    //

    // Removed a reference for guid2
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRefConflict2, PHANTOM, 1 );

    // Ref count: 1 for host reference, 1 for dn reference, 1 for child object
    VerifyRefCount( pdnRef8, PHANTOM, 3 );
    VerifyRefCount( pdnRef1, PHANTOM, 3 );
    VerifyRefCount( pdnRefStruct, PHANTOM, 1 );

    // Reconstruct the munged name of structural phantom using the guid exported
    // from dbsubj.c specifically for our test.
    // (This test hook exists only #ifdef INCLUDE_UNIT_TESTS on DBG builds.)
    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              &gLastGuidUsedToCoalescePhantoms, szMangledStruct, &cchMangledStruct);
    cb = pdnRefStructContainer->structLen + 100;
    pdnRefStructContainer = THReAllocEx(pTHStls, pdnRefStructContainer, cb);
    AppendRDN(pdnContainer, pdnRefStructContainer, cb, szMangledStruct, cchMangledStruct,
              ATT_COMMON_NAME);

    VerifyRefCount(pdnRefStructContainer, PHANTOM, 0);
    // The structural phantom has no guid, and thus VerifyStringName cannot be used

    VerifyRefCount( pdnHost2, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 1 );
    VerifyRefCount( pdnRef1, PHANTOM, 3 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    
    // Remove our test objects.
    LogicallyDeleteObject( pdnHost2 );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, REAL_OBJECT, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, PHANTOM, 3 );
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );

    LogicallyDeleteObject( pdnHost );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 ); // 1 for dn ref, 1 for child
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefStruct, PHANTOM, 1 );

    LogicallyDeleteObject( pdnHost3 );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 );  // 1 for dn ref, 1 for child
    VerifyRefCount( pdnRealSubContainer, REAL_OBJECT, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 );
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );
    VerifyRefCount( pdnRefStruct, PHANTOM, 0 );

    LogicallyDeleteObject( pdnRealSubContainer );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 ); // 1 for dn ref, 1 for child
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 ); // Stays same because of LKP
    VerifyRefCount( pdnUpdateObj, REAL_OBJECT, 1 );


    LogicallyDeleteObject( pdnUpdateObj );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, PHANTOM, 2 ); // 1 for dn ref, 1 for child
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 ); // No change from above
    VerifyRefCount( pdnUpdateObj, TOMBSTONE, 1 );

    PhysicallyDeleteObject( pdnUpdateObj );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 ); // 2?
    VerifyRefCount( pdnRef1, PHANTOM, 1 ); // 1 for child
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 7 ); // No change from above
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );    
    
    PhysicallyDeleteObject( pdnRefStruct );
    VerifyRefCount( pdnRef1, PHANTOM, 0 );

    PhysicallyDeleteObject( pdnRef1 );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, PHANTOM, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 ); // ? still exists
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 6 ); // down one from above
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );

    PhysicallyDeleteObject( pdnRefConflict );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, PHANTOM, 0 );
    VerifyRefCount( pdnFakeSubContainer2, PHANTOM, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 5 ); // down one from above
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );
    
    PhysicallyDeleteObject( pdnFakeSubContainer1 );
    PhysicallyDeleteObject( pdnFakeSubContainer2 );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 3 ); // down two from above
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );

    VerifyRefCount(pdnRefStructContainer, PHANTOM, 0);
    PhysicallyDeleteObject( pdnRefStructContainer );
    VerifyRefCount( pdnContainer, REAL_OBJECT, 2 ); // down one
    
    LogicallyDeleteObject( pdnContainer );

    VerifyRefCount( pdnHost2, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost, TOMBSTONE, 1 );
    VerifyRefCount( pdnHost3, TOMBSTONE, 1 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, TOMBSTONE, 1 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, TOMBSTONE, 2 ); // stays same as previous
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );


    
    PhysicallyDeleteObject( pdnHost2 );
    PhysicallyDeleteObject( pdnHost );
    PhysicallyDeleteObject( pdnHost3 );
    PhysicallyDeleteObject( pdnRealSubContainer );
    // Releases LKP on pdnContainer
    VerifyRefCount( pdnContainer, TOMBSTONE, 1 ); // down one

    PhysicallyDeleteObject( pdnContainer );

    VerifyRefCount( pdnHost2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnHost, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnHost3, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRefConflict, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRef1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnRealSubContainer, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer1, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnFakeSubContainer2, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnContainer, DOESNT_EXIST, 0 );
    VerifyRefCount( pdnUpdateObj, DOESNT_EXIST, 0 );    

    FreeObjectName( pdnContainer );
    FreeObjectName( pdnFakeSubContainer1 );
    FreeObjectName( pdnFakeSubContainer2 );
    FreeObjectName( pdnHost );
    FreeObjectName( pdnHost2 );
    FreeObjectName( pdnHost3 );
    FreeObjectName( pdnRealSubContainer );
    FreeObjectName( pdnRefConflict );
    FreeObjectName( pdnRefConflict2 );
    FreeObjectName( pdnRef1Conflict );
    FreeObjectName( pdnRef1 );
    FreeObjectName( pdnRef2 );
    FreeObjectName( pdnRef3 );
    FreeObjectName( pdnRef4 );
    FreeObjectName( pdnRef5 );
    FreeObjectName( pdnRef6 );
    FreeObjectName( pdnRef7 );
    FreeObjectName( pdnRef8 );
    FreeObjectName( pdnUpdateObj );


    ReportTest("PhantomUpdateTest");
}


//////////////////////////////////////////////////////////////////////
//                                                                  //
// Public entry point.                                              //
//                                                                  //
//////////////////////////////////////////////////////////////////////

void
TestReferenceCounts(void)
{
    THSTATE     *pTHS = pTHStls;
    DWORD       dwException;
    ULONG       ulErrorCode;
    ULONG       dsid;
    PVOID       dwEA;
    ATTCACHE    *pAC;

    Assert(VALID_THSTATE(pTHS));

    // Validate our linked and non-linked DSNAME-valued properties.
    Assert((pAC = SCGetAttById(pTHS, gNonLinkedAttrTyp)) && pAC->ulLinkID);
    Assert((pAC = SCGetAttById(pTHS, gLinkedAttrTyp)) && !pAC->ulLinkID);

    if(!pTHS->phSecurityContext) {
        // No security context virtually guarantees all your Logical Deletes
        // will fail.
        DPRINT( 0, "RefCount tests should not be run without a binding.\n");
        return;
    }
    
    __try
    {
        RefCountTestSetup();

        PhantomRenameOnPromotionWithStructuralCollision(LinkedProperty);
        PhantomRenameOnPromotionWithStructuralCollision(NonLinkedProperty);

        UnmangleRDNTest();
        
        NestedTransactionEscrowedUpdateTest();

        ParentChildRefCountTest();
        ObjectCleaningRefCountTest();
        PhantomRenameOnPromotionTest();
        NameCollisionTest();
        RefPhantomSidUpdateTest();
        StructPhantomGuidSidUpdateTest();
        ObjectSidNoUpdateTest();
        ConflictedNcNameFixupTest( TRUE /*subref*/ );
        CrossRefAddNcNameFixupTest( FALSE /* phantom*/);
        CrossRefAddNcNameFixupTest( TRUE /*subref*/ );

        AttributeTestForRealObject(LinkedProperty);
        AttributeTestForDeletedObject(LinkedProperty);
        AttributeTestForDeletedObjectProperty(LinkedProperty);
        pTHS->fDRA = TRUE;
        __try {
            DPRINT( 0, "Again as the replicator...\n" );
            AttributeTestForDeletedObjectProperty(LinkedProperty);
        } __finally {
            pTHS->fDRA = FALSE;
        }
        AttributeTestForDeletedHost(LinkedProperty);
        PhantomPromotionDemotionTest(LinkedProperty);

        AttributeTestForRealObject(NonLinkedProperty);
        AttributeTestForDeletedObject(NonLinkedProperty);
        pTHS->fDRA = TRUE;
        __try {
            DPRINT( 0, "Again as the replicator...\n" );
            AttributeTestForDeletedObjectProperty(NonLinkedProperty);
        } __finally {
            pTHS->fDRA = FALSE;
        }
        AttributeTestForDeletedHost(NonLinkedProperty);
        PhantomPromotionDemotionTest(NonLinkedProperty);


        RefCountTestCleanup();

        // second test round
        // we create a different test hierarchy, since we
        // are very dependent on the type of class under 
        // which these the test objects are created
        // these three calls should be together
        // 
        RefCountTestSetup2();
        PhantomUpdateTest();
        PhantomRenameOnPhantomRDNConflict();
        RefCountTestCleanup();
    }
    __except(GetExceptionData(GetExceptionInformation(), 
                             &dwException,
                             &dwEA, 
                             &ulErrorCode, 
                             &dsid)) 
    {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\src\samcache.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samcache.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains routines to support account and universal group
    caching.

Author:

    ColinBr     03-01-00

Environment:

    User Mode - Win32

Revision History:

    ColinBr     03-01-00
        Created

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>
#include <mappings.h>
#include <mdcodes.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <dsexcept.h>
#include <dsevent.h>
#include <debug.h>
#include <anchor.h>
#include <dsconfig.h>
#include <attids.h>
#include <fileno.h>
#include <taskq.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h> // for NetApiBufferFree
#include <esent.h>

#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <samsrvp.h>

#include <filtypes.h>

#include <schedule.h>
#include <ismapi.h>

#include <samlogon.h>

#define FILENO FILENO_SAMCACHE
#define DEBSUB "SAMCACHE:"


// Useful
#define NELEMENTS(x)  (sizeof(x)/sizeof((x)[0]))

// Reschedule in 5 minutes for resource error 
#define UNEXPECTED_ERROR_RESCHEDULE_SECS  (5*60)


// 500 users in one refresh cycle
#define GCLESS_DEFAULT_REFRESH_LIMIT 500

// 6 months
#define GCLESS_DEFAULT_SITE_STICKINESS_DAYS  180

// 1 week
#define GCLESS_DEFAULT_STALENESS_HOURS 168

// The number of entries to batch when going to a GC
// 50 users with 100 groups @ 28 bytes each ~= 140K
// which KamenM indicated is a more optimal packet size
// for both high and low bandwidth connections while
// limiting memory pressure from the IP stack (see attached
// mail in bug #418257)
#define GC_BATCH_LIMIT 50

// The width of a replication schedule's slot in seconds. (15 min)
#define REPL_SLOT_IN_SECONDS 900 

#define ONE_SECOND_IN_FILETIME (10 * (1000*1000))

#define ENTRY_HAS_EXPIRED(entry, standard) \
    ((-1) == CompareFileTime((FILETIME*)&(entry),(FILETIME*)&(standard)))

LARGE_INTEGER ZeroTime = {0};
#define IS_ZERO_TIME(entry) \
    (!memcmp(&entry, &ZeroTime, sizeof(ZeroTime)))

// Eight hours
#define DEFAULT_REFRESH_INTERVAL_SECS  (8*60*60)


// When searching for the old cached membership, bail after
// this many accounts to avoid outlier situations where we end up
// walking all users in the database
#define NTDSA_SAM_CACHE_MAX_STALE_ACCOUNTS  100

// When performing cleanup, do only this many accounts at a time.
#define MAX_CLEANUP_LIMIT 64

//
// This is the format of the MSDS-Cached-Membership binary blob
//
#include <pshpack1.h>

typedef struct _GROUP_CACHE_V1 {

    //
    // SIDs are placed in SidStart in the following order
    //
    DWORD accountCount;
    DWORD accountSidHistoryCount;
    DWORD universalCount;
    DWORD universalSidHistoryCount;
    BYTE  SidStart[1];
    
}GROUP_CACHE_V1;

typedef struct {

    DWORD Version;
    union {
        GROUP_CACHE_V1 V1;
    };

}GROUP_CACHE_BLOB;

#include <poppack.h>


//
// A helpful macro to know if two strings are the same. 
// x and y must be NULL terminated.
//
#define EQUAL_STRING(x, y)                                           \
    (CSTR_EQUAL == CompareStringW(DS_DEFAULT_LOCALE,                 \
                                  DS_DEFAULT_LOCALE_COMPARE_FLAGS,   \
                                  (x), wcslen(x), (y), wcslen(y)))

//
// A structure to define elements of an array that have the sites we are
// connected to and whether a GC is present in the site.  This information is
// used to both determine which site to schedule ourselves from if there
// is no preferred site and also to determine if the GC we found is from
// a site with lowest cost.
//
typedef struct _CACHE_CONNECTED_SITES {
    LPWSTR siteName;
    ULONG  cost;
    BOOLEAN fHasGC;
} CACHE_CONNECTED_SITES;


// Exported from dra.lib::drainst.c
BOOL 
fIsBetweenTime(
    IN REPLTIMES *,
    IN DSTIME,
    IN DSTIME
    );

// Local prototypes
DWORD
cleanupOldEntries(
    IN  THSTATE *pTHS,
    IN ULONG *DNTList,
    IN ATTRVAL *Values OPTIONAL,
    IN ULONG  DNTCount
    );

DWORD
analyzeSitePreference(
    IN  ULONG defaultRefreshInterval,
    OUT ULONG* cConnectedSitesOutput, 
    OUT CACHE_CONNECTED_SITES **connectedSitesOutput,
    OUT LPWSTR* siteName,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    );

VOID
analyzeSchedule(
    IN  ULONG defaultRefreshInterval,
    IN  LPWSTR  siteName,
    IN  SCHEDULE *pSchedule,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    );

DWORD 
getGCFromSite(
    IN  THSTATE *pTHS,
    IN  LPWSTR siteName,
    IN  ULONG  cConnectedSites, OPTIONAL
    IN  CACHE_CONNECTED_SITES *connectedSites, OPTIONAL
    OUT LPWSTR *gcName,
    OUT LPWSTR *gcDomain
    );

BOOL 
convertScheduleToReplTimes(
    IN PSCHEDULE schedule,
    OUT REPLTIMES *replTimes
    );

DWORD
findScheduleForSite(
    IN  THSTATE   *pTHS,
    IN  LPWSTR     transportDN,
    IN  LPWSTR     localSiteName,
    IN  LPWSTR     targetSiteName,
    OUT PSCHEDULE *ppSchedule
    );

LPSTR
DbgPrintDsTime(
    DSTIME time,
    CHAR * buffer
    );


VOID
marshallCachedMembershipSids(
    IN  THSTATE *pTHS,
    IN  AUG_MEMBERSHIPS* Account,
    IN  AUG_MEMBERSHIPS* Universal,
    OUT PVOID *pBuf,
    OUT ULONG *cbBuf
    )
/*++

Routine Description:

    This routine converts an array of SID's into to continous binary blob
    of SIDs that it can be stored in the Cached-Membership attribute of
    a user object.
    
Parameters:

    pTHS -- thread state
    
    Account -- the account groups and sid history
    
    Universal -- the universal groups and sid history
    
    pBuf -- the buffer to write in the cached memberships attribute
    
    cbBuf -- the number of bytes in pBuf

Return Values

    None.

 --*/
{
    ULONG i;
    PBYTE pTemp;
    ULONG cbTemp;
    GROUP_CACHE_BLOB *pBlob;

    Assert(Account);
    Assert(Universal);

    // Calculate the length of the structure
    cbTemp = 0;
    for (i = 0; i < Account->MembershipCount; i++) {
        Assert(RtlValidSid(&Account->Memberships[i]->Sid));
        Assert(RtlLengthSid(&Account->Memberships[i]->Sid) ==
               Account->Memberships[i]->SidLen);
        cbTemp += Account->Memberships[i]->SidLen;
    }
    for (i = 0; i < Account->SidHistoryCount; i++) {
        Assert(RtlValidSid(Account->SidHistory[i]));
        cbTemp += RtlLengthSid(Account->SidHistory[i]);
    }
    for (i = 0; i < Universal->MembershipCount; i++) {
        Assert(RtlValidSid(&Universal->Memberships[i]->Sid));
        Assert(RtlLengthSid(&Universal->Memberships[i]->Sid) ==
               Universal->Memberships[i]->SidLen);
        cbTemp += Universal->Memberships[i]->SidLen;
    }
    for (i = 0; i < Universal->SidHistoryCount; i++) {
        Assert(RtlValidSid(Universal->SidHistory[i]));
        cbTemp += RtlLengthSid(Universal->SidHistory[i]);
    }

    cbTemp += sizeof(GROUP_CACHE_BLOB);
    pBlob = (GROUP_CACHE_BLOB*) THAllocEx(pTHS, cbTemp);

    // Current version
    pBlob->Version = 1;

    // Sid in the sids

    // Offset starts from SidStart
    pTemp = &(pBlob->V1.SidStart[0]);

    // First the account memberships
    pBlob->V1.accountCount = Account->MembershipCount;
    for (i = 0; i < Account->MembershipCount; i++) {
        ULONG size = Account->Memberships[i]->SidLen;
        memcpy(pTemp, &Account->Memberships[i]->Sid, size);
        pTemp += size;
    }

    // Now the account sid histories
    pBlob->V1.accountSidHistoryCount = Account->SidHistoryCount;
    for (i = 0; i < Account->SidHistoryCount; i++) {
        ULONG size = RtlLengthSid(Account->SidHistory[i]);
        memcpy(pTemp, Account->SidHistory[i], size);
        pTemp += size;
    }

    // Now the universal memberships
    pBlob->V1.universalCount = Universal->MembershipCount;
    for (i = 0; i < Universal->MembershipCount; i++) {
        ULONG size = Universal->Memberships[i]->SidLen;
        memcpy(pTemp, &Universal->Memberships[i]->Sid, size);
        pTemp += size;
    }

    // Finally the universal sid histories
    pBlob->V1.universalSidHistoryCount = Universal->SidHistoryCount;
    for (i = 0; i < Universal->SidHistoryCount; i++) {
        ULONG size = RtlLengthSid(Universal->SidHistory[i]);
        memcpy(pTemp, Universal->SidHistory[i], size);
        pTemp += size;
    }


    // Done
    *pBuf = pBlob;
    *cbBuf = cbTemp;

    return;
}


BOOL
unmarshallCachedMembershipSids(
    IN  THSTATE *pTHS,
    IN  PVOID pBuf,
    IN  ULONG cbBuf,
    OUT AUG_MEMBERSHIPS** Account,
    OUT AUG_MEMBERSHIPS** Universal
    )
/*++

Routine Description:

    This routine converts a binary blob of SID's to an array of SID's.  The
    binary blob is a value for the CachedMembership attribute of a user.

Parameters:

    pTHS -- thread state
    
    pBuf -- the buffer read from the cached memberships attribute
    
    cbBuf -- the number of bytes in pBuf
    
    Account -- the account groups and sid history
    
    Universal -- the universal groups and sid history


Return Values

    TRUE if properly decoded; FALSE otherwise

 --*/
{
    ULONG i, count;
    GROUP_CACHE_BLOB *pBlob = (GROUP_CACHE_BLOB*)pBuf;
    UCHAR *pTemp;
    PSID *sidArray;
    AUG_MEMBERSHIPS *pAccount;
    AUG_MEMBERSHIPS *pUniversal;
    ULONG sizeOfSidDsName = DSNameSizeFromLen(0);
    
    // Assert this is a version we understand
    Assert(pBlob->Version == 1);
    if (1 != pBlob->Version) {
        return FALSE;
    }

    // Alloc space for the returned structures
    pAccount = (AUG_MEMBERSHIPS*) THAllocEx(pTHS, sizeof(AUG_MEMBERSHIPS));
    pUniversal = (AUG_MEMBERSHIPS*) THAllocEx(pTHS, sizeof(AUG_MEMBERSHIPS));

    pTemp = (&pBlob->V1.SidStart[0]);

    // Extract the account memberships
    if (pBlob->V1.accountCount > 0) {
        pAccount->Memberships = THAllocEx(pTHS, pBlob->V1.accountCount * sizeof(DSNAME*));
        pAccount->MembershipCount = pBlob->V1.accountCount;
        for (i = 0; i < pAccount->MembershipCount; i++) {
    
            DSNAME *dsname = (DSNAME*) THAllocEx(pTHS, sizeOfSidDsName);
            ULONG  size = RtlLengthSid((PSID)pTemp);
    
            Assert(size > 0);
            dsname->structLen = sizeOfSidDsName;
            memcpy(&dsname->Sid, pTemp, size);
            dsname->SidLen = size;
            pAccount->Memberships[i] = dsname;
            pTemp += size;
        }
    }

    // Extract the account sid histories
    if (pBlob->V1.accountSidHistoryCount > 0) {
        pAccount->SidHistory = THAllocEx(pTHS, pBlob->V1.accountSidHistoryCount * sizeof(PSID));
        pAccount->SidHistoryCount = pBlob->V1.accountSidHistoryCount;
        for (i = 0; i < pAccount->SidHistoryCount; i++) {
    
            ULONG  size = RtlLengthSid((PSID)pTemp);
            PSID   sid = (PSID) THAllocEx(pTHS, size);
    
            Assert(RtlValidSid((PSID)pTemp));
            Assert(size > 0);
            memcpy(sid, pTemp, size);
            pAccount->SidHistory[i] = sid;
            pTemp += size;
        }
    }


    // Extract the universals
    if (pBlob->V1.universalCount > 0) {
        pUniversal->Memberships = THAllocEx(pTHS, pBlob->V1.universalCount * sizeof(DSNAME*));
        pUniversal->MembershipCount = pBlob->V1.universalCount;
        for (i = 0; i < pUniversal->MembershipCount; i++) {
    
            DSNAME *dsname = (DSNAME*) THAllocEx(pTHS, sizeOfSidDsName);
            ULONG  size = RtlLengthSid((PSID)pTemp);
    
            Assert(size > 0);
            dsname->structLen = sizeOfSidDsName;
            memcpy(&dsname->Sid, pTemp, size);
            dsname->SidLen = size;
            pUniversal->Memberships[i] = dsname;
            pTemp += size;
        }
    }

    // Extract the account sid histories
    if (pBlob->V1.universalSidHistoryCount) {
        pUniversal->SidHistory = THAllocEx(pTHS, pBlob->V1.universalSidHistoryCount * sizeof(PSID));
        pUniversal->SidHistoryCount = pBlob->V1.universalSidHistoryCount;
        for (i = 0; i < pUniversal->SidHistoryCount; i++) {
    
            ULONG  size = RtlLengthSid((PSID)pTemp);
            PSID   sid = (PSID) THAllocEx(pTHS, size);
    
            Assert(RtlValidSid((PSID)pTemp));
            Assert(size > 0);
            memcpy(sid, pTemp, size);
            pUniversal->SidHistory[i] = sid;
            pTemp += size;
        }
    }

    *Account = pAccount;
    *Universal = pUniversal;

    return TRUE;
}

NTSTATUS
GetMembershipsFromCache(
    IN  DSNAME* pDSName,
    OUT AUG_MEMBERSHIPS** Account,
    OUT AUG_MEMBERSHIPS** Universal
    )
/*++

Routine Description:

    This routine, exported from ntdsa.dll, retrieves a user's cached group
    membership.  The group membership is returned if and if only if the
    timestamp of the last update is within the staleness period and if the
    group membership attribute exists.

Parameters:

    pDSNAME -- the name of the user
    
    Account -- the account group memberships and sid histories
    
    Universal -- the universal group memberships and sid histories
    
Return Values
    
    STATUS_SUCCESS if the group membership was returned
    
    STATUS_DS_NO_ATTRIBUTE_OR_VALUE  if there is no cache or if the cache
                                     has expired.

 --*/
{
    THSTATE *pTHS = pTHStls;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG err;
    ULONG size;
    ULONG stalenessMinutes;

    LARGE_INTEGER timeTemp, timeBestAfter;

    BOOL fCommit = FALSE;

    Assert(pDSName);
    Assert(Account);
    Assert(Universal);

    // Determine staleness limit (measured in minutes)
    err = GetConfigParam(GCLESS_STALENESS,
                         &stalenessMinutes,
                         sizeof(stalenessMinutes));
    if (err) {
        stalenessMinutes = GCLESS_DEFAULT_STALENESS_HOURS*60;
        err = 0;
    }
    timeTemp.QuadPart = Int32x32To64(stalenessMinutes*60, ONE_SECOND_IN_FILETIME);
    GetSystemTimeAsFileTime((FILETIME*)&timeBestAfter);
    timeBestAfter.QuadPart -= timeTemp.QuadPart;


    // The default status is that no cached membership could be found or
    // used
    ntStatus = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;

    // This routine assumes a transaction is open
    Assert(pTHS != NULL)
    Assert(pTHS->pDB != NULL);

    _try {

        LARGE_INTEGER lastRefreshTime;

        err = DBFindDSName(pTHS->pDB, pDSName);
        if (err) {
            // user not found?
            DPRINT(1,"User not found when retrieving membership cache\n");
            _leave;
        }

        err = DBGetSingleValue(pTHS->pDB,
                               ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP,
                               &lastRefreshTime,
                               sizeof(lastRefreshTime),
                               &size);

        if (!err) {
            // There is a value -- check to see if it is not stale
            if (!ENTRY_HAS_EXPIRED(lastRefreshTime, timeBestAfter)) {

                PVOID pBuf = NULL;
                ULONG cbBuf = 0;

                // This is not stale
                err = DBGetAttVal(pTHS->pDB,
                                  1, // first value
                                  ATT_MS_DS_CACHED_MEMBERSHIP,
                                  0,
                                  0,
                                  &cbBuf,
                                  (UCHAR**)&pBuf);

                if (!err) {

                    if ( unmarshallCachedMembershipSids(pTHS,
                                                   pBuf,
                                                   cbBuf,
                                                   Account,
                                                   Universal)) {
                        ntStatus = STATUS_SUCCESS;
                    } else {
                        DPRINT(0,"Unmarshalling group membership attribute failed!\n");
                    }


                } else {

                    DPRINT(0,"Group Membership Cache time stamp exists but no membership!\n");
                }
            }
        }
        fCommit = TRUE;
    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (!NT_SUCCESS(ntStatus)) {
        *Account = NULL;
        *Universal = NULL;
    }

    // This routine assumes a transaction is open at the start
    // so we should end with one, too
    Assert(pTHS != NULL);
    Assert(pTHS->pDB != NULL);


    return ntStatus;
}


NTSTATUS
CacheMemberships(
    IN  DSNAME* pDSName,
    IN  AUG_MEMBERSHIPS* Account,
    IN  AUG_MEMBERSHIPS* Universal
    )
/*++

                                                            
Routine Description:

    This exported routine updates the cached membership for a user as well
    as the site affinity if requested to do so. This routine may be called
    with or without an existing DBPOS or open transaction.  
        
Parameters:

    pDSName -- the account to update
    
    Account -- the account group memberships and sid histories
    
    Universal -- the universal group memberships and sid histories
    
Return Values
    
    STATUS_SUCCESS, or a resource error otherwise                          

 --*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    THSTATE *pTHS=pTHStls;
    PVOID pBuf = NULL;
    ULONG cbBuf = 0;
    ULONG i;
    ULONG err;
    BOOL fCommit = FALSE;  
    GUID siteGuid;
    DBPOS *pDBTemp;
    
    _try
    {
        // Package SIDs into binary format
        marshallCachedMembershipSids( pTHS,
                                      Account,
                                      Universal,
                                      &pBuf,
                                      &cbBuf );
        
        // Open a new DBPOS and transaction for use here
        DBOpen(&pDBTemp);
        
        _try
        {
            LARGE_INTEGER ts;
            ATTCACHE *pAC;
            ATTRVALBLOCK attrValBlock;
            ATTRVAL attrVal;
            BOOL fChanged;

            err = DBFindDSName(pDBTemp, pDSName);
            if (err) {
                // can't find the user
                ntStatus = STATUS_NO_SUCH_USER;
                _leave;
            }

            // Update the cached membership value
            pAC = SCGetAttById(pTHS, ATT_MS_DS_CACHED_MEMBERSHIP);
            Assert(NULL != pAC);
            memset(&attrValBlock, 0, sizeof(attrValBlock));
            attrValBlock.valCount = 1;
            attrValBlock.pAVal = &attrVal;
            memset(&attrVal, 0, sizeof(attrVal));
            attrVal.valLen = cbBuf;
            attrVal.pVal = (UCHAR*)pBuf;

            err = DBReplaceAtt_AC(pDBTemp,
                                  pAC,
                                  &attrValBlock,
                                  &fChanged);
            if (err) {
                // This is an unexpected error
                DPRINT1(0,"DBReplaceAtt_AC failed with 0x%d unexpectedly\n", 
                        err);
                _leave;
            }
    

            // Update the time stamp value
            pAC = SCGetAttById(pTHS, ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP);
            Assert(NULL != pAC);
            GetSystemTimeAsFileTime((FILETIME*)&ts);
            memset(&attrValBlock, 0, sizeof(attrValBlock));
            attrValBlock.valCount = 1;
            attrValBlock.pAVal = &attrVal;
            memset(&attrVal, 0, sizeof(attrVal));
            attrVal.valLen = sizeof(ts);
            attrVal.pVal = (UCHAR*)&ts;

            err = DBReplaceAtt_AC(pDBTemp,
                                  pAC,
                                  &attrValBlock,
                                  &fChanged);
            if (err) {
                // This is an unexpected error
                DPRINT1(0,"DBReplaceAtt_AC failed with 0x%d unexpectedly\n", 
                        err);
                _leave;
            }
    
            if (!err) {
                err  = DBRepl(pDBTemp, 
                              FALSE,  // not DRA
                              0,
                              NULL,
                              0 );
                if (err) {
                    DPRINT1(0,"DBRepl failed with 0x%d unexpectedly\n", err);
                }
            }

            if (!err) {
                fCommit = TRUE;
            }
        }
        _finally
        {   
            //
            // Close our local transaction 
            //
            DBClose(pDBTemp, fCommit);
        }
    }
    __except(HandleMostExceptions(GetExceptionCode()))
    {
        // Whack error code to insufficient resources.
        // Exceptions will typically take place under those conditions
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    if (err && NT_SUCCESS(ntStatus)) {
        // An unexpected error occurred
        ntStatus = STATUS_UNSUCCESSFUL;        
    }

    if (!NT_SUCCESS(ntStatus)) {
       
        LogEvent8WithData(DS_EVENT_CAT_GROUP_CACHING,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_GROUP_CACHING_FAILED_TO_CACHE_MEMBERSHIPS,
                          szInsertWin32ErrCode(RtlNtStatusToDosError(ntStatus)),
                          szInsertWin32Msg(RtlNtStatusToDosError(ntStatus)),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( err ),
                          &err );        
    }

    return ntStatus;
}

DWORD 
getSchedulingInformation(
    IN  THSTATE *pTHS,
    OUT BOOL    *fRunNow,
    OUT DWORD   *pcSecsUntilNextIteration,
    OUT ULONG    *cConnectedSites,
    OUT CACHE_CONNECTED_SITES **connectedSites,
    OUT LPWSTR *siteName,
    OUT DWORD   *dsidExit
    )
/*++

Routine Description:

    This routine analyses site configuration information to determine if
    the refresh membership task should run now and when it should run again.
    
Parameters:

    pTHS -- thread state
    
    fRunNow -- should the task run now?
    
    pcSecsUntilNextIteration -- when the task should run again
    
    cConnectedSites -- the number of sites the local site has connectivety to
    
    connectedSites -- the sites the locate has connectivety to
    
    siteName -- the name of the site the task is scheduled to refresh from
    
    dsidExit -- the DSID of any fatal errors

Return Values

    0 on success, !0 otherwise

 --*/
{

    ULONG err = 0;
    ULONG defaultRefreshInterval;

    // Get the default refresh reschedule time
    err = GetConfigParam(GCLESS_REFRESH_INTERVAL,
                         &defaultRefreshInterval,
                         sizeof(defaultRefreshInterval));
    if (err) {
        defaultRefreshInterval = DEFAULT_REFRESH_INTERVAL_SECS;
        err = 0;
    } else {
        // value in registry is minutes -- we need seconds
        defaultRefreshInterval *= 60;
    }
    *pcSecsUntilNextIteration = defaultRefreshInterval;


    //
    // Find either the configured site, or if it is timely to run
    // now
    //
    // This routine logs whether a helper site was found.
    //
    err = analyzeSitePreference(defaultRefreshInterval,
                                cConnectedSites,
                                connectedSites,
                                siteName,
                                fRunNow,
                                pcSecsUntilNextIteration);
    if (err) {
        // unexpected
        *dsidExit = DSID(FILENO, __LINE__);
        goto Cleanup;
    }

Cleanup:

    return err;


}

DWORD
getTargetGCInformation(
    IN  THSTATE *pTHS,
    IN  ULONG    cConnectedSites OPTIONAL,
    IN  CACHE_CONNECTED_SITES *connectedSites OPTIONAL,
    IN  LPWSTR   siteName,
    OUT LPWSTR  *gcName,
    OUT LPWSTR  *gcDomain,
    OUT DWORD   *pcSecsUntilNextIteration,
    OUT DWORD   *dsidExit
    )
/*++

Routine Description:

    This routine determines the name of GC from which the group memberships
    can be updated from.  
    
    siteName is the most relevant parameter to determine where the GC is from.
    connectedSites is for logging purposes only.
                                                          
Parameters:

    pTHS -- thread state
    
    cConnectedSites -- the number of sites the local site has connectivety to
    
    connectedSites -- the sites the locate has connectivety to

    siteName -- the site from which a GC should be currently available
        
    gcName -- the name of the GC to update memberships from
    
    gcDomain -- the domain name that the GC belongs to
    
    pcSecsUntilNextIteration -- when the task should run again
    
    dsidExit -- the DSID of any fatal errors

Return Values

    0 on success, !0 otherwise

 --*/
{

    DWORD err;
    //
    // We are going to run -- try to find a GC
    //
    // This routine logs whether a helper GC was found
    //
    err = getGCFromSite(pTHS,
                        siteName,
                        cConnectedSites,
                        connectedSites,
                        gcName,
                        gcDomain);
    if (err) {
        //
        // No GC -- don't run
        //
        *dsidExit = DSID(FILENO, __LINE__);
        goto Cleanup;
    }

Cleanup:

    return err;

}

DWORD
getAccountsToRefresh(
    IN  THSTATE* pTHS,
    OUT DWORD *refreshCountOutput,
    OUT DSNAME ***refreshListOutput,
    OUT DWORD  *pcSecsUntilNextIteration,
    OUT ULONG  *dsidExit
    )
/*++

Routine Description:

    This routine walks the site affinity list for the local site either
    expiring the account or adding the account to the list of accounts whose
    memberships need refreshing.

Parameters:

    pTHS -- thread state
    
    refreshCountOutput -- the number of accounts that need refreshing
    
    refreshListOutput -- the accounts that need refreshing
    
    pcSecsUntilNextIteration -- seconds until next iteration (used for error
                                conditions).
                                
    dsidExit -- the location of a fatal error, if any                                

Return Values

    0 on success, !0 otherwise

 --*/
{

    ULONG err = 0;
    ULONG refreshMax;
    ULONG siteStickiness;
    DWORD refreshCount = 0;
    DSNAME **refreshList = NULL;

    ATTCACHE *pAC = NULL;
    INDEX_VALUE IV;
    GUID siteGuid;
    BOOL fCommit = FALSE;
    ULONG i;

    // Storage for accounts that have expired
    ULONG   oldEntries[MAX_CLEANUP_LIMIT];
    ATTRVAL oldValues[MAX_CLEANUP_LIMIT];
    ULONG   oldCount = 0;

    LARGE_INTEGER timeTemp, timeBestAfter;

    // There should not be a transaction
    Assert(NULL == pTHS->pDB);

    memset(oldEntries, 0, sizeof(oldEntries));
    memset(oldValues, 0, sizeof(oldValues));

    // Determine how many users to refresh
    err = GetConfigParam(GCLESS_REFRESH_LIMIT,
                         &refreshMax,
                         sizeof(refreshMax));
    if (err) {
        refreshMax = GCLESS_DEFAULT_REFRESH_LIMIT;
        err = 0;
    }

    // Init the list of users to be refreshed
    refreshList = (DSNAME**) THAllocEx(pTHS, sizeof(DSNAME*)*refreshMax);

    // Determine the BestAfter time.  If the site affinity timestamp is
    // greater than the BestAfter time, then the user's membership will
    // be refreshed; otherwise it will be purged from the list (ie the
    // value will be removed from the site affinity attribute
    err = GetConfigParam(GCLESS_SITE_STICKINESS,
                         &siteStickiness,
                         sizeof(siteStickiness));
    if (err) {
        // siteStickiness is in minutes
        siteStickiness = GCLESS_DEFAULT_SITE_STICKINESS_DAYS*24*60;
        err = 0;
    }
    timeTemp.QuadPart = Int32x32To64(siteStickiness*60, ONE_SECOND_IN_FILETIME);
    GetSystemTimeAsFileTime((FILETIME*)&timeBestAfter);
    timeBestAfter.QuadPart -= timeTemp.QuadPart;


    // Get the list of users by walking site affinity index
    DBOpen(&pTHS->pDB);

    __try {

        BOOL fFoundOurSite = FALSE;

        // Set up our site guid as the index value
        Assert(!fNullUuid(&gAnchor.pSiteDN->Guid));
        memcpy(&siteGuid, &gAnchor.pSiteDN->Guid, sizeof(GUID));
        memset(&IV, 0, sizeof(IV));
        IV.pvData = &siteGuid;
        IV.cbData = sizeof(siteGuid);

        // Set the index to the site affinity
        pAC = SCGetAttById(pTHS, ATT_MS_DS_SITE_AFFINITY);
        Assert(NULL != pAC);
        err = DBSetCurrentIndex(pTHS->pDB, 
                               (eIndexId)0, 
                               pAC, 
                               FALSE);  // don't maintain currency
        Assert(0 == err);
        if (err) {
            LogUnhandledError(err);
            DPRINT(0,"DBSetCurrentIndex to SiteAffinity failed\n");
            _leave;
        }

        err = DBSeek(pTHS->pDB,
                    &IV,
                     1,
                     DB_SeekGE);

        while (!err) {

            ATTR *pAttr;
            ULONG attrCount;
            DSNAME *pDSName;

            BOOL fCurrentEntryIsInSite = FALSE;

            // get our name
            pDSName = DBGetCurrentDSName(pTHS->pDB);
            Assert(pDSName);

            // get all of our site affinities
            err = DBGetMultipleAtts(pTHS->pDB,
                                    1, // all attributes
                                    &pAC,
                                    NULL, // no range
                                    NULL,
                                    &attrCount,
                                    &pAttr,
                                    DBGETMULTIPLEATTS_fEXTERNAL,
                                    0);

            // If we found this entry via an index, an attribute
            // value should exist
            Assert(!err);
            if (err) {
                DPRINT(0,"DBGetMultipleAtts failed even though entry in index exists\n");
                LogUnhandledError(err);
                _leave;
            }

            Assert(attrCount < 2);
            if (attrCount > 0) {
                // There must be at least one value
                Assert(pAttr->AttrVal.valCount > 0);

                // Find our site values
                Assert(pAttr->attrTyp == ATT_MS_DS_SITE_AFFINITY);
                for (i=0; i<pAttr->AttrVal.valCount; i++) {

                    SAMP_SITE_AFFINITY *psa;
                    ATTRVAL AttrVal = pAttr->AttrVal.pAVal[i];

                    Assert(sizeof(SAMP_SITE_AFFINITY) <= AttrVal.valLen);
                    psa = (SAMP_SITE_AFFINITY*) AttrVal.pVal;

                    if (IsEqualGUID(&siteGuid,&psa->SiteGuid)) {


                        if (ENTRY_HAS_EXPIRED(psa->TimeStamp, timeBestAfter)
                         && !IS_ZERO_TIME(psa->TimeStamp)  ) {

                            DPRINT1(0,"Expiring %ws \n", pDSName->StringName);
                            if ( oldCount < NELEMENTS(oldEntries) ) {
                                oldEntries[oldCount] = pTHS->pDB->DNT;
                                oldValues[oldCount].pVal = AttrVal.pVal;
                                oldValues[oldCount].valLen = AttrVal.valLen;
                                oldCount++;
                            }

                        } else {

                            DPRINT1(0,"Adding %ws to the refresh list\n", pDSName->StringName);
                            Assert(refreshCount < refreshMax);
                            if (refreshCount < refreshMax) {
                                refreshList[refreshCount++] = pDSName;
                            }
                        }

                        fFoundOurSite = TRUE;
                        fCurrentEntryIsInSite = TRUE;

                        //
                        // Once we have found our site, leave.
                        //
                        // N.B. This is necessary since we want to ignored
                        // site affinities that in error occur more than
                        // once.
                        //
                        break;
                    }
                }
            }

            // Are we done processing our site or have as many as we can
            // take?
            if ( (fFoundOurSite
             && !fCurrentEntryIsInSite)
             || (refreshCount >= refreshMax)) {

                Assert(refreshCount <= refreshMax);
                break;
            }

            // Move to the next candidate
            err = DBMove(pTHS->pDB, FALSE, 1);

        }
        err = 0;
        fCommit = TRUE;
    }
    _finally {
        DBClose(pTHS->pDB, fCommit);
    }

    if (err) {

        // An unexpected error hit
        // Log an event, reschedule, and return
        LogUnhandledError(err);
        if (pcSecsUntilNextIteration) {
            *pcSecsUntilNextIteration = UNEXPECTED_ERROR_RESCHEDULE_SECS;
        }
        *dsidExit = DSID(FILENO, __LINE__);
        goto Cleanup;
    }


    err = cleanupOldEntries(pTHS,
                            oldEntries,
                            oldValues,
                            oldCount);
    if (err) {
        // This isn't fatal
        err = 0;
    }

    if (refreshCount == refreshMax) {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GROUP_CACHING_MAX_USERS_REFRESHED,
                 szInsertUL(refreshMax),
                 NULL,
                 NULL);
       
    }

Cleanup:

    if (0 == err) {
        *refreshListOutput = refreshList;
        *refreshCountOutput = refreshCount;
    }

    return err;

}

DWORD
updateMemberships(
    IN THSTATE *pTHS,
    IN LPWSTR gcName,
    IN LPWSTR gcDomain,
    IN DWORD  refreshCount,
    IN DSNAME** refreshList
    )
/*++

Routine Description:

    This routine calls gcName to update the cached memberships of the accounts
    in refreshList.
    
Parameters:

    pTHS -- thread state
    
    gcName -- the name of the GC to update memberships from
    
    gcDomain -- the domain name that the GC belongs to
    
    refreshCount -- the number of accounts that need refreshing
    
    refreshList -- the accounts that need refreshing

Return Values

    0

 --*/
{
    ULONG err = 0;
    ULONG refreshIndex;

    //
    // Now get and update the membership cache
    //
    refreshIndex = 0;
    while (refreshIndex < refreshCount
       &&  !eServiceShutdown ) {

        NTSTATUS ntStatus = STATUS_SUCCESS;
        ULONG count;
        DSNAME*  users[GC_BATCH_LIMIT];

        memset(&users, 0, sizeof(users));

        count = 0;
        while ( (count < NELEMENTS(users))
             && (refreshIndex < refreshCount) ) {

                users[count] = refreshList[refreshIndex];
                count++;
                refreshIndex++;
        }
        // Get the list of users by walking site affinity index
        DBOpen(&pTHS->pDB);
    
        __try {

            ntStatus = GetAccountAndUniversalMemberships(pTHS,
                                                         0, // no flags -> universal
                                                         gcName,
                                                         gcDomain,
                                                         count,
                                                         users,
                                                         TRUE, // refresh task
                                                         NULL,
                                                         NULL);
    
            if (!NT_SUCCESS(ntStatus)) {
    
                //
                // Strange -- log error and continue
                //
                LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                         DS_EVENT_SEV_BASIC,
                         DIRLOG_GROUP_CACHING_GROUP_RETRIEVAL_FAILED,
                         szInsertWin32Msg(RtlNtStatusToDosError(ntStatus)),
                         NULL,
                         NULL);
            }
        }
        _finally
        {
            if (pTHS->pDB) {
                // Don't commit changes since this will only happen on
                // error
                DBClose(pTHS->pDB, FALSE);
            }
        }
    }

    // There should not be a transaction
    Assert(NULL == pTHS->pDB);
    
    return 0;
}

DWORD
checkIfFallingBehind(
    IN THSTATE *pTHS
    )
/*++

Routine Description:

    This routine checks that time stamp of the oldest cached membership. If
    the time stamp indicates that cached membership is still stale (even
    after the refresh task has already run), then an event log message is
    posted.
    
Parameters:

    pTHS -- thread state
    
Return Values

    0

 --*/
{

    DWORD err = 0;
    ATTCACHE *pAC;
    ULONG   oldEntries[MAX_CLEANUP_LIMIT];
    ATTRVAL oldValues[MAX_CLEANUP_LIMIT];
    ULONG   oldCount = 0;
    DWORD i;
    BOOLEAN fCommit = FALSE;

    //
    // Now determine if we are falling behind
    //
    DBOpen(&pTHS->pDB);
    __try {

        ULONG count = 0;

        // Set the index to the cached membership time stamp.
        // Find the entry with the earliest time stamp to see if
        // that entry is stale
        BOOL fFoundEntry = FALSE;

        pAC = SCGetAttById(pTHS, ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP);
        Assert(NULL != pAC);
        err = DBSetCurrentIndex(pTHS->pDB, 
                               (eIndexId)0, 
                               pAC, 
                               FALSE);  // don't maintain currency
        Assert(0 == err);
        if (err) {
            LogUnhandledError(err);
            DPRINT(0,"DBSetCurrentIndex to SiteAffinity failed\n");
            _leave;
        }

        // Prepare to get the site affinity.
        pAC = SCGetAttById(pTHS, ATT_MS_DS_SITE_AFFINITY);
        Assert(NULL != pAC);

        // reset the count of elements we want to cleanup
        oldCount = 0;
        err = DBMove(pTHS->pDB,
                     FALSE,  // don't use sort table
                     DB_MoveFirst);
        while (!err) {

            ATTR *pAttr;
            ULONG attrCount;

            count++;
            if (count > NTDSA_SAM_CACHE_MAX_STALE_ACCOUNTS) {
                //
                // This is an unusual configuration; we have visited
                // many user's that have cached membership but no
                // site affinity. Break to avoid walking a large number
                // The cleanup code will eventually remove these
                // entries
                //
                break;
            }

            // get all of our site affinities
            err = DBGetMultipleAtts(pTHS->pDB,
                                    1, // all attributes
                                    &pAC,
                                    NULL, // no range
                                    NULL,
                                    &attrCount,
                                    &pAttr,
                                    DBGETMULTIPLEATTS_fEXTERNAL,
                                    0);

            if (!err) {

                if (attrCount > 0) {
                    // There must be at least one value
                    Assert(pAttr->AttrVal.valCount > 0);
    
                    // Find our site values
                    Assert(pAttr->attrTyp == ATT_MS_DS_SITE_AFFINITY);
                    for (i=0; i<pAttr->AttrVal.valCount; i++) {
    
                        SAMP_SITE_AFFINITY *psa;
                        ATTRVAL AttrVal = pAttr->AttrVal.pAVal[i];
    
                        Assert(sizeof(SAMP_SITE_AFFINITY) <= AttrVal.valLen);
                        psa = (SAMP_SITE_AFFINITY*) AttrVal.pVal;
    
                        if (IsEqualGUID(&gAnchor.pSiteDN->Guid,&psa->SiteGuid)) {

                            fFoundEntry = TRUE;
                            break;
                        }
                    }
                } else {

                    // A cached membership value, but no site affinity? 
                    // Cleanup this entry since it will never updated 
                    if ( oldCount < NELEMENTS(oldEntries) ) {
                        oldEntries[oldCount] = pTHS->pDB->DNT;
                        oldCount++;
                    }
                }
            }
            err = 0;

            if (fFoundEntry) {
                break;
            }

            err = DBMove(pTHS->pDB,
                         FALSE,  // don't use sort table
                         DB_MoveNext);
        }

        if (fFoundEntry) {

            LARGE_INTEGER entryExpires;
            LARGE_INTEGER lastRefreshTime;
            LARGE_INTEGER now;
            LARGE_INTEGER timeTemp;

            err = DBGetSingleValue(pTHS->pDB,
                                   ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP,
                                   &entryExpires,
                                   sizeof(entryExpires),
                                   NULL);
            if (!err) {

                // When does the last entry expire (measured in minutes)
                ULONG siteStaleness;
                err = GetConfigParam(GCLESS_STALENESS,
                                     &siteStaleness,
                                     sizeof(siteStaleness));
                if (err) {
                    siteStaleness = GCLESS_DEFAULT_STALENESS_HOURS * 60;
                    err = 0;
                }
                timeTemp.QuadPart = Int32x32To64(siteStaleness*60, ONE_SECOND_IN_FILETIME);
                entryExpires.QuadPart += timeTemp.QuadPart;

                GetSystemTimeAsFileTime((FILETIME*)&now);

                if (entryExpires.QuadPart < now.QuadPart ) {

                    // We are falling behind

                    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GROUP_CACHING_FALLING_BEHIND,
                             NULL,
                             NULL,
                             NULL);

                }

            }
        }

        if (err == JET_errNoCurrentRecord) {
            //
            // This is the case where no object has the cached membership
            // time stamp.
            //
            err = 0;
        }
        fCommit = TRUE;
    }
    _finally {
        DBClose(pTHS->pDB, fCommit);
    }


    if (oldCount > 0 ) {

        // An error here isn't fatal and are logged in the function
        // itself
        (VOID) cleanupOldEntries(pTHS,
                                 oldEntries,
                                 NULL,
                                 oldCount);
    }

    return 0;

}

VOID
RefreshUserMembershipsMain (
    DWORD * pcSecsUntilNextIteration,
    BOOL    fClientRequest
    )
/*++

Routine Description:

    This routine is the main algorithm for refreshing the cached group
    memberships for sites configured as branch offices. See spec for
    theory.

Parameters:

    pcSecsUntilNextIteration -- when the task should be resheduled
    
    fClientRequest -- TRUE if this task is being initiatized by a client request
                      (via a write to the rootDSE object)

Return Values
    
    None.

 --*/
{
    THSTATE *pTHS = pTHStls;
    ATTCACHE *pAC = NULL;

    DWORD err = 0;
    ULONG i;

    BOOL fRunNow = FALSE;
    LPWSTR siteName = NULL;
    LPWSTR gcName;
    LPWSTR gcDomain;

    DWORD refreshCount;
    DSNAME **refreshList = NULL;

    ULONG   dsidExit = 0;

    ULONG   cConnectedSites = 0;
    CACHE_CONNECTED_SITES *connectedSites = NULL;

    DPRINT(1,"Group Membership Cache Refresh Task commencing.\n");

    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
             DS_EVENT_SEV_BASIC,
             DIRLOG_GROUP_CACHING_TASK_STARTING,
             NULL,
             NULL,
             NULL);


    //
    // Either the task is running by itself or the caller has already 
    // been access check'ed.  In either case it is now safe to
    // set fDSA to TRUE.  It is also necessary since searches will
    // be made (to determine site information).
    //
    pTHS->fDSA = TRUE;
    _try
    {
        // Shutdown? Exit
        if (eServiceShutdown) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        if (!isGroupCachingEnabled()) {
            // nothing to do
            DPRINT(1,"Group caching not enabled -- exiting .\n");
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
        

        //
        // Determine if the task can run and the next time the task
        // should run.
        //
        err = getSchedulingInformation(pTHS,
                                       &fRunNow,
                                       pcSecsUntilNextIteration,
                                       &cConnectedSites,
                                       &connectedSites,
                                       &siteName,
                                       &dsidExit
                                     );
        if (err) {
            if (dsidExit == 0) {
                dsidExit = DSID(FILENO, __LINE__);
            }
            goto LogReturn;
        }


        if (!fRunNow && !fClientRequest) {
        
            // Always run during a client request
            Assert(0 != *pcSecsUntilNextIteration);
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }

        //
        // Get scheduling information and a target DC
        //
        err = getTargetGCInformation(pTHS,
                                     cConnectedSites,
                                     connectedSites,
                                     siteName,
                                     &gcName,
                                     &gcDomain,
                                     pcSecsUntilNextIteration,
                                     &dsidExit
                                     );
        if (err) {
            if (dsidExit == 0) {
                dsidExit = DSID(FILENO, __LINE__);
            }
            goto LogReturn;
        }
    
        //
        // Get the list of accounts to refresh
        //
        err = getAccountsToRefresh(pTHS,
                                   &refreshCount,
                                   &refreshList,
                                   pcSecsUntilNextIteration,
                                   &dsidExit
                                   );
        if (err) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        //
        // Update the memberships
        //
        err = updateMemberships(pTHS,
                                gcName,
                                gcDomain,
                                refreshCount,
                                refreshList);

        if (err) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        // Shutdown? Exit
        if (eServiceShutdown) {
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }
    
        //
        // Log a message if there are users that haven't been updated
        //
        err = checkIfFallingBehind(pTHS);
        if (err) {
            // unexpected
            dsidExit = DSID(FILENO, __LINE__);
            goto LogReturn;
        }

        //
        // We are done!
        //
        dsidExit = DSID(FILENO, __LINE__);
        goto LogReturn;
    
    LogReturn:

        if (connectedSites) {
            for (i = 0; i < cConnectedSites; i++) {
                if (connectedSites[i].siteName) {
                    THFreeEx(pTHS, connectedSites[i].siteName);
                }
            }
            THFreeEx(pTHS, connectedSites);
        }
    
        if (siteName) {
            THFreeEx(pTHS, siteName);
        }
    
        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_TASK_ENDING,
                 szInsertUL(err),
                 szInsertHex(dsidExit),
                 NULL);

    }
    _finally
    { 
        pTHS->fDSA = FALSE;
    }

    return;
}


void
RefreshUserMemberships (
        void *  pv,
        void ** ppvNext,
        DWORD * pcSecsUntilNextIteration
        )
/*++

Description:

    This routine is a wrapper for RefreshUserMembershipsMain.  The purpose
    is to be callable from the ds task queue.

Parameters:

    pv      -- input parameter for this iteration
    ppvNext -- input parameter for next iteration
    pcSecsUntilNextIteration -- seconds until next iteration
    
Return values:

       None.
       
--*/
{
    DWORD secsUntilNextIteration = 0;

    *pcSecsUntilNextIteration = 0;

    __try {

        RefreshUserMembershipsMain( pcSecsUntilNextIteration, FALSE );
    }
    __finally {

        // Something fatal happened
        if ( 0 == *pcSecsUntilNextIteration ) {
            *pcSecsUntilNextIteration = DEFAULT_REFRESH_INTERVAL_SECS;
        }

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_TASK_RESCHEDULING,
                 szInsertUL((*pcSecsUntilNextIteration / 60)),
                 NULL,
                 NULL);

        *ppvNext = pv;
    }
    
    return;
}

BOOL
siteContainsGC(
    IN THSTATE* pTHS,
    IN LPWSTR siteName
    )
/*++

Description:

    This routine determines if siteName contains a GC by searching in the DS
    for a NTDSA object that has the GC bit set on its options attribute

Parameters:

    pTHS -- thread state
    
    siteName -- the DN of a site

Return values:

    TRUE if siteName contains a GC; FALSE otherwise
       
--*/
{

    SEARCHRES * pSearchRes;
    ULONG err;
    FILTER * pf;
    DSNAME * siteDN;
    SEARCHARG searchArg;
    BOOL fFoundGC = FALSE;
    ATTR attr;
    ENTINF *EntInf = NULL;
    ENTINFLIST *EntInfList = NULL;
    ULONG len, size;
    ULONG i, j;
    DWORD ZeroValue = 0;
    DSNAME *pdnDsaObjCat;

    Assert(NULL != siteName);

    // Search for ntdsa objects with an options field greater than 0

    // First, create the siteDN
    len = wcslen(siteName);
    size = DSNameSizeFromLen(len);
    siteDN = THAllocEx(pTHS, size);
    siteDN->structLen = size;
    siteDN->NameLen = len;
    wcscpy(&siteDN->StringName[0], siteName);

    //
    // BUGBUG -- Scalability -- should this be a paged search?
    //
    memset(&searchArg, 0, sizeof(searchArg));
    InitCommarg(&searchArg.CommArg);
    searchArg.pObject = siteDN;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.bOneNC = TRUE;
    searchArg.searchAliases = FALSE;


    // Ask for the options attribute
    searchArg.pSelectionRange = NULL;
    searchArg.pSelection = THAllocEx(pTHS, sizeof(ENTINFSEL));
    searchArg.pSelection->attSel = EN_ATTSET_LIST;
    searchArg.pSelection->infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection->AttrTypBlock.attrCount = 1;
    searchArg.pSelection->AttrTypBlock.pAttr = &attr;
    memset(&attr, 0, sizeof(attr));
    attr.attrTyp = ATT_OPTIONS;

    // Build a filter to find NTDS-DSA objects

    // initial choice object
    searchArg.pFilter = pf = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_AND;
    pf->FilterTypes.And.pFirstFilter = THAllocEx(pTHS, sizeof(FILTER));

    // first predicate:  the right object class
    pdnDsaObjCat = DsGetDefaultObjCategory(CLASS_NTDS_DSA);
    Assert(pdnDsaObjCat);
    pf = pf->FilterTypes.And.pFirstFilter;
    pf->choice = FILTER_CHOICE_ITEM;
    pf->pNextFilter = NULL;
    pf->FilterTypes.Item.choice =  FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDsaObjCat->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR*)pdnDsaObjCat;
    searchArg.pFilter->FilterTypes.And.count = 1;

    // second predicate:  ignore objects with no options field, or 
    // options equal to zero
    pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf = pf->pNextFilter;
    pf->pNextFilter = NULL;
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice = FI_CHOICE_GREATER;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_OPTIONS;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(DWORD);
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE)&ZeroValue;
    searchArg.pFilter->FilterTypes.And.count = 2;

    pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));

    SearchBody(pTHS,
               &searchArg, 
               pSearchRes,
               0);
    

    EntInfList = &pSearchRes->FirstEntInf;
    for (i = 0; i < pSearchRes->count; i++) {

        Assert(EntInfList != NULL);
        EntInf = &EntInfList->Entinf;

        for (j = 0; j < EntInf->AttrBlock.attrCount; j++) {

            ATTR *pAttr = &EntInf->AttrBlock.pAttr[j];
            ULONG Options;

            Assert(pAttr->attrTyp == ATT_OPTIONS);
            Assert(pAttr->AttrVal.valCount == 1);
            Assert(pAttr->AttrVal.pAVal[0].valLen == sizeof(DWORD));

            Options = *((DWORD*)pAttr->AttrVal.pAVal[0].pVal);

            if (Options & NTDSDSA_OPT_IS_GC) {
                // We found one
                fFoundGC = TRUE;
                break;
            }
        }
        EntInfList = EntInfList->pNextEntInf;
    }

    THClearErrors();

    if (!fFoundGC) {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_INTERNAL,
                 DIRLOG_GROUP_CACHING_GROUP_NO_GC_SITE,
                 szInsertWC(siteName),
                 NULL,
                 NULL);
    }

    return fFoundGC;

}


int
__cdecl
compareConnectedSites(
    const void* elem1,
    const void* elem2
    )
{
    CACHE_CONNECTED_SITES *cs1 = (CACHE_CONNECTED_SITES *)elem1;
    CACHE_CONNECTED_SITES *cs2 = (CACHE_CONNECTED_SITES *)elem2;

    return (int)cs1->cost - (int)cs2->cost;

}


DWORD
analyzeSitePreference(
    IN  ULONG defaultRefreshInterval,
    OUT ULONG* cConnectedSitesOutput,
    OUT CACHE_CONNECTED_SITES **connectedSitesOutput,
    OUT LPWSTR* siteName,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    )
/*++

Description:

    This routine is used during the cached membership refresh task to determine
    which site to ask the locator to find a GC in. Also, it determines if
    there is (IP) connectivity to the site now and hence if the task should
    run.

Parameters:

    defaultRefreshInterval -- the default refresh interval in seconds

    cConnectedSitesOutput -- the number of sites in the array of connected sites
    
    connectedSitesOutput -- an array of connected sites, to be freed with THFree
                            along with any embedded siteName fields
    
    siteName -- set to the admin configured site if one exists
    
    pfRunNow -- set to TRUE if there is connectivity to an available site now
    
    secsTillNextIteration -- based on the schedule information, this variable
                             indicates the next time this task should be run.
                             
    
Return values:

    0 on success:
    !0 on fatal error: all interesting events will be logged
       
--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD err = 0;
    WCHAR transportName[] = L"CN=IP,CN=Inter-Site Transports,CN=Sites,";
    LPWSTR transportDN = NULL;
    LPWSTR preferredSite = NULL, localSite= NULL, workSite = NULL;
    SCHEDULE *workSchedule = NULL;
    SCHEDULE *pSchedule = NULL;
    ULONG size, count;
    ULONG i, j;
    ULONG ourSiteIndex;
    ISM_SCHEDULE *pIsmSchedule = NULL;
    ISM_CONNECTIVITY *pConnectivity = NULL;
    CACHE_CONNECTED_SITES *connectedSites = NULL;
    ULONG cheapestCost;
    LPWSTR workSiteFriendlyName = NULL;

    // Init the out parameters
    *cConnectedSitesOutput = 0;
    *connectedSitesOutput = NULL;
    *siteName = NULL;

    // Prepare our local site
    localSite = THAllocEx(pTHS, (gAnchor.pSiteDN->NameLen+1) * sizeof(WCHAR));
    wcsncpy(localSite, 
            gAnchor.pSiteDN->StringName, 
            gAnchor.pSiteDN->NameLen);

    // Prepare the transport DN
    size = ((gAnchor.pConfigDN->NameLen+1) * sizeof(WCHAR)) + sizeof(transportName);
    transportDN = THAllocEx(pTHS, size);
    wcscpy(transportDN, transportName);
    wcsncat(transportDN, gAnchor.pConfigDN->StringName, gAnchor.pConfigDN->NameLen);

    // Read the configured preferred site, if any
    DBOpen(&pTHS->pDB);
    _try
    {
        WCHAR SiteSettingsCN[] = L"Ntds Site Settings";
        DSNAME *pSiteSettingsDN = NULL;
        
        size = 0;
        size = AppendRDN(gAnchor.pSiteDN,
                         pSiteSettingsDN,
                         size,
                         SiteSettingsCN,
                         0,
                         ATT_COMMON_NAME
                         );

        pSiteSettingsDN = THAllocEx(pTHS,size);
        pSiteSettingsDN->structLen = size;
        AppendRDN(gAnchor.pSiteDN,
                  pSiteSettingsDN,
                  size,
                  SiteSettingsCN,
                  0,
                  ATT_COMMON_NAME
                  );

        err = DBFindDSName(pTHS->pDB, pSiteSettingsDN);
        THFreeEx(pTHS,pSiteSettingsDN);
        if (!err) {
            ULONG len = 0;
            DSNAME *pPrefSiteDN;

            err = DBGetAttVal(pTHS->pDB,
                               1,
                               ATT_MS_DS_PREFERRED_GC_SITE,
                               0,
                               0,
                               &len,
                               (UCHAR**)&pPrefSiteDN);
            if (!err) {
                preferredSite = THAllocEx(pTHS, 
                                          (pPrefSiteDN->NameLen+1)*sizeof(WCHAR));
                wcsncpy(preferredSite, 
                        pPrefSiteDN->StringName, 
                        pPrefSiteDN->NameLen);
            }
        }

        if (preferredSite) {
    
            // There is a configured site
            // Note that we manually find a schedule instead of calling the
            // ISM -- this is by design.

            err = findScheduleForSite(pTHS,
                                      transportDN,
                                      localSite,
                                      preferredSite,
                                      &workSchedule);
            if (!err) {
    
                DWORD parseErr;
                DWORD len, ccKey, ccVal;
                WCHAR *pKey, *pVal;

                // And a valid schedule exists -- we'll use
                // this site
                workSite = preferredSite;

                // Return the value to the caller in the friendly name format
                len = wcslen(preferredSite);
                parseErr = GetRDN(&preferredSite,
                                  &len,
                                  &pKey,
                                  &ccKey,
                                  &pVal,
                                  &ccVal);
                Assert(0 == parseErr && (ccVal > 0));

                *siteName = THAllocEx(pTHS, (ccVal+1)*sizeof(WCHAR));
                wcsncpy(*siteName, pVal, ccVal);
                workSiteFriendlyName = *siteName;

            } else {

                // Can't get a schedule to the preferred site?
                // Log a warning
                LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_GROUP_CACHING_NO_SCHEDULE_FOR_PREFERRED_SITE,
                         szInsertWC(preferredSite),
                         NULL,
                         NULL);
            }
        }

        //
        // No preferred site could be found -- make the expensive call to the
        // ISM to find a cheap site to schedule ourselves around.
        //
    
        if (NULL == workSite) {

            err = I_ISMGetConnectivity(transportDN,
                                       &pConnectivity);
    
            if (!err) {

                DSNAME *dsnameLocalSite = NULL;
                DSNAME *dsnameTargetSite = NULL;
                ULONG  len;

                Assert(NULL != pConnectivity);

                //
                // Convert the names to DSNAME's so the proper
                // name comparison function can be used.
                //
                len = wcslen(localSite);
                size = DSNameSizeFromLen(len);
                dsnameLocalSite = THAllocEx(pTHS,size);
                dsnameLocalSite->structLen = size;
                wcscpy(&dsnameLocalSite->StringName[0], localSite);
                dsnameLocalSite->NameLen = len;
        
                // Find our site
                for (i = 0; i < pConnectivity->cNumSites; i++) {
        
                    len = wcslen(pConnectivity->ppSiteDNs[i]);
                    size = DSNameSizeFromLen(len);
                    // Note the THAllocEx -- don't alloca in a loop
                    dsnameTargetSite = THAllocEx(pTHS, size);
                    memset(dsnameTargetSite, 0, size);
                    dsnameTargetSite->structLen = size;
                    wcscpy(&dsnameTargetSite->StringName[0], pConnectivity->ppSiteDNs[i]);
                    dsnameTargetSite->NameLen = len;

                    if (NameMatchedStringNameOnly(dsnameLocalSite,
                                                  dsnameTargetSite)) {
                        // This is it;
                        THFreeEx(pTHS, dsnameTargetSite);
                        ourSiteIndex = i;
                        break;
                    }
                    THFreeEx(pTHS, dsnameTargetSite);
                }
                THFreeEx(pTHS,dsnameLocalSite);

                if (i == pConnectivity->cNumSites) {
                    //
                    // This is an unexpected occurrance; we couldn't find
                    // our site.
                    //
                    err = ERROR_NO_SUCH_SITE;
                    leave;
                }
        
        
                // Now find sites we are connected too
                //
                // N.B. We are considered connected to our own site, so if we
                // have a GC, then use our site.  This behavoir falls out
                // naturally from the algorithm below.
                //                

                connectedSites = (CACHE_CONNECTED_SITES*)THAllocEx(pTHS, 
                                           pConnectivity->cNumSites * sizeof(CACHE_CONNECTED_SITES));
                count = 0;
                for (j = 0; j < pConnectivity->cNumSites; j++) {
        
                    if (pConnectivity->pLinkValues[ourSiteIndex*pConnectivity->cNumSites+j].ulCost != 0xFFFFFFFF) {
                        // There is connectivity

                        DPRINT3(1,"Connectivity found between %ls and %ls, cost %d\n", 
                                localSite,
                                pConnectivity->ppSiteDNs[j],
                                pConnectivity->pLinkValues[ourSiteIndex*pConnectivity->cNumSites+j].ulCost);
                        connectedSites[count].siteName = pConnectivity->ppSiteDNs[j];
                        connectedSites[count].cost = pConnectivity->pLinkValues[ourSiteIndex*pConnectivity->cNumSites+j].ulCost;
                        count++;
                    }
                }
        
                // sort the array in decreasing cost
                if (count > 0) {
        
                    qsort(connectedSites, 
                          count,
                          sizeof(*connectedSites),
                          compareConnectedSites);
                }
        
                // Find the cheapest sites with a GC in them and put the sites
                // into connectedSites.  Note that the siteName field
                // is changed from the the DN to the friendly name and
                // that no references to ISM allocated memory are returned
                // from this function.
                Assert( NULL == workSite );
                for (i = 0; i < count; i++) {

                    if (workSite 
                     && (connectedSites[i].cost > cheapestCost)) {

                        // We have found at least one site with a GC and are
                        // now on to more expensive sites.  We can exit.
                        break;
                    }

                    if (siteContainsGC(pTHS, connectedSites[i].siteName)) {

                        if (pIsmSchedule) {
                            I_ISMFree(pIsmSchedule);
                            pIsmSchedule = NULL;
                        }
        
                        // make sure there is a schedule
                        err = I_ISMGetConnectionSchedule(transportDN,
                                                         localSite,
                                                         connectedSites[i].siteName,
                                                         &pIsmSchedule);
                        if (!err) {

                            DWORD parseErr;
                            DWORD ccKey, ccVal;
                            WCHAR *pKey, *pVal;
                            LPWSTR friendlyName;

                            // And a valid schedule exists -- we'll use
                            // this site
                            connectedSites[i].fHasGC = TRUE;

                            //
                            // Replace the DN with a friendly name
                            //
                            len = wcslen(connectedSites[i].siteName);
                            parseErr = GetRDN(&connectedSites[i].siteName,
                                              &len,
                                              &pKey,
                                              &ccKey,
                                              &pVal,
                                              &ccVal);
                            Assert(0 == parseErr && (ccVal > 0));
            
                            friendlyName = THAllocEx(pTHS, (ccVal+1)*sizeof(WCHAR));
                            wcsncpy(friendlyName, pVal, ccVal);

                            if (NULL == workSite) {

                                //
                                // We'll use the first cheapest site to schedule
                                // ourselves on.
                                //

                                cheapestCost = connectedSites[i].cost;
                                workSite = connectedSites[i].siteName;
                                workSiteFriendlyName = friendlyName;

                                if (pIsmSchedule && pIsmSchedule->pbSchedule) {
                                    workSchedule = THAllocEx(pTHS, pIsmSchedule->cbSchedule);
                                    memcpy(workSchedule, pIsmSchedule->pbSchedule, pIsmSchedule->cbSchedule);
                                }
                            }

                            // Change over to the friendly name
                            connectedSites[i].siteName = friendlyName;

                        } else {

                            LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                                     DS_EVENT_SEV_BASIC,
                                     DIRLOG_GROUP_CACHING_NO_SCHEDULE_FOR_SITE,
                                     szInsertWC(connectedSites[i].siteName),
                                     szInsertUL(err),
                                     NULL);

                            connectedSites[i].siteName = NULL;
                        }

                    } else {

                        connectedSites[i].siteName = NULL;
                    }


                }

                // Set the return values.  i is the number of sites that
                // were visited in the loop above.
                *cConnectedSitesOutput = i;
                *connectedSitesOutput = connectedSites;

            }
        }
    }
    _finally {
        DBClose(pTHS->pDB, TRUE);
    }

    if (workSite) {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_SITE_FOUND,
                 szInsertWC(workSiteFriendlyName),
                 NULL,
                 NULL);

        analyzeSchedule(defaultRefreshInterval,
                        workSiteFriendlyName,
                        workSchedule,
                        pfRunNow,
                        secsTillNextIteration);

    } else {

        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_NO_SITE_FOUND,
                 NULL,
                 NULL,
                 NULL);

        // Our best efforts failed. Rely on the locator
        // and use default scheduling
        *pfRunNow = TRUE;
        *secsTillNextIteration = defaultRefreshInterval;
    }

    if (connectedSites && (NULL == *connectedSitesOutput)) {
        THFreeEx(pTHS, connectedSites);
    }

    if (workSchedule) {
        THFreeEx(pTHS, workSchedule);
    }

    if (pConnectivity) {
        I_ISMFree(pConnectivity);
    }

    if (pIsmSchedule) {
        I_ISMFree(pIsmSchedule);
    }

    return err;

}


DWORD 
getGCFromSite(
    IN  THSTATE *pTHS,
    IN  LPWSTR siteName,
    IN  ULONG cConnectedSites OPTIONAL,
    IN  CACHE_CONNECTED_SITES *connectedSites OPTIONAL,
    OUT LPWSTR *gcName,
    OUT LPWSTR *gcDomain
    )
/*++

Description:

    This routine is used during the cached membership refresh task to determine
    which site to ask the locator to find a GC in. Also, it determines if
    there is (IP) connectivity to the site now and hence if the task should
    run.

Parameters:

    siteName -- the user specified site name; returned as NULL if the user
                hasn't configured one

    cConnectedSites -- the number of sites in the array of connected sites
    
    connectedSites -- an array of connected sites
                
    pfRunNow -- set to TRUE if there is connectivity to an available site now
    
    secsTillNextIteration -- based on the schedule information, this variable
                             indicates the next time this task should be run.
                             
    
Return values:

    0 on success:
    !0 on fatal error: all interesting events will be logged
       
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW  DomainControllerInfo = NULL;
    DWORD Flags;
    DWORD attempt = 0;
    LPWSTR requestedSiteName = siteName;

    *gcName = NULL;
    *gcDomain = NULL;

    // Necessary flags
    Flags = DS_GC_SERVER_REQUIRED | DS_RETURN_DNS_NAME;

    while (TRUE)  {

        //
        // GC discovery algorithm is as follows:
        //
        // Try to find GC in preferred site (if one is provided).
        // If that fails, try again for any site.
        //

        if (DomainControllerInfo) {
            NetApiBufferFree(DomainControllerInfo);
            DomainControllerInfo = NULL;
        }

        //
        // Call into DsGetDcName
        //
        WinError = DsGetDcNameW(NULL,  // call locally
                                NULL,  // domain doesn't matter
                                NULL,  // domain guid
                                requestedSiteName,  // site name
                                Flags,
                                &DomainControllerInfo);


        if ( (ERROR_SUCCESS != WinError)
         &&  (NULL != requestedSiteName) ) {
            //
            // Try again with no site name and turn off the force flag just
            // in case it was previously set
            //
            requestedSiteName = NULL;
            continue;
        }

        break;

    }

    if ( ERROR_SUCCESS == WinError ) {

        //
        // We found a GC
        //
        LPWSTR discoveredSiteName;
        DWORD len;
        BOOL  fRewind = FALSE;

        Assert(DomainControllerInfo != NULL);

        //
        // Copy the info to the out parameters
        //
        Assert(DomainControllerInfo->DomainControllerName);
        len = wcslen(DomainControllerInfo->DomainControllerName);
        (*gcName) = THAllocEx(pTHS, (len+1) * sizeof(WCHAR));
        wcscpy( (*gcName), DomainControllerInfo->DomainControllerName);

        Assert(DomainControllerInfo->DomainName);
        if (DomainControllerInfo->DomainName[0] == L'\\' ) {
            DomainControllerInfo->DomainName += 2;
        }
        len = wcslen(DomainControllerInfo->DomainName);
        (*gcDomain) = THAllocEx(pTHS, (len+1) * sizeof(WCHAR));
        wcscpy( (*gcDomain), DomainControllerInfo->DomainName);
        if (fRewind) {
            DomainControllerInfo->DomainName -= 2;
        }

        //
        // Perform some analysis to determine how good the GC is
        //
        discoveredSiteName = DomainControllerInfo->DcSiteName;
        if (discoveredSiteName) {

            //
            // First, if there was a preferred site and the destination DC is
            // not in the preferred site, log a warning
            //
            if (siteName) {
    
                if (!EQUAL_STRING(siteName, discoveredSiteName)) {
    
                    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GROUP_CACHING_CLOSER_GC_FOUND,
                             szInsertWC(siteName),
                             szInsertWC(discoveredSiteName),
                             NULL);
                }
            }

            //
            // Next, if we have a list of close sites as determined by the ISM
            // see if the GC that the locator found is in one of those sites
            //
            if (connectedSites) {
    
                BOOL fdiscoveredSiteIsCheap = FALSE;
                ULONG i;

                for (i = 0; i < cConnectedSites; i++) {
    
                    if ( connectedSites[i].fHasGC
                     &&  EQUAL_STRING(discoveredSiteName, connectedSites[i].siteName)) {

                         fdiscoveredSiteIsCheap = TRUE;
                         break;
                    }
                }

                if (!fdiscoveredSiteIsCheap) {

                    LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GROUP_CACHING_CONFIGURED_SITE_NOT_CLOSEST,
                             szInsertWC(discoveredSiteName),
                             NULL,
                             NULL);

                }
            }
        }

       LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                DS_EVENT_SEV_BASIC,
                DIRLOG_GROUP_CACHING_GC_FOUND,
                szInsertWC(*gcName),
                szInsertWC(DomainControllerInfo->DcSiteName),
                szInsertWC(*gcDomain));
    }


    if ( ERROR_SUCCESS != WinError ) {

        //
        // Couldn't find a GC -- log an error message
        //
        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_GROUP_CACHING_NO_GC_FOUND,
                 szInsertWin32Msg(WinError),
                 NULL,
                 NULL);

    }

    if (DomainControllerInfo) {
        NetApiBufferFree(DomainControllerInfo);
    }

    return WinError;
}

VOID
analyzeSchedule(
    IN  ULONG    defaultRefreshInterval,
    IN  LPWSTR   siteName,
    IN  SCHEDULE *pSchedule OPTIONAL,
    OUT BOOL*  pfRunNow,
    OUT DWORD* secsTillNextIteration
    )
/*++

Description:

    This routine, given a schedule, determines if the current
    time falls under an open window.  It also sets the next time
    for the refresh task to run adjusted by a random factor between
    0 and the lesser of 15 minutes and defaultRefreshInterval to 
    prevent large numbers of DCs from executing this task against 
    the same GC at once.  

Parameters:

    siteName  -- name of the site we are connecting with
                              
    pSchedule -- a schedule of 15 minutes slots
    
    defaultRefreshInterval -- default seconds 'till next iteration
    
    pfRunNow  -- is there a window open now
    
    secsTillNextIteration -- when the task should next run

Return values:

    None.
       
--*/
{
    REPLTIMES replTimes;    
    DSTIME now, nextTime;
    BOOL fOn;
    ULONG count;
    UCHAR *pTemp;
    ULONG  randomFactor;
    DSTIME  proposedTime;
#if DBG
    // The date string won't be more than 40 characters
    CHAR    DsTimeBuffer[40];
#endif
    // The seed will be psuedo randomized from the tick count
    ULONG ulRandomSeed = GetTickCount();

    Assert(pfRunNow);
    Assert(secsTillNextIteration);

    // Calculate a randomizing factor (between 0 and 15 minutes) so 
    // not all DC's refresh at the same time.  While this value will always
    // be less than DEFAULT_REFRESH_INTERVAL_SECS, the value can
    // potentially be changed via the registry to something < 15 min.  
    // We will use the smaller of 15 min and defaultRefreshInterval when
    // determining our upper bound to prevent possible underflow 
    // conditions where the next refresh time will be set very far into 
    // the future.    
    randomFactor = (RtlRandomEx(&ulRandomSeed) %
                           min(15*60, defaultRefreshInterval));

    if ( (pSchedule == NULL) 
      || (pSchedule->NumberOfSchedules == 0)
      || (!convertScheduleToReplTimes(pSchedule, &replTimes))) {
        DPRINT(1,"Running now since schedule is always on\n");
        fOn = TRUE;
        *pfRunNow = TRUE;
        *secsTillNextIteration = defaultRefreshInterval + randomFactor;

    } else {

        // Look through the schedule to see if we should run now
        now = DBTime();
        DPRINT1(1,"Current Time: %s\n", DbgPrintDsTime(now, DsTimeBuffer));

        (*pfRunNow) = fIsBetweenTime(&replTimes, now, now);
    
        // Now determine the next time to wake up
        nextTime = now;
        if ((*pfRunNow)) {
            DPRINT(1,"Can run right now\n");
            nextTime += defaultRefreshInterval;
        }
    
        // Find the next "on" time starting with nextTime
        count = 0;
        do {
            DPRINT1(1,"Next proposed time %s\n", DbgPrintDsTime(nextTime, DsTimeBuffer));
            fOn = fIsBetweenTime(&replTimes, nextTime, nextTime);
            if (fOn) {
                DPRINT1(1,"This last time (%s) works\n", DbgPrintDsTime(nextTime, DsTimeBuffer));
                break;
            } else {
                // 15 minute increments
                nextTime +=  REPL_SLOT_IN_SECONDS;
            }
            count++;
            // There are 672 fifteen minute slots in a week
        } while (count < 672);

        if (fOn) {
            *secsTillNextIteration = (ULONG) (nextTime - now);
        } else {
            *secsTillNextIteration = defaultRefreshInterval;
        }

        // Add the factor if the result is still with in the window, otherwise
        // subtract.  If that doesn't work, leave as is.
        proposedTime = now + *secsTillNextIteration + randomFactor;
        if (fIsBetweenTime(&replTimes, proposedTime, proposedTime) ) {
            DPRINT2(1,"Proposed time of %s works (random factor of %d seconds added)\n", DbgPrintDsTime(proposedTime, DsTimeBuffer), randomFactor);
            *secsTillNextIteration += randomFactor;
        } else {
            // If randomFactor is ever larger we would underflow 
            // secsTillNextIteration which would result in a very 
            // long interval before refresh
            Assert(*secsTillNextIteration >= randomFactor);             

            proposedTime = now + *secsTillNextIteration - randomFactor;
            if (fIsBetweenTime(&replTimes, proposedTime, proposedTime) ) {
                DPRINT2(1,"Proposed time of %s works (random factor of %d subtracted)\n", DbgPrintDsTime(proposedTime, DsTimeBuffer), randomFactor);
                *secsTillNextIteration -= randomFactor;
            } else {
                DPRINT(1,"Random factor did not help -- leaving alone\n");
            }
        }
        Assert(fIsBetweenTime(&replTimes, now + *secsTillNextIteration, now + *secsTillNextIteration));
    }

    if (!fOn) {

        ULONG nextIter = *secsTillNextIteration / (60 * 60);
        LogEvent(DS_EVENT_CAT_GROUP_CACHING,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_GROUP_CACHING_CANT_FIND_OPEN_SLOT,
                 szInsertWC(siteName),
                 szInsertUL(nextIter),
                 NULL);
    }

    return;
}



VOID
freeAUGMemberships(
    IN THSTATE *pTHS,
    IN AUG_MEMBERSHIPS*p
    )
//
// Frees the embedded members of an AUG_MEMBERSHIPS structure
//
{
    if (p) {
        ULONG i;

        for (i = 0; i < p->MembershipCount; i++) {
            THFreeEx(pTHS, p->Memberships[i]);
        }
        THFreeEx(pTHS, p->Memberships);

        for (i = 0; i < p->SidHistoryCount; i++) {
            THFreeEx(pTHS, p->SidHistory[i]);
        }
        THFreeEx(pTHS, p->SidHistory);

        if (p->Attributes) {
            THFreeEx(pTHS, p->Attributes);
        }
    }
    return;
}


BOOL
isGroupCachingEnabled(
    VOID
    )
/*++

Routine Description:

    This routine returns whether group caching is turned on for the local
    site.

Parameters:

    None.

Return Values:

    TRUE or FALSE

 --*/
{
    BOOL fEnabled = FALSE;
    NTSTATUS st;
    BOOLEAN fMixed;

    st  = SamIMixedDomain2(&gAnchor.pDomainDN->Sid, &fMixed);
    if (!NT_SUCCESS(st)) {
        fMixed = TRUE;
    }
    fEnabled =  (gAnchor.SiteOptions & NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED)
            && !SampAmIGC()
            && !fMixed;

    return fEnabled;
}


DWORD
cleanupOldEntries(
    IN THSTATE *pTHS,
    IN ULONG *DNTList,
    IN ATTRVAL *Values OPTIONAL,
    IN ULONG  DNTCount
    )
/*++

Description:

    This routine takes a list of objects whose no gc logon attributes
    are to be removed.
    
Parameters:

    pTHS -- thread state
    
    DNTList -- the list of objects, by DNT, that should be cleaned up
    
    Values -- the site affinity values, if any, that should be removed
    
    DNTCount -- the number of objects that need cleaning up                      

Return values:

    0
    
--*/
{

    ULONG err;
    ULONG i;
    BOOL fLazyCommit = pTHS->fLazyCommit;

    pTHS->fLazyCommit = TRUE;

    for (i = 0; i < DNTCount; i++) {

        BOOL fCommit = FALSE;

        DBOpen(&pTHS->pDB);
        _try
        {
            DBFindDNT(pTHS->pDB, DNTList[i]);

            if (ARGUMENT_PRESENT(Values)) {
                // remove the site affinity value
                err = DBRemAttVal(pTHS->pDB,
                                  ATT_MS_DS_SITE_AFFINITY,
                                  Values[i].valLen,
                                  Values[i].pVal);
                if (err) {
                    if (DB_ERR_VALUE_DOESNT_EXIST != err) {
                        DPRINT(0,"DBRemAttVal failed unexpectantly.\n");
                        LogUnhandledError(err);
                    }
                    // This is not fatal
                    err = 0;
                }
            }
        
            // remove the cached membership
            err = DBRemAtt(pTHS->pDB,
                           ATT_MS_DS_CACHED_MEMBERSHIP);
            if (err) {
                if (DB_ERR_ATTRIBUTE_DOESNT_EXIST != err) {
                    DPRINT(0,"DBRemAtt failed unexpectantly.\n");
                    LogUnhandledError(err);
                }
                // This is not fatal
                err = 0;
            }
        
            // remove the cached membership time stamp
            err = DBRemAtt(pTHS->pDB,
                           ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP);
        
            if (err) {
                if (DB_ERR_ATTRIBUTE_DOESNT_EXIST != err) {
                    DPRINT(0,"DBRemAtt failed unexpectantly.\n");
                    LogUnhandledError(err);
                }
                // This is not fatal
                err = 0;
            }
        
            if (!err) {
                err  = DBRepl(pTHS->pDB, 
                              FALSE,  // not DRA
                              0,
                              NULL,
                              0 );
                if (err) {
                    DPRINT1(0,"DBRepl failed with 0x%d unexpectantly\n", err);
                }
            }
            fCommit = TRUE;
        }
        _finally
        {

            DBClose(pTHS->pDB, fCommit);
        }
    }

    pTHS->fLazyCommit = fLazyCommit;

    return 0;

}


BOOL 
convertScheduleToReplTimes(
    IN PSCHEDULE schedule,
    OUT REPLTIMES *replTimes
    )
/*++

Description:

    This routine translates a schedule into a REPLTIMEs structure.
    
    This is useful so that repl routines to analyse a schedule can be 
    used.

    This routine was lifted from the routine KCC_CONNECTION::SetSchedule      
    
Parameters:

    schedule -- the scheduled (already filled in)
    
    replTimes -- repltimes to be filled in during this routine

Return values:

    TRUE if translation was successfull (schedule was something we could
    understand)
    
    FALSE otherwise.
       
--*/
{
    ULONG i, j;
    LONG  nInterval;

    if ((1 <= schedule->NumberOfSchedules) && (3 >= schedule->NumberOfSchedules)) {

       // locate the interval schedule in the struct and ignore bandwidth & priority
       nInterval = -1;
       for (j = 0; j < schedule->NumberOfSchedules; j++) {

           if (SCHEDULE_INTERVAL == schedule->Schedules[j].Type) {

               // located the INTERVAL schedule - if there are more than one INTERVAL schedules
               // in the blob, we will use only the first one.
               nInterval = j;
               break;
           }
       }

       if (nInterval >= 0) {

           // sanity check to see if all the interval schedule data is present
           if ((schedule->Schedules[nInterval].Offset + SCHEDULE_DATA_ENTRIES) <= schedule->Size) {

               // Everything in the blob is as expected and we found a valid INTERVAL schedule
               // - convert the 168 byte schedule data to the internal 84 byte format
               PBYTE pbSchedule = ((PBYTE) schedule) + schedule->Schedules[nInterval].Offset;
               for (i = 0, j = 0; j < SCHEDULE_DATA_ENTRIES; ++i, j += 2) {

                   replTimes->rgTimes[i] = (((pbSchedule[j] & 0x0F) << 4) | (pbSchedule[j+1] & 0x0F));
               }

               return TRUE;
           }
       }
    }

    return FALSE;
}


DWORD
findScheduleForSite(
    IN  THSTATE*   pTHS,
    IN  LPWSTR     transportDN,
    IN  LPWSTR     localSiteName,
    IN  LPWSTR     targetSiteName,
    OUT PSCHEDULE *ppSchedule
    )
/*++

Routine Description:

    This routine finds the cheapest schedule connecting localSiteName
    and targetSiteName.  It does this by querying site connections.                  
    
Parameters:


    pTHS -- thread state

    transportDN -- the DN of the transport under which to look for site links
    
    localSiteName -- the site hosted by this DS
    
    targetSiteName -- the destination site that no gc logon wants to talk to
    
    ppSchedule -- the schedule of the cheapest link, if one exists.


Return Values

    0 on success, ERROR_NOT_FOUND if no schedule can be found

 --*/
{
    ULONG err = 0;
    SEARCHRES * pSearchRes;
    FILTER * pf, *topLevelFilter;
    DSNAME * siteDN;
    SEARCHARG searchArg;
    ATTR attr, attrList[2];
    ENTINF *EntInf = NULL;
    ENTINFLIST *EntInfList = NULL;
    ULONG len, size;
    ULONG i, j;
    DSNAME *pdnDsaObjCat;
    DSNAME *pdnLocalSite;
    DSNAME *pdnTargetSite;
    DSNAME *pdnTransport;
    BOOL   fScheduleFound = FALSE;

    ULONG minimumCost;
    PSCHEDULE minimumSchedule;
    DSNAME * minimumName;

    Assert(transportDN);
    Assert(localSiteName);
    Assert(targetSiteName);
    Assert(ppSchedule);
    
    // Init the out parameter
    *ppSchedule = NULL;
    
    //
    // First, create the DSNAME's for the search
    //
    len = wcslen(localSiteName);
    size = DSNameSizeFromLen(len);
    pdnLocalSite = THAllocEx(pTHS, size);
    pdnLocalSite->structLen = size;
    pdnLocalSite->NameLen = len;
    wcscpy(pdnLocalSite->StringName, localSiteName);

    len = wcslen(targetSiteName);
    size = DSNameSizeFromLen(len);
    pdnTargetSite = THAllocEx(pTHS, size);
    pdnTargetSite->structLen = size;
    pdnTargetSite->NameLen = len;
    wcscpy(pdnTargetSite->StringName, targetSiteName);

    len = wcslen(transportDN);
    size = DSNameSizeFromLen(len);
    pdnTransport = THAllocEx(pTHS, size);
    pdnTransport->structLen = size;
    pdnTransport->NameLen = len;
    wcscpy(pdnTransport->StringName, transportDN);
    
    pdnDsaObjCat = DsGetDefaultObjCategory(CLASS_SITE_LINK);
    Assert(pdnDsaObjCat);
    
    if (!pdnDsaObjCat) {
        return ERROR_NOT_FOUND;
    }
    
    //
    // Create the filter: 
    //
    //      siteLink objects
    //  and siteobject attribute contains localSite
    //  and siteobject attribute contains targetSite
    //
    
    // initial choice object
    pf = topLevelFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_AND;
    pf->FilterTypes.And.count = 3;

    // first predicate:  siteList contains localsite
    pf = pf->FilterTypes.And.pFirstFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_SITE_LIST;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnLocalSite->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE)pdnLocalSite;
    
    // second predicate:  siteList contains targetSite
    pf = pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_SITE_LIST;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnTargetSite->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (PBYTE)pdnTargetSite;

    // third predicate:  the right object class
    pf = pf->pNextFilter = THAllocEx(pTHS, sizeof(FILTER));
    pf->choice = FILTER_CHOICE_ITEM;
    pf->FilterTypes.Item.choice =  FI_CHOICE_EQUALITY;
    pf->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    pf->FilterTypes.Item.FilTypes.ava.Value.valLen = pdnDsaObjCat->structLen;
    pf->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR*)pdnDsaObjCat;
    
    
    // 
    // Setup the search arguments
    //
    memset(&searchArg, 0, sizeof(searchArg));
    
    InitCommarg(&searchArg.CommArg);
    
    searchArg.pObject = pdnTransport;
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    searchArg.searchAliases = FALSE;
    searchArg.pFilter = topLevelFilter;
    
    // Ask for the cost and schedule attribute
    searchArg.pSelectionRange = NULL;
    searchArg.pSelection = THAllocEx(pTHS, sizeof(ENTINFSEL));
    searchArg.pSelection->attSel = EN_ATTSET_LIST;
    searchArg.pSelection->infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection->AttrTypBlock.attrCount = 2;
    searchArg.pSelection->AttrTypBlock.pAttr = attrList;
    memset(&attrList, 0, sizeof(attrList));
    attrList[0].attrTyp = ATT_COST;
    attrList[1].attrTyp = ATT_SCHEDULE;
    
    pSearchRes = THAllocEx(pTHS, sizeof(SEARCHRES));

    //
    // Do the search
    //
    
    SearchBody(pTHS,
              &searchArg, 
               pSearchRes,
               0);
    

    THClearErrors();

    //
    // Find the cheapest link in the return set, if any
    //
    minimumCost = 0xFFFFFFFF;
    minimumSchedule = NULL;
    minimumName = NULL;

    if ( pSearchRes