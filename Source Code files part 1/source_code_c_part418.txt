ppInfoCopy->CopyToManagedApplication(&(pAppList->rgApps[dwApp]));
                
                if ( Status != ERROR_SUCCESS )
                    break;

                dwApp++;
            }
        }
    
        _Apps.ResetEnd();

        if ( Status != ERROR_SUCCESS )
        {
            DWORD dwCopiedApp;

            //
            // On failure, we need to clear any apps we allocated
            // before the failure occurred
            //
            for ( dwCopiedApp = 0; dwCopiedApp < dwApp; dwCopiedApp++ )
            {
                ClearManagedApp( & ( pAppList->rgApps[ dwCopiedApp ] ) );
            }

            midl_user_free( pAppList->rgApps );
            pAppList->rgApps = 0;

            pArpContext->Status = Status;

            return Status;
        }

        pAppList->Applications = dwApp;
    }

GetManagedApplications_WriteLogsAndExit:

    //
    // Store the status of this operation in the waiting thread's context --
    // note that this is the last time we can safely access this structure
    // since we will next signal its thread to unblock, and the stack
    // frame in which this structure is allocated will disappear
    //
    if ( ! fPlanningMode )
    {
        pArpContext->Status = Status;

        //
        // Signal the waiting thread that we are finished enumerating
        //
        GetRsopContext()->SetAppsEnumerated();
    }

    //
    // Write any Rsop logs -- this is a no op if
    // rsop logging is not enabled
    //
    WriteRsopLogs();

    return Status;
}

DWORD
CManagedAppProcessor::GetAppsFromLocal()
{
    CAppList        LocalApps( NULL );
    CAppInfo *      pAppInfo;
    CAppInfo *      pAppInfoInsert;
    CAppInfo *      pScriptInfo;
    int             GPOCompare;
    DWORD           Count;
    DWORD           Status;
    HRESULT         hr;
    BOOL            bStatus;

    if ( GetRsopContext()->IsPlanningModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    Status = GetOrderedLocalAppList( LocalApps );

    if ( ERROR_SUCCESS == Status )
        Status = Impersonate();

    if ( Status != ERROR_SUCCESS )
        return Status;

    Count = 0;

    LocalApps.Reset();

    for ( pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem();
          pAppInfo;
          pAppInfo = (CAppInfo *) LocalApps.GetCurrentItem() )
    {
        //
        // Remember which scripts are associated with app entries we find 
        // in the registry.  We'll use this later as a hint to detect roaming 
        // profile merge problems with our app entries in hkcu.
        //
        pScriptInfo = _LocalScripts.Find( pAppInfo->_DeploymentId );
        if ( pScriptInfo )
            pScriptInfo->_State = APPSTATE_SCRIPT_PRESENT;

        if ( _Apps.Find( pAppInfo->_DeploymentId ) != NULL )
        {
            LocalApps.MoveNext();
            continue;
        }

        if ( pAppInfo->_State & APPSTATE_ASSIGNED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALASSIGN_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( pAppInfo->_State & APPSTATE_PUBLISHED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALPUBLISHED_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( pAppInfo->_State & APPSTATE_ORPHANED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALORPHAN_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( pAppInfo->_State & APPSTATE_UNINSTALLED )
        {
            DebugMsg((DM_VERBOSE, IDS_LOCALUNINSTALL_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }

        LocalApps.MoveNext();
        pAppInfo->Remove();
        Count++;

        //
        // If this app is currently applied, check it's real state in the DS.  We
        // didn't get in the query results either because it didn't match the search
        // criteria or because it really did go out of scope.  Currently applied apps include
        // those listed in the registry as published or assigned, as well as those listed
        // in the registry as unmanaged or uninstalled that currently have a script present
        // on this machine.
        // In the case of no-changes, we have to query for published apps which we
        // don't have scripts for so that we can retrieve the proper sysvol path to
        // get the script.
        //
        if ( (! _bNoChanges && (pAppInfo->_State & (APPSTATE_ASSIGNED | APPSTATE_PUBLISHED | APPSTATE_SCRIPT_EXISTED))) ||
             (_bNoChanges && (pAppInfo->_State & APPSTATE_PUBLISHED) && (pAppInfo->_State & APPSTATE_SCRIPT_NOT_EXISTED)) )
        {
            uCLSSPEC        ClassSpec;
            PACKAGEDISPINFO PackageInfo;

            memset( &PackageInfo, 0, sizeof(PackageInfo) );

            ClassSpec.tyspec = TYSPEC_OBJECTID;
            memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, &pAppInfo->_DeploymentId, sizeof(GUID) );
            StringToGuid( pAppInfo->_pwszGPOId, &ClassSpec.tagged_union.ByObjectId.PolicyId );

            DebugMsg((DM_VERBOSE, IDS_CHECK_APP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));

            hr = CsGetAppInfo( &ClassSpec, NULL, &PackageInfo );

            if ( S_OK == hr )
            {
                BOOL bRestored;

                bRestored = pAppInfo->_bRestored;

                DebugMsg((DM_VERBOSE, IDS_CHECK_APP_FOUND, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, PackageInfo.dwActFlags));
                delete pAppInfo;
                pAppInfo = new CAppInfo( this, &PackageInfo, FALSE, bStatus );
                if ( ! bStatus )
                {
                    delete pAppInfo;
                    pAppInfo = 0;
                }
                if ( ! pAppInfo )
                    Status = ERROR_OUTOFMEMORY;
                ReleasePackageInfo( &PackageInfo );

                if ( pAppInfo )
                    pAppInfo->_bRestored = bRestored;
            }
            else if ( CS_E_PACKAGE_NOTFOUND == hr )
            {
                DebugMsg((DM_VERBOSE, IDS_CHECK_APP_NOTFOUND, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
            }
            else
            {
                Status = (DWORD) hr;
            }

            if ( Status != ERROR_SUCCESS )
            {
                DebugMsg((DM_VERBOSE, IDS_CHECK_APP_FAIL, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, Status));
                Revert();
                return Status;
            }
        }

        pAppInfoInsert = 0;

        //
        // Now we insert the locally discovered app into the proper sorted spot in
        // our master list generated from the initial DS query.
        //
        for ( _Apps.Reset(); pAppInfoInsert = (CAppInfo *) _Apps.GetCurrentItem(); _Apps.MoveNext() )
        {
            GPOCompare = _GPOs.Compare( pAppInfoInsert->_pwszGPOId, pAppInfo->_pwszGPOId );

            if ( -1 == GPOCompare )
                continue;

            if ( 1 == GPOCompare )
                break;

            // Smallest USN is oldest.  We sort from oldest to newest.
            if ( CompareFileTime( &pAppInfoInsert->_USN, &pAppInfo->_USN ) >= 0 )
                break;
        }

        // FIFO insert handles both the empty list and end of list conditions.
        if ( ! pAppInfoInsert )
            _Apps.InsertFIFO( pAppInfo );
        else
            pAppInfoInsert->InsertBefore( pAppInfo );
    }

    LocalApps.ResetEnd();

    Revert();

    DebugMsg((DM_VERBOSE, IDS_LOCALAPP_COUNT, Count));
    return ERROR_SUCCESS;
}


BOOL
CManagedAppProcessor::DetectLostApps()
{
    HKEY        hkApp;
    WCHAR       wszDeploymentId[GUIDSTRLEN+1];
    CAppInfo *  pScriptInfo;
    DWORD       Size;
    DWORD       State;
    DWORD       Status;

    if ( GetRsopContext()->IsPlanningModeEnabled() || ! _bUser )
        return FALSE;

    for ( _LocalScripts.Reset(); pScriptInfo = (CAppInfo *) _LocalScripts.GetCurrentItem(); _LocalScripts.MoveNext() )
    {
        GuidToString( pScriptInfo->_DeploymentId, wszDeploymentId);

        Status = RegOpenKeyEx( 
                    _hkAppmgmt, 
                    wszDeploymentId, 
                    0,
                    KEY_READ,
                    &hkApp );

        if ( Status != ERROR_SUCCESS )
        {
            _LocalScripts.ResetEnd();
            DebugMsg((DM_VERBOSE, IDS_DETECTED_LOST_APPS)); 
            return TRUE;
        }
        else
        {
            Size = sizeof(DWORD);
            State = 0;

            Status = RegQueryValueEx( 
                        hkApp, 
                        APPSTATEVALUE,
                        0,
                        NULL,
                        (LPBYTE) &State,
                        &Size );

            RegCloseKey( hkApp );

            //
            // This isn't a lost app, but rather an app which was orphaned or
            // uninstalled on another computer.  We will force a full policy
            // run in this case as well to process the removal.  This is similar
            // to the case where we find the FullPolicy value set.
            //
            if ( ! (State & (APPSTATE_PUBLISHED | APPSTATE_ASSIGNED)) )
                return TRUE;
        }
    }

    _LocalScripts.ResetEnd();

    return FALSE;
}

DWORD
CManagedAppProcessor::GetLostApps()
{
    uCLSSPEC        ClassSpec;
    PACKAGEDISPINFO PackageInfo;
    CAppInfo *      pScriptInfo;
    CAppInfo *      pAppInfo;
    CAppInfo *      pAppInfoInsert;
    GUID            GPOId;
    int             GPOCompare;
    LONG            RedeployCount;
    DWORD           Status;
    HRESULT         hr;
    BOOL            bStatus;
    BOOL            bInsertNew;

    if ( GetRsopContext()->IsPlanningModeEnabled() || ! _bUser )
        return ERROR_SUCCESS;

    // 
    // In this routine we are detecting app entries which are erroneously
    // missing from our hkcu data.  This can occur in various scenarios
    // involving roaming profiles.  An unassociated script file and our 
    // rsop data is used for the detection.
    //
    // Note: 
    // There is quite a bit of duplicated code here and in the above routine
    // ::GetAppsFromLocal.  That is because this change was added late in 
    // WindowsXP and we wanted to isolate it from existing functionality.  
    // In future this could be cleaned up if this codebase is taken forward.
    //

    Status = ERROR_SUCCESS;

    for ( _LocalScripts.Reset(); pScriptInfo = (CAppInfo *) _LocalScripts.GetCurrentItem(); _LocalScripts.MoveNext() )
    {
        if ( pScriptInfo->_State != 0 )
            continue;

        DebugMsg((DM_VERBOSE, IDS_UNMATCHED_SCRIPT));

        pAppInfo = 0;

        hr = FindAppInRSoP( pScriptInfo, &GPOId, &RedeployCount );

        if ( ! SUCCEEDED(hr) )
        {
            if ( WBEM_E_NOT_FOUND == hr )
            {
                DebugMsg((DM_VERBOSE, IDS_SCRIPTNOTINRSOP1));
                DeleteScriptFile( pScriptInfo->_DeploymentId );
                continue;
            }
            else
            {
                Status = (DWORD) hr;
                DebugMsg((DM_VERBOSE, IDS_SCRIPTNOTINRSOP2, hr));
                break;
            }
        }

        DebugMsg((DM_VERBOSE, IDS_SCRIPTINRSOP));
            
        pAppInfo = _Apps.Find( pScriptInfo->_DeploymentId );

        if ( pAppInfo )
        {
            bInsertNew = FALSE;
            DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_INDS2, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
            goto GetLostAppsInsert;
        }

        memset( &PackageInfo, 0, sizeof(PackageInfo) );
        ClassSpec.tyspec = TYSPEC_OBJECTID;
        memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, &pScriptInfo->_DeploymentId, sizeof(GUID) );
        memcpy( &ClassSpec.tagged_union.ByObjectId.PolicyId, &GPOId, sizeof(GUID) );

        Status = Impersonate();
        if ( ERROR_SUCCESS == Status )
        {
            hr = CsGetAppInfo( &ClassSpec, NULL, &PackageInfo );
            Revert();
        }
        else
        {
            hr = HRESULT_FROM_WIN32( Status );
        }

        if ( S_OK == hr )
        {
            bStatus = TRUE;
            pAppInfo = new CAppInfo( this, &PackageInfo, FALSE, bStatus );
            ReleasePackageInfo( &PackageInfo );
            bInsertNew = TRUE;

            if ( ! bStatus )
            {
                delete pAppInfo;
                pAppInfo = 0;
            }
            if ( ! pAppInfo )
                Status = ERROR_OUTOFMEMORY;
            else
                DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_INDS, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName));
        }
        else if ( CS_E_PACKAGE_NOTFOUND == hr )
        {
            DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_NODS));

            //
            // Since the app is not visible to this user, delete the 
            // orphaned script.
            //
            DeleteScriptFile( pScriptInfo->_DeploymentId );
        }
        else
        {
            Status = (DWORD) hr;
        }

        if ( Status != ERROR_SUCCESS )
        {
            DebugMsg((DM_VERBOSE, IDS_SCRIPTAPP_ERRORDS, Status));
            break;
        }

        if ( ! pAppInfo )
            continue;

GetLostAppsInsert:
        //
        // Because we're restoring this app, much of the persisted state is lost.
        // We artifically re-create the key aspects here.
        //
        pAppInfo->_State |= APPSTATE_PUBLISHED | APPSTATE_RESTORED;
        pAppInfo->_AssignCount = 1;
        pAppInfo->_LocalRevision = (DWORD) RedeployCount;
        pAppInfo->_ScriptTime = pScriptInfo->_ScriptTime;

        // Switch to full policy mode whenever we force a lost app back into scope.
        _bNoChanges = FALSE;

        if ( ! bInsertNew )
            continue;

        // 
        // Our newly discovered app now needs to be added to our processing list.
        //
        for ( _Apps.Reset(); pAppInfoInsert = (CAppInfo *) _Apps.GetCurrentItem(); _Apps.MoveNext() )
        {
            GPOCompare = _GPOs.Compare( pAppInfoInsert->_pwszGPOId, pAppInfo->_pwszGPOId );

            if ( -1 == GPOCompare )
                continue;

            if ( 1 == GPOCompare )
                break;

            // Smallest USN is oldest.  We sort from oldest to newest.
            if ( CompareFileTime( &pAppInfoInsert->_USN, &pAppInfo->_USN ) >= 0 )
                break;
        }

        // FIFO insert handles both the empty list and end of list conditions.
        if ( ! pAppInfoInsert )
            _Apps.InsertFIFO( pAppInfo );
        else
            pAppInfoInsert->InsertBefore( pAppInfo );
    }

    _LocalScripts.ResetEnd();

    return Status;
}

HRESULT
CManagedAppProcessor::FindAppInRSoP(
    CAppInfo *  pScriptInfo,
    GUID *      pGPOId,
    LONG *      pRedeployCount
    )
{
    WCHAR       wszGPOId[128];
    WCHAR *     pwszGPOId;
    LONG        ValueLen;
    HRESULT     hr;

    hr = _Apps.InitRsopLog();

    if ( ! SUCCEEDED(hr) )
        return hr;

    pwszGPOId = wszGPOId;
    ValueLen = sizeof(wszGPOId) / sizeof(wszGPOId[0]);

    // 
    // Close your eyes, this is ugly.  The CAppInfo which is only used to track
    // script files only have the _DeploymentId member set.  However, OpenExistingRecord
    // needs a couple of other fields to operate correctly.  We feed those here.
    //
    pScriptInfo->_pManApp = this;
    pScriptInfo->_State = APPSTATE_PUBLISHED;

    CConflict   ScriptRecord( pScriptInfo );
         
    hr = _Apps.OpenExistingRecord( &ScriptRecord );

    if ( SUCCEEDED(hr) )
    {
        hr = ScriptRecord.GetValue( RSOP_ATTRIBUTE_GPOID, pwszGPOId, &ValueLen );
        if ( S_FALSE == hr )
        {
            pwszGPOId = new WCHAR[ValueLen];
            if ( pwszGPOId )
                hr = ScriptRecord.GetValue( RSOP_ATTRIBUTE_GPOID, pwszGPOId, &ValueLen );
            else 
                hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED(hr) )
            hr = ScriptRecord.GetValue( APP_ATTRIBUTE_REDEPLOYCOUNT, pRedeployCount );
    }

    if ( SUCCEEDED(hr) )
    {
        WCHAR * pwszNull;

        // The GPOId comes back from GetValue like CN={gpoguid},CN=Policies,...

        pwszNull = wcschr( pwszGPOId, L'}' );
        if ( pwszNull )
        {
            pwszNull[1] = 0;
            StringToGuid( &pwszGPOId[3], pGPOId );
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    if ( pwszGPOId != wszGPOId )
        delete [] pwszGPOId;

    return hr;
}

void
CManagedAppProcessor::DeleteScriptFile(
    GUID & DeploymentId
    )
{
    DWORD   Length;
    WCHAR * pwszLocalScriptPath;

    Length = lstrlen( LocalScriptDir() );
    
    pwszLocalScriptPath = new WCHAR[Length + GUIDSTRLEN + 5];
    if ( ! pwszLocalScriptPath )
        return;
    
    (void) StringCchCopy( pwszLocalScriptPath, Length+GUIDSTRLEN+5, LocalScriptDir() );
    GuidToString( DeploymentId, &pwszLocalScriptPath[Length]);

    (void) StringCchCopy( &pwszLocalScriptPath[Length+GUIDSTRLEN], 5, L".aas" );
    DeleteFile( pwszLocalScriptPath );

    delete [] pwszLocalScriptPath;
}

HRESULT
CManagedAppProcessor::GetPackageEnumeratorFromPath(
        WCHAR*         wszClassStorePath,
        GUID*          pCategory,
        DWORD          dwAppFlags,
        IEnumPackage** ppIEnumPackage)
{
    HRESULT         hr;
    IClassAccess  * pIClassAccess = NULL;

    //
    // Get an IClassAccess
    //
    hr = GetClassAccessFromPath(
        wszClassStorePath,
        &pIClassAccess);

    if (SUCCEEDED(hr))
    {
        //
        // Get the enumerator
        //
        hr = pIClassAccess->EnumPackages(
            NULL,
            pCategory,
            NULL,
            dwAppFlags,
            ppIEnumPackage
            );

        pIClassAccess->Release();
    }

    return hr;
}

HRESULT
CManagedAppProcessor::GetDsPackageFromGPO(
    CGPOInfo*        pGpoInfo,
    GUID*            pDeploymentId,
    PACKAGEDISPINFO* pPackageInfo)
{
    HRESULT         hr;

    memset( pPackageInfo, 0, sizeof(*pPackageInfo) );

    //
    // Determine the class store path for this gpo
    //
    WCHAR* pwszClassStorePath;

    pwszClassStorePath = NULL;

    //
    // The path returned is allocated by the callee so we must
    // free it later
    //
    hr = CsGetClassStorePath( pGpoInfo->GetGPOPath(), &pwszClassStorePath );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Terminate the class store path list with a delimiter to satisfy
    // class store syntax requirements
    //
    WCHAR* pwszTerminatedClassStorePath;
    ULONG ulSize;

    ulSize = lstrlen( pwszClassStorePath ) + 1 + 1;
    pwszTerminatedClassStorePath = new WCHAR[ ulSize ];

    if ( pwszTerminatedClassStorePath )
    {
        IClassAccess  * pIClassAccess = NULL;
        uCLSSPEC        ClassSpec;

        ClassSpec.tyspec = TYSPEC_OBJECTID;
        memcpy( &ClassSpec.tagged_union.ByObjectId.ObjectId, pDeploymentId, sizeof(GUID) );
        StringToGuid( pGpoInfo->_pwszGPOId, &ClassSpec.tagged_union.ByObjectId.PolicyId );

        //
        // Perform the actual termination
        //

        hr = StringCchCopy( pwszTerminatedClassStorePath, ulSize, pwszClassStorePath );
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat( pwszTerminatedClassStorePath, ulSize, L";" );
        }

        if (SUCCEEDED(hr)) 
        {
            //
            // Get an IClassAccess using this class store path
            //
            hr = GetClassAccessFromPath(
                pwszTerminatedClassStorePath,
                &pIClassAccess);
        }

        if (SUCCEEDED(hr))
        {
            //
            // Perform the search for the requested deployment
            //
            hr = pIClassAccess->GetAppInfo(
                &ClassSpec,
                NULL,
                pPackageInfo);
            
            pIClassAccess->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    if ( pwszClassStorePath )
    {
        LocalFree( pwszClassStorePath );
    }

    delete [] pwszTerminatedClassStorePath;

    return hr;
}


HRESULT
CManagedAppProcessor::GetClassAccessFromPath(
    WCHAR*          wszClassStorePath,
    IClassAccess**  ppIClassAccess)
{
    HRESULT         hr;
    PRSOP_TARGET    pRsopTarget;
    
    *ppIClassAccess = NULL;

    pRsopTarget = GetRsopContext()->_pRsopTarget;

    //
    // Get an IClassAccess
    //
    hr = CsGetClassAccess(ppIClassAccess);

    //
    // Set the IClassAccess to use the class stores
    // corresponding to the class store path passed in
    //
    if (SUCCEEDED(hr))
    {
        hr = (*ppIClassAccess)->SetClassStorePath(
            wszClassStorePath,
            pRsopTarget ? pRsopTarget->pRsopToken : NULL );
    }

    return hr;
}

DWORD
CManagedAppProcessor::CommitPolicyList()
{
    CGPOInfo *  pGPO;
    WCHAR *     pwszGPOList;
    DWORD       Length;
    DWORD       Status;
    HRESULT     hr;

    if ( GetRsopContext()->IsPlanningModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    Length = 1;
    _GPOs.Reset();

    for ( pGPO = (CGPOInfo *) _GPOs.GetCurrentItem();
          pGPO;
          _GPOs.MoveNext(), pGPO = (CGPOInfo *) _GPOs.GetCurrentItem() )
    {
        Length += lstrlen( pGPO->_pwszGPOId ) + 1;
    }

    _GPOs.ResetEnd();

    pwszGPOList = new WCHAR[Length];
    if ( ! pwszGPOList )
        return ERROR_OUTOFMEMORY;
    pwszGPOList[0] = 0;

    _GPOs.Reset();

    for ( pGPO = (CGPOInfo *) _GPOs.GetCurrentItem();
          pGPO;
          _GPOs.MoveNext(), pGPO = (CGPOInfo *) _GPOs.GetCurrentItem() )
    {
        hr = StringCchCat( pwszGPOList, Length, pGPO->_pwszGPOId );
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat( pwszGPOList, Length, L";" );
        }

        if (FAILED(hr)) 
        {
            delete [] pwszGPOList;
            return hr;
        }
    }

    _GPOs.ResetEnd();

    Status = RegSetValueEx(
               _hkAppmgmt,
               POLICYLISTVALUE,
               0,
               REG_SZ,
               (LPBYTE) pwszGPOList,
               Length * sizeof(WCHAR) );

    delete [] pwszGPOList;

    return Status;
}

DWORD
CManagedAppProcessor::LoadPolicyList()
{
    PGROUP_POLICY_OBJECT pGPOList = NULL;
    DWORD                Status;

    Status = Impersonate();

    if ( ERROR_SUCCESS == Status )
    {
        Status = GetCurrentUserGPOList( &pGPOList );

        Revert();
    }

    if (ERROR_SUCCESS == Status)
    {
        Status = SetPolicyListFromGPOList( pGPOList );
    }

    if ( pGPOList )
    {
        FreeGPOList( pGPOList );
    }

    if ( ERROR_SUCCESS == Status )
    {
        MergePolicyList();
    }

    return Status;
}

DWORD
CManagedAppProcessor::SetPolicyListFromGPOList(
    PGROUP_POLICY_OBJECT pGPOList
    )
{
    DWORD       Status;
    WCHAR *     pwszGPOList;
    WCHAR *     pwszGPO;
    WCHAR *     pwszGPOEnd;
    DWORD       Size;

    Status = ERROR_SUCCESS;
    pwszGPOList = 0;
    Size = 0;

    PGROUP_POLICY_OBJECT pCurrentGPO;

    for (pCurrentGPO = pGPOList; NULL != pCurrentGPO; pCurrentGPO = pCurrentGPO->pNext)
    {
        BOOL bStatus;

        DebugMsg((DM_VERBOSE, IDS_GPO_NAME, pCurrentGPO->lpDisplayName, pCurrentGPO->szGPOName));
        DebugMsg((DM_VERBOSE, IDS_GPO_FILESYSPATH, pCurrentGPO->lpFileSysPath));
        DebugMsg((DM_VERBOSE, IDS_GPO_DSPATH, pCurrentGPO->lpDSPath));

        bStatus = AddGPO( pCurrentGPO );

        if ( ! bStatus )
        {
            Status = ERROR_OUTOFMEMORY;
            break;
        }
    }

    return Status;
}

DWORD
CManagedAppProcessor::MergePolicyList()
{
    WCHAR *     pwszGPOList;
    WCHAR *     pwszGPO;
    WCHAR *     pwszGPOEnd;
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    pwszGPOList = 0;
    Size = 0;

    Status = RegQueryValueEx(
                _hkAppmgmt,
                POLICYLISTVALUE,
                0,
                NULL,
                (LPBYTE) NULL,
                &Size );

    if ( ERROR_FILE_NOT_FOUND == Status )
        return ERROR_SUCCESS;

    if ( ERROR_SUCCESS == Status )
    {
        pwszGPOList = new WCHAR[Size/2];
        if ( ! pwszGPOList )
            return ERROR_OUTOFMEMORY;

        Status = RegQueryValueEx(
                    _hkAppmgmt,
                    POLICYLISTVALUE,
                    0,
                    NULL,
                    (LPBYTE) pwszGPOList,
                    &Size );
    }

    if ( ERROR_SUCCESS == Status )
    {
        GROUP_POLICY_OBJECT GPOInfo;

        memset( &GPOInfo, 0, sizeof( GPOInfo ) );

        for ( pwszGPO = pwszGPOList; *pwszGPO; pwszGPO = pwszGPOEnd + 1 )
        {
            pwszGPOEnd = wcschr( pwszGPO, L';' );

            if ( ! pwszGPOEnd )
            {
                Status = ERROR_INVALID_PARAMETER;
                break;
            }

            *pwszGPOEnd = 0;

            if ( ! _GPOs.Find( pwszGPO ) )
            {
                HRESULT hr;

                hr = StringCchCopy( GPOInfo.szGPOName, 
                                    sizeof(GPOInfo.szGPOName)/sizeof(GPOInfo.szGPOName[0]), 
                                    pwszGPO );
                if (FAILED(hr)) 
                {
                    Status = HRESULT_CODE(hr);
                    break;
                }

                GPOInfo.lpDisplayName = L"";
                GPOInfo.lpDSPath = L"";
                GPOInfo.lpLink = L"";

                bStatus = _GPOs.Add( &GPOInfo );

                if ( ! bStatus )
                {
                    Status = ERROR_OUTOFMEMORY;
                    break;
                }
            }
        }
    }

    delete [] pwszGPOList;

    return Status;
}


DWORD
CManagedAppProcessor::CreateAndSecureScriptDir()
{
    SECURITY_DESCRIPTOR SecDesc;
    SECURITY_ATTRIBUTES SecAttr;
    SID_IDENTIFIER_AUTHORITY AuthorityNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY AuthorityEveryone = SECURITY_WORLD_SID_AUTHORITY;
    PSID        pSidUser;
    PSID        pSidEveryone;
    PSID        pSidSystem;
    PSID        pSidAdmin;
    PACL        pAcl;
    ACE_HEADER * pAceHeader;
    PSID        pSid;
    DWORD       AclSize;
    DWORD       AceIndex;
    DWORD       Length;
    DWORD       Attributes;
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    Status = ERROR_SUCCESS;

    //
    // The following check is used to determine if the appmgmt directories
    // for this user/machine exist in the proper win2001 format.  If so we
    // can quickly exit.
    // When the directories exist but without the system bit set, this means
    // we need to migrate to the new win2001 ACL format.
    //
    Attributes = GetFileAttributes( _pwszLocalPath );

    if ( (Attributes != (DWORD) -1) && (Attributes & FILE_ATTRIBUTE_SYSTEM) )
        return ERROR_SUCCESS;

    //
    // If a user object is moved within a domain forest the SID will change.
    // Here we check for that case and rename the previous SID dir to the
    // new SID.  This is only a necessary check if a script dir by the current
    // SID name does not exist.
    //
    if ( ((DWORD) -1 == Attributes) && _bUser )
    {
        WCHAR * pwszPreviousSid = 0;

        Status = GetPreviousSid( _hUserToken, _pwszLocalPath, &pwszPreviousSid );

        if ( (ERROR_SUCCESS == Status) && pwszPreviousSid )
        {
            Status = RenameScriptDir( pwszPreviousSid, _pwszLocalPath );
            delete pwszPreviousSid;
            return Status;
        }

        if ( Status != ERROR_SUCCESS )
            return Status;
    }

    pSidEveryone = 0;
    pSidSystem = 0;
    pSidAdmin = 0;
    pSidUser = 0;
    pAcl = 0;

    if ( _bUser )
    {
        pSidUser = AppmgmtGetUserSid( _hUserToken );
        if ( ! pSidUser )
            return ERROR_OUTOFMEMORY;
    }

    bStatus = AllocateAndInitializeSid( &AuthorityEveryone, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidEveryone );

    if ( bStatus )
        bStatus = AllocateAndInitializeSid( &AuthorityNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem );

    if ( bStatus )
        bStatus = AllocateAndInitializeSid( &AuthorityNT, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSidAdmin );

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SecureScriptDirEnd;
    }

    AclSize = GetLengthSid(pSidSystem) +
              GetLengthSid(pSidAdmin) +
              sizeof(ACL) + (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
    if ( _bUser )
        AclSize += GetLengthSid(pSidUser);
    else
        AclSize += GetLengthSid(pSidEveryone);

    pAcl = (PACL) LocalAlloc( 0, AclSize );

    if ( pAcl )
    {
        bStatus = InitializeAcl( pAcl, AclSize, ACL_REVISION );
        if ( ! bStatus )
            Status = GetLastError();
    }
    else
    {
        Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
        goto SecureScriptDirEnd;

    //
    // Access is as follows :
    //  %systemroot%\system32
    //      appmgmt - LocalSystem (Full), Admin Group (Full), Everyone (Read/Execute, this folder only)
    //      appmgmt\machine - LocalSystem (Full), Admin Group (Full)
    //      appmgmt\<usersid> - LocalSystem (Full), Admin Group (Full), <usersid> (Read/Execute)
    //

    AceIndex = 0;

    bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem);

    if ( bStatus )
    {
        bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
        if ( bStatus )
            pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
    }

    if ( bStatus )
    {
        AceIndex++;
        bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidAdmin);

        if ( bStatus )
        {
            bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
            if ( bStatus )
                pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        }
    }

    if ( bStatus )
    {
        AceIndex++;
        bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE, pSidEveryone);
    }

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SecureScriptDirEnd;
    }

    bStatus = InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION );

    if ( bStatus )
        bStatus = SetSecurityDescriptorDacl( &SecDesc, TRUE, pAcl, FALSE );

    if ( bStatus )
    {
        PWCHAR  pwszSlash1, pwszSlash2;

        //
        // We are always creating dirs of the form "%systemroot%\system32\appmgmt\<sid>\".
        //

        pwszSlash1 = wcsrchr( _pwszLocalPath, L'\\' );
        *pwszSlash1 = 0;
        pwszSlash2 = wcsrchr( _pwszLocalPath, L'\\' );
        *pwszSlash2 = 0;

        SecAttr.nLength = sizeof( SecAttr );
        SecAttr.lpSecurityDescriptor = &SecDesc;
        SecAttr.bInheritHandle = FALSE;

        // This creates the root appmgmt dir.
        bStatus = CreateDirectory( _pwszLocalPath, &SecAttr );

        if ( ! bStatus && (ERROR_ALREADY_EXISTS == GetLastError()) )
        {
            bStatus = SetFileSecurity( _pwszLocalPath, DACL_SECURITY_INFORMATION, &SecDesc );
        }

        *pwszSlash1 = L'\\';
        *pwszSlash2 = L'\\';

        if ( bStatus )
        {
            //
            // We always remove the Everyone ACE, but only in the case of a user
            // (rather then the machine) subdir do we then add in a user specific
            // ACE to replace it below.
            //
            bStatus = DeleteAce( pAcl, AceIndex );

            if ( _bUser )
            {
                if ( bStatus )
                    bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE, pSidUser);

                if ( bStatus )
                {
                    bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
                    if ( bStatus )
                        pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
                }
            }

            // This now creates the user specific subdir.
            if ( bStatus )
                bStatus = CreateDirectory( _pwszLocalPath, &SecAttr );
        }

        if ( ! bStatus && (ERROR_ALREADY_EXISTS == GetLastError()) )
        {
            bStatus = SetFileSecurity( _pwszLocalPath, DACL_SECURITY_INFORMATION, &SecDesc );
            if ( bStatus )
                bStatus = SetFileAttributes( _pwszLocalPath, FILE_ATTRIBUTE_SYSTEM );
        }
    }

    if ( ! bStatus )
        Status = GetLastError();

SecureScriptDirEnd:

    FreeSid( pSidUser );
    FreeSid( pSidEveryone );
    FreeSid( pSidSystem );
    FreeSid( pSidAdmin );
    LocalFree( pAcl );

    return Status;
}

DWORD
CManagedAppProcessor::GetOrderedLocalAppList(
    CAppList & AppList
    )
{
    CAppList        RegAppList( NULL );
    CAppInfo *      pAppInfo;
    WCHAR           wszDeploymentId[44];
    WCHAR *         pwszGPOList;
    WCHAR *         pwszGPO;
    WCHAR *         pwszGPOEnd;
    DWORD           Index;
    DWORD           Size;
    DWORD           Status;
    BOOL            bStatus;

    DebugMsg((DM_VERBOSE, IDS_GET_LOCAL_APPS));

    pwszGPOList = 0;
    Size = 0;

    Status = ERROR_FILE_NOT_FOUND;

    if ( !GetRsopContext()->IsPlanningModeEnabled() )
    {
        Status = RegQueryValueEx(
            _hkAppmgmt,
            POLICYLISTVALUE,
            0,
            NULL,
            (LPBYTE) NULL,
            &Size );

    }

    if ( ERROR_SUCCESS == Status )
    {
        pwszGPOList = new WCHAR[Size/2];
        if ( ! pwszGPOList )
        {
            Status = ERROR_OUTOFMEMORY;
            goto GetOrderedLocalAppListEnd;
        }

        Status = RegQueryValueEx(
                    _hkAppmgmt,
                    POLICYLISTVALUE,
                    0,
                    NULL,
                    (LPBYTE) pwszGPOList,
                    &Size );
    }
    else
    {
        //
        // The policylist named value will not exist the first time policy
        // runs.  Therefor there will be no apps already on the machine if
        // this value is not present.
        //
        // Note however, that because this is a new value for NT5 beta3,
        // beta2+ clients may have apps, but won't have this value.  For
        // those machines, this new value will be written during the first
        // full policy run.  That will not pose any problems.
        //
        return ERROR_SUCCESS;
    }

    if ( Status != ERROR_SUCCESS )
        goto GetOrderedLocalAppListEnd;

    Index = 0;

    for (;;)
    {
        Status = RegEnumKey(
                    _hkAppmgmt,
                    Index++,
                    wszDeploymentId,
                    sizeof(wszDeploymentId) / sizeof(WCHAR) );

        if ( ERROR_NO_MORE_ITEMS == Status )
        {
            Index--;
            Status = ERROR_SUCCESS;
            break;
        }

        if ( Status != ERROR_SUCCESS )
            break;

        pAppInfo = new CAppInfo( this, wszDeploymentId, bStatus );

        if ( ! pAppInfo || ! bStatus )
            Status = ERROR_OUTOFMEMORY;

        if ( Status != ERROR_SUCCESS )
        {
            if ( pAppInfo )
                delete pAppInfo;
            break;
        }

        RegAppList.InsertFIFO( pAppInfo );
    }

    if ( Status != ERROR_SUCCESS )
        goto GetOrderedLocalAppListEnd;

    if ( 0 == Index )
    {
        DebugMsg((DM_VERBOSE, IDS_NO_LOCAL_APPS));
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_LOCAL_APP_COUNT, Index));
    }

    //
    // We first gather all apps for policies we know about and order them
    // according to the policy precedences.
    //
    for ( pwszGPO = pwszGPOList; *pwszGPO; pwszGPO = pwszGPOEnd + 1 )
    {
        pwszGPOEnd = wcschr( pwszGPO, L';' );
        *pwszGPOEnd = 0;

        RegAppList.Reset();

        for ( pAppInfo = (CAppInfo *) RegAppList.GetCurrentItem();
              pAppInfo;
              pAppInfo = (CAppInfo *) RegAppList.GetCurrentItem() )
        {
            if ( lstrcmpi( pAppInfo->_pwszGPOId, pwszGPO ) != 0 )
            {
                RegAppList.MoveNext();
                continue;
            }

            DebugMsg((DM_VERBOSE, IDS_LOCAL_APP_DUMP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, pAppInfo->_State, pAppInfo->_AssignCount));

            RegAppList.MoveNext();
            pAppInfo->Remove();
            AppList.InsertFIFO( pAppInfo );
        }

        RegAppList.ResetEnd();
    }

    //
    // In some instances we will still have apps in the registry that are not in the
    // current list of policies.  We add them to the front of the final list.
    //
    for ( RegAppList.Reset(); pAppInfo = (CAppInfo *) RegAppList.GetCurrentItem(); )
    {
        DebugMsg((DM_VERBOSE, IDS_LOCAL_APP_DUMP, pAppInfo->_pwszDeploymentName, pAppInfo->_pwszGPOName, pAppInfo->_State, pAppInfo->_AssignCount));

        RegAppList.MoveNext();
        pAppInfo->Remove();
        AppList.InsertLIFO( pAppInfo );
    }

    RegAppList.ResetEnd();

GetOrderedLocalAppListEnd:

    delete [] pwszGPOList;

    if ( Status != ERROR_SUCCESS )
        DebugMsg((DM_WARNING, IDS_GETLOCALAPPS_FAIL, Status));

    return Status;
}

DWORD
CManagedAppProcessor::GetLocalScriptAppList(
    CAppList & AppList
    )
{
    WIN32_FIND_DATA FindData;
    CAppInfo *  pAppInfo;
    WCHAR *     pwszPath;
    HANDLE      hFind;
    DWORD       Status;
    HRESULT     hr;
    ULONG       ulSize;

    ulSize = lstrlen(_pwszLocalPath) + 7;
    pwszPath = new WCHAR[ulSize];
    if ( ! pwszPath )
        return ERROR_OUTOFMEMORY;

    hr = StringCchCopy( pwszPath, ulSize, _pwszLocalPath );
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat( pwszPath, ulSize, L"\\*.aas" );
    }

    if (FAILED(hr)) 
    {
        delete [] pwszPath;
        return HRESULT_CODE(hr);
    }

    hFind = FindFirstFile( pwszPath, &FindData );

    delete [] pwszPath;

    if ( INVALID_HANDLE_VALUE == hFind )
        return ERROR_SUCCESS;

    do
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            continue;

        pwszPath = wcschr( FindData.cFileName, L'.' );
        if ( ! pwszPath )
            continue;
        *pwszPath = 0;

        pAppInfo = new CAppInfo( FindData.cFileName );
        if ( ! pAppInfo )
            return ERROR_OUTOFMEMORY;
        pAppInfo->_ScriptTime = FindData.ftLastWriteTime;

        AppList.InsertFIFO( pAppInfo );
    } while ( FindNextFile( hFind, &FindData ) );

    FindClose( hFind );
    return ERROR_SUCCESS;
}

DWORD
GetScriptDirPath(
    HANDLE      hToken,
    DWORD       ExtraPathChars,    
    WCHAR **    ppwszPath,
    DWORD       *pdwAllocatedLength
    )
{
    WCHAR           wszPath[MAX_PATH];
    WCHAR *         pwszSystemDir;
    DWORD           AllocLength;
    DWORD           Length;
    DWORD           Status;
    UNICODE_STRING  SidString;

    Status = ERROR_SUCCESS;
    *ppwszPath = 0;
    if (NULL != pdwAllocatedLength) 
    {
        *pdwAllocatedLength = 0;
    }

    pwszSystemDir = wszPath;
    AllocLength = sizeof(wszPath) / sizeof(WCHAR);

    RtlInitUnicodeString( &SidString, NULL );

    for (;;)
    {
        Length = GetSystemDirectory(
                    pwszSystemDir,
                    AllocLength );

        if ( 0 == Length )
            return GetLastError();

        if ( Length >= AllocLength )
        {
            AllocLength = Length + 1;
            pwszSystemDir = (WCHAR *) LocalAlloc( 0, AllocLength * sizeof(WCHAR) );
            if ( ! pwszSystemDir )
                return ERROR_OUTOFMEMORY;
            continue;
        }

        break;
    }

    if ( hToken )
    {
        Status = GetSidString( hToken, &SidString );
    }
    else
    {
        RtlInitUnicodeString( &SidString, L"MACHINE" );
    }

    if ( ERROR_SUCCESS == Status )
    {
        HRESULT   hr;
        ULONG     ulSize;

        // System dir + \appmgmt\ + Sid + \ + null

        ulSize = Length + 11 + (SidString.Length / 2) + ExtraPathChars;
        *ppwszPath = new WCHAR[ulSize];

        if ( *ppwszPath )
        {
            hr = StringCchCopy( *ppwszPath, ulSize, pwszSystemDir );
            if (SUCCEEDED(hr)) 
            {
                if ( pwszSystemDir[lstrlen(pwszSystemDir)-1] != L'\\' )
                {
                    hr = StringCchCat( *ppwszPath, ulSize, L"\\" );
                }
                if (SUCCEEDED(hr)) 
                {
                    hr = StringCchCat( *ppwszPath, ulSize, L"appmgmt\\" );
                    if (SUCCEEDED(hr)) 
                    {              
                        hr = StringCchCat( *ppwszPath, ulSize, SidString.Buffer );
                        if (SUCCEEDED(hr)) 
                        {
                            hr = StringCchCat( *ppwszPath, ulSize, L"\\" );
                        }
                    }
                }
            }

            if (SUCCEEDED(hr)) 
            {
                if (NULL != pdwAllocatedLength) 
                {
                    *pdwAllocatedLength = ulSize;
                }
            }
            else
            {
                delete [] *ppwszPath;
                *ppwszPath = NULL;
                Status = HRESULT_CODE(hr);
            }
        }
        else
        {
            Status = ERROR_OUTOFMEMORY;
        }
    }

    if ( hToken )
        RtlFreeUnicodeString( &SidString );

    if ( pwszSystemDir != wszPath )
        LocalFree( pwszSystemDir );

    return Status;
}

void
CManagedAppProcessor::LogonMsg(
    DWORD   MsgId,
    ...
    )
{
    WCHAR   wszMsg[80];
    WCHAR   wszBuffer[256];
    va_list VAList;
    int     Status;

    if ( ! _pfnStatusCallback || ! LoadLoadString() )
        return;

    Status = (*pfnLoadStringW)( ghDllInstance, MsgId, wszMsg, sizeof(wszMsg) / sizeof(WCHAR) );

    if ( 0 == Status )
        return;

    va_start( VAList, MsgId );

    (void) StringCchVPrintf( wszBuffer, sizeof(wszBuffer)/sizeof(wszBuffer[0]), wszMsg, VAList);
    va_end( VAList );

    _pfnStatusCallback( FALSE, wszBuffer );
}

//
// CGPOInfoList
//

CGPOInfoList::~CGPOInfoList()
{
    CGPOInfo * pGPO;

    Reset();

    while ( pGPO = (CGPOInfo *) GetCurrentItem() )
    {
        MoveNext();

        pGPO->Remove();
        delete pGPO;
    }

    ResetEnd();
}

BOOL
CGPOInfoList::Add(
    PGROUP_POLICY_OBJECT pGPOInfo
    )
{
    CGPOInfo *  pGPO;
    BOOL        bStatus = FALSE;

    pGPO = new CGPOInfo( pGPOInfo, bStatus );

    if ( ! bStatus )
    {
        if ( pGPO )
            delete pGPO;
        pGPO = 0;
    }

    if ( ! pGPO )
        return FALSE;

    InsertFIFO( pGPO );

    return TRUE;
}


CGPOInfo *
CGPOInfoList::Find(
    WCHAR * pwszGPOId
    )
{
    CGPOInfo *  pGPO;

    pGPO = NULL;

    for ( Reset(); pGPO = (CGPOInfo *) GetCurrentItem(); MoveNext() )
    {
        if ( lstrcmpi( pwszGPOId, pGPO->_pwszGPOId ) == 0 )
            break;
    }

    ResetEnd();

    return pGPO;
}

int
CGPOInfoList::Compare(
    WCHAR * pwszGPOId1,
    WCHAR * pwszGPOId2
    )
{
    CGPOInfo *  pGPO;
    int         Index;
    int         Index1;
    int         Index2;

    Index1 = Index2 = -1;

    Reset();

    Index = 0;

    while ( pGPO = (CGPOInfo *) GetCurrentItem() )
    {
        if ( lstrcmpi( pGPO->_pwszGPOId, pwszGPOId1 ) == 0 )
            Index1 = Index;

        if ( lstrcmpi( pGPO->_pwszGPOId, pwszGPOId2 ) == 0 )
            Index2 = Index;

        MoveNext();
        Index++;
    }

    ResetEnd();

    if ( Index1 == Index2 )
        return 0;

    if ( Index1 < Index2 )
        return -1;
    else
        return 1;
}

//
// CGPOInfo
//

CGPOInfo::CGPOInfo(
    PGROUP_POLICY_OBJECT pGPOInfo,
    BOOL &      bStatus
    )
{
    bStatus = TRUE;

    _pwszGPOId = StringDuplicate( (PWCHAR) pGPOInfo->szGPOName );
    _pwszGPOName = StringDuplicate( (PWCHAR) pGPOInfo->lpDisplayName );
    _pwszGPOPath = StringDuplicate( (PWCHAR) pGPOInfo->lpDSPath );

    if ( pGPOInfo->lpLink )
    {
        _pwszSOMPath = StringDuplicate( StripLinkPrefix(pGPOInfo->lpLink) );
    }
    else
    {
        _pwszSOMPath = NULL;
    }

    if ( ! _pwszGPOId || ! _pwszGPOName || ! _pwszGPOPath || ! _pwszSOMPath )
        bStatus = FALSE;
}

CGPOInfo::~CGPOInfo()
{
    delete [] _pwszGPOId;
    delete [] _pwszGPOName;
    delete [] _pwszGPOPath;
    delete [] _pwszSOMPath;
}


CRsopAppContext::CRsopAppContext(
    DWORD   dwContext,
    HANDLE  hEventAppsEnumerated, // = NULL
    APPKEY* pAppType) :           // = NULL
    CRsopContext( APPMGMTEXTENSIONGUID ),
    _dwContext( dwContext ),
    _wszDemandSpec( NULL ),
    _bTransition( FALSE ),
    _dwInstallType( DEMAND_INSTALL_NONE ),
    _bRemovalPurge( FALSE ),
    _bRemoveGPOApps( FALSE ),
    _bForcedRefresh( FALSE ),
    _dwCurrentRsopVersion( 0 ),
    _hEventAppsEnumerated( hEventAppsEnumerated ),
    _StatusAbort( ERROR_SUCCESS )
{
    WCHAR  wszClsid[ MAX_SZGUID_LEN ];
    WCHAR* wszDemandSpec;

    if ( pAppType )
    {
        switch (pAppType->Type)
        {
        case FILEEXT :
            _dwInstallType = DEMAND_INSTALL_FILEEXT;
            wszDemandSpec = pAppType->uType.FileExt;
            break;

        case PROGID :
            _dwInstallType = DEMAND_INSTALL_PROGID;
            wszDemandSpec = pAppType->uType.ProgId;
            break;

        case COMCLASS :
            _dwInstallType = DEMAND_INSTALL_CLSID;
            GuidToString( pAppType->uType.COMClass.Clsid, wszClsid);
            wszDemandSpec = wszClsid;
            break;

        case APPNAME :
            _dwInstallType = DEMAND_INSTALL_NAME;
            wszDemandSpec = NULL;
            break;
        
        default:
            wszDemandSpec = NULL;
        }
        
        _wszDemandSpec = StringDuplicate( wszDemandSpec );
    }
}

CRsopAppContext::~CRsopAppContext()
{
    //
    // If policy was aborted before we attempted to apply it,
    // we will have logged only the applications that caused us to
    // abort.  So in this case, the rsop data is incomplete
    //
    if ( ERROR_SUCCESS != _StatusAbort )
    {
        HRESULT hr;

        hr = HRESULT_FROM_WIN32( _StatusAbort );

        //
        // The rsop data is incomplete, so disable rsop with the
        // error code below so that the administrator will know 
        // that the data are not complete.
        //
        (void) DisableRsop( hr );
    }
}


void
CRsopAppContext::InitializeRsopContext( 
    HANDLE hUserToken,
    HKEY   hkUser,
    BOOL   bForcedRefresh,
    BOOL*  pbNoChanges)
{
    //
    // In planning mode, all initialization is
    // already done, there is nothing to do here
    //
    if ( IsPlanningModeEnabled() )
    {
        return;
    }

    //
    // To get an rsop namespace, we need to know the user's sid
    //
    PSID pSid;
    BOOL bProfileConsistent;

    pSid = NULL;
    bProfileConsistent = TRUE;

    //
    // The token will only be non-NULL if we are in user policy
    //
    if ( hUserToken )
    {
        pSid = AppmgmtGetUserSid( hUserToken );

        if ( ! pSid )
        {
            (void) DisableRsop( ERROR_OUTOFMEMORY );
            
            return;
        }
    }

    //
    // Perform the base context initialization -- pSid will be NULL
    // here if we are in machine policy, which is ok.
    //
    (void) InitializeContext( pSid );

    if ( pSid )
    {
        (void) FreeSid( pSid );

        DWORD dwMachineVersion;
        DWORD dwUserVersion;
        DWORD dwSize;

        dwMachineVersion = 0;
        dwUserVersion = 0;

        dwSize = sizeof( dwMachineVersion );
    
        //
        // Read machine version
        //
        (void) RegQueryValueEx(
            GetNameSpaceKey(),
            RSOPVERSION,
            NULL,
            NULL,
            (LPBYTE) &dwMachineVersion,
            &dwSize);
        
        dwSize = sizeof( dwUserVersion );

        //
        // Read user version
        //
        (void) RegQueryValueEx(
            hkUser,
            RSOPVERSION,
            NULL,
            NULL,
            (LPBYTE) &dwUserVersion,
            &dwSize);

        //
        // Always sync the current version for this machine to the profile's version
        //
        _dwCurrentRsopVersion = dwUserVersion;
            
        bProfileConsistent = dwUserVersion == dwMachineVersion;
   }

    //
    // In the policy refresh case, we are done initializing if
    // a forced refresh isn't demanded
    //
    if ( ( CRsopAppContext::POLICY_REFRESH == GetContext() ) && ! bForcedRefresh )
    {
        //
        // Force a refresh if the profile is not consitent with the machine's rsop
        //
        if ( *pbNoChanges && ! bProfileConsistent )
        {
            bForcedRefresh = TRUE;
            *pbNoChanges = FALSE;

            DebugMsg((DM_VERBOSE, IDS_CHANGES_RSOP_CHANGE));
        }
        else
        {
            return;
        }
    }

    _bForcedRefresh = bForcedRefresh;

    //
    // In this case, the gp engine did not pass in a 
    // namespace for logging, either because we are executing outside of
    // policy refresh context or because there were no changes and
    // we decided to reapply policy regardless.  Since the gp engine did
    // not give us a namespace, we must initialize from a saved namespace
    //
    (void) InitializeSavedNameSpace();
}

HRESULT
CRsopAppContext::MoveAppContextState( CRsopAppContext* pRsopContext )
{
    HRESULT hr;

    hr = S_OK;

    if ( pRsopContext->_wszDemandSpec )
    {
        _wszDemandSpec = StringDuplicate( pRsopContext->_wszDemandSpec );

        if ( ! _wszDemandSpec )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = MoveContextState( pRsopContext );
    }

    _dwContext = pRsopContext->_dwContext;
    _dwInstallType = pRsopContext->_dwInstallType;
    _bTransition = pRsopContext->_bTransition;
    _bRemovalPurge = pRsopContext->_bRemovalPurge;
    _bRemoveGPOApps = pRsopContext->_bRemoveGPOApps;
    _bForcedRefresh = pRsopContext->_bForcedRefresh;
    _dwCurrentRsopVersion = pRsopContext->_dwCurrentRsopVersion;
    _hEventAppsEnumerated = pRsopContext->_hEventAppsEnumerated;
    _StatusAbort = pRsopContext->_StatusAbort;

    return hr;
}


HRESULT
CRsopAppContext::SetARPContext()
{
    if ( ! IsPlanningModeEnabled() )
    {
        return E_INVALIDARG;
    }

    _dwContext = ARPLIST;

    return S_OK;
}

DWORD
CRsopAppContext::WriteCurrentRsopVersion( HKEY hkUser )
{
    if ( ! IsRsopEnabled() || IsPlanningModeEnabled() )
    {
        return ERROR_SUCCESS;
    }

    DWORD dwCurrentVersion;
    LONG  Status;

    dwCurrentVersion = _dwCurrentRsopVersion + 1;

    //
    // Write the machine version
    //
    Status = RegSetValueEx(
        GetNameSpaceKey(),
        RSOPVERSION,
        0,
        REG_DWORD,
        (LPBYTE) &dwCurrentVersion,
        sizeof( DWORD ) );

    LONG  StatusUser;
        
    //
    // Read user version
    //
    StatusUser = RegSetValueEx(
        hkUser,
        RSOPVERSION,
        0,
        REG_DWORD,
        (LPBYTE) &dwCurrentVersion,
        sizeof( DWORD ) );

    if ( ERROR_SUCCESS == Status )
    {
        Status = StatusUser;
    }

    return Status;
}

void
CRsopAppContext::SetPolicyAborted( DWORD Status )
{
    if ( ERROR_SUCCESS == _StatusAbort )
    {
        _StatusAbort = Status;
    }
}

BOOL
CRsopAppContext::HasPolicyAborted()
{
    return ERROR_SUCCESS != _StatusAbort;
}

void
CRsopAppContext::SetAppsEnumerated()
{
    if ( _hEventAppsEnumerated )
    {
        (void) SetEvent( _hEventAppsEnumerated );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\common\rsop\polbase.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  polbase.cxx
//
//*************************************************************

#include "rsop.hxx"
#include <strsafe.h>

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::CPolicyDatabase
//
// Purpose: Constructor for CPolicyDatabase
//
// Params: 
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
CPolicyDatabase::CPolicyDatabase() :
    _hrInit(E_OUTOFMEMORY),
    _pOle32Api( NULL )
{}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::~CPolicyDatabase
//
// Purpose: destructor for CPolicyDatabase -- uninitializes
//     COM
//
// Params: 
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
CPolicyDatabase::~CPolicyDatabase()
{
    //
    // Clean up COM state
    //
    if ( SUCCEEDED(_hrInit) )
    {
        _pOle32Api->pfnCoUnInitialize();
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::InitializeCOM
//
// Purpose: Initializes the calling thread for COM, loading
//          necessary dll's and function entry points
//
// Params: none
//
//
// Return value: S_OK if successful, other facility error if
//         the function fails.
//
// Notes:  State initialized by this call is cleaned up by
//         the destructor
//
//------------------------------------------------------------
HRESULT CPolicyDatabase::InitializeCOM()
{
    //
    // Need to dynamically load the the COM api's since
    // the policy database is accessed through COM.
    //
    _pOle32Api = LoadOle32Api();
    
    if ( _pOle32Api ) 
    {
        //
        // If we successfully loaded COM, initialize it
        //
        _hrInit = _pOle32Api->pfnCoInitializeEx( NULL, COINIT_MULTITHREADED );
    }
    else
    {
        _hrInit = HRESULT_FROM_WIN32(GetLastError());   
    }

    return _hrInit;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyDatabase::Bind
//
// Purpose: Bind to a policy database and return an interface
//          for the user or machine namespace
//
// Params:
//
//
// Return value: S_OK if successful, other facility error if
//         the function fails.
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyDatabase::Bind(
    WCHAR*          wszRequestedNameSpace,
    IWbemServices** ppWbemServices)
{
    HRESULT       hr;

    hr = InitializeCOM();

    if ( FAILED(hr) )
    {
        return hr;
    }

    XInterface<IWbemLocator> xLocator; // Interface used to locate classes

    //
    // To bind, we use COM to request the COM interface to
    // the database
    //
    hr = _pOle32Api->pfnCoCreateInstance( CLSID_WbemLocator,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IWbemLocator,
                                          (LPVOID *) &xLocator );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Refer to the namespace with an automation type so that
    // we can make use of the locator interface, which takes bstr's.
    //
    XBStr xNameSpace( wszRequestedNameSpace );

    //
    // Verify the initialization of the bstr
    //
    if ( !xNameSpace )
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Now connect to the namespace requested by the caller
        //
        hr = xLocator->ConnectServer( xNameSpace,
                                       NULL,
                                       NULL,
                                       0L,
                                       0L,
                                       NULL,
                                       NULL,
                                       ppWbemServices );
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetUnknown
//
// Purpose: retrieves an IUnknown for this policy record --
//    useful if this policy record itself needs to be nested
//    inside another record and we want to use VT_UNKNOWN to
//    do this.
//
// Params: ppUnk -- out param for IUnknown
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::GetUnknown(IUnknown** ppUnk)
{
    HRESULT hr;

    hr = GetRecordInterface()->QueryInterface(
        IID_IUnknown,
        (LPVOID*) ppUnk);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::InitRecord
//
// Purpose: Initializes a policy record with the database's
//     record interface, thereby connecting this record object
//     with the database record abstraction.
//
// Params: pRecordInterface -- the database's record interface
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
void CPolicyRecord::InitRecord(IWbemClassObject* pRecordInterface)
{
    _xRecordInterface = pRecordInterface;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         wszValue -- unicode value to which to set it
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR* wszValueName,
    WCHAR* wszValue)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! wszValue )
    {
        return S_OK;
    }

    //
    // Set up a variant for the value itself
    //
    hr = varValue.SetStringValue(wszValue);    

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         lzValue -- long value to which to set it
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR* wszValueName,
    LONG   Value)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Set up a variant for the value itself
    //
    varValue.SetLongValue(Value);    

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         bValue -- boolean value to which to set it
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR* wszValueName,
    BOOL   bValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Set up a variant for the value itself
    //
    varValue.SetBoolValue(bValue);    

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a specific value (column) of a database
//     record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         pTime -- time to which to set the value
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*      wszValueName,
    SYSTEMTIME* pTimeValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Set up a variant for the value itself
    //
    XBStr xTimeString;

    hr = SystemTimeToWbemTime( *pTimeValue, xTimeString );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = varValue.SetStringValue( xTimeString );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Now that we have the data, call the method
    // to set it
    //
    return _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Adds an element to an array value (column)
//     of a database record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         rgwszValues -- string array to which to set this value
//         cMaxElements -- number of elements in the array
//
// Return value: S_OK if successful, S_FALSE if successful
//         and the array is now full, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*  wszValueName,
    WCHAR** rgwszValues,
    DWORD   cMaxElements)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! cMaxElements )
    {
        return S_OK;
    }

    DWORD iElement;

    for (iElement = 0; iElement < cMaxElements; iElement++)
    {
        //
        // Now set up a variant for the value itself
        //
        hr = varValue.SetNextStringArrayElement(
            rgwszValues[iElement],
            cMaxElements);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We will only write this once we have all the data --
    // The set function above will return S_FALSE if the
    // array is full, so we check for that below
    //
    ASSERT( (S_FALSE == hr) || ! cMaxElements );

    //
    // Now that we have all the data, call the method
    // to set it
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Adds an element to an array value (column)
//     of a database record (row) with a specific value
//
// Params: wszValueName -- name of value (column) to set
//         rgValues -- LONG array to which to set this value
//         cMaxElements -- number of in the array 
//
// Return value: S_OK if successful, S_FALSE if successful
//         and the array is now full, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*  wszValueName,
    LONG*   rgValues,
    DWORD   cMaxElements)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! cMaxElements )
    {
        return S_OK;
    }

    DWORD iElement;

    for (iElement = 0; iElement < cMaxElements; iElement++)
    {
        //
        // Now set up a variant for the value itself
        //
        hr = varValue.SetNextLongArrayElement(
            rgValues[iElement],
            cMaxElements);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We will only write this once we have all the data --
    // The set function above will return S_FALSE if the
    // array is full, so we check for that below
    //
    ASSERT( (S_FALSE == hr) || ! cMaxElements );

    //
    // Now that we have all the data, call the method
    // to set it
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::SetValue
//
// Purpose: Sets a record's value to that of the specified byte array
//
// Params: wszValueName -- name of value (column) to set
//         rgValues  -- byte array to which to set this value
//         cMaxElements -- number of elements in the array
//
// Return value: S_OK if successful, S_FALSE if successful
//         and the array is now full, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::SetValue(
    WCHAR*  wszValueName,
    BYTE*   rgValues,
    DWORD   cMaxElements)
{
    CVariant varValue;
    HRESULT  hr;

    if ( ! cMaxElements )
    {
        return S_OK;
    }

    DWORD iElement;

    for (iElement = 0; iElement < cMaxElements; iElement++)
    {
        //
        // Now set up a variant for the value itself
        //
        hr = varValue.SetNextByteArrayElement(
            rgValues[iElement],
            cMaxElements);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // We will only write this once we have all the data --
    // The set function above will return S_FALSE if the
    // array is full, so we check for that below
    //
    ASSERT( (S_FALSE == hr) || ! cMaxElements );

    //
    // Now that we have all the data, call the method
    // to set it
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearValue
//
// Purpose: Sets a value to VT_NULL
//
// Params: wszValueName -- name of value (column) to set
//
// Return value: S_OK if successful, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::ClearValue(
        WCHAR*  wszValueName)
{
    CVariant varValue;
    HRESULT  hr;

    ( (VARIANT*) varValue )->vt = VT_NULL;

    //
    // Set this to an empty value by passing it an
    // empty variant
    //
    hr = _xRecordInterface->Put(
        wszValueName,
        0L,
        varValue,
        0);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetValue
//
// Purpose: Reads the named column of the record into a LONG
//
// Params: wszValueName -- name of value (column) to get
//         pValue -- pointer to LONG for contents of column
//
// Return value: S_OK if successful, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::GetValue(
    WCHAR*        wszValueName,
    LONG*         pValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Now that we have the value name, call the method
    // to set it
    //
    hr = _xRecordInterface->Get(
        wszValueName,
        0L,
        (VARIANT*) &varValue,
        NULL,
        NULL);

    if ( SUCCEEDED(hr) )
    {
        if ( varValue.IsLongValue() )
        {
            *pValue = ((VARIANT*)varValue)->lVal;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetValue
//
// Purpose: Reads the named column of the record into a WCHAR*
//
// Params: wszValueName -- name of value (column) to get
//         pwszValue -- pointer to caller allocated buffer for
//         data
//         pcchValue -- on success, the length of the string in chars
//         written to pwszValue.  If the function returns
//         S_FALSE, this is the length in chars required to
//         write the string including the zero terminator
//
// Return value: S_OK if successful, S_FALSE if insufficient
//         buffer, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyRecord::GetValue(
    WCHAR*        wszValueName,
    WCHAR*        wszValue,
    LONG*         pcchValue)
{
    CVariant varValue;
    HRESULT  hr;

    //
    // Now that we have the value name, call the method
    // to set it
    //
    hr = _xRecordInterface->Get(
        wszValueName,
        0L,
        (VARIANT*) &varValue,
        NULL,
        NULL);

    if ( SUCCEEDED(hr) )
    {
        if ( varValue.IsStringValue() )
        {
            LONG Required;
        
            Required = ( SysStringLen( ((VARIANT*)varValue)->bstrVal ) + 1 );

            if ( Required <= *pcchValue )
            {
                hr = StringCchCopy( wszValue, *pcchValue, ((VARIANT*)varValue)->bstrVal );
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                *pcchValue = Required;
                hr = S_FALSE;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetRecordInterface
//
// Purpose: private method to allow the log class to
//     manipulate this record object through the
//     record object's encapsulated database record
//     interface.
//
// Params:
//
// Return value: a database record interface
//
// Notes:  Should never fail unless called in 
//     inappropriate circumstances (e.g. unit'ed object)
//
//------------------------------------------------------------
IWbemClassObject* CPolicyRecord::GetRecordInterface()
{
    return _xRecordInterface;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecordStatus::CPolicyRecordStatus
//
// Purpose: constructore for CPolicyRecordStatus
//
//------------------------------------------------------------
CPolicyRecordStatus::CPolicyRecordStatus() :
    _SettingStatus( RSOPIgnored )
{}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecordStatus::SetRsopFailureStatus
//
// Purpose: set a record's failure status data
//
// Params: dwStatus -- os error code for the setting represented by this record
//         dwEventId -- event log id for the attempt to apply this setting
//
// Return value: none
//
// Notes:  Does not fail -- should only be called in diagnostic (logging) mode
//
//------------------------------------------------------------
void CPolicyRecordStatus::SetRsopFailureStatus(
    DWORD     dwStatus,
    DWORD     dwEventId)
{
    SETTINGSTATUS       SettingStatus;

    //
    // Setting status is based on the error code
    //
    SettingStatus = ( ERROR_SUCCESS != dwStatus ) ? RSOPFailed : RSOPApplied;

    //
    // Get the current time -- this does not fail
    //
    GetSystemTime( &_StatusTime );

    //
    // Now set the record's failure status data
    //
    _SettingStatus = SettingStatus;
    _dwEventId = dwEventId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\common\rsop\util.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  util.cxx
//
//  Contains definitions for utility functions related to
//  rsop for use by client side extensions
//
//  Created: 10-11-1999 adamed 
//
//*************************************************************/

#include "rsop.hxx"

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//  StripPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to Gpo
//
//  Parameters: pwszPath - full path to the ds object linked 
//                  to the gpo
//
//  Returns:    Pointer to suffix
//
//-------------------------------------------------------------
WCHAR *StripLinkPrefix( WCHAR *pwszPath )
{
    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\common\rsop\context.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  context.cxx
//
//*************************************************************

#include "rsop.hxx"
#include <strsafe.h>

CRsopContext::CRsopContext(
    PRSOP_TARGET pRsopTarget,
    BOOL         bReportingMode,
    WCHAR*       wszExtensionGuid
    ) : 
    _pWbemServices( pRsopTarget->pWbemServices ),
    _wszNameSpace( NULL ),
    _pRsopTarget( pRsopTarget ),
    _bEnabled( TRUE ),
    _dwMode( bReportingMode ? MODE_REPORTING : MODE_PLANNING ),
    _phrLoggingStatus ( NULL ),
    _hPolicyAccess( NULL ),
    _wszExtensionGuid( wszExtensionGuid ),
    _hkRsop( NULL )
{
    _pWbemServices->AddRef();
}


CRsopContext::CRsopContext(
    IWbemServices* pWbemServices,
    HRESULT*       phrLoggingStatus,
    WCHAR*         wszExtensionGuid
    ) :
    _pWbemServices( pWbemServices ),
    _wszNameSpace( NULL ),
    _pRsopTarget( NULL ),
    _bEnabled( pWbemServices != NULL ),
    _dwMode( MODE_DIAGNOSTIC ),
    _phrLoggingStatus ( phrLoggingStatus ),
    _hPolicyAccess( NULL ),
    _wszExtensionGuid( wszExtensionGuid ),
    _hkRsop( NULL )
{
    if ( _bEnabled )
    {
        _pWbemServices->AddRef();
    }
}

CRsopContext::CRsopContext(
    WCHAR* wszExtensionGuid
    ) : 
    _pWbemServices( NULL ),
    _wszNameSpace( NULL ),
    _pRsopTarget( NULL ),
    _bEnabled( FALSE ),
    _dwMode( MODE_DIAGNOSTIC ),
    _phrLoggingStatus ( NULL ),
    _hPolicyAccess( NULL ),
    _wszExtensionGuid( wszExtensionGuid ),
    _hkRsop( NULL )
{}


CRsopContext::~CRsopContext()
{
    ASSERT( ! _hPolicyAccess );

    //
    // Set the final logging status
    //
    if ( _bEnabled && _phrLoggingStatus )
    {
        *_phrLoggingStatus = S_OK;
    }

    if ( _pWbemServices )
    {
        _pWbemServices->Release();
    }

    delete [] _wszNameSpace;

    if ( _hkRsop )
    {
        RegCloseKey( _hkRsop );
    }
}

BOOL CRsopContext::IsRsopEnabled()
{
    return _bEnabled;
}

BOOL CRsopContext::IsPlanningModeEnabled()
{
    return ( _dwMode == MODE_PLANNING ) || ( _dwMode == MODE_REPORTING );
}

BOOL CRsopContext::IsDiagnosticModeEnabled()
{
    return _dwMode == MODE_DIAGNOSTIC;
}

BOOL CRsopContext::IsReportingModeEnabled()
{
    return ( _dwMode == MODE_REPORTING );
}

HRESULT CRsopContext::GetRsopStatus()
{
    HRESULT hr;

    hr = S_OK;

    if ( _phrLoggingStatus )
    {
        hr = *_phrLoggingStatus;
    }

    return hr;
}

void CRsopContext::SetNameSpace ( WCHAR* wszNameSpace )
{
    _wszNameSpace = wszNameSpace;

    if ( _wszNameSpace )
    {
        EnableRsop();
    }
}

void CRsopContext::EnableRsop()
{
    _bEnabled = (NULL != _pWbemServices) || 
        ( NULL != _wszNameSpace );
}

void CRsopContext::DisableRsop( HRESULT hrReason )
{
    if ( _bEnabled && _phrLoggingStatus )
    {
        *_phrLoggingStatus = hrReason;
    }

    _bEnabled = FALSE;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRsopContext::Bind
//
// Purpose: Bind to a policy database and return an interface
//          for the user or machine namespace
//
// Params:
//
//
// Return value: S_OK if successful, S_FALSE if already init'd,
//         other facility error if, the function fails.
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CRsopContext::Bind( IWbemServices** ppWbemServices )
{
    HRESULT       hr;

    ASSERT ( _bEnabled );

    hr = S_OK;

    //
    // Only bind to the database if we don't already have an interface
    //
    if ( ! _pWbemServices )
    {
        //
        // If we don't have one, we'll have to bind
        // using the namespace path
        //
        hr = _PolicyDatabase.Bind(
            _wszNameSpace,
            &_pWbemServices);
    }

    //
    // If we already have an interface, return that
    //
    if ( _pWbemServices )
    {
        *ppWbemServices = _pWbemServices;
        hr = S_FALSE;
    }

    if ( FAILED(hr) )
    {
        DisableRsop( hr );
    }

    return hr;
}
   

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRsopContext::GetNameSpace
//
// Purpose: Gets the namespace to which this context  is bound
//
// Params: ppwszNameSpace -- out parameter that will point
//     to the address of a string that has the namespace --
//     this memory should be freed by the caller
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CRsopContext::GetNameSpace( WCHAR** ppwszNameSpace )
{
    LPWSTR            wszNamespaceEnd;
    LPWSTR            wszNameSpace;
    CVariant          var;
    IWbemClassObject* pWbemClassObject;

    XBStr             xbstrPath( L"__PATH" );
    XBStr             xbstrClass( RSOP_POLICY_SETTING );

    if ( ! xbstrPath || ! xbstrClass )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT  hr;

    pWbemClassObject = NULL;

    //
    // Get the class
    //
    hr = _pWbemServices->GetObject(
        xbstrClass,
        0L,
        NULL,
        &pWbemClassObject,
        NULL );

    if ( SUCCEEDED( hr ) )
    {
        
        //
        // Read the path property of the class from the class object
        //
        hr = pWbemClassObject->Get(
            xbstrPath,
            0L,
            (VARIANT*) &var,
            NULL,
            NULL);

        pWbemClassObject->Release();
    }

    //
    // Now parse the path to obtain the parent namespace of 
    // the class, which is the namespace in which the
    // IWbemServices pointer resides
    //

    //
    // Find the end of the class name so we can null-terminate it
    //
    if ( SUCCEEDED( hr ) )
    {
        //
        // Look for the delimiter that terminates the class name
        //
        wszNamespaceEnd = wcschr( ((VARIANT*) &var)->bstrVal, L':' );

        //
        // If we found the delimiter, terminate the string there
        //
        if ( wszNamespaceEnd )
        {
            *wszNamespaceEnd = L'\0';
        }
                        
        //
        // Allocate space for the namespace string
        //
        DWORD dwNSLength = wcslen( ((VARIANT*) &var)->bstrVal ) + 1;
        wszNameSpace = new WCHAR [ dwNSLength ];
        
        //
        // If we got space for the namespace, copy it
        //
        if ( wszNameSpace )
        {
            hr = StringCchCopy( wszNameSpace, dwNSLength, ((VARIANT*) &var)->bstrVal );
            ASSERT( SUCCEEDED(hr) );

            *ppwszNameSpace = wszNameSpace;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT
CRsopContext::MoveContextState( CRsopContext* pRsopContext )
{
    _pWbemServices = pRsopContext->_pWbemServices;

    if ( _pWbemServices )
    {
        _pWbemServices->AddRef();
    }

    _bEnabled = pRsopContext->_bEnabled;

    _dwMode = pRsopContext->_dwMode;

    _phrLoggingStatus = pRsopContext->_phrLoggingStatus;

    pRsopContext->_phrLoggingStatus = NULL;

    delete [] _wszNameSpace;
    _wszNameSpace = pRsopContext->_wszNameSpace;

    pRsopContext->_wszNameSpace = NULL;

    _pRsopTarget = pRsopContext->_pRsopTarget;

    _wszExtensionGuid = pRsopContext->_wszExtensionGuid;

    _hkRsop = pRsopContext->_hkRsop;

    pRsopContext->_hkRsop = NULL;

    return S_OK;
}

HRESULT
CRsopContext::GetExclusiveLoggingAccess( BOOL bMachine )
{
    HRESULT hr;

    hr = S_OK;

    ASSERT( ! _hPolicyAccess );

    //
    // We require exclusive access in diagnostic mode only --
    // in planning mode, we have implicit exclusive access
    //
    if ( IsRsopEnabled() && IsDiagnosticModeEnabled() )
    {
        _hPolicyAccess = EnterCriticalPolicySection( bMachine );

        //
        // On failure, disable logging
        //
        if ( ! _hPolicyAccess )
        {
            LONG Status;

            Status = GetLastError();

            hr = HRESULT_FROM_WIN32( Status );

            if ( SUCCEEDED( hr ) )
            {
                hr = E_FAIL;
            }

            DisableRsop( hr );
        }
    }
    
    return hr;
}
 
void
CRsopContext::ReleaseExclusiveLoggingAccess()
{
    if ( _hPolicyAccess )
    {
        LeaveCriticalPolicySection( _hPolicyAccess );
        
        _hPolicyAccess = NULL;
    }
}


LONG
CRsopContext::GetRsopNamespaceKeyPath(
    PSID    pUserSid,
    WCHAR** ppwszDiagnostic )
{
    LONG           Status;
    UNICODE_STRING SidString;
    WCHAR*         wszUserSubkey;
    HRESULT        hr   =  S_OK;

    *ppwszDiagnostic = NULL;

    RtlInitUnicodeString( &SidString, NULL );

    wszUserSubkey = NULL;

    Status = ERROR_SUCCESS;

    //
    // First, get the subkey
    //
    if ( pUserSid )
    {
        NTSTATUS NtStatus;

        NtStatus = RtlConvertSidToUnicodeString(
            &SidString,
            pUserSid,
            TRUE);

        if ( NT_SUCCESS( NtStatus ) )
        {
            wszUserSubkey = SidString.Buffer;
        }
        else
        {
            Status = RtlNtStatusToDosError( NtStatus );
        }
    }
    else
    {
        wszUserSubkey = MACHINESUBKEY;
    }

    //
    // If we have obtained the full subkey, we can now
    // generate the path for it
    //
    if ( ERROR_SUCCESS == Status )
    {
        DWORD cchLen;

        //
        // Space for the user sid string + the pathsep
        //
        cchLen = lstrlen ( wszUserSubkey ) + 1;

        //
        // Space for the gp extension state parent + extension list key (includes both pathseps and null terminator) +
        // + the cse subkey
        //
        cchLen += ( sizeof( GPSTATEKEY ) + sizeof( EXTENSIONLISTKEY ) ) / sizeof( *wszUserSubkey ) + 
            lstrlen( _wszExtensionGuid ) + 1;

        *ppwszDiagnostic = new WCHAR[ cchLen ];

        if ( *ppwszDiagnostic )
        {
            hr = StringCchCopy( *ppwszDiagnostic, cchLen, GPSTATEKEY L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( *ppwszDiagnostic, cchLen, wszUserSubkey );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( *ppwszDiagnostic, cchLen, EXTENSIONLISTKEY );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( *ppwszDiagnostic, cchLen, _wszExtensionGuid );
            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            Status = ERROR_OUTOFMEMORY;
        }
    }

    //
    // Free allocated resources
    //
    if ( SidString.Buffer )
    {
        RtlFreeUnicodeString( &SidString );
    }

    return Status;
}

void
CRsopContext::InitializeContext( PSID pUserSid )
{
    LONG   Status;
    WCHAR* wszNameSpace;
    WCHAR* wszNameSpaceKeyPath;

    //
    // In planning mode, all initialization is
    // already done, there is nothing to do here
    //
    if ( IsPlanningModeEnabled() )
    {
        return;
    }

    //
    // Return successfully if we already have our key.
    //
    if ( _hkRsop )
        return;
    
    Status = ERROR_SUCCESS;

    //
    // First, we need to get the rsop subkey -- we must ensure that it exists
    //
    Status = GetRsopNamespaceKeyPath(
        pUserSid,
        &wszNameSpaceKeyPath);

    if ( ERROR_SUCCESS == Status )
    {
        //
        // We create a key under the user's per machine policy
        // subtree.  This key must be persistent so that extensions
        // that process policy outside of the policy engine context
        // or in no changes when the policy engine does not pass
        // a namepsace to the extension can know whether RSoP is enabled
        // or not and where to log the data
        //
        Status = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            wszNameSpaceKeyPath,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &_hkRsop,
            NULL );

        delete [] wszNameSpaceKeyPath;
    }

    if ( ERROR_SUCCESS != Status )
    {
        HRESULT hr;

        hr = HRESULT_FROM_WIN32( Status );

        DisableRsop( hr );
    }
}

void
CRsopContext::InitializeSavedNameSpace()
{
    LONG   Status;
 
    if ( ! _hkRsop )
    {
        return;
    }

    //
    // In planning mode, all initialization is
    // already done, there is nothing to do here
    //
    if ( IsPlanningModeEnabled() )
    {
        return;
    }
    
    Status = ERROR_SUCCESS;
 
    //
    // If we already have a namespace, there is no need to use the saved
    // namespace, so we can leave since we've ensured the existence of the namespace key
    //
    if ( HasNameSpace() )
    {
        return;
    }
    
    //
    // The rsop namespace for this user is stored in the registry -- 
    // we query this below
    //
    DWORD  Size;

    Size = 0;

    Status = RegQueryValueEx(
        _hkRsop,
        RSOPNAMESPACE,
        NULL,
        NULL,
        NULL,
        &Size);

    if ( ERROR_SUCCESS == Status )
    {
        WCHAR* wszNameSpace;

        wszNameSpace = (WCHAR*) new BYTE [ Size ];

        if ( ! wszNameSpace )
        {
            Status = ERROR_OUTOFMEMORY;

            goto CRsopContext__InitializeSavedNameSpace__Exit;
        }

        Status = RegQueryValueEx(
            _hkRsop,
            RSOPNAMESPACE,
            NULL,
            NULL,
            (LPBYTE) wszNameSpace,
            &Size);

        if ( ERROR_SUCCESS != Status )
        {
            delete [] wszNameSpace;
            wszNameSpace = NULL;
        }
        else
        {
            SetNameSpace( wszNameSpace );
        }
    }

 CRsopContext__InitializeSavedNameSpace__Exit:
    
    if ( ERROR_SUCCESS != Status )
    {
        HRESULT hr;

        hr = HRESULT_FROM_WIN32( Status );

        DisableRsop( hr );
    }
}


void
CRsopContext::SaveNameSpace()
{
    WCHAR*  wszNameSpace;
    HRESULT hr;

    if ( ! IsRsopEnabled() )
    {
        return;
    }

    if ( IsPlanningModeEnabled() )
    {
        return;
    }
    
    wszNameSpace = NULL;

    //
    // Retrieve the rsop namespace -- note that the retrieved
    // string should be freed
    //
    hr = GetNameSpace( &wszNameSpace );

    if ( SUCCEEDED( hr ) )
    {
#if DBG
        DWORD
        DebugStatus =
#endif // DBG
            RegSetValueEx( _hkRsop,
                           RSOPNAMESPACE,
                           0,
                           REG_SZ,
                           (LPBYTE) wszNameSpace,
                           (lstrlen( wszNameSpace ) + 1) * sizeof(WCHAR) );
    }

    delete [] wszNameSpace;
}

void
CRsopContext::DeleteSavedNameSpace()
{
    if ( IsPlanningModeEnabled() )
    {
        return;
    }
    
#if DBG
    DWORD
    DebugStatus =
#endif // DBG
        RegDeleteValue( _hkRsop,
                        RSOPNAMESPACE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\common\rsop\dllload.cxx ===
//*************************************************************
//
//  DLL loading functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995 - 2000
//  All rights reserved
//
//*************************************************************

#include "rsop.hxx"

//
// file global variables containing pointers to APIs and
// loaded modules
//

OLE32_API       g_Ole32Api;

CRITICAL_SECTION g_ApiDLLCritSec;

//*************************************************************
//
//  InitializeAPIs()
//
//  Purpose:    initializes API structures for delay loaded
//              modules
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void InitializeAPIs( void )
{
    ZeroMemory( &g_Ole32Api,    sizeof( OLE32_API ) );
}

//*************************************************************
//
//  InitializeApiDLLsCritSec()
//
//  Purpose:    initializes a CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void InitializeApiDLLsCritSec( void )
{
    InitializeCriticalSection( &g_ApiDLLCritSec );
}

//*************************************************************
//
//  CloseApiDLLsCritSec()
//
//  Purpose:    clean up CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void CloseApiDLLsCritSec( void )
{
    DeleteCriticalSection( &g_ApiDLLCritSec );
}

//*************************************************************
//
//  LoadOle32Api()
//
//  Purpose:    Loads ole32.dll
//
//  Parameters: none
//
//  Return:     pointer to OLE32_API
//
//*************************************************************

POLE32_API LoadOle32Api()
{
    BOOL bResult = FALSE;
    OLE32_API *pOle32Api = &g_Ole32Api;

    if ( pOle32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        return pOle32Api;
    }

    pOle32Api->hInstance = LoadLibrary (TEXT("ole32.dll"));

    if (!pOle32Api->hInstance) {
        goto Exit;
    }

    pOle32Api->pfnCoCreateInstance = (PFNCOCREATEINSTANCE) GetProcAddress (pOle32Api->hInstance,
                                                                           "CoCreateInstance");
    if (!pOle32Api->pfnCoCreateInstance) {
        goto Exit;
    }

    pOle32Api->pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress (pOle32Api->hInstance,
                                                                       "CoInitializeEx");
    if (!pOle32Api->pfnCoInitializeEx) {
        goto Exit;
    }

    pOle32Api->pfnCoUnInitialize = (PFNCOUNINITIALIZE) GetProcAddress (pOle32Api->hInstance,
                                                                        "CoUninitialize");
    if (!pOle32Api->pfnCoUnInitialize) {
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        if ( pOle32Api->hInstance ) {
            FreeLibrary( pOle32Api->hInstance );
        }

        ZeroMemory( pOle32Api, sizeof( OLE32_API ) );
        pOle32Api = 0;
    }

    return pOle32Api;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\common\rsop\pollog.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  pollog.cxx
//
//*************************************************************

#include "rsop.hxx"
#include <strsafe.h>

#define RECORD_ENUMERATION_TIMEOUT -1

#define WQL_LANGUAGE L"WQL"
#define WSZGENERAL_CRITERIA_TEMPLATE L"select * from %s"
#define WSZSPECIFIC_CRITERIA_TEMPLATE WSZGENERAL_CRITERIA_TEMPLATE L" where %s"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::CPolicyLog
//
// Purpose: Constructor for CPolicyLog class
//
// Params: none
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
CPolicyLog::CPolicyLog() :
    _pRsopContext(NULL )
{}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::InitLog
//
// Purpose: Initializes the logging class so that it
//     can create / delete / edit record in the database
//
// Params:
//     pRsopContext -- context used to bind to the namespace
//     wszPolicyType -- string corresponding to the record
//     (policy) type -- this is the name of a class defined
//     in the database schema.
//
// Return value: S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::InitLog(
    CRsopContext* pRsopContext,
    WCHAR*        wszPolicyType)
{
    HRESULT          hr;

    _pRsopContext = pRsopContext;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Set our internal automation compatible version
    // of the policy type with the caller's specification --
    // return if we cannot set this value
    //
    _wszClass = wszPolicyType;

    XBStr xbstrClass;

    xbstrClass = wszPolicyType;

    if ( ! xbstrClass )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Now, bind the context to get the correct namespace
    //
    hr = pRsopContext->Bind( &_xWbemServices );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Be sure to AddRef it, since we don't want it to
    // go away when we're done
    //
    _xWbemServices->AddRef();

    //
    // Now we attempt to get an interface to the class of policy
    // requested by the caller
    //
    hr = GetRecordCreator(
        &xbstrClass,
        &_xRecordCreator);

    if (FAILED(hr))
    {
        return hr;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::UninitLog
//
// Purpose: Uninitializes the logging class so that all
//     its resources are freed
//
// Params: none
//
// Return value: none
//
// Notes:  
//
//------------------------------------------------------------
void CPolicyLog::UninitLog()
{
    _xEnum = NULL;
  
    _xWbemServices = NULL;

    _xRecordCreator = NULL;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::AddBlankRecord
//
// Purpose: Creates a blank record in the policy database,
//     and connects the supplied CPolicyRecord with the
//     newly created record
//
// Params: pRecord -- reference to a CPolicyRecord which will
//     be associated with the new record if this funciton
//    succeeds.
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::AddBlankRecord(CPolicyRecord* pRecord)
{
    HRESULT           hr;
    IWbemClassObject* pRecordInterface;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    pRecordInterface = NULL;

    //
    // Use the record creator interface to create 
    // an instance of the class of record associated
    // with this log
    //
    hr = _xRecordCreator->SpawnInstance(
        0,
        &pRecordInterface);

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Initialize the CPolicyRecord so that it is
    // associated with the newly created record
    //
    pRecord->InitRecord(pRecordInterface);

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::CommitRecord
//
// Purpose: Commits an edited policy record to the database
//
// Params: pRecord -- the record to commit
//
// Return value: S_OK if successful, other error if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::CommitRecord(CPolicyRecord* pRecord)
{
    return _xWbemServices->PutInstance(
        pRecord->GetRecordInterface(),
        WBEM_FLAG_CREATE_OR_UPDATE,
        NULL,
        NULL);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::WriteNewRecord
//
// Purpose: Creates a new record in the database, populates
//     that record with information specific to the CPolicyRecord
//     object, and commits the record.
//
// Params: pRecord -- reference to a CPolicyRecord which contains
//     information that should be written to the database
//
// Return S_OK if success, error otherwise
//
// Notes:  The pRecord object may not be passed to this
//         method more than once
//
//------------------------------------------------------------
HRESULT CPolicyLog::WriteNewRecord(CPolicyRecord* pRecord)
{
    HRESULT hr;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Now, let's attempt to add a blank entry for this record to the database
    //
    hr = AddBlankRecord( pRecord );

    if (FAILED(hr)) 
    {
        return hr;
    }

    //
    // Write the information for this record into the blank log record 
    //
    hr = pRecord->Write();

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We've written the record, now commit it permanently to the log
    // in the database
    //
    hr = CommitRecord( pRecord );

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetRecordCreator
//
// Purpose: Returns an interface that allows for the creation
//     of records of a specified class in the database
//
// Params: pStrClass -- a string named with a class as defined
//     by the database schema that indicates the class for
//     which we require an interface
//
//     ppClass -- out param returning an interface to the
//     record creator for a given class
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::GetRecordCreator(
    XBStr*             pxStrClass,
    IWbemClassObject** ppClass)
{
    HRESULT          hr;

    //
    // Call the method of the namespace interface to return
    // an instance of the specified class defined in that namespace
    //
    hr = _xWbemServices->GetObject(
        *pxStrClass,
        0L,
        NULL,
        ppClass,
        NULL );

    return hr;
} 


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::GetNextRecord
//
// Purpose: Associates a CPolicyRecord with a database
//     record that's next in the current enumeration
//
// Params: pRecord -- CPolicyRecord to be associated with
//     the next db record in the enumeration
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::GetNextRecord( CPolicyRecord* pRecord )
{
    ULONG             ulReturned;
    IWbemClassObject* pInstance;
    HRESULT           hr;

    ulReturned = 1;

    //
    // Use the enumeration interface to return a record interface
    // to the next item in the enumeration -- we choose
    // here to enumerate one at a time as this is not
    // optimzed for speed currently.
    //
    hr = _xEnum->Next( 
        RECORD_ENUMERATION_TIMEOUT,
        1,
        &pInstance,
        &ulReturned );

    //
    // If we received one item back with a success code,
    // we have retrieved an interface -- associate
    // the retrieved interface with the caller-specified
    // pRecord
    //
    if ( (S_OK == hr) && (1 == ulReturned) )
    {
        pRecord->InitRecord( pInstance );
    }
    else
    {
        ASSERT(FAILED(hr) || (S_FALSE == hr));
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyLog::OpenExistingRecord
//
// Purpose: Associates a CPolicyRecord with a database
//     record that corresponds to a path emitted by
//     CPolicyRecord's GetPath method
//
// Params: pRecord -- CPolicyRecord to be associated with
//     the existing database item
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT
CPolicyLog::OpenExistingRecord( CPolicyRecord* pRecord )
{
    HRESULT hr;

    WCHAR*   wszPath = NULL;
    DWORD   cchLength = MAX_PATH;
    BSTR    PathName = NULL;


    wszPath = (WCHAR*)LocalAlloc(LPTR, cchLength*sizeof(WCHAR));
    if ( wszPath == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = pRecord->GetPath( wszPath, &cchLength );
    if ( FAILED( hr ) )
    {
        LocalFree( wszPath );
        return hr;
    }

    if ( S_OK == hr )
    {
        PathName = SysAllocString( wszPath );
        LocalFree( wszPath );
        wszPath = NULL;
    }
    else
    {
        LocalFree( wszPath );
        
        wszPath = (WCHAR*)LocalAlloc(LPTR, cchLength*sizeof(WCHAR));
        if ( wszPath != NULL )
        {
            hr = pRecord->GetPath( wszPath, &cchLength );
            if ( FAILED(hr) )
            {
                LocalFree( wszPath );
                return hr;
            }

            PathName = SysAllocString( wszPath );
            LocalFree( wszPath );
            wszPath = NULL;
        }
    }
      
    if ( ! PathName )
    {
        return E_OUTOFMEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        IWbemClassObject* pInstance;
        
        pInstance = NULL;

        if ( _xWbemServices )
        {
            hr = _xWbemServices->GetObject(
                PathName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pInstance,
                NULL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED( hr ) )
        {
            pRecord->InitRecord( pInstance );
        }
    }

    SysFreeString( PathName );

    if ( SUCCEEDED( hr ) )
    {
       pRecord->_bNewRecord = FALSE;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::DeleteRecord
//
// Purpose: Deletes the record associated with this CPolicyRecord
//     from the database
//
// Params: pRecord -- CPolicyRecord associated with
//     the record to delete
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::DeleteRecord(
    CPolicyRecord* pRecord,
    BOOL           bDeleteStatus)
{
    CVariant var;
    HRESULT  hr;

    //
    // If specified by the caller, delete any associated status records
    //
    if ( bDeleteStatus )
    {
        hr = DeleteStatusRecords( pRecord );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Retrieve the database path of the record to delete
    //
    hr = pRecord->GetRecordInterface()->Get( 
        WMI_PATH_PROPERTY,
        0L,
        (VARIANT*) &var,
        NULL,
        NULL);

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Now that we have the path, we can use it to delete the record
    // by supplying it to the namespace's delete instance method --
    // this will delete the record from the namespace
    //
    hr = _xWbemServices->DeleteInstance( 
        ((VARIANT*) &var)->bstrVal,
        0L,
        NULL,
        NULL );

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::DeleteRecord
//
// Purpose: Deletes the record associated with this CPolicyRecord
//     from the database
//
// Params: pRecord -- CPolicyRecord associated with
//     the record to delete
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::DeleteStatusRecords( CPolicyRecord* pRecord )
{
    HRESULT hr;

    //
    // If there is a setting status associated with
    // this error, delete it
    //
    hr = RsopResetPolicySettingStatus(
        0,
        _xWbemServices,
        pRecord->GetRecordInterface());

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearLog
//
// Purpose: Clears all records of this log's class (policy type)
//     from the log's associated namespace
//
// Params: none
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::ClearLog(
    WCHAR* wszSpecifiedCriteria,
    BOOL   bDeleteStatus)
{
    HRESULT hr;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Retrieve an enumerator for the specified criteria
    //
    hr = GetEnum( wszSpecifiedCriteria );

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We will iterate through all existing records
    //
    for (;;)
    {
        CPolicyRecord CurrentRecord;

        //
        // Retrieve the current record from the
        // namespace
        //
        hr = GetNextRecord(&CurrentRecord);
        
        if (FAILED(hr))
        {
            return hr;
        }
     
        //
        // If there are no more records to retrieve,
        // we are done and can exit the loop.
        //
        if (S_FALSE == hr)
        {
            break;
        }
       
        //
        // Delete the current record from the namespace
        //
        hr = DeleteRecord( &CurrentRecord, bDeleteStatus );
    }

    FreeEnum();

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearLog
//
// Purpose: Deletes all instances of this class from the namespace
//
// Params: none
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CPolicyLog::GetEnum( WCHAR* wszSpecifiedCriteria )
{
    HRESULT               hr;

    if ( _xEnum )
    {
        return E_FAIL;
    }

    //
    // Generate criteria from the caller's specification
    //
    WCHAR* wszCriteria;
    DWORD  dwCritLength = ( wszSpecifiedCriteria ? lstrlen(wszSpecifiedCriteria) : 0 ) +
                            sizeof( WSZSPECIFIC_CRITERIA_TEMPLATE ) / sizeof(WCHAR) +
                            lstrlen( _wszClass ) + 1;

    wszCriteria = new WCHAR [ dwCritLength ];

    if ( ! wszCriteria )
    {
        return E_OUTOFMEMORY;
    }

    //
    // This creates a query for instances of the class supported by this log
    // that adhere to the caller's specifications (usually asserts the value of some property)
    //
    if ( wszSpecifiedCriteria )
    {
        //
        // Include the user's criteria if specified
        //
        hr = StringCchPrintf(wszCriteria,
                             dwCritLength,
                             WSZSPECIFIC_CRITERIA_TEMPLATE,
                             _wszClass,
                             wszSpecifiedCriteria);
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        //
        // If the user specified no criteria, do not attempt to include it
        //
        hr = StringCchPrintf(wszCriteria,
                             dwCritLength,
                             WSZGENERAL_CRITERIA_TEMPLATE,
                             _wszClass);
        ASSERT(SUCCEEDED(hr));
    }

    hr = E_OUTOFMEMORY;

    XBStr  Query( wszCriteria );
    XBStr  QueryLanguage( WQL_LANGUAGE );

    if ( Query && QueryLanguage )
    {
        //
        // Use this method to obtain an enumerator for instances
        // satisfying the specified criteria
        //
        hr = _xWbemServices->ExecQuery(
            QueryLanguage,
            Query,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &_xEnum );
    }

    delete [] wszCriteria;

    if ( FAILED(hr) )
    {
        return hr;
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPolicyRecord::ClearLog
//
// Purpose: Deletes all instances of this class from the namespace
//
// Params: none
//
// Return S_OK if success, error otherwise
//
// Notes:  
//
//------------------------------------------------------------
void CPolicyLog::FreeEnum()
{
    //
    // This will release the interface and set it to NULL so
    // that we know that it is released;
    //
    _xEnum = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\common\inc\schema.h ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998 - 2000
//  All rights reserved
//
//  schema.h
//
//  This file contains declarations related to the wmi schema
//  for rsop policy objects
//
//*************************************************************

//
// WMI intrinsic properties
//
#define WMI_PATH_PROPERTY                          L"__PATH"


//
// Rsop base properties
//

#define RSOP_POLICY_SETTING                        L"RSOP_PolicySetting"

// Unique id
#define RSOP_ATTRIBUTE_ID                          L"id"

// A user friendly name.
#define RSOP_ATTRIBUTE_NAME                        L"name"

// The scope of management links to the gpo
// of this policy object 
#define RSOP_ATTRIBUTE_SOMID                       L"SOMID"

// The creation time of this instance
#define RSOP_ATTRIBUTE_CREATIONTIME                L"creationTime"

// The GPO Identifier for this PO.  Using this and the policy class you
// can get back to the GPO Object of which this is an identifier
#define RSOP_ATTRIBUTE_GPOID                       L"GPOID"

// This is the order in which the policy is applied when 
// considering only its class.
#define RSOP_ATTRIBUTE_PRECEDENCE                  L"precedence"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\debug.cxx ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "fdeploy.hxx"

//
// Global Variable containing the debugging level.  The debug level can be
// modified by both the debug init routine and the event logging init
// routine.  Debugging can be enabled even on retail systems through
// registry settings.
//

DWORD   gDebugLevel = DL_NONE;

//
// Debug strings
//

const WCHAR cwszTitle[] = L"FDEPLOY (%x) ";
const WCHAR cwszTime[] = L"%02d:%02d:%02d:%03d ";
const WCHAR cwszLogfile[] = L"%SystemRoot%\\Debug\\UserMode\\fdeploy.log";
const WCHAR cwszCRLF[] = L"\r\n";

//
// Registry debug information
//

#define DEBUG_REG_LOCATION  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics"
#define DEBUG_KEY_NAME      L"FDeployDebugLevel"

//*************************************************************
//
//  InitDebugSupport()
//
//  Sets the debugging level.
//  Also checks the registry for a debugging level.
//
//*************************************************************
void InitDebugSupport()
{
    HKEY    hKey;
    DWORD   Size;
    DWORD   Type;
    BOOL    bVerbose;
    DWORD   Status;

#if DBG
    gDebugLevel = DL_NORMAL;
#else
    gDebugLevel = DL_NONE;
#endif

    Status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    DIAGNOSTICS_KEY,
                    0,
                    KEY_READ,
                    &hKey );

    bVerbose = FALSE;
    Size = sizeof(bVerbose);

    if ( ERROR_SUCCESS == Status )
    {
        Status = RegQueryValueEx(
                        hKey,
                        DIAGNOSTICS_POLICY_VALUE,
                        NULL,
                        &Type,
                        (LPBYTE) &bVerbose,
                        &Size );

        if ( (ERROR_SUCCESS == Status) && (Type != REG_DWORD) )
            bVerbose = FALSE;

        RegCloseKey(hKey);
    }

    Status = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                DEBUG_REG_LOCATION,
                &hKey );

    if ( ERROR_SUCCESS == Status )
    {
        Size = sizeof(gDebugLevel);
        RegQueryValueEx(
                hKey,
                DEBUG_KEY_NAME,
                NULL,
                &Type,
                (LPBYTE)&gDebugLevel,
                &Size );

        RegCloseKey(hKey);
    }

    if ( bVerbose )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;
}

BOOL DebugLevelOn( DWORD mask )
{
    BOOL bOutput = FALSE;

    if ( gDebugLevel & DL_VERBOSE )
        bOutput = TRUE;
    else if ( gDebugLevel & DL_NORMAL )
        bOutput = ! (mask & DM_VERBOSE);
#if DBG
    else // DL_NONE
        bOutput = (mask & DM_ASSERT);
#endif

    return bOutput;
}

//*************************************************************
//
//  _DebugMsg()
//
//  Displays debug messages based on the debug level
//  and type of debug message.
//
//  Parameters :
//      mask    -   debug message type
//      MsgID   -   debug message id from resource file
//      ...     -   variable number of parameters
//
//*************************************************************
void _DebugMsg(DWORD mask, DWORD MsgID, ...)
{
    BOOL bEventLogOK;
    WCHAR wszDebugTitle[30];
    WCHAR wszDebugTime [30];
    WCHAR wszDebugBuffer[4*MAX_PATH];
    WCHAR wszMsg[MAX_PATH];
    va_list VAList;
    DWORD dwErrCode;
    SYSTEMTIME systime;

    bEventLogOK = ! (mask & DM_NO_EVENTLOG);

    if ( ! DebugLevelOn( mask ) )
        return;

    //
    // Save the last error code (so the debug output doesn't change it).
    //
    dwErrCode = GetLastError();

    va_start(VAList, MsgID);

    //
    // Event log message ids start at 101.  For these we must call
    // FormatMessage.  For other verbose debug output, we use
    // LoadString to get the string resource.
    //
    if ( MsgID < 100 )
    {
        if ( ! LoadString( ghDllInstance, MsgID, wszMsg, MAX_PATH) )
        {
            SetLastError(dwErrCode);
            return;
        }
        (void) StringCbVPrintf(wszDebugBuffer, sizeof(wszDebugBuffer), wszMsg, VAList);
    }
    else
    {
        DWORD   CharsWritten;

        CharsWritten = FormatMessage(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    ghDllInstance,
                    MsgID,
                    0,
                    wszDebugBuffer,
                    sizeof(wszDebugBuffer) / sizeof(WCHAR) - 1,
                    &VAList );

        if ( 0 == CharsWritten )
        {
            SetLastError(dwErrCode);
            return;
        }

        wszDebugBuffer[wcslen(wszDebugBuffer)] = L'\0';
    }

    va_end(VAList);

    GetLocalTime( &systime );
    (void) StringCbPrintf( wszDebugTitle, sizeof(wszDebugTitle), cwszTitle, GetCurrentProcessId() );
    (void) StringCbPrintf( wszDebugTime, sizeof(wszDebugTime), cwszTime, systime.wHour, systime.wMinute,
              systime.wSecond, systime.wMilliseconds);

    OutputDebugString( wszDebugTitle );
    OutputDebugString( wszDebugTime );
    OutputDebugString( wszDebugBuffer );
    OutputDebugString( cwszCRLF );

    if ( gDebugLevel & DL_LOGFILE )
    {
        HANDLE  hFile;
        TCHAR   cwszExpLogfile [MAX_PATH + 1];

        DWORD   dwRet = ExpandEnvironmentStrings (cwszLogfile, cwszExpLogfile,
                                                  MAX_PATH + 1);

        if (0 != dwRet && dwRet <= MAX_PATH)
        {
            hFile = OpenUnicodeLogFile(cwszExpLogfile);

            if ( hFile != INVALID_HANDLE_VALUE )
            {
                if ( SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF )
                {
                    WCHAR * wszBuffer;
                    DWORD   Size;

                    Size = lstrlen(wszDebugBuffer) + lstrlen (wszDebugTime) + 1;
                    __try
                    {
                        wszBuffer = (WCHAR *) alloca (Size * sizeof (WCHAR));
                    }
                    __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
                    {
                        _resetstkoflw();
                        wszBuffer = NULL;
                    }

                    if (wszBuffer)
                    {
                        (void) StringCchCopy(wszBuffer, Size, wszDebugTime);
                        (void) StringCchCat(wszBuffer, Size, wszDebugBuffer);
                        WriteFile(
                                hFile,
                                (LPCVOID) wszBuffer,
                                lstrlen(wszBuffer) * sizeof(WCHAR),
                                &Size,
                                NULL );
                        WriteFile(
                                hFile,
                                (LPCVOID) cwszCRLF,
                                lstrlen(cwszCRLF) * sizeof(WCHAR),
                                &Size,
                                NULL );
                    }
                }

                CloseHandle (hFile);
            }
        }
    }

    if ( bEventLogOK &&  gpEvents && (gDebugLevel & DL_EVENTLOG) )
        gpEvents->Report( EVENT_FDEPLOY_VERBOSE, 1, wszDebugBuffer );

    //
    // Restore the last error code
    //
    SetLastError(dwErrCode);

#if DBG
    if ( mask & DM_ASSERT )
        DebugBreak();
#endif
}

HANDLE OpenUnicodeLogFile (LPCTSTR lpszFilePath)
{
    HANDLE hFile;
    DWORD  Status;
    DWORD  dwWritten;

    Status = ERROR_SUCCESS;

    hFile = CreateFile(
        lpszFilePath,
        FILE_WRITE_DATA | FILE_APPEND_DATA,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        Status = GetLastError();
    }

    if ( ERROR_FILE_NOT_FOUND == Status )
    {
        //
        // The file doesn't exist, so we'll try to create it
        // with the byte order marker
        //

        hFile = CreateFile(
            lpszFilePath,
            FILE_WRITE_DATA | FILE_APPEND_DATA,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if ( INVALID_HANDLE_VALUE != hFile )
        {
            BOOL bWritten;

            //
            // Add the unicode byte order marker to the beginning of the file
            // so that APIs know for sure that it is a unicode file.
            //

            bWritten = WriteFile(
                hFile,
                L"\xfeff\r\n",
                4 * sizeof(WCHAR),
                &dwWritten, 
                NULL);

            if ( ! bWritten )
            {
                CloseHandle( hFile );
                hFile = INVALID_HANDLE_VALUE;
            }
        }
    }

    return hFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\common\rsop\variant.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  variant.hxx
//
//*************************************************************

#include "rsop.hxx"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::CVariant
//
// Purpose: Constructor for CVariant class.  Initializes the
//     storage of the variant data.
//
// Params: none
//
// Return value: none
//
// Notes:
//
//------------------------------------------------------------
CVariant::CVariant() :
    _iCurrentArrayIndex(0),
    _cMaxArrayElements(0)
{
    VariantInit(&_var);
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::~CVariant
//
// Purpose: Denstructor for CVariant class.  Frees any data
//     allocated to store variant data.
//
// Params: none
//
// Return value: none
//
// Notes:
//
//------------------------------------------------------------
CVariant::~CVariant()
{
    HRESULT hr;

    hr = VariantClear(&_var);

    ASSERT(SUCCEEDED(hr));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetStringValue
//
// Purpose: Sets the type of the variant to VT_BSTR and creates
//     a bstr to store the string.
//
// Params: wszValue -- this unicode string is the value to
//     which we want to set this variant
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  The variant should not be set to a value after
//     this is called -- otherwise, you may lose reference
//     to allocated memory -- the value is meant to be set
//     only once.  
//
//------------------------------------------------------------
HRESULT CVariant::SetStringValue(WCHAR* wszValue)
{
    XBStr xString;

    ASSERT(VT_EMPTY == _var.vt); 

    xString = wszValue;

    if (!xString)
    {
        return E_OUTOFMEMORY;
    }
    
    _var.vt = VT_BSTR;
    _var.bstrVal = xString.Acquire();

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetLongValue
//
// Purpose: Sets the type of the variant to VT_I4 and creates
//     a bstr to store the string.
//
// Params: lValue -- this LONG value is the value to
//     which we want to set this variant
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  The variant should not be set to a value after
//     this is called -- otherwise, you may lose reference
//     to allocated memory -- the value is meant to be set
//     only once.  
//
//------------------------------------------------------------
HRESULT CVariant::SetLongValue(LONG lValue)
{
    ASSERT(VT_EMPTY == _var.vt); 

    _var.vt = VT_I4;
    _var.lVal = lValue;

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetBoolValue
//
// Purpose: Sets the type of the variant to VT_BOOL and stores the value
//
// Params: bValue -- this boolean value is the value to
//     which we want to set this variant
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  The variant should not be set to a value after
//     this is called -- otherwise, you may lose reference
//     to allocated memory -- the value is meant to be set
//     only once.  
//
//------------------------------------------------------------
HRESULT CVariant::SetBoolValue(BOOL bValue)
{
    ASSERT(VT_EMPTY == _var.vt); 

    _var.vt = VT_BOOL;
    _var.boolVal = bValue ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextLongArrayElement
//
// Purpose: Adds an element in an array of strings to a 
//     specified string
//
// Params: Value -- the value to which to add as an element
//         cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextLongArrayElement(
    LONG  Value,
    DWORD cMaxElements)
{
    HRESULT hr;
    
    //
    // Add the long to the correct index
    // in the array
    //
    hr = SetNextArrayElement(
        VT_I4,
        cMaxElements,
        &Value);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextStringArrayElement
//
// Purpose: Adds an element to an array of strings
//
// Params: wszValue -- the value to which to add as an element
//         cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextStringArrayElement(
    WCHAR* wszValue,
    DWORD  cMaxElements)
{
    HRESULT hr;
    XBStr   xString;

    //
    // Create a bstr from the supplied unicode string
    //
    xString = wszValue;

    if (!xString)
    {
        return E_OUTOFMEMORY;
    }
    
    //
    // Now add the unicode string to the correct index
    // in the array
    //
    hr = SetNextArrayElement(
        VT_BSTR,
        cMaxElements,
        xString);

    //
    // If we've succeeded in setting the element, it now
    // owns the reference, so we release our reference
    //
    if (SUCCEEDED(hr))
    {
        (void) xString.Acquire();
    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextByteArrayElement
//
// Purpose: Adds an element in an array of bytes to a byte array 
//
// Params: byteValue -- the value to which to add as an element
//         cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextByteArrayElement(
    BYTE  byteValue,
    DWORD cMaxElements)
{
    HRESULT hr;
    
    //
    // Add the long to the correct index
    // in the array
    //
    hr = SetNextArrayElement(
        VT_UI1,
        cMaxElements,
        &byteValue);

    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::IsStringValue
//
// Purpose: Determines whether this variant represents a string
//
// Params: 
//
// Return value: returns TRUE if this is a string, FALSE if not
//
//------------------------------------------------------------
BOOL CVariant::IsStringValue()
{
    return VT_BSTR == _var.vt;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::IsLongValue
//
// Purpose: Determines whether this variant represents a long
//
// Params: 
//
// Return value: returns TRUE if this is a long, FALSE if not
//
//------------------------------------------------------------
BOOL CVariant::IsLongValue()
{
    return VT_I4 == _var.vt;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::operator VARIANT*()
//
// Purpose: Casts this object into a VARIANT structure pointer
//
// Params: 
//
// Return value: returns a pointer to a VARIANT structure
//
// Notes:  
//
//------------------------------------------------------------
CVariant::operator VARIANT*()
{
    return &_var;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::SetNextArrayElement
//
// Purpose: Adds an element to an array of objects of arbitrary
//     type
//
// Params: wszValue -- the value to which to set the element
//     cMaxElements (optional) -- the maximum number
//         of elements in this array -- must be specified
//         the first time this method is called on this object
//
// Return value: returns S_OK if successful, other
//     error code if not
//
// Notes:  
//
//------------------------------------------------------------
HRESULT CVariant::SetNextArrayElement(
        VARTYPE varType,
        DWORD   cMaxElements,
        LPVOID  pvData)
{
    HRESULT hr;

    //
    // If this array contains no elements, return the hr
    // that lets the caller know that this array is full
    //
    if ( 0 == cMaxElements )
    {
        return S_FALSE;
    }

    //
    // The first time this method is called on this object,
    // we should allocate space for the array
    //
    if ( !_iCurrentArrayIndex )
    {
        ASSERT( cMaxElements );
        ASSERT( VT_EMPTY == _var.vt );

        //
        // Allocate space for the array with elements
        // of the caller specifed type and number
        //
        hr = InitializeArray(
            varType,
            cMaxElements);

        if (FAILED(hr)) 
        {
            return hr;
        }

        _cMaxArrayElements = cMaxElements;
    } 

    ASSERT( ((DWORD) _iCurrentArrayIndex) < _cMaxArrayElements );

    //
    // Now add the polymorphic object's IUnknown
    // into the array
    //
    hr = SafeArrayPutElement(
        _var.parray,
        &_iCurrentArrayIndex,
        pvData);

    //
    // If we've filled up the array, return S_FALSE to
    // signal that no more elements can be added
    //
    if (SUCCEEDED(hr))
    {
        //
        // Increment our cursor into the array to the
        // next element 
        //
        _iCurrentArrayIndex++;

        //
        // Check our current index -- if it's the same
        // as our maximum, we're full
        //
        if ( ((DWORD) _iCurrentArrayIndex) == _cMaxArrayElements)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CVariant::InitializeArray
//
// Purpose: Private method that allocates space for an array
//     of a specified size and element type
//
// Params: varType -- type of elements that will be in the array
//     cMaxElements -- the size, in elements, of the array
//
// Return value: returns ERROR_SUCCESS if successful, other
//     win32 error code if not
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CVariant::InitializeArray(
    VARTYPE varType,
    DWORD   cMaxElements)
{
    SAFEARRAY*     pSafeArray;
    SAFEARRAYBOUND arrayBound;

    //
    // Set the bounds of the array to be zero-based
    //
    arrayBound.lLbound = 0;
    arrayBound.cElements = cMaxElements;

    //
    // Allocate the array
    //
    pSafeArray = SafeArrayCreate(
        varType,
        1, // 1 dimension
        &arrayBound);

    if (!pSafeArray) 
    {
        return E_OUTOFMEMORY;
    }

    //
    // Set our state to refer to the allocated memory
    // with the specified type
    //
    _var.vt = VT_ARRAY | varType;
    _var.parray = pSafeArray;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\rdrschem.h ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998 - 2000
//  All rights reserved
//
//  appschem.h
//
//  This file contains declarations related to the wmi schema
//  for folder redirection policy objects
//
//*************************************************************

//
// WMI class names for the folder redirection classes
//

#define RSOP_REDIRECTED_FOLDER L"RSOP_FolderRedirectionPolicySetting"


//
// Attribute names for the RSOP_FolderRedirectionPolicyObject class
//

// Unique id
#define RDR_ATTRIBUTE_ID                           L"id"

// Path to which folder is redirected
#define RDR_ATTRIBUTE_RESULT                       L"resultantPath"

// Groups - Array of security groups
#define RDR_ATTRIBUTE_GROUPS                       L"securityGroups"

// Paths - Array of redirection paths 
#define RDR_ATTRIBUTE_PATHS                        L"redirectedPaths"

// Installation Type: 1 = basic, 2 = maximum
#define RDR_ATTRIBUTE_INSTALLATIONTYPE             L"installationType"
//
// Enumerated values for installation type attribute
//
#define RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_BASIC 1L
#define RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_MAX   2L

// Grant Type - Grant user exclusive access
#define RDR_ATTRIBUTE_GRANTTYPE                    L"grantType"

// Move Type - true = moce contents of directory
#define RDR_ATTRIBUTE_MOVETYPE                     L"moveType"

// Policy Removal - 1 = leave folder in new location, 2 = redirect the folder back to the user profile location
#define RDR_ATTRIBUTE_POLICYREMOVAL                L"policyRemoval"
//
// Enumerated values for policyremoval attribute
//
#define RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REMAIN   1L
#define RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REDIRECT 2L

// Redirecting group
#define RDR_ATTRIBUTE_REDIRECTING_GROUP            L"redirectingGroup"


//
// Miscellaneous definitions
//

#define MAX_SZGUID_LEN 39
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\events.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  events.cxx
//
//*************************************************************

#include "fdeploy.hxx"

CEvents * gpEvents = 0;

CEvents::CEvents()
{
    _hEventLog = NULL;
    _pUserSid = NULL;
    _Refs = 0;
}

CEvents::~CEvents()
{
    if ( _hEventLog )
        CloseEventLog( _hEventLog );

    if ( _pUserSid )
        LocalFree( _pUserSid );
}

DWORD
CEvents::Init()
{
    DWORD       Size;
    DWORD       Type;
    DWORD       Status;
    HKEY        hKey;

    Status = ERROR_SUCCESS;

    if ( ! _hEventLog )
        _hEventLog = OpenEventLog( NULL, FDEPLOY_EVENT_SOURCE );

    if ( ! _hEventLog )
        return GetLastError();

    return ERROR_SUCCESS;
}

PSID
CEvents::UserSid()
{
    GetUserSid();

    // The caller does not own this sid and should not attempt to free it
    return _pUserSid;
}

void
CEvents::GetUserSid()
{
    DWORD       Size;
    DWORD       Status;
    HANDLE      hToken;
    PTOKEN_USER pTokenUserData;
    BOOL        bStatus;

    if ( _pUserSid )
        return;

    bStatus = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

    if ( ! bStatus )
        return;

    Size = sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG));
    __try
    {
        pTokenUserData = (PTOKEN_USER) alloca( Size );
    }
    __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
    {
        _resetstkoflw();
        pTokenUserData = NULL;
        CloseHandle( hToken );
        return;
    }

    bStatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    pTokenUserData,
                    Size,
                    &Size );

    CloseHandle( hToken );

    if ( ! bStatus )
        return;

    Size = GetLengthSid( pTokenUserData->User.Sid );

    _pUserSid = (PSID) LocalAlloc( 0, Size );

    if ( _pUserSid )
    {
        bStatus = CopySid( Size, _pUserSid, pTokenUserData->User.Sid );

        if ( ! bStatus )
        {
            LocalFree( _pUserSid );
            _pUserSid = NULL;
        }
    }
}

void
CEvents::Report(
    DWORD       EventID,
    WORD        Strings,
    ...
    )
{
    va_list     VAList;
    WCHAR **    ppwszStrings;
    WORD        Type;
    DWORD       DbgMsgLevel;

    switch ( EventID >> 30 )
    {
    case 3:
        Type = EVENTLOG_ERROR_TYPE;
        DbgMsgLevel = DM_WARNING;
        break;
    case 2:
        Type = EVENTLOG_WARNING_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    case 1:
    case 0:
        Type = EVENTLOG_INFORMATION_TYPE;
        DbgMsgLevel = DM_VERBOSE;
        break;
    default:
        return;
    }

    ppwszStrings = 0;

    if ( Strings > 0 )
    {
        __try
        {
            ppwszStrings = (WCHAR **) alloca( Strings * sizeof(WCHAR *) );
        }
        __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
        {
            _resetstkoflw();
            return;
        }

        va_start( VAList, Strings );
        for ( DWORD n = 0; n < Strings; n++ )
            ppwszStrings[n] = va_arg( VAList, WCHAR * );
        va_end( VAList );
    }

    GetUserSid();

    (void) ReportEvent(
                    _hEventLog,
                    Type,
                    0,
                    EventID,
                    _pUserSid,
                    Strings,
                    0,
                    (LPCWCH *) ppwszStrings,
                    NULL );

    //
    // Also make sure the event messages get sent to the debugger and log file.
    // Kind of hacky method, but makes it so every caller to ::Report doesn't
    // have to call _DebugMsg as well.
    // However, don't do this for the verbose messages otherwise it will be
    // dumped to the debugger twice.
    //
    if ( EVENT_FDEPLOY_VERBOSE == EventID )
        return;

    switch ( Strings )
    {
    case 0 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID );
        break;
    case 1 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0] );
        break;
    case 2 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1] );
        break;
    case 3 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2] );
        break;
    case 4 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0], ppwszStrings[1], ppwszStrings[2], ppwszStrings[3] );
        break;
    case 5 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0],
                   ppwszStrings[1], ppwszStrings[2], ppwszStrings[3],
                   ppwszStrings[4]);
        break;
    case 6 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0],
                   ppwszStrings[1], ppwszStrings[2], ppwszStrings[3],
                   ppwszStrings[4], ppwszStrings[5]);
        break;
    case 7 :
        _DebugMsg( DbgMsgLevel | DM_NO_EVENTLOG, EventID, ppwszStrings[0],
                   ppwszStrings[1], ppwszStrings[2], ppwszStrings[3],
                   ppwszStrings[4], ppwszStrings[5], ppwszStrings[6]);
        break;
    default :
        VerboseDebugDump( L"CEvents::Report called with more params then expected\n" );
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\log.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1999 - 2000
//  All rights reserved
//
//  log.cxx
//
//  Contains definitions for classes related to rsop logging
//  for the folder redirection client-side extension
//
//  Created: 8-01-1999 adamed
//
//*************************************************************

#include "fdeploy.hxx"


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::CRedirectionPolicy
//
// Purpose: Constructor for CRedirectionPlicy
//
// Params:
//     pGpoData -- structure containing information
//         from the gpo
//     pRdirect -- structure containing redireciton information
//         Precedence -- the precedence this redirection candidate
//         should have.  Lower values are least signifcant, higher
//         values have higher precedence.
// 
// Return value: none
//
// Notes: This constructor allocates memory and performs
//     other complex operations -- if it fails,
//     this fact is tracked internally and operations on the
//     object will fail as well with the error code
//
//------------------------------------------------------------
CRedirectionPolicy::CRedirectionPolicy(
    CFileDB*       pGpoData,
    CRedirectInfo* pRedirect,
    LONG           Precedence,
    HRESULT*       phr) :
    _rgwszGroups(NULL),
    _rgwszRedirectedPaths(NULL),
    _cGroups(0),
    _Precedence(Precedence),
    _dwFlags(pRedirect->m_dwFlags),
    _wszDisplayName(NULL),
    _wszLocalizedName(NULL),
    _wszGPODSPath(NULL),
    _wszSOMId(NULL),
    _pNext(NULL),
    _iFolderIndex(pRedirect->m_rID),
    _iAncestorIndex(0),
    _bHasAncestor(FALSE),
    _pGpoData( pGpoData ),
    _bMissingAncestor( FALSE ),
    _wszRedirectedPath( NULL )
{
    RtlInitUnicodeString( &_RedirectedSid, NULL );

    //
    // If this folder has a parent folder, remember that fact,
    // and record the id of the parent folder
    //
    if (pRedirect->m_pParent)
    {
        _iAncestorIndex = pRedirect->m_pParent->m_rID;
        _bHasAncestor = TRUE;
    }

    //
    // Retrieve security group / redirected folder information
    //
    _hrInit = GetGroupInformation(pRedirect->m_szGroupRedirectionData);

    if (FAILED(_hrInit))
    {
        *phr = _hrInit;
        return;
    }

    //
    // Copy the gpo's ds path for use as a gpo id -- we want only the part
    // of the path after the link prefix and user or computer container
    //
    WCHAR* wszGPOPrefixEnd;

    wszGPOPrefixEnd = wcschr( StripLinkPrefix( pGpoData->_pwszGPODSPath ), L',' );

    //
    // At this point, we are one charcter in front of the gpo container --
    // copy everything after this position
    //
    if ( wszGPOPrefixEnd )
    {
        _wszGPODSPath = StringDuplicate( wszGPOPrefixEnd + 1 );
    }

    if ( ! _wszGPODSPath )
    {
        goto exit_on_memory_allocation_failure;
    }
   
    //
    // Copy the scope of management path and use it as an id,
    // copying only the path after the ds prefix
    //
    _wszSOMId = StringDuplicate( StripLinkPrefix(pGpoData->_pwszGPOSOMPath) );

    if ( ! _wszSOMId )
    {
        goto exit_on_memory_allocation_failure;
    }

    //
    // Copy the friendly name of the redirected folder
    //
    _wszDisplayName = StringDuplicate(pRedirect->m_szDisplayName);

    if ( ! _wszDisplayName )
    {
        goto exit_on_memory_allocation_failure;
    }

    //
    // Copy the localized file system name of the folder
    //
    _wszLocalizedName = StringDuplicate(pRedirect->m_szLocDisplayName);

    if ( ! _wszLocalizedName )
    {
        goto exit_on_memory_allocation_failure;
    }

    //
    // Copy the redirected sid in string format -- the sid
    // will not be present if this folder inherits from the parent,
    // so do not copy it in that case -- this will be dealt with later
    // when the final parent is known.
    //
    if ( pRedirect->m_pSid )
    {
        NTSTATUS       Status;

        //
        // Copy the path to which this folder is redirected
        //
        _wszRedirectedPath = StringDuplicate( _rgwszRedirectedPaths[ pRedirect->m_iRedirectingGroup ] );
        
        if ( ! _wszRedirectedPath )
        {
            goto exit_on_memory_allocation_failure;
        }

        Status = RtlConvertSidToUnicodeString(
            &_RedirectedSid,
            pRedirect->m_pSid,
            TRUE);

        if (STATUS_SUCCESS != Status)
        {
            LONG Error;

            Error = RtlNtStatusToDosError(Status);

            _hrInit = HRESULT_FROM_WIN32(Error);
        }
        else
        {
            _hrInit = S_OK;
        }
    }

    *phr = _hrInit;

    return;

exit_on_memory_allocation_failure:

    //
    // Set our internal state to error so that methods
    // know that our internal state is bad and will fail
    // safely
    //
    _hrInit = E_OUTOFMEMORY;
    *phr = _hrInit;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::~CRedirectionPolicy
//
// Purpose: Destructor for CRedirectionPolicy.  Frees resources
//     allocated by this object
//
// Params: none
// 
// Return value: none
//
// Notes:
//
//------------------------------------------------------------
CRedirectionPolicy::~CRedirectionPolicy()
{
    LONG iGroup;

    //
    // Iterate through the groups / paths strings
    // and destroy each one
    //
    for (iGroup = 0; iGroup < _cGroups; iGroup++)
    {
        delete [] _rgwszGroups[iGroup];
        delete [] _rgwszRedirectedPaths[iGroup];
    }

    //
    // Free all the other allocated strings
    //
    delete [] _rgwszGroups;
    delete [] _rgwszRedirectedPaths;

    delete [] _wszGPODSPath;
    delete [] _wszSOMId;
    delete [] _wszDisplayName;
    delete [] _wszLocalizedName;
    delete [] _wszRedirectedPath;

    RtlFreeUnicodeString(&_RedirectedSid);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::Write
//
// Purpose: implementation of pure virtual Write method required
//     by all policy records.  It writes policy information 
//     for the redirection candidate to the log in the database
//
// Params: none
// 
// Return value: S_OK if successful, error otherwise
//
// Notes:
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::Write()
{
    HRESULT hr;
        
    //
    // Set the unique id
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_ID,
        _wszDisplayName);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_ID, hr )

    //
    // If we cannot make a unique id, we must exit because this is a key
    //
    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, IDS_RSOP_ATTEMPT_WRITE, _wszDisplayName));
        return hr;
    }

    //
    // Set the precedence for the setting -- this is also a key
    // so we must exit if we cannot set this
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_PRECEDENCE,
        _Precedence);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_PRECEDENCE, hr )

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Set the time stamp on the record
    //
    {
        SYSTEMTIME CurrentTime;
        
        //
        // This does not fail
        //
        GetSystemTime( &CurrentTime );

        hr = SetValue(
            RSOP_ATTRIBUTE_CREATIONTIME,
            &CurrentTime);
        
        REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_CREATIONTIME, hr );
    }

    //
    // Set the installationtype -- basic or advanced in the UI
    //
    {
        LONG InstallationType;

        if ( _dwFlags & REDIR_SCALEABLE )
        {
            InstallationType = RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_MAX;
        }
        else
        {
            InstallationType = RDR_ATTRIBUTE_INSTALLATIONTYPE_VALUE_BASIC;
        }

        hr = SetValue(
            RDR_ATTRIBUTE_INSTALLATIONTYPE,
            InstallationType);

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_INSTALLATIONTYPE, hr )
    }
    
    //
    // Set unique id for the gpo
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_GPOID,
        _wszGPODSPath);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_GPOID, hr )

    //
    // Set the friendly name of the redirected folder
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_NAME,
        _wszDisplayName);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_NAME, hr )


    //
    // Set the scope of management that caused this
    // policy to be applied
    //
    hr = SetValue(
        RSOP_ATTRIBUTE_SOMID,
        _wszSOMId);

    REPORT_ATTRIBUTE_SET_STATUS( RSOP_ATTRIBUTE_SOMID, hr )

    //
    // The path to which the folder would be redirected
    //
    if ( ! _pGpoData->GetRsopContext()->IsReportingModeEnabled() )
    {
        if ( _wszRedirectedPath )
        {
            hr = SetValue(
                RDR_ATTRIBUTE_RESULT,
                _wszRedirectedPath);
        
            REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_RESULT, hr )
        }
    }

    //
    // In the case of a child setting with a missing parent, none of the
    // other information can be logged, since it cannot be inferred
    // from the parent (there is none)
    //

    //
    // Access grant type
    //
    hr = SetValue(
        RDR_ATTRIBUTE_GRANTTYPE,
        ( ! _bMissingAncestor ) ? (BOOL) (_dwFlags & REDIR_SETACLS) : FALSE);
    
    REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_GRANTTYPE, hr )

    //
    // Move Type
    //
    hr = SetValue(
        RDR_ATTRIBUTE_MOVETYPE,
        ( ! _bMissingAncestor ) ? (BOOL) (_dwFlags & REDIR_MOVE_CONTENTS) : FALSE);

    REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_MOVETYPE, hr )

    WCHAR* wszDefaultGroup = EVERYONE_WELLKNOWN_SID;

    //
    // Redirecting group
    //

    if ( ! _pGpoData->GetRsopContext()->IsReportingModeEnabled() )
    {
        hr = SetValue(
            RDR_ATTRIBUTE_REDIRECTING_GROUP,
            ( ! _bMissingAncestor ) ? _RedirectedSid.Buffer : wszDefaultGroup );

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_REDIRECTING_GROUP, hr )
    }

    //
    // List of security groups
    //
    hr = SetValue(
        RDR_ATTRIBUTE_GROUPS,
        ( ! _bMissingAncestor ) ? _rgwszGroups : &wszDefaultGroup,
        ( ! _bMissingAncestor ) ? _cGroups : 1);

    REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_GROUPS, hr )

    //
    // In the case of a child setting with a missing parent, we must
    // generate the resultant path from local state since policy has
    // not redirected the parent
    //

    //
    // List of redirected paths parallel to the security group list
    //
    if ( ! _bMissingAncestor )
    {
        hr = SetValue(
            RDR_ATTRIBUTE_PATHS,
            _rgwszRedirectedPaths,
            _cGroups);

        REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_PATHS, hr )
    }
    else if ( ! _pGpoData->GetRsopContext()->IsReportingModeEnabled() )
    {
        WCHAR* wszLocalInheritedPath;

        wszLocalInheritedPath = NULL;

        //
        // If this folder is set to follow its ancestor but no ancestor
        // was specified, we can still set the resulting path by
        // looking at the path to which we are redirected
        //
        hr = GenerateLocalInheritedPath(
            &wszLocalInheritedPath);

        if ( SUCCEEDED( hr ) )
        {
            hr = SetValue(
                RDR_ATTRIBUTE_RESULT,
                _rgwszGroups,
                _cGroups);

            REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_RESULT, hr )

            hr = SetValue(
                RDR_ATTRIBUTE_PATHS,
                &wszLocalInheritedPath,
                1);

            REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_PATHS, hr )
        }
    }

    //
    // Policy Removal
    //
    hr = SetValue(
        RDR_ATTRIBUTE_POLICYREMOVAL,
        (_dwFlags & REDIR_RELOCATEONREMOVE) ?
            RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REDIRECT :
            RDR_ATTRIBUTE_POLICYREMOVAL_VALUE_REMAIN);

    REPORT_ATTRIBUTE_SET_STATUS( RDR_ATTRIBUTE_POLICYREMOVAL, hr )

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GetGroupInformation
//
// Purpose: Gets gorup information from the redirection ini 
//     file data concerning the list of security groups and
//     the redirected folder for each group
//
// Params: wszGroupRedirectionData -- this data was retrieved
//     from an ini file and contains group and folder lists
// 
// Return value: S_OK if successful, error otherwise
//
// Notes:
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::GetGroupInformation(
    WCHAR* wszGroupRedirectionData)
{
    HRESULT hr;

    //
    // First, parse the file in order to count the groups.  No 
    // memory allocation is done when counting, so this should
    // always succeed
    //
    hr = ParseGroupInformation(
        wszGroupRedirectionData,
        &_cGroups);

    ASSERT(S_OK == hr);

    //
    // Allocate space for references to each group and folder
    // based on the count returned above
    //
    _rgwszGroups = new WCHAR* [_cGroups];

    _rgwszRedirectedPaths = new WCHAR* [_cGroups];

    if (!_rgwszGroups || !_rgwszRedirectedPaths)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Initialize newly allocated references
    //
    RtlZeroMemory(_rgwszGroups, sizeof(*_rgwszGroups) * _cGroups);
    RtlZeroMemory(_rgwszRedirectedPaths, sizeof(*_rgwszRedirectedPaths) * _cGroups);

    //
    // Now perform the actual copy of parsed information.  Note that this
    // will allocate space for strings for each folder and group and
    // set our vectors of references to refer to those strings.  An out of
    // memory error could occur here, so we return any error we get
    //
    hr = ParseGroupInformation(
                wszGroupRedirectionData,
                &_cGroups,
                _rgwszGroups,
                _rgwszRedirectedPaths);

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::ParseGroupInformation
//
// Purpose: parses the redirection ini file data to retrieve
//     the list of security groups and the redirected folder for
//     each group
//
// Params:
//     wszGroupRedirectionData -- this data was retrieved
//         from an ini file and contains group and folder lists. IMPORTANT : This data 
//         is distructive in the sence that the data is changed by this function.
//     pCount -- in, out param indicating # of groups / paths to retrieve.
//         on output, only has meaning if the folder and group arrays
//         are not specified -- in this case, it contains the count
//         of groups / paths so you can determine how many exist
//         before allocation.
//     rgwszGroups -- on input, contains an array of pointers
//         to c-strings.  If NULL, only a count of groups / paths
//         is performed and there is no output. 
//         On output, an allocation is made and data is copied
//         for each group. Each entry in the array
//         will be set to point to the appropriate allocated
//         string
//     rgwszPaths -- similar to above, except for target paths
// 
// Return value: S_OK if successful, error otherwise
//
// Notes: IMPORTANT: rgwszGroups and rgwszPaths are parallel
//     arrays and should be accessed as such.
//     In the case of partial allocations below due to out of memory,
//     allocated memory is cleared by the destructor.
//     The basic algorithm for the parsing is taken from another location
//     in this extension -- if that changes, so must this.
//
//     Current data format:
//
//     <group-sid1>=<redirected-filesyspath1><String terminator \0>
//     <group-sid2>=<redirected-filesyspath2><String terminator \0>
//     <group-sid3>=<redirected-filesyspath3><String terminator \0><String terminator \0>
//     ...
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::ParseGroupInformation(
    WCHAR*         wszGroupRedirectionData,
    LONG*          pCount,
    WCHAR**        rgwszGroups,
    WCHAR**        rgwszPaths)
{   
    WCHAR*  wszCurrent;
    DWORD   cchCurrent;
    DWORD   cGroups;
    HRESULT hr;

    //
    // Init locals
    //
    cGroups = 0;
    hr = S_OK;

    //
    // First, find out how many paths there are, and separate
    // the path entry into its constituents
    //
    wszCurrent = wszGroupRedirectionData;

    if (wszCurrent)
    {
        //
        // Move through the data
        //
        for (wszCurrent;
             *wszCurrent;
             wszCurrent += cchCurrent)
        {
            WCHAR* wszPath;

            //
            // Find out the length of the current entry
            //
            cchCurrent = lstrlen(wszCurrent) + 1;

            //
            // Get the path so we can validate it
            //
            wszPath = wcschr(wszCurrent, L'=');

            //
            // If no path is specified, this is an invalid entry
            //
            if (!wszPath)
            {
                continue;
            }

            //
            // Terminate the pathname, but only if we're doing copying
            //
            if (rgwszGroups)
            {
                *wszPath = L'\0';
            }

            //
            // Advance to the path past the delimiter
            //
            wszPath++;

            //
            // A blank path -- skip this
            //
            if (!*wszPath)
            {
                continue;
            }

            //
            // If the group array is specified, we need to copy the
            // group and folder information, not just count groups / paths
            //
            if (rgwszGroups)
            {
                DWORD Status;

                //
                // Copy this group
                //
                rgwszGroups[cGroups] = StringDuplicate(wszCurrent);

                if ( ! rgwszGroups[cGroups] )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                
                //
                // Copy this path
                //
                Status = GetExpandedPath(
                    _pGpoData,
                    wszPath,
                    _iFolderIndex,
                    _bHasAncestor,
                    &(rgwszPaths[cGroups]));

                //
                // In planning mode, we may get an empty string for a 
                // path if an environment variable cannot be generated,
                // so we check for that case here and simulate the error
                //
                if ( _pGpoData->GetRsopContext()->IsPlanningModeEnabled() &&
                     ( ERROR_SUCCESS == Status ) )
                {
                    if ( ! *(rgwszPaths[cGroups]) )
                    {
                        gpEvents->Report(
                            EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                            2,
                            _wszDisplayName,
                            StatusToString ( ERROR_ENVVAR_NOT_FOUND )
                            );

                        _pGpoData->SimulatePlanningError( ERROR_ENVVAR_NOT_FOUND );
                    }
                }

                if ( ERROR_SUCCESS != Status )
                {
                    hr = HRESULT_FROM_WIN32( Status );
                    break;
                }
            }

            cGroups++;
        }
    }

    //
    // Record the number of groups counted
    //
    *pCount = cGroups;

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GenerateInheritedPath
//
// Purpose: Return the name of the path that results from
//     treating this folder as a subfolder of a specific path
//
// Params:
//     pwszAncestorPath -- in parameter indicating parent folder in 
//         in which this folder should be placed
// 
//     ppwszInheritedPath -- out parameter for resulting path
// 
// Return value: S_OK if successful, error otherwise
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::GenerateInheritedPath(
    WCHAR*  pwszAncestorPath,
    WCHAR** ppwszInheritedPath)
{
    HRESULT hr;
    DWORD   cchParent;
    DWORD   cchRelative;
    size_t  sizeInheritedPath;
    
    hr = E_OUTOFMEMORY;

    //
    // Construct the folder path by adding the relative path of this
    // child to its ancestor's path
    //

    //
    // First, determine the length of the path of this folder
    // relative to its ancestor's path -- this is just the
    // localized name of the folder
    //
    cchRelative = lstrlen( _wszLocalizedName );

    cchParent = lstrlen( pwszAncestorPath );

    sizeInheritedPath = cchParent + 1 + cchRelative + 1;
    *ppwszInheritedPath = new WCHAR[sizeInheritedPath];
    
    if ( *ppwszInheritedPath )
    {
        //
        // Now, copy the ancestor's path
        //
        (void) StringCchCopy( *ppwszInheritedPath, sizeInheritedPath, pwszAncestorPath );

        //
        // Add on the path separator if one does not already exist at the end of the ancestor path
        //
        if ( ( cchParent != 0 ) && 
             ( L'\\' != pwszAncestorPath[ cchParent - 1] ) )
        {
            (void) StringCchCat( *ppwszInheritedPath, sizeInheritedPath, L"\\" );
        }

        //
        // Now append this child's relative path to its ancestor
        //
        (void) StringCchCat( *ppwszInheritedPath, sizeInheritedPath, _wszLocalizedName );

        hr = S_OK;
    }
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GenerateInheritedPath
//
// Purpose: Return the name of the path that results from
//     treating this folder as a subfolder of the path
//     to which this folder's parent is redirected
//
// Params:
//
//     ppwszInheritedPath -- out parameter for resulting path
// 
// Return value: S_OK if successful, error otherwise
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::GenerateLocalInheritedPath(
    WCHAR** ppwszInheritedPath )
{
    HRESULT        hr;
    int            iAncestor;
    CRedirectInfo* pAncestorInfo;
    WCHAR          wszFolderKey [ TARGETPATHLIMIT ];
    WCHAR          wszInheritedFolder [ TARGETPATHLIMIT ];

    hr = S_OK;

    iAncestor = GetAncestorIndex();

    pAncestorInfo = & ( gPolicyResultant[ iAncestor ] );

    hr = StringCchCopy( wszFolderKey, TARGETPATHLIMIT, pAncestorInfo->m_szFolderRelativePath );
    if ( FAILED(hr) )
    {
        return hr;
    }
    hr = StringCchCat( wszFolderKey, TARGETPATHLIMIT, L"\\" );
    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( _pGpoData->GetRsopContext()->IsDiagnosticModeEnabled() )
    { 
        DWORD Status;

        Status = _pGpoData->GetLocalFilePath(
            wszFolderKey,
            wszInheritedFolder);

        hr = HRESULT_FROM_WIN32( Status );
    }
    else
    {
        hr = StringCchCopy( wszInheritedFolder, TARGETPATHLIMIT, L"%USERPROFILE%\\" );
        if ( FAILED(hr) )
        {
            return hr;
        }
        hr = StringCchCat( wszInheritedFolder, TARGETPATHLIMIT, wszFolderKey );
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = GenerateInheritedPath(
            wszInheritedFolder,
            ppwszInheritedPath);
    }
    
    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::CopyInheritedData
//
// Purpose: Copies data that should be inherited from an ancestor
//          to the object
//
// Params:
//     pAncestralPolicy -- pointer to CRedirectionPolicy representing
//         the policy for the ancestor folder
// 
// Return value: S_OK if successful, error otherwise.
//
// Notes: 
//
//     If a folder is set to inherit from its parent, the
//     following attributes must be copied from the parent:
//
//         - Security Groups
//         - Redirection target paths
//         - The number of groups / paths
//         - Flags
//
//     This method copies those attributes from an ancestor
//     to this object
//
//------------------------------------------------------------
HRESULT CRedirectionPolicy::CopyInheritedData( CRedirectionPolicy* pAncestralPolicy )
{
    LONG    iGroup;
    LONG    cGroups;
    HRESULT hr;

    //
    // If we have no ancestor, then the only ancestral information
    // we can copy is the redirected path
    //
    if ( ! pAncestralPolicy )
    {
        _bMissingAncestor = TRUE;

        hr = GenerateLocalInheritedPath(
            &_wszRedirectedPath);

        return hr;
    }

    //
    // Copy the redirecting group information first -- it 
    // will only be there if the user would have gotten
    // this folder, so do not try to copy it if it is not there
    //
    if ( pAncestralPolicy->_RedirectedSid.Buffer )
    {
        BOOLEAN fAllocatedString;

        fAllocatedString = RtlCreateUnicodeString(
            &_RedirectedSid,
            pAncestralPolicy->_RedirectedSid.Buffer);

        if ( !fAllocatedString )
        {
            return E_OUTOFMEMORY;
        }

        RtlCopyUnicodeString(
            &_RedirectedSid,
            &(pAncestralPolicy->_RedirectedSid));

        hr = GenerateInheritedPath(
            pAncestralPolicy->_wszRedirectedPath,
            &_wszRedirectedPath);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Find out how many groups / paths there are
    //
    cGroups = pAncestralPolicy->_cGroups;
    iGroup = 0;
    _rgwszGroups = NULL;
    _rgwszRedirectedPaths = NULL;

    //
    // Allocate space for the security groups
    //
    _rgwszGroups = new WCHAR* [ cGroups ];

    hr = E_OUTOFMEMORY;

    if ( _rgwszGroups )
    {
        //
        // Now allocate space for the target paths
        //
        _rgwszRedirectedPaths = new WCHAR* [ cGroups ];

        if ( _rgwszRedirectedPaths )
        {
            hr = S_OK;

            //
            // Now allocate copies of each security group and
            // redirected target path
            //
            for ( iGroup = 0; iGroup < cGroups; iGroup ++ )
            {
                DWORD cchParent;

                //
                // Construct the folder path by adding the relative path of this
                // child to its ancestor's path
                //

                //
                // First, copy the ancestor's path
                //
                hr = GenerateInheritedPath(
                    pAncestralPolicy->_rgwszRedirectedPaths[ iGroup ],
                    &( _rgwszRedirectedPaths[ iGroup ] )
                    );
                
                if ( FAILED( hr ) )
                {
                    break;
                }

                //
                // Security group is much simpler -- just copy it
                //
                _rgwszGroups[ iGroup ] = StringDuplicate(
                    pAncestralPolicy->_rgwszGroups[ iGroup ]);

                if ( ! _rgwszGroups[ iGroup ] )
                {
                    // Clean up at least this iteration
                    delete [] _rgwszRedirectedPaths[ iGroup ];
                    
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
        }
    }

    //
    // Copy the flags
    //
    _dwFlags = pAncestralPolicy->_dwFlags;

    //
    // If we're successful, set the # of groups. We only set this on
    // success so that we don't write out an incomplete set
    //
    if ( SUCCEEDED( hr ) )
    {
        _cGroups = cGroups;
    }
    // Otherwise we must clean up any memory we used ...
    else
    {
        LONG iCleanupGroup;
        for ( iCleanupGroup = 0; iCleanupGroup < iGroup; iCleanupGroup++ )
        {
            delete [] _rgwszGroups[ iCleanupGroup ];
            delete [] _rgwszRedirectedPaths[ iCleanupGroup ];
        }

        delete [] _rgwszGroups;
        _rgwszGroups = NULL;
        delete [] _rgwszRedirectedPaths;
        _rgwszRedirectedPaths = NULL;

        _cGroups = 0;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GetFolderIndex
//
// Purpose: Retrieves a numeric index representing the folder
//          (startup, mydocs, etc)
//
// Params: none
// 
// Return value: index of the folder redirected by this policy
//
// Notes: 
//
//------------------------------------------------------------
int CRedirectionPolicy::GetFolderIndex()
{
    return _iFolderIndex;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::GetAncestorIndex
//
// Purpose: Retrieves a numeric index representing the ancestor
//          of this folder
//
// Params: none
// 
// Return value: index of the ancestor of the folder redirected
//     by this policy
//
// Notes: 
//
//------------------------------------------------------------
int CRedirectionPolicy::GetAncestorIndex()
{
    return _iAncestorIndex;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::HasAncestor
//
// Purpose: Indicates whether or not the folder redirected by
//     this policy has an ancestor folder
//
// Params: none
// 
// Return value: TRUE if the folder redirected by this policy
//     has an ancestor, FALSE if not
//
// Notes: 
//
//------------------------------------------------------------
BOOL CRedirectionPolicy::HasAncestor()
{
    return _bHasAncestor;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::HasInheritedData
//
// Purpose: Indicates whether or not the folder redirected by
//     this policy should inherit data from its ancestor
//
// Params: none
// 
// Return value: TRUE if the folder redirected by this policy
//     should inherit data from an ancestor, FALSE if not
//
// Notes: 
//
//------------------------------------------------------------
BOOL CRedirectionPolicy::HasInheritedData()
{
    //
    // If the policy lists no groups / target paths, then
    // it must obtain them from a parent
    //
    return 0 == _cGroups;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::NormalizePrecedence
//
// Purpose: Normalize precedence according the scale passed in
//
// Params: 
//     lScale - indicates what value should be considered the 
//     highest priority, and then priority is reversed based on this --
//     e.g. if 5 is the scale, an object with precedence 5
//     will become precedence 1 (the most important) when this
//     function is called.  The object with precedence 1
//     will have value 5, the least significant, and intervening
//     values will behave accordingly
// 
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
void CRedirectionPolicy::NormalizePrecedence( LONG Scale )
{
    //
    // Reverse the precedence -- switch it from highest values
    // are most important to the reverse
    //
    _Precedence = Scale - _Precedence + 1;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionPolicy::IsRedirected()
//
// Purpose: Normalize precedence according the scale passed in
//
// Params: 
//     none
// 
// Return value: TRUE if the folder is currently 
//     successfully redirected, FALSE if not
//
// Notes: 
//
//------------------------------------------------------------
BOOL CRedirectionPolicy::IsRedirected()
{
    DWORD Status;

    //
    // Check the global state to see if this folder
    // has been successfully redirected
    //
    Status = gPolicyResultant[ _iFolderIndex ].m_StatusRedir;

    return ERROR_SUCCESS == Status;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPrecedenceState::CPrecedenceState
//
// Purpose: Constructor for CPrecedenceState class
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CPrecedenceState::CPrecedenceState()
{
    RtlZeroMemory(_rgFolderPrecedence, sizeof(_rgFolderPrecedence));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPrecedenceState::UpdateFolderPrecedence
//
// Purpose: Changes the precedence of the winning folder specified by
//     the index
//
// Params:
//     iFolder -- index of folder whose precedence we are updating
//
// Return value: returns the new precedence of the folder
//
// Notes: 
//
//------------------------------------------------------------
LONG CPrecedenceState::UpdateFolderPrecedence( int iFolder )
{
    //
    // Increase the precedence of the winning folder
    //
    return ++ ( _rgFolderPrecedence[ iFolder ] );
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CPrecedenceState::GetFolderPrecedence
//
// Purpose: Retrieves the precedence of the folder specified by
//     the index
//
// Params:
//     iFolder -- index of folder whose precedence we are
//     retrieving
//
// Return value: returns the current precedence of the folder
//
// Notes: 
//
//------------------------------------------------------------
LONG CPrecedenceState::GetFolderPrecedence( int iFolder )
{
    return _rgFolderPrecedence[ iFolder ];
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::AddRedirectionPolicies
//
// Purpose: Appends candidate policies to the list of
//     redirection candidates
//
// Params:
//     pGpoData -- pointer to information concerning the gpo
//     from which the redirection candidate came
//     pRedirectionInfo -- pointer to array candidate policies 
//     (one for each folder that can be redirected) to
//     append to the list
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//      IMPORTANT: this method is designed to be called
//      multiple times and aggregate state across calls.  The 
//      order in which calls occur is important -- each gpo
//      passed in must be greater than the gpo passed
//      in the previous call.  Or put another way, this
//      method should be called in order of least precedent gpo
//      to most.  This is necessary in order for the precedence
//      calculations to be correct
//
//------------------------------------------------------------
HRESULT CRedirectionLog::AddRedirectionPolicies(
    CFileDB*          pGpoData,
    CRedirectInfo*    pRedirectionInfo)
{
    DWORD               iRedirect;

    ASSERT( _pRsopContext->IsRsopEnabled() );

    //
    // For each folder that could be redirected, we'll check to see
    // if it gets redirected, and add it to the list if so
    //
    for (iRedirect = 0 ; iRedirect < EndRedirectable; iRedirect++)
    {
        LONG                Precedence;
        CRedirectionPolicy* pNewRedirection;

        //
        // Check to see if this is redirected
        //
        if ( pRedirectionInfo[ iRedirect ].HasPolicy() )
        {
            HRESULT hr;

            //
            // We do not support the Programs and Startup folders --
            // we used to and the core code continues to include
            // them in its data structures.  We should ignore these folders
            // if we see them
            //
            if ( ( Programs == pRedirectionInfo[ iRedirect ].GetFolderID() ) ||
                 ( Startup == pRedirectionInfo[ iRedirect ].GetFolderID() ) )
            {
                continue;
            }

            //
            // Update the folder's precedence since we found a candidate
            //
            Precedence = _PrecedenceState.UpdateFolderPrecedence( iRedirect );

            //
            // Create an abstraction of the redirection candidate policy
            //
            pNewRedirection = new CRedirectionPolicy(
                pGpoData,
                &(pRedirectionInfo[iRedirect]),
                Precedence,
                &hr);

            if ( ! pNewRedirection )
            {
                hr = E_OUTOFMEMORY;
            }

            if ( FAILED(hr) )
            {
                _pRsopContext->DisableRsop( hr );
                return hr;
            }

            //
            // Add it to the list of redirections
            //
            *_ppNextRedirection = pNewRedirection;
            _ppNextRedirection = &(pNewRedirection->_pNext);
        }
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::NormalizePrecedence
//
// Purpose: Normalize a redirection's precedence according
//     to its relationship with redirections from other gpo's
//
// Params:
//     pRedirectionPolicy -- redirection policy candidate to
//     be normalized
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
void CRedirectionLog::NormalizePrecedence( CRedirectionPolicy* pRedirectionPolicy )
{
    int iFolder;

    //
    // Find the folder index for the redirected candidate
    //
    iFolder = pRedirectionPolicy->GetFolderIndex();

    //
    // Now use the winning precedence as the scale to normalize
    // this candidate
    //
    pRedirectionPolicy->NormalizePrecedence(
        _PrecedenceState.GetFolderPrecedence( iFolder ) );
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::WriteRsopLog
//
// Purpose: Creates an rsop log of all the redirection information
//     for the current user
//
// Params: none
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CRedirectionLog::WriteRsopLog()
{
    CRedirectionPolicy* pCurrent;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    //
    // Clear any existing log before writing out redirection results
    //
    ClearRsopLog();

    //
    // Iterate through the list of redirection candidates
    //
    for (pCurrent = _pRedirectionList;
         pCurrent;
         pCurrent = (CRedirectionPolicy*) pCurrent->_pNext)
    {
        //
        // Normalize the precedence of this candidate with
        // respect to other redirections
        //
        NormalizePrecedence( pCurrent );

        //
        // Add in any ancestral policy data
        //
        (void) AddAncestralPolicy( pCurrent );    

        //
        // Write the record to the database
        //
        if ( pCurrent->IsRedirected() )
        {
            WriteNewRecord(pCurrent);
        }
    }

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::GetAncestor
//
// Purpose: returns the candidate redirection that is redirecting
//     the folder that is the ancestor of the specified redirection
//     candidate
//
// Params: pRedirectionPolicy -- redirection whose candidate
//     redirection ancestor we wish to retrieve
//
// Return value: reference to redirection policy candidate
//
// Notes: 
//
//------------------------------------------------------------
CRedirectionPolicy* CRedirectionLog::GetAncestor(
    CRedirectionPolicy* pRedirectionPolicy )
{
    int                 iFolder;
    CRedirectionPolicy* pAncestor;
    CRedirectionPolicy* pCurrent;

    pAncestor = NULL;

    //
    // First, determine which folder is the ancestor of the
    // specified redirection
    //
    iFolder = pRedirectionPolicy->GetAncestorIndex();

    //
    // Iterate trhough the list -- it is sorted, with
    // the highest gpo last, and ancestors always
    // appear before children -- we want to find the
    // highest ancestor 
    //
    for (pCurrent = _pRedirectionList;
         pCurrent;
         pCurrent = (CRedirectionPolicy*) pCurrent->_pNext)
    {
        //
        // Remember the last ancestor we've seen
        //
        if ( iFolder == pCurrent->GetFolderIndex() )
        {
            pAncestor = pCurrent;
        }
    }

    //
    // Now return the ancestor that is currently highest
    // without violating the gpo precedence of the child setting
    //
    return pAncestor;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::AddAncestralPolicy
//
// Purpose: causes a redirection candidate to inherit settings
//     from an ancestor folder (if it has one) if inheritance
//     is specified in the policy
//
// Params: pRedirectionPolicy -- redirection to which we want
//     to which we want to add ancestor's policy settings
//
// Return value: S_OK if successful, error otherwise
//
// Notes: 
//
//------------------------------------------------------------
HRESULT CRedirectionLog::AddAncestralPolicy( CRedirectionPolicy* pRedirectionPolicy)
{
    HRESULT hr;

    CRedirectionPolicy* pAncestorPolicy;

    //
    // See if this redirection has inherited data
    //
    if ( ! pRedirectionPolicy->HasInheritedData() )
    {
        return S_OK;
    }

    //
    // If this policy doesn't have an ancestor, then we're done
    //
    if ( ! pRedirectionPolicy->HasAncestor() )
    {
        return S_OK;
    }

    //
    // This policy has an ancestor -- retrieve it
    //
    pAncestorPolicy = GetAncestor( pRedirectionPolicy );

    //
    // Inherit settings from the ancestor
    //
    hr = pRedirectionPolicy->CopyInheritedData( pAncestorPolicy );

    return hr;
}


HRESULT CRedirectionLog::AddPreservedPolicy( WCHAR* wszFolderName )
{
    DWORD   cchLen;
    WCHAR*  wszNewQuery;
    HRESULT hr = S_OK;

    if ( ! _pRsopContext->IsRsopEnabled() )
    {
        return S_OK;
    }

    cchLen = lstrlen( wszFolderName );

    cchLen += sizeof( WQL_INSTANCE ) / sizeof( WCHAR ) +
        sizeof( WQL_AND ) / sizeof( WCHAR );

    if ( _wszDeletionQuery )
    {
        cchLen += lstrlen( _wszDeletionQuery );
    }
    
    wszNewQuery = new WCHAR [ cchLen ];

    if ( ! wszNewQuery )
    {
        return E_OUTOFMEMORY;
    }

    if ( _wszDeletionQuery )
    {
        (void) StringCchCopy( wszNewQuery, cchLen, _wszDeletionQuery );
        (void) StringCchCat( wszNewQuery, cchLen, WQL_AND );
    }
    else
    {
        *wszNewQuery = L'\0';
    }

    hr = StringCchPrintf( wszNewQuery + lstrlen( wszNewQuery ),
                          cchLen - lstrlen( wszNewQuery ),
                          WQL_INSTANCE,
                          wszFolderName );
    if ( SUCCEEDED(hr) )
    {
        delete [] _wszDeletionQuery;
        _wszDeletionQuery = wszNewQuery;
    }
    else
    {
        delete [] wszNewQuery;
    }
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::CRedirectionLog
//
// Purpose: constructor for class CRedirectionLog
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CRedirectionLog::CRedirectionLog() :
    _pRedirectionList(NULL),
    _ppNextRedirection(&_pRedirectionList),
    _wszDeletionQuery( NULL ),
    _SimulatedStatus( ERROR_SUCCESS )
{}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::~CRedirectionLog
//
// Purpose: destructor for class CRedirectionLog.
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
CRedirectionLog::~CRedirectionLog()
{
    CRedirectionPolicy* pCurrent;
    CRedirectionPolicy* pNext;

    for (pCurrent = _pRedirectionList;
         pCurrent;
         pCurrent = pNext)
    {
        pNext = (CRedirectionPolicy*) pCurrent->_pNext;

        delete pCurrent;
    }

    delete [] _wszDeletionQuery;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::InitRsop
//
// Purpose: Initializes rsop logging
//
// Params: pRsopContext -- logging contxt
//         bForceRsop -- TRUE if we should bind to a namespace
//             in the absence of an existing namespace in this context
//
//
// Return value: none
//
// Notes: 
//
//    Success of initialization is stored internally -- rsop
//    is disabled if there's a failure
//
//------------------------------------------------------------
void CRedirectionLog::InitRsop( CRsopContext* pRsopContext, BOOL bForceRsop )
{
    HRESULT    hr;

    //
    // If the caller needs us to bind to a saved namespace because
    // the gp engine did not pass one in and we need to log new data,
    // do so.
    //
    if ( bForceRsop )
    {
        (void) pRsopContext->InitializeSavedNameSpace();
    }

    //
    // Initialize Rsop logging
    //
    hr = InitLog( pRsopContext, RSOP_REDIRECTED_FOLDER );

    if (FAILED(hr))
    {
        pRsopContext->DisableRsop( hr );
        return;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::ClearRsopLog
//
// Purpose: Clears the namespace of records
//
// Params: none
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
void CRedirectionLog::ClearRsopLog()
{
    HRESULT hr;

    //
    // Nothing to do if logging is not enabled
    //
    if (! _pRsopContext->IsRsopEnabled() )
    {
        return;
    }

    //
    // Attempt to clear the log
    //
    hr = ClearLog( _wszDeletionQuery );

    //
    // If we cannot clear it, disable logging
    //
    if (FAILED(hr))
    {
        _pRsopContext->DisableRsop( hr );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::SimluatePlanningError
//
// Purpose: During planning mode, we may be able to detect
//          a situation that would result in an error
//          if policy application were attempted on a real client --
//          this function simulates a specific Win32 error
//
// Params: Status
//
// Return value: none
//
// Notes: 
//
//------------------------------------------------------------
void CRedirectionLog::SimulatePlanningError( DWORD Status )
{
    if ( ERROR_SUCCESS == _SimulatedStatus )
    {
        _SimulatedStatus = Status;
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: CRedirectionLog::GetPlanningSimulatedErrorIfNecessary
//
// Purpose: During planning mode, we may be able to detect
//          a situation that would result in an error
//          if policy application were attempted on a real client --
//          this function retrieves such a simulated error, but
//          only if it does not "override" the Status code
//          passed in
//
// Params: Status
//
// Return value: The error status with the highest precedence
//
// Notes: 
//
//------------------------------------------------------------
DWORD CRedirectionLog::GetPlanningSimulatedErrorIfNecessary( DWORD Status )
{
    DWORD PreferredStatus;

    PreferredStatus = Status;

    if ( ERROR_SUCCESS == Status )
    {
        PreferredStatus = _SimulatedStatus;
    }

    return PreferredStatus;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Function: StringDuplicate
//
// Purpose: Simple duplication of a c-string
//
// Params: wszOriginal -- string to be duplicated
//
// Return value: reference to allocated duplicate string if 
//     successful, NULL on failure
//
// Notes:  returned string should be freed by caller with
//     vector delete
//
//------------------------------------------------------------
WCHAR* StringDuplicate(WCHAR* wszOriginal)
{
    WCHAR* wszNew;
    DWORD  cchSize;

    ASSERT(wszOriginal);

    //
    // Determine original size
    //
    cchSize = lstrlen(wszOriginal) + 1;

    //
    // Allocate the space for the duplicate
    //
    wszNew = new WCHAR[ cchSize ];

    //
    // Duplicate to the new allocation if
    // the allocation was successful
    //
    if (wszNew) 
    {
        (void) StringCchCopy(wszNew, cchSize, wszOriginal);
    }

    return wszNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\redir.cxx ===
/*++




Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 1998

Module Name:

    redir.cxx

Abstract:
    This module contains the implementation for the members of the class
    CRedirInfo which is used to consolidate redirection information from all
    the policies applied to a particular GPO and then finally do the redirection
    for the policy with the highest precedence.

Author:

    Rahul Thombre (RahulTh) 8/11/1998

Revision History:

    8/11/1998   RahulTh         Created this module.

--*/

#include "fdeploy.hxx"

//initialize some global variables
WCHAR * g_szRelativePathNames[] =
{
    L"Desktop",
    L"My Documents",
    L"My Documents\\My Pictures",
    L"Start Menu",
    L"Start Menu\\Programs",
    L"Start Menu\\Programs\\Startup",
    L"Application Data"
};

WCHAR * g_szDisplayNames[] =
{
    L"Desktop",
    L"My Documents",
    L"My Pictures",
    L"Start Menu",
    L"Programs",
    L"Startup",
    L"Application Data"
};
//above: use the same order and elements as in REDIRECTABLE

//global variables.
const int g_lRedirInfoSize = (int) EndRedirectable;
//static members of the class
int CRedirectInfo::m_idConstructor = 0;

CRedirectInfo gPolicyResultant [g_lRedirInfoSize];
CRedirectInfo gDeletedPolicyResultant [g_lRedirInfoSize];
CRedirectInfo gAddedPolicyResultant [g_lRedirInfoSize];

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::CRedirectInfo
//
//  Synopsis:   Constructor for the class
//
//  Arguments:
//
//  Returns:
//
//  History:    8/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CRedirectInfo::CRedirectInfo ()
{
    m_rID = (REDIRECTABLE)(m_idConstructor);   //assign IDs sequentially.
    m_idConstructor = (m_idConstructor + 1) %  ((int)EndRedirectable);
    
    m_pSid = NULL;
    m_szLocation = NULL;
    m_cbLocSize = 0;
    m_szGroupRedirectionData = NULL;

    ResetMembers ();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::~CRedirectInfo
//
//  Synopsis:   destructor
//
//  Arguments:
//
//  Returns:
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CRedirectInfo::~CRedirectInfo ()
{
    FreeAllocatedMem ();
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::FreeAllocatedMem
//
//  Synopsis:   frees memory allocated for member vars.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirectInfo::FreeAllocatedMem (void)
{
    if (m_szLocation)
    {
        delete [] m_szLocation;
        m_szLocation = NULL;
        m_cbLocSize = 0;
    }

    if (m_pSid)
    {
        delete [] ((BYTE *)m_pSid);
        m_pSid = NULL;
    }

    if (m_szGroupRedirectionData)
    {
        delete [] m_szGroupRedirectionData;
        m_szGroupRedirectionData = NULL;        
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::ResetMembers
//
//  Synopsis:   resets the members of the class to their default values.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      static members of a class, like other global variables are
//              initialized only when the dll is loaded. So if this dll
//              stays loaded across logons, then the fact that the globals
//              have been initialized based on a previous logon can cause
//              problems. Therefore, this function is used to reinitialize
//              the globals.
//
//---------------------------------------------------------------------------
void CRedirectInfo::ResetMembers(void)
{
    FreeAllocatedMem ();
    
    m_iRedirectingGroup = 0;
    
    //defaults. are changed later on based on the state of this object.
    m_bFollowsParent = FALSE;
    m_bRedirectionAttempted = FALSE;
    m_StatusRedir = ERROR_SUCCESS;
    m_bValidGPO = FALSE;
    m_szGPOName[0] = L'\0';

    (void) StringCbCopy(m_szFolderRelativePath, sizeof(m_szFolderRelativePath), g_szRelativePathNames [(int) m_rID]);
    (void) StringCbCopy(m_szDisplayName, sizeof(m_szDisplayName), g_szDisplayNames [(int) m_rID]);

    m_fDataValid = FALSE;
    m_cbLocSize = 256;   //start with a random amount
    m_szLocation = new WCHAR [m_cbLocSize];
    if (m_szLocation)
    {
        m_szLocation[0] = '\0';
    }
    else
    {
        m_cbLocSize = 0; //don't worry right now if memory cannot be allocated here, we will fail later
    }
    //set the parent and child pointers for the special parent/descendants
    m_pChild = NULL;    //start with defaults
    m_pParent = NULL;
    switch (m_rID)
    {
    case MyDocs:
        m_pChild = this - (int) m_rID + (int) MyPics;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case MyPics:
        m_pParent = this - (int) m_rID + (int) MyDocs;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case StartMenu:
        m_pChild = this - (int) m_rID + (int) Programs;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case Programs:
        m_pParent = this - (int) m_rID + (int) StartMenu;
        m_pChild = this - (int) m_rID + (int) Startup;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case Startup:
        m_pParent = this - (int) m_rID + (int) Programs;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case Desktop:
        m_pChild = NULL;
        m_pParent = NULL;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    case AppData:
        m_pChild = NULL;
        m_pParent = NULL;
        m_dwFlags = REDIR_DONT_CARE;
        break;
    }

    //as a safety mechanism, load localized folder names if ghDllInstance
    //has been set. note: ghDllInstance won't be set for global variables
    //since their constructors before DllMain. For such variables, the
    //localized names have to be called explicitly from some other function
    //which is called after DllMain.
    if (ghDllInstance)
        LoadLocalizedNames();

    //
    // No need to modify m_rID or m_idConstructor. The construct has already
    // taken care of it and touching them might cause undesirable results if
    // not done in the proper order. Besides, these don't change across multiple
    // sessions.
    //
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetFolderIndex
//
//  Synopsis:   a static member function that, given the name of a special
//              folder, returns its id which can be used to locate the
//              redirection info. for that particular folder.
//
//  Arguments: [in][szFldrName : the name of the folder as stored in fdeploy.ini
//
//  Returns: the id of the folder. If the folder is not redirectable, the
//           function returns EndRedirectable.
//
//  History:    8/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
REDIRECTABLE CRedirectInfo::GetFolderIndex (LPCTSTR szFldrName)
{
    int i;
    for (i = 0; i < (int)EndRedirectable; i++)
    {
        if (0 == lstrcmpi (szFldrName, g_szDisplayNames[i]))
            break;  //we have found a match
    }

    return (REDIRECTABLE)i;   //if a match was not found above, i == EndRedirectable
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::LoadLocalizedNames
//
//  Synopsis:   loads the localized folder display names and folder relative
//              paths from the resources.
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS if the names were successfully loaded.
//              an error code describing the cause of the failure otherwise.
//
//  History:    5/6/1999  RahulTh  created
//
//  Notes:      we cannot do this in the constructor because ghDllInstance
//              is not initialized at that time and therefore LoadString will
//              fail. This is because DllMain is called after the constructors.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::LoadLocalizedNames (void)
{
    UINT    DisplayID = 0;
    UINT    RelpathID = 0;

    switch (m_rID)
    {
    case MyDocs:
        DisplayID = RelpathID = IDS_MYDOCS;
        break;
    case MyPics:
        DisplayID = IDS_MYPICS;
        RelpathID = IDS_MYPICS_REL;
        break;
    case StartMenu:
        DisplayID = RelpathID = IDS_STARTMENU;
        break;
    case Programs:
        DisplayID = IDS_PROGRAMS;
        RelpathID = IDS_PROGRAMS_REL;
        break;
    case Startup:
        DisplayID = IDS_STARTUP;
        RelpathID = IDS_STARTUP_REL;
        break;
    case Desktop:
        DisplayID = RelpathID = IDS_DESKTOP;
        break;
    case AppData:
        DisplayID = RelpathID = IDS_APPDATA;
        break;
    default:
        ASSERT("Unknown folder id" && NULL);
        break;
    }

    //now get the localized name of the folder and the localized relative
    //path names (w.r.t. the userprofile directory)
    m_szLocDisplayName[0] = m_szLocFolderRelativePath[0] = '\0';   //safety

    if (!LoadString (ghDllInstance, DisplayID, m_szLocDisplayName, 80))
        return GetLastError();

    if (DisplayID == RelpathID)
    {
        return HRESULT_CODE(StringCbCopy(m_szLocFolderRelativePath, sizeof(m_szLocFolderRelativePath), m_szLocDisplayName));    //top level folders
    }
    else
    {
        if (LoadString (ghDllInstance, RelpathID, m_szLocFolderRelativePath, 80))   //special descendant folders
        {
            return ERROR_SUCCESS;
        }
        else
        {
            return GetLastError();
        }
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GatherRedirectionInfo
//
//  Synopsis:   this function gathers redirection info. from the ini file
//
//  Arguments:  [in] pFileDB : pointer to the CFileDB object that called it
//              [in] dwFlags : the flags as obtained from the ini file
//              [in] bRemove : whether this is a policy that is being removed
//
//  Returns:    STATUS_SUCCESS if successful. An error code otherwise.
//
//  History:    8/11/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::GatherRedirectionInfo (CFileDB * pFileDB, DWORD dwFlags, BOOL bRemove)
{
    DWORD   Status = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    DWORD   len;
    BOOL    bStatus;
    WCHAR * pwszSection = 0;
    BOOL    bFoundGroup;
    WCHAR * pwszString = 0;
    WCHAR * pwszSid = 0;
    WCHAR * pwszPath = 0;
    PSID    Sid = NULL;

    if (bRemove &&
        (!gSavedSettings[m_rID].m_bValidGPO ||
         (0 != _wcsicmp (pFileDB->_pwszGPOUniqueName, gSavedSettings[m_rID].m_szGPOName))
        )
       )
    {
        DebugMsg((DM_VERBOSE, IDS_IGNORE_DELETEDGPO, pFileDB->_pwszGPOName, pFileDB->_pwszGPOUniqueName, m_szLocDisplayName));
        Status = ERROR_SUCCESS;
        //set default values on the members just to be on the safe side.
        m_fDataValid = FALSE;
        m_dwFlags = REDIR_DONT_CARE;
        m_bValidGPO = FALSE;
        m_szGPOName[0] = L'\0';
        goto GatherInfoEnd;
    }

    //the data is valid. This function is only called when something relevant is found in the ini file.
    m_fDataValid = TRUE;

    //store the flags
    m_dwFlags = dwFlags;

    //store the GPO's unique name
    if (bRemove)
    {
        m_bValidGPO = FALSE;    //for redirection resulting from a removed GPO, we do not store the GPO name to avoid processing a removal twice
        m_szGPOName[0] = L'\0';
    }
    else
    {
        m_bValidGPO = TRUE;
        (void) StringCbCopy(m_szGPOName, sizeof(m_szGPOName), pFileDB->_pwszGPOUniqueName);
    }

    //there is nothing to do if policy is not specified for this folder
    if (m_dwFlags & REDIR_DONT_CARE)
        goto GatherInfoSuccess;

    m_bRemove = bRemove;

    //also, we can do nothing right now if this is a special descendant folder
    //following its parent
    if (m_dwFlags & REDIR_FOLLOW_PARENT)
        goto GatherInfoSuccess;

    //a location has been specified by this policy

    if ( ! pFileDB->GetRsopContext()->IsPlanningModeEnabled() )
    {
        //we must have a list of groups to which the user belongs
        //each user must at least have everyone as one of his groups
        if (! pFileDB->_pGroups)
            goto GatherInfoErr;
    }

    DWORD cchSectionLen;

    bStatus = pFileDB->ReadIniSection (m_szDisplayName, &pwszSection, &cchSectionLen);

    if (!bStatus)
        goto GatherInfoErr;

    bFoundGroup = FALSE;

    //
    // For rsop, we need to know the list of security groups
    // and redirected paths -- we'll copy this information for
    // use by the rsop logging code
    //
    if (pFileDB->GetRsopContext()->IsRsopEnabled())
    {
        //
        // Note that when we do the copy, the size returned
        // by ReadIniSection above does not include the null terminator,
        // even though thaft character is present, so we must add that character
        // to the count ourselves. 
        //
        m_szGroupRedirectionData = new WCHAR[cchSectionLen + 1];

        if (m_szGroupRedirectionData)
        {
            RtlCopyMemory(m_szGroupRedirectionData,
                          pwszSection,
                          ( cchSectionLen + 1 ) * sizeof(*pwszSection));
        }
        else
        {
            pFileDB->GetRsopContext()->DisableRsop( E_OUTOFMEMORY );
        }
    }

    if ( ! pFileDB->GetRsopContext()->IsReportingModeEnabled() )
    {
        DWORD iGroup;

        iGroup = 0;

        for (pwszString = pwszSection;
             *pwszString;
             pwszString += lstrlen(pwszString) + 1)
        {
            pwszSid = pwszString;
            pwszPath = wcschr (pwszString, L'=');
            if (!pwszPath)
                continue;   //skip any invalid entries

            //temporarily break up the sid and the path
            *pwszPath++ = L'\0';

            if (! *pwszPath)
            {
                //again an invalid path. restore the = sign and move on
                pwszPath[-1] = L'=';    //note: we had advanced the pointer above
                continue;
            }

            //the entry is valid
            bFoundGroup = GroupInList (pwszSid, pFileDB->_pGroups);

            if (bFoundGroup)
            {
                m_iRedirectingGroup = iGroup;

                break;      //we have found a group, so break out of the loop
            }
            else
            {
                //restore the '=' sign, and try the next group
                pwszPath[-1] = L'='; //note: we had advanced the pointer above
            }
            
            iGroup++;
        }
    }
    else
    {
        //
        // In reporting mode, we treat every folder as if it applies so
        // that we can report on all settings in the GPO
        //
        bFoundGroup = TRUE;
    }
     
    if (!bFoundGroup)
    {
        //no group was found, so treat this as a don't care
        m_dwFlags = REDIR_DONT_CARE;
    }
    else if ( ! pFileDB->GetRsopContext()->IsReportingModeEnabled() )
    {
        //first store the sid
        if (m_pSid)
            delete [] ((BYTE*) m_pSid);     //m_pSid is always allocated from our heap, so never use RtlFreeSid

        m_pSid = NULL;

        if (!m_bRemove)
            Status = AllocateAndInitSidFromString (pwszSid, &Sid);
        else
            Status = AllocateAndInitSidFromString (L"S-1-1-0", &Sid);    //if this is a removed policy, we set the SID to Everyone -- so that when we look at the saved settings at a later time, we shouldn't have to process the policy again (see code for NeedsProcessing)

        if (ERROR_SUCCESS != Status)
            goto GatherInfoEnd;

        if (m_pSid)
            delete [] ((BYTE*) m_pSid);
        Status = MySidCopy (&m_pSid, Sid);  //we want to always allocate memory for this sid from our heap
        RtlFreeSid (Sid);   //cleanup. must take place before the following check

        if (ERROR_SUCCESS != Status)
            goto GatherInfoEnd;

        //we have found a group
        DebugMsg ((DM_VERBOSE, IDS_GROUP_MEMBER, pwszSid, pwszPath));
        SimplifyPath (pwszPath);
        
        //
        // Copy the location
        // Use X:\ for paths of the form X: to avoid problems during the file
        // copy phase.
        //
        BOOL bAppendSlash = FALSE;
        len = lstrlen (pwszPath);
        if (2 == len && L':' == pwszPath[1])
        {
            bAppendSlash = TRUE;
            len++;  // Ensure that the extra backslash at the end is accounted for in length calculations.
        }
        
        if (m_cbLocSize <= len)
        {    
            //we need to reallocate memory for the location
            if (m_cbLocSize)
                delete [] m_szLocation;

            m_cbLocSize = len + 1;  // Add one for the terminating null.
            m_szLocation = new TCHAR [m_cbLocSize];
            if (!m_szLocation)
            {
                m_cbLocSize = 0;
                goto GatherInfoErr;
            }
        }
        (void) StringCchCopy(m_szLocation, m_cbLocSize, pwszPath);
        if (bAppendSlash)
        {
            (void) StringCchCat(m_szLocation, m_cbLocSize, L"\\");
        }
    }


GatherInfoSuccess:
    DebugMsg ((DM_VERBOSE, IDS_COLLECT_REDIRINFO, m_szLocDisplayName, m_dwFlags));
    Status = STATUS_SUCCESS;
    goto GatherInfoEnd;

GatherInfoErr:
    Status = ERROR_OUTOFMEMORY;
    m_fDataValid = FALSE;
    m_dwFlags = REDIR_DONT_CARE;    //so that these settings will be ignored while merging into global data
    DebugMsg ((DM_VERBOSE, IDS_GATHER_FAILURE, Status, m_szLocDisplayName));

GatherInfoEnd:
    if (pwszSection)
        delete [] pwszSection;
    
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::WasRedirectionAttempted
//
//  Synopsis:   indicates whether redirection has already been attempted on
//              this folder.
//
//  Arguments:  none.
//
//  Returns:    a bool indicating the required status
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const BOOL CRedirectInfo::WasRedirectionAttempted (void)
{
    return m_bRedirectionAttempted;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetFolderID
//
//  Synopsis:   returns the index of this folder in the array of 
//              redirection candidates
//
//  Arguments:  none.
//
//  Returns:    an index into the list of redirected folders
//
//  History:    11/20/2001  AdamEd  created
//
//  Notes:
//
//---------------------------------------------------------------------------
REDIRECTABLE CRedirectInfo::GetFolderID(void)
{
    return m_rID;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetFlags
//
//  Synopsis:   returns the redirection flags for the folder represented by
//              this object
//
//  Arguments:  none
//
//  Returns:    the value of the flags
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const DWORD CRedirectInfo::GetFlags (void)
{
    return m_dwFlags;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetRedirStatus
//
//  Synopsis:   retrieves the return code of the redirection operation
//
//  Arguments:  none
//
//  Returns:    the member m_StatusRedir
//
//  History:    5/3/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const DWORD CRedirectInfo::GetRedirStatus (void)
{
    return m_StatusRedir;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetLocation
//
//  Synopsis:   returns the redirection location for the folder represented
//              by this object
//
//  Arguments:  none
//
//  Returns:    a pointer to the buffer containing the path
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
LPCTSTR CRedirectInfo::GetLocation (void)
{
    return m_szLocation;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::GetLocalizedName
//
//  Synopsis:   returns the localized name of the folder
//
//  Arguments:  none
//
//  Returns:    a pointer to the buffer containing the localized name
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
LPCTSTR CRedirectInfo::GetLocalizedName (void)
{
    return m_szLocDisplayName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::Redirect
//
//  Synopsis:   this function performs the actual redirection for the
//              folder represented by this object.
//
//  Arguments:  [in] hUserToken : handle to the user token
//              [in] hKeyRoot : handle to HKCU
//              [in] pFileDB : pointer to the CFileDB object from which this
//                             function was called.
//
//  Returns:    a DWORD indicating the success/failure code in redirection
//
//  History:    8/12/1998  RahulTh  created
//
//  Notes:
//           It is very important to record the return code in m_StatusRedir
//           before returning from this function. If we don't do that
//           we might end up returning the wrong value to the policy engine
//           while attempting to redirect special descendant folders which
//           can affect the list of policies obtained at a subsequent logon
//           session.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::Redirect (HANDLE   hUserToken,
                               HKEY     hKeyRoot,
                               CFileDB* pFileDB)
{
    HRESULT     hr = S_OK;
    SHARESTATUS SourceStatus = NoCSC;
    SHARESTATUS DestStatus = NoCSC;
    DWORD       PinStatus = ERROR_SUCCESS;
    WCHAR   *   wszProcessedPath = NULL;

    if (m_bRedirectionAttempted)
    {
        goto Redir_CleanupAndQuit;  //redirection has already been attempted
                                    //and the success / failure code has been
                                    //recorded in m_StatusRedir. Use the same
                                    //error code as the return value as this
                                    //value may not yet have been recorded in
                                    //ProcessGroupPolicy
    }

    //we shall now attempt to redirect...
    m_bRedirectionAttempted = TRUE;

    if (m_dwFlags & REDIR_FOLLOW_PARENT)
    {
        //this is possible only if UpdateDescendant ran out of memory
        //which means that we could not derive the folder's redirection
        //info. No point trying to log an event since we are out of memory
        //anyway. we just try to quit as gracefully as we can.
        m_StatusRedir = ERROR_OUTOFMEMORY;
        goto Redir_KillChildAndLeave;
    }

    WCHAR       wszExpandedNewPath [TARGETPATHLIMIT];
    WCHAR       wszExpandedCurrentPath [TARGETPATHLIMIT];
    WCHAR       wszHackedName [TARGETPATHLIMIT];
    WCHAR       wszExpandedSavedFolderPath [TARGETPATHLIMIT];
    WCHAR       wszExpandedNewFolderPath [TARGETPATHLIMIT];
    CSavedSettings * pLocalSettings;
    BOOL        bCurrentPathValid;  //indicates if we have been successful in obtaining the current path of the folder.
    UNICODE_STRING  Path;
    UNICODE_STRING  ExpandedPath;

    //set some defaults.
    m_StatusRedir = ERROR_SUCCESS;
    bCurrentPathValid = TRUE;

    //if the policy cares about the location of the folder, then we must
    //expand the path

    if (! (m_dwFlags & REDIR_DONT_CARE))
    {
        //show additional status messages if the verbose status is on.
        DisplayStatusMessage (IDS_REDIR_CALLBACK);

        if (!m_cbLocSize)
        {
            m_StatusRedir = ERROR_OUTOFMEMORY;
            //we had run out of memory so no point trying to log an event
            //we just quit as gracefully as we can.
            goto Redir_KillChildAndLeave;
        }

        if (m_bRemove)
        {
            m_StatusRedir = HRESULT_CODE(StringCchCopy( m_szLocation, m_cbLocSize, L"%USERPROFILE%\\"));
            if ( m_StatusRedir != ERROR_SUCCESS )
            {
                goto Redir_KillChildAndLeave;
            }
            m_StatusRedir = HRESULT_CODE(StringCchCat( m_szLocation, m_cbLocSize, m_szLocFolderRelativePath));
            if ( m_StatusRedir != ERROR_SUCCESS )
            {
                goto Redir_KillChildAndLeave;
            }
        }

        // Get the expanded destination path.
        // First expand the homedir component, if applicable.
        m_StatusRedir = ExpandHomeDirPolicyPath (m_rID,
                                                 m_szLocation,
                                                 m_bFollowsParent,
                                                 &wszProcessedPath);
        if (ERROR_SUCCESS == m_StatusRedir)
        {
            Path.Length = (wcslen (wszProcessedPath) + 1) * sizeof (WCHAR);
            Path.MaximumLength = sizeof (wszProcessedPath);
            Path.Buffer = wszProcessedPath;

            ExpandedPath.Length = 0;
            ExpandedPath.MaximumLength = sizeof (wszExpandedNewFolderPath);
            ExpandedPath.Buffer = wszExpandedNewFolderPath;

            m_StatusRedir = RtlExpandEnvironmentStrings_U (
                               pFileDB->_pEnvBlock,
                               &Path,
                               &ExpandedPath,
                               NULL
                               );

            if (STATUS_BUFFER_TOO_SMALL == m_StatusRedir)
            {
                gpEvents->Report (
                        EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                        3,
                        m_szLocDisplayName,
                        m_szLocation,
                        NumberToString ( TARGETPATHLIMIT )
                        );

                goto Redir_KillChildAndLeave;
            }
        }

        if (ERROR_SUCCESS != m_StatusRedir)
        {
            DebugMsg ((DM_WARNING, IDS_REDIRECT_EXP_FAIL, m_szLocation, m_StatusRedir));
            gpEvents->Report (
                    EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                    2,
                    m_szLocDisplayName,
                    StatusToString ( m_StatusRedir )
                    );

            goto Redir_KillChildAndLeave;
        }
    }

    pLocalSettings = & (gSavedSettings[(int) m_rID]);

    if (pLocalSettings->m_dwFlags & REDIR_DONT_CARE)
    {
        if (m_dwFlags & REDIR_DONT_CARE)
        {
            pLocalSettings->Save (pLocalSettings->m_szCurrentPath, m_dwFlags, NULL, NULL);
            if (MyDocs == m_rID)
            {
                m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);

                if ( ERROR_SUCCESS != m_StatusRedir )
                {
                    goto Redir_KillChildAndLeave;
                }
            }

            goto Redir_CleanupAndQuit;
        }

        DebugMsg ((DM_VERBOSE, IDS_REDIRECT, m_szLocDisplayName, m_szLocation));

        //the policy cares about the location of this doc.

        //must get the correct syntax for GetLocalFilePath
        m_StatusRedir = HRESULT_CODE(StringCchCopy(wszHackedName, TARGETPATHLIMIT, m_szFolderRelativePath));
        if ( m_StatusRedir != ERROR_SUCCESS )
        {
            goto Redir_KillChildAndLeave;
        }
        m_StatusRedir = HRESULT_CODE(StringCchCat(wszHackedName, TARGETPATHLIMIT, L"\\"));
        if ( m_StatusRedir != ERROR_SUCCESS )
        {
            goto Redir_KillChildAndLeave;
        }
        m_StatusRedir = pFileDB->GetLocalFilePath (wszHackedName, wszExpandedCurrentPath);

        //
        // Expand the homedir if necessary. Note: GetLocalFilePath will not
        // do it because it calls SHGetFolderPath and HOMESHARE and HOMEPATH
        // are not defined at that point.
        //
        if (ERROR_SUCCESS == m_StatusRedir)
        {
            m_StatusRedir = ExpandHomeDir (m_rID,
                                           wszExpandedCurrentPath,
                                           TRUE,
                                           &wszProcessedPath,
                                           pLocalSettings->m_bHomedirChanged ? pLocalSettings->m_szLastHomedir : NULL
                                          );
            if (ERROR_SUCCESS != m_StatusRedir ||
                ! wszProcessedPath ||
                TARGETPATHLIMIT <= lstrlen (wszProcessedPath))
            {
                m_StatusRedir = (ERROR_SUCCESS == m_StatusRedir) ? ERROR_BUFFER_OVERFLOW : m_StatusRedir;
            }
            else
            {
                (void) StringCchCopy(wszExpandedCurrentPath, TARGETPATHLIMIT, wszProcessedPath);
            }
        }

        //GetLocalFilePath might fail if SHGetFolderPath fails. SHGetFolderPath
        //fails if the registry keys for the folder point to an invalid path and
        //there is nothing in the CSC cache for it either. So in this particular
        //case, we ignore the failure and treat it as a NO_MOVE. In NO_MOVE, we
        //do not require the current path of the folder.
        if ((ERROR_SUCCESS != m_StatusRedir) &&
            ERROR_INVALID_NAME != m_StatusRedir)    //the only possible error from GetLocalFilePath not generated by SHGetFolderPath
        {
            m_dwFlags &= ~REDIR_MOVE_CONTENTS;
            m_StatusRedir = ERROR_SUCCESS;
            bCurrentPathValid = FALSE;
            (void) StringCchCopy(wszExpandedCurrentPath, TARGETPATHLIMIT, L"???");    //if bCurrentPathValid is FALSE, this string will only be used in logs
        }

        if (m_StatusRedir != ERROR_SUCCESS)
        {
            DebugMsg ((DM_WARNING, IDS_REDIRECT_NO_LOCAL, m_szLocDisplayName, m_StatusRedir));
            gpEvents->Report (
                     EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                     2,
                     m_szLocDisplayName,
                     StatusToString ( m_StatusRedir )
                     );
            goto Redir_KillChildAndLeave;
        }

        //make sure that it is not already redirected
        if (bCurrentPathValid && (0 == _wcsicmp (wszExpandedCurrentPath, wszExpandedNewFolderPath)))
        {
            pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : NULL);
            if (MyDocs == m_rID)
            {
                m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                           (m_bRemove || (m_dwFlags & REDIR_DONT_CARE))?FALSE:TRUE);

                if ( ERROR_SUCCESS != m_StatusRedir )
                {
                    goto Redir_KillChildAndLeave;
                }
            }

            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       wszExpandedNewFolderPath));
            //however, it is possible that the folders have not been pinned.
            //e.g. a roaming user who has already been redirected on one machine
            //and now logs on to another machine for the first time.
            DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
            if (ShareOnline == DestStatus)
            {

                PinStatus = PinIfNecessary (wszExpandedNewFolderPath, DestStatus);
                if ( ERROR_SUCCESS != PinStatus )
                    DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                              m_szLocDisplayName, PinStatus));

                CacheDesktopIni (wszExpandedNewFolderPath, DestStatus, PinFile);
            }
            m_StatusRedir = ERROR_SUCCESS;
            goto Redir_CleanupAndQuit;
        }

        if (g_bCSCEnabled)
        {
            SourceStatus = bCurrentPathValid ? GetCSCStatus (wszExpandedCurrentPath) : PathLocal;
            DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
            if (ShareOffline == DestStatus ||
                ((m_dwFlags & REDIR_MOVE_CONTENTS) && ShareOffline == SourceStatus))
            {
                m_StatusRedir = ERROR_CSCSHARE_OFFLINE;
                gpEvents->Report (
                        EVENT_FDEPLOY_FOLDER_OFFLINE,
                        3,
                        m_szLocDisplayName,
                        wszExpandedCurrentPath,
                        wszExpandedNewFolderPath
                        );
                goto Redir_KillChildAndLeave;
            }
        }

        DebugMsg (( DM_VERBOSE, IDS_REDIRECT_PREVPATH,
                    pLocalSettings->m_szCurrentPath,
                    wszExpandedCurrentPath));
        DebugMsg (( DM_VERBOSE, IDS_REDIRECT_NEWPATH, m_szLocation,
                    wszExpandedNewFolderPath));

        m_StatusRedir = PerformRedirection (
                           pFileDB,
                           bCurrentPathValid,
                           wszExpandedCurrentPath,
                           wszExpandedNewFolderPath,
                           SourceStatus,
                           DestStatus,
                           hUserToken
                           );

        if (ERROR_SUCCESS == m_StatusRedir)
        {
            if (m_bRemove)
            {
                if (MyDocs == m_rID)
                {
                    m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);

                    if ( ERROR_SUCCESS != m_StatusRedir )
                    {
                        goto Redir_KillChildAndLeave;
                    }
                }

                pLocalSettings->Save (m_szLocation, REDIR_DONT_CARE, NULL, NULL);
            }
            else
            {
                if (MyDocs == m_rID)
                {
                    m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                               (m_dwFlags & REDIR_DONT_CARE) ? FALSE : TRUE);

                    if ( ERROR_SUCCESS != m_StatusRedir )
                    {
                        goto Redir_KillChildAndLeave;
                    }
                }

                pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : 0);
            }
        }
        else if (m_pChild && m_pChild->m_bFollowsParent)  //if this is a parent whose redirection was unsuccessful, do not redirect the child if it is supposed to follow
        {
            PreventDescendantRedirection (m_StatusRedir);
        }

        goto Redir_CleanupAndQuit;
    }

    //if we are here, it means that the saved settings don't have the
    //REDIR_DONT_CARE flag set
    if (m_dwFlags & REDIR_DONT_CARE)
    {
        //the original settings cared about the location of the folder,
        //but now no one cares. So remove any redirection restrictions.
        if (MyDocs == m_rID)
        {
            m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);

            if ( ERROR_SUCCESS != m_StatusRedir )
            {
                goto Redir_KillChildAndLeave;
            }
        }

        pLocalSettings->Save (pLocalSettings->m_szCurrentPath, m_dwFlags, NULL, NULL);
        m_StatusRedir = ERROR_SUCCESS;
        goto Redir_CleanupAndQuit;
    }

    DebugMsg((DM_VERBOSE, IDS_REDIRECT, m_szLocDisplayName, m_szLocation));

    // This policy cares about where this folder goes.

    //
    // So first expand the homedir part if applicable
    // use the last value of homedir if the value of homedir has changed.
    //
    m_StatusRedir = ExpandHomeDir(m_rID,
                                  pLocalSettings->m_szLastRedirectedPath,
                                  TRUE,
                                  &wszProcessedPath,
                                  pLocalSettings->m_bHomedirChanged ? pLocalSettings->m_szLastHomedir : NULL);

    if (ERROR_SUCCESS == m_StatusRedir)
    {
        // Now first expand the saved path, we will use that for redirection
        Path.Length = (wcslen (wszProcessedPath) + 1) * sizeof (WCHAR);
        Path.MaximumLength = Path.Length;
        Path.Buffer = wszProcessedPath;

        ExpandedPath.Length = 0;
        ExpandedPath.MaximumLength = sizeof (wszExpandedSavedFolderPath);
        ExpandedPath.Buffer = wszExpandedSavedFolderPath;

        m_StatusRedir = RtlExpandEnvironmentStrings_U (
                                pFileDB->_pEnvBlock,
                                &Path,
                                &ExpandedPath,
                                NULL
                                );

        if (STATUS_BUFFER_TOO_SMALL == m_StatusRedir)
        {
            gpEvents->Report (
                    EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                    3,
                    m_szLocDisplayName,
                    pLocalSettings->m_szLastRedirectedPath,
                    NumberToString ( TARGETPATHLIMIT )
                    );

            goto Redir_KillChildAndLeave;
        }
    }

    if (ERROR_SUCCESS != m_StatusRedir)
    {
        DebugMsg ((DM_WARNING, IDS_REDIRECT_EXP_FAIL, pLocalSettings->m_szLastRedirectedPath, m_StatusRedir));
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                2,
                m_szLocDisplayName,
                StatusToString ( m_StatusRedir )
                );

        goto Redir_KillChildAndLeave;
    }

    //make sure that it is not already redirected to the location.
    if (0 == _wcsicmp (wszExpandedSavedFolderPath, wszExpandedNewFolderPath))
    {
        //the cached path and the path specified by the policy is the same
        //but someone may have messed with the registry, if that is the case
        //we use the path in the registry as the base path
        //must get the correct syntax for GetLocalFilePath
        m_StatusRedir = HRESULT_CODE(StringCchCopy(wszHackedName, TARGETPATHLIMIT, m_szFolderRelativePath));
        if ( m_StatusRedir != ERROR_SUCCESS )
        {
            goto Redir_KillChildAndLeave;
        }
        m_StatusRedir = HRESULT_CODE(StringCchCat(wszHackedName, TARGETPATHLIMIT, L"\\"));
        if ( m_StatusRedir != ERROR_SUCCESS )
        {
            goto Redir_KillChildAndLeave;
        }
        m_StatusRedir = pFileDB->GetLocalFilePath (wszHackedName, wszExpandedCurrentPath);

        //
        // Expand the homedir if necessary. Note: GetLocalFilePath will not
        // do it because it calls SHGetFolderPath and HOMESHARE and HOMEPATH
        // are not defined at that point.
        //
        if (ERROR_SUCCESS == m_StatusRedir)
        {
            m_StatusRedir = ExpandHomeDir (m_rID,
                                           wszExpandedCurrentPath,
                                           TRUE,
                                           &wszProcessedPath,
                                           pLocalSettings->m_bHomedirChanged ? pLocalSettings->m_szLastHomedir : NULL
                                          );
            if (ERROR_SUCCESS != m_StatusRedir ||
                ! wszProcessedPath ||
                TARGETPATHLIMIT <= lstrlen (wszProcessedPath))
            {
                m_StatusRedir = (ERROR_SUCCESS == m_StatusRedir) ? ERROR_BUFFER_OVERFLOW : m_StatusRedir;
            }
            else
            {
                (void) StringCchCopy(wszExpandedCurrentPath, TARGETPATHLIMIT, wszProcessedPath);
            }
        }

        //GetLocalFilePath may fail if SHGetFolderPath fails. This
        //would mean that the registry is messed up anyway. Also, move contents
        //no longer makes sense, since the path to which the reg. points to
        //is invalid or worse, the registry key is missing. also, it would
        //imply that there is nothing in the CSC cache
        if ((ERROR_SUCCESS != m_StatusRedir) &&
            ERROR_INVALID_NAME != m_StatusRedir)    //the only possible error from GetLocalFilePath not generated by SHGetFolderPath
        {
            m_StatusRedir = ERROR_SUCCESS;
            bCurrentPathValid = FALSE;
            m_dwFlags &= ~REDIR_MOVE_CONTENTS;
        }

        if (m_StatusRedir != ERROR_SUCCESS)
        {
            DebugMsg ((DM_WARNING, IDS_REDIRECT_NO_LOCAL, m_szLocDisplayName, m_StatusRedir));
            gpEvents->Report (
                     EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                     2,
                     m_szLocDisplayName,
                     StatusToString ( m_StatusRedir )
                     );
            goto Redir_KillChildAndLeave;
        }
        //we have found out the path stored in the registry, so compare it with
        //the saved path
        if (bCurrentPathValid && (0 == _wcsicmp (wszExpandedSavedFolderPath, wszExpandedCurrentPath)))
        {
            //all the paths are identical, so we are fine. save and quit
            pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : 0);
            if (MyDocs == m_rID)
            {
                m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                           (m_bRemove || (m_dwFlags & REDIR_DONT_CARE))?FALSE:TRUE);

                if ( ERROR_SUCCESS != m_StatusRedir )
                {
                    goto Redir_KillChildAndLeave;
                }
            }

            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       wszExpandedNewFolderPath));
            //however, it is possible that the folders have not been pinned.
            //e.g. a roaming user who has already been redirected on one machine
            //and now logs on to another machine for the first time.
            DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
            if (ShareOnline == DestStatus)
            {

                PinStatus = PinIfNecessary (wszExpandedNewFolderPath, DestStatus);
                if ( ERROR_SUCCESS != PinStatus )
                    DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                              m_szLocDisplayName, PinStatus));

                CacheDesktopIni (wszExpandedNewFolderPath, DestStatus, PinFile);
            }
            m_StatusRedir = ERROR_SUCCESS;
            goto Redir_CleanupAndQuit;
        }
        else //somebody has been messing with the registry
        {
            //use the path in the registry as the source path
            //and perform redirection again
            if (bCurrentPathValid)
                (void) StringCchCopy(wszExpandedSavedFolderPath, TARGETPATHLIMIT, wszExpandedCurrentPath);
            else
                (void) StringCchCopy(wszExpandedSavedFolderPath, TARGETPATHLIMIT, L"???");
                                    //to be on the safe side, since we don't want to use the saved path as the source for redirection
                                    //if bCurrentPathValid is FALSE, this string will only be used in debug messages and error logs
        }
    }

    if (g_bCSCEnabled)
    {
        SourceStatus = bCurrentPathValid ? GetCSCStatus (wszExpandedSavedFolderPath) : PathLocal;
        DestStatus = GetCSCStatus (wszExpandedNewFolderPath);
        if (ShareOffline == DestStatus ||
            ((m_dwFlags & REDIR_MOVE_CONTENTS) && ShareOffline == SourceStatus))
        {
            m_StatusRedir = ERROR_CSCSHARE_OFFLINE;
            gpEvents->Report (
                    EVENT_FDEPLOY_FOLDER_OFFLINE,
                    3,
                    m_szLocDisplayName,
                    wszExpandedSavedFolderPath,
                    wszExpandedNewFolderPath
                    );
            goto Redir_KillChildAndLeave;
        }
    }

    DebugMsg (( DM_VERBOSE, IDS_REDIRECT_PREVPATH,
                pLocalSettings->m_szLastRedirectedPath,
                wszExpandedSavedFolderPath));
    DebugMsg (( DM_VERBOSE, IDS_REDIRECT_NEWPATH, m_szLocation,
                wszExpandedNewFolderPath));


    m_StatusRedir = PerformRedirection (
                       pFileDB,
                       bCurrentPathValid,
                       wszExpandedSavedFolderPath,
                       wszExpandedNewFolderPath,
                       SourceStatus,
                       DestStatus,
                       hUserToken
                       );

    if (ERROR_SUCCESS == m_StatusRedir)
    {
        if (m_bRemove)
        {
            if (MyDocs == m_rID)
            {
                m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot, FALSE);

                if ( ERROR_SUCCESS != m_StatusRedir )
                {
                    goto Redir_KillChildAndLeave;
                }
            }

            pLocalSettings->Save (m_szLocation, REDIR_DONT_CARE, NULL, NULL);
        }
        else
        {
            if (MyDocs == m_rID)
            {
                m_StatusRedir = RestrictMyDocsRedirection (hUserToken, hKeyRoot,
                                           (m_dwFlags & REDIR_DONT_CARE)?FALSE:TRUE);

                if ( ERROR_SUCCESS != m_StatusRedir )
                {
                    goto Redir_KillChildAndLeave;
                }
            }

            pLocalSettings->Save (m_szLocation, m_dwFlags, m_pSid, m_bValidGPO ? m_szGPOName : 0);
        }
    }
    else if (m_pChild && m_pChild->m_bFollowsParent)  //if redirection was unsuccessful and this folder has children, prevent the redirection of the children if they are supposed to follow
    {
        PreventDescendantRedirection (m_StatusRedir);
    }

    goto Redir_CleanupAndQuit;

//the following code is executed whenever some fatal error occurs
//and we want to make sure that if this is a dir with a special
//descendant and the descendant is supposed to follow the parent,
//then we don't want to attempt redirection for the child.
Redir_KillChildAndLeave:
    if (ERROR_SUCCESS != m_StatusRedir &&
            (m_pChild && m_pChild->m_bFollowsParent))
        PreventDescendantRedirection (m_StatusRedir);

Redir_CleanupAndQuit:
    if (wszProcessedPath)
        delete [] wszProcessedPath;

    if ( ERROR_SUCCESS != m_StatusRedir )
    {
        HRESULT hrRsop;

        hrRsop = pFileDB->AddPreservedPolicy( (WCHAR*) m_szDisplayName );

        if ( FAILED( hrRsop ) )
        {
            pFileDB->GetRsopContext()->DisableRsop( hrRsop );
        }
    }

    return m_StatusRedir;
}
        
//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::ShouldSaveExpandedPath
//
//  Synopsis:   Determines whether we need to store the expanded path in the
//              registry or the unexpanded paths. See notes for additional
//              details.
//
//  Arguments:  none.
//
//  Returns:    TRUE : if the expanded path should be stored.
//              FALSE : otherwise.
//
//  History:    5/1/2001  RahulTh  created
//
//  Notes:
//      If the destination path is a homedir path, store the expanded path
//      in the registry so that if msgina is unable to set the homedir
//      variables and uses the local defaults instead, the shell doesn't 
//      end up thinking that MyDocs is local.
//
//      If the destination path is a different kind of path, then store the
//      expanded path if it has the %username% variable in it. Because if we
//      don't then when a user's UPN changes and the user logs on with the new
//      username, then the shell will expand the path using the new username.
//      Now, normally this won't be a problem because we would have already
//      done the rename operation. However, if for some reason we are
//      not successful in that rename operation (say because we are
//      invoked in limited foreground or because the server is offline)
//      then the rename will not succeed. In this case, the shell will
//      end up creating a new empty folder in that location whenever the
//      user tries to access it. So the next time the user logs on,
//      the new folder is already present and the rename fails with
//      ERROR_ALREADY_EXISTS and we just end up pointing to the new
//      location. The files stay in the old location. Therefore, we must
//      not use the unexpanded path in SHSetFolderPath. However, we must
//      store the unexpanded path in our local cache in order to
//      successfully detect UPN changes.
//
//      We do not want to store the expanded path unconditionally because
//      in situations where the user is going back to a local location,
//      especially the local userprofile location, we do not want to store
//      the expanded path because it is not device independent and will cause
//      problems for roaming users (e.g. a certain drive may not be available
//      on all the machines so we should keep the path as %userprofile%\...
//      rather than something like E:\Documents & Settings\...)
//
//---------------------------------------------------------------------------
BOOL CRedirectInfo::ShouldSaveExpandedPath(void)
{
    if (! m_szLocation || L'\0' == m_szLocation[0])
        return FALSE;
    
    // Detect the homedir case
    if (IsHomedirPolicyPath(m_rID, m_szLocation, TRUE))
        return TRUE;
    
    //
    // Check if the path contains the username variable.
    // If it does then we should store the expanded paths. However regardless
    // of everything else, if the path begins with %userprofile%, we should
    // never store the expanded path because we will never be guaranteed a
    // device independent path in that case and will run into all sorts of
    // problems.
    //
    _wcslwr (m_szLocation);
    // Compare the beginning of the two strings (the -1 is required to prevent comparing the terminating NULL)
    if (0 == wcsncmp (m_szLocation, L"%userprofile%", sizeof(L"%userprofile%")/sizeof(WCHAR) - 1))
        return FALSE;
    if (wcsstr (m_szLocation, L"%username%"))
        return TRUE;
    
    //
    // If we are here, we did not meet any of the conditions required for
    // storing the expanded paths. So we should just store the unexpanded paths
    //
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::PerformRedirection
//
//  Synopsis:   performs the nitty gritty of redirection including copying
//              files, updating the registry, logging events etc.
//
//  Arguments:  [in] pFileDB    : the CFileDB structure that is used throughout
//              [in] bSourceValid : if pwszSource contains a valid path
//              [in] pwszSource : source path
//              [in] pwszDest   : Destination path
//              [in] StatusFrom : CSC status of the source share
//              [in] StatusTo   : CSC status of the destination share
//
//  Returns:    ERROR_SUCCESS if everything was successful. An error code
//              otherwise.
//
//  History:    11/21/1998  RahulTh  created
//              12/13/2000  RahulTh  Special cased homedir redirection to
//                                   prevent security checks and store expanded
//                                   paths in the registry (see comments within the function)
//
//  Notes:      this functions expects both shares to be online when it is
//              invoked.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::PerformRedirection (CFileDB     *  pFileDB,
                                         BOOL           bSourceValid,
                                         WCHAR       *  pwszSource,
                                         WCHAR       *  pwszDest,
                                         SHARESTATUS    StatusFrom,
                                         SHARESTATUS    StatusTo,
                                         HANDLE         hUserToken
                                         )
{
    BOOL    bCheckOwner;
    BOOL    bMoveContents;
    BOOL    bIsHomeDirRedirection = FALSE;  // Tracks if this is a homedir redirection policy
    DWORD   Status;
    int     iResultCompare;
    WCHAR * pwszSkipSubdir;
    int     csidl;
    BOOL    bStatus;
    DWORD   PinStatus;
    HRESULT hResult = S_OK;
    CCopyFailData   CopyFailure;
    
    //
    // We need to track if this is a homedir redirection policy because
    // of 2 reasons:
    //      1) In homedir redirection, security checks are skipped.
    //      2) In homedir redirection, the expanded path is stored in the registry. This is 
    //          to prevent problems that might occur if the homedir variables cannot be
    //          set by msgina and end up pointing to the local userprofile. In this case,
    //          we do not want the shell to start pointing MyDocs to the local location.
    // 
    bIsHomeDirRedirection = IsHomedirPolicyPath(m_rID, m_szLocation, TRUE);
    
    csidl = pFileDB->RegValueCSIDLFromFolderName (m_szFolderRelativePath);

    // Skip security check for homedir redirection.
    bCheckOwner = ((m_dwFlags & REDIR_SETACLS) && (!bIsHomeDirRedirection)) ? TRUE : FALSE;
    bMoveContents = m_dwFlags & REDIR_MOVE_CONTENTS ? TRUE : FALSE;

    if (bSourceValid)
    {
        Status = ComparePaths (pwszSource, pwszDest, &iResultCompare);

        if (ERROR_SUCCESS != Status)
        {
            //this is very unlikely
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_FAIL,
                    4,
                    m_szLocDisplayName,
                    StatusToString (Status),
                    pwszSource,
                    pwszDest
                    );
            return Status;
        }

        if (0 == iResultCompare)
        {
            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       pwszDest));
            //however, it is possible that the folders have not been pinned.
            //e.g. a roaming user who has already been redirected on one machine
            //and now logs on to another machine for the first time.
            if (ShareOnline == StatusTo)
            {

                PinStatus = PinIfNecessary (pwszDest, StatusTo);
                if ( ERROR_SUCCESS != PinStatus )
                    DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                              m_szLocDisplayName, PinStatus));

                CacheDesktopIni (pwszDest, StatusTo, PinFile);
            }
            return ERROR_SUCCESS;
        }

        //it is okay to redirect to a path that is a descendant of the current
        //path if we are not moving contents
        if (bMoveContents && (-1 == iResultCompare))
        {
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_RECURSE,
                    4,
                    m_szLocDisplayName,
                    m_szLocation,
                    pwszSource,
                    pwszDest
                    );

            return ERROR_REQUEST_ABORTED;
        }
    }

    Status = pFileDB->CreateRedirectedFolderPath (pwszSource, pwszDest,
                                                  bSourceValid,
                                                  bCheckOwner, bMoveContents);

    if (ERROR_SUCCESS != Status)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_CREATE_FAIL,
                4,
                m_szLocDisplayName,
                StatusToString (Status),
                m_szLocation,
                pwszDest
                );
        return Status;
    }

    //now we know that both the source and destinations paths exist
    //so make sure that they are not the same path in different formats
    //this is an expensive function as it involves creation and deletion of
    //multiple files over the network. so we invoke it only if absolutely
    //necessary
    if (bSourceValid && bMoveContents)
    {
        Status = CheckIdenticalSpecial (pwszSource, pwszDest, &iResultCompare);

        if (ERROR_SUCCESS != Status)
        {
            //this is very unlikely...
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_FAIL,
                    4,
                    m_szLocDisplayName,
                    StatusToString (Status),
                    pwszSource,
                    pwszDest
                    );
            return Status;
        }

        if (0 == iResultCompare)
        {
            DebugMsg ((DM_VERBOSE, IDS_REDIRECT_INSYNC, m_szLocDisplayName,
                       pwszDest));

            //
            // The paths are the same but in different formats (or perhaps
            // through different shares. So at least update the registry to
            // point to the new path.
            //
            hResult = SHSetFolderPath(csidl | CSIDL_FLAG_DONT_UNEXPAND,
                                      hUserToken,
                                      0,
                                      ShouldSaveExpandedPath() ? pwszDest : m_szLocation);
            Status = GetWin32ErrFromHResult (hResult);

            //
            // This basically should never fail.  But do we want to try to delete the
            // copied files if it does? Or the wacked CSC database?
            //
            if ( Status != ERROR_SUCCESS )
            {
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_REGSET_FAIL,
                        2,
                        m_szLocDisplayName,
                        StatusToString( Status ) );

                return Status;
            }
            else
            {
                //we were successul.
                //first, rename the local CSC cache.
                if (m_pChild)
                    pwszSkipSubdir = m_pChild->m_szLocDisplayName;
                else
                    pwszSkipSubdir = NULL;
                MoveDirInCSC (pwszSource, pwszDest, pwszSkipSubdir,
                              StatusFrom, StatusTo, TRUE, TRUE);
                if (g_bCSCEnabled && ShareOnline == StatusFrom)
                {
                    DeleteCSCFileTree (pwszSource, pwszSkipSubdir, TRUE);
                    DeleteCSCShareIfEmpty (pwszSource, StatusFrom);
                }

                //Also, it is possible that the folders have not been pinned.
                //e.g. a roaming user who has already been redirected on one
                //machine and now logs on to another machine for the first time.
                if (ShareOnline == StatusTo)
                {

                    PinStatus = PinIfNecessary (pwszDest, StatusTo);
                    if ( ERROR_SUCCESS != PinStatus )
                        DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                                  m_szLocDisplayName, PinStatus));

                    CacheDesktopIni (pwszDest, StatusTo, PinFile);
                }

                //report this event and return. there is
                //nothing more to be done here.
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_REDIRECT,
                        1,
                        m_szLocDisplayName );
                return ERROR_SUCCESS;
            }
        }
    }

    if (bSourceValid && bMoveContents)
    {
        DebugMsg ((DM_VERBOSE, IDS_REDIRECT_COPYON, m_szLocDisplayName));

        //
        // Exclude any special descendants when
        // doing file copies and deletes. Similarly for Programs and
        // Startup
        //

        if (m_pChild)
            pwszSkipSubdir = m_pChild->m_szLocDisplayName;
        else
            pwszSkipSubdir = NULL;

        Status = pFileDB->CopyFileTree( pwszSource,
                                        pwszDest,
                                        pwszSkipSubdir,
                                        StatusFrom,
                                        StatusTo,
                                        TRUE,
                                        &CopyFailure );

        //it is necessary to do the following for 2 reasons:
        //(a) the user may have dirty files in the cache. these don't get
        //    moved above.
        //(b) the files may have already been moved on the network by the
        //    the extension when the user logged on from another machine
        //    therefore, the cache on the second machine never gets updated
        //
        //we only try our best to move the files here. Errors are ignored.
        if (ERROR_SUCCESS == Status)
        {
            MoveDirInCSC (pwszSource, pwszDest,
                          pwszSkipSubdir,
                          StatusFrom, StatusTo, FALSE, TRUE);
        }
        else
        {
            //the copy failed. We might have failed halfway and left the cache
            //in an inconsistent state, so rollback all the cached entries
            MoveDirInCSC (pwszDest, pwszSource, pwszSkipSubdir,
                          StatusTo, StatusFrom, TRUE, TRUE);
        }



        if ( ERROR_SUCCESS != Status )
        {
            if (! CopyFailure.IsCopyFailure())
            {
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_MOVE_FAIL,
                        5,
                        m_szLocDisplayName,
                        StatusToString( Status ),
                        m_szLocation,
                        pwszSource,
                        pwszDest );
            }
            else
            {
                gpEvents->Report(
                        EVENT_FDEPLOY_FOLDER_COPY_FAIL,
                        7,
                        m_szLocDisplayName,
                        StatusToString( Status ),
                        m_szLocation,
                        pwszSource,
                        pwszDest,
                        CopyFailure.GetSourceName(),
                        CopyFailure.GetDestName() );
            }

            return Status;
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_REDIRECT_COPYOFF, m_szLocDisplayName));
    }

    //
    // Look at the comments for ShouldSaveExpandedPath() for details on why we
    // sometimes need to store expanded paths.
    //
    hResult = SHSetFolderPath(csidl | CSIDL_FLAG_DONT_UNEXPAND,
                              hUserToken,
                              0,
                              ShouldSaveExpandedPath() ? pwszDest : m_szLocation);
    Status = GetWin32ErrFromHResult (hResult);


    if ( Status != ERROR_SUCCESS )
    {
        gpEvents->Report(
                EVENT_FDEPLOY_FOLDER_REGSET_FAIL,
                2,
                m_szLocDisplayName,
                StatusToString( Status ) );

        return Status;
    }

    if (!m_bRemove)
    {
        //
        // hack to work around a shell problem.
        //
        // Pin the folder so that the shell never gets an error when
        // trying to resolve this path.  This will prevent it from
        // reverting to a temporary local path.
        //
        // For now just call pin/unpin APIs for any unc style path.  Not
        // really much value in checking first to see if the share is
        // cacheable.
        //

        if ( bSourceValid &&
             (L'\\' == pwszSource[0]) &&
             (L'\\' == pwszSource[1]) )
        {
            CSCUnpinFile( pwszSource,
                          FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                          NULL, NULL, NULL );
            CacheDesktopIni (pwszSource, StatusFrom, UnpinFile);
        }

        if ( (L'\\' == pwszDest[0]) &&
             (L'\\' == pwszDest[1]) )
        {
            PinStatus = PinIfNecessary (pwszDest, StatusTo);

            if ( ERROR_SUCCESS != PinStatus )
                DebugMsg((DM_VERBOSE, IDS_CSCPIN_FAIL,
                          m_szLocDisplayName, PinStatus));

            CacheDesktopIni (pwszDest, StatusTo, PinFile);
        }
    }

    //the contents were moved. now redirect any special children
    //this ensures that deletions (if any) in the child folders,
    //are performed first. thus deletion of this folder won't fail
    //due to existence of its children within it.
    //should not check for m_pChild->m_bFollowsParent here as
    //the child may currently lie under this folder and if we do
    //not perform the redirection of the child here, we might have
    //problems deleting this folder even when we should not have any
    //problems
    if (m_pChild)
    {
        Status = m_pChild->Redirect (pFileDB->_hUserToken,
                                     pFileDB->_hkRoot, pFileDB);

    }

    //note : contents of the source should not be deleted if this is a
    //       policy removal
    if ( bSourceValid && bMoveContents)
    {
        Status = ERROR_SUCCESS;

        //leave the contents on the server if this is a policy removal.
        //also leave the contents on the server when moving from
        //a network to a local location, so that subsequent redirections
        //from other workstations will get all the contents back to local.
        if (!m_bRemove && (!IsPathLocal(pwszDest) || IsPathLocal(pwszSource)))
        {
            //
            // This could fail because of ACLing.  We ignore any failures here.
            //
            DebugMsg((DM_VERBOSE, IDS_REDIRECT_DELETE,
                      m_szLocDisplayName, pwszSource));

            Status = pFileDB->DeleteFileTree( pwszSource,
                                                 pwszSkipSubdir
                                                );
            if ( ERROR_SUCCESS == Status )
            {
                //DeleteFileTree does not remove the top level node passed to it.
        // Delete the top level node only if it is not the user's home
        // directory
        const WCHAR * pwszHomeDir = NULL;
        DWORD dwHomeDirStatus = ERROR_SUCCESS;
        
        pwszHomeDir = gUserInfo.GetHomeDir(dwHomeDirStatus);
        
        if (NULL == pwszHomeDir || 0 != lstrcmpi (pwszHomeDir, pwszSource))
        {
            //clear the attributes before deleting.
            SetFileAttributes (pwszSource,
                       FILE_ATTRIBUTE_NORMAL);
            if ( ! RemoveDirectory( pwszSource ) )
            {
            Status = GetLastError();
            DebugMsg((DM_VERBOSE, IDS_DIRDEL_FAIL,
                  pwszSource, Status));
            }
        }
            }

            if ( Status != ERROR_SUCCESS )
                DebugMsg((DM_WARNING, IDS_REDIRECT_DEL_FAIL,
                          pwszSource, m_szLocDisplayName,
                          m_szLocation, Status));
        }

        //but we always clean up the CSC cache irrespective of whether it is a
        //policy removal or not because folder redirection should be as transparent
        //to the user as possible and it would be annoying for the user to get
        //CSC notifications for shares that are no longer used as redirection
        //targets.
        if (g_bCSCEnabled && ShareOnline == StatusFrom)
        {
            DeleteCSCFileTree (pwszSource, pwszSkipSubdir, TRUE);
            DeleteCSCShareIfEmpty (pwszSource, StatusFrom);
        }

    }

    gpEvents->Report(
            EVENT_FDEPLOY_FOLDER_REDIRECT,
            1,
            m_szLocDisplayName );

    return ERROR_SUCCESS;
}


//+--------------------------------------------------------------------------
//
//  Member:     PreventRedirection
//
//  Synopsis:   this function prevents the redirection code from attempting
//              redirection. Also prevents redirection of any of the child
//              folders.
//
//  Arguments:  [in] Status : the error code indicating the cause of failure.
//
//  Returns:    nothing. It will always succeed.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:      if the pre-processing step that handles the user name change
//              fails for some reason, this function is invoked so that
//              any attempt at applying simultaneous policy changes is thwarted
//
//---------------------------------------------------------------------------
void CRedirectInfo::PreventRedirection (DWORD Status)
{
    m_bRedirectionAttempted = TRUE;
    m_StatusRedir = Status;

    if (m_pChild)
        PreventDescendantRedirection (Status);

    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     PreventDescendantRedirection
//
//  Synopsis:   this function invalidates the data in the children so that
//              the client extension will not try to redirect them
//              this is necessary to prevent redirection of children if the
//              redirection of the parents failed.
//
//  Arguments:  [in] Status : the error code indicating the cause of failure
//
//  Returns:    nothing. it will always succeed.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
void CRedirectInfo::PreventDescendantRedirection (DWORD Status)
{
    if (! m_pChild) //nothing to do if this is not a parent
        return;

    m_pChild->m_bRedirectionAttempted = TRUE;
    m_pChild->m_StatusRedir = Status;

    //disable Startup too if start menu failed.
    if (StartMenu == m_rID)
    {
        m_pChild->m_pChild->m_bRedirectionAttempted = TRUE;
        m_pChild->m_pChild->m_StatusRedir = Status;
    }

    return;
}


//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::UpdateDescendant
//
//  Synopsis:   fills up the internal variables of a descendant object
//              if it is supposed to follow the parent by using the
//              data stored in the parent object
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::UpdateDescendant (void)
{
    DWORD   len;
    WCHAR * szLoc = NULL;
    DWORD   Status;

    Status = ERROR_SUCCESS;

    if (!m_pParent)     //this is not a special descendant
        goto UpdateEnd;

    if (!(m_dwFlags & REDIR_FOLLOW_PARENT))
        goto UpdateEnd; //nothing to do. this descendant is not supposed to follow the parent

    if (!m_pParent->m_fDataValid || (m_pParent->m_dwFlags & REDIR_DONT_CARE))
    {
        m_fDataValid = m_pParent->m_fDataValid;
        m_dwFlags = REDIR_DONT_CARE;
        goto UpdateEnd;
    }

    m_fDataValid = m_pParent->m_fDataValid;

    m_bFollowsParent = TRUE;

    //if we are here, policy has been specified for the parent
    len = lstrlen (m_szLocDisplayName) + lstrlen (m_pParent->m_szLocation) + 2;    //one extra for the backslash
    if (m_cbLocSize < len)
    {
        //we need to allocate memory
        szLoc = new WCHAR [len];
        if (!szLoc)
        {
            //out of memory. cannot derive info. from parent. will have to ignore this GPO
            DebugMsg((DM_VERBOSE, IDS_DERIVEINFO_ERROR, m_szLocDisplayName));
            m_dwFlags = REDIR_DONT_CARE;
            m_fDataValid = FALSE;
            Status = ERROR_OUTOFMEMORY;
            goto UpdateEnd;
        }
        if (m_cbLocSize)
            delete [] m_szLocation;
        m_szLocation = szLoc;
        m_cbLocSize = len;
    }

    if (m_pSid)
    {
        delete [] ((BYTE*) m_pSid);
        m_pSid = NULL;
    }
    
    Status = MySidCopy (&m_pSid, m_pParent->m_pSid);
    if ( ERROR_SUCCESS != Status )
    {
        goto UpdateEnd;
    }

    //copy the data (based on code above, the buffer is large enough, so no error checking is needed
    //first get the settings
    m_dwFlags = m_pParent->m_dwFlags & (REDIR_SETACLS | REDIR_MOVE_CONTENTS | REDIR_RELOCATEONREMOVE);
    (void) StringCchCopy(m_szLocation, m_cbLocSize, m_pParent->m_szLocation);
    len = lstrlen (m_szLocation);
    if (len > 0 && L'\\' != m_szLocation[len - 1])
    {
        (void) StringCchCat(m_szLocation, m_cbLocSize, L"\\");
                                        //add a \ only if the parent's path is not
                                        //terminated with a \. Otherwise, we will
                                        //end up with 2 \ in the child's path which
                                        //will land SHGetFolderPath into trouble
                                        //after the redirection is done.
    }
    (void) StringCchCat(m_szLocation, m_cbLocSize, m_szLocDisplayName); //use the localized folder name
    m_bRemove = m_pParent->m_bRemove;

UpdateEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::operator=
//
//  Synopsis:   overloaded assignment operator used for merging
//
//  Arguments:  standard
//
//  Returns:    standard
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:      DO NOT copy the values of m_bRedirectionAttempted and
//              m_StatusRedir in this function.
//
//---------------------------------------------------------------------------
CRedirectInfo& CRedirectInfo::operator= (const CRedirectInfo& ri)
{
    WCHAR * szLoc = 0;
    DWORD   Status;
    PSID    Sid;
    HRESULT hr = S_OK;

    ASSERT (m_rID == ri.m_rID);

    if (!ri.m_fDataValid)
        goto AssignEnd;

    if ((ri.m_dwFlags & REDIR_FOLLOW_PARENT) && MyPics == m_rID)
    {
        m_fDataValid = ri.m_fDataValid;
        m_dwFlags = REDIR_FOLLOW_PARENT;
        m_bRemove = ri.m_bRemove;
        if (m_bValidGPO = ri.m_bValidGPO)   //note:this IS an assignment -- not a comparison
            (void) StringCbCopy(m_szGPOName, sizeof(m_szGPOName), ri.m_szGPOName);
        else
            m_szGPOName[0] = L'\0';

        goto AssignEnd;
    }
    else if ((ri.m_dwFlags & (REDIR_DONT_CARE | REDIR_FOLLOW_PARENT)))
    {
        //REDIR_FOLLOW_PARENT will be set only if UpdateDescendant ran out of memory
        //in any case, we will have to ignore the policy

        //note that we have to special case My Pics above because UpdateDescendant
        //is called for My Pics after all the policies have been looked at
        //thus it has not been called at this point yet.

        //the reason we call UpdateDescendant for My Pictures after looking at
        //all the policies because it is possible to specify "Follow My Docs"
        //in one policy and specify the location of My Docs in another policy
        if (!m_fDataValid)
        {
            m_fDataValid = ri.m_fDataValid;
            m_dwFlags = REDIR_DONT_CARE;
            m_bRemove = ri.m_bRemove;
            if (m_bValidGPO = ri.m_bValidGPO)   //note: this IS an assignment -- not a comparison
                (void) StringCbCopy(m_szGPOName, sizeof(m_szGPOName), ri.m_szGPOName);
            else
                m_szGPOName[0] = L'\0';
        }

        goto AssignEnd; //ignore. no policy settings for the GPO being merged.
    }

    //note: in the following code... before modifying any of the data
    //we must make sure that we can get memory for all of the members
    //if we fail for even one of them and we have already changed the rest
    //we can run into an inconsistent state. Therefore, we first allocate
    //all the required memory and then actually proceed with the copy.
    Sid = 0;
    Status = MySidCopy (&Sid, ri.m_pSid);
    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_MERGE_FAILURE, m_szLocDisplayName));
        goto AssignEnd;
    }

    if (m_cbLocSize < ri.m_cbLocSize)
    {
        szLoc = new WCHAR [ri.m_cbLocSize];
        if (!szLoc)
        {
            //we could not obtain memory to store the new path.
            //we will have to ignore this policy
            DebugMsg ((DM_VERBOSE, IDS_MERGE_FAILURE, m_szLocDisplayName));
            delete [] ((BYTE*) Sid);    //do not do this at the end. The same memory will be used by m_pSid.
            goto AssignEnd;
        }
        if (m_cbLocSize) delete [] m_szLocation;
        m_szLocation = szLoc;
        m_cbLocSize = ri.m_cbLocSize;
    }

    //now we have the required memory, so we won't fail.
    //fill in the data.
    if (m_pSid)
        delete [] ((BYTE*) m_pSid);
    m_pSid = Sid;
    (void) StringCchCopy(m_szLocation, m_cbLocSize, ri.m_szLocation);
    m_dwFlags = ri.m_dwFlags & (REDIR_SETACLS | REDIR_MOVE_CONTENTS | REDIR_RELOCATEONREMOVE);
    m_bRemove = ri.m_bRemove;
    m_bFollowsParent = ri.m_bFollowsParent;
    m_fDataValid = ri.m_fDataValid;
    if (m_bValidGPO = ri.m_bValidGPO)   //note: this IS an assignment not a comparison
        (void) StringCbCopy(m_szGPOName, sizeof(m_szGPOName), ri.m_szGPOName);
    else
        m_szGPOName[0] = L'\0';

AssignEnd:
    return *this;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRedirectInfo::ComputeEffectivePolicyRemoval
//
//  Synopsis:   tries to find out if the removal of a user from a group
//              has caused a particular policy to be effectively removed
//              for a particular user.
//
//  Arguments:  [pGPOList] : a list of GPOs still in effect for this user.
//                           if a GPO is effectively removed for this user, it
//                           has to figure in this list.
//              [pFileDB] : pointer to the file DB structure
//
//  Returns:
//
//  History:    2/18/1999  RahulTh  created
//
//  Notes:      this also detects cases where a user's group membership may
//              not have changed but the policy no longer specifies any
//              target for this group.
//
//---------------------------------------------------------------------------
DWORD CRedirectInfo::ComputeEffectivePolicyRemoval (
                           PGROUP_POLICY_OBJECT pDeletedGPOList,
                           PGROUP_POLICY_OBJECT pChangedGPOList,
                           CFileDB * pFileDB)
{
    WCHAR                   pwszLocalPath[MAX_PATH];
    WCHAR *                 pwszLocalIniFile = NULL;
    PGROUP_POLICY_OBJECT    pGPO;
    WCHAR *                 pwszGPTIniFilePath = NULL;
    DWORD                   Length = 0;
    DWORD                   Status = ERROR_SUCCESS;
    BOOL                    bStatus;
    HANDLE                  hFind;
    WIN32_FIND_DATA         FindData;
    WCHAR                   pwszDefault[] = L"*";
    DWORD                   dwFlags;
    WCHAR *                 pwszReturnedString = NULL;
    DWORD                   Size = 0;
    UNICODE_STRING          StringW;
    DWORD                   i;
    PTOKEN_GROUPS           pGroups;
    WCHAR                   pwszSid[MAX_PATH];  //more than enough to store a sid.
    BOOL                    bGPOInChangedList = FALSE;

    //if the policy resultant is not set to DONT_CARE, it means that even if a
    //policy has been effectively removed due to a group change or removal of a
    //group from the advanced settings, some other policy has taken precedence
    //and as a result, the policy resultant should remain the way it is.
    if (! (m_dwFlags & REDIR_DONT_CARE))
    {
        Status = ERROR_SUCCESS;
        goto CmpEffPolRem_End;
    }

    //there is no valid GPO stored in the per user per machine cache.
    //so we cannot do much.
    if (!gSavedSettings[m_rID].m_bValidGPO)
    {
        Status = ERROR_SUCCESS;
        goto CmpEffPolRem_End;
    }

    //if the location of this folder was not specified by policy at last logon
    //a group change cannot result in an effective policy removal for this folder.
    if (gSavedSettings[m_rID].m_dwFlags & REDIR_DONT_CARE)
    {
        Status = ERROR_SUCCESS;
        goto CmpEffPolRem_End;
    }

    //if we are here, then the folder was last redirected through policy and now
    //either policy does not care, or a group change makes it seem so. If it is
    //the latter, then we have to compute effective policy removal. Also, it is
    //possible that the last policy application was a partial success and
    //therefore a GPO that got deleted did not show up in either the changed
    //GPO list or the deleted GPO list. We have to take into account that case
    //too.

    //first check if the GPO is present in the deleted GPO list.
    for (pGPO = pDeletedGPOList; pGPO; pGPO = pGPO->pNext)
    {
        if (0 == _wcsicmp (gSavedSettings[m_rID].m_szGPOName, pGPO->szGPOName))
            break;
    }

    if (!pGPO)
    {
        //if the policy isn't in the deleted GPO list, check if it is in the
        //changed GPO list. If it isn't then this is a GPO that got deleted but did
        //not show up in any of the lists because it never got fully applied.
        //if it is, then either this is actually a don't care situation or it
        //should be treated as policy removal because there was a group change.

        for (pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext)
        {
            if (0 == _wcsicmp (gSavedSettings[m_rID].m_szGPOName, pGPO->szGPOName))
                break;
        }

        if (NULL != pGPO)   //it is in the changed GPO list.
        {
            bGPOInChangedList = TRUE;
            //get the path to the ini file on the sysvol.
            Length = wcslen(pGPO->lpFileSysPath) + wcslen(GPT_SUBDIR) + wcslen (INIFILE_NAME) + 1;
            __try {
                pwszGPTIniFilePath = (WCHAR *) alloca( Length * sizeof(WCHAR) );
            } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
                _resetstkoflw();
                pwszGPTIniFilePath = NULL;
                Status = ERROR_OUTOFMEMORY;
                goto CmpEffPolRem_End;
            }
            Status = HRESULT_CODE(StringCchCopy( pwszGPTIniFilePath, Length, pGPO->lpFileSysPath ));
            if ( Status != ERROR_SUCCESS )
            {
                goto CmpEffPolRem_End;
            }
            Status = HRESULT_CODE(StringCchCat( pwszGPTIniFilePath, Length, GPT_SUBDIR ));
            if ( Status != ERROR_SUCCESS )
            {
                goto CmpEffPolRem_End;
            }
            Status = HRESULT_CODE(StringCchCat( pwszGPTIniFilePath, Length, INIFILE_NAME ));
            if ( Status != ERROR_SUCCESS )
            {
                goto CmpEffPolRem_End;
            }
        }
    }


    //get the path to the locally cached copy of the ini file.
    Length = wcslen (pFileDB->_pwszLocalPath) + wcslen (gSavedSettings[m_rID].m_szGPOName) + 6;
    __try {
        pwszLocalIniFile = (WCHAR *) alloca (Length * sizeof (WCHAR));
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        pwszLocalIniFile = NULL;
        Status = ERROR_OUTOFMEMORY;
        goto CmpEffPolRem_End;
    }
    Status = HRESULT_CODE(StringCchCopy( pwszLocalIniFile, Length, pFileDB->_pwszLocalPath ));
    if ( Status != ERROR_SUCCESS )
    {
        goto CmpEffPolRem_End;
    }
    Status = HRESULT_CODE(StringCchCat( pwszLocalIniFile, Length, L"\\" ));
    if ( Status != ERROR_SUCCESS )
    {
        goto CmpEffPolRem_End;
    }
    Status = HRESULT_CODE(StringCchCat( pwszLocalIniFile, Length, gSavedSettings[m_rID].m_szGPOName ));
    if ( Status != ERROR_SUCCESS )
    {
        goto CmpEffPolRem_End;
    }
    Status = HRESULT_CODE(StringCchCat( pwszLocalIniFile, Length, L".ini" ));
    if ( Status != ERROR_SUCCESS )
    {
        goto CmpEffPolRem_End;
    }

    Status = ERROR_SUCCESS;
    bStatus = FALSE;
    if (bGPOInChangedList)
    {
        bStatus = CopyFile( pwszLocalIniFile, pwszGPTIniFilePath, FALSE );
    }
    if ( ! bStatus )    // Work off of the locally cached copy.
    {
        //try to use the cached version if any.
        hFind = FindFirstFile( pwszLocalIniFile, &FindData );
        if ( INVALID_HANDLE_VALUE != hFind )
        {
            Status = ERROR_SUCCESS;
            FindClose( hFind );
        }
        else
        {
            Status = GetLastError();
        }
    }

    //we don't have an ini file to work with, so we can't do much but quit.
    if (ERROR_SUCCESS != Status)
        goto CmpEffPolRem_End;

    //now we have an ini file. so read the relevant info. from it.
    //first grab the flags
    Status = SafeGetPrivateProfileStringW (
                  L"FolderStatus",
                  m_szDisplayName,
                  pwszDefault,
                  &pwszReturnedString,
                  &Size,
                  pwszLocalIniFile
                  );

    if (ERROR_SUCCESS != Status)
        goto CmpEffPolRem_End;

    if (L'*' == *pwszReturnedString)
    {
        //there are no settings for this folder. Possibly because
        //someone changed the settings on the server.
        //Treat it as a don't care.
        goto CmpEffPolRem_End;
    }

    //now grab the hex flags
    StringW.Buffer = pwszReturnedString;
    StringW.Length = wcslen (pwszReturnedString) * sizeof (WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof(WCHAR);
    RtlUnicodeStringToInteger( &StringW, 16, &dwFlags );

    //if this is a special descendant folder and it is supposed to follow
    //the parent, we might first have to derive its settings from the
    //parent and then proceed.
    if (m_pParent && (dwFlags & REDIR_FOLLOW_PARENT))
    {
        //the check for m_pParent is redundant since non-descendant folders
        //can never have this flag. but this has been added as a safety mechanism
        //against ini file corruption
        //we will have to derive the settings from the parent later on.
        m_dwFlags = REDIR_FOLLOW_PARENT;
        m_fDataValid = TRUE;
        m_bFollowsParent = TRUE;
        m_bRemove = TRUE;
        m_bValidGPO = FALSE;    //since this is a removal
        m_szGPOName[0] = L'\0';
        Status = UpdateDescendant(); //derive the settings from the parent

        goto CmpEffPolRem_End;
    }

    if ((dwFlags & REDIR_DONT_CARE) ||
        (m_bFollowsParent && (m_dwFlags & REDIR_DONT_CARE)))
    {
        //the policy has been changed to Don't Care. so it is not a removal.
        //leave everything as is.
        goto CmpEffPolRem_End;
    }

    if (!(dwFlags & REDIR_RELOCATEONREMOVE))
    {
        //the choice is to orphan. so let it stay as don't care.
        goto CmpEffPolRem_End;
    }
    
    //
    // If the GPO that was used for redirection the last time is not in the
    // changed GPO list, then this is surely a policy removal.
    // otherwise, it can either be a policy removal due to a group change (or
    // a group's policy getting removed from the GPO or it can be just that
    // the policy was changed to Don't care.
    //
    if (bGPOInChangedList)
    {
        //
        // Check if the user is still a member of the group that was used for
        // redirection.
        //
        pGroups = pFileDB->_pGroups;
        for (i = 0, bStatus = FALSE;
             i < pGroups->GroupCount && !bStatus;
             i++
            )
        {
            bStatus = RtlEqualSid (gSavedSettings[m_rID].m_psid, pGroups->Groups[i].Sid);
        }

        if (bStatus)    //the user still belongs to that group.
        {
            //so perhaps the policy for this group was removed.
            //make sure that this is the case.
            Status = ERROR_INVALID_SID;
            if (gSavedSettings[m_rID].m_psid)
            {
                pwszSid [0] = L'\0';
                StringW.Length = 0;
                StringW.MaximumLength = sizeof (pwszSid);
                StringW.Buffer = pwszSid;
                Status = RtlConvertSidToUnicodeString (&StringW, gSavedSettings[m_rID].m_psid, FALSE);
            }

            if (ERROR_SUCCESS != Status)
                goto CmpEffPolRem_End;

            Status = SafeGetPrivateProfileStringW (
                          m_szDisplayName,
                          StringW.Buffer,
                          pwszDefault,
                          &pwszReturnedString,
                          &Size,
                          pwszLocalIniFile
                          );

            if (ERROR_SUCCESS != Status)
                goto CmpEffPolRem_End;

            if (0 != _wcsicmp(pwszReturnedString, pwszDefault))
            {
                //
                // Policy exists for this folder so leave things the way they are.
                // Ideally this is not possible and one should never enter this
                // code path
                //
                goto CmpEffPolRem_End;
            }
        }
    }

    //
    // If the user is no longer a member of the group, then this is clearly
    // a case where the policy is effectively removed because the user was
    // removed from a group that was used for redirection.
    //
    // At any rate, if we are here, then this is a policy removal so make the
    // appropriate settings
    //
    Size = wcslen(L"%USERPROFILE%\\") + wcslen(m_szLocFolderRelativePath) + 1;
    if (m_cbLocSize && (m_cbLocSize < Size))
    {
        delete [] m_szLocation;
        m_cbLocSize = 0;
        m_szLocation = new WCHAR [Size];
        if (!m_szLocation)
        {
            Status = ERROR_OUTOFMEMORY;
            goto CmpEffPolRem_End;
        }
        m_cbLocSize = Size;
    }
    (void) StringCchCopy(m_szLocation, m_cbLocSize, L"%USERPROFILE%\\");
    (void) StringCchCat(m_szLocation, m_cbLocSize, m_szLocFolderRelativePath);
    m_fDataValid = TRUE;
    m_dwFlags = dwFlags;
    m_bRemove = TRUE;
    m_bValidGPO = FALSE;    //since this is a removal.
    m_szGPOName[0] = '\0';
    DebugMsg((DM_VERBOSE, IDS_EFFECTIVE_REMOVE_POLICY, pGPO?pGPO->lpDisplayName:gSavedSettings[m_rID].m_szGPOName, m_szLocDisplayName));

CmpEffPolRem_End:
    if (pwszReturnedString)
        delete [] pwszReturnedString;
    return Status;
}

CRedirectInfo::HasPolicy()
{
    BOOL bHasExplicitPolicy;
    BOOL bHasPolicy;

    bHasExplicitPolicy = ! ( m_dwFlags & REDIR_DONT_CARE );

    //
    // If this folder appears to be explicitly redirected, we
    // should be sure that its parent isn't explicitly denied,
    // if it is configured to follow the parent
    //
    if ( ( m_dwFlags & REDIR_FOLLOW_PARENT ) && m_pParent && bHasExplicitPolicy )
    {
        bHasPolicy = m_pParent->HasPolicy();
    }
    else
    {
        bHasPolicy = bHasExplicitPolicy;
    }
    
    return bHasPolicy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\resource.h ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  Resource.h
//
//  Header file for fdeploy.rc
//
//*************************************************************

#define IDS_STRING              0
#define IDS_PROCESSGPO          1
#define IDS_GPO_FLAGS           2
#define IDS_GPO_NAME            3
#define IDS_GPO_FILESYSPATH     4
#define IDS_GPO_DSPATH          5
#define IDS_GPO_DISPLAYNAME     6
#define IDS_NOCHANGES           7
#define IDS_PROCESSREDIRECTS    8
#define IDS_REDIRECT            9
#define IDS_REDIRECT_DEL_FAIL   10
#define IDS_REDIRECT_INSYNC     11
#define IDS_REDIRECT_PREVPATH   12
#define IDS_REDIRECT_NEWPATH    13
#define IDS_REDIRECT_COPYON     14
#define IDS_REDIRECT_COPYOFF    15
#define IDS_MYDOCSRESTRICT_ON   16
#define IDS_MYDOCSRESTRICT_OFF  17
#define IDS_FOLDERPATH_FAIL     18
#define IDS_NO_LOCALAPPDATA     19
#define IDS_REDIRECT_NO_LOCAL   20
#define IDS_REDIRECT_EXP_FAIL   21
#define IDS_HASADD_POLICY       22
#define IDS_HASREMOVE_POLICY    23
#define IDS_PROCESS_GATHER_OK   24
#define IDS_REDIRECT_DELETE     25
#define IDS_DIRDEL_FAIL         26
#define IDS_FILEDEL_FAIL        27
#define IDS_DIRCREATE_FAIL      28
#define IDS_FILECOPY_FAIL       29
#define IDS_SETSECURITY_FAIL    30
#define IDS_REDIR_NOTSUPPORTED  31
#define IDS_COLLECT_REDIRINFO   32
#define IDS_DERIVEINFO_ERROR    33
#define IDS_ACL_MISMATCH        34
#define IDS_CSCPIN_FAIL         35
#define IDS_GROUP_MEMBER        36
#define IDS_MERGE_FAILURE       37
#define IDS_GATHER_FAILURE      38
#define IDS_INIT_FAILED         39
#define IDS_INVALID_FLAGS       40
#define IDS_DESKTOP             41
#define IDS_MYDOCS              42
#define IDS_MYPICS              43
#define IDS_STARTMENU           44
#define IDS_PROGRAMS            45
#define IDS_STARTUP             46
#define IDS_APPDATA             47
#define IDS_MYPICS_REL          48
#define IDS_PROGRAMS_REL        49
#define IDS_STARTUP_REL         50
#define IDS_DEFAULT_CALLBACK    51
#define IDS_REDIR_CALLBACK      52
#define IDS_IGNORE_DELETEDGPO   53
#define IDS_EFFECTIVE_REMOVE_POLICY     54
#define IDS_CSCDELETE_FAIL      55
#define IDS_CSCRENAME_FAIL      56
#define IDS_UPN_CHANGE          57
#define IDS_GETNAME_FAILED      58
#define IDS_RSOP_ATTRIBUTE_FAIL 59
#define IDS_RSOP_ATTEMPT_WRITE  60
#define IDS_HOMEDIR_EXPANDED    61
#define IDS_HOMEDIR_EXPAND_FAIL 62
#define IDS_QUERYDSFORHOMEDIR   63
#define IDS_OBTAINED_HOMEDIR    64
#define IDS_FAILED_GETHOMEDIR   65
#define IDS_MYPICSLINK_FAILED   66
#define IDS_MYPICSLINK_SUCCEEDED 67
#define IDS_POLICY_DELAYED      68
#define IDS_SKIP_FILE           69
#define IDS_NO_TEMPNAME         70
#define IDS_RENAME_FAILED       71
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\fdeploy.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  fdeploy.cxx
//
//*************************************************************

#include "fdeploy.hxx"
#include "rsopdbg.h"

#define ABORT_IF_NECESSARY      if (pbAbort && *pbAbort)   \
                                {               \
                                    Status = ERROR_REQUEST_ABORTED; \
                                    goto ProcessGPOCleanup;         \
                                    }

#define FLUSH_AND_ABORT_IF_NECESSARY    if (pbAbort && *pbAbort)   \
                                        {               \
                                            Status = ERROR_REQUEST_ABORTED; \
                                            goto ProcessGPOFlush;         \
                                        }

CDebug dbgRsop(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                 L"RsopDebugLevel",
                 L"gpdas.log",
                 L"gpdas.bak",
                 TRUE );



//status callback function
PFNSTATUSMESSAGECALLBACK gpStatusCallback;

//saved per user per machine settings
CSavedSettings gSavedSettings[(int)EndRedirectable];

//if CSC is enabled or not
BOOL    g_bCSCEnabled = FALSE;

// Used for LoadString.
HINSTANCE   ghDllInstance = 0;
HINSTANCE   ghFileDeployment = 0;
WCHAR       gwszStatus[20];
WCHAR       gwszNumber[20];

// User info.
CUsrInfo        gUserInfo;
const WCHAR *   gwszUserName = NULL;


//+--------------------------------------------------------------------------
//
//  Function:   ReinitGlobals
//
//  Synopsis:   Reinitializes the global variables that should not carry
//              over to the next run of folder redirection.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      static members of classes and other global variables are
//              initialized only when the dll is loaded. So if this dll
//              stays loaded across logons, then the fact that the globals
//              have been initialized based on a previous logon can cause
//              problems. Therefore, this function is used to reinitialize
//              the globals.
//
//---------------------------------------------------------------------------
void ReinitGlobals (void)
{
    DWORD       i;
    
    // First reset the static members of various classes.
    CSavedSettings::ResetStaticMembers();
    
    // Now reset members of various global objects.
    gUserInfo.ResetMembers();
    for (i = 0; i < (DWORD) EndRedirectable; i++)
    {
        gSavedSettings[i].ResetMembers();
        gPolicyResultant[i].ResetMembers();
        gAddedPolicyResultant[i].ResetMembers();
        gDeletedPolicyResultant[i].ResetMembers();
    }
    
    return;
}

extern "C" DWORD WINAPI
ProcessGroupPolicyEx (
    DWORD   dwFlags,
    HANDLE  hUserToken,
    HKEY    hKeyRoot,
    PGROUP_POLICY_OBJECT   pDeletedGPOList,
    PGROUP_POLICY_OBJECT   pChangedGPOList,
    ASYNCCOMPLETIONHANDLE   pHandle,
    BOOL*   pbAbort,
    PFNSTATUSMESSAGECALLBACK pStatusCallback,
    IN IWbemServices *pWbemServices,
    HRESULT          *phrRsopStatus )
{
    CRsopContext DiagnosticModeContext( pWbemServices, phrRsopStatus, FDEPLOYEXTENSIONGUID );

    if(! (dwFlags & GPO_INFO_FLAG_MACHINE))
    {
        // Reinitialize all globals that should not get carried over from
        // a previous run of folder redirection. This is necessary just in
        // case this dll is not unloaded by userenv after each run. Also, we should
        // do this before any other processing is done to ensure correct behavior.
        ReinitGlobals();
    }

    return ProcessGroupPolicyInternal (
        dwFlags,
        hUserToken,
        hKeyRoot,
        pDeletedGPOList,
        pChangedGPOList,
        pHandle,
        pbAbort,
        pStatusCallback,
        &DiagnosticModeContext );
}

extern "C" DWORD WINAPI
GenerateGroupPolicy (
    IN DWORD dwFlags,
    IN BOOL  *pbAbort,
    IN WCHAR *pwszSite,
    IN PRSOP_TARGET pComputerTarget,
    IN PRSOP_TARGET pUserTarget )
{
    DWORD Status;

    if(! (dwFlags & GPO_INFO_FLAG_MACHINE))
    {
        // Reinitialize all globals that should not get carried over from
        // a previous run of folder redirection. This is necessary just in
        // case this dll is not unloaded by userenv after each run. Also, we should
        // do this before any other processing is done to ensure correct behavior.
        ReinitGlobals();    
    }

    CRsopContext PlanningModeContext(
        pUserTarget, 
        dwFlags & GPO_INFO_FLAG_REPORT,
        FDEPLOYEXTENSIONGUID );

    Status = ERROR_SUCCESS;

    //
    // There is no machine policy, only user --
    // process only user policy
    //
    if ( pUserTarget && pUserTarget->pGPOList )
    {
        gUserInfo.SetPlanningModeContext( &PlanningModeContext );

        Status = ProcessGroupPolicyInternal(
            dwFlags,
            NULL,
            NULL,
            NULL,
            pUserTarget->pGPOList,
            NULL,
            pbAbort,
            NULL,
            &PlanningModeContext);
    }

    return Status;
}


DWORD ProcessGroupPolicyInternal (
    DWORD   dwFlags,
    HANDLE  hUserToken,
    HKEY    hKeyRoot,
    PGROUP_POLICY_OBJECT   pDeletedGPOList,
    PGROUP_POLICY_OBJECT   pChangedGPOList,
    ASYNCCOMPLETIONHANDLE   pHandle,
    BOOL*   pbAbort,
    PFNSTATUSMESSAGECALLBACK pStatusCallback,
    CRsopContext* pRsopContext )
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   RedirStatus;
    CFileDB CurrentDB;
    DWORD   i;
    PGROUP_POLICY_OBJECT   pCurrGPO = NULL;
    HANDLE  hDupToken = NULL;
    BOOL    fUpdateMyPicsLinks = FALSE;
    BOOL    fPlanningMode;
    BOOL    fWriteRsopLog = FALSE;
    BOOL    bForcedRefresh = FALSE;

    gpStatusCallback = pStatusCallback;

    fPlanningMode = pRsopContext->IsPlanningModeEnabled();

    //some basic initializations first.
    InitDebugSupport();

    //
    // Even though this extension has indicated its preference for not
    // handling machine policies, the admin. might still override these 
    // preferences through policy. Since, this extension is not designed to 
    // handled this situation, we need to explicitly check for these cases and 
    // quit at this point.
    //
    if (dwFlags & GPO_INFO_FLAG_MACHINE)
    {
        DebugMsg((DM_VERBOSE, IDS_INVALID_FLAGS));
        Status = ERROR_INVALID_FLAGS;
        goto ProcessGPOCleanup;
    }

    if ( dwFlags & GPO_INFO_FLAG_VERBOSE )
        gDebugLevel |= DL_VERBOSE | DL_EVENTLOG;

    gpEvents = new CEvents();
    if (!gpEvents)
    {
        DebugMsg((DM_VERBOSE, IDS_INIT_FAILED));
        Status = ERROR_OUTOFMEMORY;
        goto ProcessGPOCleanup;
    }

    Status = gpEvents->Init();
    if (Status != ERROR_SUCCESS) 
    {
        gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
        goto ProcessGPOCleanup;
    }
    gpEvents->Reference();

    DebugMsg((DM_VERBOSE, IDS_PROCESSGPO));
    DebugMsg((DM_VERBOSE, IDS_GPO_FLAGS, dwFlags));


    if ( ! fPlanningMode )
    {
        bStatus = DuplicateToken (hUserToken,
                                  SecurityImpersonation,
                                  &hDupToken);
        if (!bStatus)
        {
            Status = GetLastError();
            gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
            goto ProcessGPOCleanup;
        }

        //impersonate the logged on user,
        bStatus = ImpersonateLoggedOnUser( hDupToken );
        //bail out if impersonation fails
        if (!bStatus)
        {
            gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
            Status = GetLastError();
            goto ProcessGPOCleanup;
        }

        g_bCSCEnabled = CSCIsCSCEnabled ();

        //try to get set ownership privileges. These will be required
        //when we copy over ownership information
        GetSetOwnerPrivileges (hDupToken);

        //get the user name -- this is used for tracking name changes.
        gwszUserName = gUserInfo.GetUserName (Status);
        if (ERROR_SUCCESS != Status)
        {
            DebugMsg ((DM_VERBOSE, IDS_GETNAME_FAILED, Status));
            gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
            goto ProcessGPOCleanup;
        }
    }

    //load the localized folder names and relative paths. (also see
    //notes before the function LoadLocalizedNames()
    Status = LoadLocalizedFolderNames ();
    if (ERROR_SUCCESS != Status)
    {
        gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
        goto ProcessGPOCleanup;
    }

    //now initialize those values for the CFileDB object that are going to
    //be the same across all the policies
    if (ERROR_SUCCESS != (Status = CurrentDB.Initialize(hDupToken, hKeyRoot, pRsopContext )))
    {
        gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
        goto ProcessGPOCleanup;
    }

    if ( ! fPlanningMode )
    {

        //now load the per user per machine settings saved during the last logon
        for (i = 0; i < (DWORD) EndRedirectable; i++)
        {
            Status = gSavedSettings[i].Load (&CurrentDB);
            if (ERROR_SUCCESS != Status)
            {
                gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
                goto ProcessGPOCleanup;
            }
        }
    }

    //now if the GPO_NOCHANGES flag has been specified, make sure that it is
    //okay not to do any processing
    bStatus = TRUE;
    if ( (dwFlags & GPO_INFO_FLAG_NOCHANGES) &&
         !fPlanningMode &&
        !( dwFlags & GPO_INFO_FLAG_LOGRSOP_TRANSITION ) )
    {
        for (bStatus = FALSE, i = 0;
             i < (DWORD)EndRedirectable && (!bStatus);
             i++)
        {
            bStatus = gSavedSettings[i].NeedsProcessing();
        }
    }

    if (!bStatus)   //we are in good shape. No processing is required.
    {
        Status = ERROR_SUCCESS;
        DebugMsg ((DM_VERBOSE, IDS_NOCHANGES));
        goto ProcessGPOCleanup;
    }
    else
    {
        if ((dwFlags & GPO_INFO_FLAG_BACKGROUND) ||
            (dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND))
        {
            //
            // Log an event only in the async. foreground case. In all other
            // cases just output a debug message. Note: The Background flag
            // will be set even in the async. foreground case. So we must
            // explicitly make this check against the async. foreground
            // flag.
            //
            if (dwFlags & GPO_INFO_FLAG_ASYNC_FOREGROUND)
            {
                gpEvents->Report (EVENT_FDEPLOY_POLICY_DELAYED, 0);
            }
            else
            {
                DebugMsg ((DM_VERBOSE, IDS_POLICY_DELAYED));
            }
            Status = ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
            goto ProcessGPOCleanup;
        }

        if ( ! fPlanningMode &&
             (dwFlags & GPO_INFO_FLAG_NOCHANGES))
        {
            // a user name or homedir change has occured and no gpo changes occurred,
            // so in order to perform RSoP logging, we will need to get our own
            // RSoP namespace since the GP engine does not give us the namespace
            // if no changes occurred -- we note this below

            bForcedRefresh = TRUE;
            fWriteRsopLog = TRUE;
        }
    }

    //
    // If we have changes or we are in planning mode, enable logging
    //
    if ( pChangedGPOList || pDeletedGPOList || fPlanningMode )
    {
        fWriteRsopLog = TRUE;
    }

    if ( fWriteRsopLog )
    {
        //
        // If RSoP logging should occur in logging mode, initialize
        // the rsop context -- this is not necessary in planning mode
        //
        if ( pRsopContext->IsDiagnosticModeEnabled() )
        {
            PSID pUserSid;

            pUserSid = gpEvents->UserSid();

            if ( pUserSid )
            {
                // This call requires elevated privileges to succeed.
                RevertToSelf();
                (void) pRsopContext->InitializeContext( pUserSid );
                // Re-impersonate the logged on user,
                bStatus = ImpersonateLoggedOnUser( hDupToken );
                // Bail out if impersonation fails
                if (!bStatus)
                {
                    gpEvents->Report (EVENT_FDEPLOY_INIT_FAILED, 0);
                    Status = GetLastError();
                    goto ProcessGPOCleanup;
                }
            }
            else
            {
                pRsopContext->DisableRsop( ERROR_OUTOFMEMORY );
            }
        }

        CurrentDB.InitRsop( pRsopContext, bForcedRefresh );
    }

    //first process any user name changes.
    for (i = 0; i < (DWORD) EndRedirectable; i++)
    {
        Status = gSavedSettings[i].HandleUserNameChange(
                                            &CurrentDB,
                                            &(gPolicyResultant[i]));
        if (ERROR_SUCCESS != Status)
        {
            // Failure events will be reported while processing the name change
            goto ProcessGPOCleanup;
        }
    }

    //first process the deleted GPOs
    //we need to do this in reverse, because removed policies are sent
    //in reverse, that is the closest policy is sent last. So if you have
    //two policies that redirect the same folder and both of them are removed
    //simultaneously, then, the code gets the wrong value for the redirection
    //destination of the resultant set of removed policies and therefore
    //assumes that someone else must have modified it and therefore leaves it
    //alone
    if (pDeletedGPOList)
    {
        //go all the way to the end
        for (pCurrGPO = pDeletedGPOList; pCurrGPO->pNext; pCurrGPO = pCurrGPO->pNext)
            ;
        //now pCurrGPO points to the last policy in the removed list, so go at
        //it in the reverse order.
        for (; pCurrGPO; pCurrGPO = pCurrGPO->pPrev)
        {
            DebugMsg((DM_VERBOSE, IDS_GPO_NAME, pCurrGPO->szGPOName));
            DebugMsg((DM_VERBOSE, IDS_GPO_FILESYSPATH, pCurrGPO->lpFileSysPath));
            DebugMsg((DM_VERBOSE, IDS_GPO_DSPATH, pCurrGPO->lpDSPath));
            DebugMsg((DM_VERBOSE, IDS_GPO_DISPLAYNAME, pCurrGPO->lpDisplayName));

            //if we are unable to process even a single policy, we must abort
            //immediately otherwise we may end up with an incorrect resultant
            //policy.
            if (ERROR_SUCCESS != (Status = CurrentDB.Process (pCurrGPO, TRUE)))
                goto ProcessGPOCleanup;

            ABORT_IF_NECESSARY
        }
    }

    //update the descendants
    Status = gDeletedPolicyResultant[(int) MyPics].UpdateDescendant ();

    if ( ERROR_SUCCESS != Status )
    {
        goto ProcessGPOCleanup;
    }

    //now process the other GPOs
    for (pCurrGPO = pChangedGPOList; pCurrGPO; pCurrGPO = pCurrGPO->pNext)
    {
        DebugMsg((DM_VERBOSE, IDS_GPO_NAME, pCurrGPO->szGPOName));
        DebugMsg((DM_VERBOSE, IDS_GPO_FILESYSPATH, pCurrGPO->lpFileSysPath));
        DebugMsg((DM_VERBOSE, IDS_GPO_DSPATH, pCurrGPO->lpDSPath));
        DebugMsg((DM_VERBOSE, IDS_GPO_DISPLAYNAME, pCurrGPO->lpDisplayName));

        //if we are unable to process even a single policy, we must abort
        //immediately otherwise we may end up with an incorrect resultant
        //policy.
        if (ERROR_SUCCESS != (Status = CurrentDB.Process (pCurrGPO, FALSE)))
        {
            goto ProcessGPOCleanup;
        }

        ABORT_IF_NECESSARY
    }

    if ( fPlanningMode )
    {
        goto ProcessGPOCleanup;
    }

    //now update the My Pics data. UpdateDescendant will derive the settings for
    //My Pics from My Docs if it is set to derive its settings from My Docs.
    gAddedPolicyResultant[(int) MyPics].UpdateDescendant ();

    //now merge the deleted policy resultant and added policy resultants
    for (i = 0; i < (DWORD) EndRedirectable; i++)
    {
        gPolicyResultant[i] = gDeletedPolicyResultant[i];
        gPolicyResultant[i] = gAddedPolicyResultant[i];
        //check to see if any group membership change has caused a policy to
        //be effectively removed for this user.
        Status = gPolicyResultant[i].ComputeEffectivePolicyRemoval (pDeletedGPOList,
                                                           pChangedGPOList,
                                                           &CurrentDB);
        if ( ERROR_SUCCESS != Status )
        {
            goto ProcessGPOCleanup;
        }
    }

    //do the final redirection
    //we ignore errors that might occur in redirection
    //so that redirection of other folders is not hampered.
    //however, if there is a failure, we save that information
    //so that we can inform the group policy engine

    if (ERROR_SUCCESS == Status)
    {
        for (i = 0; i < (int)EndRedirectable; i++)
        {
            RedirStatus= gPolicyResultant[i].Redirect(hDupToken, hKeyRoot,
                                                      &CurrentDB);

            if ((ERROR_SUCCESS != RedirStatus) && (ERROR_SUCCESS == Status))
                Status = RedirStatus;

            FLUSH_AND_ABORT_IF_NECESSARY    //abort if necessary, but first, flush the shell's special folder cache
                                            ///as we may have redirected some folders already.
        }

        //update shell links to MyPics within MyDocuments if policy specified
        //the location of at least one of MyDocs and MyPics and succeeded in
        //redirection. For additional details see comments at the beginning of
        //the function UpdateMyPicsShellLinks.
        if (
            (
             (!(gPolicyResultant[(int)MyDocs].GetFlags() & REDIR_DONT_CARE)) &&
             (ERROR_SUCCESS == gPolicyResultant[(int)MyDocs].GetRedirStatus())
            )
            ||
            (
             (!(gPolicyResultant[(int)MyPics].GetFlags() & REDIR_DONT_CARE)) &&
             (ERROR_SUCCESS == gPolicyResultant[(int)MyPics].GetRedirStatus())
            )
           )
        {
            fUpdateMyPicsLinks = TRUE;
            //note:we do not invoke the shell link update function here since
            //we need to flush the shell special folder cache or we may not
            //get the true current location of MyDocs or MyPics. Therefore,
            //the function is actually invoked below.
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, IDS_PROCESSREDIRECTS, Status));
    }

    //
    // Do not try to update the link (shell shortcut) in planning mode since
    // planning mode takes no real action, just records results
    //
    if ( fPlanningMode )
    {
        fUpdateMyPicsLinks = FALSE;
    }


    //flush the shell's special folder cache. we may have successfully redirected
    //some folders by the time we reach here. So it is always a good idea to let
    //the shell know about it.

ProcessGPOFlush:
    if (fUpdateMyPicsLinks)
        UpdateMyPicsShellLinks(hDupToken,
                               gPolicyResultant[(int)MyPics].GetLocalizedName());

ProcessGPOCleanup:  //don't leave any turds behind.

    if ( (ERROR_SUCCESS == Status) && !fPlanningMode )
    {
        //we have successfully applied all the policies, so remove any cached
        //ini files for removed policies.
        //any errors in deletion are ignored.
        DeleteCachedConfigFiles (pDeletedGPOList, &CurrentDB);
    }

    //we are done, so we stop running as the user
    if ( ! fPlanningMode )
    {
        RevertToSelf();
    }
    
    // In logging (aka diagnostic) mode, we need to ensure that
    // we reset the saved namespace before logging so that in the
    // no changes case where we need to log ( i.e. username / homedir change ),
    // we only log rsop data if RSoP was enabled at the last change

    if ( fWriteRsopLog )
    {
        (void) pRsopContext->DeleteSavedNameSpace();

        if ( pRsopContext->IsRsopEnabled() )
        {
            HRESULT hrLog;
            
            hrLog = CurrentDB.WriteRsopLog();
            
            if ( SUCCEEDED( hrLog ) )
            {
                (void) pRsopContext->SaveNameSpace();
            }
        }
    }

    if ( ! fPlanningMode )
    {
        if (hDupToken)
            CloseHandle (hDupToken);
    }
    else
    {
        Status = CurrentDB.GetPlanningSimulatedErrorIfNecessary( Status );
    }

    if (gpEvents)
        gpEvents->Release();

    //restore the status message
    DisplayStatusMessage (IDS_DEFAULT_CALLBACK);

    // CPolicyDatabase::FreeDatabase();

    return Status;
}


extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH :
        ghDllInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);
        break;
    case DLL_PROCESS_DETACH :
        break;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    DWORD   dwDisp;
    LONG    lResult;
    HKEY    hkSource = NULL;
    HKEY    hKey = NULL;
    TCHAR   EventFile[]    = TEXT("%SystemRoot%\\System32\\fdeploy.dll");
    TCHAR   ParamFile[]    = TEXT("%SystemRoot%\\System32\\kernel32.dll");
    WCHAR   EventSources[] = TEXT("(Folder Redirection,Application)\0" );
    DWORD   dwTypes        = 0x7;
    DWORD   dwSet          = 1;
    DWORD   dwReset        = 0;
    HRESULT hr = S_OK;

    //register the dll as an extension of the policy engine
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{25537BA6-77A8-11D2-9B6C-0000F8080861}"),
                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                              NULL, &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        hr = SELFREG_E_CLASS;
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE) TEXT("Folder Redirection"),
                             (lstrlen (TEXT("Folder Redirection")) + 1) * sizeof (TCHAR));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hKey, TEXT("ProcessGroupPolicyEx"), 0, REG_SZ, (LPBYTE)TEXT("ProcessGroupPolicyEx"),
                             (lstrlen(TEXT("ProcessGroupPolicyEx")) + 1) * sizeof(TCHAR));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hKey, TEXT("DllName"), 0, REG_EXPAND_SZ, (LPBYTE)TEXT("fdeploy.dll"),
                             (lstrlen(TEXT("fdeploy.dll")) + 1) * sizeof(TCHAR));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hKey, TEXT("NoMachinePolicy"), 0, REG_DWORD,
                             (LPBYTE)&dwSet, sizeof (dwSet));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hKey, TEXT("NoSlowLink"), 0, REG_DWORD,
                             (LPBYTE)&dwSet, sizeof (dwSet));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hKey, TEXT("PerUserLocalSettings"), 0, REG_DWORD,
                             (LPBYTE)&dwSet, sizeof (dwSet));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    //we want the folder redirection extension to get loaded each time.
    lResult = RegSetValueEx (hKey, TEXT("NoGPOListChanges"), 0, REG_DWORD,
                             (LPBYTE)&dwReset, sizeof (dwReset));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    //
    // New perf. stuff. We also want to get called in the background and
    // async. foreground case.
    //
    lResult = RegSetValueEx (hKey, TEXT("NoBackgroundPolicy"), 0, REG_DWORD,
                             (LPBYTE)&dwReset, sizeof (dwReset));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hKey, TEXT("GenerateGroupPolicy"), 0, REG_SZ, (LPBYTE)TEXT("GenerateGroupPolicy"),
                             (lstrlen (TEXT("GenerateGroupPolicy")) + 1) * sizeof(TCHAR));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    // Need to register event sources for RSoP
    lResult = RegSetValueEx (hKey, TEXT("EventSources"), 0, REG_MULTI_SZ, (LPBYTE)EventSources,
                   sizeof(EventSources) );
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }    

    //register the dll as a source for event log messages
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Folder Redirection"),
                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                              NULL, &hkSource, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        hr = SELFREG_E_CLASS;
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hkSource, TEXT("EventMessageFile"), 0, REG_EXPAND_SZ, (LPBYTE) EventFile,
                             (lstrlen(EventFile) + 1) * sizeof (TCHAR));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hkSource, TEXT("ParameterMessageFile"), 0, REG_EXPAND_SZ, (LPBYTE) ParamFile,
                             (lstrlen(ParamFile) + 1) * sizeof (TCHAR));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    lResult = RegSetValueEx (hkSource, TEXT("TypesSupported"), 0, REG_DWORD, (LPBYTE) &dwTypes,
                             sizeof(DWORD));
    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto DllRegisterServer_exit;
    }

    hr = S_OK;

DllRegisterServer_exit:

    if ( hKey )
    {
        RegCloseKey (hKey);
    }

    if ( hkSource )
    {
        RegCloseKey (hkSource);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    RegDelnode (HKEY_LOCAL_MACHINE,
                TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{25537BA6-77A8-11D2-9B6C-0000F8080861}"));
    RegDelnode (HKEY_LOCAL_MACHINE,
                     TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Folder Redirection"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\filedb.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  filedb.cxx
//
//*************************************************************

#include "fdeploy.hxx"

#define SAVED_SETTINGS_FILE     L"{25537BA6-77A8-11D2-9B6C-0000F8080861}.ini"

HRESULT RsopSidsFromToken(PRSOPTOKEN     pRsopToken,
                          PTOKEN_GROUPS* ppGroups);

FOLDERINFO gUserShellFolders[] =
{
  {CSIDL_APPDATA, 17, L"Application Data\\"},
  // {CSIDL_COOKIES, 8, L"Cookies\\"},
  {CSIDL_DESKTOPDIRECTORY, 8, L"Desktop\\"},
  {CSIDL_FAVORITES, 10, L"Favorites\\"},
  // {CSIDL_HISTORY, 8, L"History\\"},
  // {0, 15, L"Local Settings\\"}, Has no reg key, no CSIDL
  {CSIDL_MYPICTURES, 25, L"My Documents\\My Pictures\\"},
  {CSIDL_PERSONAL, 13, L"My Documents\\"},
  {CSIDL_NETHOOD, 8, L"NetHood\\"},
  {CSIDL_PRINTHOOD, 10, L"PrintHood\\"},
  // {CSIDL_RECENT, 7, L"Recent\\"},
  {CSIDL_SENDTO,  7, L"SendTo\\"},
  {CSIDL_STARTUP, 28, L"Start Menu\\Programs\\Startup\\"},
  {CSIDL_PROGRAMS, 20, L"Start Menu\\Programs\\"},
  {CSIDL_STARTMENU, 11, L"Start Menu\\"},
  {CSIDL_TEMPLATES, 10, L"Templates\\"},
  // {CSIDL_INTERNET_CACHE, 25, L"Temporary Internet Files\\"},
  {0, 0, NULL }
};

FOLDERINFO gMachineShellFolders[] =
{
  {CSIDL_COMMON_APPDATA, 17, L"Application Data\\"},
  {CSIDL_COMMON_DESKTOPDIRECTORY, 8, L"Desktop\\"},
  // {0, 10, L"Documents\\"}, No shell support
  {CSIDL_COMMON_STARTUP, 28, L"Start Menu\\Programs\\Startup\\"},
  {CSIDL_COMMON_PROGRAMS, 20, L"Start Menu\\Programs\\"},
  {CSIDL_COMMON_STARTMENU, 11, L"Start Menu\\"},
  {0, 0, NULL}
};

static DWORD gSchema = 1;

CFileDB::CFileDB()
{
    _hUserToken = 0;
    _hkRoot = 0;
    _pEnvBlock = 0;
    _pGroups = 0;
    _pwszGPTPath = 0;
    _GPTPathLen = 0;
    _pwszIniFilePath = 0;
    _IniFileLen = 0;
    _pwszGPOName = 0;
    _pwszGPOUniqueName = 0;
    _pwszGPOSOMPath = 0;
    _pRsopContext = 0;
}

CFileDB::~CFileDB()
{
    if ( _pEnvBlock )
        DestroyEnvironmentBlock( _pEnvBlock );
    if (_pwszGPTPath)
        delete [] _pwszGPTPath;
    if (_pwszIniFilePath)
        delete [] _pwszIniFilePath;

    //
    // Note that _pGroups must be freed with LocalFree --
    // we are able to free it with delete because we
    // have redefined delete to be LocalFree
    //
    if (_pGroups)
        delete [] (BYTE*) _pGroups;

    // _pwszGPOName is not allocated
    // _pwszGPOUniqueName is not allocated
    // _pwszGPODSPath is not allocated
}

DWORD CFileDB::Initialize (
    HANDLE        hUserToken,
    HKEY          hkRoot,
    CRsopContext* pRsopContext)
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    ULONG   Size;
    int     CSidl;
    WCHAR * pwszSlash;
    HRESULT hr;
    HANDLE  hFind;
    WIN32_FIND_DATA FindData;

    //set the token
    _hUserToken = hUserToken;

    //set the root key
    _hkRoot = hkRoot;

    // set the rsop logging context
    _pRsopContext = pRsopContext;

    //create an environment block for the user. we need this for expanding
    //variables.
    if (! _pEnvBlock)
    {
        if (!CreateEnvironmentBlock ( &_pEnvBlock, _hUserToken, FALSE))
        {
            Status = GetLastError();
            goto InitializeEnd;
        }
    }

    //get the list of group to which the user belongs
    _pGroups = 0;
    Size = 0;

    //
    // We may only use the Nt security subsystem api below
    // to retrieve groups when we are not in planning mode
    //
    for (; ! _pRsopContext->IsPlanningModeEnabled() ;)
    {
        Status = NtQueryInformationToken(
                     _hUserToken,
                     TokenGroups,
                     _pGroups,
                     Size,
                     &Size );

        if ( (STATUS_BUFFER_TOO_SMALL == Status) || (ERROR_OUTOFMEMORY == Status) )
        {
            _pGroups = (PTOKEN_GROUPS) new BYTE [ Size ];
            if ( ! _pGroups )
            {
                Status = ERROR_OUTOFMEMORY;
                break;
            }

            continue;
        }

        if ( Status != STATUS_SUCCESS )
        {
            if (_pGroups)
                delete [] ((BYTE*) _pGroups);
            _pGroups = 0;
        }

        break;
    }

    //
    // In planning mode, we get our security groups from
    // the policy engine's simulated token, not from a real token
    //
    if ( _pRsopContext->IsPlanningModeEnabled() &&
         ! _pRsopContext->IsReportingModeEnabled() )
    {
        DWORD        cbSize;
        PRSOP_TARGET pRsopTarget;

        pRsopTarget = _pRsopContext->_pRsopTarget;

        //
        // The call below uses RSoP's planning mode "simulated"
        // security subsystem to retrieve the sids from the simulated
        // token.  The function allocates memory in _pGroups that
        // must be freed with LocalFree.
        //
        hr = RsopSidsFromToken(pRsopTarget->pRsopToken, &_pGroups);

        Status = HRESULT_CODE(hr);
    }


    if (ERROR_SUCCESS != Status)
        goto InitializeEnd;

    //
    // Retrieve the local path -- note that we do not need this in planning mode
    //

    if ( ! _pRsopContext->IsPlanningModeEnabled() )
    {
        //get the path to our directory under Local Settings.
        CSidl = CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE;

        hr = SHGetFolderPath( NULL, CSidl, _hUserToken, 0, _pwszLocalPath );

        if ( hr != S_OK )
        {
            //try to get the last error.
            if (FACILITY_WIN32 == HRESULT_FACILITY (hr))
            {
                Status = HRESULT_CODE(hr);
            }
            else
            {
                Status = GetLastError();
                if (ERROR_SUCCESS == Status)
                {
                    //an error had occurred but nobody called SetLastError
                    //should not be mistaken as a success.
                    Status = (DWORD) hr;
                }
            }
            DebugMsg((DM_WARNING, IDS_NO_LOCALAPPDATA, Status));
            goto InitializeEnd;
        }

        pwszSlash = _pwszLocalPath + wcslen( _pwszLocalPath );
        hr = StringCchCat( _pwszLocalPath, MAX_PATH, L"\\Microsoft\\Windows\\File Deployment" );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto InitializeEnd;
        }

        Status = ERROR_SUCCESS;
        //now create directories as necessary
        // Quick check to see if we have necessary local dirs.
        hFind = FindFirstFile( _pwszLocalPath, &FindData );

        if ( INVALID_HANDLE_VALUE == hFind )
        {
            do
            {
                pwszSlash = wcschr( &pwszSlash[1], L'\\' );

                if ( pwszSlash )
                    *pwszSlash = 0;

                bStatus = CreateDirectory( _pwszLocalPath, NULL );
                if ( ! bStatus && (GetLastError() != ERROR_ALREADY_EXISTS) )
                {
                    Status = GetLastError();
                    break;
                }

                if ( pwszSlash )
                    *pwszSlash = L'\\';
            } while ( pwszSlash );
        }
        else
        {
            FindClose( hFind );
        }
    }


InitializeEnd:
    return Status;
}


DWORD
CFileDB::Process(
    PGROUP_POLICY_OBJECT pGPO,
    BOOL    bRemove
    )
{
    WCHAR * pwszGPTIniFilePath = NULL;
    DWORD   Length = 0;
    DWORD   Status;
    DWORD   ProcessStatus;
    BOOL    bStatus;
    BOOL    bPolicyApplied;
    HANDLE  hFind;
    DWORD   dwAttr = INVALID_FILE_ATTRIBUTES;
    WIN32_FIND_DATA FindData;
    HRESULT hr = S_OK;

    if ( bRemove && _pRsopContext->IsPlanningModeEnabled() )
    {
        return ERROR_INVALID_PARAMETER;
    }

    bPolicyApplied = FALSE;
    Status = ERROR_SUCCESS;

    //first initialize the variables that vary with policies
    _bRemove = bRemove;
    if ( ! _bRemove )
    {
        Length = wcslen(pGPO->lpFileSysPath) + wcslen(GPT_SUBDIR) + 1;
        if (Length > _GPTPathLen)
        {
            //we need more memory than has been allocated.
            //so get that before proceeding
            if (_pwszGPTPath)
                delete _pwszGPTPath;
            _GPTPathLen = 0;    //make sure that this always reflects the correct value
            _pwszGPTPath = new WCHAR [Length];
            if ( ! _pwszGPTPath )
            {
                Status = ERROR_OUTOFMEMORY;
                goto ProcessEnd;
            }
            _GPTPathLen = Length;   //make sure that this always reflects the correct value
        }

        hr = StringCchCopy( _pwszGPTPath, _GPTPathLen, pGPO->lpFileSysPath );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }
        hr = StringCchCat( _pwszGPTPath, _GPTPathLen, GPT_SUBDIR );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }

        Length += wcslen( INIFILE_NAME );
        pwszGPTIniFilePath = new WCHAR[ Length ];
        if ( ! pwszGPTIniFilePath )
        {
            Status = ERROR_OUTOFMEMORY;
            goto ProcessEnd;
        }

        hr = StringCchCopy( pwszGPTIniFilePath, Length, _pwszGPTPath );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }
        hr = StringCchCat( pwszGPTIniFilePath, Length, INIFILE_NAME );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }

        //
        // Do a quick check to see if we have any file deployment
        // for this policy.
        //
        hFind = FindFirstFile( pwszGPTIniFilePath, &FindData );

        if ( INVALID_HANDLE_VALUE == hFind )
        {
            Status = GetLastError();
            goto ProcessEnd;
        }
        else
        {
            bPolicyApplied = TRUE;
            DebugMsg((DM_VERBOSE, IDS_HASADD_POLICY, pGPO->lpDisplayName));
            FindClose( hFind );
        }
    }

    Status = ERROR_SUCCESS;

    if ( _pRsopContext->IsPlanningModeEnabled() )
    {
        Length = wcslen( pwszGPTIniFilePath ) + 1;
    }
    else
    {
        Length = wcslen( _pwszLocalPath ) + wcslen( pGPO->szGPOName ) + 6;
    }

    if (Length > _IniFileLen)
    {
        //we need more memory than has been allocated
        if (_pwszIniFilePath)
            delete [] _pwszIniFilePath;
        _IniFileLen = 0;    //make sure that this always reflects the current value
        _pwszIniFilePath = new WCHAR[Length];
        if ( ! _pwszIniFilePath )
        {
            Status = ERROR_OUTOFMEMORY;
            goto ProcessEnd;
        }
        _IniFileLen = Length;   //make sure that this always reflects the current value
    }

    if ( _pRsopContext->IsPlanningModeEnabled() )
    {
        hr = StringCchCopy( _pwszIniFilePath, _IniFileLen, pwszGPTIniFilePath );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }
    }
    else
    {
        hr = StringCchCopy( _pwszIniFilePath, _IniFileLen, _pwszLocalPath );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }
        hr = StringCchCat( _pwszIniFilePath, _IniFileLen, L"\\" );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }
        hr = StringCchCat( _pwszIniFilePath, _IniFileLen, pGPO->szGPOName );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }
        hr = StringCchCat( _pwszIniFilePath, _IniFileLen, L".ini" );
        if ( FAILED(hr) )
        {
            Status = HRESULT_CODE(hr);
            goto ProcessEnd;
        }
    }

    if ( _bRemove )
    {
        hFind = FindFirstFile( _pwszIniFilePath, &FindData );

        if ( INVALID_HANDLE_VALUE == hFind )
        {
            //this error should be ignored since there is nothing we can do.
            //the policy has been deleted and the local settings are missing
            //so we have no choice but to treat these as if the settings were
            //to orphan the folder upon policy removal.
            goto ProcessEnd;
        }
        else
        {
            bPolicyApplied = TRUE;
            DebugMsg((DM_VERBOSE, IDS_HASREMOVE_POLICY, pGPO->lpDisplayName));
            FindClose( hFind );
        }
    }
    else if ( ! _pRsopContext->IsPlanningModeEnabled() )
    {
        //
        // Cache the ini file locally. Note that if a local copy of the GPO already
        // exists and it has hidden/read-only/system attributes, then the CopyFile
        // API will fail with ERROR_ACCESS_DENIED unless the source (on the sysvol) 
        // has the same attributes.
        // Therefore we first slap on normal attributes on the local copy if any
        // and restore the original attributes if we fail in the CopyFile.
        //
        
        dwAttr = GetFileAttributes (_pwszIniFilePath);
        //
        // Don't set the file attributes to normal unless GetFileAttributes
        // succeeds
        //
        if (INVALID_FILE_ATTRIBUTES != dwAttr)
            SetFileAttributes (_pwszIniFilePath, FILE_ATTRIBUTE_NORMAL);
        bStatus = CopyFile( pwszGPTIniFilePath, _pwszIniFilePath, FALSE );
        if ( ! bStatus )
        {
            Status = GetLastError();
            //
            // Restore the local cache's attributes (if we had changed them)
            // since our copy operation has failed.
            //
            if (INVALID_FILE_ATTRIBUTES != dwAttr)
                SetFileAttributes (_pwszIniFilePath, dwAttr);
        }
    }

    if ( Status != ERROR_SUCCESS )
        goto ProcessEnd;

    _pwszGPOName = (WCHAR *) pGPO->lpDisplayName;
    _pwszGPOUniqueName = (WCHAR *) pGPO->szGPOName;
    _pwszGPOSOMPath = ( WCHAR *) pGPO->lpLink;
    _pwszGPODSPath = ( WCHAR *) pGPO->lpDSPath;

    ProcessStatus = ProcessRedirects();

    if ( (ProcessStatus != ERROR_SUCCESS) && (ERROR_SUCCESS == Status) )
        Status = ProcessStatus;

ProcessEnd:

    if ( Status != ERROR_SUCCESS )
    {
        gpEvents->Report (
                   EVENT_FDEPLOY_POLICYPROCESS_FAIL,
                   2,
                   pGPO->lpDisplayName,
                   StatusToString (Status)
                   );
    }
    else if ( bPolicyApplied )
    {
        DebugMsg((DM_VERBOSE, IDS_PROCESS_GATHER_OK, pGPO->lpDisplayName));
    }

    delete [] pwszGPTIniFilePath;

    return Status;
}


DWORD
CFileDB::ProcessRedirects(void)
{
    WCHAR *         pwszString = 0;
    WCHAR *         pwszSectionStrings = 0;
    WCHAR *         pwszRedirection = 0;
    WCHAR           wszFolderName[80];
    UNICODE_STRING  String;
    DWORD           Flags;
    DWORD           RedirectStatus;
    DWORD           Status;
    BOOL            bStatus;
    REDIRECTABLE    index;
    DWORD           RedirStatus;
    CRedirectInfo   riPolicy [(int) EndRedirectable];   //the redirection info. for this policy
    DWORD           i;

    //first load the localized folder names
    for (i = 0, Status = ERROR_SUCCESS; i < (DWORD)EndRedirectable; i++)
    {
        Status = riPolicy[i].LoadLocalizedNames();
        if (ERROR_SUCCESS != Status)
            return Status;  //bail out if the resource names cannot be loaded.
    }

    pwszSectionStrings = 0;

    bStatus = ReadIniSection( L"FolderStatus", &pwszSectionStrings );

    if ( ! bStatus )
    {
        Status = ERROR_OUTOFMEMORY;
        goto ProcessRedirectsEnd;
    }

    Status = ERROR_SUCCESS;

    for ( pwszString = pwszSectionStrings;
          *pwszString != 0;
          pwszString += lstrlen(pwszString) + 1 )
    {
        //
        // The syntax for each line is :
        //   foldername=FLAGS
        //

        //
        // First extract the foldername.
        //

        pwszRedirection = wcschr( pwszString, L'=' );
        if (!pwszRedirection)
        {
            Status = ERROR_FILE_CORRUPT;
            goto ProcessRedirectsEnd;
        }
        *pwszRedirection = 0;
        Status = HRESULT_CODE(StringCbCopy( wszFolderName, sizeof(wszFolderName), pwszString ));
        if ( Status != ERROR_SUCCESS )
        {
            goto ProcessRedirectsEnd;
        }
        *pwszRedirection++ = L'=';

        //
        // Now grab the hex FLAGS.
        //

        String.Buffer = pwszRedirection;

        pwszRedirection = wcschr( pwszRedirection, L' ' );
        if ( pwszRedirection )
            *pwszRedirection = 0;

        String.Length = wcslen( String.Buffer ) * sizeof(WCHAR);
        String.MaximumLength = String.Length + sizeof(WCHAR);

        RtlUnicodeStringToInteger( &String, 16, &Flags );

        //just gather the information here.
        //actual redirections are performed in ProcessGPO after all the policies
        //have been processed.
        if (EndRedirectable ==
            (index = CRedirectInfo::GetFolderIndex (wszFolderName)))
        {
            //redirection of this folder is not supported
            DebugMsg ((DM_VERBOSE, IDS_REDIR_NOTSUPPORTED, wszFolderName));
        }
        else
        {
            //if this is a policy that has been removed and it was decided to
            //orphan the contents, we don't even look at it
            if (!_bRemove || (Flags & (REDIR_RELOCATEONREMOVE | REDIR_FOLLOW_PARENT)))
            {
                //if there is a problem in gathering redirection info. for a folder
                //quit immediately, or we might end up computing an incorrect
                //resultant policy
                if (ERROR_SUCCESS != (Status = riPolicy [(int) index].GatherRedirectionInfo (this, Flags, _bRemove)))
                    goto ProcessRedirectsEnd;
            }
        }
    }
    
    //now update the data stored in the descendant objects
    //this is required because if the descendants follow the parent
    //then the settings need to be obtained from the parent
    //note that we do not call UpdateDescendant for MyPics here, but in fdeploy.cxx
    //for details on why we do this, look at comments in operator= in redir.cxx
    Status = riPolicy[(int) Programs].UpdateDescendant();

    if ( ERROR_SUCCESS == Status )
    {
        Status = riPolicy[(int) Startup].UpdateDescendant(); //this call must be made after Programs has been updated
    }

    if ( ERROR_SUCCESS != Status )
    {
        goto ProcessRedirectsEnd;
    }

    //merge info into the global redirection store
    for (i = 0; i < (DWORD) EndRedirectable; i++)
    {
        if (_bRemove)
            gDeletedPolicyResultant[i] = riPolicy[i];
        else
            gAddedPolicyResultant[i] = riPolicy[i];
    }

ProcessRedirectsEnd:
    delete pwszSectionStrings;

    if ( ERROR_SUCCESS != Status )
    {
        DebugMsg((DM_VERBOSE, IDS_PROCESSREDIRECTS, Status));
    }
    else
    {
        if ( ! _bRemove && _pRsopContext->IsRsopEnabled() )
        {
            (void) AddRedirectionPolicies(
                this,
                riPolicy);
        }
    }

    return Status;
}


BOOL
CFileDB::ReadIniSection(
    WCHAR *     pwszSectionName,
    WCHAR **    ppwszStrings,
    DWORD *     pcchLen
    )
{
    DWORD   Length;
    DWORD   ReturnLength;

    *ppwszStrings = 0;
    Length = 256;

    for (;;)
    {
        // prevent a corrupt Ini file from eating up all available memory.
        if (MaxIniSectionSize < Length)
            return FALSE;

        delete *ppwszStrings;
        *ppwszStrings = new WCHAR[Length];

        if ( ! *ppwszStrings )
            return FALSE;

        ReturnLength = GetPrivateProfileSection(
                            pwszSectionName,
                            *ppwszStrings,
                            Length,
                            _pwszIniFilePath );

        if ( ReturnLength != (Length - 2) )
        {
            if (pcchLen)
            {
                *pcchLen = ReturnLength;
            }

            return TRUE;
        }

        Length *= 2;
    }
}

DWORD
CFileDB::GetLocalFilePath(
    WCHAR *         pwszFolderPath,
    WCHAR *         wszFullPath
    )
{
    int CSidl;
    DWORD Status;
    HRESULT hr;
    WCHAR * pwszFolderName;

    CSidl = CSIDL_FLAG_MASK;    //use a value that is not a valid CSIDL value for any folder.

    for (DWORD n = 0; gUserShellFolders[n].FolderName; n++)
    {
        if (0 == _wcsicmp (pwszFolderPath, gUserShellFolders[n].FolderName))
        {
            pwszFolderName = gUserShellFolders[n].FolderName;
            CSidl = gUserShellFolders[n].CSidl;
            break;
        }
    }

    if ( CSIDL_FLAG_MASK != CSidl )
    {
        hr = SHGetFolderPath( 0, CSidl | CSIDL_FLAG_DONT_VERIFY,
                              _hUserToken, 0, wszFullPath );
        Status = GetWin32ErrFromHResult (hr);

        if ( ERROR_SUCCESS != Status )
        {
            DebugMsg((DM_WARNING, IDS_FOLDERPATH_FAIL, pwszFolderName, Status));
            return Status;
        }
    }
    else
        return ERROR_INVALID_NAME;

    return ERROR_SUCCESS;
}

DWORD
CFileDB::GetPathFromFolderName(
    WCHAR *     pwszFolderName,
    WCHAR *     wszFullPath
    )
{
    int CSidl;
    DWORD Status;
    HRESULT hr;

    CSidl = CSIDL_FLAG_MASK;    //use a csidl value that is not valid for any folder

    for (DWORD n = 0; gUserShellFolders[n].FolderName; n++)
    {
        //we subtract 1 from the length because one of the paths is \ terminated
        //and the other is not.
        if ( _wcsnicmp( pwszFolderName, gUserShellFolders[n].FolderName, gUserShellFolders[n].FolderNameLength - 1 ) == 0 )
        {
            CSidl = gUserShellFolders[n].CSidl;
            break;
        }
    }

    if ( CSIDL_FLAG_MASK != CSidl )
    {
        hr = SHGetFolderPath( 0, CSidl | CSIDL_FLAG_DONT_VERIFY,
                              _hUserToken, 0, wszFullPath );

        if ( S_OK != hr )
        {
            DebugMsg((DM_WARNING, IDS_FOLDERPATH_FAIL, pwszFolderName, hr));
            return (DWORD) hr;
        }
    }
    else
        return ERROR_INVALID_NAME;

    return ERROR_SUCCESS;
}

const FOLDERINFO*
CFileDB::FolderInfoFromFolderName(
    WCHAR *     pwszFolderName
    )
{
    //
    // This method returns the index into global array.
    //

    if ( _hUserToken )
    {
        for ( DWORD n = 0; gUserShellFolders[n].FolderName; n++ )
        {
            if ( _wcsnicmp( pwszFolderName, gUserShellFolders[n].FolderName, gUserShellFolders[n].FolderNameLength - 1 ) == 0 )
                return &gUserShellFolders[n];
        }
    }
    else
    {
        for ( DWORD n = 0; gMachineShellFolders[n].FolderName; n++ )
        {
            if ( _wcsnicmp( pwszFolderName, gMachineShellFolders[n].FolderName, gMachineShellFolders[n].FolderNameLength - 1 ) == 0 )
                return &gMachineShellFolders[n];
        }
    }

    return NULL;
}

int
CFileDB::RegValueCSIDLFromFolderName(
    WCHAR *     pwszFolderName
    )
{
    const FOLDERINFO    *pFI;

    pFI = FolderInfoFromFolderName(pwszFolderName);
    if (pFI != NULL)
        return pFI->CSidl;
    else
        return -1;      // invalid CSIDL
}

const WCHAR *
CFileDB::GetLocalStoragePath ()
{
    return (LPCWSTR) _pwszLocalPath;
}

DWORD
CFileDB::CopyFileTree(
    WCHAR * pwszExistingPath,
    WCHAR * pwszNewPath,
    WCHAR * pwszIgnoredSubdir,
    SHARESTATUS StatusFrom,
    SHARESTATUS StatusTo,
    BOOL        bAllowRdrTimeout,
    CCopyFailData * pCopyFailure
    )
{
    HANDLE      hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WIN32_FILE_ATTRIBUTE_DATA   SourceAttr;
    WIN32_FILE_ATTRIBUTE_DATA   DestAttr;
    WCHAR *     wszSource = NULL;
    WCHAR *     pwszSourceEnd = 0;
    WCHAR *     wszDest = NULL;
    WCHAR *     pwszDestEnd = 0;
    WCHAR *     pwszTempFilename = 0;
    DWORD       FileAttributes;
    DWORD       Status;
    BOOL        bStatus;
    BOOL        bReuseTempName = FALSE;
    int         lenSource;
    int         lenDest;
    DWORD       StatusCSCDel = ERROR_SUCCESS;
    DWORD       dwAttr = INVALID_FILE_ATTRIBUTES;
    size_t      sourceRemaining;
    size_t      destRemaining;


    if (! pwszExistingPath || ! pwszNewPath)
        return ERROR_PATH_NOT_FOUND;

    lenSource = wcslen (pwszExistingPath);
    lenDest = wcslen (pwszNewPath);

    if (! lenSource || ! lenDest)
        return ERROR_PATH_NOT_FOUND;

    // Create source string
    sourceRemaining = lenSource + MAX_PATH + 2;
    wszSource = new WCHAR[ sourceRemaining ];
    if (NULL == wszSource)
    {
        return ERROR_OUTOFMEMORY;
    }

    Status = HRESULT_CODE(StringCchCopyEx( wszSource, sourceRemaining, pwszExistingPath, &pwszSourceEnd, &sourceRemaining, 0 ));
    if ( Status != ERROR_SUCCESS )
    {
        goto CopyFileTree_End;
    }
    if (L'\\' != pwszSourceEnd[-1])
    {
        Status = HRESULT_CODE(StringCchCopyEx( pwszSourceEnd, sourceRemaining, L"\\", &pwszSourceEnd, &sourceRemaining, 0 ));
        if ( Status != ERROR_SUCCESS )
        {
            goto CopyFileTree_End;
        }
    }
    Status = HRESULT_CODE(StringCchCopy( pwszSourceEnd, sourceRemaining, L"*" ));
    if ( Status != ERROR_SUCCESS )
    {
        goto CopyFileTree_End;
    }

    // Create destination string
    destRemaining = lenDest + MAX_PATH + 2;
    wszDest = new WCHAR[ destRemaining ];
    if (NULL == wszDest)
    {
        Status = ERROR_OUTOFMEMORY;
        goto CopyFileTree_End;
    }

    Status = HRESULT_CODE(StringCchCopyEx( wszDest, destRemaining, pwszNewPath, &pwszDestEnd, &destRemaining, 0 ));
    if ( Status != ERROR_SUCCESS )
    {
        goto CopyFileTree_End;
    }

    if (L'\\' != pwszDestEnd[-1])
    {
        Status = HRESULT_CODE(StringCchCopyEx( pwszDestEnd, destRemaining, L"\\", &pwszDestEnd, &destRemaining, 0 ));
        if ( Status != ERROR_SUCCESS )
        {
            goto CopyFileTree_End;
        }
    }

    // Now find the relevant file(s)
    hFind = FindFirstFile( wszSource, &FindData );

    Status = ERROR_SUCCESS;
    if ( INVALID_HANDLE_VALUE == hFind )
    {
        goto CopyFileTree_End;
    }

    do
    {
        Status = HRESULT_CODE(StringCchCopy( pwszSourceEnd, sourceRemaining, FindData.cFileName ));
        if ( Status != ERROR_SUCCESS )
        {
            break;
        }
        Status = HRESULT_CODE(StringCchCopy( pwszDestEnd, destRemaining, FindData.cFileName ));
        if ( Status != ERROR_SUCCESS )
        {
            break;
        }

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            if ( lstrcmp( FindData.cFileName, L"." ) == 0 ||
                 lstrcmp( FindData.cFileName, L".." ) == 0 ||
                 (pwszIgnoredSubdir && lstrcmpi( FindData.cFileName, pwszIgnoredSubdir ) == 0) )
                continue;

            Status = FullDirCopyW (wszSource, wszDest, FALSE);

            if ( ERROR_SUCCESS == Status )
            {
                if (ERROR_SUCCESS == StatusCSCDel)
                {
                    Status = CopyFileTree( wszSource, wszDest, NULL, StatusFrom, StatusTo, bAllowRdrTimeout, pCopyFailure );
                }
                else
                {
                    //no point delaying CSCDeletes anymore since we have already failed once.
                    Status = CopyFileTree (wszSource, wszDest, NULL, StatusFrom, StatusTo, FALSE, pCopyFailure);
                }
                //copy over the pin info. too
                if (ERROR_SUCCESS == Status)
                    MergePinInfo (wszSource, wszDest, StatusFrom, StatusTo);
            }
            else
            {
                pCopyFailure->RegisterFailure (wszSource, wszDest);
                DebugMsg((DM_VERBOSE, IDS_DIRCREATE_FAIL, wszDest, Status));
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
            // First check if it is necessary to copy the file over.
            bStatus = GetFileAttributesEx( wszSource, GetFileExInfoStandard, &SourceAttr );
            if ( bStatus )
            {
                bStatus = GetFileAttributesEx( wszDest, GetFileExInfoStandard, &DestAttr );
                if (bStatus)
                {
                    if (CompareFileTime( &SourceAttr.ftLastWriteTime, &DestAttr.ftLastWriteTime ) <= 0)
                    {
                        // The destination is newer or at least as old as the source.
                        // There is no need to copy. However, we should delete
                        // the locally cached copy of the file if any since the
                        // destination is newer.
                        DebugMsg((DM_VERBOSE, IDS_SKIP_FILE, wszDest));
                        if (ERROR_SUCCESS == StatusCSCDel)
                            StatusCSCDel = DeleteCSCFile ( wszSource, bAllowRdrTimeout);
                        else
                            DeleteCSCFile ( wszSource, FALSE);
                        continue;
                    }
                }
                else
                {
                    Status = GetLastError();
                    if (ERROR_PATH_NOT_FOUND == Status ||
                        ERROR_FILE_NOT_FOUND == Status)
                    {
                        // The destination was not found. So we must proceed with the copy.
                        bStatus = TRUE;
                        Status = ERROR_SUCCESS;
                    }
                }
            }
            else
            {
                // We failed to get the attributes of the source file.
                Status = GetLastError();
            }

            if (ERROR_SUCCESS == Status)
            {
                //
                // If we are here, we need to copy the file over.
                // In order to avoid loss of data, we must first copy the file
                // over to a temporary file at the destination and then rename
                // the file at the destination. This is because if the network
                // connection gets dropped during the filecopy operation, then
                // we are left with an incomplete file at the destination.
                // If we use the real name on the destination directly, then
                // the file will be skipped at the next redirection attempt
                // because of our last writer wins algorithm. As a result, when
                // the redirection succeeds subsequently, we end up with a loss
                // of user data. Copying to a temp name and then renaming the
                // file prevents this problem from happening because the rename
                // operation is atomic.
                //
                // First check if we need to generate a new temporary filename
                // Note: We try to minimize the number of calls to GetTempFilename
                // because it can be a very expensive call as it can result in
                // multiple CreateFile calls over the network which can be
                // especially slow for EFS shares.
                //
                bReuseTempName = FALSE;
                if (NULL != pwszTempFilename && L'\0' != *pwszTempFilename)
                {
                    dwAttr = GetFileAttributes (pwszTempFilename);
                    if (INVALID_FILE_ATTRIBUTES == dwAttr)
                    {
                        Status = GetLastError();
                        if (ERROR_PATH_NOT_FOUND == Status ||
                            ERROR_FILE_NOT_FOUND == Status)
                        {
                            Status = ERROR_SUCCESS;
                            bReuseTempName = TRUE;
                        }
                    }
                }
                if (ERROR_SUCCESS == Status && FALSE == bReuseTempName)
                {
                    // We need to generate a new temporary filename.
                    if (NULL == pwszTempFilename)
                    {
                        pwszTempFilename = new WCHAR [MAX_PATH + 1];
                        if (NULL == pwszTempFilename)
                            Status = ERROR_OUTOFMEMORY;
                    }
                    if (ERROR_SUCCESS == Status)
                    {
                        *pwszTempFilename = 0;
                        *pwszDestEnd = 0;
                        bStatus = GetTempFileName(wszDest, TEXT("frd"), 0, pwszTempFilename);
                        *pwszDestEnd = FindData.cFileName[0];
                        if (!bStatus)
                        {
                            Status = GetLastError();
                            DebugMsg((DM_VERBOSE, IDS_NO_TEMPNAME, wszDest, Status));
                        }
                    }
                }
                if (ERROR_SUCCESS == Status)
                {
                    // Now we have a temp. filename and we are ready to copy.
                    Status = FullFileCopyW (wszSource, pwszTempFilename, FALSE);

                    if (ERROR_SUCCESS == Status)
                    {
                        // Now we rename the file at the destination in one atomic
                        // step. Note however that if the destination file exists
                        // and has readonly/hidden/system attributes, the MoveFileEx
                        // API will fail with ERROR_ACCESS_DENIED. So we slap on normal
                        // attributes on the file before doing the Move. If we fail,
                        // we restore the attributes.
                        dwAttr = GetFileAttributes (wszDest);
                        // Change attributes only if we managed to figure out the 
                        // actual attributes.
                        if (INVALID_FILE_ATTRIBUTES != dwAttr)
                            SetFileAttributes (wszDest, FILE_ATTRIBUTE_NORMAL);
                        if (!MoveFileEx(pwszTempFilename, wszDest, MOVEFILE_REPLACE_EXISTING))
                        {
                            Status = GetLastError();
                            DebugMsg((DM_VERBOSE, IDS_RENAME_FAILED, pwszTempFilename, wszDest, Status)); 
                            // Restore the attributes of the destination file.
                            // Provided we changed those in the first place.
                            if (INVALID_FILE_ATTRIBUTES != dwAttr)
                                SetFileAttributes (wszDest, dwAttr);
                            // Also try to delete the temp file because we might still
                            // be able to do it. But ignore any failures. We are just
                            // trying to be nice by removing turds.
                            DeleteFile(pwszTempFilename);
                            
                        }
                    }
                    else
                    {
                        //
                        // ignore failure here because we may no longer have network connectivity and
                        // the delete operation may fail here.
                        //
                        DeleteFile(pwszTempFilename);
                    }
                }
            }
            
            if ( Status != ERROR_SUCCESS )
            {
                pCopyFailure->RegisterFailure (wszSource, wszDest);

                switch (Status)
                {
                case ERROR_INVALID_SECURITY_DESCR:
                    DebugMsg((DM_VERBOSE, IDS_SETSECURITY_FAIL, wszSource, wszDest));
                    break;
                default:
                    DebugMsg((DM_VERBOSE, IDS_FILECOPY_FAIL, wszSource, wszDest, Status));
                    break;
                }
            }
        }

        if ( Status != ERROR_SUCCESS )
            break;

    } while ( FindNextFile( hFind, &FindData ) );
    
CopyFileTree_End:
    // Some final cleanup before we return.
    delete [] wszSource;
    delete [] wszDest;
    delete [] pwszTempFilename;

    if (INVALID_HANDLE_VALUE != hFind)
        FindClose( hFind );
    
    return Status;
}

DWORD
CFileDB::DeleteFileTree(
    WCHAR * pwszPath,
    WCHAR * pwszIgnoredSubdir
    )
{
    HANDLE      hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR *     wszSource = NULL;
    WCHAR *     pwszSourceEnd = 0;
    DWORD       Status;
    BOOL        bStatus;
    int         len;
    size_t      sourceRemaining;

    if (!pwszPath)
        return ERROR_PATH_NOT_FOUND;

    len = wcslen (pwszPath);

    if (!len)
        return ERROR_PATH_NOT_FOUND;

    // Create source string
    sourceRemaining = len + MAX_PATH + 2;
    wszSource = new WCHAR[ sourceRemaining ];
    if (NULL == wszSource)
    {
        return ERROR_OUTOFMEMORY;
    }
    Status = HRESULT_CODE(StringCchCopyEx( wszSource, sourceRemaining, pwszPath, &pwszSourceEnd, &sourceRemaining, 0 ));
    if ( Status != ERROR_SUCCESS )
    {
        goto DeleteFileTree_End;
    }
    if (L'\\' != pwszSourceEnd[-1])
    {
        Status = HRESULT_CODE(StringCchCopyEx( pwszSourceEnd, sourceRemaining, L"\\", &pwszSourceEnd, &sourceRemaining, 0 ));
        if ( Status != ERROR_SUCCESS )
        {
            goto DeleteFileTree_End;
        }
    }
    Status = HRESULT_CODE(StringCchCopy( pwszSourceEnd, sourceRemaining, L"*" ));
    if ( Status != ERROR_SUCCESS )
    {
        goto DeleteFileTree_End;
    }

    // Now find the file(s)
    hFind = FindFirstFile( wszSource, &FindData );

    Status = ERROR_SUCCESS;
    if ( INVALID_HANDLE_VALUE == hFind )
    {
        goto DeleteFileTree_End;
    }

    for (;;)
    {
        Status = HRESULT_CODE(StringCchCopy( pwszSourceEnd, sourceRemaining, FindData.cFileName ));
        if ( Status != ERROR_SUCCESS )
        {
            break;
        }

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            if ( lstrcmp( FindData.cFileName, L"." ) != 0 &&
                 lstrcmp( FindData.cFileName, L".." ) != 0 &&
                 (! pwszIgnoredSubdir || lstrcmpi( FindData.cFileName, pwszIgnoredSubdir ) != 0) )
            {
                SetFileAttributes( wszSource, FILE_ATTRIBUTE_NORMAL );
                Status = DeleteFileTree( wszSource, NULL);

                if ( ERROR_SUCCESS == Status )
                {
                    if ( ! RemoveDirectory( wszSource ) )
                    {
                        Status = GetLastError();
                        DebugMsg((DM_VERBOSE, IDS_DIRDEL_FAIL, wszSource, Status));
                    }
                }
            }
        }
        else
        {
            SetFileAttributes( wszSource, FILE_ATTRIBUTE_NORMAL );
            bStatus = DeleteFile( wszSource );
            if ( ! bStatus )
            {
                Status = GetLastError();
                DebugMsg((DM_VERBOSE, IDS_FILEDEL_FAIL, wszSource, Status));
            }
        }

        if ( Status != ERROR_SUCCESS )
            break;

        bStatus = FindNextFile( hFind, &FindData );

        if ( ! bStatus )
        {
            Status = GetLastError();
            if ( ERROR_NO_MORE_FILES == Status )
                Status = ERROR_SUCCESS;
            break;
        }
    }

DeleteFileTree_End:
    if (INVALID_HANDLE_VALUE != hFind)
    {
        FindClose( hFind );
    }

    delete [] wszSource;
    return Status;
}

//note: the bCheckOwner flag: if set to true, then if the directory in question
//      already exists, the function Fails with an ERROR_INVALID_OWNER if the
//      the owner of the existing directory is not the user.
//      bSourceValid indicates if there is a valid path in pwszSource
DWORD
CFileDB::CreateRedirectedFolderPath(
    const WCHAR * pwszSource,
    const WCHAR * pwszDest,
    BOOL    bSourceValid,
    BOOL    bCheckOwner,
    BOOL    bMoveContents
    )
{
    WCHAR * pwszSlash = 0;
    WCHAR * pwszPath = NULL;
    DWORD   Status   = ERROR_SUCCESS;
    int     len;
    WCHAR * pwszSuccess = NULL;
    DWORD   dwAttributes;

    //first make a local copy of the destination path to work with.
    //while copying, we actually convert it into an absolute path so
    //that we eliminate any problems with weird paths like
    //\\server\share\..\hello\..\there
    len = wcslen (pwszDest) + 1;
    pwszPath = new WCHAR[len];
    if ( !pwszPath )
    {
        return ERROR_OUTOFMEMORY;
    }
    pwszSuccess = _wfullpath (pwszPath, pwszDest, len);
    if (!pwszSuccess)
    {
        Status = ERROR_BAD_PATHNAME;  //actually _wfullpath rarely fails
        goto CreateRedirectedFolderPath_Cleanup;
    }

    //
    // Will only accept drive based or UNC based paths.
    //
    // A redirect path of just <drive>:\ or \\server\share will be accepted
    // even though this would be a strange choice for redirection.
    //
    // IMPORTANT: also see notes at the beginning of the function

    if ( L':' == pwszPath[1] && L'\\' == pwszPath[2] )
    {
        pwszSlash = &pwszPath[2];
    }
    else if ( L'\\' == pwszPath[0] && L'\\' == pwszPath[1] )
    {
        pwszSlash = wcschr( &pwszPath[2], L'\\' );
        if ( pwszSlash )
        {
            //watch out for '\' terminated paths
            if (L'\0' == pwszSlash[1])
            {
                pwszSlash = 0;
            }
            else    //it is at least of the form \\server\share
            {
                pwszSlash = wcschr( &pwszSlash[1], L'\\' );
                //if it is of the form \\server\share, then we allow this path
                //based depending on the ownership checks if any
                if (!pwszSlash)
                {
                    Status = bCheckOwner ? IsUserOwner(pwszPath) : ERROR_SUCCESS;
                    goto CreateRedirectedFolderPath_Cleanup;
                }
                //note: we do not have to watch out for the '\' terminated
                //paths here (e.g. \\server\share\) because that will be
                //taken care of below : in -> if (!pwszSlash[1])
            }
        }
    }
    else
    {
        pwszSlash = 0;
    }

    if ( ! pwszSlash )
    {
        Status = ERROR_BAD_PATHNAME;
        goto CreateRedirectedFolderPath_Cleanup;
    }

    //if it is the root directory of a drive or root of a UNC share
    //we succeed based on ownership checks, if any...
    //but before that, we also need to make sure that the specified path
    //exists or we may end up redirecting to a non-existent location.
    if ( !pwszSlash[1])
    {
        if (0xFFFFFFFF != (dwAttributes = GetFileAttributes(pwszPath)))
        {
            //it exists
            if (! (FILE_ATTRIBUTE_DIRECTORY & dwAttributes))
            {
                Status = ERROR_DIRECTORY;
            }
            else
            {
                //it exists and is a directory
                Status = bCheckOwner ? IsUserOwner (pwszPath) : ERROR_SUCCESS;
            }
        }
        else
        {
            Status = GetLastError();
        }

        goto CreateRedirectedFolderPath_Cleanup;
    }

    //if we are here, it is not the root of a drive or a share.
    //so we might have to do create the destination.
    //First do a quick check to see if the path exists already. this
    //is not only an optimization, but is also necessary for cases
    //where an admin. may want to lock down access to certain folders
    //by pre-creating the folders and putting highly resitrictive ACLs on them
    //in that case, CreateDirectory (later in the code) would fail with
    //ACCESS_DENIED rather than ERROR_ALREADY_EXISTS and the redirection code
    //will bail out even though it is not necessary to.
    if (0xFFFFFFFF != (dwAttributes = GetFileAttributes(pwszPath)))
    {
        //it exists
        if (! (FILE_ATTRIBUTE_DIRECTORY & dwAttributes))
        {
            Status = ERROR_DIRECTORY;
        }
        else
        {
            //it exists and is a directory
            Status = bCheckOwner ? IsUserOwner (pwszPath) : ERROR_SUCCESS;
        }
        goto CreateRedirectedFolderPath_Cleanup;
    }

    //the destination has not been pre-created, so we need to do that
    //ourselves

    do
    {
        pwszSlash = wcschr( &pwszSlash[1], L'\\' );

        // Watch out for '\' terminated paths.
        if ( pwszSlash && (L'\0' == pwszSlash[1]) )
            pwszSlash = 0;

        if ( pwszSlash )
        {
            *pwszSlash = 0;
            CreateDirectory( pwszPath, NULL );
            *pwszSlash = L'\\';

            //ignore all errors in the intermediate folders not just
            //ERROR_ALREADY_EXISTS because of folders like
            //\\server\share\dir1\dir2\%username% where the user may not
            //have write access in dir1 but might have so in dir2
            //if the path is invalid we will either discover it at the last
            //dir in the chain or while trying to redirect to the destination
            //retaining the code here just in case...
            //
            /*if ( ! bStatus && (GetLastError() != ERROR_ALREADY_EXISTS) )
                return GetLastError();*/
        }
        else
        {
            //
            // Last dir in the chain.  We set security on the last dir in
            // the path to only allow the user & system access if
            // the directory did not already exist.
            //

            if (bCheckOwner)
            {
                Status = CreateFolderWithUserFileSecurity( pwszPath );
            }
            else 
            {
                Status = ERROR_SUCCESS;
                
                if (!CreateDirectory( pwszPath, NULL ))
                    Status = GetLastError();
            }

            if ( ERROR_SUCCESS == Status )
            {
                //the extension created the directory, so try to set the user as
                //the owner explicitly because if a member of the local administrators
                //group creates a directory/file, the Administrators group becomes
                //the owner by default. This can cause problems with quota accounting
                //and also if the settings on the redirection policy are changed
                //at a later date. However, since it is not necessary that the
                //we will succeed in setting the owner here, we ignore any failures
                SetUserAsOwner (pwszPath);
                
                //
                // We want to skip the DACL if we want to apply exclusive ACLs
                // i.e., bCheckOwner is true. Otherwise, we should just copy
                // over all the metadata.
                //
                if (bSourceValid && bMoveContents)
                    FullDirCopyW (pwszSource, pwszPath, bCheckOwner);

                goto CreateRedirectedFolderPath_Cleanup;
            }
            else if ( ERROR_ALREADY_EXISTS != Status)
            {
                goto CreateRedirectedFolderPath_Cleanup;
            }
            else
            {
                //the directory already exists
                //start anti-spoofing agent
                //do the ownership check only on the last dir in chain and only
                //if the flags in the ini file tell you to.
                if (bCheckOwner &&
                    (ERROR_SUCCESS != (Status = IsUserOwner(pwszPath))))
                {
                    DebugMsg ((DM_VERBOSE, IDS_ACL_MISMATCH, pwszPath, Status));
                    goto CreateRedirectedFolderPath_Cleanup;
                }
                else
                {
                    Status = ERROR_SUCCESS;
                    goto CreateRedirectedFolderPath_Cleanup;
                }
            }
        }

    } while ( pwszSlash );

    Status = ERROR_SUCCESS;

CreateRedirectedFolderPath_Cleanup:
    delete [] pwszPath;

    return Status;
}

DWORD
CFileDB::SetUserAsOwner(
    WCHAR * pwszPath
    )
{
    SECURITY_DESCRIPTOR SecDesc;
    PSID        pSidUser = 0;
    PTOKEN_USER pTokenUser = 0;
    DWORD       Size = 0;
    DWORD       Status = ERROR_SUCCESS;
    BOOL        bStatus;

    if ( ! _hUserToken )
        return ERROR_SUCCESS;

    Status = NtQueryInformationToken(
                 _hUserToken,
                 TokenUser,
                 pTokenUser,
                 Size,
                 &Size );

    if ( STATUS_BUFFER_TOO_SMALL == Status )
    {
        pTokenUser = (PTOKEN_USER) new BYTE[ Size ];
        if ( ! pTokenUser )
        {
            return ERROR_OUTOFMEMORY;
        }

        Status = NtQueryInformationToken(
                     _hUserToken,
                     TokenUser,
                     pTokenUser,
                     Size,
                     &Size );
    }

    if ( Status != ERROR_SUCCESS )
    {
        goto SetUserAsOwner_End;
    }

    Size = RtlLengthSid( pTokenUser->User.Sid );
    pSidUser = (PSID) new BYTE[ Size ];
    if ( pSidUser == NULL )
    {
        Status = ERROR_OUTOFMEMORY;
        goto SetUserAsOwner_End;
    }

    Status = RtlCopySid( Size, pSidUser, pTokenUser->User.Sid );
    if ( Status != ERROR_SUCCESS )
    {
        goto SetUserAsOwner_End;
    }

    bStatus = InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION );

    if ( bStatus )
    {
        bStatus = SetSecurityDescriptorOwner (&SecDesc, pSidUser, 0);
    }

    if (bStatus)
    {
        bStatus = SetFileSecurity( pwszPath, OWNER_SECURITY_INFORMATION, &SecDesc);
    }

    if ( ! bStatus )
    {
        Status = GetLastError();
    }

SetUserAsOwner_End:
    delete [] (BYTE*) pTokenUser;
    delete [] (BYTE*) pSidUser;
    
    return Status;
}

DWORD
CFileDB::CreateFolderWithUserFileSecurity(
    WCHAR * pwszPath
    )
{
    SECURITY_DESCRIPTOR SecDesc;
    SID_IDENTIFIER_AUTHORITY AuthorityNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY AuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID        pSidUser = 0;
    PSID        pSidSystem = 0;
    PACL        pAcl = 0;
    ACE_HEADER * pAceHeader;
    PTOKEN_USER pTokenUser = 0;
    PSID        pSid = 0;
    DWORD       AclSize;
    DWORD       AceIndex;
    DWORD       Size;
    DWORD       Status;
    BOOL        bStatus;

    if ( ! _hUserToken )
        return ERROR_SUCCESS;

    pSidSystem = 0;

    pTokenUser = 0;
    Size = 0;

    Status = NtQueryInformationToken(
                 _hUserToken,
                 TokenUser,
                 pTokenUser,
                 Size,
                 &Size );

    if ( STATUS_BUFFER_TOO_SMALL == Status )
    {
        pTokenUser = (PTOKEN_USER) new BYTE[ Size ];
        if ( ! pTokenUser )
        {
            return ERROR_OUTOFMEMORY;
        }

        Status = NtQueryInformationToken(
                     _hUserToken,
                     TokenUser,
                     pTokenUser,
                     Size,
                     &Size );
    }

    if ( Status != ERROR_SUCCESS )
    {
        goto SetUserFileSecurityEnd;
    }

    Size = RtlLengthSid( pTokenUser->User.Sid );
    pSidUser = (PSID) new BYTE[ Size ];
    if ( pSidUser == NULL )
    {
        Status = ERROR_OUTOFMEMORY;
        goto SetUserFileSecurityEnd;
    }

    Status = RtlCopySid( Size, pSidUser, pTokenUser->User.Sid );

    if ( Status != ERROR_SUCCESS )
    {
        goto SetUserFileSecurityEnd;
    }

    bStatus = AllocateAndInitializeSid( &AuthorityNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSystem);

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SetUserFileSecurityEnd;
    }

    //
    // Allocate space for the ACL
    //

    AclSize = (GetLengthSid(pSidUser)) +
              (GetLengthSid(pSidSystem)) +
              sizeof(ACL) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) new BYTE[ AclSize ];
    if ( pAcl )
    {
        bStatus = InitializeAcl( pAcl, AclSize, ACL_REVISION );
        if ( ! bStatus )
            Status = GetLastError();
    }
    else
    {
        Status = ERROR_OUTOFMEMORY;
    }

    if ( Status != ERROR_SUCCESS )
    {
        goto SetUserFileSecurityEnd;
    }

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidUser);

    if ( bStatus )
    {
        bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
        if ( bStatus )
            pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
    }

    if ( bStatus )
    {
        AceIndex++;
        bStatus = AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSidSystem);

        if ( bStatus )
        {
            bStatus = GetAce(pAcl, AceIndex, (void **) &pAceHeader);
            if ( bStatus )
                pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
        }
    }

    if ( ! bStatus )
    {
        Status = GetLastError();
        goto SetUserFileSecurityEnd;
    }

    bStatus = InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION );

    if (bStatus)
    {
        SetSecurityDescriptorControl (&SecDesc, SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED);
        //SE_DACL_PROTECTED is supported by NTFS5 but not by NTFS4, therefore
        //we ignore any failures in SetSecurityDesciptorControl
    }

    if ( bStatus )
    {
        bStatus = SetSecurityDescriptorDacl( &SecDesc, TRUE, pAcl, FALSE );
    }

    //set the owner explicitly. This is required because if the user is an
    //admin, then when the directory is created, the owner is set to the group
    //administrators, rather than the user

    if ( bStatus )
    {
        bStatus = SetSecurityDescriptorOwner (&SecDesc, pSidUser, 0);
    }

    if ( bStatus )
    {
        SECURITY_ATTRIBUTES sa;
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = &SecDesc;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    
        bStatus = CreateDirectory(pwszPath, &sa);
    }

    if ( ! bStatus )
    {
        Status = GetLastError();
    }

SetUserFileSecurityEnd:

    delete [] (BYTE*) pAcl;
    delete [] (BYTE*) pTokenUser;
    delete [] (BYTE*) pSidUser;

    if (pSidSystem)
    {
        FreeSid( pSidSystem );
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileDB::IsUserOwner
//
//  Synopsis:   given a path. this function determines if the user is the
//              the owner of the file/folder
//
//  Arguments:  [in] pwszPath
//
//  Returns:    ERROR_SUCCESS if user is owner
//              otherwise an error code
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CFileDB::IsUserOwner (const WCHAR * pwszPath)
{
    BOOL            bStatus;
    DWORD           Status;
    BOOL            bIsMember;
    DWORD           dwLengthNeeded;
    PSECURITY_DESCRIPTOR    pSecDesc = 0;
    PSID            pOwnerSid = 0;
    BOOL            bDaclDefaulted;

    //first check if we are on FAT. if we are on FAT, then we simply let
    //succeed since FAT cannot have any ACLs anyway
    Status = IsOnNTFS (pwszPath);
    if (ERROR_NO_SECURITY_ON_OBJECT == Status)
    {
        Status = ERROR_SUCCESS;     //we are on FAT
        goto UserOwnerEnd;
    }
    else if (ERROR_SUCCESS != Status)
        goto UserOwnerEnd;         //there was some other error
    //else we are on NTFS and ready to rumble!

    //get the owner sid from the folder.
    dwLengthNeeded = 0;
    if ( !GetFileSecurity (pwszPath, OWNER_SECURITY_INFORMATION,
                               pSecDesc, dwLengthNeeded,
                               &dwLengthNeeded) )
    {
        //GetFileSecurity failed if we are here
        Status = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER != Status)
            goto UserOwnerEnd;

        //GetFileSecurity failed due to insufficient memory if we are here.
        pSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[dwLengthNeeded];
        if (NULL == pSecDesc)
        {
            Status = ERROR_OUTOFMEMORY;
            goto UserOwnerEnd;
        }

        if ( !GetFileSecurity (pwszPath, OWNER_SECURITY_INFORMATION,
                                   pSecDesc, dwLengthNeeded,
                                   &dwLengthNeeded) )
        {
            Status = GetLastError();
            goto UserOwnerEnd;
        }
    }

    //now get the owner sid
    bStatus = GetSecurityDescriptorOwner (
                    pSecDesc,
                    &pOwnerSid,
                    &bDaclDefaulted);
    if (!bStatus)
    {
        Status = GetLastError();
    }
    else
    {
        if (!pOwnerSid)
        {
            Status = ERROR_INVALID_OWNER;
        }
        else
        {
            bStatus = CheckTokenMembership (_hUserToken, pOwnerSid, &bIsMember);
            if (!bStatus)
                Status = GetLastError();
            else
            {
                if (bIsMember)
                    Status = ERROR_SUCCESS;
                else
                    Status = ERROR_INVALID_OWNER;
            }
        }
    }

UserOwnerEnd:
    delete [] (BYTE*) pSecDesc;

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileDB::GetEnvBlock
//
//  Synopsis:   gets a pointer to the user's environment block
//
//  Arguments:  none.
//
//  Returns:    pointer to the user's environment block.
//              NULL if it is not created yet
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
PVOID CFileDB::GetEnvBlock (void)
{
    return _pEnvBlock;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFileDB::GetRsopContext
//
//  Synopsis:   gets a pointer to the rsop logging context
//
//  Arguments:  none.
//
//  Returns:    pointer to the rsop logging context -- never null
//
//
//  History:    12/8/1999  adamed  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CRsopContext*
CFileDB::GetRsopContext()
{
    return _pRsopContext;
}

//member functions and data for class CSavedSettings

//initialize the class's static variables.
int CSavedSettings::m_idConstructor = 0;
CFileDB * CSavedSettings::m_pFileDB = NULL;
WCHAR * CSavedSettings::m_szSavedSettingsPath = NULL;

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::ResetStaticMembers
//
//  Synopsis:   resets the static members to their default values.
//
//  Arguments:  none
//
//  Returns:    nothing
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      static members of a class, like other global variables are
//              initialized only when the dll is loaded. So if this dll
//              stays loaded across logons, then the fact that the globals
//              have been initialized based on a previous logon can cause
//              problems. Therefore, this function is used to reinitialize
//              the globals.
//
//---------------------------------------------------------------------------
void CSavedSettings::ResetStaticMembers(void)
{
    //
    // No need to delete it. This usually points to a local variable in
    // ProcessGroupPolicyInternal. So the actual object gets deleted when
    // after each processing. We just need to make sure that it is reflected
    // here.
    //
    m_pFileDB = NULL;
    
    if (m_szSavedSettingsPath)
    {
        delete [] m_szSavedSettingsPath;
        m_szSavedSettingsPath = NULL;
    }
    
    // No need to do anything about m_idConstructor
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings
//
//  Synopsis:   default constructor for the class.
//
//  Arguments:
//
//  Returns:
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CSavedSettings::CSavedSettings ()
{
    m_rID = (REDIRECTABLE) m_idConstructor;
    m_idConstructor = (m_idConstructor + 1) % ((int) EndRedirectable);
    m_szLastRedirectedPath = NULL;
    m_szCurrentPath = NULL;
    m_szLastUserName = NULL;
    m_szLastHomedir = NULL;
    m_bIsHomedirRedir = FALSE;
    m_bHomedirChanged = FALSE;
    m_dwFlags = REDIR_DONT_CARE;    //this is always a safe default
    m_psid = 0;
    m_bValidGPO = FALSE;
    m_bUserNameChanged = FALSE;
    m_szGPOName[0] = L'\0';
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::ResetMembers
//
//  Synopsis:   Resets the member variables.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      see ResetStaticMembers.
//
//---------------------------------------------------------------------------
void CSavedSettings::ResetMembers(void)
{
    if (m_szLastRedirectedPath)
    {
        delete [] m_szLastRedirectedPath;
        m_szLastRedirectedPath = NULL;
    }
    
    if (m_szCurrentPath)
    {
        delete [] m_szCurrentPath;
        m_szCurrentPath = NULL;
    }

    if (m_szLastUserName)
    {
        delete [] m_szLastUserName;
        m_szLastUserName = NULL;
    }

    if (m_szLastHomedir)
    {
        delete [] m_szLastHomedir;
        m_szLastHomedir = NULL;
    }

    if (m_psid)
    {
        RtlFreeSid (m_psid);
        m_psid = NULL;
    }
    
    m_bHomedirChanged = FALSE;
    m_dwFlags = REDIR_DONT_CARE;    //this is always a safe default
    m_bValidGPO = FALSE;
    m_bUserNameChanged = FALSE;
    m_szGPOName[0] = L'\0';
    
    // No need to do anything about m_rID.
}

//+--------------------------------------------------------------------------
//
//  Member:     ~CSavedSettings
//
//  Synopsis:   default destructor
//
//  Arguments:
//
//  Returns:
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CSavedSettings::~CSavedSettings ()
{
    //free static members if necessary
    if (m_szSavedSettingsPath)
    {
        delete [] m_szSavedSettingsPath;
        m_szSavedSettingsPath = NULL;    //this is necessary so that the
                                        //destructor of the next object does
                                        //not try to free it again
    }

    //
    // Free other memory allocated for members of this object
    // and reset them.
    //
    ResetMembers();
}

//+--------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   loads the saved settings into the object for its corresponding
//              folder
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if successful. otherwise an error code
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::Load (CFileDB * pFileDB)
{
    DWORD   Status;
    BOOL    bStatus;
    DWORD   len;

    //first set the FileDB object if it has not already been set
    if (!m_pFileDB)
        m_pFileDB = pFileDB;

    ASSERT (m_pFileDB);

    //get the name of the file where the last settings have been saved
    //if we haven't already done so.
    if (!m_szSavedSettingsPath)
    {
        len = wcslen (pFileDB->_pwszLocalPath) +
            wcslen (SAVED_SETTINGS_FILE) + 2;

        m_szSavedSettingsPath = (WCHAR *) new WCHAR [len];
        if (!m_szSavedSettingsPath)
        {
            Status = ERROR_OUTOFMEMORY;
            goto LoadEnd;
        }
        Status = HRESULT_CODE(StringCchCopy(m_szSavedSettingsPath, len, pFileDB->_pwszLocalPath));
        if ( Status != ERROR_SUCCESS )
        {
            goto LoadEnd;
        }
        Status = HRESULT_CODE(StringCchCat(m_szSavedSettingsPath, len, L"\\"));
        if ( Status != ERROR_SUCCESS )
        {
            goto LoadEnd;
        }
        Status = HRESULT_CODE(StringCchCat(m_szSavedSettingsPath, len, SAVED_SETTINGS_FILE));
        if ( Status != ERROR_SUCCESS )
        {
            goto LoadEnd;
        }
    }

    //do a quick check to see if the file exists
    if (0xFFFFFFFF == GetFileAttributes(m_szSavedSettingsPath))
        Status = LoadDefaultLocal ();
    else
        Status = LoadFromIniFile ();

LoadEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     GetCurrentPath
//
//  Synopsis:   gets the current path of the folder.
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if successful
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::GetCurrentPath (void)
{
    DWORD   Status = ERROR_SUCCESS;
    WCHAR * pwszValueName = 0;
    DWORD   Size;
    WCHAR * pwszProcessedPath = NULL;

    if (m_szCurrentPath)
    {
        delete [] m_szCurrentPath;
        m_szCurrentPath = NULL;
    }

    m_szCurrentPath = new WCHAR [MAX_PATH];
    if (!m_szCurrentPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto GetCurrentPathEnd;
    }
    m_szCurrentPath[0] = L'\0';
    Status = m_pFileDB->GetPathFromFolderName (
                g_szRelativePathNames[(int)m_rID],
                m_szCurrentPath
                );
    if (((DWORD) S_OK != Status) &&  //if SHGetFolderPath failed, use the local userprofile path
        ERROR_INVALID_NAME != Status)   //the only error from GetPathFromFolderName that is not generated by SHGetFolderPath
    {
        Status = HRESULT_CODE(StringCchCopy(m_szCurrentPath, MAX_PATH, L"%USERPROFILE%\\"));
        if ( Status != ERROR_SUCCESS )
        {
            goto GetCurrentPathEnd;
        }
        Status = HRESULT_CODE(StringCchCat(m_szCurrentPath, MAX_PATH, g_szRelativePathNames[(int)m_rID]));
        if ( Status != ERROR_SUCCESS )
        {
            goto GetCurrentPathEnd;
        }
    }
    else
    {
        // expand the homedir path if applicable.
        if (IsHomedirPath (m_rID, m_szCurrentPath, TRUE))
        {
            Status = ExpandHomeDir (m_rID, m_szCurrentPath, TRUE, &pwszProcessedPath);
            delete [] m_szCurrentPath;
            m_szCurrentPath = NULL;
            if (ERROR_SUCCESS == Status)
            {
                m_szCurrentPath = pwszProcessedPath;
                pwszProcessedPath = NULL;
            }
        }
    }

    if (m_szCurrentPath)
        RemoveEndingSlash( m_szCurrentPath );

GetCurrentPathEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     ResetLastUserName
//
//  Synopsis:   sets the last user name to the current username
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS : if there is no error.
//              an error code otherwise.
//
//  History:    9/15/1999  RahulTh  created
//
//  Notes:      the most likely cause of failure for this function -- if at all
//              it happens, will be an out of memory condition.
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::ResetLastUserName (void)
{
    DWORD Status = ERROR_SUCCESS;
    size_t lastUserNameLength = 0;
    
    if (m_szLastUserName)
    {
        delete [] m_szLastUserName;
        m_szLastUserName = NULL;
    }

    lastUserNameLength = wcslen(gwszUserName);
    m_szLastUserName = new WCHAR [lastUserNameLength + 1];
    if (!m_szLastUserName)
    {
        return ERROR_OUTOFMEMORY;
    }

    Status = HRESULT_CODE(StringCchCopy(m_szLastUserName, lastUserNameLength+1, gwszUserName));
    if ( Status == ERROR_SUCCESS )
    {
        m_bUserNameChanged = FALSE;
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     LoadDefaultLocal
//
//  Synopsis:   loads the default local userprofile path and default
//              flags into the object
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if successful an error code otherwise
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:      the security group is set to Everyone as you can never
//              cease being a member of the group
//
//              this function is usually invoked when one can't find
//              the ini file that contains the last saved settings or
//              if the ini file does not contain the corresponding section
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::LoadDefaultLocal (void)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   len;

    // The default case cannot be homedir redirection.
    // Just make sure that our bool has been properly set.
    m_bIsHomedirRedir = FALSE;

    //set the default flags
    m_dwFlags = REDIR_DONT_CARE;

    //to be on the safe side -- set the default values for all members.
    m_bValidGPO = FALSE;
    m_szGPOName[0] = L'\0';

    //set the last username to be the same as the current username
    //since we load the defaults only when we do not have any data about the
    //last logon (i.e., no per user per machine FR cache
    Status = ResetLastUserName ();
    if (ERROR_SUCCESS != Status)
        goto LoadDefaultsEnd;

    //allocate the sid
    //to be on the safe side, free the sid if it has already been allocated
    if (m_psid)
    {
        RtlFreeSid (m_psid);
        m_psid = NULL;
    }
    Status = AllocateAndInitSidFromString (L"S-1-1-0", &m_psid);

    if (ERROR_SUCCESS != Status)
    {
        m_psid = 0;
        goto LoadDefaultsEnd;
    }

    //get the last redirected path
    //again, to be on the safe side, free any used memory first
    if (m_szLastRedirectedPath)
    {
        delete [] m_szLastRedirectedPath;
        m_szLastRedirectedPath = NULL;
    }
    len = wcslen (L"%USERPROFILE%\\") +
        wcslen (g_szRelativePathNames[(int)m_rID]) + 1;
    m_szLastRedirectedPath = new WCHAR [len];
    if (!m_szLastRedirectedPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto LoadDefaultsEnd;
    }
    Status = HRESULT_CODE(StringCchCopy(m_szLastRedirectedPath, len, L"%USERPROFILE%\\"));
    if ( Status != ERROR_SUCCESS )
    {
        goto LoadDefaultsEnd;
    }
    Status = HRESULT_CODE(StringCchCat(m_szLastRedirectedPath, len, g_szRelativePathNames[(int)m_rID]));
    if ( Status != ERROR_SUCCESS )
    {
        goto LoadDefaultsEnd;
    }

    //get the current path
    Status = GetCurrentPath();

LoadDefaultsEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     LoadFromIniFile
//
//  Synopsis:   this function loads redirection info. from the ini file
//              that contains the last saved settings.
//              file.
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if everything is successful. an error code otherwise
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:      if this function cannot find the corresponding section in the
//              ini file, it loads the default local path
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::LoadFromIniFile (void)
{
    DWORD   Status = ERROR_SUCCESS;
    WCHAR   pwszDefault[] = L"*";
    WCHAR * pwszReturnedString = NULL;
    WCHAR * pwszProcessedPath = NULL;
    DWORD   retVal;
    DWORD   Size;
    UNICODE_STRING  StringW;
    GUID    GPOGuid;

    //
    // If this object contains the MyDocs settings, get the last value
    // of homedir
    //
    if (MyDocs == m_rID || MyPics == m_rID)
    {
        Status = SafeGetPrivateProfileStringW (
                       g_szDisplayNames [(int) m_rID],
                       L"Homedir",
                       pwszDefault,
                       &m_szLastHomedir,
                       &Size,
                       m_szSavedSettingsPath);
        if (ERROR_SUCCESS != Status)
            goto LoadIniEnd;

        if (L'*' == *m_szLastHomedir)
        {
            // The value of homedir at the last redirection was not found.
            delete [] m_szLastHomedir;
            m_szLastHomedir = NULL;
        }
    }

    //first try to get the user name when the user had last logged on.
    Status = SafeGetPrivateProfileStringW (
                   g_szDisplayNames [(int) m_rID],
                   L"Username",
                   pwszDefault,
                   &m_szLastUserName,
                   &Size,
                   m_szSavedSettingsPath);

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *m_szLastUserName)
    {
        //the username field was not found in the ini file. must be an older
        //cache. since we do not have the information, we just use the defaults,
        //i.e. set the current user name as the last user name
        Status = ResetLastUserName();
        if (ERROR_SUCCESS != Status)
            goto LoadIniEnd;
    }
    else
    {
        //we found a user name in the local cache.
        //update the member variable which indicates whether the user name
        //has changed since the last logon.
        if (0 == _wcsicmp (m_szLastUserName, gwszUserName))
            m_bUserNameChanged = FALSE;
        else
            m_bUserNameChanged = TRUE;
    }

    //then try to get the path
    Status = SafeGetPrivateProfileStringW (
                   g_szDisplayNames [(int) m_rID],
                   L"Path",
                   pwszDefault,
                   &m_szLastRedirectedPath,
                   &Size,
                   m_szSavedSettingsPath);

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *m_szLastRedirectedPath) //we could not find the required data.
    {
        //so we go with the defaults
        Status = LoadDefaultLocal();
        goto LoadIniEnd;
    }
    else if (IsHomedirPath (m_rID, m_szLastRedirectedPath, TRUE))
    {
        Status = ExpandHomeDir (m_rID,
                                m_szLastRedirectedPath,
                                TRUE,
                                &pwszProcessedPath,
                                m_szLastHomedir
                                );
        delete [] m_szLastRedirectedPath;
        if (ERROR_SUCCESS != Status)
        {
            m_szLastRedirectedPath = NULL;
            goto LoadIniEnd;
        }
        else
        {
            m_bIsHomedirRedir = TRUE;
            m_szLastRedirectedPath = pwszProcessedPath;
            pwszProcessedPath = NULL;
        }
    }

    //next try to get the security group
    Status = SafeGetPrivateProfileStringW (
                   g_szDisplayNames[(int)m_rID],
                   L"Group",
                   pwszDefault,
                   &pwszReturnedString,
                   &Size,
                   m_szSavedSettingsPath
                   );

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *pwszReturnedString)
    {
        //data was missing, so go with the defaults
        Status = LoadDefaultLocal();
        goto LoadIniEnd;
    }

    if (m_psid)
    {
        RtlFreeSid (m_psid);
        m_psid = NULL;
    }

    Status = AllocateAndInitSidFromString (pwszReturnedString, &m_psid);

    if (ERROR_SUCCESS != Status)
    {
        m_psid = 0;
        goto LoadIniEnd;
    }

    //now get the flags
    Status = SafeGetPrivateProfileStringW (
                  g_szDisplayNames[(int)m_rID],
                  L"Flags",
                  pwszDefault,
                  &pwszReturnedString,
                  &Size,
                  m_szSavedSettingsPath
                  );

    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    if (L'*' == *pwszReturnedString)
    {
        Status = LoadDefaultLocal();
        goto LoadIniEnd;
    }

    //now grab the hex flags
    StringW.Buffer = pwszReturnedString;
    StringW.Length = wcslen (pwszReturnedString) * sizeof (WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof(WCHAR);
    RtlUnicodeStringToInteger( &StringW, 16, &m_dwFlags );

    //now get the unique name of the GPO (if any) that was used to redirect the folder
    Status = SafeGetPrivateProfileStringW (
                 g_szDisplayNames[(int) m_rID],
                 L"GPO",
                 pwszDefault,
                 &pwszReturnedString,
                 &Size,
                 m_szSavedSettingsPath
                 );
    if (ERROR_SUCCESS != Status)
        goto LoadIniEnd;

    StringW.Length = sizeof (WCHAR) * wcslen (pwszReturnedString);
    StringW.MaximumLength = (USHORT)(sizeof(WCHAR) * Size);
    StringW.Buffer = pwszReturnedString;

    if ((L'*' == *pwszReturnedString) ||    //there is no valid GPO info., or
        (sizeof(m_szGPOName) <= wcslen(pwszReturnedString)) || //the file has been corrupted. the length of a valid unique name cannot exceed the size of m_szGPO, or
        (STATUS_INVALID_PARAMETER == RtlGUIDFromString (&StringW, &GPOGuid))  //it is not a valid GUID
        )
    {
        //there is no valid GPO info.
        m_bValidGPO = FALSE;
        m_szGPOName[0] = L'\0';
    }
    else
    {
        m_bValidGPO = TRUE;
        (void) StringCbCopy(m_szGPOName, sizeof(m_szGPOName), pwszReturnedString);
    }

    //get the current path.
    Status = GetCurrentPath ();

LoadIniEnd:
    if (pwszReturnedString)
        delete [] pwszReturnedString;
    if (pwszProcessedPath)
        delete [] pwszProcessedPath;

    return Status;
}


//+--------------------------------------------------------------------------
//
//  Member:     NeedsProcessing
//
//  Synopsis:   once the saved settings and the registry values have been
//              loaded, this function determines if we need to look at all the
//              policies. Note that this assumes that the GPO_NOCHANGES flag
//              has already been set by the policy engine
//
//  Arguments:  none
//
//  Returns:    TRUE / FALSE
//
//  History:    11/18/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CSavedSettings::NeedsProcessing (void)
{
    BOOL            bStatus;
    DWORD           i;
    DWORD           Status;
    PTOKEN_GROUPS   pGroups;
    WCHAR           wszExpandedPath [TARGETPATHLIMIT + 1];
    UNICODE_STRING  Path;
    UNICODE_STRING  ExpandedPath;
    const WCHAR *   pwszCurrentHomedir = NULL;
    WCHAR           wszProcessedSource [TARGETPATHLIMIT + 1];
    WCHAR           wszProcessedDest [TARGETPATHLIMIT + 1];
    int             len;

    //if policy didn't care about the location of the folder at last logon
    //then even if the last redirected path is not the same as the current
    //path, it should not mean that that we need to reprocess the policy
    //when the GPO_NOCHANGES flag has been provided
    if (m_dwFlags & REDIR_DONT_CARE)
        return FALSE;

    //if we are here, policy specified the location of the folder at the
    //the last logon. make sure that the user name has not changed since
    //last logon. If so, we need to process the policies again and move
    //the user's folders accordingly.
    if (m_bUserNameChanged)
        return TRUE;

    //
    // If we are here, the username had not changed, but if the homedir
    // changed, that can affect the path.
    // Note: Here, we cannot use the IsHomedirPath function to determine
    // if this is a homedir redirection since we would have already expanded
    // the path in LoadFromIniFile. Therefore, we must use m_bIsHomedirRedir
    //
    if (m_bIsHomedirRedir)
    {
        //
        // Note: GetHomeDir is an expensive call since it can result
        // in a call to the DS to get the user's home directory. So we try to
        // be as lazy as possible about executing it.
        //
        pwszCurrentHomedir = gUserInfo.GetHomeDir (Status);
        if (ERROR_SUCCESS != Status ||
            ! pwszCurrentHomedir ||
            ! m_szLastHomedir ||
            0 != lstrcmpi (m_szLastHomedir, pwszCurrentHomedir))
        {
            m_bHomedirChanged = TRUE;
            return TRUE;
        }
    }

    //check if the last redirected path and current path are identical
    if (0 != _wcsicmp(m_szLastRedirectedPath, m_szCurrentPath))
    {
        //the paths are different. we need to do processing
        //even if the policy engine thinks otherwise
        //but sometimes we may have an expanded path in m_szCurrentPath
        //e.g. if some User Shell Folder values are missing. So expand
        //the last redirected path and compare it with the current path
        Path.Length = (wcslen (m_szLastRedirectedPath) + 1) * sizeof (WCHAR);
        Path.MaximumLength = sizeof (m_szLastRedirectedPath);
        Path.Buffer = m_szLastRedirectedPath;

        ExpandedPath.Length = 0;
        ExpandedPath.MaximumLength = sizeof (wszExpandedPath);
        ExpandedPath.Buffer = wszExpandedPath;

        Status = RtlExpandEnvironmentStrings_U (
                      m_pFileDB->_pEnvBlock,
                      &Path,
                      &ExpandedPath,
                      NULL
                      );
        if (ERROR_SUCCESS != Status)
            return TRUE;        //that's our best bet in case of failure

        //
        // Now process the paths so that they do not contain any redundant
        // slashes etc.
        //
        if (NULL == _wfullpath (wszProcessedSource, m_szCurrentPath, MAX_PATH))
        {
            return TRUE;
        }
        else
        {
            //
            // Eliminate any trailing slashes. Note: after going through
            // _wfullpath, there can be at the most one trailing slash
            //
            len = lstrlen (wszProcessedSource);
            if (L'\\' == wszProcessedSource[len-1])
                wszProcessedSource[len - 1] = L'\0';
        }

        if (NULL == _wfullpath (wszProcessedDest, wszExpandedPath, MAX_PATH))
        {
            return TRUE;
        }
        else
        {
            //
            // Eliminate any trailing slashes. Note: after going through
            // _wfullpath, there can be at the most one trailing slash
            //
            len = lstrlen (wszProcessedDest);
            if (L'\\' == wszProcessedDest[len-1])
                wszProcessedDest[len - 1] = L'\0';
        }

        // Now that we have the nice compact paths, we compare them.
        if (0 != _wcsicmp (wszProcessedSource, wszProcessedDest))
            return TRUE;
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   saves settings back to the local settings
//
//  Arguments:  [in] pwszPath : the path to which the folder was redirected
//              [in] dwFlags  : the flags that were used for redirection
//              [in] pSid     : the Sid of the group that was used for
//                              redirection. If this is NULL, then we
//                              default to the Sid for everyone : S-1-1-0
//
//  Returns:    ERROR_SUCCESS if everything was successful or an error code.
//
//  History:    11/20/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::Save (const WCHAR * pwszPath, DWORD dwFlags, PSID pSid, const WCHAR * pszGPOName)
{
    WCHAR *         pwszSection = NULL;
    UNICODE_STRING  StringW;
    WCHAR           pwszFlags [ MAX_PATH ];
    size_t          len;
    int             homedirInfoLen = 0;
    WCHAR *         pszCurr;
    WCHAR           pwszSid [ MaxSidString ];
    DWORD           Status;
    BOOL            bStatus;
    ULONG           ulUserNameInfoLen;
    const WCHAR *   wszHomedir = NULL;
    BOOL            bSaveHomedir = FALSE;

    //
    // First determine if the homedir value needs to be saved.
    // We need to do this first so that we can add the necessary value to the
    // buffer.
    if (IsHomedirPath (m_rID, pwszPath, TRUE) ||
        IsHomedirPolicyPath (m_rID, pwszPath, TRUE))
    {
        wszHomedir = gUserInfo.GetHomeDir (Status);
        if (ERROR_SUCCESS != Status ||
            ! wszHomedir ||
            L'\0' == *wszHomedir)
        {
            Status = (ERROR_SUCCESS == Status) ? ERROR_BAD_PATHNAME : Status;
            goto SaveSettings_End;
        }

        // If we are here, then we need to save the homedir value
        bSaveHomedir = TRUE;
        homedirInfoLen = wcslen (wszHomedir) + 9;   // 8 chars for Homedir=
                                                    // + 1 for the terminating NULL
    }

    //calculate the # of characters required to store UserName=<username>
    //including the terminating NULL character.
    ulUserNameInfoLen = wcslen (gwszUserName) + 10; //9 chars for Username=
                                                    //+ 1 terminating NULL

    //don't need to calculate the exact length, this will be more than enough
    // no double null termination required since new is 0 initing it.
    len = wcslen(pwszPath) + homedirInfoLen + 2 * MAX_PATH + ulUserNameInfoLen + 50;
    pwszSection = new WCHAR[sizeof(WCHAR) * len];

    if (NULL == pwszSection)
    {
        Status = ERROR_OUTOFMEMORY;
        goto SaveSettings_End;
    }

    pwszFlags[0] = L'\0';
    StringW.Length = 0;
    StringW.MaximumLength = sizeof (pwszFlags);
    StringW.Buffer = pwszFlags;

    RtlIntegerToUnicodeString (dwFlags, 16, &StringW);

    Status = HRESULT_CODE(StringCchCopy(pwszSection, len, L"Username="));
    if ( Status != ERROR_SUCCESS )
    {
        goto SaveSettings_End;
    }
    Status = HRESULT_CODE(StringCchCatEx(pwszSection, len, gwszUserName, &pszCurr, &len, 0));
    if ( Status != ERROR_SUCCESS )
    {
        goto SaveSettings_End;
    }

    pszCurr++;

    // Save the homedir value only if the redirection destination is the homedir.
    if (bSaveHomedir)
    {
        Status = HRESULT_CODE(StringCchCopy(pszCurr, len, L"Homedir="));
        if ( Status != ERROR_SUCCESS )
        {
            goto SaveSettings_End;
        }
        Status = HRESULT_CODE(StringCchCatEx(pszCurr, len, wszHomedir, &pszCurr, &len, 0));
        if ( Status != ERROR_SUCCESS )
        {
            goto SaveSettings_End;
        }
        pszCurr++;
    }

    
    Status = HRESULT_CODE(StringCchCopy(pszCurr, len, L"Path="));
    if ( Status != ERROR_SUCCESS )
    {
        goto SaveSettings_End;
    }

    if (IsHomedirPolicyPath (m_rID, pwszPath, TRUE))
    {
        Status = HRESULT_CODE(StringCchCatEx(pszCurr, len, &pwszPath[2], &pszCurr, &len, 0));
        if ( Status != ERROR_SUCCESS )
        {
            goto SaveSettings_End;
        }
    }
    else
    {
        Status = HRESULT_CODE(StringCchCatEx(pszCurr, len, pwszPath, &pszCurr, &len, 0));
        if ( Status != ERROR_SUCCESS )
        {
            goto SaveSettings_End;
        }
    }

    pszCurr++;

    Status = HRESULT_CODE(StringCchCopy(pszCurr, len, L"Flags="));
    if ( Status != ERROR_SUCCESS )
    {
        goto SaveSettings_End;
    }
    Status = HRESULT_CODE(StringCchCatEx(pszCurr, len, pwszFlags, &pszCurr, &len, 0));
    if ( Status != ERROR_SUCCESS )
    {
        goto SaveSettings_End;
    }

    pszCurr++;

    Status = HRESULT_CODE(StringCchCopy(pszCurr, len, L"Group="));
    if ( Status != ERROR_SUCCESS )
    {
        goto SaveSettings_End;
    }

    //now we set the sid to everyone (that is the safest) if no sid has been
    //specified or if we are unable to convert the supplied sid into a string.
    Status = ERROR_INVALID_SID; //just some error code
    if (pSid)
    {
        pwszSid [0] = L'\0';
        StringW.Length = 0;
        StringW.MaximumLength = sizeof (pwszSid);
        StringW.Buffer = pwszSid;

        Status = RtlConvertSidToUnicodeString (&StringW, pSid, FALSE);
    }

    if (ERROR_SUCCESS != Status)
    {
        (void) StringCbCopy(pwszSid, sizeof(pwszSid), L"S-1-1-0");   //use the sid for everyone if we can't find anything else
    }

    Status = HRESULT_CODE(StringCchCatEx(pszCurr, len, pwszSid, &pszCurr, &len, 0));
    if ( Status != ERROR_SUCCESS )
    {
        goto SaveSettings_End;
    }

    pszCurr++;

    //add the GPO if there is a valid one.
    if (pszGPOName)
    {
        Status = HRESULT_CODE(StringCchCopy(pszCurr, len, L"GPO="));
        if ( Status != ERROR_SUCCESS )
        {
            goto SaveSettings_End;
        }
        Status = HRESULT_CODE(StringCchCatEx(pszCurr, len, pszGPOName, &pszCurr, &len, 0));
        if ( Status != ERROR_SUCCESS )
        {
            goto SaveSettings_End;
        }
    }

    //before writing to the ini file, we must pre-create it in Unicode,
    //otherwise, the WritePrivate* APIs will write the file in ANSI, which
    //will break folder redirection in international/ML builds.
    Status = PrecreateUnicodeIniFile (m_szSavedSettingsPath);
    if ((Status != ERROR_SUCCESS) && (Status != ERROR_ALREADY_EXISTS)) 
    {
        goto SaveSettings_End;
    }

    Status = ERROR_SUCCESS;
    //now we can go ahead and save the section
    //first empty the section
    bStatus = WritePrivateProfileSection (
                   g_szDisplayNames[(int) m_rID],
                   NULL,
                   m_szSavedSettingsPath
                   );
    //now write the actual section
    if (bStatus)
        bStatus = WritePrivateProfileSection (
                       g_szDisplayNames[(int) m_rID],
                       pwszSection,
                       m_szSavedSettingsPath
                       );

    if (!bStatus)
        Status = GetLastError();

SaveSettings_End:
    if (pwszSection)
        delete [] pwszSection;

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::HandleUserNameChange
//
//  Synopsis:   this function handles any changes in the user name that
//              have occurred since the last logon. in case the username has
//              changed since the last logon, this function renames any
//              folders redirected earlier using the %username% variable so
//              that the path that the redirected folder points to is continues
//              to be valid.
//
//  Arguments:  [in] pFileDB : point to the CFileDB object.
//
//  Returns:    ERROR_SUCCESS if everything worked properly
//              an error code otherwise.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:      a failed rename is not considered a failure. in this case,
//              an event is logged and the code ensures that redirection
//              is not attempted if there is a simultaneous change in the
//              redirection policies.
//
//              in this way a failed rename for one folder does not hold up
//              the redirection of other folders which might be independent of
//              this particular folder.
//---------------------------------------------------------------------------
DWORD CSavedSettings::HandleUserNameChange (CFileDB * pFileDB,
                                            CRedirectInfo * pRedir)
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   RedirStatus = ERROR_SUCCESS;
    WCHAR   wszLastPath [TARGETPATHLIMIT];
    WCHAR   wszExpandedSource [TARGETPATHLIMIT];
    WCHAR   wszExpandedDest [TARGETPATHLIMIT];
    WCHAR   wszRenamePart [TARGETPATHLIMIT];
    WCHAR   wszExpandedRenameSource [TARGETPATHLIMIT];
    WCHAR   wszExpandedRenameDest [TARGETPATHLIMIT];
    WCHAR * wszTemp = NULL;
    WCHAR * wszEnd = NULL;
    SHARESTATUS SourceStatus;
    SHARESTATUS DestStatus;
    BOOL    bRenamePerformed = FALSE;


    if ((! m_bUserNameChanged)    ||
        pRedir->WasRedirectionAttempted() ||
        (REDIR_DONT_CARE & m_dwFlags))
    {
        goto HandleUPNChangeEnd;//nothing to do if the username has not changed
                                //since the last logon or if the rename has
                                //already been attempted. Even if the attempted
                                //redirection had failed, it is not fatal.
                                //similarly, if policy didn't set the location
                                //of the folder last time, we don't care.
    }

    if (Programs == m_rID ||  //since programs and startup always follow the
        Startup == m_rID      //Start Menu, rename of Start Menu handles these
                              //folders automatically
        )
    {
        goto HandleUPNChangeEnd;
    }

    //show additional status messages if the verbose status is on.
    DisplayStatusMessage (IDS_REDIR_CALLBACK);
    DebugMsg ((DM_VERBOSE, IDS_UPN_CHANGE, pRedir->GetLocalizedName(), m_szLastUserName, gwszUserName));

    //okay, so there is a change in the user name and policy did care about the
    //the location. check if last path contained the username. if not, we have
    //nothing more to do.
    if (TARGETPATHLIMIT <= wcslen (m_szLastRedirectedPath))
    {
        gpEvents->Report (
                EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                3,
                pRedir->GetLocalizedName(),
                m_szLastRedirectedPath,
                NumberToString ( TARGETPATHLIMIT )
                );
        pRedir->PreventRedirection (STATUS_BUFFER_TOO_SMALL);
        goto HandleUPNChangeEnd;
    }
    (void) StringCchCopy(wszLastPath, TARGETPATHLIMIT, m_szLastRedirectedPath);
    _wcslwr (wszLastPath);

    wszTemp = wcsstr (wszLastPath, L"%username%");

    if (NULL == wszTemp)
        goto HandleUPNChangeEnd;    //there is no %username% string, we are
                                    //done. no rename is required.

    //get the part that needs to be renamed.
    (void) StringCchCopy(wszRenamePart, TARGETPATHLIMIT, wszLastPath);
    wszEnd = wcschr (wszRenamePart + (wszTemp - wszLastPath), L'\\');
    if (wszEnd)
        *wszEnd = L'\0';

    //get expanded versions of the paths -- using the new username and the old
    //username
    wszTemp = wszLastPath;
    RedirStatus = ExpandPathSpecial (pFileDB, wszLastPath, m_szLastUserName, wszExpandedSource);
    if (ERROR_SUCCESS == RedirStatus)
    {
        RedirStatus = ExpandPathSpecial (pFileDB, wszLastPath, gwszUserName, wszExpandedDest);
    }
    if (ERROR_SUCCESS == RedirStatus)
    {
        wszTemp = wszRenamePart;
        RedirStatus = ExpandPathSpecial (pFileDB, wszRenamePart, m_szLastUserName, wszExpandedRenameSource);
    }
    if (ERROR_SUCCESS == RedirStatus)
    {
        RedirStatus = ExpandPathSpecial (pFileDB, wszRenamePart, gwszUserName, wszExpandedRenameDest);
    }

    if (STATUS_BUFFER_TOO_SMALL == RedirStatus)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_DESTPATH_TOO_LONG,
                3,
                pRedir->GetLocalizedName(),
                wszTemp,
                NumberToString ( TARGETPATHLIMIT )
                );
        pRedir->PreventRedirection (STATUS_BUFFER_TOO_SMALL);
        goto HandleUPNChangeEnd;
    }
    else if (ERROR_SUCCESS != RedirStatus)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_EXPAND_FAIL,
                2,
                pRedir->GetLocalizedName(),
                StatusToString ( RedirStatus )
                );
        pRedir->PreventRedirection (RedirStatus);
        goto HandleUPNChangeEnd;
    }

    //get the online/offline status of the shares.
    SourceStatus = GetCSCStatus (wszExpandedRenameSource);
    DestStatus = GetCSCStatus (wszExpandedRenameDest);

    if (ShareOffline == SourceStatus || ShareOffline == DestStatus)
    {
        gpEvents->Report (
                EVENT_FDEPLOY_FOLDER_OFFLINE,
                3,
                pRedir->GetLocalizedName(),
                wszExpandedSource,
                wszExpandedDest
                );
        pRedir->PreventRedirection (ERROR_CSCSHARE_OFFLINE);
        goto HandleUPNChangeEnd;
    }

    //we are finally ready to rename. first make sure that the source exists.
    //sometimes an earlier rename operation might have already renamed this
    //folder
    RedirStatus = ERROR_SUCCESS;
    if (0xFFFFFFFF == GetFileAttributes(wszExpandedRenameSource))
    {
        RedirStatus = GetLastError();
    }
    if (ERROR_FILE_NOT_FOUND != RedirStatus)
    {
        bStatus = MoveFile (wszExpandedRenameSource, wszExpandedRenameDest);
        if (!bStatus)
        {
            RedirStatus = GetLastError();
            gpEvents->Report (
                    EVENT_FDEPLOY_REDIRECT_FAIL,
                    4,
                    pRedir->GetLocalizedName(),
                    StatusToString (RedirStatus),
                    wszExpandedSource,
                    wszExpandedDest
                    );
            pRedir->PreventRedirection (RedirStatus);
            goto HandleUPNChangeEnd;
        }
    }

    //the rename was successful. now rename the CSC cache.
    if (ShareOnline == SourceStatus)
    {
        MoveDirInCSC (wszExpandedSource, wszExpandedDest, NULL, SourceStatus, DestStatus, TRUE, TRUE);
        DeleteCSCShareIfEmpty (wszExpandedSource, SourceStatus);
    }
    bRenamePerformed = TRUE;

HandleUPNChangeEnd:
    if (m_bUserNameChanged && ERROR_SUCCESS == pRedir->GetRedirStatus())
    {
        UpdateUserNameInCache();
        if (bRenamePerformed)
        {
            gpEvents->Report(
                    EVENT_FDEPLOY_FOLDER_REDIRECT,
                    1,
                    pRedir->GetLocalizedName());
        }
    }
    return RedirStatus;
}

//+--------------------------------------------------------------------------
//
//  Member:     CSavedSettings::UpdateUserNameInCache
//
//  Synopsis:   updates the user name in the cache with the new username
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS : if successful.
//              an error code otherwise.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CSavedSettings::UpdateUserNameInCache (void)
{
    BOOL    bStatus;

    bStatus = WritePrivateProfileString (
                     g_szDisplayNames[(int) m_rID],
                     L"UserName",
                     gwszUserName,
                     m_szSavedSettingsPath
                     );

    if (!bStatus)
        return GetLastError();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\util.cxx ===
//*************************************************************
//
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//  util.cxx
//
//*************************************************************

#include "fdeploy.hxx"
#define  PCOMMON_IMPL
#include "pcommon.h"

WCHAR* NTPrivs[] = {
    SE_TAKE_OWNERSHIP_NAME,     //we only need take ownership privileges
    SE_RESTORE_NAME,            //we only need to be able to assign owners
    L"\0"
};

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::CCopyFailData
//
//  Synopsis:   constructor for the object that contains data about
//              copy failures.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CCopyFailData::CCopyFailData () : m_bCopyFailed (FALSE), m_dwSourceBufLen (0),
                                  m_pwszSourceName (NULL), m_dwDestBufLen (0),
                                  m_pwszDestName (NULL)
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::~CCopyFailData
//
//  Synopsis:   destructor for the object that contains data about the last
//              copy failure
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
CCopyFailData::~CCopyFailData ()
{
    if (m_dwSourceBufLen)
        delete [] m_pwszSourceName;

    if (m_dwDestBufLen)
        delete [] m_pwszDestName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::RegisterFailure
//
//  Synopsis:   registers information about a failed copy.
//
//  Arguments:  [in] pwszSource : the source file for the copy.
//              [in] pwszDest : the destination file for the copy.
//
//  Returns:    ERROR_SUCCESS : on succesful registration.
//              an error code otherwise.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:      if another failure has already been registered in this
//              object, it is not overwritten with the new info. We only
//              keep track of the first failure. Since folder redirection
//              anyway bails out on the first copy failure, we don't really
//              expect this function to be called more than once.
//
//---------------------------------------------------------------------------
DWORD CCopyFailData::RegisterFailure (LPCTSTR pwszSource, LPCTSTR pwszDest)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    DWORD   dwFromLen = 0;
    DWORD   dwToLen = 0;

    //bail out if another copy failure has already been registered.
    if (m_bCopyFailed)
        return dwStatus;

    //first copy the source info.
    dwFromLen = wcslen (pwszSource);
    if (dwFromLen >= m_dwSourceBufLen)
    {
        //we need a bigger buffer.
        delete [] m_pwszSourceName;
        m_dwSourceBufLen = 0;
        m_pwszSourceName = new WCHAR [dwFromLen + 1];
        if (m_pwszSourceName)
            m_dwSourceBufLen = dwFromLen + 1;
        else
            dwStatus = ERROR_OUTOFMEMORY;
    }
    if (ERROR_SUCCESS == dwStatus)
        (void) StringCchCopy(m_pwszSourceName, m_dwSourceBufLen, pwszSource);

    //now copy the destination info.
    if (ERROR_SUCCESS == dwStatus)
    {
        dwToLen = wcslen (pwszDest);
        if (dwToLen >= m_dwDestBufLen)
        {
            //we need a bigger buffer
            delete [] m_pwszDestName;
            m_dwDestBufLen = 0;
            m_pwszDestName = new WCHAR [dwToLen + 1];
            if (m_pwszDestName)
                m_dwDestBufLen = dwToLen + 1;
            else
                dwStatus = ERROR_OUTOFMEMORY;
        }
    }

    if (ERROR_SUCCESS == dwStatus)
        (void) StringCchCopy(m_pwszDestName, m_dwDestBufLen, pwszDest);

    //register the fact that the copy fail data has been
    //successfully incorporated into the object
    if (ERROR_SUCCESS == dwStatus)
        m_bCopyFailed = TRUE;

    return dwStatus;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::IsCopyFailure
//
//  Synopsis:   indicates if copy failure data exists within the object.
//
//  Arguments:  none.
//
//  Returns:    TRUE / FALSE : self-explanatory
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL CCopyFailData::IsCopyFailure (void)
{
    return m_bCopyFailed;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::GetSourceName
//
//  Synopsis:   gets the name of the source file of the failed copy.
//
//  Arguments:  none.
//
//  Returns:    name of the source file of the failed copy.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:      returns NULL if the data does not exist or if a
//              copy failure has not been incorporated into the object
//
//---------------------------------------------------------------------------
LPCTSTR CCopyFailData::GetSourceName (void)
{
    if (! m_bCopyFailed)
        return NULL;

    if (! m_dwSourceBufLen)
        return NULL;

    return m_pwszSourceName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CCopyFailData::GetDestName
//
//  Synopsis:   gets the name of the destination file of the failed copy.
//
//  Arguments:  none.
//
//  Returns:    name of the destination file of the failed copy.
//
//  History:    1/25/2000  RahulTh  created
//
//  Notes:      returns NULL if the data does not exist or if a copy failure
//              has not been incorporated into the object.
//
//---------------------------------------------------------------------------
LPCTSTR CCopyFailData::GetDestName (void)
{
    if (! m_bCopyFailed)
        return NULL;

    if (! m_dwDestBufLen)
        return NULL;

    return m_pwszDestName;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsOnNTFS
//
//  Synopsis:   this function determines whether a given file/folder lies
//              on an NTFS volume or not.
//
//  Arguments:  [in] pwszPath : the full pathname of the file.
//
//  Returns:    ERROR_SUCCESS : if it is on NTFS
//              ERROR_NO_SECURITY_ON_OBJECT : if it is on FAT
//              other error codes if something goes wrong
//
//  History:    9/4/1998  RahulTh  created
//
//  Notes:
//              1. the full pathname is required in order to determine
//                 if the file/folder is on an NTFS volume
//              2. If the file/folder lies on a network share, then the
//                 share must be online when this function is executed.
//                 if it is offline and CSC is turned on, then even NTFS
//                 volumes will show up as FAT volumes.
//
//---------------------------------------------------------------------------
DWORD IsOnNTFS (const WCHAR* pwszPath)
{
    WCHAR*  szName = 0;
    DWORD   Status;
    size_t  len;
    BOOL    bAddSlash = FALSE;
    BOOL    bStatus;
    DWORD   dwFlags;
    WCHAR*  szLastSlash;
    WCHAR*  pwszSuccess = NULL;

    // Basic sanity checks
    if (NULL == pwszPath || L'\0' == *pwszPath)
    {
        return ERROR_BAD_PATHNAME;
    }
    
    //GetVolumeInformation requires its 1st argument to be terminated by a slash
    //so we first make sure that this is the case.
    len = wcslen (pwszPath);
    if ('\\' != pwszPath[len-1])
    {
        len++;
        bAddSlash = TRUE;
    }

    __try {
        szName = (WCHAR*) alloca ((len + 1)*sizeof(WCHAR));
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return ERROR_OUTOFMEMORY;
    }

    //obtain the absolute path
    pwszSuccess = _wfullpath (szName, pwszPath, len + 1);

    if (!pwszSuccess)
    {
        return ERROR_BAD_PATHNAME;  //_wfullpath will very rarely fail, but
                                    //never hurts to take precautions
    }

    if (bAddSlash)
    {
        szName[len] = '\0';
        szName[len-1] = '\\';
    }
    //now our path name is terminated by a slash, and we have the absolute path
    //too, so we don't have to worry about errors generating from weird paths
    //like \\server\share\hello\..\.\ etc...

    for (szLastSlash = szName + len - 1;;)
    {
        bStatus = GetVolumeInformation (szName, 0, 0, 0, 0, &dwFlags, 0, 0);
        if (!bStatus)
        {
            Status = GetLastError();
            if (ERROR_DIR_NOT_ROOT != Status)
            {
                return Status;
            }

            //GetVolumeInformation requires that the path provided to it be
            //the root of the volume. So if we are here, it means that the
            //function returned ERROR_DIR_NOT_ROOT. So we remove the last
            //component from the path and try with the smaller path. We repeat
            //this until we either succeed or end up with no path in which
            //case we return ERROR_INVALID_NAME
            *szLastSlash = '\0';
            szLastSlash = wcsrchr (szName, '\\');
            if (NULL == szLastSlash)
                return ERROR_INVALID_NAME;  //we have run out of components
            else
                szLastSlash[1] = '\0';  //get rid of the last component.
        }
        else
            break;
    }

    if (dwFlags & FS_PERSISTENT_ACLS)
        return ERROR_SUCCESS;           //NTFS supports persistent ACLs

    //if we are here, then GetVolumeInformation succeeded, but the volume
    //does not support persistent ACLs. So it must be a FAT volume.
    return ERROR_NO_SECURITY_ON_OBJECT;
}

//+--------------------------------------------------------------------------
//
//  Function:   RestrictMyDocsRedirection
//
//  Synopsis:   Disables/Enables the ability of users to redirect the
//              "My Documents" folder
//
//  Arguments:  [in] fRestrict : Disable if TRUE, Enable if FALSE
//
//  Returns:    ERROR_SUCCESS : on success
//              *OR* other Win32 error codes based on the error that occurred
//
//  History:    8/25/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD RestrictMyDocsRedirection (
            HANDLE      hToken,
            HKEY        hKeyRoot,
            BOOL        fRestrict
            )
{
    HKEY    hkRoot;
    HANDLE  hUserToken;
    HKEY    hkPolicies;
    HKEY    hkExplorer;
    DWORD   Status;

    hkRoot = hKeyRoot;
    hUserToken = hToken;

    //
    // This policies key is secured, so we must do this as LocalSystem.
    //
    RevertToSelf();

    Status = RegCreateKeyEx(
                hkRoot,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies",
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ | KEY_WRITE,
                NULL,
                &hkPolicies,
                NULL );

    if ( ERROR_SUCCESS == Status )
    {
        Status = RegCreateKeyEx(
                    hkPolicies,
                    L"Explorer",
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hkExplorer,
                    NULL );

        RegCloseKey( hkPolicies );
    }

    if ( ERROR_SUCCESS == Status )
    {
        if ( fRestrict )
        {
            Status = RegSetValueEx(
                        hkExplorer,
                        L"DisablePersonalDirChange",
                        0,
                        REG_DWORD,
                        (PBYTE) &fRestrict,
                        sizeof(fRestrict) );
        }
        else
        {
            RegDeleteValue( hkExplorer, L"DisablePersonalDirChange" );
        }

        RegCloseKey( hkExplorer );
    }

    //now that the keys have been modified, return to impersonation.
    if (!ImpersonateLoggedOnUser( hUserToken ))
        Status = GetLastError();

    if ( ERROR_SUCCESS == Status )
    {
        if ( fRestrict )
        {
            DebugMsg((DM_VERBOSE, IDS_MYDOCSRESTRICT_ON));
        }
        else
        {
            DebugMsg((DM_VERBOSE, IDS_MYDOCSRESTRICT_OFF));
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GroupInList
//
//  Synopsis:   given a group sid in string format, and a list of group sids
//              in PTOKEN_GROUPS format, this function figures out if the
//              give sid belongs to that list
//
//  Arguments:  [in] pwszSid : the given sid in string format
//              [in] PTOKEN_GROUPS : a list of group sids
//
//  Returns:    TRUE : if the group is found in the list
//              FALSE : otherwise. FALSE is also returned if an error occurs
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL GroupInList (WCHAR * pwszSid, PTOKEN_GROUPS pGroups)
{
    ASSERT (pwszSid);

    PSID    pSid = 0;
    DWORD   Status;
    BOOL    bStatus = FALSE;
    DWORD   i;

    //optimization for the basic case
    if (2 == CompareString( LOCALE_INVARIANT, NORM_IGNORECASE, pwszSid, -1, L"s-1-1-0", -1)) //if the user is an earthling
    {
        bStatus = TRUE;
        goto GroupInListEnd;
    }

    Status = AllocateAndInitSidFromString (pwszSid, &pSid);

    if (ERROR_SUCCESS != Status)
        goto GroupInListEnd;

    for (i = 0, bStatus = FALSE;
         i < pGroups->GroupCount && !bStatus;
         i++
        )
    {
        bStatus = RtlEqualSid (pSid, pGroups->Groups[i].Sid);
    }


GroupInListEnd:
    if (pSid)
        RtlFreeSid (pSid);
    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    size_t      sidStrSize = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    SID_IDENTIFIER_AUTHORITY Auth;

    sidStrSize = lstrlen (lpszSidStr) + 1;
    pSidStr = new WCHAR [sidStrSize];
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    (void) StringCchCopy(pSidStr, sidStrSize, lpszSidStr);
    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        delete [] pSidStr;
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = wcslen (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = new WCHAR [len + 1];

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    (void) StringCchCopy(pwszNumStr, len + 1, szNum);
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        delete [] pwszNumStr;
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   CopyProgressRoutine
//
//  Synopsis:   this is a callback function for PrivCopyFileExW. It is used
//              to track errors that are considered fatal by the folder
//              redirection client. In many cases, PrivCopyFileExW will succeed
//              even if a certain operation like encryption fails. The only
//              way a calling prgram can find out about this is through this
//              callback function by looking at the reason for the callback.
//              currently, the only 3 reasons that are considered fatal for
//              redirection are PRIVCALLBACK_ENCRYPTION_FAILED and
//              PRIVCALLBACK_DACL_ACCESS_DENIED and
//              PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED. All other reasons will
//              either not occur, or can be safely ignored.
//
//              The data passed via lpData is actually a pointer to a DWORD
//              that this callback function uses to store an error code if one
//              occurs.
//
//  Arguments:  see sdk help on CopyProgressRoutine
//
//  Returns:    see sdk help on CopyProgressRoutine
//
//  History:    10/21/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD CALLBACK CopyProgressRoutine (
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD         dwStreamNumber,
    DWORD         dwCallbackReason,
    HANDLE        hSourceFile,
    HANDLE        hDestinationFile,
    LPVOID        lpData
    )
{
    LPDWORD lpStatus = (LPDWORD) lpData;

    //an error condition has already been registered. No need to invoke
    //this callback again
    if (ERROR_SUCCESS != *lpStatus)
        return PROGRESS_QUIET;

    switch (dwCallbackReason)
    {
    case PRIVCALLBACK_ENCRYPTION_FAILED:
        *lpStatus = ERROR_ENCRYPTION_FAILED;
        return PROGRESS_CANCEL; //no point continuing. we have already failed
    case PRIVCALLBACK_DACL_ACCESS_DENIED:
        *lpStatus = ERROR_INVALID_SECURITY_DESCR;
        return PROGRESS_CANCEL; //same as above
    case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        *lpStatus = ERROR_INVALID_OWNER;
        return PROGRESS_CANCEL;
    default:
        return PROGRESS_CONTINUE;   //all other conditions can be safely ignored
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   FullFileCopyW
//
//  Synopsis:   this function makes use of the internal API PrivCopyFileExW
//              to copy not only the contents of a file but also metadata
//              like encryption, compression and DACL
//
//              This function also imposes limits on the lengths of the files
//              that can be copied. Anything longer than MAX_PATH is disallowed
//              because the shell cannot gracefully handle such paths and we
//              don't want to create problems for the user by redirecting their
//              files to paths that explorer cannot get to.
//
//  Arguments:  [in] wszSource : the path of the source file.
//              [in] wszDest : the path of the destination file.
//              [in] bFailIfExists : whether the function should fail if
//                                   the destination exists
//
//  Returns:    ERROR_SUCCESS : if successful
//              ERROR_ENCRYPTION_FAILED : if the source is encrypted and
//                                        the destination cannot be encrypted
//              ERROR_INVALID_SECURITY_DESCR: if the DACL of the source cannot
//                                            be copied over to the destination
//              ERROR_FILE_EXISTS / ERROR_ALREADY_EXISTS : if the destination
//                                             exists and bFailIfExists is TRUE
//              ERROR_INVALID_OWNER : if the owner info. cannot be copied
//              or other error codes.
//
//              ERROR_FILENAME_EXCED_RANGE : if the filename is longer than MAX_PATH.
//
//  History:    10/22/1998  RahulTh  created
//              12/13/2000  RahulTh  added length limitations
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD FullFileCopyW (
    const WCHAR*  wszSource,
    const WCHAR*  wszDest,
    BOOL          bFailIfExists
    )
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwFlags = PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_OWNER_GROUP;
    BOOL    bCancel = FALSE;
    BOOL    bStatus;
    int     lenSource = 0;
    int     lenDest = 0;
    
    if (bFailIfExists)
        dwFlags |= COPY_FILE_FAIL_IF_EXISTS;

    if ( wszSource != 0 )
        lenSource = wcslen (wszSource);
    
    if ( wszDest != 0 )
        lenDest = wcslen (wszDest);
    
    //
    // Prevent copying of files longer than MAX_PATH characters. This limitation
    // needs to be added because the shell cannot handle paths longer than
    // MAX_PATH gracefully and we don't want to land the users into trouble by
    // creating files / folder that they cannot get to via explorer.
    //
    if (lenDest >= MAX_PATH || lenSource >= MAX_PATH)
        return ERROR_FILENAME_EXCED_RANGE;

    bStatus = PrivCopyFileExW (wszSource, wszDest,
                               (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                               (LPVOID) &Status,
                               &bCancel,
                               dwFlags
                              );

    //get the last error if PrivCopyFileExW failed
    //and the callback function has not already registered a fatal error
    if ((ERROR_SUCCESS == Status) && (!bStatus))
        Status = GetLastError();

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   FullDirCopyW
//
//  Synopsis:   creates a directory using the new PrivCopyFileExW so that
//              all the file metadata and ownership information is retained
//
//              This function also imposes limits on the lengths of the folders
//              that can be copied. Anything longer than MAX_PATH is disallowed
//              because the shell cannot gracefully handle such paths and we
//              don't want to create problems for the user by redirecting their
//              files to paths that explorer cannot get to.
//
//  Arguments:  [in] pwszSource : the full path of the source directory
//              [in] pwszDest : the full path of the destination directory
//              [in] bSkipDacl : Skip DACL copying.
//
//  Returns:    ERROR_SUCCESS : if the copy was successful
//              ERROR_INVALID_SECURITY_DESCR : if the DACL could not be applied
//              ERROR_INVALID_OWNER : if the owner information could not be copied
//              ERROR_ENCRYPTION_FAILED : if the encryption info. could not be copied
//              or other error codes if some other error occurs
//              ERROR_FILENAME_EXCED_RANGE : if the filename is longer than MAX_PATH.
//
//  History:    11/5/1998  RahulTh  created
//              12/13/2000 RahulTh  added length limitations
//              5/2/2002   RahulTh  added the skip DACL flag
//
//  Notes:      Essentially the same as FullFileCopyW, but we have an extra
//              attribute to indicate that we are trying to copy a directory
//              Also, the FAIL_IF_EXSTS flag doesn't have any significance
//              when we are trying to copy directories, so that is something
//              we do not need here.
//
//---------------------------------------------------------------------------
DWORD FullDirCopyW (const WCHAR* pwszSource, const WCHAR* pwszDest, BOOL bSkipDacl)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwFlags = PRIVCOPY_FILE_METADATA |
                        PRIVCOPY_FILE_OWNER_GROUP | PRIVCOPY_FILE_DIRECTORY;
    BOOL    bCancel = FALSE;
    BOOL    bStatus = TRUE;
    int     lenSource = 0;
    int     lenDest = 0;
    
    if ( pwszSource != NULL )
        lenSource = wcslen (pwszSource);
    
    if ( pwszDest != NULL )
        lenDest = wcslen (pwszDest);
    
    //
    // Prevent copying of files longer than MAX_PATH characters. This limitation
    // needs to be added because the shell cannot handle paths longer than
    // MAX_PATH gracefully and we don't want to land the users into trouble by
    // creating files / folder that they cannot get to via explorer.
    //
    if (lenDest >= MAX_PATH || lenSource >= MAX_PATH)
        return ERROR_FILENAME_EXCED_RANGE;
    
    if (bSkipDacl)
        dwFlags |= PRIVCOPY_FILE_SKIP_DACL;

    bStatus = PrivCopyFileExW (pwszSource, pwszDest,
                               (LPPROGRESS_ROUTINE) CopyProgressRoutine,
                               (LPVOID) &Status,
                               &bCancel,
                               dwFlags
                              );

    //get the last error if PrivCopyFileExW failed
    //and the callback function has not already registered a fatal error
    if ((ERROR_SUCCESS == Status) && (!bStatus))
        Status = GetLastError();

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   FileInDir
//
//  Synopsis:   given a file and a directory, this function determines if
//              a file with the same name exists in the given directory.
//
//  Arguments:  [in] pwszFile : the name of the file : it can be the full path
//              [in] pwszDir : the directory for which the check needs to be
//                             performed
//              [out] pExists : if the function succeeds, this will contain
//                              the result. TRUE if the file is present in the
//                              directory. FALSE otherwise.
//
//  Returns:    ERROR_SUCCESS : if it is successful
//              ERROR_OUTOFMEMORY : if it runs out of memory
//              ERROR_BAD_NETPATH : if the network path for the given directory
//                                  cannot be found
//
//  History:    10/28/1998  RahulTh  created
//
//  Notes:      pwszDir MUST BE \ terminated
//
//---------------------------------------------------------------------------
DWORD FileInDir (LPCWSTR pwszFile, LPCWSTR pwszDir, BOOL* pExists)
{
    const WCHAR*  pwszFileName = NULL;
    WCHAR*  pwszDestName = NULL;
    int     len;
    DWORD   Status = ERROR_SUCCESS;

    //first get the display name of the source file
    pwszFileName = wcsrchr (pwszFile, L'\\');
    if (!pwszFileName)
        pwszFileName = pwszFile;
    else
        pwszFileName++; //go past the slash

    //the dir should be \ terminated
    len = wcslen (pwszFile) + wcslen (pwszDir) + 1;
    __try {
        pwszDestName = (WCHAR*) alloca (sizeof (WCHAR) * len);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return ERROR_OUTOFMEMORY;
    }

    Status = HRESULT_CODE(StringCchCopy(pwszDestName, len, pwszDir));
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }
    Status = HRESULT_CODE(StringCchCat(pwszDestName, len, pwszFileName));
    if ( Status != ERROR_SUCCESS )
    {
        return Status;
    }

    if (0xFFFFFFFF == GetFileAttributes(pwszDestName))
    {
        //return an error if it is a bad network name. Saves us the trouble
        //of trying to redirect to a non-existent location later
        if (ERROR_BAD_NETPATH == GetLastError())
            return ERROR_BAD_NETPATH;
        else
            *pExists = FALSE;
    }
    else
        *pExists = TRUE;

    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ComparePaths
//
//  Synopsis:   given 2 paths, this function compares them to check if
//              they are identical or if one is a descendant of the other
//              or if no such relationship can be deduced
//
//  Arguments:  [in] pwszSource : the first path
//              [in] pwszDest : the second path
//              [out] pResult : the result of the comparison if the function
//                              succeeds in comparing the paths.
//                    value of pResult may contain the following values upon
//                    successful completion.
//                      0 : if the 2 paths are identical
//                      -1 : if the second path is a descendant of the first
//                      1 : if no such relationship can be deduced
//
//  Returns:    ERROR_SUCCESS : if the function succeeds in comparing the paths
//              other error codes depending on the failure
//
//  History:    10/28/1998  RahulTh  created
//
//  Notes:      the result of the comparison is unreliable if the paths are
//              expressed in different formats, e.g. TCP/IP, UNC, NetBios etc.
//
//---------------------------------------------------------------------------
DWORD ComparePaths (LPCWSTR pwszSource, LPCWSTR pwszDest, int* pResult)
{
    DWORD   Status = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    BOOL    bStatus;
    WCHAR*  pwszAbsSource = NULL;
    WCHAR*  pwszAbsDest = NULL;
    int     lSource, lDest;
    size_t  sourceSize, destSize;
    WCHAR*  pwszSuccess = NULL;

    ASSERT (pResult);
    //first allocate memory for the absolute paths.
    //since the arguments to this function are full pathnames
    //the lengths of the absolute paths cannot exceed the length of
    //the parameters
    //add an extra character because we will add a \ to the end of the abs. path
    sourceSize = wcslen (pwszSource) + 2;
    __try {
        pwszAbsSource = (WCHAR*) alloca (sizeof(WCHAR) * sourceSize);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        pwszAbsSource = NULL;
        Status = ERROR_OUTOFMEMORY;
        goto ComparePathsEnd;
    }

    //add an extra character because we will add a \ to the end of the abs. path
    destSize = wcslen (pwszDest) + 2;
    __try {
        pwszAbsDest = (WCHAR*) alloca (sizeof(WCHAR) * destSize);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        pwszAbsDest = NULL;
        Status = ERROR_OUTOFMEMORY;
        goto ComparePathsEnd;
    }

    //first get the absolute paths. after that we will just work with the
    //absolute paths.
    //note: we need the absolute paths so that we can can check if one path
    //is a descendant of the other path by just using wcsncmp. without absolute
    //paths, wcsncmp cannot be used because we can have 2 paths like
    //\\server\share\hello\there and \\server\share\hello\..\hello\there\hi
    //in this case the second path is actually a descendant of the first, but
    //wcsncmp cannot detect that. getting the absolute paths will eliminate
    //the .., . etc.
    //also we must terminate the absolute paths with \, so that wcsncmp does
    //not mistakenly think that \\server\share\hellofubar is a descendant
    //of \\server\share\hello
    pwszSuccess = _wfullpath (pwszAbsSource, pwszSource, sourceSize);
    if (!pwszSuccess)
    {
        Status = ERROR_BAD_PATHNAME;
        goto ComparePathsEnd;
    }
    pwszSuccess = _wfullpath (pwszAbsDest, pwszDest, destSize);
    if (!pwszSuccess)
    {
        Status = ERROR_BAD_PATHNAME;
        goto ComparePathsEnd;
    }

    //update the lengths with the actual lengths of the absolute paths
    //not including the terminating null character
    lSource = wcslen (pwszAbsSource);
    lDest = wcslen (pwszAbsDest);

    //terminate the absolute paths with '\' if necessary. also make
    //the appropriate changes to the lengths
    if (L'\\' != pwszAbsSource[lSource - 1])
    {
        (void) StringCchCat(pwszAbsSource, sourceSize, L"\\");  //we won't run out of space here
        //because of the extra character allocation
        lSource++;
    }
    if (L'\\' != pwszAbsDest[lDest - 1])
    {
        (void) StringCchCat(pwszAbsDest, destSize, L"\\");    //won't run out of space here because
        //of the extra allocation above
        lDest++;
    }

    //now we are all set (finally!) to perform the comparisons

    //first do a simple check of whether the paths are identical
    if ((lSource == lDest) && (0 == _wcsicmp (pwszAbsSource, pwszAbsDest)))
    {
        *pResult = 0;
        goto ComparePathsSuccess;
    }

    //check for recursion
    if ((lDest > lSource) && (0 == _wcsnicmp (pwszAbsSource, pwszAbsDest, lSource)))
    {
        *pResult = -1;
        goto ComparePathsSuccess;
    }

    //if we are here, these paths are not identical...
    *pResult = 1;


ComparePathsSuccess:
    Status = ERROR_SUCCESS;
    goto ComparePathsEnd;

ComparePathsEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   CheckIdenticalSpecial
//
//  Synopsis:   given 2 paths, this function determines if they are actually
//              the same path expressed in 2 different formats
//
//  Arguments:  [in] pwszSource : path #1
//              [in] pwszDest   : path #2
//              [out] pResult   : result of the comparison
//
//  Returns:    ERROR_SUCCESS if the function could perform the comparison
//              in this case *pResult will contain the result of comparison
//              Other win32 errors, in which case *pResult should not be used
//              by the calling function
//
//  History:    12/1/1998  RahulTh  created
//
//  Notes:      this function expects both pwszSource and pwszDest to exist and
//              be online when it is called.
//
//---------------------------------------------------------------------------
DWORD CheckIdenticalSpecial (LPCWSTR pwszSource, LPCWSTR pwszDest, int* pResult)
{
    ASSERT (pResult);

    BOOL    bStatus;
    DWORD   Status;
    BOOL    bTempFileCreated = FALSE;
    WCHAR * pwszTempPath;
    UINT    lUnique = 0;
    BOOL    bFileExists;
    WCHAR * pwszSlashTerminatedDest;
    int     lDest, destSize;

    //first append a \ to pwszDest if it is not already \ terminated
    //allocate an extra characted just in case we need it
    lDest = wcslen(pwszDest);
    destSize = lDest + 2;
    __try {
        pwszSlashTerminatedDest = (WCHAR *) alloca (sizeof (WCHAR) * destSize);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        pwszSlashTerminatedDest = NULL;
        Status = ERROR_OUTOFMEMORY;
        goto CheckIdenticalEnd;
    }

    (void) StringCchCopy(pwszSlashTerminatedDest, destSize, pwszDest);
    if (L'\\' != pwszSlashTerminatedDest[lDest - 1])
    {
        (void) StringCchCat(pwszSlashTerminatedDest, destSize, L"\\");
        lDest++;
    }

    __try {
        pwszTempPath = (WCHAR*) alloca (sizeof (WCHAR) * (MAX_PATH + wcslen(pwszSource) + 2));
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        pwszTempPath = NULL;
        Status = ERROR_OUTOFMEMORY;
        goto CheckIdenticalEnd;
    }

    if (0 == (lUnique = GetTempFileName(pwszSource, L"fde", 0, pwszTempPath)))
    {
        //a failure to create the temporary file would mean that the source
        //and destination paths are different...
        *pResult = 1;
        goto CheckIdenticalSuccess;
    }

    //now we have created a temporary file,
    bTempFileCreated = TRUE;

    //check if it exists on the destination
    //note: FileInDir requires that the path in the second parameter is
    //      slash terminated.
    Status = FileInDir (pwszTempPath, pwszSlashTerminatedDest, &bFileExists);

    if (Status != ERROR_SUCCESS)
        goto CheckIdenticalEnd;

    //if the file does not exist at the destination, we know that these 2 paths
    //are different. However, if the file does exist at the destination, we
    //need to watch out for the rare case that the file existed even before we
    //we created the temp file at the source. To do this, we must delete the
    //temp file from the source and make sure that it has indeed disappeared
    //from the destination
    if (!bFileExists)
    {
        *pResult = 1;
    }
    else
    {
        if (!DeleteFile(pwszTempPath))
            goto CheckIdenticalErr;

        //the file has been deleted
        bTempFileCreated = FALSE;
        //make sure that it has disappeared from the destination
        Status = FileInDir (pwszTempPath, pwszSlashTerminatedDest, &bFileExists);

        if (Status != ERROR_SUCCESS)
            goto CheckIdenticalEnd;

        if (bFileExists)
        {
            *pResult = 1;   //by some quirk of fate, a file by the same name as
                            //the tempfile preexisted on the destination, so
                            //in reality they are not the same share.
        }
        else
        {
            //the file has disappeared from the dest. this means that it was
            //indeed the same share
            *pResult = 0;
        }
    }

CheckIdenticalSuccess:
    Status = ERROR_SUCCESS;
    goto CheckIdenticalEnd;

CheckIdenticalErr:
    Status = GetLastError();

CheckIdenticalEnd:
    if (bTempFileCreated)
        DeleteFile (pwszTempPath);  //ignore any errors here.
    return Status;
}

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetSetOwnerPrivileges
//
//  Synopsis:   tries to get privileges to set ownership
//
//  Arguments:  [in] hToken : handle to the token for which we are trying to
//                            obtain the privileges
//
//  Returns:    nothing
//
//  History:    11/6/1998  RahulTh  created
//
//  Notes:      this function never fails. It just tries its best to get all
//              NT privileges. It is not guaranteed that it will get all of
//              them, as it depends on the user's rights
//
//---------------------------------------------------------------------------
void GetSetOwnerPrivileges (HANDLE hToken)
{
    BOOL    bStatus;
    DWORD   Status;
    DWORD   Size = 0;
    DWORD   i;
    DWORD   privCount;
    PTOKEN_PRIVILEGES pPrivs = NULL;

    //try to get all the windows NT privileges.
    for (i=0, privCount=0; *NTPrivs[i]; i++)
        privCount++;

    Size = sizeof (LUID_AND_ATTRIBUTES) * (privCount - 1) +
                sizeof (TOKEN_PRIVILEGES);

    __try {
        pPrivs = (PTOKEN_PRIVILEGES) alloca (Size);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        pPrivs = NULL;
        goto GetAllPrivsEnd;
    }

    for (i=0, privCount = 0; *NTPrivs[i]; i++)
    {
        bStatus = LookupPrivilegeValue (NULL, NTPrivs[i],
                                        &(pPrivs->Privileges[privCount].Luid));
        if (!bStatus)
            continue;

        pPrivs->Privileges[privCount++].Attributes = SE_PRIVILEGE_ENABLED;
    }
    pPrivs->PrivilegeCount = privCount;

    AdjustTokenPrivileges (hToken,
                           FALSE,
                           pPrivs,
                           NULL, NULL, NULL
                           );

GetAllPrivsEnd:
    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   SafeGetPrivateProfileStringW
//
//  Synopsis:   a wrapper for GetPrivateProfileString which takes care of
//              all the error checks etc. so that functions that call
//              this routine won't have to do it.
//
//  Arguments:  very similar to GetPrivateProfileStringW
//
//  Returns:    ERROR_SUCCESS if successful. An error code otherwise
//              Also, upon successful return *pSize contains the size of
//              the data copied -- not including the terminating NULL
//              probably the only Error code this will ever return is
//              ERROR_OUTOFMEMORY
//
//  History:    11/19/1998  RahulTh  created
//              12/13/2000  RahulTh  made prefix happy by initializing vars.
//                                   which anyway get set by GetPrivateProfileString
//
//  Notes:      if *ppwszReturnedString has been allocated memory, it might
//              get freed by this function
//              this function also allocates memory for the data
//
//---------------------------------------------------------------------------
DWORD SafeGetPrivateProfileStringW (
             const WCHAR * pwszSection,
             const WCHAR * pwszKey,
             const WCHAR * pwszDefault,
             WCHAR **      ppwszReturnedString,
             DWORD *       pSize,
             const WCHAR * pwszIniFile
             )
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   retVal;

    *pSize = MAX_PATH;
    do
    {
        if (*ppwszReturnedString)
            delete [] *ppwszReturnedString;

        *ppwszReturnedString = new WCHAR [*pSize];

        if (!(*ppwszReturnedString))
        {
            Status = ERROR_OUTOFMEMORY;
            *pSize = 0;
            goto SafeGetEnd;
        }
        
        (*ppwszReturnedString)[0] = L'*';
        (*ppwszReturnedString)[1] = L'\0';
        

        retVal = GetPrivateProfileString (
                       pwszSection,
                       pwszKey,
                       pwszDefault,
                       *ppwszReturnedString,
                       *pSize,
                       pwszIniFile
                       );

        if (*pSize - 1 != retVal)
        {
            *pSize = retVal;
            break;
        }

        //if we are here, we need more memory
        //try with twice of what we had
        *pSize = (*pSize) * 2;

    } while ( TRUE );

SafeGetEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   MySidCopy
//
//  Synopsis:   copies sids and also allocates memory for the destination Sid
//
//  Arguments:  [out] ppDestSid : pointer the destination Sid;
//              [in] pSourceSid : the source Sid
//
//  Returns:    ERROR_SUCCESS if successful. an error code otherwise
//
//  History:    11/20/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD MySidCopy (PSID * ppDestSid, PSID pSourceSid)
{
    DWORD Status;
    ULONG Size = 0;

    *ppDestSid = 0;

    if (!pSourceSid)
        return ERROR_SUCCESS;

    Size = RtlLengthSid (pSourceSid);

    if (!Size)
        return ERROR_SUCCESS;

    *ppDestSid = (PSID) new BYTE [Size];

    if (! (*ppDestSid))
        return ERROR_OUTOFMEMORY;

    NTSTATUS ntStatus;
    DWORD dwError;

    ntStatus = RtlCopySid (Size, *ppDestSid, pSourceSid);
    dwError = RtlNtStatusToDosError(ntStatus);
    if (!NT_SUCCESS(ntStatus)) 
    {
        delete [] *ppDestSid;
        *ppDestSid = NULL;
    }

    return dwError;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetShareStatus
//
//  Synopsis:   this function is a wrapper for CSCQueryFileStatus.
//              basically CSCQueryFileStatus can fail if there was never a net
//              use to a share. So this function tries to create a net use to
//              the share if CSCQueryFileStatus fails and then re-queries the
//              file status
//
//  Arguments:  [in] pwszShare : the share name
//              [out] pdwStatus : the share Status
//              [out] pdwPinCount : the pin count
//              [out] pdwHints : the hints
//
//  Returns:    TRUE : if everything was successful.
//              FALSE : if there was an error. In this case, it GetLastError()
//                      will contain the specific error code.
//
//  History:    5/11/1999  RahulTh  created
//
//  Notes:      it is very important that this function be passed a share name
//              it does not do any parameter validation. So under no
//              circumstance should this function be passed a filename.
//
//---------------------------------------------------------------------------
BOOL GetShareStatus (const WCHAR * pwszShare, DWORD * pdwStatus,
                     DWORD * pdwPinCount, DWORD * pdwHints)
{
    NETRESOURCE nr;
    DWORD       dwResult;
    DWORD       dwErr = NO_ERROR;
    BOOL        bStatus;

    bStatus = CSCQueryFileStatus(pwszShare, pdwStatus, pdwPinCount, pdwHints);

    if (!bStatus)
    {
        //try to connect to the share
        ZeroMemory ((PVOID) (&nr), sizeof (NETRESOURCE));
        nr.dwType = RESOURCETYPE_DISK;
        nr.lpLocalName = NULL;
        nr.lpRemoteName = (LPTSTR) pwszShare;
        nr.lpProvider = NULL;

        dwErr = WNetUseConnection(NULL, &nr, NULL, NULL, 0,
                                  NULL, NULL, &dwResult);

        if (NO_ERROR == dwErr)
        {
            bStatus = CSCQueryFileStatus (pwszShare, pdwStatus, pdwPinCount, pdwHints);
            if (!bStatus)
                dwErr = GetLastError();
            else
                dwErr = NO_ERROR;

            WNetCancelConnection2 (pwszShare, 0, FALSE);
        }
        else
        {
            bStatus = FALSE;
        }

    }

    SetLastError(dwErr);
    return bStatus;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetCSCStatus
//
//  Synopsis:   given a path, finds out if it is local and if it is not
//              whether it is online or offline.
//
//  Arguments:  [in] pwszPath : the path to the file
//
//  Returns:    Local/Online/Offline
//
//  History:    11/20/1998  RahulTh  created
//
//  Notes:      it is important that the path passed to this function is a
//              a full path and not a relative path
//
//              this function will return offline if the share is not live or
//              if the share is live but CSC thinks that it is offline
//
//              it will return PathLocal if the path is local or if the path
//              is a network path that cannot be handled by CSC e.g. a network
//              share with a pathname longer than what csc can handle or if it
//              is a netware share. in this case it makes sense to return
//              PathLocal because CSC won't maintain a database for these shares
//              -- same as for a local path. so as far as CSC is concerned, this
//              is as good as a local path.
//
//---------------------------------------------------------------------------
SHARESTATUS GetCSCStatus (const WCHAR * pwszPath)
{
    WCHAR * pwszAbsPath = NULL;
    WCHAR * pwszCurr = NULL;
    int     len;
    BOOL    bRetVal;
    DWORD   Status;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (!pwszPath)
        return ShareOffline;    //a path must be provided

    len = wcslen (pwszPath);

    __try {
        pwszAbsPath = (WCHAR *) alloca (sizeof (WCHAR) * (len + 1));
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        
        //we are out of memory, so it is safest to return ShareOffline
        //so that we can bail out of redirection.
        return ShareOffline;
    }

    //get the absolute path
    pwszCurr = _wfullpath (pwszAbsPath, pwszPath, len + 1);

    if (!pwszCurr)
    {
        //in order for _wfullpath to fail, something really bad has to happen
        //so it is best to return ShareOffline so that we can bail out of
        //redirection
        return ShareOffline;
    }

    len = wcslen (pwszAbsPath);

    if (! (
           (2 <= len) &&
           (L'\\' == pwszAbsPath[0]) &&
           (L'\\' == pwszAbsPath[1])
           )
       )
    {
        //it is a local path if it does not begin with 2 backslashes
        return PathLocal;
    }

    //this is a UNC path; so extract the \\server\share part
    pwszCurr = wcschr ( & (pwszAbsPath[2]), L'\\');

    //first make sure that it is at least of the form \\server\share
    //watch out for the \\server\ case
    if (!pwszCurr || !pwszCurr[1])
        return ShareOffline;        //it is an invalid path (no share name)

    //the path is of the form \\server\share
    //note: the use _wfullpath automatically protects us against the \\server\\ case
    pwszCurr = wcschr (&(pwszCurr[1]), L'\\');
    if (pwszCurr)   //if it is of the form \\server\share\...
        *pwszCurr = L'\0';

    //now pwszAbsPath is a share name
    bRetVal = CSCCheckShareOnline (pwszAbsPath);

    if (!bRetVal)
    {
        if (!g_bCSCEnabled)
        {
            //CSC has not been enabled on this machine, so the fact that
            //CSC check share online failed means that the share is indeed
            //offline.
            return ShareOffline;
        }
        if (ERROR_SUCCESS != GetLastError())
        {
           //either there is really a problem (e.g. invalid share name) or
           //it is just a share that is not handled by CSC e.g. a netware share
           //or a share with a name that is longer than can be handled by CSC
           //so check if the share actually exists
           if (0xFFFFFFFF != GetFileAttributes(pwszAbsPath))
           {
              //this can still be a share that is offline since GetFileAttributes
              //will return the attributes stored in the cache
              Status = 0;
              bRetVal = GetShareStatus (pwszAbsPath, &Status, &dwPinCount,
                                            &dwHints);
              if (! bRetVal || (! (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & Status)))
                 return PathLocal;     //this is simply a valid path that CSC cannot handle
              else if (bRetVal &&
                       (FLAG_CSC_SHARE_STATUS_NO_CACHING ==
                            (FLAG_CSC_SHARE_STATUS_CACHING_MASK & Status)))
                  return PathLocal;     //CSC caching is not turned on for the share.
           }
        }

        //it is indeed an inaccessble share
        return ShareOffline;  //for all other cases, treat this as offline
    }
    else
    {
        if (!g_bCSCEnabled)
        {
            //CSC has not been enabled on this machine, so the fact that
            //CSCCheckShareOnline succeed means that the share is indeed
            //accessible. Since nothing can be cached, we must return
            //PathLocal here.
            return PathLocal;
        }
        //if we are here, it means that the share is live, but CSC might still
        //think that it is offline.
       Status = 0;
       bRetVal = GetShareStatus (pwszAbsPath, &Status, &dwPinCount,
                                     &dwHints);
       if (bRetVal && (FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP & Status))
          return ShareOffline;   //CSC thinks that the share is offline
       else if (bRetVal &&
                (FLAG_CSC_SHARE_STATUS_NO_CACHING ==
                            (FLAG_CSC_SHARE_STATUS_CACHING_MASK & Status)))
           return PathLocal;    //CSC caching is not turned on for the share
       else if (!bRetVal)
           return ShareOffline;

       //in all other cases, consider the share as online since
       //CSCCheckShareOnline has already returned TRUE
       return ShareOnline;
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   MoveDirInCSC
//
//  Synopsis:   this function moves a directory within the CSC cache without
//              prejudice. If the destination is a local path, it just deletes
//              the source tree from the cache
//
//  Arguments:  [in] pwszSource : the source path
//              [in] pwszDest   : the dest path
//              [in] pwszSkipSubdir : the directory to skip while moving
//              [in] StatusFrom : the CSC status of the source path
//              [in] StatusTo   : the CSC status of the dest. path
//              [in] bAllowRdrTimeout : if stuff needs to be deleted from the
//                              cache, we may not succeed immediately since
//                              the rdr keeps the handles to recently opened
//                              files open. This paramaters tells the function
//                              whether it needs to wait and retry
//
//  Returns:    nothing. it just tries its best.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:      the value of bAllowRdrTimeout is always ignored for the
//              in-cache rename operation. we always want to wait for
//              the timeout.
//
//---------------------------------------------------------------------------
void MoveDirInCSC (const WCHAR * pwszSource, const WCHAR * pwszDest,
                   const WCHAR * pwszSkipSubdir,
                   SHARESTATUS   StatusFrom, SHARESTATUS   StatusTo,
                   BOOL  bAllowRdrTimeoutForDel,
                   BOOL  bAllowRdrTimeoutForRen)
{
    WIN32_FIND_DATA findData;
    DWORD   dwFileStatus;
    DWORD   dwPinCount;
    HANDLE  hCSCFind;
    DWORD   dwHintFlags;
    FILETIME origTime;
    WCHAR * pwszPath;
    WCHAR * pwszEnd;
    int     len;
    size_t  pathSize;
    size_t  endSize;
    DWORD   StatusCSCRen = ERROR_SUCCESS;
    HRESULT hr = S_OK;

    if (!g_bCSCEnabled || PathLocal == StatusFrom)
        return;                 //there is nothing to do. nothing was cached.

    if (PathLocal == StatusTo)
    {
        //the destination is a local path, so we should just delete the
        //files from the source
        DeleteCSCFileTree (pwszSource, pwszSkipSubdir, bAllowRdrTimeoutForDel);
    }
    else
    {
        len = wcslen (pwszSource);
        pathSize = len + MAX_PATH + 2;
        __try {
            pwszPath = (WCHAR *) alloca (sizeof (WCHAR) * pathSize);
        } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
            _resetstkoflw();
            return;
        }
        if (!pwszPath || len <= 0)
            return;
        (void) StringCchCopy(pwszPath, pathSize, pwszSource);
        pwszEnd = pwszPath + len;
        endSize = pathSize - len;
        if (L'\\' != pwszEnd[-1])
        {
            *pwszEnd++ = L'\\';
            endSize--;
        }
        hCSCFind = CSCFindFirstFile (pwszSource, &findData, &dwFileStatus,
                                     &dwPinCount, &dwHintFlags, &origTime);

        if (INVALID_HANDLE_VALUE != hCSCFind)
        {
            do
            {
                if (0 != _wcsicmp (L".", findData.cFileName) &&
                    0 != _wcsicmp (L"..", findData.cFileName) &&
                    (!pwszSkipSubdir || (0 != _wcsicmp (findData.cFileName, pwszSkipSubdir))))
                {
                    StatusCSCRen = HRESULT_CODE(StringCchCopy(pwszEnd, endSize, findData.cFileName));
                    if ( StatusCSCRen != ERROR_SUCCESS )
                    {
                        break;
                    }
                    if (ERROR_SUCCESS == StatusCSCRen)
                    {
                        StatusCSCRen = DoCSCRename (pwszPath, pwszDest, TRUE, bAllowRdrTimeoutForRen);
                    }
                    else
                    {
                        //here we ignore the return value since an error has already occurred.
                        //and we do not wish to spend any more time in timeouts in any subsequent
                        //rename operation.
                        DoCSCRename (pwszPath, pwszDest, TRUE, FALSE);
                    }
                }

            } while ( CSCFindNextFile (hCSCFind, &findData, &dwFileStatus,
                                       &dwPinCount, &dwHintFlags, &origTime)
                     );

            CSCFindClose (hCSCFind);
        }

        //merge the pin info. at the top level folder
        MergePinInfo (pwszSource, pwszDest, StatusFrom, StatusTo);
    }

    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   DoCSCRename
//
//  Synopsis:   does a file rename within the CSC cache.
//
//  Arguments:  [in] pwszSource : full source path
//              [in] pwszDest : full path to destination directory
//              [in] bOverwrite : overwrite if the file/folder exists at
//                                  the destination
//              [in] bAllowRdrTimeout : if TRUE, retry for 10 seconds on failure
//                              so that rdr and mem. mgr. get enough time to
//                              release the handles.
//
//  Returns:    ERROR_SUCCESS if the rename was successful.
//              an error code otherwise.
//
//  History:    5/26/1999  RahulTh  created
//
//  Notes:      no validation of parameters is done. The caller is responsible
//              for that
//
//---------------------------------------------------------------------------
DWORD DoCSCRename (const WCHAR * pwszSource, const WCHAR * pwszDest,
                   BOOL bOverwrite, BOOL bAllowRdrTimeout)
{
    DWORD   Status = ERROR_SUCCESS;
    BOOL    bStatus;
    int     i;

    bStatus = CSCDoLocalRename (pwszSource, pwszDest, bOverwrite);
    if (!bStatus)
    {
        Status = GetLastError();
        if (ERROR_SUCCESS != Status &&
            ERROR_FILE_NOT_FOUND != Status &&
            ERROR_PATH_NOT_FOUND != Status &&
            ERROR_INVALID_PARAMETER != Status &&
            ERROR_BAD_NETPATH != Status)
        {
            if (bAllowRdrTimeout)
            {
                if (!bOverwrite && ERROR_FILE_EXISTS == Status)
                {
                    Status = ERROR_SUCCESS;
                }
                else
                {
                    for (i = 0; i < 11; i++)
                    {
                        Sleep (1000);   //wait for the handle to be released
                        bStatus = CSCDoLocalRename (pwszSource, pwszDest, bOverwrite);
                        if (bStatus)
                        {
                            Status = ERROR_SUCCESS;
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }

    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_CSCRENAME_FAIL, pwszSource, pwszDest, Status));
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCFileTree
//
//  Synopsis:   deletes a file tree from the CSC
//
//  Arguments:  [in] pwszSource : the path to the folder whose contents should
//                                be deleted
//              [in] pwszSkipSubdir : name of the subdirectory to be skipped.
//              [in] bAllowRdrTimeout : if true, makes multiple attempts to
//                              delete the file since the rdr may have left
//                              the handle open for sometime which can result
//                              in an ACCESS_DENIED message.
//
//  Returns:    ERROR_SUCCESS if the deletion was successful. An error code
//              otherwise.
//
//  History:    11/21/1998  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD DeleteCSCFileTree (const WCHAR * pwszSource, const WCHAR * pwszSkipSubdir,
                        BOOL bAllowRdrTimeout)
{
    WIN32_FIND_DATA findData;
    DWORD   dwFileStatus;
    DWORD   dwPinCount;
    HANDLE  hCSCFind;
    DWORD   dwHintFlags;
    FILETIME origTime;
    WCHAR * pwszPath;
    WCHAR * pwszEnd;
    int     len;
    size_t  pathSize;
    size_t  endSize;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwCopyStatus = ERROR_SUCCESS;

    if (! g_bCSCEnabled)
        return ERROR_SUCCESS;
        
    len = wcslen(pwszSource);
    pathSize = len + MAX_PATH + 2;
    __try {
        pwszPath = (WCHAR *) alloca (sizeof(WCHAR) * pathSize);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return ERROR_OUTOFMEMORY;     //nothing much we can do if we run out of memory
    }

    if (len <= 0)
        return ERROR_BAD_PATHNAME;

    (void) StringCchCopy(pwszPath, pathSize, pwszSource);
    pwszEnd = pwszPath + len;
    endSize = pathSize - len;
    if (L'\\' != pwszEnd[-1])
    {
        *pwszEnd++ = L'\\';
        endSize--;
    }

    hCSCFind = CSCFindFirstFile (pwszSource, &findData, &dwFileStatus,
                                 &dwPinCount, &dwHintFlags, &origTime);

    if (INVALID_HANDLE_VALUE != hCSCFind)
    {
        do
        {
            if (0 != _wcsicmp (L".", findData.cFileName) &&
                0 != _wcsicmp (L"..", findData.cFileName) &&
                (!pwszSkipSubdir || (0 != _wcsicmp (pwszSkipSubdir, findData.cFileName))))
            {
                //
                // Note: Don't assign the return value directly to Status or you will
                // risk losing track of the fact that we had failed earlier.
                // As a side-effect of this, we will also not turn off the retry loop (bAllowRdrTimeout)
                // for file deletes and thus will end up with a max. delay which is linearly proportional
                // to the number of filesystem objects in the users' folder rather than a constant max. delay.
                //
                dwCopyStatus = HRESULT_CODE(StringCchCopy(pwszEnd, endSize, findData.cFileName));
                if ( dwCopyStatus != ERROR_SUCCESS )
                {
                    Status = dwCopyStatus;
                    break;
                }

                if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    if (ERROR_SUCCESS != Status)
                    {
                        //no point delaying the deletes since a delete has already
                        //failed.
                        DeleteCSCFileTree (pwszPath, NULL, FALSE);
                    }
                    else
                    {
                        Status = DeleteCSCFileTree (pwszPath, NULL, bAllowRdrTimeout);
                    }
                }
                else
                {
                    if (ERROR_SUCCESS != Status)
                    {
                        //no point delaying the delete if we have already failed.
                        DeleteCSCFile (pwszPath, FALSE);
                    }
                    else
                    {
                        Status = DeleteCSCFile (pwszPath, bAllowRdrTimeout);
                    }
                }
            }

        } while ( CSCFindNextFile (hCSCFind, &findData, &dwFileStatus,
                                   &dwPinCount, &dwHintFlags, &origTime)
                 );

        CSCFindClose (hCSCFind);
    }

    if (ERROR_SUCCESS != Status)
    {
        //no point in delaying the delete if we have already failed.
        DeleteCSCFile (pwszSource, FALSE);
    }
    else
    {
        Status = DeleteCSCFile (pwszSource, bAllowRdrTimeout);
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCFile
//
//  Synopsis:   deletes the given path. but might make repeated attempts to
//              make sure that the rdr has enough time to release any handles
//              that it holds.
//
//  Arguments:  [in] pwszPath : the path to delete.
//              [in] bAllowRdrTimeout : make multiple attempts to delete the
//                          file with waits in between so that the rdr has
//                          enough time to release any held handles.
//
//  Returns:    ERROR_SUCCES if the delete was successful. An error code
//              otherwise.
//
//  History:    5/26/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD DeleteCSCFile (const WCHAR * pwszPath, BOOL bAllowRdrTimeout)
{
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    int     i;

    bStatus = CSCDelete (pwszPath);
    if (!bStatus)
    {
        Status = GetLastError();
        if (ERROR_SUCCESS != Status &&
            ERROR_FILE_NOT_FOUND != Status &&
            ERROR_PATH_NOT_FOUND != Status &&
            ERROR_INVALID_PARAMETER != Status)
        {
            //this is a valid error.
            //so based on the value of bAllowRdrTimeout and based
            //on whether we have already failed in deleting something
            //we will try repeatedly to delete the file for 10 seconds
            //note: there is no point in repeatedly trying if the deletion
            //failed because this was a directory which was not empty
            if (bAllowRdrTimeout && ERROR_DIR_NOT_EMPTY != Status)
            {
                for (i = 0; i < 11; i++)
                {
                    Sleep (1000);   //wait for 1 second and try again
                    bStatus = CSCDelete (pwszPath);
                    if (bStatus)
                    {
                        Status = ERROR_SUCCESS;
                        break;
                    }
                }
            }
        }
        else
        {
            Status = ERROR_SUCCESS;
        }
    }

    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_CSCDELETE_FAIL, pwszPath, Status));
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DisplayStatusMessage
//
//  Synopsis:   displays the status message in the UI when the verbose status
//              is on.
//
//  Arguments:  resource id of the message to be displayed.
//
//  Returns:    nothing
//
//  History:    2/25/1999  RahulTh  created
//
//  Notes:      failures are ignored.
//
//---------------------------------------------------------------------------
void DisplayStatusMessage (UINT rid)
{
    WCHAR   pwszMessage [MAX_PATH];

    if (!gpStatusCallback)
        return;

    if (!LoadString (ghDllInstance, rid, pwszMessage, MAX_PATH))
        return;

    gpStatusCallback (TRUE, pwszMessage);
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCSCShareIfEmpty
//
//  Synopsis:   given a file name, this function deletes from the local cache
//              the share to which the file belongs if the local cache for that
//              share is empty
//
//  Arguments:  [in] pwszFileName : the full file name -- must be UNC
//              [in] shStatus : the share status - online, offline, local etc.
//
//  Returns:    ERROR_SUCCESS : if successful
//              a win32 error code if something goes wrong
//
//  History:    4/22/1999  RahulTh  created
//
//  Notes:      we do not have to explicitly check if the share is empty
//              because if it is not, then the delete will fail anyway
//
//---------------------------------------------------------------------------
DWORD DeleteCSCShareIfEmpty (LPCTSTR pwszFileName, SHARESTATUS shStatus)
{
    DWORD   Status;
    WCHAR * pwszFullPath = NULL;
    WCHAR * pwszCurr = NULL;
    int     len;
    WCHAR * pwszShrEnd;

    if (PathLocal == shStatus || NoCSC == shStatus)
        return ERROR_SUCCESS;

    if (ShareOffline == shStatus)
        return ERROR_CSCSHARE_OFFLINE;

    len = wcslen (pwszFileName);

    if (len <= 2)
        return ERROR_BAD_PATHNAME;

    if (pwszFileName[0] != L'\\' || pwszFileName[1] != L'\\')
        return ERROR_BAD_PATHNAME;

    __try {
        pwszFullPath = (WCHAR *) alloca (sizeof (WCHAR) * (len + 1));
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return ERROR_OUTOFMEMORY;
    }

    if (NULL == _wfullpath(pwszFullPath, pwszFileName, len + 1))
        return ERROR_BAD_PATHNAME;  //canonicalization was unsuccessful.
                                    // -- rarely happens

    pwszShrEnd = wcschr (pwszFullPath + 2, L'\\');

    if (NULL == pwszShrEnd)
        return ERROR_BAD_PATHNAME;  //the path does not have the share component

    pwszShrEnd++;

    pwszShrEnd = wcschr (pwszShrEnd, L'\\');

    if (NULL == pwszShrEnd)
    {
        //we already have the path in \\server\share form, so just try to
        //delete the share.
        return DeleteCSCFile (pwszFullPath, TRUE);
    }

    //if we are here, then we have a path longer than just \\server\share.
    //so try to delete all the way up to the share name. This is necessary
    //because a user might be redirected to something like
    // \\server\share\folder\%username% and we wouldn't want only \\server\share
    // and \\server\share\folder to be cached.
    Status = ERROR_SUCCESS;
    do
    {
        pwszCurr = wcsrchr (pwszFullPath, L'\\');
        if (NULL == pwszCurr)
            break;
        *pwszCurr = L'\0';
        Status = DeleteCSCFile (pwszFullPath, TRUE);
        //no point trying to delete the parent if deletion of this directory
        //failed.
        if (ERROR_SUCCESS != Status)
            break;
    } while ( pwszCurr > pwszShrEnd );

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   MergePinInfo
//
//  Synopsis:   merges the pin info. from the source to destination
//
//  Arguments:  [in] pwszSource : the full path to the source
//              [in] pwszDest   : the full path to the destination
//              [in] StatusFrom : CSC status of the source share
//              [in] StatusTo   : CSC status of the destination share
//
//  Returns:    ERROR_SUCCESS : if it was successful
//              a Win32 error code otherwise
//
//  History:    4/23/1999  RahulTh  created
//
//  Notes:      the hint flags are a union of the source hint flags and
//              destination hint flags. The pin count is the greater of the
//              source and destination pin count
//
//              Usually this function should only be called for folders. The
//              CSC rename API handles files well. But this function will work
//              for files as well.
//
//---------------------------------------------------------------------------
DWORD MergePinInfo (LPCTSTR pwszSource, LPCTSTR pwszDest,
                   SHARESTATUS StatusFrom, SHARESTATUS StatusTo)
{
    BOOL    bStatus;
    DWORD   dwSourceStat, dwDestStat;
    DWORD   dwSourcePinCount, dwDestPinCount;
    DWORD   dwSourceHints, dwDestHints;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   i;

    if (ShareOffline == StatusFrom || ShareOffline == StatusTo)
        return ERROR_CSCSHARE_OFFLINE;

    if (ShareOnline != StatusFrom || ShareOnline != StatusTo)
        return ERROR_SUCCESS;       //there is nothing to do if one of the shares
                                    //is local.
    if (!pwszSource || !pwszDest ||
        0 == wcslen(pwszSource) || 0 == wcslen(pwszDest))
        return ERROR_BAD_PATHNAME;

    bStatus = CSCQueryFileStatus (pwszSource, &dwSourceStat, &dwSourcePinCount,
                                  &dwSourceHints);
    if (!bStatus)
        return GetLastError();

    bStatus = CSCQueryFileStatus (pwszDest, &dwDestStat, &dwDestPinCount,
                                  &dwDestHints);
    if (!bStatus)
        return GetLastError();

    //first set the hint flags on the destination
    if (dwDestHints != dwSourceHints)
    {
        bStatus = CSCPinFile (pwszDest, dwSourceHints, &dwDestStat,
                              &dwDestPinCount, &dwDestHints);
        if (!bStatus)
            Status = GetLastError();    //note: we do not bail out here. we try
                                        //to at least merge the pin count before
                                        //leaving
    }

    //now merge the pin count : there is nothing to be done if the destination
    //pin count is greater than or equal to the source pin count
    if (dwDestPinCount < dwSourcePinCount)
    {
        for (i = 0, bStatus = TRUE; i < (dwSourcePinCount - dwDestPinCount) &&
                                    bStatus;
             i++)
        {
            bStatus = CSCPinFile( pwszDest,
                                  FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                                  NULL, NULL, NULL );
        }

        if (!bStatus && ERROR_SUCCESS == Status)
            Status = GetLastError();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   PinIfNecessary
//
//  Synopsis:   this function pins a file if necessary.
//
//  Arguments:  [in] pwszPath : full path of the file/folder to be pinned
//              [in] shStatus : CSC status of the share.
//
//  Returns:    ERROR_SUCCESS if it was successful. An error code otherwise.
//
//  History:    5/27/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD PinIfNecessary (const WCHAR * pwszPath, SHARESTATUS shStatus)
{
    DWORD   Status = ERROR_SUCCESS;
    BOOL    bStatus;
    DWORD   dwStatus;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (!pwszPath || !pwszPath[0])
        return ERROR_BAD_NETPATH;

    if (! g_bCSCEnabled)
        return ERROR_SUCCESS;

    if (ShareOffline == shStatus)
        return ERROR_CSCSHARE_OFFLINE;
    else if (PathLocal == shStatus || NoCSC == shStatus)
        return ERROR_SUCCESS;

    bStatus = CSCQueryFileStatus (pwszPath, &dwStatus, &dwPinCount, &dwHints);
    if (!bStatus || dwPinCount <= 0)
    {
        bStatus = CSCPinFile (pwszPath,
                              FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                              NULL, NULL, NULL);
        if (!bStatus)
            Status = GetLastError();
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   CacheDesktopIni
//
//  Synopsis:   some special folders use the desktop.ini file to present
//              special views in explorer (e.g. My Pictures). If a folder is
//              redirected to a network share and a user goes offline without
//              ever looking at the folder in explorer, the desktop.ini file
//              is not in the cache and therefore the special views are lost
//
//              This function tries to cache the desktop.ini file as soon as
//              the folder is pinned so that special views are not lost even
//              if the user goes offline
//
//              When the folder is unpinned, this function merely unpins the
//              dekstop.ini file
//
//  Arguments:  [in] pwszPath : the path to the folder
//              [in] shStatus : the CSC status of the share
//              [in] uCommand : Pin/Unpin
//
//  Returns:    ERROR_SUCCESS if everything is successful.
//              a win32 error code otherwise.
//
//  History:    4/25/1999  RahulTh  created
//
//  Notes:      this function should only be called after the folder has been
//              successfully redirected.
//
//              if desktop.ini is already pinned, this function does not try
//              to pin it again.
//
//---------------------------------------------------------------------------
DWORD CacheDesktopIni (LPCTSTR pwszPath, SHARESTATUS shStatus, CSCPINCOMMAND uCommand)
{
    int     len;
    WCHAR   szDesktopIniName[] = L"desktop.ini";
    WCHAR * pwszDesktopIni = NULL;
    size_t  desktopIniSize = 0;
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwStatus;
    DWORD   dwPinCount;
    DWORD   dwHints;

    if (PathLocal == shStatus)
        return ERROR_SUCCESS;   //nothing to be done.

    if (ShareOffline == shStatus)
        return ERROR_CSCSHARE_OFFLINE;

    len = wcslen (pwszPath);
    if (!pwszPath || 0 == len)
        return ERROR_BAD_PATHNAME;

    desktopIniSize = len + wcslen(szDesktopIniName) + 2; //extra char for backslash
    __try {
        pwszDesktopIni = (WCHAR *) alloca (sizeof (WCHAR) * desktopIniSize);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return ERROR_OUTOFMEMORY;
    }

    (void) StringCchCopy(pwszDesktopIni, desktopIniSize, pwszPath);
    if (L'\\' != pwszDesktopIni[len - 1])
    {
        pwszDesktopIni[len] = L'\\';
        pwszDesktopIni[len + 1] = L'\0';
    }
    (void) StringCchCat(pwszDesktopIni, desktopIniSize, szDesktopIniName);

    if (PinFile == uCommand)
    {
        bStatus = CSCQueryFileStatus (pwszDesktopIni, &dwStatus, &dwPinCount,
                                      &dwHints);
        //pin only if it has not already been pinned.
        if (!bStatus || dwPinCount <= 0)
        {
            if (bStatus = CSCPinFile(pwszDesktopIni,
                                     FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                                     NULL, NULL, NULL)
                )
            {
                bStatus = CSCFillSparseFiles(pwszDesktopIni, FALSE,
                                             CSCCallbackProc, 0);
            }
            if (!bStatus)
                Status = GetLastError();
        }
    }
    else if (UnpinFile == uCommand)
    {
        if (! CSCUnpinFile (pwszDesktopIni, FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                            NULL, NULL, NULL))
            Status = GetLastError();
    }

    return Status;

}

//+--------------------------------------------------------------------------
//
//  Function:   CSCCallbackProc
//
//  Synopsis:   callback function for CSCFillSparseFiles
//
//  Arguments:  see docs
//
//  Returns:    see docs
//
//  History:    4/26/1999  RahulTh  created
//
//  Notes:      just returns a default value for all...
//
//---------------------------------------------------------------------------
DWORD WINAPI
CSCCallbackProc(LPCTSTR             pszName,
                DWORD               dwStatus,
                DWORD               dwHintFlags,
                DWORD               dwPinCount,
                LPWIN32_FIND_DATA   pFind32,
                DWORD               dwReason,
                DWORD               dwParam1,
                DWORD               dwParam2,
                DWORD_PTR           dwContext)
{
    return CSCPROC_RETURN_CONTINUE;
}

//+--------------------------------------------------------------------------
//
//  Function:   UpdateMyPicsShellLink
//
//  Synopsis:   there is no easy way to get to My Pictures if it is redirected
//              independently of My Documents since the shell does not really
//              address this issue. Therefore, this function is required to
//              make sure that if My Pictures is not located directly under
//              My Documents, there is at least a shell link pointing to the
//              location of My Pictures. This function also makes sure that
//              the shell link is cached in case My Documents is on a network
//              share. This way, if the share were to go offline before the user
//              had a chance to access My Documents, then the shell link would
//              still be accessible.
//
//              Also, if My Pictures is a direct descendant of My Documents,
//              this function gets rid of the shell link to minimize user
//              confusion.
//
//  Arguments:  [in] pwszMyPicsLocName : localized display name of My Pictures.
//
//  Returns:    S_OK : if everything went smoothly.
//              an HRESULT derived from the error if there is one.
//
//  History:    5/2/1999  RahulTh  created
//              2/14/2001 RahulTh  Fixed shortcut creation problem in free
//                                 threaded COM by using SHCoCreateInstance
//                                 to short-circuit COM.
//
//  Notes:      This function shall not be required if the shell comes up with
//              an easy way to get to My Pictures even when it does not lie
//              directly under My Documents.
//
//---------------------------------------------------------------------------
HRESULT UpdateMyPicsShellLinks (HANDLE hUserToken, const WCHAR * pwszMyPicsLocName)
{
    WCHAR   szMyDocsPath [TARGETPATHLIMIT];
    WCHAR   szMyPicsPath [TARGETPATHLIMIT];
    WCHAR * pwszMyPicsLink = NULL;
    size_t  myPicsLinkSize = 0;
    int     MyDocsLen;
    int     MyPicsLen;
    HRESULT hr = S_OK;
    SHARESTATUS MyDocsCSCStatus;
    BOOL    fMyPicsFollows = TRUE;
    BOOL    bStatus;
    DWORD   Status = ERROR_SUCCESS;
    IShellLink * psl = NULL;
    IPersistFile * ppf = NULL;
    DWORD   dwPinCount;
    DWORD   dwHints;
    DWORD   dwCSCState;
    BOOL    bComInitialized = FALSE;

    //make sure that we have the user token.
    if (!hUserToken)
    {
        hr = E_FAIL;
        goto UpdateMyPicsLink_End;
    }

    //now get the path to My Documents
    hr = SHGetFolderPath(0, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY,
                         hUserToken, 0, szMyDocsPath);
    if (S_OK != hr)
        goto UpdateMyPicsLink_End;

    //now make sure that we can get enough memory to store the path to the
    //shell link.
    MyDocsLen = wcslen (szMyDocsPath);
    if (0 == MyDocsLen)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto UpdateMyPicsLink_End;
    }

    myPicsLinkSize = MyDocsLen + wcslen(pwszMyPicsLocName) + 6;
    __try {
        pwszMyPicsLink = (WCHAR *) alloca (sizeof(WCHAR) * myPicsLinkSize);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        pwszMyPicsLink = NULL;
        hr = E_OUTOFMEMORY;
        goto UpdateMyPicsLink_End;
    }

    //now make sure that the share on which My Docs exists is not offline
    MyDocsCSCStatus = GetCSCStatus (szMyDocsPath);
    if (ShareOffline == MyDocsCSCStatus)
    {
        hr = HRESULT_FROM_WIN32 (ERROR_CSCSHARE_OFFLINE);
        goto UpdateMyPicsLink_End;
    }

    //now construct the path to the shell link to MyPics in the MyDocs folder
    (void) StringCchCopy(pwszMyPicsLink, myPicsLinkSize, szMyDocsPath);
    if (L'\\' != szMyDocsPath[MyDocsLen - 1])
    {
        pwszMyPicsLink[MyDocsLen] = L'\\';
        pwszMyPicsLink[MyDocsLen+1] = L'\0';
    }
    (void) StringCchCat(pwszMyPicsLink, myPicsLinkSize, pwszMyPicsLocName);
    (void) StringCchCat(pwszMyPicsLink, myPicsLinkSize, L".lnk");

    //now obtain the path to My Pictures
    hr = SHGetFolderPath (0, CSIDL_MYPICTURES | CSIDL_FLAG_DONT_VERIFY,
                          hUserToken, 0, szMyPicsPath);
    if (S_OK != hr)
        goto UpdateMyPicsLink_End;

    //now find out if MyPics is a descendant of My Docs.
    MyPicsLen = wcslen (szMyPicsPath);
    if (0 == MyPicsLen)
    {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_PATHNAME);
        goto UpdateMyPicsLink_End;
    }

    if (MyPicsLen <= MyDocsLen ||
        0 != _wcsnicmp (szMyPicsPath, szMyDocsPath, MyDocsLen)
       )
    {
        fMyPicsFollows = FALSE;
    }

    //delete the shell link if MyPics is supposed to follow MyDocs.
    if (fMyPicsFollows)
    {
        Status = ERROR_SUCCESS;
        if (!DeleteFile (pwszMyPicsLink))
        {
            Status = GetLastError();
            if (ERROR_PATH_NOT_FOUND == Status ||
                ERROR_FILE_NOT_FOUND == Status)
                Status = ERROR_SUCCESS;
        }
        hr = HRESULT_FROM_WIN32 (Status);
        goto UpdateMyPicsLink_End;
    }

    //if we are here, we need to create/update the shell link.
    
    //
    // Note: We need to use SHCoCreateInstance. This is because the GP engine
    // is now freethreaded whereas the threading model for CLSID_ShellLink is
    // still Apartment. This means that if we use CoCreateInstance, it will
    // create the object on a COM thread in its own apartment. This means that
    // it will run as LocalSystem and not impersonated as the logged on user.
    // This is not what we want, especially when we are creating shortcuts on
    // a network share and we need to go across the wire as the logged on user
    // rather than the machine account in order to authenticate successfully.
    // To get around this problem, we use SHCoCreateInstance() which is an
    // internal shell API that completely short-circuits COM and calls into
    // shell32's DllGetClassObject directly thus creating the objects on the
    // same thread. This API is primarily for shell user *ONLY* to handle crufty
    // compat stuff so use this *VERY* *VERY *SPARINGLY*. If you want to do
    // anything remotely fancy with IShellLink, check with the shell team to
    // make sure that it is still okay to use the SHCoCreateInstance API.
    //
    hr = CoInitialize (NULL);
    if (SUCCEEDED(hr))
        bComInitialized = TRUE;
    
    if (SUCCEEDED (hr) || RPC_E_CHANGED_MODE == hr) // If we successfully initialized COM or if it was already initialized.
    {
        hr = SHCoCreateInstance(NULL,
                                &CLSID_ShellLink,
                                NULL,
                                IID_IShellLink,
                                (LPVOID*)&psl);
        if (FAILED(hr))
            psl = NULL; // For safety.
    }
    if (SUCCEEDED(hr))
        hr = psl->SetPath (szMyPicsPath);
    if (SUCCEEDED(hr))
        hr = psl->SetDescription (pwszMyPicsLocName);
    if (SUCCEEDED(hr))
        hr = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf);
    if (SUCCEEDED(hr))
    {
        hr = ppf->Save(pwszMyPicsLink, TRUE);
        ppf->Release();
    }
    
    // Release IShellLink if necessary.
    if (psl)
        psl->Release();
    
    // Uninitialize COM if necessary.
    if (bComInitialized)
    {
        CoUninitialize();
        bComInitialized = FALSE;
    }

    //also cache the shell link if MyDocs is redirected to a cacheable
    //network share
    if (SUCCEEDED(hr) && ShareOnline == MyDocsCSCStatus)
    {
        Status = ERROR_SUCCESS;
        bStatus = TRUE;
        bStatus = CSCQueryFileStatus (pwszMyPicsLink, &dwCSCState,
                                      &dwPinCount, &dwHints);
        if (bStatus)
        {
            if (0 == dwPinCount && (!(dwHints & FLAG_CSC_HINT_PIN_USER)))
            {
                if (bStatus = CSCPinFile(pwszMyPicsLink,
                                         FLAG_CSC_HINT_COMMAND_ALTER_PIN_COUNT,
                                         NULL, NULL, NULL)
                   )
                {
                    bStatus = CSCFillSparseFiles(pwszMyPicsLink, FALSE,
                                                 CSCCallbackProc, 0);
                }
            }
        }

        if (!bStatus)
        {
            Status = GetLastError();
        }

        hr = HRESULT_FROM_WIN32 (Status);
    }

UpdateMyPicsLink_End:
    if (FAILED(hr))
    {
        DebugMsg ((DM_VERBOSE, IDS_MYPICSLINK_FAILED, GetWin32ErrFromHResult(hr)));
    }
    else
    {
        DebugMsg ((DM_VERBOSE, IDS_MYPICSLINK_SUCCEEDED, szMyDocsPath));
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadLocalizedFolderNames
//
//  Synopsis:   loads the localized folder names into global objects of
//              CRedirectInfo class.
//
//  Arguments:  none.
//
//  Returns:    ERROR_SUCCESS if everything was successful.
//              an error code otherwise.
//
//  History:    5/6/1999  RahulTh  created
//
//  Notes:      the function bails out at the first failure. Also see notes
//              on CRedirectInfo::LoadLocalizedNames.
//
//---------------------------------------------------------------------------
DWORD LoadLocalizedFolderNames (void)
{
    DWORD   i;
    DWORD   Status;

    for (i = 0, Status = ERROR_SUCCESS; i < (DWORD)EndRedirectable; i++)
    {
        Status = gPolicyResultant[i].LoadLocalizedNames();
        if (ERROR_SUCCESS == Status)
            Status = gAddedPolicyResultant[i].LoadLocalizedNames();
        if (ERROR_SUCCESS == Status)
            Status = gDeletedPolicyResultant[i].LoadLocalizedNames();
        if (ERROR_SUCCESS != Status)
            break;
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteCachedConfigFiles
//
//  Synopsis:   deletes the locally cached copies of fdeploy.ini for GPOs
//              in a list of GPOs.
//
//  Arguments:  [in] pGPOList : the list of GPOs
//              [in] pFileDB : a filedb object containing info. about the
//                              location of the files etc.
//
//  Returns:    ERROR_SUCCESS if all the files were successfully deleted.
//              an error code otherwise.
//
//  History:    5/27/1999  RahulTh  created
//
//  Notes:      this function tries its best to delete as many files as
//              possible
//
//---------------------------------------------------------------------------
DWORD DeleteCachedConfigFiles (const PGROUP_POLICY_OBJECT pGPOList,
                               CFileDB * pFileDB)
{
    DWORD   Status = ERROR_SUCCESS;
    DWORD   StrStatus = ERROR_SUCCESS;
    WCHAR * pwszPath = NULL;
    size_t  pathSize = 0;
    WCHAR * pwszEnd = NULL;
    size_t  endSize = 0;
    int     len;
    PGROUP_POLICY_OBJECT pGPO;
    
    len = wcslen (pFileDB->GetLocalStoragePath());
    pathSize = len + MAX_PATH + 2;
    __try {
        pwszPath = (WCHAR *) alloca (sizeof (WCHAR) * pathSize);
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return ERROR_OUTOFMEMORY;
    }

    (void) StringCchCopy(pwszPath, pathSize, pFileDB->GetLocalStoragePath());
    (void) StringCchCat(pwszPath, pathSize, L"\\");
    pwszEnd = pwszPath + len + 1;
    endSize = pathSize - len - 1;

    for (pGPO = pGPOList; pGPO; pGPO = pGPO->pNext)
    {
        StrStatus = HRESULT_CODE(StringCchCopy(pwszEnd, endSize, pGPO->szGPOName));
        if ( StrStatus == ERROR_SUCCESS )
        {
            StrStatus = HRESULT_CODE(StringCchCat(pwszEnd, endSize, L".ini"));
            if ( StrStatus == ERROR_SUCCESS )
            {
                if (!DeleteFile (pwszPath) && ERROR_SUCCESS == Status)
                {
                    Status = GetLastError();
                    if (ERROR_PATH_NOT_FOUND == Status ||
                        ERROR_FILE_NOT_FOUND == Status)
                    {
                        Status = ERROR_SUCCESS;
                    }
                }
            }
        }

        // If we could not build a specific file name, we are still going to go on,
        //  but will cache this error code to be returned by the function at the end.
        if ( (StrStatus != ERROR_SUCCESS) && (Status == ERROR_SUCCESS) )
        {
            Status = StrStatus;
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   SimplifyPath
//
//  Synopsis:   given a path, this function tries to simplify it by
//              canonicalizing it and removing extra slashes by calling
//              _wfullpath
//
//  Arguments:  [in/out] pwszPath : the given path
//
//  Returns:    nothing
//
//  History:    5/27/1999  RahulTh  created
//
//  Notes:      the function tries its best to simplify the path. If it fails,
//              it simply returns the path supplied originally.
//
//---------------------------------------------------------------------------
void SimplifyPath (WCHAR * pwszPath)
{
    size_t  len;
    WCHAR * pwszAbsPath;

    if (!pwszPath || !pwszPath[0])
        return;

    len = wcslen (pwszPath);

    __try {
        pwszAbsPath = (WCHAR *) alloca (sizeof (WCHAR) * (len + 1));
    } __except(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
        _resetstkoflw();
        return;
    }

    if (NULL != _wfullpath (pwszAbsPath, pwszPath, len + 1) &&
        wcslen (pwszAbsPath) <= len)
    {
        (void) StringCchCopy(pwszPath, len + 1, pwszAbsPath);
    }

    return;
}

//+--------------------------------------------------------------------------
//
//  Function:   PrecreateUnicodeIniFile
//
//  Synopsis:   The WritePrivateProfile* functions do not write in unicode
//              unless the file already exists in unicode format. Therefore,
//              this function is used to precreate a unicode file so that
//              the WritePrivateProfile* functions can preserve the unicodeness.
//
//  Arguments:  [in] lpszFilePath : the full path of the ini file.
//
//  Returns:    ERROR_SUCCESS if successful.
//              an error code otherwise.
//
//  History:    7/9/1999  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD PrecreateUnicodeIniFile (LPCTSTR lpszFilePath)
{
    HANDLE      hFile;
    WIN32_FILE_ATTRIBUTE_DATA   fad;
    DWORD       Status = ERROR_ALREADY_EXISTS;
    DWORD       dwWritten;

    if (!GetFileAttributesEx (lpszFilePath, GetFileExInfoStandard, &fad))
    {
        if (ERROR_FILE_NOT_FOUND == (Status = GetLastError()))
        {
            hFile = CreateFile(lpszFilePath, GENERIC_WRITE, 0, NULL,
                               CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                BOOL bRet;

                //add the unicode mask to the beginning of the file so that
                //ReadPrivate* APIs do not accidentally think that this an ANSI
                //file.
                bRet = WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwWritten, NULL);
                //add a few unicode characters just to be safe.
                if (bRet) 
                {
                    bRet = WriteFile(hFile, L"     \r\n", 7 * sizeof(WCHAR),
                              &dwWritten, NULL);
                }

                if (bRet) 
                {
                    Status = ERROR_SUCCESS;
                }
                else
                {
                    Status = GetLastError();
                }

                CloseHandle(hFile);
            }
            else
            {
                Status = GetLastError();
            }
        }
    }

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsPathLocal
//
//  Synopsis:   this function determines if a given path is a local path
//              or a UNC path.
//
//  Arguments:  pwszPath : the full path of the file.
//
//  Returns:    FALSE : if it is a UNC path.
//              TRUE : otherwise
//
//  History:    7/30/1999  RahulTh  created
//
//  Notes:      this function basically returns TRUE unless the first
//              characters of the supplied path are '\'.
//
//---------------------------------------------------------------------------
BOOL IsPathLocal (LPCWSTR pwszPath)
{
    if (NULL == pwszPath || 2 > wcslen (pwszPath))
        return TRUE;        //assume local

    if (L'\\' == pwszPath[0] && L'\\' == pwszPath[1])
        return FALSE;

    return TRUE;    //local in all other cases.
}

//+--------------------------------------------------------------------------
//
//  Function:   ExpandPathSpecial
//
//  Synopsis:   expands a path using a given user name.
//
//  Arguments:  [in] pFileDB : pointer to the CFileDB object
//              [in] pwszPath : pointer to the path to be expanded.
//              [in] pwszUserName : the user name to be used in expansion
//              [out] wszExpandedPath : the expanded path.
//              [in, out] pDesiredBufferSize (optional) : on input, the size
//              of the wszExpandedPath buffer.  On output, the size needed
//              to expand the path to that buffer.  This may be NULL, in which
//              case the buffer is assumed to be TARGETPATHLIMIT size.
//
//  Returns:    ERROR_SUCCESS : if the expanded path was successfully obtained.
//              STATUS_BUFFER_TOO_SMALL : if the expanded path was too large
//                      to fit in the supplied buffer.
//              other win32 error codes based on what goes wrong.
//
//  History:    9/20/1999  RahulTh  created
//
//  Notes:      wszExpandedPath is assumed to be a buffer containing
//              TARGETPATHLIMIT characters, unlesss pDesiredBufferSize
//              is specified. It is the caller's responsibility
//              to allocate/free this memory. This function does not try to
//              validate the memory that wszExpandedPath points to.
//
//              This function is also not equipped to handle multiple
//              occurrences of the %username% substring in the last path.
//
//---------------------------------------------------------------------------
DWORD ExpandPathSpecial (
                         CFileDB * pFileDB,
                         const WCHAR * pwszPath,
                         const WCHAR * pwszUserName,
                         WCHAR * wszExpandedPath,
                         ULONG * pDesiredBufferSize
                         )
{
    DWORD           Status = ERROR_SUCCESS;
    UNICODE_STRING  Path;
    UNICODE_STRING  ExpandedPath;
    WCHAR           wszLastPath [TARGETPATHLIMIT];
    WCHAR *         wszTemp = NULL;
    WCHAR           wszSuffix [TARGETPATHLIMIT];

    if (TARGETPATHLIMIT <= wcslen(pwszPath))
        return STATUS_BUFFER_TOO_SMALL;

    wszSuffix[0] = L'\0';
    wszLastPath[0] = L'\0';
    
    (void) StringCchCopy(wszLastPath, TARGETPATHLIMIT, pwszPath);

    //convert it to lower case. useful while searching for other strings
    //within the string.
    _wcslwr (wszLastPath);

    //
    // If the caller does not specify a user name, just use environment
    // variable substitution to take care of %username% instead of
    // doing it ourselves
    //
    if ( pwszUserName )
    {
        //the username has changed since the last logon. must first substitute
        //the occurence of %username% if any with the supplied user name
        wszTemp = wcsstr (wszLastPath, L"%username%");
    }

    //if the %username% string is not present, nothing more needs to be
    //done. we can just go ahead and expand what we've got.
    if (NULL != wszTemp)
    {
        //the last path contains %username%
        //get the parts that appear before and after the %username% string
        //reuse wszLastPath for the prefix
        *wszTemp = L'\0';
        (void) StringCchCopy(wszSuffix, TARGETPATHLIMIT, wszTemp + 10); //go past %username%

        //make sure that we are not running out of space.
        if (TARGETPATHLIMIT <=
                    wcslen (wszLastPath) +
                    wcslen (pwszUserName) +
                    wcslen (wszSuffix))
        {
            return STATUS_BUFFER_TOO_SMALL;
        }
        (void) StringCchCat(wszLastPath, TARGETPATHLIMIT, pwszUserName);
        (void) StringCchCat(wszLastPath, TARGETPATHLIMIT, wszSuffix);
    }

    USHORT ExpandedBufferMax = (USHORT)(pDesiredBufferSize ? *pDesiredBufferSize : TARGETPATHLIMIT);

    //
    // In planning mode, we are only interested in %username% --
    // any other environment variables can remain unexpanded since
    // they may depend on local state to which we do not have access
    // in planning mode.
    //
    if ( pFileDB->GetRsopContext()->IsPlanningModeEnabled() )
    {
        if ( ERROR_SUCCESS == Status )
        {
            Status = HRESULT_CODE(StringCchCopy( wszExpandedPath, ExpandedBufferMax, wszLastPath ));
            if ( (Status != ERROR_SUCCESS) && (pDesiredBufferSize != NULL) )
            {
                *pDesiredBufferSize = wcslen(wszLastPath) + 1;
            }
        }

        return Status;
    }


    //now expand other variables in the path
    Path.Length = (wcslen (wszLastPath) + 1) * sizeof (WCHAR);
    Path.MaximumLength = sizeof (wszLastPath);
    Path.Buffer = wszLastPath;

    ExpandedPath.Length = 0;
    ExpandedPath.MaximumLength = ExpandedBufferMax * sizeof (WCHAR);
    ExpandedPath.Buffer = wszExpandedPath;

    Status = RtlExpandEnvironmentStrings_U (
                            pFileDB->GetEnvBlock(),
                            &Path,
                            &ExpandedPath,
                            pDesiredBufferSize
                            );

    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   ExpandHomeDir
//
//  Synopsis:   Expands the HOMEDIR component in the path.
//
//  Arguments:  [in] rID : the id of the folder
//              [in] pwszPath : the unexpanded path
//              [in] bAllowMyPics : allow expansion of homedir for MyPics
//              [out] ppwszExpandedPath : the expanded result
//              [in, optional] pwszHomedir : the value of homedir to be used in substitution
//
//  Returns:    ERROR_SUCCESS : if successful.
//              a Win32 error code otherwise.
//
//  History:    3/10/2000  RahulTh  created
//
//  Notes:      This function has the following additional restrictions:
//              (a) It is a no-op for all folders except MyDocs and MyPics.
//              (b) It only acts on paths that begin with
//                  %HOMESHARE%%HOMEPATH%
//
//              Also, if the function does not return ERROR_SUCCESS, then
//              *ppwszExpandedPath can be null.
//
//              if the caller does not supply the homedir value for
//              substitution, the value is obtained from the user object.
//
//---------------------------------------------------------------------------
DWORD   ExpandHomeDir (IN REDIRECTABLE  rID,
                       IN const WCHAR * pwszPath,
                       BOOL             bAllowMyPics,
                       OUT WCHAR **     ppwszExpandedPath,
                       IN const WCHAR * pwszHomedir // = NULL
                       )
{
    DWORD         Status = ERROR_SUCCESS;
    int           len;
    const WCHAR * wszSuffix;
    int           expandedLen;
    int           lenHomedir;

    // First free the supplied buffer if necessary
    if (*ppwszExpandedPath)
    {
        delete [] *ppwszExpandedPath;
        *ppwszExpandedPath = NULL;
    }

    if (! pwszPath || L'\0' == *pwszPath)
    {
        Status = ERROR_BAD_PATHNAME;
        goto ExpandHomeDir_End;
    }

    // Proceed only if the HOMEDIR component is in the right place.
    if (! IsHomedirPath (rID, pwszPath, bAllowMyPics))
    {
        if (! HasHomeVariables (pwszPath))
        {
            goto ExpandHomeDir_ReturnSame;
        }
        else
        {
            // This is not a homedir path, so it is not supposed to have any home variables
            Status = ERROR_BAD_PATHNAME;
            goto ExpandHomeDir_End;
        }
    }

    //
    // If we are here, then we need to substitute the HOMEDIR part
    // with the actual home directory. We use the current homedir value
    // only if the caller hasn't already supplied us with one.
    //
    len = lstrlen (HOMEDIR_STR);
    if (! pwszHomedir)
        pwszHomedir = gUserInfo.GetHomeDir(Status);
    //
    // At this point, pwszHomeDir can be NULL even if Status is ERROR_SUCCESS
    // This happens if the user object does not have a homedir set on it
    // So we must fail even in that case.
    //
    if (! pwszHomedir || ERROR_SUCCESS != Status)
    {
        // Do not clobber status set by GetHomeDir if it had failed.
        Status = (ERROR_SUCCESS == Status) ? ERROR_BAD_PATHNAME : Status;
        goto ExpandHomeDir_End;
    }

    //
    // Now we have everything we need to proceed.
    // First allocate the required buffer.
    //
    lenHomedir = lstrlen (pwszHomedir);
    expandedLen = lenHomedir + lstrlen (&pwszPath[len]);
    *ppwszExpandedPath = new WCHAR [expandedLen + 1];
    if (! *ppwszExpandedPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto ExpandHomeDir_End;
    }
    // Generate the new path.
    (void) StringCchCopy(*ppwszExpandedPath, expandedLen + 1, pwszHomedir);

    // Append the suffix
    wszSuffix = &pwszPath[len];
    // Eliminate duplicate '\' characters
    if (L'\\' == (*ppwszExpandedPath)[lenHomedir - 1] && L'\\' == pwszPath[len])
        wszSuffix++;
    (void) StringCchCat(*ppwszExpandedPath, expandedLen + 1, wszSuffix);

    DebugMsg ((DM_VERBOSE, IDS_HOMEDIR_EXPANDED, pwszPath, *ppwszExpandedPath));

    goto ExpandHomeDir_End;

    //
    // If we are here, then, there was no error, but no substitution was
    // necessary either. So we just return the same path.
    //

ExpandHomeDir_ReturnSame:
    len = lstrlen (pwszPath);
    *ppwszExpandedPath = new WCHAR [len + 1];
    if (! *ppwszExpandedPath)
    {
        Status = ERROR_OUTOFMEMORY;
        goto ExpandHomeDir_End;
    }

    // Copy the path.
    (void) StringCchCopy(*ppwszExpandedPath, len + 1, pwszPath);
    Status = ERROR_SUCCESS;

ExpandHomeDir_End:
    if (ERROR_SUCCESS != Status)
    {
        DebugMsg ((DM_VERBOSE, IDS_HOMEDIR_EXPAND_FAIL, pwszPath, Status));
    }
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   ExpandHomeDirPolicyPath
//
//  Synopsis:   Expands the HOMEDIR component in the path as specified in the
//              ini file (ones that begin with \\%HOMESHARE%%HOMEPATH%)
//
//  Arguments:  [in] rID : the id of the folder
//              [in] pwszPath : the unexpanded path
//              [in] bAllowMyPics : allow expansion of homedir for MyPics
//              [out] ppwszExpandedPath : the expanded result
//              [in, optional] pwszHomedir : the value of homedir to be used in substitution
//
//  Returns:    ERROR_SUCCESS : if successful.
//              a Win32 error code otherwise.
//
//  History:    3/10/2000  RahulTh  created
//
//  Notes:      This function has the following additional restrictions:
//              (a) It is a no-op for all folders except MyDocs and MyPics.
//              (b) It only acts on paths that begin with
//                  \\%HOMESHARE%%HOMEPATH% or %HOMESHARE%%HOMEPATH%
//
//              Also, if the function does not return ERROR_SUCCESS, then
//              *ppwszExpandedPath can be null.
//
//              if the caller does not supply the homedir value for
//              substitution, the value is obtained from the user object.
//
//---------------------------------------------------------------------------
DWORD   ExpandHomeDirPolicyPath (IN REDIRECTABLE  rID,
                                 IN const WCHAR * pwszPath,
                                 IN BOOL          bAllowMyPics,
                                 OUT WCHAR **     ppwszExpandedPath,
                                 IN const WCHAR * pwszHomedir // = NULL
                                 )
{
    if (IsHomedirPolicyPath(rID, pwszPath, bAllowMyPics))
    {
        return ExpandHomeDir (rID,
                              &pwszPath[2],
                              bAllowMyPics,
                              ppwszExpandedPath,
                              pwszHomedir
                              );
    }
    else
    {
        return ExpandHomeDir (rID,
                              pwszPath,
                              bAllowMyPics,
                              ppwszExpandedPath,
                              pwszHomedir
                              );
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   IsHomedirPath
//
//  Synopsis:   determines if a given redirection destination is in the homedir.
//              This means all paths that begin with %HOMESHARE%%HOMEPATH
//
//  Arguments:  [in] rID : The folder identifier.
//              [in] pwszPath : The path.
//              [in] bAllowMyPics : allow homedir paths for MyPics folder
//
//  Returns:    TRUE : if it is a homedir path
//              FALSE: otherwise.
//
//  History:    3/12/2000  RahulTh  created
//
//  Notes:      This function returns FALSE for all folders other than
//              MyDocs because that is the only folder for which redirection
//              to the home directory is permitted.
//
//              See additional notes about bAllowMyPics in the comments above
//              IsHomedirPolicyPath
//
//---------------------------------------------------------------------------
BOOL IsHomedirPath (IN REDIRECTABLE rID, IN LPCWSTR pwszPath, BOOL bAllowMyPics)
{
    int     len;

    if ((MyDocs != rID && (MyPics != rID || !bAllowMyPics)) ||
        ! pwszPath ||
        L'\0' == *pwszPath)
    {
        return FALSE;
    }

    //
    // Make sure that the length of the path is longer than that of
    // %HOMESHARE%%HOMEPATH. If not, there is no way that this can be
    // a homedir path
    //
    len = lstrlen (HOMEDIR_STR);
    if (lstrlen (pwszPath) < len)
        return FALSE;

    // If we are here, we need to compare the two strings
    if (0 == _wcsnicmp (HOMEDIR_STR, pwszPath, len) &&
        (L'\0' == pwszPath[len] || L'\\' == pwszPath[len]) &&
        NULL == wcschr (&pwszPath[len], L'%')   // no other variable names allowed
        )
    {
        // If all the conditions above are met, then this is indeed a homedir path
        return TRUE;
    }

    // If we are here, this cannot be a homedir path.
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   IsHomedirPolicyPath
//
//  Synopsis:   determines if a given redirection destination is in the homedir.
//              This means all paths that begin with \\%HOMESHARE%%HOMEPATH
//
//  Arguments:  [in] rID : The folder identifier.
//              [in] pwszPath : The path.
//              [in] bAllowMyPics : Allow MyPics to have a homedir path
//
//  Returns:    TRUE : if it is a homedir path as specified in the ini file
//              FALSE: otherwise.
//
//  History:    3/12/2000  RahulTh  created
//
//  Notes:      This function returns FALSE for all folders other than
//              MyDocs & MyPics because that is the only folder for which
//              redirection to the home directory is permitted.
//
//              Note: redirection to HOMEDIR is permitted for MyPics only
//              if it is set to follow MyDocs. Not otherwise. That is why
//              we need the third parameter.
//
//---------------------------------------------------------------------------
BOOL IsHomedirPolicyPath (IN REDIRECTABLE   rID,
                          IN LPCWSTR        pwszPath,
                          IN BOOL           bAllowMyPics)
{
    //
    // It is a homedir path as specified by the policy if it begins
    // with \\%HOMESHARE%%HOMEPATH%
    //
    if ((MyDocs == rID || (MyPics == rID && bAllowMyPics)) &&
        pwszPath &&
        lstrlen (pwszPath) > 2 &&
        L'\\' == pwszPath[0] &&
        L'\\' == pwszPath[1] )
    {
        return IsHomedirPath (rID, &pwszPath[2], bAllowMyPics);
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   HasHomeVariables
//
//  Synopsis:   finds if a given string has any of the home variables
//              i.e. HOMESHARE, HOMEPATH or HOMEDRIVE
//
//  Arguments:  [in] pwszPath : the path string
//
//  Returns:    TRUE: if the path has home variables.
//              FALSE: otherwise
//
//  History:    3/22/2000  RahulTh  created
//
//  Notes:      This function is required because we do not wish to allow
//              these variables in the path except in highly restricted
//              conditions, viz. My Docs redirection that begins with
//              \\%HOMESHARE%%HOMEPATH%
//
//              Therefore, we need to explicitly check for the existence of
//              variables in paths that don't meet these requirements.
//
//---------------------------------------------------------------------------
BOOL HasHomeVariables (IN LPCWSTR pwszPath)
{
    WCHAR * pszTmp;

    pszTmp = wcschr (pwszPath, L'%');

    while (pszTmp)
    {
        if (0 == _wcsnicmp (HOMESHARE_VARIABLE, pszTmp, HOMESHARE_VARLEN) ||
            0 == _wcsnicmp (HOMEDRIVE_VARIABLE, pszTmp, HOMEDRIVE_VARLEN) ||
            0 == _wcsnicmp (HOMEPATH_VARIABLE,  pszTmp, HOMEPATH_VARLEN))
        {
            return TRUE;
        }

        pszTmp = wcschr (pszTmp + 1, L'%');
    }

    // If we are here, we did not find any home variables in the path.
    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetWin32ErrFromHResult
//
//  Synopsis:   given an HResult, this function tries to extract the
//              corresponding Win 32 error.
//
//  Arguments:  [in] hr : the hresult value
//
//  Returns:    the Win 32 Error code.
//
//  History:    3/13/2000  RahulTh  created
//
//  Notes:      if hr is not S_OK, the return value will be something other
//              than ERROR_SUCCESS;
//
//---------------------------------------------------------------------------
DWORD GetWin32ErrFromHResult (IN HRESULT hr)
{
    DWORD   Status = ERROR_SUCCESS;

    if (S_OK != hr)
    {
        if (FACILITY_WIN32 == HRESULT_FACILITY(hr))
        {
            Status = HRESULT_CODE(hr);
        }
        else
        {
            Status = GetLastError();
            if (ERROR_SUCCESS == Status)
            {
                //an error had occurred but nobody called SetLastError
                //should not be mistaken as a success.
                Status = (DWORD) hr;
            }
        }
    }

    return Status;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetExpandedPath
//
//  Synopsis:   given a redirected path that may contain environment variables,
//              evaluates the variables to produce a fully realized path
//
//  Arguments:  [in]  pFileDB : object containing general context information
//              [in]  wszSourcePath : the unexpanded path
//              [in]  rID : The folder identifier.
//              [in]  bAllowMyPics : allow homedir paths for MyPics folder
//              [out] ppwszExpandedPath -- on output, the address of the
//                    expanded path, must be freed by the caller
//
//  Returns:    the Win 32 Error code.
//
//  History:    5/30/2000  AdamEd  created
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD
GetExpandedPath(
    IN  CFileDB*      pFileDB,
    IN  WCHAR*        wszSourcePath,
    IN  int           rID,
    IN  BOOL          bAllowMyPics,
    OUT WCHAR**       ppwszExpandedPath)
{
    WCHAR* wszDestination;
    WCHAR* wszHomeDir;
    DWORD  Status;

    const WCHAR* wszUserName;

    *ppwszExpandedPath = NULL;


    wszDestination = NULL;
    wszHomeDir = NULL;

    wszUserName = NULL;

    //
    // In diagnostic mode, we will end up expanding %username% and
    // the %homedir% and %homepath% vars, as well as any other variables that
    // are defined, but in planning mode we will only
    // handle the first 3, and we only do so if a specific user account
    //
    if ( pFileDB->GetRsopContext()->IsPlanningModeEnabled() )
    {
        //
        // In planning mode, the thread context is not that
        // of the desired user, so we must override it
        //
        wszUserName = gUserInfo.GetUserName( Status );

        if ( ERROR_SUCCESS != Status )
        {
            goto GetExpandedPath_Exit;
        }

        if ( ! wszUserName )
        {
            //
            // In planning mode, GetUserName can return success
            // but return a NULL username -- this means that
            // the planning mode target contained only a SOM, not a user
            // name, so we can accept the blank user name and cease
            // further expansion attempts -- we cannot expand %username%
            // or the %home%* variables if we do not have a user account. Thus,
            // we use the unexpanded path.
            //
            wszDestination = StringDuplicate( wszSourcePath );

            if ( ! wszDestination )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }

            goto GetExpandedPath_Exit;
        }
    }

    Status = ExpandHomeDirPolicyPath(
        (REDIRECTABLE) rID,
        wszSourcePath,
        bAllowMyPics,
        &wszHomeDir);

    if ( ERROR_SUCCESS != Status )
    {
        //
        // In planning mode, we may not have access to read homedir,
        // especially in cases where the user object resides in a different
        // domain than the one with the dc running this code --
        // in that case, we will just not expand it
        //
        if ( pFileDB->GetRsopContext()->IsPlanningModeEnabled() )
        {
            Status = ERROR_SUCCESS;

            //
            // Allocate an unexpanded version of the string with
            // homedir in it
            //
            wszHomeDir = StringDuplicate( wszSourcePath );

            if ( ! wszHomeDir )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        if ( ERROR_SUCCESS != Status )
        {
            goto GetExpandedPath_Exit;
        }
    }

    USHORT         cchDestination;
    ULONG          ReturnedLength;
    NTSTATUS       NtStatus;

    cchDestination = TARGETPATHLIMIT;

    wszDestination = new WCHAR [ cchDestination + 1 ];

    if ( ! wszDestination )
    {
        goto GetExpandedPath_Exit;
    }

    ReturnedLength = cchDestination * sizeof( *wszDestination );

    NtStatus = ExpandPathSpecial(
        pFileDB,
        wszHomeDir,
        wszUserName,
        wszDestination,
        &ReturnedLength);

    if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
    {
        delete [] wszDestination;

        wszDestination = new WCHAR [ ReturnedLength / sizeof( *wszDestination ) + 1 ];

        if ( ! wszDestination )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto GetExpandedPath_Exit;
        }

        NtStatus = ExpandPathSpecial(
            pFileDB,
            wszHomeDir,
            wszUserName,
            wszDestination,
            &ReturnedLength);
    }

    if ( STATUS_SUCCESS != NtStatus )
    {
        Status = RtlNtStatusToDosError( NtStatus );
    }

GetExpandedPath_Exit:

    delete [] wszHomeDir;

    if ( ERROR_SUCCESS != Status )
    {
        delete [] wszDestination;
    }
    else
    {
        *ppwszExpandedPath = wszDestination;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpresult\gpresult.c ===
//*************************************************************
//  File name: GPRESULT.C
//
//  Description:  Command line tool to dump the resultant set
//                of policy.
//
//  Note:         This is just a simple command line tool,
//                SitaramR and team are writing the real
//                resultant set of policy tool.
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//*************************************************************

#include "gpresult.h"
#include <common.ver>

#define GROUPPOLICY_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy")
#define GROUPMEMBERSHIP_KEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership")
#define GPEXT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")
#define SCRIPTS_KEYNAME   TEXT("Software\\Policies\\Microsoft\\Windows\\System\\Scripts")

#define PROFILE_LIST_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s")

BOOL ParseCommandLine (int argc, char *argv[]);
void DumpGeneralInfo (void);
DWORD DumpPolicyOverview (BOOL bMachine);
void StringToGuid( TCHAR * szValue, GUID * pGuid );
void DumpProfileInfo (void);
void DumpSecurityGroups(BOOL bMachine);
void DumpSecurityPrivileges(void);
void DumpGPOInfo (PGROUP_POLICY_OBJECT pGPO);
void DumpFolderRedir (void);
void DumpIPSec (void);
void DumpDiskQuota (void);
void DumpScripts (PGROUP_POLICY_OBJECT pGPO, LPTSTR lpScriptType, LPTSTR lpTitle);
void DumpAppMgmt (BOOL bMachine);

GUID guidRegistry = REGISTRY_EXTENSION_GUID;

BOOL g_bVerbose = FALSE;
BOOL g_bSuperVerbose = FALSE;
BOOL g_bUser = TRUE;
BOOL g_bMachine = TRUE;
BOOL g_bDebuggerOutput = FALSE;
DWORD g_bNewFunc = FALSE;


//*************************************************************
//
//  main()
//
//  Purpose:    main entry point
//
//  Parameters: argc and argv
//
//
//  Return:     int error code
//
//*************************************************************

int __cdecl main( int argc, char *argv[])
{
    SYSTEMTIME systime;
    TCHAR szDate[100];
    TCHAR szTime[100];
    HANDLE hUser, hMachine;
    BOOL bResult;


    //
    // Parse the command line args
    //

    bResult = ParseCommandLine (argc, argv);


    //
    // Print the legal banner
    //

    PrintString(IDS_LEGAL1);
    PrintString(IDS_LEGAL2);
    PrintString(IDS_2NEWLINE);


    if (!bResult)
    {
        PrintString(IDS_USAGE1);
        PrintString(IDS_USAGE2);
        PrintString(IDS_USAGE3);
        PrintString(IDS_USAGE4);
        PrintString(IDS_USAGE5);
        PrintString(IDS_USAGE6);

        return 0;
    }


    //
    // Claim the policy critical sections while this tool is running so that
    // the data can't change while the report is being generated.
    //

    hUser = EnterCriticalPolicySection(FALSE);
    hMachine = EnterCriticalPolicySection(TRUE);


    //
    // Print the date and time this report is generated
    //

    GetLocalTime (&systime);

    GetDateFormat (LOCALE_USER_DEFAULT, DATE_LONGDATE, &systime,
                   NULL, szDate, ARRAYSIZE(szDate));

    GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                   NULL, szTime, ARRAYSIZE(szTime));

    PrintString(IDS_CREATEINFO, szDate, szTime);


    //
    // Print the general machine info
    //

    DumpGeneralInfo ();


    //
    // Dump out user policy results if appropriate
    //

    if (g_bUser)
    {
        DumpPolicyOverview (FALSE);
        PrintString(IDS_2NEWLINE);
    }


    //
    // Dump out computer policy results if appropriate
    //

    if (g_bMachine)
    {
        DumpPolicyOverview (TRUE);
    }


    //
    // Release the policy critical sections
    //

    LeaveCriticalPolicySection(hUser);
    LeaveCriticalPolicySection(hMachine);

    return 0;
}

//*************************************************************
//
//  DumpGeneralInfo()
//
//  Purpose:    Dumps out the general info about the computer
//
//  Parameters: none
//
//  Return:     void
//
//*************************************************************

void DumpGeneralInfo (void)
{
    OSVERSIONINFOEX   osiv;
    OSVERSIONINFO     osver;
    DWORDLONG   dwlConditionMask;
    BOOL bTSAppServer = FALSE;
    BOOL bTSRemoteAdmin = FALSE;
    BOOL bWks = FALSE;
    HKEY hkey;
    LONG lResult;
    TCHAR szProductType[50];
    DWORD dwType, dwSize;

    PrintString(IDS_OSINFO);

    //
    // Query the registry for the product type.
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                            0,
                            KEY_READ,
                            &hkey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof(szProductType);
        szProductType[0] = TEXT('\0');

        lResult = RegQueryValueEx (hkey,
                                   TEXT("ProductType"),
                                   NULL,
                                   &dwType,
                                   (LPBYTE) szProductType,
                                   &dwSize);

        RegCloseKey (hkey);

        if (lResult == ERROR_SUCCESS)
        {
            if (!lstrcmpi (szProductType, TEXT("WinNT")))
            {
                bWks = TRUE;
                PrintString(IDS_OS_PRO);

            } else if (!lstrcmpi (szProductType, TEXT("ServerNT"))) {
                PrintString(IDS_OS_SRV);

            } else if (!lstrcmpi (szProductType, TEXT("LanmanNT"))) {
                PrintString(IDS_OS_DC);
            }
        }
    }


    //
    // Build number
    //

    ZeroMemory( &osver, sizeof( OSVERSIONINFO ) );
    osver.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    if (GetVersionEx(&osver))
    {
        if (osver.szCSDVersion[0] != TEXT('\0'))
            PrintString(IDS_OS_BUILDNUMBER1, osver.dwMajorVersion,
                     osver.dwMinorVersion, osver.dwBuildNumber, osver.szCSDVersion);
        else
            PrintString(IDS_OS_BUILDNUMBER2, osver.dwMajorVersion,
                     osver.dwMinorVersion, osver.dwBuildNumber);
    }


    //
    // Check for a TS App Server
    //

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osiv.wSuiteMask = VER_SUITE_TERMINAL;

    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    bTSAppServer = VerifyVersionInfo(&osiv, VER_SUITENAME, dwlConditionMask);


    //
    // Check for TS running in remote admin mode
    //

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );
    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    osiv.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    bTSRemoteAdmin = VerifyVersionInfo(&osiv, VER_SUITENAME, dwlConditionMask);


    if (!bWks)
    {
        if (bTSAppServer)
        {
            if (bTSRemoteAdmin)
            {
                PrintString(IDS_TS_REMOTEADMIN);
            }
            else
            {
                PrintString(IDS_TS_APPSERVER);
            }
        }
        else
        {
            PrintString(IDS_TS_NONE);
        }
    }
    else
    {
        PrintString(IDS_TS_NOTSUPPORTED);
    }

}

//*************************************************************
//
//  ParseCommandLine()
//
//  Purpose:    Parses the command line args
//
//  Parameters: argc and argv
//
//  Return:     TRUE if processing should continue
//              FALSE if this tool should exit immediately
//
//*************************************************************

BOOL ParseCommandLine (int argc, char *argv[])
{
    int iIndex = 1;
    LPSTR lpArg;

    while (iIndex < argc)
    {
        lpArg = argv[iIndex] + 1;


        //
        // Enable verbose mode
        //

        if (!lstrcmpiA("V", lpArg))
        {
            g_bVerbose = TRUE;
        }
        else if (!lstrcmpiA("v", lpArg))
        {
            g_bVerbose = TRUE;
        }

        //
        // Enable super verbose mode
        //

        else if (!lstrcmpiA("S", lpArg))
        {
            g_bVerbose = TRUE;
            g_bSuperVerbose = TRUE;
        }
        else if (!lstrcmpiA("s", lpArg))
        {
            g_bVerbose = TRUE;
            g_bSuperVerbose = TRUE;
        }

        //
        // Show computer policy only
        //

        else if (!lstrcmpiA("C", lpArg))
        {
            g_bMachine = TRUE;
            g_bUser = FALSE;
        }
        else if (!lstrcmpiA("c", lpArg))
        {
            g_bMachine = TRUE;
            g_bUser = FALSE;
        }

        //
        // Show user policy only
        //

        else if (!lstrcmpiA("U", lpArg))
        {
            g_bMachine = FALSE;
            g_bUser = TRUE;
        }
        else if (!lstrcmpiA("u", lpArg))
        {
            g_bMachine = FALSE;
            g_bUser = TRUE;
        }

        //
        // Output to the debugger instead of the screen
        //

        else if (!lstrcmpiA("D", lpArg))
        {
            g_bDebuggerOutput = TRUE;
        }
        else if (!lstrcmpiA("d", lpArg))
        {
            g_bDebuggerOutput = TRUE;
        }

        //
        // Show the usage screen
        //

        else if (!lstrcmpiA("?", lpArg))
        {
            return FALSE;
        }

        iIndex++;
    }

    return TRUE;
}

//*************************************************************
//
//  ExtractDomainNameFromSamName()
//
//  Purpose:    Pulls the domain name out of a SAM style
//              name.  eg:  NTDev\ericflo
//
//  Parameters: lpSamName - source
//              lpDomainName - destination
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ExtractDomainNameFromSamName (LPTSTR lpSamName, LPTSTR lpDomainName)
{
    LPTSTR lpSrc, lpDest;

    //
    // Look for the \ between the domain and username and copy
    // the contents to the domain name buffer
    //

    lpSrc = lpSamName;
    lpDest = lpDomainName;

    while (*lpSrc && ((*lpSrc) != TEXT('\\')))
    {
        *lpDest = *lpSrc;
        lpSrc++;
        lpDest++;
    }

    if (*lpSrc != TEXT('\\'))
    {
        return FALSE;
    }

    *lpDest = TEXT('\0');

    return TRUE;
}

//*************************************************************
//
//  GetDomainType()
//
//  Purpose:     Determines if the domain is NT4 or W2k by checking
//               if DS support is available.
//
//  Parameters:  lpDomainName - domain name
//               pbW2K - TRUE if w2k, FALSE if something else
//               pbLocalAccount - TRUE if local account
//
//  Return:      TRUE if successful
//               FALSE if an error occurs
//
//*************************************************************

BOOL GetDomainType (LPTSTR lpDomainName, BOOL * pbW2K, BOOL *pbLocalAccount)
{
    PDOMAIN_CONTROLLER_INFO pDCI;
    DWORD dwResult, dwSize;
    TCHAR szComputerName[MAX_PATH];


    //
    // Check this domain for a DC
    //

    dwResult = DsGetDcName (NULL, lpDomainName, NULL, NULL,
                            DS_DIRECTORY_SERVICE_PREFERRED, &pDCI);

    if (dwResult == ERROR_SUCCESS)
    {

        //
        // Found a DC, does it have a DS ?
        //

        if (pDCI->Flags & DS_DS_FLAG) {
            *pbW2K = TRUE;
        }

        NetApiBufferFree(pDCI);

        return TRUE;
    }


    //
    // Check if the domain name is also the computer name (eg: local account)
    //

    dwSize = ARRAYSIZE(szComputerName);
    if (GetComputerName (szComputerName, &dwSize))
    {
        if (!lstrcmpi(szComputerName, lpDomainName))
        {
            *pbLocalAccount = TRUE;
            return TRUE;
        }
    }

    return FALSE;
}

//*************************************************************
//
//  DumpPolicyOverview()
//
//  Purpose:    Main function that dumps the summary information
//              about each CSE and it's GPOs
//
//  Parameters: bMachine - computer or user policy
//
//  Return:     Win32 error code
//
//*************************************************************

DWORD DumpPolicyOverview (BOOL bMachine)
{
    HKEY hKey, hSubKey;
    DWORD dwType, dwSize, dwIndex, dwNameSize;
    LONG lResult;
    FILETIME ftWrite, ftLocal;
    SYSTEMTIME systime;
    TCHAR szTime[30];
    TCHAR szDate[30];
    TCHAR szName[50];
    TCHAR szBuffer[MAX_PATH] = {0};
    TCHAR szDomainName[150] = {0};
    ULONG ulSize;
    GUID guid;
    PGROUP_POLICY_OBJECT pGPO, pGPOTemp;
    BOOL bW2KDomain = FALSE;
    BOOL bLocalAccount = FALSE;
    LPTSTR lpSiteName = NULL;


    //
    // Print a banner
    //

    if (bMachine)
    {
        ulSize = MAX_PATH;
        GetComputerObjectName (NameSamCompatible, szBuffer, &ulSize);
        ExtractDomainNameFromSamName (szBuffer, szDomainName);

        GetDomainType (szDomainName, &bW2KDomain, &bLocalAccount);

        if (bW2KDomain)
        {
            ulSize = ARRAYSIZE(szBuffer);
            szBuffer[0] = TEXT('\0');
            GetComputerObjectName (NameFullyQualifiedDN, szBuffer, &ulSize);
        }


        PrintString(IDS_NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
        PrintString(IDS_COMPRESULTS1);
        PrintString(IDS_COMPRESULTS2, szBuffer);
        PrintString(IDS_DOMAINNAME, szDomainName);

        if (bW2KDomain)
        {
            PrintString(IDS_W2KDOMAIN);

            DsGetSiteName(NULL, &lpSiteName);
            PrintString(IDS_SITENAME, lpSiteName);
            NetApiBufferFree(lpSiteName);
        }
        else if (bLocalAccount)
        {
            PrintString(IDS_LOCALCOMP);
        }
        else
        {
            PrintString(IDS_NT4DOMAIN);
        }

        //
        // Dump out the computer's security group information
        //

        PrintString(IDS_NEWLINE);
        DumpSecurityGroups(bMachine);

        PrintString(IDS_NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
    }
    else
    {

        ulSize = MAX_PATH;
        GetUserNameEx (NameSamCompatible, szBuffer, &ulSize);
        ExtractDomainNameFromSamName (szBuffer, szDomainName);

        GetDomainType (szDomainName, &bW2KDomain, &bLocalAccount);

        if (bW2KDomain)
        {
            ulSize = ARRAYSIZE(szBuffer);
            szBuffer[0] = TEXT('\0');
            GetUserNameEx (NameFullyQualifiedDN, szBuffer, &ulSize);
        }


        PrintString(IDS_NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
        PrintString(IDS_USERRESULTS1);
        PrintString(IDS_USERRESULTS2, szBuffer);
        PrintString(IDS_DOMAINNAME, szDomainName);

        if (bW2KDomain)
        {
            PrintString(IDS_W2KDOMAIN);

            DsGetSiteName(NULL, &lpSiteName);
            PrintString(IDS_SITENAME, lpSiteName);
            NetApiBufferFree(lpSiteName);
        }
        else if (bLocalAccount)
        {
            PrintString(IDS_LOCALUSER);
        }
        else
        {
            PrintString(IDS_NT4DOMAIN);
        }


        //
        // Dump out the user's profile and security group information
        //

        PrintString(IDS_NEWLINE);
        DumpProfileInfo();
        DumpSecurityGroups(bMachine);

        if (g_bVerbose)
        {
            DumpSecurityPrivileges();
        }

        PrintString(IDS_2NEWLINE);
        PrintString(IDS_LINE);
        PrintString(IDS_NEWLINE);
    }


    //
    // Find out the last time Group Policy was applied
    //

    lResult = RegOpenKeyEx (bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, GROUPPOLICY_KEY,
                            0, KEY_READ, &hKey);


    if (lResult != ERROR_SUCCESS)
    {
        PrintString(IDS_OPENHISTORYFAILED, lResult);
        return lResult;
    }

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               &ftWrite);

    if (lResult == ERROR_SUCCESS)
    {
        FileTimeToLocalFileTime (&ftWrite, &ftLocal);
        FileTimeToSystemTime (&ftLocal, &systime);
        GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime, NULL, szTime, ARRAYSIZE(szTime));
        GetDateFormat (LOCALE_USER_DEFAULT, DATE_LONGDATE, &systime, NULL, szDate, ARRAYSIZE(szDate));
        PrintString(IDS_LASTTIME, szDate, szTime);
    }
    else
    {
        PrintString(IDS_QUERYKEYINFOFAILED, lResult);
    }

    RegCloseKey (hKey);


    //
    // Find out which DC Group Policy was applied from last time
    //

    if (RegOpenKeyEx (bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = MAX_PATH * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');
        if (RegQueryValueEx (hKey, TEXT("DCName"), NULL, &dwType,
                            (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_DCNAME, (szBuffer+2));
            g_bNewFunc = TRUE;
        }

        RegCloseKey (hKey);
    }


    //
    // Dump out registry policy information
    //

    lResult = GetAppliedGPOList (bMachine ? GPO_LIST_FLAG_MACHINE : 0, NULL, NULL,
                                 &guidRegistry, &pGPO);

    if (lResult == ERROR_SUCCESS)
    {
        if (pGPO)
        {
            PrintString(IDS_LINE2);

            if (bMachine)
            {
                PrintString(IDS_COMPREGPOLICY);
            }
            else
            {
                PrintString(IDS_USERREGPOLICY);
            }


            pGPOTemp = pGPO;

            while (pGPOTemp)
            {
                PrintString(IDS_GPONAME, pGPOTemp->lpDisplayName);
                DumpGPOInfo (pGPOTemp);
                pGPOTemp = pGPOTemp->pNext;
            }

            FreeGPOList (pGPO);


            //
            // If we are in verbose mode, dump out the registry settings that
            // were applied
            //

            if (g_bVerbose) {

                if (bMachine)
                    ExpandEnvironmentStrings (TEXT("%ALLUSERSPROFILE%\\ntuser.pol"), szBuffer, MAX_PATH);
                else
                    ExpandEnvironmentStrings (TEXT("%USERPROFILE%\\ntuser.pol"), szBuffer, MAX_PATH);

                DisplayRegistryData (szBuffer);
            }
        }
    }


    //
    // Enumerate the extensions
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, GPEXT_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwIndex = 0;
        dwNameSize = 50;

        while (RegEnumKeyEx (hKey, dwIndex, szName, &dwNameSize, NULL, NULL,
                          NULL, NULL) == ERROR_SUCCESS)
        {

            //
            // Skip the registry extension since we did it above
            //

            if (lstrcmpi(TEXT("{35378EAC-683F-11D2-A89A-00C04FBBCFA2}"), szName))
            {

                //
                // Get the list of GPOs this extension applied
                //

                StringToGuid(szName, &guid);

                lResult = GetAppliedGPOList (bMachine ? GPO_LIST_FLAG_MACHINE : 0, NULL, NULL,
                                             &guid, &pGPO);

                if (lResult == ERROR_SUCCESS)
                {
                    if (pGPO)
                    {
                        //
                        // Get the extension's friendly display name
                        //

                        lResult = RegOpenKeyEx (hKey, szName, 0, KEY_READ, &hSubKey);

                        if (lResult == ERROR_SUCCESS)
                        {

                            dwSize = MAX_PATH * sizeof(TCHAR);
                            lResult = RegQueryValueEx (hSubKey, NULL, 0, &dwType, (LPBYTE) &szBuffer,
                                                       &dwSize);

                            if (lResult == ERROR_SUCCESS)
                            {
                                PrintString(IDS_LINE2);
                                if (bMachine)
                                {
                                    PrintString (IDS_COMPPOLICY, szBuffer);
                                }
                                else
                                {
                                    PrintString (IDS_USERPOLICY, szBuffer);
                                }
                            }
                            else
                            {
                                PrintString(IDS_LINE2);
                                if (bMachine)
                                {
                                    PrintString (IDS_COMPPOLICY, szName);
                                }
                                else
                                {
                                    PrintString (IDS_USERPOLICY, szName);
                                }
                            }


                            //
                            // Dump out the GPO list
                            //

                            pGPOTemp = pGPO;

                            while (pGPOTemp)
                            {
                                PrintString(IDS_GPONAME, pGPOTemp->lpDisplayName);
                                DumpGPOInfo (pGPOTemp);
                                pGPOTemp = pGPOTemp->pNext;
                            }


                            //
                            // If we're in verbose mode, then dump out some addition
                            // information about certain extensions
                            //

                            if (g_bVerbose)
                            {
                                if (!lstrcmpi(TEXT("{827D319E-6EAC-11D2-A4EA-00C04F79F83A}"), szName))
                                {
                                    PrintString(IDS_SECEDIT);
                                }
                                else if (!lstrcmpi(TEXT("{e437bc1c-aa7d-11d2-a382-00c04f991e27}"), szName))
                                {
                                    DumpIPSec ();
                                }
                                else if (!lstrcmpi(TEXT("{25537BA6-77A8-11D2-9B6C-0000F8080861}"), szName))
                                {
                                    DumpFolderRedir ();
                                }
                                else if (!lstrcmpi(TEXT("{3610eda5-77ef-11d2-8dc5-00c04fa31a66}"), szName))
                                {
                                    DumpDiskQuota ();
                                }
                                else if (!lstrcmpi(TEXT("{c6dc5466-785a-11d2-84d0-00c04fb169f7}"), szName))
                                {
                                    DumpAppMgmt (bMachine);
                                }
                                else if (!lstrcmpi(TEXT("{42B5FAAE-6536-11d2-AE5A-0000F87571E3}"), szName))
                                {
                                    if (bMachine)
                                    {
                                        DumpScripts (pGPO, TEXT("Startup"), TEXT("Startup scripts specified in"));
                                        DumpScripts (pGPO, TEXT("Shutdown"), TEXT("Shutdown scripts specified in"));
                                    }
                                    else
                                    {
                                        DumpScripts (pGPO, TEXT("Logon"), TEXT("Logon scripts specified in"));
                                        DumpScripts (pGPO, TEXT("Logoff"), TEXT("Logoff scripts specified in"));
                                    }
                                }
                                else
                                {
                                    PrintString(IDS_NOINFO);
                                }
                            }
                        }

                        FreeGPOList (pGPO);
                    }
                }
            }

            dwIndex++;
            dwNameSize = 50;
        }

        RegCloseKey (hKey);
    }

    return ERROR_SUCCESS;

}

//*************************************************************
//
//  StringToGuid()
//
//  Purpose:    Converts a GUID in string format to a GUID structure
//
//  Parameters: szValue - guid in string format
//              pGuid   - guid structure receiving the guid
//
//
//  Return:     void
//
//*************************************************************

void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

//*************************************************************
//
//  DumpProfileInfo()
//
//  Purpose:    Checks if the user has a roaming profile and if
//              so prints the storage path.
//
//  Parameters: void
//
//  Return:     void
//
//*************************************************************

void DumpProfileInfo (void)
{
    LPTSTR lpSid = NULL;
    HANDLE hProcess = NULL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    HKEY hKey;
    DWORD dwType, dwSize;


    //
    // Get the user's token
    //

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hProcess))
    {
        PrintString(IDS_OPENPROCESSTOKEN, GetLastError());
        goto Exit;
    }


    //
    // Get the user's sid
    //

    lpSid = GetSidString(hProcess);

    if (!lpSid)
    {
        PrintString(IDS_QUERYSID);
        goto Exit;
    }


    //
    // Open the user's profile mapping key
    //

    wsprintf (szBuffer, PROFILE_LIST_PATH, lpSid);

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        szBuffer[0] = TEXT('\0');
        dwSize = MAX_PATH * sizeof(TCHAR);


        //
        // Get the roaming profile value
        //

        if (RegQueryValueEx (hKey, TEXT("CentralProfile"), NULL, &dwType,
                             (LPBYTE) &szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            if (szBuffer[0] != TEXT('\0'))
            {
                PrintString(IDS_ROAMINGPROFILE, szBuffer);
            }
            else
            {
                PrintString(IDS_NOROAMINGPROFILE);
            }
        }


        szBuffer[0] = TEXT('\0');
        dwSize = MAX_PATH * sizeof(TCHAR);


        //
        // Get the local profile value
        //

        if (RegQueryValueEx (hKey, TEXT("ProfileImagePath"), NULL, &dwType,
                             (LPBYTE) &szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            if (szBuffer[0] != TEXT('\0'))
            {
                ExpandEnvironmentStrings(szBuffer, szBuffer2, MAX_PATH);
                PrintString(IDS_LOCALPROFILE, szBuffer2);
            }
            else
            {
                PrintString(IDS_NOLOCALPROFILE);
            }
        }


        RegCloseKey (hKey);
    }


Exit:
    if (lpSid)
    {
        DeleteSidString(lpSid);
    }

    if (hProcess)
    {
        CloseHandle (hProcess);
    }
}

//*************************************************************
//
//  DumpSecurityGroups()
//
//  Purpose:    Dumps the user's / computer's security groups
//
//  Parameters: bMachine
//
//  Return:     void
//
//*************************************************************

void DumpSecurityGroups (BOOL bMachine)
{
    DWORD dwSize, dwIndex, dwNameSize, dwDomainSize, dwCount, dwSidSize, dwType;
    TCHAR szName[100];
    TCHAR szDomain[100];
    TCHAR szValueName[25];
    SID_NAME_USE eUse;
    PSID pSid;
    HKEY hKey;
    LONG lResult;
    NTSTATUS status;
    LPTSTR pSidString;


    if (bMachine)
    {
        PrintString(IDS_SECURITYGROUPS2);
    }
    else
    {
        PrintString(IDS_SECURITYGROUPS1);
    }


    //
    // Open the registry key
    //

    lResult = RegOpenKeyEx ((bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\GroupMembership"),
                      0, KEY_READ, &hKey);


    if (lResult != ERROR_SUCCESS)
    {
        if ((lResult != ERROR_FILE_NOT_FOUND) && (lResult != ERROR_PATH_NOT_FOUND))
        {
            PrintString (IDS_OPENHISTORYFAILED, lResult);
        }
        return;
    }


    //
    // Query for the largest sid
    //

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                               NULL, &dwSidSize, NULL, NULL);

    if (lResult != ERROR_SUCCESS)
    {
        PrintString(IDS_QUERYKEYINFOFAILED, lResult);
        RegCloseKey (hKey);
        return;
    }


    //
    // Allocate a buffer for the sid
    //

    pSidString = LocalAlloc (LPTR, dwSidSize);

    if (!pSidString)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        RegCloseKey (hKey);
        return;
    }


    //
    // Query for the number of sids
    //

    dwSize = sizeof(dwCount);
    lResult = RegQueryValueEx (hKey, TEXT("Count"), NULL, &dwType,
                               (LPBYTE) &dwCount, &dwSize);

    if (lResult != ERROR_SUCCESS)
    {
        PrintString (IDS_QUERYVALUEFAILED, lResult);
        LocalFree (pSidString);
        RegCloseKey (hKey);
        return;
    }


    //
    // Lookup the friendly display name for each sid and print it on the screen
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        wsprintf (szValueName, TEXT("Group%d"), dwIndex);

        dwSize = dwSidSize;
        lResult = RegQueryValueEx (hKey, szValueName, NULL, &dwType,
                                   (LPBYTE) pSidString, &dwSize);

        if (lResult != ERROR_SUCCESS)
        {
            PrintString (IDS_QUERYVALUEFAILED, lResult);
            LocalFree (pSidString);
            RegCloseKey (hKey);
            return;
        }

        status = AllocateAndInitSidFromString (pSidString, &pSid);

        if (status != STATUS_SUCCESS)
        {
            PrintString (IDS_QUERYSID);
            LocalFree (pSidString);
            RegCloseKey (hKey);
            return;
        }


        dwNameSize = ARRAYSIZE(szName);
        dwDomainSize = ARRAYSIZE(szDomain);

        if (LookupAccountSid(NULL, pSid, szName, &dwNameSize,
                             szDomain, &dwDomainSize, &eUse))
        {
            PrintString(IDS_GROUPNAME, szDomain, szName);
        }
        else
        {
            if (GetLastError() != ERROR_NONE_MAPPED)
            {
                PrintString(IDS_LOOKUPACCOUNT, GetLastError());
            }
        }

        RtlFreeSid(pSid);
    }

    LocalFree (pSidString);

    RegCloseKey (hKey);

}

//*************************************************************
//
//  DumpSecurityPrivileges()
//
//  Purpose:    Dumps the user's security privileges
//
//  Parameters: void
//
//  Return:     void
//
//*************************************************************

void DumpSecurityPrivileges (void)
{
    HANDLE hProcess;
    DWORD dwSize, dwIndex, dwNameSize, dwLang;
    TCHAR szName[100];
    TCHAR szDisplayName[200];
    TOKEN_PRIVILEGES *lpPrivileges;
    PLUID pLuid;
    LUID_AND_ATTRIBUTES *pEntry;


    PrintString(IDS_SECURITYPRIVILEGES);


    //
    // Get the user's token
    //

    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hProcess))
    {
        PrintString(IDS_OPENPROCESSTOKEN, GetLastError());
        return;
    }


    //
    // Query the token for the privileges
    //

    dwSize = 0;
    GetTokenInformation(hProcess, TokenPrivileges, NULL, 0, &dwSize);

    if (dwSize == 0)
    {
        PrintString(IDS_PRIVSIZE);
        CloseHandle(hProcess);
        return;
    }

    lpPrivileges = LocalAlloc (LPTR, dwSize);

    if (!lpPrivileges)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        CloseHandle(hProcess);
        return;
    }

    if (!GetTokenInformation(hProcess, TokenPrivileges, lpPrivileges, dwSize, &dwSize))
    {
        PrintString(IDS_TOKENINFO, GetLastError());
        LocalFree(lpPrivileges);
        CloseHandle(hProcess);
        return;
    }


    //
    // Lookup the friendly display name for each privilege and print it on the screen
    //

    for (dwIndex = 0; dwIndex < lpPrivileges->PrivilegeCount; dwIndex++)
    {
        dwNameSize = 100;
        pEntry = &lpPrivileges->Privileges[dwIndex];

        pLuid = &pEntry->Luid;

        if (LookupPrivilegeName(NULL, pLuid, szName, &dwNameSize))
        {

            dwNameSize = 200;
            if (LookupPrivilegeDisplayName (NULL, szName, szDisplayName, &dwNameSize, &dwLang))
            {
                PrintString(IDS_GPONAME, szDisplayName);
            }
            else
            {
                PrintString(IDS_GPONAME, szName);
            }
        }
        else
        {
            if (GetLastError() != ERROR_NONE_MAPPED)
            {
                PrintString(IDS_LOOKUPFAILED, GetLastError());
            }
        }
    }


    LocalFree (lpPrivileges);

    CloseHandle (hProcess);

}


//*************************************************************
//
//  DumpGPOInfo()
//
//  Purpose:    Prints the details about a specific GPO
//
//  Parameters: pGPO - a GPO
//
//  Return:     void
//
//*************************************************************

void DumpGPOInfo (PGROUP_POLICY_OBJECT pGPO)
{
    TCHAR szBuffer[2 * MAX_PATH];
    LPTSTR lpTemp;

    if (!g_bVerbose)
    {
        return;
    }


    //
    // Print the version number and guid
    //

    if (g_bSuperVerbose)
    {
        if (g_bNewFunc)
        {
            PrintString(IDS_REVISIONNUMBER1, LOWORD(pGPO->dwVersion), HIWORD(pGPO->dwVersion));
        }
        else
        {
            PrintString(IDS_REVISIONNUMBER2, pGPO->dwVersion);
        }
    }
    else
    {
        if (g_bNewFunc)
        {
            PrintString(IDS_REVISIONNUMBER2, LOWORD(pGPO->dwVersion));
        }
        else
        {
            PrintString(IDS_REVISIONNUMBER2, pGPO->dwVersion);
        }
    }

    PrintString(IDS_UNIQUENAME, pGPO->szGPOName);


    //
    // To get the domain name, we parse the UNC path because the domain name
    // is also the server name
    //

    lstrcpy (szBuffer, (pGPO->lpFileSysPath+2));

    lpTemp = szBuffer;

    while (*lpTemp && *lpTemp != TEXT('\\'))
        lpTemp++;

    if (*lpTemp == TEXT('\\'))
    {
        *lpTemp = TEXT('\0');
        PrintString(IDS_DOMAINNAME2, szBuffer);
    }


    //
    // Print out where this GPO was linked (LSDOU)
    //

    if (g_bNewFunc)
    {
        switch (pGPO->GPOLink)
        {
            case GPLinkMachine:
                PrintString(IDS_LOCALLINK);
                break;

            case GPLinkSite:
                PrintString(IDS_SITELINK, (pGPO->lpLink + 7));
                break;

            case GPLinkDomain:
                PrintString(IDS_DOMAINLINK, (pGPO->lpLink + 7));
                break;

            case GPLinkOrganizationalUnit:
                PrintString(IDS_OULINK, (pGPO->lpLink + 7));
                break;

            case GPLinkUnknown:
            default:
                PrintString(IDS_UNKNOWNLINK);
                break;
        }
    }


   PrintString(IDS_NEWLINE);
}

//*************************************************************
//
//  DumpFolderRedir()
//
//  Purpose:    Prints any redirected folder locations
//
//  Parameters: void
//
//  Return:     void
//
//*************************************************************

void DumpFolderRedir (void)
{
    TCHAR szPath[2 * MAX_PATH];
    TCHAR szNames[200];
    LPTSTR lpName;
    TCHAR szRdr[2 * MAX_PATH];

    if (!g_bVerbose)
    {
        return;
    }


    //
    // Get the path to the local settings\app data folder
    //

    if (SHGetFolderPath (NULL, CSIDL_LOCAL_APPDATA , NULL, SHGFP_TYPE_CURRENT, szPath) != S_OK)
    {
        PrintString(IDS_GETFOLDERPATH);
        return;
    }


    //
    // Tack on the folder rdr specific stuff
    //

    lstrcat (szPath, TEXT("\\Microsoft\\Windows\\File Deployment\\{25537BA6-77A8-11D2-9B6C-0000F8080861}.ini"));


    //
    // Grab the section names from the ini file
    //

    if (!GetPrivateProfileSectionNames (szNames, 200, szPath))
    {
        PrintString(IDS_GETPRIVATEPROFILE);
        return;
    }


    //
    // Loop through the sections getting the path value for each.  If the path
    // doesn't start with %userprofile%, then we assume it has been redirected.
    //

    lpName = szNames;

    while (*lpName)
    {
        GetPrivateProfileString (lpName, TEXT("Path"), TEXT("%USERPROFILE%"), szRdr,
                                 2 * MAX_PATH, szPath);

        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE, szRdr, 13,
                           TEXT("%USERPROFILE%"), 13) != CSTR_EQUAL)
        {
            PrintString(IDS_FOLDERREDIR, lpName, szRdr);
        }
        lpName = lpName + lstrlen(lpName) + 1;
    }
}

//*************************************************************
//
//  DumpIPSec()
//
//  Purpose:    Dumps out the IPSec information
//
//  Parameters: none
//
//  Return:     void
//
//*************************************************************

void DumpIPSec (void)
{
    HKEY hKey;
    DWORD dwSize, dwType;
    TCHAR szBuffer[350];



    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy"),
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS)
    {

        dwSize = 350 * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');

        if (RegQueryValueEx (hKey, TEXT("DSIPSECPolicyName"),
                             NULL, &dwType, (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_IPSEC_NAME, szBuffer);
        }


        dwSize = 350 * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');

        if (RegQueryValueEx (hKey, TEXT("DSIPSECPolicyDescription"),
                             NULL, &dwType, (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_IPSEC_DESC, szBuffer);
        }


        dwSize = 350 * sizeof(TCHAR);
        szBuffer[0] = TEXT('\0');

        if (RegQueryValueEx (hKey, TEXT("DSIPSECPolicyPath"),
                             NULL, &dwType, (LPBYTE) szBuffer, &dwSize) == ERROR_SUCCESS)
        {
            PrintString(IDS_IPSEC_PATH, szBuffer);
        }


        RegCloseKey (hKey);
    }

}

//*************************************************************
//
//  DumpDiskQuota()
//
//  Purpose:    Dumps out the disk quota policies
//
//  Parameters: none
//
//  Return:     void
//
//*************************************************************

void DumpDiskQuota (void)
{
    HKEY hKey;
    DWORD dwSize, dwType, dwData;
    TCHAR szBuffer[350];


    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                      TEXT("Software\\Policies\\Microsoft\\Windows NT\\DiskQuota"),
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS)
    {

        //
        // Query for enabled
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("Enable"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_ENABLED1);
        }
        else
        {
            PrintString (IDS_DQ_ENABLED2);
        }


        //
        // Query for enforced
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("Enforce"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_ENFORCED1);
        }
        else
        {
            PrintString (IDS_DQ_ENFORCED2);
        }


        //
        // Query for limit
        //

        dwSize = sizeof(dwData);
        dwData = 0xFFFFFFFF;

        RegQueryValueEx (hKey, TEXT("Limit"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);


        if (dwData != 0xFFFFFFFF)
        {
            PrintString (IDS_DQ_LIMIT1, dwData);

            dwSize = sizeof(dwData);
            dwData = 2;

            RegQueryValueEx (hKey, TEXT("LimitUnits"),
                             NULL, &dwType, (LPBYTE) &dwData, &dwSize);


            switch (dwData)
            {
                case 1:
                    PrintString (IDS_DQ_KB);
                    break;

                case 2:
                    PrintString (IDS_DQ_MB);
                    break;

                case 3:
                    PrintString (IDS_DQ_GB);
                    break;

                case 4:
                    PrintString (IDS_DQ_TB);
                    break;

                case 5:
                    PrintString (IDS_DQ_PB);
                    break;

                case 6:
                    PrintString (IDS_DQ_EB);
                    break;
            }
        }
        else
        {
            PrintString (IDS_DQ_LIMIT2);
        }


        //
        // Query for warning level
        //

        dwSize = sizeof(dwData);
        dwData = 0xFFFFFFFF;

        RegQueryValueEx (hKey, TEXT("Threshold"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);


        if (dwData != 0xFFFFFFFF)
        {
            PrintString (IDS_DQ_WARNING1, dwData);

            dwSize = sizeof(dwData);
            dwData = 2;

            RegQueryValueEx (hKey, TEXT("ThresholdUnits"),
                             NULL, &dwType, (LPBYTE) &dwData, &dwSize);


            switch (dwData)
            {
                case 1:
                    PrintString (IDS_DQ_KB);
                    break;

                case 2:
                    PrintString (IDS_DQ_MB);
                    break;

                case 3:
                    PrintString (IDS_DQ_GB);
                    break;

                case 4:
                    PrintString (IDS_DQ_TB);
                    break;

                case 5:
                    PrintString (IDS_DQ_PB);
                    break;

                case 6:
                    PrintString (IDS_DQ_EB);
                    break;
            }
        }
        else
        {
            PrintString (IDS_DQ_WARNING2);
        }


        //
        // Log event over limit
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("LogEventOverLimit"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_LIMIT_EXCEED1);
        }
        else
        {
            PrintString (IDS_DQ_LIMIT_EXCEED2);
        }


        //
        // Log event over threshold
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("LogEventOverThreshold"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_LIMIT_EXCEED3);
        }
        else
        {
            PrintString (IDS_DQ_LIMIT_EXCEED4);
        }


        //
        // Apply policy to removable media
        //

        dwSize = sizeof(dwData);
        dwData = 0;

        RegQueryValueEx (hKey, TEXT("ApplyToRemovableMedia"),
                         NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        if (dwData)
        {
            PrintString (IDS_DQ_REMOVABLE1);
        }
        else
        {
            PrintString (IDS_DQ_REMOVABLE2);
        }

        RegCloseKey (hKey);
    }
}

void DumpScripts (PGROUP_POLICY_OBJECT pGPO, LPTSTR lpScriptType, LPTSTR lpTitle)
{
    PGROUP_POLICY_OBJECT pGPOTemp;
    TCHAR szPath[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
    TCHAR szArgs[MAX_PATH];
    TCHAR szTemp[30];
    DWORD dwIndex;
    BOOL bShowTitle;


    pGPOTemp = pGPO;

    while (pGPOTemp)
    {
        bShowTitle = TRUE;

        lstrcpy (szPath, pGPOTemp->lpFileSysPath);
        lstrcat (szPath, TEXT("\\Scripts\\Scripts.ini"));

        dwIndex = 0;

        while (TRUE)
        {
            //
            // Get the command line
            //

            szCmdLine[0] = TEXT('\0');
            wsprintf (szTemp, TEXT("%dCmdLine"), dwIndex);
            GetPrivateProfileString (lpScriptType, szTemp, TEXT(""),
                                     szCmdLine, MAX_PATH,
                                     szPath);

            //
            // If the command line is empty, we're finished
            //

            if (szCmdLine[0] == TEXT('\0'))
            {
                break;
            }

            //
            // Get the parameters
            //

            szArgs[0] = TEXT('\0');
            wsprintf (szTemp, TEXT("%dParameters"), dwIndex);
            GetPrivateProfileString (lpScriptType, szTemp, TEXT(""),
                                     szArgs, MAX_PATH,
                                     szPath);


            if (bShowTitle)
            {
                PrintString(IDS_SCRIPTS_TITLE, lpTitle, pGPOTemp->lpDisplayName);
                bShowTitle = FALSE;
            }

            PrintString(IDS_SCRIPTS_ENTRY, szCmdLine, szArgs);

            dwIndex++;
        }

        pGPOTemp = pGPOTemp->pNext;
    }
}

void DumpAppMgmt (BOOL bMachine)
{
    DWORD dwNumApps = 0, i, dwCount;
    PMANAGEDAPPLICATION pPubApps = NULL;
    PLOCALMANAGEDAPPLICATION pLocalApps = NULL;


    //
    // Assigned applications first
    //

    if (bMachine)
    {
        PrintString(IDS_APPMGMT_TITLE1);
    }
    else
    {
        PrintString (IDS_APPMGMT_TITLE2);
    }

    dwCount = 0;

    if (GetLocalManagedApplications (!bMachine, &dwNumApps, &pLocalApps) == ERROR_SUCCESS)
    {
        for (i=0; i < dwNumApps; i++)
        {
            if (pLocalApps[i].dwState & LOCALSTATE_ASSIGNED)
            {
                PrintString(IDS_APPMGMT_NAME, pLocalApps[i].pszDeploymentName);
                PrintString(IDS_APPMGMT_GPONAME, pLocalApps[i].pszPolicyName);

                if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_ORPHAN)
                {
                    PrintString(IDS_APPMGMT_ORPHAN);
                }

                if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_UNINSTALL)
                {
                    PrintString(IDS_APPMGMT_UNINSTALL);
                }

                dwCount++;
            }
        }
    }

    if (dwCount == 0)
    {
        PrintString(IDS_APPMGMT_NONE);
    }


    //
    // Exit now if this is machine processing
    //

    if (bMachine)
    {
        if (pLocalApps)
        {
            LocalFree (pLocalApps);
        }

        return;
    }


    //
    // Now published applications
    //

    PrintString(IDS_APPMGMT_TITLE3);

    dwCount = 0;

    for (i=0; i < dwNumApps; i++)
    {
        if (pLocalApps[i].dwState & LOCALSTATE_PUBLISHED)
        {
            PrintString(IDS_APPMGMT_NAME, pLocalApps[i].pszDeploymentName);
            PrintString(IDS_APPMGMT_GPONAME, pLocalApps[i].pszPolicyName);

            if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_ORPHAN)
            {
                PrintString(IDS_APPMGMT_ORPHAN);
            }

            if (pLocalApps[i].dwState & LOCALSTATE_POLICYREMOVE_UNINSTALL)
            {
                PrintString(IDS_APPMGMT_UNINSTALL);
            }

            dwCount++;
        }
    }

    if (dwCount == 0)
    {
        PrintString(IDS_APPMGMT_NONE);
    }

    if (pLocalApps)
    {
        LocalFree (pLocalApps);
    }



    //
    // Exit now if we are not in super verbose mode
    //

    if (!g_bSuperVerbose)
    {
        PrintString(IDS_APPMGMT_ARP1);
        return;
    }


    //
    // Query for the full list of published applications
    //

    PrintString(IDS_APPMGMT_ARP2);

    dwCount = 0;
    if (GetManagedApplications (NULL, MANAGED_APPS_USERAPPLICATIONS, MANAGED_APPS_INFOLEVEL_DEFAULT,
                                &dwNumApps, &pPubApps) == ERROR_SUCCESS)
    {
        for (i=0; i < dwNumApps; i++)
        {
            PrintString(IDS_APPMGMT_NAME, pPubApps[i].pszPackageName);
            PrintString(IDS_APPMGMT_GPONAME, pPubApps[i].pszPolicyName);

            if (pPubApps[i].bInstalled)
            {
                PrintString(IDS_APPMGMT_STATE1);
            }
            else
            {
                PrintString(IDS_APPMGMT_STATE2);
            }

            dwCount++;
        }

        if (pPubApps)
        {
            LocalFree (pPubApps);
        }
    }

    if (dwCount == 0)
    {
        PrintString(IDS_APPMGMT_NONE);
    }

}

void PrintString(UINT uiStringId, ...)
{
    LPTSTR lpMsg;
    TCHAR szFormat[100];
    TCHAR szBuffer[200];
    va_list marker;


    va_start(marker, uiStringId);

    if (LoadString (GetModuleHandle(NULL), uiStringId, szFormat, ARRAYSIZE(szFormat)))
    {
        wvsprintf(szBuffer, szFormat, marker);

        if (g_bDebuggerOutput)
        {
            OutputDebugString (szBuffer);
        }
        else
        {
            _tprintf(TEXT("%s"), szBuffer);
        }
    }

    va_end(marker);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpext\fdeploy\usrinfo.cxx ===
/*++

Microsoft Windows
Copyright (C) Microsoft Corporation, 1981 - 2000

Module Name:

    usrinfo.cxx

Abstract:
    This module contains the implementation of the members of the class
    CUsrInfo which is used to store and manipulate pertinent information
    about the logged on user, e.g. the HOMEDIR path, the user name,
    logon domain, etc.


Author:

    Rahul Thombre (RahulTh) 2/28/2000

Revision History:

    2/28/2000   RahulTh         Created this module.

--*/

#include "fdeploy.hxx"

CUsrInfo::CUsrInfo () : _pwszNameBuf (NULL),
                        _pwszUserName (NULL),
                        _pwszDomain (NULL),
                        _pwszHomeDir (NULL),
                        _bAttemptedGetUserName (FALSE),
                        _bAttemptedGetHomeDir (FALSE),
                        _StatusUserName (ERROR_SUCCESS),
                        _StatusHomeDir (ERROR_SUCCESS),
                        _pPlanningModeContext (NULL)
{
}

CUsrInfo::~CUsrInfo ()
{
    ResetMembers();
}

//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::ResetMembers
//
//  Synopsis:   Resets the member variables to their default values.
//
//  Arguments:  none.
//
//  Returns:    nothing.
//
//  History:    12/17/2000  RahulTh  created
//
//  Notes:      This function was added to facilitate the reinitialization
//              of the member functions of global variables. This is necessary
//              for consecutive runs of folder redirection (if fdeploy.dll) does
//              not get reloaded for some reason and the constructors for the
//              global variables are not invoked. This can lead to strange
//              undesirable results especially if the two consecutive runs are
//              for two different users.
//
//---------------------------------------------------------------------------
void CUsrInfo::ResetMembers(void)
{
    if (_pwszNameBuf)
    {
        delete [] _pwszNameBuf;
        _pwszNameBuf = NULL;
    }
    
    //
    // Note: _pwszUserName and _pwszDomain are const pointers pointing to the
    //       domain and user name within _pwszNameBuf. So there is no need to
    //       delete them here.
    //
    _pwszUserName = _pwszDomain = NULL;
    
    if (_pwszHomeDir)
    {
        delete [] _pwszHomeDir;
        _pwszHomeDir = NULL;
    }
    
    _bAttemptedGetHomeDir = _bAttemptedGetUserName = FALSE; // fixing bug 590015
    _StatusUserName = _StatusHomeDir = ERROR_SUCCESS;
    _pPlanningModeContext = NULL;
    
    return;
}

//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::GetUserName
//
//  Synopsis:   Retrieves the name of the logged on user.
//
//  Arguments:  [out] DWORD : StatusCode : the status code of the operation
//
//  Returns:    NULL : if the user name could not be obtained.
//              const pointer to a string containing the username otherwise.
//
//  History:    2/28/2000  RahulTh  created
//
//  Notes:
//
//---------------------------------------------------------------------------
const WCHAR * CUsrInfo::GetUserName (OUT DWORD & StatusCode)
{
    ULONG       ulNameLen;
    BOOL        bStatus;
    WCHAR *     wszPtr = NULL;

    //
    // In planning mode, if no user name was specified because the
    // caller targeted a SOM and not a user, we will return NULL
    // with a success status to indicate this
    //
    if ( _pPlanningModeContext && 
        ! _pPlanningModeContext->_pRsopTarget->pwszAccountName )
    {
        StatusCode = ERROR_SUCCESS;
        return NULL;
    }

    if (_bAttemptedGetUserName)
        goto GetUserName_CleanupAndQuit;

    _bAttemptedGetUserName = TRUE;

    for (ulNameLen = UNLEN + 1;;)
    {
        if (_pwszNameBuf)
        {
            delete [] _pwszNameBuf;
            _pwszNameBuf = NULL;
        }

        _pwszNameBuf = new WCHAR [ulNameLen];

        if (! _pwszNameBuf)
        {
            _StatusUserName = ERROR_OUTOFMEMORY;
            goto GetUserName_CleanupAndQuit;
        }

        //
        // In non-planning mode, we can use standard system api's
        // to retrieve a sam compatible user name ("domain\username").
        //
        if ( ! _pPlanningModeContext )
        {
            bStatus = GetUserNameEx (NameSamCompatible, _pwszNameBuf, &ulNameLen);
            if (!bStatus)
                _StatusUserName = GetLastError();
        }
        else
        {
            _StatusUserName = GetPlanningModeSamCompatibleUserName( 
                _pwszNameBuf,
                &ulNameLen);
        }

        if (ERROR_MORE_DATA == _StatusUserName)
            continue;
        else if (ERROR_SUCCESS == _StatusUserName)
            break;
        else
            goto GetUserName_CleanupAndQuit;
    }

    wszPtr = wcschr (_pwszNameBuf, L'\\');

    // Make sure it is in the form domain\username
    if (!wszPtr || L'\0' == wszPtr[1] || wszPtr == _pwszNameBuf)
    {
        _StatusUserName = ERROR_NO_SUCH_USER;
        goto GetUserName_CleanupAndQuit;
    }

    //
    // If we are here, we already have a SAM compatible name, in the form of
    // domain\username. Now we just need to make sure that _pwszUserName
    // and _pwszDomain point to the right places in the string.
    //
    // First NULL out the \ so that the string is split into the domain part
    // and the username part
    //
    *wszPtr = L'\0';

    // Assign the proper pointers
    _pwszUserName = &wszPtr[1];
    _pwszDomain = _pwszNameBuf;

    // Record success
    _StatusUserName = ERROR_SUCCESS;

GetUserName_CleanupAndQuit:
    StatusCode = _StatusUserName;
    return _pwszUserName;
}

//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::GetHomeDir
//
//  Synopsis:   Retrieves the homedir of the logged on user, if defined.
//
//  Arguments:  [out] DWORD : StatusCode : the status code of the operation
//
//  Returns:    NULL : if homedir is not defined or the information cannot be
//                     obtained.
//              const pointer to a string containing the homedir otherwise.
//
//  History:    2/28/2000  RahulTh  created
//
//  Notes:      If the homedir is not set for the user, then this function
//              returns NULL, but the StatusCode is set to ERROR_SUCCESS
//              That is how we differentiate between the case where there
//              is no homedir because there was an error trying to obtain it
//              and the case where there was no error but the homedir has not
//              been set for the user.
//
//---------------------------------------------------------------------------
const WCHAR * CUsrInfo::GetHomeDir (OUT DWORD & StatusCode)
{
    const WCHAR *   pwszUName = NULL;
    PUSER_INFO_2    pUserInfo = NULL;
    NET_API_STATUS  netStatus = NERR_Success;
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;

    if (_bAttemptedGetHomeDir)
        goto GetHomeDir_CleanupAndQuit;

    _bAttemptedGetHomeDir = TRUE;

    // Get the user name and domain so that we can query for the homedir.

    if (_bAttemptedGetUserName)
    {
        _StatusHomeDir = _StatusUserName;
        pwszUName = _pwszUserName;
    }
    else
    {
        pwszUName = this->GetUserName (_StatusHomeDir);
    }

    if (NULL == pwszUName || ERROR_SUCCESS != _StatusHomeDir)
        goto GetHomeDir_CleanupAndQuit;

    //
    // If we are here, we have the user name and the domain info.
    // So now we try to get the user's home directory from the user
    // object.
    //
    // First get a domain controller
    //

    DebugMsg ((DM_VERBOSE, IDS_QUERYDSFORHOMEDIR, _pwszUserName));

    _StatusHomeDir = DsGetDcName (NULL, _pwszDomain, NULL, NULL,
                                  DS_DIRECTORY_SERVICE_REQUIRED, &pDCInfo);
    if (NO_ERROR != _StatusHomeDir)
        goto GetHomeDir_CleanupAndQuit;

    netStatus = NetUserGetInfo (pDCInfo->DomainControllerName,
                                pwszUName,
                                2,
                                (LPBYTE *) &pUserInfo
                                );
    switch (netStatus)
    {
    case NERR_Success:
        break;
    case NERR_InvalidComputer:
        _StatusHomeDir = ERROR_INVALID_COMPUTERNAME;
        goto GetHomeDir_CleanupAndQuit;
        break;
    case NERR_UserNotFound:
        _StatusHomeDir = ERROR_NO_SUCH_USER;
        goto GetHomeDir_CleanupAndQuit;
        break;
    case ERROR_ACCESS_DENIED:
        _StatusHomeDir = ERROR_ACCESS_DENIED;
        goto GetHomeDir_CleanupAndQuit;
        break;
    default:
        //
        // We encountered some other unexpected network error. Just translate it to a 
        // generic error code.
        //
        _StatusHomeDir = ERROR_UNEXP_NET_ERR;
        goto GetHomeDir_CleanupAndQuit;
        break;
    }

    //
    // If we are here, we managed to get the user info.
    // Now, check if the user has a home directory
    //
    // Note: If the user does not have a home directory set, we return
    //       NULL, but _StatusHomeDir is set to ERROR_SUCCESS
    _StatusHomeDir = ERROR_SUCCESS;
    if (pUserInfo->usri2_home_dir && L'\0' != pUserInfo->usri2_home_dir)
    {
        size_t homeDirSize = lstrlen (pUserInfo->usri2_home_dir) + 1;
        _pwszHomeDir = new WCHAR [homeDirSize];
        if (_pwszHomeDir)
        {
            (void) StringCchCopy(_pwszHomeDir, homeDirSize, pUserInfo->usri2_home_dir);
            DebugMsg ((DM_VERBOSE, IDS_OBTAINED_HOMEDIR, _pwszHomeDir));
        }
        else
        {
            _StatusHomeDir = ERROR_OUTOFMEMORY;
        }
    }

GetHomeDir_CleanupAndQuit:
    // Cleanup
    if (pDCInfo)
        NetApiBufferFree ((LPVOID)pDCInfo);

    if (pUserInfo)
        NetApiBufferFree ((LPVOID)pUserInfo);

    // Set return values and quit
    StatusCode = _StatusHomeDir;
    if (ERROR_SUCCESS != StatusCode)
    {
        DebugMsg ((DM_VERBOSE, IDS_FAILED_GETHOMEDIR));
    }
    return (const WCHAR *) _pwszHomeDir;
}


//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::SetPlanningModeContext
//
//  Synopsis:   Set's this object's planning mode information -- setting
//              this causes this object to believe it is in planning mode
//
//  Arguments:  [in] CRsopContext* pRsopContext : pointer to planning mode
//              context object.  The lifetime of the context object is not
//              owned by this object -- it does not need to be refcounted
//              before calling this method.
//
//  History:    7/6/2000  AdamEd  created
//
//---------------------------------------------------------------------------
void CUsrInfo::SetPlanningModeContext( CRsopContext* pRsopContext )
{
    _pPlanningModeContext = pRsopContext;
}


//+--------------------------------------------------------------------------
//
//  Member:     CUsrInfo::GetPlanningModeSamCompatibleUserName
//
//  Synopsis:   Retrieves the user name of the user specified in this
//              object's planning mode context
//
//  Arguments:  [in] WCHAR* : pwszUserName : buffer in which to store
//              the same compatbile user name ("domain\username" format).
//              [in, out] : pcchUserName : length, in chars, including
//              the null terminator, of the pwszUserName  buffer.
//              On output, the it is the number of characters
//              needed in the buffer, including the null terminator
//  Returns:    NULL : ERROR_SUCCESS if the user name is successfully
//                  copied to the pwszUserName buffer, ERROR_MORE_DATA otherwise
//
//  History:    7/6/2000  AdamEd  created
//
//---------------------------------------------------------------------------
DWORD CUsrInfo::GetPlanningModeSamCompatibleUserName( WCHAR* pwszUserName, ULONG* pcchUserName )
{
    DWORD  Status;
    WCHAR* pwszUserNameSource;
    ULONG  ulActualLen;

    //
    // The interface to this method is designed to mirror that of the
    // GetUserNameEx api to simplify code that executes in both planning
    // and normal modes.
    //

    //
    // In planning mode, we retrieve the user name from the RSoP context.
    // This RSoP context has the user name in sam compatible form.
    //
    pwszUserNameSource = _pPlanningModeContext->_pRsopTarget->pwszAccountName;

    ulActualLen = lstrlen( pwszUserNameSource )+1;

    //
    // If we have enough space, copy the string
    //
    if ( ulActualLen <= *pcchUserName )
    {
        (void) StringCchCopy( pwszUserName, *pcchUserName, pwszUserNameSource );

        Status = ERROR_SUCCESS;
    }
    else
    {
        Status = ERROR_MORE_DATA;
    }

    *pcchUserName = ulActualLen;
   
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpresult\gpresult.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <lm.h>
#define SECURITY_WIN32
#include <security.h>
#include <userenv.h>
#include <dsgetdc.h>
#include <tchar.h>
#include <stdio.h>
#include <shlobj.h>
#include <appmgmt.h>


//
// String ids
//

#define IDS_NEWLINE             100
#define IDS_2NEWLINE            101
#define IDS_LEGAL1              102
#define IDS_LEGAL2              103

#define IDS_USAGE1              110
#define IDS_USAGE2              111
#define IDS_USAGE3              112
#define IDS_USAGE4              113
#define IDS_USAGE5              114
#define IDS_USAGE6              115

#define IDS_CREATEINFO          118

#define IDS_OSINFO              120
#define IDS_OS_PRO              121
#define IDS_OS_SRV              122
#define IDS_OS_DC               123

#define IDS_OS_BUILDNUMBER1     124
#define IDS_OS_BUILDNUMBER2     125

#define IDS_TS_REMOTEADMIN      130
#define IDS_TS_APPSERVER        131
#define IDS_TS_NONE             132
#define IDS_TS_NOTSUPPORTED     133

#define IDS_LINE                135
#define IDS_LINE2               136
#define IDS_COMPRESULTS1        137
#define IDS_COMPRESULTS2        138
#define IDS_DOMAINNAME          139
#define IDS_W2KDOMAIN           140
#define IDS_SITENAME            141
#define IDS_LOCALCOMP           142
#define IDS_NT4DOMAIN           143

#define IDS_USERRESULTS1        144
#define IDS_USERRESULTS2        145
#define IDS_LOCALUSER           146

#define IDS_LASTTIME            149
#define IDS_DCNAME              150

#define IDS_COMPREGPOLICY       152
#define IDS_USERREGPOLICY       153

#define IDS_COMPPOLICY          155
#define IDS_USERPOLICY          156

#define IDS_GPONAME             158

#define IDS_SECEDIT             160
#define IDS_NOINFO              161

#define IDS_ROAMINGPROFILE      164
#define IDS_NOROAMINGPROFILE    165
#define IDS_LOCALPROFILE        166
#define IDS_NOLOCALPROFILE      167

#define IDS_SECURITYGROUPS1     170
#define IDS_SECURITYGROUPS2     171
#define IDS_GROUPNAME           172
#define IDS_SECURITYPRIVILEGES  173

#define IDS_REVISIONNUMBER1     175
#define IDS_REVISIONNUMBER2     176
#define IDS_UNIQUENAME          177
#define IDS_DOMAINNAME2         178

#define IDS_LOCALLINK           180
#define IDS_SITELINK            181
#define IDS_DOMAINLINK          182
#define IDS_OULINK              183
#define IDS_UNKNOWNLINK         184

#define IDS_FOLDERREDIR         186

#define IDS_IPSEC_NAME          188
#define IDS_IPSEC_DESC          189
#define IDS_IPSEC_PATH          190

#define IDS_DQ_ENABLED1         195
#define IDS_DQ_ENABLED2         196
#define IDS_DQ_ENFORCED1        197
#define IDS_DQ_ENFORCED2        198
#define IDS_DQ_LIMIT1           199
#define IDS_DQ_LIMIT2           200
#define IDS_DQ_KB               201
#define IDS_DQ_MB               202
#define IDS_DQ_GB               203
#define IDS_DQ_TB               204
#define IDS_DQ_PB               205
#define IDS_DQ_EB               206
#define IDS_DQ_WARNING1         207
#define IDS_DQ_WARNING2         208
#define IDS_DQ_LIMIT_EXCEED1    209
#define IDS_DQ_LIMIT_EXCEED2    210
#define IDS_DQ_LIMIT_EXCEED3    211
#define IDS_DQ_LIMIT_EXCEED4    212
#define IDS_DQ_REMOVABLE1       213
#define IDS_DQ_REMOVABLE2       214

#define IDS_SCRIPTS_TITLE       216
#define IDS_SCRIPTS_ENTRY       217

#define IDS_APPMGMT_TITLE1      218
#define IDS_APPMGMT_TITLE2      219
#define IDS_APPMGMT_NAME        220
#define IDS_APPMGMT_GPONAME     221
#define IDS_APPMGMT_ORPHAN      222
#define IDS_APPMGMT_UNINSTALL   223
#define IDS_APPMGMT_NONE        224
#define IDS_APPMGMT_ARP1        225
#define IDS_APPMGMT_ARP2        226
#define IDS_APPMGMT_TITLE3      227
#define IDS_APPMGMT_STATE1      228
#define IDS_APPMGMT_STATE2      229

#define IDS_REGVIEW_PREF1       235
#define IDS_REGVIEW_PREF2       236
#define IDS_REGVIEW_PREF3       237
#define IDS_REGVIEW_GPONAME     238
#define IDS_REGVIEW_KEYNAME     239
#define IDS_REGVIEW_VALUENAME   240
#define IDS_REGVIEW_DWORD       241
#define IDS_REGVIEW_DWORDDATA   242
#define IDS_REGVIEW_SZ          243
#define IDS_REGVIEW_SZDATA      244
#define IDS_REGVIEW_EXPANDSZ    245
#define IDS_REGVIEW_MULTISZ     246
#define IDS_REGVIEW_MULTIDATA1  247
#define IDS_REGVIEW_MULTIDATA2  248
#define IDS_REGVIEW_BINARY      249
#define IDS_REGVIEW_BINARYDATA1 250
#define IDS_REGVIEW_BINARYFRMT  251
#define IDS_REGVIEW_NEXTLINE    252
#define IDS_REGVIEW_SPACE       253
#define IDS_REGVIEW_STRING1     254
#define IDS_REGVIEW_STRING2     255
#define IDS_REGVIEW_VERBOSE     256
#define IDS_REGVIEW_NONE        257
#define IDS_REGVIEW_NOVALUES    258
#define IDS_REGVIEW_UNKNOWN     259
#define IDS_REGVIEW_UNKNOWNSIZE 260


#define IDS_OPENHISTORYFAILED   1000
#define IDS_QUERYKEYINFOFAILED  1001
#define IDS_OPENPROCESSTOKEN    1002
#define IDS_QUERYSID            1003
#define IDS_QUERYVALUEFAILED    1004
#define IDS_MEMALLOCFAILED      1005
#define IDS_TOKENINFO           1006
#define IDS_LOOKUPACCOUNT       1007
#define IDS_PRIVSIZE            1008
#define IDS_LOOKUPFAILED        1009
#define IDS_GETFOLDERPATH       1010
#define IDS_GETPRIVATEPROFILE   1011
#define IDS_CREATEFILE          1012
#define IDS_INVALIDSIGNATURE1   1013
#define IDS_INVALIDSIGNATURE2   1014
#define IDS_VERSIONNUMBER1      1015
#define IDS_VERSIONNUMBER2      1016
#define IDS_FAILEDFIRSTCHAR     1017
#define IDS_FAILEDKEYNAMECHAR   1018
#define IDS_FAILEDSEMICOLON     1019
#define IDS_FAILEDVALUENAME     1020
#define IDS_FAILEDTYPE          1021
#define IDS_FAILEDDATALENGTH    1022
#define IDS_FAILEDDATA          1023
#define IDS_CLOSINGBRACKET1     1024
#define IDS_CLOSINGBRACKET2     1025



#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

BOOL DisplayRegistryData (LPTSTR lpRegistry);

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);
NTSTATUS LoadSidAuthFromString (const WCHAR* pString, PSID_IDENTIFIER_AUTHORITY pSidAuth);
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue);
void PrintString(UINT uiStringId, ...);

extern BOOL g_bVerbose;
extern BOOL g_bSuperVerbose;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpresult\regview.c ===
//*************************************************************
//  File name: REGVIEW.C
//
//  Description: Routines to print out a registry.pol file
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//*************************************************************

#include "gpresult.h"

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512

//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1


//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


//
// True policy keys
//

#define SOFTWARE_POLICIES           TEXT("Software\\Policies")
#define SOFTWARE_POLICIES_LEN       17

#define WINDOWS_POLICIES            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")
#define WINDOWS_POLICIES_LEN        46

//*************************************************************
//
//  DisplayRegistryData()
//
//  Purpose:    Displays the registry data
//
//  Parameters: lpRegistry  -   Path to registry.pol
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL DisplayRegistryData (LPTSTR lpRegistry)
{
    HANDLE hFile;
    BOOL bResult = FALSE;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength, dwIndex, dwCount;
    LPWSTR lpKeyName, lpValueName, lpTemp;
    LPBYTE lpData = NULL, lpIndex;
    WCHAR  chTemp;
    INT i;
    CHAR szString[20];
    BOOL bTruePolicy;


    //
    // Open the registry file
    //

    hFile = CreateFile (lpRegistry, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);


    if (hFile == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            return TRUE;
        }
        else
        {
            PrintString(IDS_CREATEFILE, GetLastError());
            return FALSE;
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        CloseHandle (hFile);
        return FALSE;
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        PrintString(IDS_MEMALLOCFAILED, GetLastError());
        LocalFree (lpKeyName);
        CloseHandle (hFile);
        return FALSE;
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {

        PrintString(IDS_INVALIDSIGNATURE1, GetLastError());
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        PrintString(IDS_INVALIDSIGNATURE2);
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        PrintString(IDS_VERSIONNUMBER1, GetLastError());
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        PrintString(IDS_VERSIONNUMBER2);
        goto Exit;
    }

    PrintString (IDS_NEWLINE);


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                PrintString(IDS_FAILEDFIRSTCHAR, GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            break;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                PrintString(IDS_FAILEDKEYNAMECHAR, GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                PrintString(IDS_FAILEDSEMICOLON, GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                PrintString(IDS_FAILEDVALUENAME, GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                PrintString(IDS_FAILEDSEMICOLON, GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDTYPE, GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDSEMICOLON, GetLastError());
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDDATALENGTH, GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDSEMICOLON, GetLastError());
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            PrintString(IDS_MEMALLOCFAILED, GetLastError());
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            PrintString(IDS_FAILEDDATA, GetLastError());
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            PrintString(IDS_CLOSINGBRACKET1, GetLastError());
            goto Exit;
        }

        if (chTemp != L']')
        {
            PrintString(IDS_CLOSINGBRACKET2, chTemp);
            goto Exit;
        }


        //
        // Print out the entry
        //

        bTruePolicy = FALSE;

        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                          lpKeyName, SOFTWARE_POLICIES_LEN,
                          SOFTWARE_POLICIES, SOFTWARE_POLICIES_LEN) == CSTR_EQUAL)
        {
            bTruePolicy = TRUE;
        }

        else if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                          lpKeyName, WINDOWS_POLICIES_LEN,
                          WINDOWS_POLICIES, WINDOWS_POLICIES_LEN) == CSTR_EQUAL)
        {
            bTruePolicy = TRUE;
        }

        if (!bTruePolicy)
        {
            PrintString (IDS_2NEWLINE);
            PrintString (IDS_REGVIEW_PREF1);
            PrintString (IDS_REGVIEW_PREF2);
            PrintString (IDS_REGVIEW_PREF3);
        }


        //
        // Check if this is comment holding the GPO name
        //

        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                          lpValueName, 20, TEXT("**Comment:GPO Name: "), 20) == CSTR_EQUAL)
        {
            PrintString (IDS_REGVIEW_GPONAME, (lpValueName+20));
        }
        else
        {
            PrintString (IDS_REGVIEW_KEYNAME, lpKeyName);
            PrintString (IDS_REGVIEW_VALUENAME, lpValueName);


            switch (dwType) {

                case REG_DWORD:
                    PrintString (IDS_REGVIEW_DWORD);
                    PrintString (IDS_REGVIEW_DWORDDATA, *((LPDWORD)lpData));
                    break;

                case REG_SZ:
                    PrintString (IDS_REGVIEW_SZ);
                    PrintString (IDS_REGVIEW_SZDATA, (LPTSTR)lpData);
                    break;

                case REG_EXPAND_SZ:
                    PrintString (IDS_REGVIEW_EXPANDSZ);
                    PrintString (IDS_REGVIEW_SZDATA, (LPTSTR)lpData);
                    break;

                case REG_MULTI_SZ:
                    PrintString (IDS_REGVIEW_MULTISZ);
                    PrintString (IDS_REGVIEW_MULTIDATA1);
                    lpTemp = (LPWSTR) lpData;

                    while (*lpTemp) {
                        PrintString (IDS_REGVIEW_MULTIDATA2, lpTemp);
                        lpTemp += lstrlen(lpTemp) + 1;
                    }
                    break;

                case REG_BINARY:
                    PrintString (IDS_REGVIEW_BINARY);

                    if (g_bSuperVerbose)
                    {
                        PrintString (IDS_REGVIEW_BINARYDATA1);

                        dwIndex = 0;
                        dwCount = 0;
                        lpIndex = lpData;
                        ZeroMemory(szString, sizeof(szString));

                        while (dwIndex <= dwDataLength) {
                            PrintString (IDS_REGVIEW_BINARYFRMT, *lpIndex);

                            if ((*lpIndex > 32) && (*lpIndex < 127)) {
                                szString[dwCount] = *lpIndex;
                            } else {
                                szString[dwCount] = '.';
                            }

                            if (dwCount < 15) {
                                dwCount++;
                            } else {
                                PrintString (IDS_REGVIEW_STRING1, szString);
                                PrintString (IDS_REGVIEW_NEXTLINE);
                                ZeroMemory(szString, sizeof(szString));
                                dwCount = 0;
                            }

                            dwIndex++;
                            lpIndex++;
                        }

                        if (dwCount > 0) {
                            while (dwCount < 16) {
                                PrintString (IDS_REGVIEW_SPACE);
                                dwCount++;
                            }
                            PrintString (IDS_REGVIEW_STRING2, szString);
                        }

                        PrintString (IDS_NEWLINE);
                    } else {
                        PrintString (IDS_REGVIEW_VERBOSE);
                    }

                    break;

                case REG_NONE:
                    PrintString (IDS_REGVIEW_NONE);
                    PrintString (IDS_REGVIEW_NOVALUES, *lpData);
                    break;


                default:
                    PrintString (IDS_REGVIEW_UNKNOWN);
                    PrintString (IDS_REGVIEW_UNKNOWNSIZE, dwDataLength);
                    break;
            }
        }

        LocalFree (lpData);
        lpData = NULL;

    }

    bResult = TRUE;

Exit:

    //
    // Finished
    //

    if (lpData) {
        LocalFree (lpData);
    }
    CloseHandle (hFile);
    LocalFree (lpKeyName);
    LocalFree (lpValueName);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\inc\ginacomn.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ginacomn.h

Abstract:

    This module contains the declarations shared between gina components.

Author:

    Cenk Ergan (cenke) - 2001/05/07

Environment:

    User Mode

--*/

#ifndef _GINACOMN_H
#define _GINACOMN_H

#ifdef __cplusplus
extern "C" {
#endif  

//
// Shared routines for optimized logon.
//

DWORD
GcCheckIfProfileAllowsCachedLogon(
    PUNICODE_STRING HomeDirectory,
    PUNICODE_STRING ProfilePath,
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    );

BOOL 
GcCheckIfLogonScriptsRunSync(
    PWCHAR UserSidString
    );

DWORD
GcAccessProfileListUserSetting (
    PWCHAR UserSidString,
    BOOL SetValue,
    PWCHAR ValueName,
    PDWORD Value
    );

DWORD
GcGetNextLogonCacheable(
    PWCHAR UserSidString,
    PDWORD NextLogonCacheable
    );

DWORD
GcSetNextLogonCacheable(
    PWCHAR UserSidString,
    DWORD NextLogonCacheable
    );

DWORD
GcSetOptimizedLogonStatus(
    PWCHAR UserSidString,
    DWORD OptimizedLogonStatus
    );

DWORD 
GcGetUserPreferenceValue(
    LPTSTR SidString
    );

//
// Shared routines for sid to string conversion.
//

PSID
GcGetUserSid( 
    HANDLE UserToken 
    );

LPWSTR
GcGetSidString( 
    HANDLE UserToken 
    );

VOID
GcDeleteSidString( 
    LPWSTR SidString 
    );

//
// Shared routines for dealing with services.
//

BOOL 
GcWaitForServiceToStart (
    LPTSTR lpServiceName, 
    DWORD dwMaxWait
    );

//
// Shared routines for dealing with paths.
//

LPTSTR 
GcCheckSlash (
    LPTSTR lpDir
    );

BOOL 
GcIsUNCPath(
    LPTSTR lpPath
    );

#ifdef __cplusplus
}
#endif    

#endif // _GINACOMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\inc\pcommon.h ===
/*
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * pcommon.h
 *
 * Common routines for policy code.
 */

//*************************************************************
//
//  RegDelnode()
//
//  Deletes a registry key and all it's subkeys.
//
//      hKeyRoot    Root key
//      lpSubKey    SubKey to delete
//
//*************************************************************
DWORD 
RegDelnode(
    IN  HKEY    hKeyRoot, 
    IN  PWCHAR  pwszSubKey
    )
#ifdef PCOMMON_IMPL
{
    HKEY    hSubKey = 0;
    PWCHAR  pwszChildSubKey = 0;
    DWORD   MaxCchSubKey;
    DWORD   Status;

    if ( ! pwszSubKey )
        return ERROR_SUCCESS;

    Status = RegDeleteKey( hKeyRoot, pwszSubKey );

    if ( ERROR_SUCCESS == Status ) 
        return ERROR_SUCCESS; 

    Status = RegOpenKeyEx( hKeyRoot, pwszSubKey, 0, KEY_READ, &hSubKey );

    if ( Status != ERROR_SUCCESS )
        return (Status == ERROR_FILE_NOT_FOUND) ? ERROR_SUCCESS : Status;

    Status = RegQueryInfoKey( hSubKey, 0, 0, 0, 0, &MaxCchSubKey, 0, 0, 0, 0, 0, 0 );

    if ( ERROR_SUCCESS == Status )
    {
        MaxCchSubKey++;
        pwszChildSubKey = (PWCHAR) LocalAlloc( 0, MaxCchSubKey * sizeof(WCHAR) );
        if ( ! pwszChildSubKey )
            Status = ERROR_OUTOFMEMORY;
    }

    for (;(ERROR_SUCCESS == Status);)
    {
        DWORD       CchSubKey;
        FILETIME    FileTime;

        CchSubKey = MaxCchSubKey;
        Status = RegEnumKeyEx(
                        hSubKey, 
                        0, 
                        pwszChildSubKey, 
                        &CchSubKey, 
                        NULL,
                        NULL, 
                        NULL, 
                        &FileTime );

        if ( ERROR_NO_MORE_ITEMS == Status )
        {
            Status = ERROR_SUCCESS;
            break;
        }

        if ( ERROR_SUCCESS == Status )
            Status = RegDelnode( hSubKey, pwszChildSubKey );
    }

    RegCloseKey( hSubKey );
    LocalFree( pwszChildSubKey );

    return RegDeleteKey( hKeyRoot, pwszSubKey );
}
#else
;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\mpnotify\mpnotify.h ===
/****************************** Module Header ******************************\
* Module Name: mpnotify.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main header file for mpnotify
*
* History:
* 01-12-93 Davidc       Created.
\***************************************************************************/

#define UNICODE


#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>


//
// Memory macros
//

#define Alloc(c)        ((PVOID)LocalAlloc(LPTR, c))
#define ReAlloc(p, c)   ((PVOID)LocalReAlloc(p, c, LPTR | LMEM_MOVEABLE))
#define Free(p)         ((VOID)LocalFree(p))


//
// Define useful types
//

#define PLPTSTR     LPTSTR *
typedef HWND * PHWND;

//
// Define a debug print routine
//

#define MPPrint(s)  KdPrint(("MPNOTIFY: ")); \
                    KdPrint(s);            \
                    KdPrint(("\n"));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\mpnotify\mpnotify.c ===
/****************************** Module Header ******************************\
* Module Name: mpnotify.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* MpNotify main module
*
* Mpnotify is an app executed by winlogon to notify network providers
* of authentication events. Currently this means logon and password change.
* This functionality is in a separate process to avoid network providers
* having to handle the asynchronous events that winlogon receives.
*
* Winlogon initializes environment variables to describe the event
* and then executes this process in system context on the winlogon
* desktop. While this process executes, winlogon handls all screen-saver
* and logoff notifications. Winlogon will terminate this process if required
* to respond to events (e.g. remote shutdown).
*
* On completion this process signals winlogon by sending a buffer of
* data to it in a WM_COPYDATA message and then quits.
*
* History:
* 01-12-93 Davidc       Created.
\***************************************************************************/

#include "mpnotify.h"
#include <ntmsv1_0.h>
#include <mpr.h>
#include <npapi.h>

#include <stdio.h>


//
// Define to enable verbose output for this module
//

// #define DEBUG_MPNOTIFY

#ifdef DEBUG_MPNOTIFY
#define VerbosePrint(s) MPPrint(s)
#else
#define VerbosePrint(s)
#endif



//
// Define the environment variable names used to pass the
// notification event data
//

#define MPR_STATION_NAME_VARIABLE       TEXT("WlMprNotifyStationName")
#define MPR_STATION_HANDLE_VARIABLE     TEXT("WlMprNotifyStationHandle")
#define MPR_WINLOGON_WINDOW_VARIABLE    TEXT("WlMprNotifyWinlogonWindow")

#define MPR_LOGON_FLAG_VARIABLE         TEXT("WlMprNotifyLogonFlag")
#define MPR_USERNAME_VARIABLE           TEXT("WlMprNotifyUserName")
#define MPR_DOMAIN_VARIABLE             TEXT("WlMprNotifyDomain")
#define MPR_PASSWORD_VARIABLE           TEXT("WlMprNotifyPassword")
#define MPR_OLD_PASSWORD_VARIABLE       TEXT("WlMprNotifyOldPassword")
#define MPR_OLD_PASSWORD_VALID_VARIABLE TEXT("WlMprNotifyOldPasswordValid")
#define MPR_LOGONID_VARIABLE            TEXT("WlMprNotifyLogonId")
#define MPR_CHANGE_INFO_VARIABLE        TEXT("WlMprNotifyChangeInfo")
#define MPR_PASSTHROUGH_VARIABLE        TEXT("WlMprNotifyPassThrough")
#define MPR_PROVIDER_VARIABLE           TEXT("WlMprNotifyProvider")
#define MPR_DESKTOP_VARIABLE            TEXT("WlMprNotifyDesktop")

#define WINLOGON_DESKTOP_NAME   TEXT("Winlogon")


//
// Define the authentication info type that we use
// This lets the provider know that we're passing
// an MSV1_0_INTERACTIVE_LOGON structure.
//

#define AUTHENTICATION_INFO_TYPE        TEXT("MSV1_0:Interactive")

//
// Define the primary authenticator
//

#define PRIMARY_AUTHENTICATOR           TEXT("Microsoft Windows Network")

/***************************************************************************\
* ScrubString
*
*   Wipes out the content of the string.
\***************************************************************************/
void ScrubString(
    LPTSTR lpName
)
{
    while(*lpName)
    {
        *lpName++ = TEXT(' ');
    }
}

/***************************************************************************\
* AllocAndGetEnvironmentVariable
*
* Version of GetEnvironmentVariable that allocates the return buffer.
*
* Returns pointer to environment variable or NULL on failure. This routine
* will also return NULL if the environment variable is a 0 length string.
*
* The returned buffer should be free using Free()
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
LPTSTR
AllocAndGetEnvironmentVariable(
    LPTSTR lpName
    )
{
    LPTSTR Buffer;
    DWORD LengthRequired;
    DWORD LengthUsed;
    DWORD BytesRequired;

    //
    // Go search for the variable and find its length
    //

    LengthRequired = GetEnvironmentVariable(lpName, NULL, 0);

    if (LengthRequired == 0) {
        VerbosePrint(("Environment variable <%ws> not found, error = %d", lpName, GetLastError()));
        return(NULL);
    }

    //
    // Allocate a buffer to hold the variable
    //

    BytesRequired = LengthRequired * sizeof(TCHAR);

    Buffer = Alloc(BytesRequired);
    if (Buffer == NULL) {
        MPPrint(("Failed to allocate %d bytes for environment variable", BytesRequired));
        return(NULL);
    }

    //
    // Go get the variable and pass a buffer this time
    //

    LengthUsed = GetEnvironmentVariable(lpName, Buffer, LengthRequired);

        // Now is a good time to cleanup the env variable
    if (LengthRequired > 1)
    {
        // There is a non empty password
        if (wcsstr(lpName, TEXT("Password"))) {   // Matches WlMprNotifyOldPassword & WlMprNotifyPassword
            LPTSTR Stars, Cursor;

            Stars = Alloc(BytesRequired);
            if (Stars != NULL) {
                    // Alloc inits to 0 and we can't have an empty value.
                    // Get Cursor to point to the last char
                Cursor = Stars + LengthRequired - 1;
                    // We need to wipe out from Cursor to Stars
                do {
                    *(--Cursor) = TEXT('*');
                } while(Stars != Cursor);

                    // That'll wipe out our env var...
                SetEnvironmentVariable(lpName, Stars);
            }
        }
    }

    if (LengthUsed != LengthRequired - 1) {
        MPPrint(("Unexpected result from GetEnvironmentVariable. Length passed = %d, length used = %d (expected %d)", LengthRequired, LengthUsed, LengthRequired - 1));
        Free(Buffer);
        return(NULL);
    }

    return(Buffer);
}


/***************************************************************************\
* FUNCTION: GetEnvironmentULong
*
* PURPOSE:  Gets the value of an environment variable and converts it back
*           to its normal form. The variable should have been written
*           using SetEnvironmentULong. (See winlogon)
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetEnvironmentULong(
    LPTSTR Variable,
    PULONG Value
    )
{
    LPTSTR String;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    String = AllocAndGetEnvironmentVariable(Variable);
    if (String == NULL) {
        return(FALSE);
    }

    //
    // Convert to ansi
    //

    RtlInitUnicodeString(&UnicodeString, String);
    Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

    Free(String);

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Convert to numeric value
    //

    if (1 != sscanf(AnsiString.Buffer, "%x", Value)) {
        Value = 0;
    }

    RtlFreeAnsiString(&AnsiString);

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: GetEnvironmentLargeInt
*
* PURPOSE:  Gets the value of an environment variable and converts it back
*           to its normal form. The variable should have been written
*           using SetEnvironmentLargeInt. (See winlogon)
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetEnvironmentLargeInt(
    LPTSTR Variable,
    PLARGE_INTEGER Value
    )
{
    LPTSTR String;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    String = AllocAndGetEnvironmentVariable(Variable);
    if (String == NULL) {
        return(FALSE);
    }

    //
    // Convert to ansi
    //

    RtlInitUnicodeString(&UnicodeString, String);
    Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

    Free(String);

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Convert to numeric value
    //

    if (2 != sscanf(AnsiString.Buffer, "%x:%x", &Value->HighPart, &Value->LowPart)) {
        Value->LowPart = 0;
        Value->HighPart = 0;
    }

    RtlFreeAnsiString(&AnsiString);

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: GetCommonNotifyVariables
*
* PURPOSE:  Gets environment variables describing values common to all
*           notification events
*
*           On successful return, all values should be free using Free()
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetCommonNotifyVariables(
    PULONG LogonFlag,
    PHWND hwndWinlogon,
    PLPTSTR StationName,
    PHWND StationHandle,
    PLPTSTR Name,
    PLPTSTR Domain,
    PLPTSTR Password,
    PLPTSTR OldPassword
    )
{
    BOOL Result = TRUE;
    ULONG OldPasswordValid;

    //
    // Prepare for failure
    //

    *hwndWinlogon = NULL;
    *StationName = NULL;
    *StationHandle = NULL;
    *Name = NULL;
    *Domain = NULL;
    *Password = NULL;
    *OldPassword = NULL;


    Result = GetEnvironmentULong(MPR_WINLOGON_WINDOW_VARIABLE, (PULONG)hwndWinlogon);

    if (Result) {
        *StationName = AllocAndGetEnvironmentVariable(MPR_STATION_NAME_VARIABLE);
        Result = (*StationName != NULL);
    }
    if (Result) {
        Result = GetEnvironmentULong(MPR_STATION_HANDLE_VARIABLE, (PULONG)StationHandle);
    }

    if (Result) {
        *Name = AllocAndGetEnvironmentVariable(MPR_USERNAME_VARIABLE);
//        Result = (*Name != NULL);
    }
    if (Result) {
        *Domain = AllocAndGetEnvironmentVariable(MPR_DOMAIN_VARIABLE);
//        Result = (*Domain != NULL);
    }
    if (Result) {
        *Password = AllocAndGetEnvironmentVariable(MPR_PASSWORD_VARIABLE);
        // If the password is NULL that's ok
    }
    if (Result) {
        Result = GetEnvironmentULong(MPR_OLD_PASSWORD_VALID_VARIABLE, &OldPasswordValid);
    }
    if (Result && OldPasswordValid) {
        *OldPassword = AllocAndGetEnvironmentVariable(MPR_OLD_PASSWORD_VARIABLE);
        // If the old password is NULL that's ok
    }
    if (Result) {
        Result = GetEnvironmentULong(MPR_LOGON_FLAG_VARIABLE, LogonFlag);
    }



    if (!Result) {
        MPPrint(("GetCommonNotifyVariables: Failed to get a variable, error = %d", GetLastError()));

        //
        // Free up any memory we allocated
        //

        if (*StationName != NULL) {
            Free(*StationName);
        }
        if (*Name != NULL) {
            Free(*Name);
        }
        if (*Domain != NULL) {
            Free(*Domain);
        }
        if (*Password != NULL) {
            ScrubString(*Password);
            Free(*Password);
        }
        if (*OldPassword != NULL) {
            ScrubString(*OldPassword);
            Free(*OldPassword);
        }
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: GetLogonNotifyVariables
*
* PURPOSE:  Get logon specific notify data
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetLogonNotifyVariables(
    PLUID   LogonId
    )
{
    BOOL Result;

    Result = GetEnvironmentLargeInt(MPR_LOGONID_VARIABLE, (PLARGE_INTEGER) LogonId);

    if (!Result) {
        MPPrint(("GetLogonNotifyVariables: Failed to get variable, error = %d", GetLastError()));
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: GetChangePasswordNotifyVariables
*
* PURPOSE:  Gets change-password specific notify data
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
GetChangePasswordNotifyVariables(
    PDWORD ChangeInfo,
    PBOOL PassThrough,
    PWSTR * ProviderName
    )
{
    BOOL Result;

    Result = GetEnvironmentULong(MPR_CHANGE_INFO_VARIABLE, ChangeInfo);
    if (Result) {
        Result = GetEnvironmentULong(MPR_PASSTHROUGH_VARIABLE, PassThrough);
    }
    if (Result)
    {
        *ProviderName = AllocAndGetEnvironmentVariable( MPR_PROVIDER_VARIABLE );
    }

    if (!Result) {
        MPPrint(("GetChangePasswordNotifyVariables: Failed to get variable, error = %d", GetLastError()));
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: NotifyWinlogon
*
* PURPOSE:  Informs winlogon that credential provider notification
*           has completed and passes the logon scripts buffer back.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

BOOL
NotifyWinlogon(
    HWND hwndWinlogon,
    DWORD Error,
    LPTSTR MultiSz OPTIONAL
    )
{
    DWORD MultiSzSize = 0;
    COPYDATASTRUCT CopyData;

    if (MultiSz != NULL) {

        LPTSTR StringPointer = MultiSz;
        DWORD Length;

        VerbosePrint(("NotifyWinlogon : logon scripts strings start"));

        do {
            Length = lstrlen(StringPointer);
            if (Length != 0) {
                VerbosePrint(("<%ws>", StringPointer));
            }

            MultiSzSize += ((Length + 1) * sizeof(TCHAR));
            StringPointer += Length + 1;

        } while (Length != 0);

        VerbosePrint(("NotifyWinlogon : logon scripts strings end"));

    }

    CopyData.dwData = Error;
    CopyData.cbData = MultiSzSize;
    CopyData.lpData = MultiSz;

    SendMessage(hwndWinlogon, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&CopyData);

    return(TRUE);
}

DWORD
NotifySpecificProvider(
    PWSTR Provider,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    DWORD               dwChangeInfo
    )
{
    HMODULE hDll;
    HKEY    hKey;
    WCHAR   szText[MAX_PATH];
    WCHAR   szPath[128];
    PWSTR   pszPath;
    DWORD   dwType;
    DWORD   dwLen;
    int     err;
    PF_NPPasswordChangeNotify pFunc;


    wcscpy(szText, TEXT("System\\CurrentControlSet\\Services\\") );
    wcscat(szText, Provider );
    wcscat(szText, TEXT("\\networkprovider") );

    err = RegOpenKey(   HKEY_LOCAL_MACHINE,
                        szText,
                        &hKey );

    if ( err )
    {
        return( err );
    }

    dwLen = sizeof( szPath );
    pszPath = szPath;

    err = RegQueryValueEx(  hKey,
                            TEXT("ProviderPath"),
                            NULL,
                            &dwType,
                            (PUCHAR) pszPath,
                            &dwLen );

    if ( err )
    {
        if ( err == ERROR_BUFFER_OVERFLOW )
        {

            pszPath = LocalAlloc( LMEM_FIXED, dwLen );
            if (pszPath)
            {
                err = RegQueryValueEx(  hKey,
                                        TEXT("ProviderPath"),
                                        NULL,
                                        &dwType,
                                        (PUCHAR) pszPath,
                                        &dwLen );
            }

        }

        if ( err )
        {
            RegCloseKey( hKey );

            if ( pszPath != szPath )
            {
                LocalFree( pszPath );
            }

            return( err );
        }
    }

    RegCloseKey( hKey );

    if ( dwType == REG_EXPAND_SZ )
    {
        ExpandEnvironmentStrings( pszPath, szText, MAX_PATH );
    }
    else if (dwType == REG_SZ )
    {
        wcscpy( szText, pszPath );
    }
    else
    {
        if (pszPath != szPath)
        {
            LocalFree( pszPath );
        }

        return( err );
    }

    //
    // Ok, now we have expanded the DLL where the NP code lives, and it
    // is in szText.  Load it, call it.
    //

    if ( pszPath != szPath )
    {
        LocalFree( pszPath );
        pszPath = NULL;
    }

    hDll = LoadLibrary( szText );

    if ( hDll )
    {
        pFunc = (PF_NPPasswordChangeNotify) GetProcAddress( hDll,
                                                    "NPPasswordChangeNotify" );
        if ( pFunc )
        {
            err = pFunc(lpAuthentInfoType,
                        lpAuthentInfo,
                        lpPreviousAuthentInfoType,
                        lpPreviousAuthentInfo,
                        lpStationName,
                        StationHandle,
                        dwChangeInfo);


        }

        FreeLibrary( hDll );
    }

    return( err );

}


/***************************************************************************\
* WinMain
*
* History:
* 01-12-93 Davidc       Created.
\***************************************************************************/

int
WINAPI
WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow
    )
{
    DWORD Error;
    BOOL Result;

    ULONG LogonFlag;
    HWND hwndWinlogon;
    LPTSTR StationName;
    HWND StationHandle;
    LPTSTR Name;
    LPTSTR Domain;
    LPTSTR Password;
    LPTSTR OldPassword;
    LPTSTR LogonScripts;
    LPTSTR Desktop;
    PWSTR Provider;

    LUID LogonId;
    DWORD ChangeInfo;

    MSV1_0_INTERACTIVE_LOGON AuthenticationInfo;
    MSV1_0_INTERACTIVE_LOGON OldAuthenticationInfo;
    HDESK hDesk = NULL ;
    HDESK hWinlogon ;

    BOOL PassThrough = FALSE;


    //
    // Get information describing event from environment variables
    //

    Result = GetCommonNotifyVariables(
                &LogonFlag,
                &hwndWinlogon,
                &StationName,
                &StationHandle,
                &Name,
                &Domain,
                &Password,
                &OldPassword);
    if (!Result) {
        MPPrint(("Failed to get common notify variables"));
        return(0);
    }


    //
    // Debug info
    //

    VerbosePrint(("LogonFlag =      0x%x", LogonFlag));
    VerbosePrint(("hwndWinlogon =   0x%x", hwndWinlogon));
    VerbosePrint(("Station Name =   <%ws>", StationName));
    VerbosePrint(("Station Handle = 0x%x", StationHandle));
    VerbosePrint(("Name =           <%ws>", Name));
    VerbosePrint(("Domain =         <%ws>", Domain));
    VerbosePrint(("Password =       <%ws>", Password));
    VerbosePrint(("Old Password =   <%ws>", OldPassword));


    //
    // Get the notify type specific data
    //

    if (LogonFlag != 0) {
        Result = GetLogonNotifyVariables(&LogonId);
    } else {
        Result = GetChangePasswordNotifyVariables(&ChangeInfo, &PassThrough, &Provider);
    }

    if (!Result) {
        MPPrint(("Failed to get notify event type-specific variables"));
        return(0);
    }


    //
    // Debug info
    //

    if (LogonFlag != 0) {
        VerbosePrint(("LogonId     =      0x%x:%x", LogonId.HighPart, LogonId.LowPart));
    } else {
        VerbosePrint(("ChangeInfo  =      0x%x", ChangeInfo));
        VerbosePrint(("PassThrough =      0x%x", PassThrough));
    }

    Desktop = AllocAndGetEnvironmentVariable( MPR_DESKTOP_VARIABLE );

    if ( wcscmp( Desktop, WINLOGON_DESKTOP_NAME ) )
    {
        //
        // Not supposed to use winlogon desktop.  Switch ourselves to the
        // current one:
        //

        hWinlogon = GetThreadDesktop( GetCurrentThreadId() );

        if ( hWinlogon )
        {
            hDesk = OpenInputDesktop( 0, FALSE, MAXIMUM_ALLOWED );

            if ( hDesk )
            {
                SetThreadDesktop( hDesk );
            }
        }

    }


    //
    // Fill in the authentication info structures
    //

    RtlInitUnicodeString(&AuthenticationInfo.UserName, Name);
    RtlInitUnicodeString(&AuthenticationInfo.LogonDomainName, Domain);
    RtlInitUnicodeString(&AuthenticationInfo.Password, Password);


    RtlInitUnicodeString(&OldAuthenticationInfo.UserName, Name);
    RtlInitUnicodeString(&OldAuthenticationInfo.LogonDomainName, Domain);
    RtlInitUnicodeString(&OldAuthenticationInfo.Password, OldPassword);


    //
    // Call the appropriate notify api
    //

    if (LogonFlag != 0) {

        Error = WNetLogonNotify(
                        PRIMARY_AUTHENTICATOR,
                        &LogonId,
                        AUTHENTICATION_INFO_TYPE,
                        &AuthenticationInfo,
                        (OldPassword != NULL) ? AUTHENTICATION_INFO_TYPE : NULL,
                        (OldPassword != NULL) ? &OldAuthenticationInfo : NULL,
                        StationName,
                        StationHandle,
                        &LogonScripts
                        );
        if (Error != ERROR_SUCCESS) {
            LogonScripts = NULL;
        }

    } else {

        if (!PassThrough) {
            ChangeInfo |= WN_NT_PASSWORD_CHANGED;
        }

        if (Provider)
        {
            Error = NotifySpecificProvider(
                        Provider,
                        AUTHENTICATION_INFO_TYPE,
                        &AuthenticationInfo,
                        AUTHENTICATION_INFO_TYPE,
                        &OldAuthenticationInfo,
                        StationName,
                        StationHandle,
                        ChangeInfo
                        );

        }
        else
        {

            Error = WNetPasswordChangeNotify(
                            PRIMARY_AUTHENTICATOR,
                            AUTHENTICATION_INFO_TYPE,
                            &AuthenticationInfo,
                            AUTHENTICATION_INFO_TYPE,
                            &OldAuthenticationInfo,
                            StationName,
                            StationHandle,
                            ChangeInfo
                            );
        }

        LogonScripts = NULL;
    }


    if (Error != ERROR_SUCCESS) {
        MPPrint(("WNet%sNotify failed, error = %d", LogonFlag ? "Logon" : "PasswordChange", Error));
    }

    //
    // Switch back if necessary
    //

    if ( hDesk )
    {
        SetThreadDesktop( hWinlogon );
        CloseDesktop( hWinlogon );
        CloseDesktop( hDesk );
    }

    //
    // Scrub the passwords before calling NotifyWinlogon
    // because we can be killed before the cleanup below
    if (Password != NULL) {
        ScrubString(Password);
    }
    if (OldPassword != NULL) {
        ScrubString(OldPassword);
    }

    //
    // Notify winlogon we completed and pass the logon script data
    //

    NotifyWinlogon(hwndWinlogon, Error, LogonScripts);

    //
    // Free up allocated data
    //

    if (LogonScripts != NULL) {
        LocalFree(LogonScripts);
    }

    if (StationName != NULL) {
        Free(StationName);
    }
    if (Name != NULL) {
        Free(Name);
    }
    if (Domain != NULL) {
        Free(Domain);
    }
    if (Password != NULL) {
        Free(Password);
    }
    if (OldPassword != NULL) {
        Free(OldPassword);
    }


    //
    // We're finished
    //

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\audit.c ===
/****************************** Module Header ******************************\
* Module Name: audit.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implementation of routines that access/manipulate the system audit log
*
* History:
* 12-09-91 Davidc       Created.
* 5-6-92   DaveHart     Fleshed out.
\***************************************************************************/

#include "msgina.h"

#include "authzi.h"
#include "msaudite.h"

/***************************************************************************\
* GetAuditLogStatus
*
* Purpose : Fills the global data with audit log status information
*
* Returns:  TRUE on success, FALSE on failure
*
* History:
* 12-09-91 Davidc       Created.
* 5-6-92   DaveHart     Fleshed out.
\***************************************************************************/

BOOL
GetAuditLogStatus(
    PGLOBALS    pGlobals
    )
{
    EVENTLOG_FULL_INFORMATION EventLogFullInformation;
    DWORD dwBytesNeeded;
    HANDLE AuditLogHandle;



    //
    // Assume the log is not full. If we can't get to EventLog, tough.
    //

    pGlobals->AuditLogFull = FALSE;

    AuditLogHandle = OpenEventLog( NULL, TEXT("Security"));

    if (AuditLogHandle) {
        if (GetEventLogInformation(AuditLogHandle, 
                                   EVENTLOG_FULL_INFO, 
                                   &EventLogFullInformation, 
                                   sizeof(EventLogFullInformation), 
                                   &dwBytesNeeded )   ) {
            if (EventLogFullInformation.dwFull != FALSE) {
                pGlobals->AuditLogFull = TRUE;
            }
        }
        CloseEventLog(AuditLogHandle);
    }


    //
    // There's no way in the current event logger to tell how full the log
    // is, always indicate we're NOT near full.
    //

    pGlobals->AuditLogNearFull = FALSE;

    return TRUE;
}




/***************************************************************************\
* DisableAuditing
*
* Purpose : Disable auditing via LSA.
*
* Returns:  TRUE on success, FALSE on failure
*
* History:
* 5-6-92   DaveHart     Created.
\***************************************************************************/

BOOL
DisableAuditing()
{
    NTSTATUS                    Status, IgnoreStatus;
    PPOLICY_AUDIT_EVENTS_INFO   AuditInfo;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE                  PolicyHandle;

    //
    // Set up the Security Quality Of Service for connecting to the
    // LSA policy object.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_VIEW_AUDIT_INFORMATION | POLICY_SET_AUDIT_REQUIREMENTS,
                 &PolicyHandle
                 );
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to open LsaPolicyObject Status = 0x%lx", Status));
        return FALSE;
    }

    Status = LsaQueryInformationPolicy(
                 PolicyHandle,
                 PolicyAuditEventsInformation,
                 (PVOID *)&AuditInfo
                 );
    if (!NT_SUCCESS(Status)) {

        IgnoreStatus = LsaClose(PolicyHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        DebugLog((DEB_ERROR, "Failed to query audit event info Status = 0x%lx", Status));
        return FALSE;
    }

    if (AuditInfo->AuditingMode) {

        AuditInfo->AuditingMode = FALSE;

        Status = LsaSetInformationPolicy(
                     PolicyHandle,
                     PolicyAuditEventsInformation,
                     AuditInfo
                     );
    } else {
        Status = STATUS_SUCCESS;
    }


    IgnoreStatus = LsaFreeMemory(AuditInfo);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = LsaClose(PolicyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to disable auditing Status = 0x%lx", Status));
        return FALSE;
    }

    return TRUE;
}

DWORD
GenerateCachedUnlockAudit(
    IN PSID pUserSid,
    IN PCWSTR pszUser,
    IN PCWSTR pszDomain
    )
{
    DWORD dwRet = ERROR_SUCCESS;

    WCHAR szComputerName[CNLEN + sizeof('\0')] = L"-";
    DWORD dwComputerNameSize = ARRAYSIZE(szComputerName);

    LUID  Luid;
    LUID SystemLuid = SYSTEM_LUID;

    if( !pUserSid || !pszUser )
    {
        DebugLog((DEB_ERROR, "GenerateCachedUnlockAudit got invalid parameters"));
        ASSERT(FALSE);
        dwRet = ERROR_INVALID_PARAMETER;
        goto ErrorReturn;
    }

    //
    // Generate a locally unique id to include in the logon sid
    // Note that this is a dummy SID. We don't want to use the logon
    // LUID as this is specific to logon/logoff. Also a NULL LUID
    // is seen as meaningless, so we have to generate a random one
    //
    if( !AllocateLocallyUniqueId(&Luid) )
    {
        dwRet = GetLastError();
        DebugLog((DEB_ERROR, "AllocateLocallyUniqueId failed, error = 0x%lx", dwRet));
        goto ErrorReturn;
    }
    
    //
    // Ignore the failure
    //
    GetComputerName(szComputerName, &dwComputerNameSize);

    if( !AuthziSourceAudit(
         APF_AuditSuccess,
         SE_CATEGID_LOGON,            //category id
         SE_AUDITID_SUCCESSFUL_LOGON, //audit id
         L"Security",
         pUserSid,                    //the user sid
         12,                          //count for va section
         APT_String,     pszUser,
         APT_String,     pszDomain ? pszDomain : L"-",
         APT_Luid,       Luid,
         APT_Ulong,      CachedUnlock,
         APT_String,     L"Winlogon",
         APT_String,     L"Winlogon unlock cache",
         APT_String,     szComputerName,
         APT_String,     L"-",
         APT_String,     L"SYSTEM",
         APT_String,     L"NT AUTHORITY",
         APT_Luid,       SystemLuid,
         APT_Ulong,      GetCurrentProcessId()
         ) )
    {
        DebugLog((DEB_ERROR, "AuthziSourceAudit failed, error = 0x%lx", dwRet));
        dwRet = GetLastError();
    }

ErrorReturn:
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\gpresult\sid.c ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "gpresult.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    SID_IDENTIFIER_AUTHORITY Auth;

    pSidStr = LocalAlloc(LPTR, (lstrlen (lpszSidStr) + 1)*sizeof(WCHAR));;
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    lstrcpy (pSidStr, lpszSidStr);
    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        LocalFree( pSidStr );
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = lstrlenW (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = LocalAlloc( LPTR, (len + 1) * sizeof(WCHAR));

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    lstrcpy (pwszNumStr, szNum);
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        LocalFree( pwszNumStr );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\authmon.h ===
typedef enum _AUTH_OPERATION {

    AuthOperLogon,
    AuthOperUnlock 	

} AUTH_OPERATION;

typedef enum _AUTH_TYPE {
 	
    AuthTypePassword,
    AuthTypeSmartCard

} AUTH_TYPE;

EXTERN_C HANDLE AuthMonitor(
    AUTH_OPERATION AuthOper,
	BOOL Console,
	PUNICODE_STRING UserName,
	PUNICODE_STRING Domain,
	PWSTR Card,
	PWSTR Reader,
	PKERB_SMART_CARD_PROFILE Profile,
	DWORD Timer,
    NTSTATUS Status
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\authmon.cxx ===
#ifdef SMARTCARD_DOGFOOD
#include "msgina.h"
#include <stdio.h>
#include <Wincrypt.h>

#include "tchar.h"
#include "authmon.h"

#include "sql.h"
#include "sqlext.h"
#include "sqltypes.h"
#include "odbcss.h"

#define SQL_CALL_SUCCESS(status) (status == SQL_SUCCESS || status == SQL_SUCCESS_WITH_INFO)
                 
#if DBG || DEBUG
#define DebugPrint(a) _DebugPrint a
void
__cdecl
_DebugPrint(
    LPCTSTR szFormat,
    ...
    )
{
    TCHAR szBuffer[512];
    va_list ap;

    szBuffer[0] = 0;
    va_start(ap, szFormat);
    _vsntprintf(szBuffer, ARRAYSIZE(szBuffer), szFormat, ap);
    szBuffer[ ARRAYSIZE(szBuffer) - 1 ] = 0;
    OutputDebugString(szBuffer);
}

int debugLine = __LINE__;
#define DEBUG_MARKER debugLine = __LINE__

#else

#define DebugPrint(a)
#define DEBUG_MARKER

#endif

typedef struct _AUTH_DATA {

    HANDLE          hHeap;
    BOOL            bConsole;
    WCHAR           szUser[64];
    AUTH_OPERATION  AuthOperation;
    WCHAR           szReader[32];
    WCHAR           szCard[48];
    ULONG           StopWatch;
    NTSTATUS        Status;
    WCHAR           szDomain[32];
    WCHAR           szDC[32];
    BYTE            pCertBlob[4096];
    ULONG           uCertBlob;
    SQLWCHAR        szSQLServer[64];
    SQLWCHAR        szSQLUser[64];
    SQLWCHAR        szSQLPassword[64];
    SQLWCHAR        szSQLDatabase[64];

} AUTH_DATA, *PAUTH_DATA;


DWORD 
WINAPI
WriteLogonData(
    PAUTH_DATA pAuthData
    )
{
    SQLRETURN RetCode = SQL_SUCCESS;
    HSTMT hStmt = NULL;
    HENV hEnv = NULL, hDbc = NULL;
    BOOL bConnected = FALSE;
    SQLSMALLINT cbConnect = 0;
    static SQLWCHAR szConnect[256], szInConnect[256];

    __try {

        RetCode = SQLAllocHandle(
            SQL_HANDLE_ENV, 
            SQL_NULL_HANDLE,
            &hEnv
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLSetEnvAttr(
            hEnv,
            SQL_ATTR_ODBC_VERSION,
            (SQLPOINTER) SQL_OV_ODBC3,  
            SQL_IS_INTEGER
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLAllocHandle(
            SQL_HANDLE_DBC,
            hEnv,
            &hDbc
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLSetConnectAttr(
            hDbc, 
            SQL_ATTR_LOGIN_TIMEOUT, 
            (SQLPOINTER) 120,
            SQL_IS_UINTEGER
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        RetCode = SQLSetConnectAttr(
            hDbc, 
            SQL_COPT_SS_INTEGRATED_SECURITY, 
            (SQLPOINTER) SQL_IS_OFF,
            SQL_IS_INTEGER
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        _snwprintf(
            szInConnect,
            sizeof(szInConnect) / sizeof(SQLWCHAR),
            (const wchar_t *) L"DRIVER=SQL Server;Server=%s;UID=%s;PWD=%s;DATABASE=%s",
            pAuthData->szSQLServer,
            pAuthData->szSQLUser,
            pAuthData->szSQLPassword,
            pAuthData->szSQLDatabase
            );
        szInConnect[ sizeof(szInConnect) / sizeof(SQLWCHAR) - 1 ] = 0;

        RetCode = SQLDriverConnect(
            hDbc,
            NULL,
            szInConnect,
            SQL_NTS,
            szConnect,
            sizeof(szConnect) / sizeof(szConnect[0]),
            &cbConnect,
            SQL_DRIVER_NOPROMPT
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        bConnected = TRUE;

        RetCode = SQLAllocHandle(
            SQL_HANDLE_STMT,
            hDbc, 
            &hStmt
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        static WCHAR szStatement[] = 
            L"INSERT INTO AuthMonitor ("
            L"BUILDLAB,"
            L"CARD,"
            L"CERTISSUER,"
            L"DC,"
            L"DOMAIN,"
            L"MACHINENAME,"
            L"READER,"
            L"SESSION,"
            L"STATUS,"
            L"STOPWATCH,"
            L"TIMESTAMP,"
            L"UNLOCK,"
            L"USERNAME"
            L") VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)";

        RetCode = SQLPrepare(
            hStmt,
            szStatement, 
            SQL_NTS
            );

        if(!SQL_CALL_SUCCESS(RetCode)) {

            DEBUG_MARKER;
            __leave;
        }

        SQLUSMALLINT iParamNo = 1;

        //
        // BUILDLAB
        //
        HKEY hKey;
        DWORD dwStatus = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hKey
            );

        static WCHAR szBuild[MAX_PATH];
        DWORD cbBuild = sizeof(szBuild);
        wcscpy(szBuild, L"");

        if (dwStatus == ERROR_SUCCESS) {

            DWORD dwType = REG_SZ;
            dwStatus = RegQueryValueEx(
                hKey,
                L"BuildLab",
                0,
                &dwType,
                (LPBYTE) szBuild,
                &cbBuild
                );

            if (dwStatus != ERROR_SUCCESS) {

                cbBuild = sizeof(szBuild);
                dwStatus = RegQueryValueEx(
                    hKey,
                    L"CurrentBuildNumber",
                    0,
                    &dwType,
                    (LPBYTE) szBuild,
                    &cbBuild
                    );
            }

            RegCloseKey(hKey);
        }

        SQLLEN cbBuildLab = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szBuild,
            0,
            &cbBuildLab
            );

        //
        // CARD
        //
        SQLLEN cbCard = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            48,
            0,
            pAuthData->szCard,
            0,
            &cbCard
            );

        //
        // CERTISSUER
        //
        PCERT_CONTEXT pCert = (PCERT_CONTEXT) CertCreateCertificateContext( 
            X509_ASN_ENCODING,
            pAuthData->pCertBlob,
            pAuthData->uCertBlob
            );

        WCHAR szIssuer[64] = L"";       
        if (pCert) {
        
            // intentionally ignore errors
            CertGetNameString(
                pCert,
                CERT_NAME_FRIENDLY_DISPLAY_TYPE,
                CERT_NAME_ISSUER_FLAG,
                NULL,
                szIssuer,
                sizeof(szIssuer) / sizeof(szIssuer[0])
                );

            CertFreeCertificateContext(pCert);
        }

        SQLLEN cbIssuer = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szIssuer,
            0,
            &cbIssuer
            );

        //
        // DC
        //
        PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;

        dwStatus = DsGetDcName(
            NULL, 
            pAuthData->szDomain, 
            NULL, 
            NULL,
            DS_IS_FLAT_NAME | DS_RETURN_FLAT_NAME,
            &pDCInfo
            );

        static WCHAR szDC[MAX_PATH];
        wcscpy(szDC, L"");

        static WCHAR szDomain[ARRAYSIZE(pAuthData->szDomain)];
        wcscpy(szDomain, L"");

        if (dwStatus == ERROR_SUCCESS) {

            lstrcpyn(szDC, pDCInfo->DomainControllerName, ARRAYSIZE(szDC));
            lstrcpyn(szDomain, pDCInfo->DomainName, ARRAYSIZE(szDomain));
            NetApiBufferFree(pDCInfo);
        }

        SQLLEN cbDC = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            32,
            0,
            szDC,
            0,
            &cbDC
            );

        //
        // DOMAIN
        //
        if (pAuthData->szDomain[0] == L'\0') {

            PWCHAR pszPos;
            if (pszPos = wcschr(pAuthData->szUser, L'@')) {

                lstrcpyn(szDomain, pszPos + 1, ARRAYSIZE(szDomain));

                if (pszPos = wcschr(szDomain, L'.')) {

                    *pszPos = L'\0';
                }
            }

        } else {

            wcscpy(szDomain, pAuthData->szDomain);
        }

        SQLLEN cbDomain = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            32,
            0,
            szDomain,
            0,
            &cbDomain
            );

        //
        // MACHINENAME
        //
        static WCHAR szMachineName[MAX_PATH];
        wcscpy(szMachineName, L"");

        DWORD dwMachineName = sizeof(szMachineName)/sizeof(szMachineName[0]);

        // intentionally ignore any failures
        GetComputerNameEx(
            ComputerNameDnsHostname, 
            szMachineName,         
            &dwMachineName    
            );

        SQLLEN cbMachineName = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szMachineName,
            0,
            &cbMachineName
            );

        //
        // READER
        //
        SQLLEN cbReader = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            32,
            0,
            pAuthData->szReader,
            0,
            &cbReader
            );

        //
        // SESSION
        //
        SQLLEN cbSession = 0;
        BOOL bSession = !pAuthData->bConsole;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_SHORT,
            SQL_SMALLINT,
            0,
            0,
            &bSession,
            0,
            &cbSession
            );

        //
        // STATUS
        //
        SQLLEN cbStatus = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_LONG,
            SQL_INTEGER,
            0,
            0,
            &pAuthData->Status,
            0,
            &cbStatus
            );

        //
        // STOPWATCH
        //
        SQLLEN cbStopWatch = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_ULONG,
            SQL_INTEGER,
            0,
            0,
            &pAuthData->StopWatch,
            0,
            &cbStopWatch
            );

        //
        // TIMESTAMP
        //
        TIMESTAMP_STRUCT TimeStamp;
        SYSTEMTIME SystemTime;

        GetLocalTime(&SystemTime);

        TimeStamp.day = SystemTime.wDay;
        TimeStamp.month = SystemTime.wMonth;
        TimeStamp.year = SystemTime.wYear;
        TimeStamp.hour = SystemTime.wHour;
        TimeStamp.minute = SystemTime.wMinute;
        TimeStamp.second = SystemTime.wSecond;
        TimeStamp.fraction = 0;

        SQLLEN cbTimeStamp = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_TIMESTAMP, 
            SQL_TIMESTAMP,
            19,
            0,
            &TimeStamp,
            0,
            &cbTimeStamp
            );

        //
        // UNLOCK
        //
        SQLLEN cbAuthOperation = 0;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_SHORT,
            SQL_SMALLINT,
            0,
            0,
            &pAuthData->AuthOperation,
            0,
            &cbAuthOperation
            );

        //
        // USERNAME
        //
        static WCHAR szUser[ARRAYSIZE(pAuthData->szUser)];
        wcscpy(szUser, pAuthData->szUser);

        if (PWCHAR pszPos = wcschr(szUser, L'@')) {
            *pszPos = L'\0';
        }

        SQLLEN cbUserName = SQL_NTS;
        SQLBindParameter(
            hStmt, 
            iParamNo++, 
            SQL_PARAM_INPUT,
            SQL_C_WCHAR,
            SQL_WCHAR,
            64,
            0,
            szUser,
            0,
            &cbUserName
            );

        RetCode = SQLExecute(hStmt);
        DEBUG_MARKER;
    }
    __finally {

    }

    if (!SQL_CALL_SUCCESS(RetCode)) {

        SDWORD      swError;
        static      SQLWCHAR    szErrorMsg[SQL_MAX_MESSAGE_LENGTH];
        SWORD       swErrorMsg;
        SQLWCHAR    szSQLState[50];

        SQLError(
            hEnv, 
            hDbc, 
            hStmt, 
            szSQLState,
            &swError, 
            szErrorMsg, 
            SQL_MAX_MESSAGE_LENGTH - 1, 
            &swErrorMsg
            );

        DebugPrint(
            (L"AuthMonitor: Error WriteLogonData (%d) - %s (%s)\n   [%s]", 
            debugLine,
            szErrorMsg,
            szSQLState,
            szInConnect)
            );
    }

    if (hStmt) {

        SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
        hStmt = NULL;
    }

    if (hDbc) {

        if (bConnected) {
            SQLDisconnect(hDbc);
            bConnected = FALSE;
        }
        SQLFreeHandle(SQL_HANDLE_DBC, hDbc);
        hDbc = NULL;
    }

    if (hEnv) {

        SQLFreeHandle(SQL_HANDLE_ENV, hEnv);
        hEnv = NULL;
    }

    HeapFree(pAuthData->hHeap, 0, pAuthData);

    DebugPrint(
        (L"AuthMonitor: WriteLogonData %s\n", 
        (SQL_CALL_SUCCESS(RetCode) ? L"succeeded" : L"failed"))
        );

    return 0;
}

EXTERN_C HANDLE AuthMonitor(
    AUTH_OPERATION AuthOper,
    BOOL Console,
    PUNICODE_STRING User,
    PUNICODE_STRING Domain,
    PWSTR Card,
    PWSTR Reader,
    PKERB_SMART_CARD_PROFILE Profile,
    DWORD Timer,
    NTSTATUS Status
    )   
{
    PAUTH_DATA pAuthData = NULL;
    HANDLE hHeap = NULL;
    HANDLE hThread = NULL;
    HKEY hKey = NULL;
    USHORT usLength;

    LONG lResult = RegOpenKeyEx(
      HKEY_LOCAL_MACHINE,
          TEXT("SOFTWARE\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
          0,
          KEY_READ,
          &hKey
          );

    if (lResult != ERROR_SUCCESS) {

        return NULL;
    }

    __try {

        DWORD dwSize, dwType, dwEnabled = 0;

        dwSize = sizeof(dwEnabled);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonEnabled"),
            0,
            &dwType,
            (PBYTE) &dwEnabled,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_DWORD || dwEnabled == 0) {

            DEBUG_MARKER;
            __leave;
        }

        hHeap = GetProcessHeap();

        if (hHeap == NULL) {

            DEBUG_MARKER;
            __leave;
        }

        pAuthData = (PAUTH_DATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(AUTH_DATA));

        if (pAuthData == NULL) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLServer);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonServer"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLServer,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLUser);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonUser"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLUser,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLPassword);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonPassword"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLPassword,
            &dwSize
            );
    
        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        dwSize = sizeof(pAuthData->szSQLDatabase);
        lResult = RegQueryValueEx(
            hKey,
            TEXT("AuthMonDatabase"),
            0,
            &dwType,
            (PBYTE) &pAuthData->szSQLDatabase,
            &dwSize
            );

        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {

            DEBUG_MARKER;
            __leave;
        }

        pAuthData->hHeap = hHeap;
        pAuthData->AuthOperation = AuthOper;
        pAuthData->bConsole = Console;
        usLength = Domain->Length;
        if (usLength + 2 > sizeof(pAuthData->szDomain))
        {
            usLength = sizeof(pAuthData->szDomain) - 2;
        }
        memcpy(pAuthData->szDomain, Domain->Buffer, usLength);
        usLength = User->Length;
        if (usLength + 2 > sizeof(pAuthData->szUser))
        {
            usLength = sizeof(pAuthData->szUser) - 2;
        }
        memcpy(pAuthData->szUser, User->Buffer, usLength);
        if (Card) {
            lstrcpyn(pAuthData->szCard, Card, ARRAYSIZE(pAuthData->szCard));
        }
        if (Reader) {
            lstrcpyn(pAuthData->szReader, Reader, ARRAYSIZE(pAuthData->szReader));
        }
        if (Profile && Profile->CertificateData && (Profile->CertificateSize < sizeof(pAuthData->pCertBlob))) {
            memcpy(
                pAuthData->pCertBlob, 
                Profile->CertificateData, 
                Profile->CertificateSize
                );
            pAuthData->uCertBlob = Profile->CertificateSize;
        }
        pAuthData->StopWatch = Timer;
        pAuthData->Status = Status;

        hThread = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) WriteLogonData,
            pAuthData,
            0,
            NULL
            );
        DEBUG_MARKER;
    }
    __finally {

        if (hKey) {

            RegCloseKey(hKey);
        }

        if (hThread == NULL) {

            if (pAuthData) {

                HeapFree(hHeap, 0, pAuthData);
            }

            DebugPrint((L"AuthMonitor: Error line %d\n", debugLine));
        }
#ifndef TEST
        else
        {
            CloseHandle(hThread);
            hThread = NULL;
        }
#endif
    }

    return hThread;
}

#ifdef TEST
_cdecl main()
{
    UNICODE_STRING Domain, User;
    HANDLE hThread = NULL;

    RtlInitUnicodeString(
        &Domain,
        L""
        );

    RtlInitUnicodeString(
        &User,
        L"Klaus"
        );

    hThread = AuthMonitor(
        AuthOperLogon,
        0,
        &User,
        &Domain,
        L"Gemplus",
        L"Utimaco",
        NULL,
        10,
        0
        );

    if (hThread) {

        WaitForSingleObjectEx(hThread, INFINITE, FALSE);
    }
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\brand.h ===
#ifndef __util_h
#define __util_h

extern HPALETTE g_hpalBranding;

extern HBITMAP g_hbmOtherDlgBrand;
extern SIZE g_sizeOtherDlgBrand;
extern HBITMAP g_hbmLogonBrand;
extern SIZE g_sizeLogonBrand;
extern HBITMAP g_hbmBand;
extern SIZE g_sizeBand;

VOID MoveChildren(HWND hWnd, INT dx, INT dy);
VOID MoveControls(HWND hWnd, UINT* aID, INT cID, INT dx, INT dy, BOOL fSizeWnd);

VOID LoadBrandingImages(BOOL fNoPaletteChanges, 
                        BOOL* pfTextOnLarge, BOOL* pfTextOnSmall);

VOID SizeForBranding(HWND hWnd, BOOL fLargeBrand);

BOOL PaintBranding(HWND hWnd, HDC hDC, INT bandOffset, BOOL fBandOnly, BOOL fLargeBrand, int nBackground);
BOOL BrandingQueryNewPalete(HWND hDlg);
BOOL BrandingPaletteChanged(HWND hDlg, HWND hWndPalChg);

VOID CreateFonts(PGINAFONTS pGinaFonts);
VOID PaintBitmapText(PGINAFONTS pGinaFonts, BOOL fTextOnLarge, BOOL fTextOnSmall);

#define ShowDlgItem(h, i, f)    \
            ShowWindow(GetDlgItem(h, i), f ? SW_SHOW:SW_HIDE)

#define EnableDlgItem(h, i, f)  \
            EnableWindow(GetDlgItem(h, i), f)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\audit.h ===
/****************************** Module Header ******************************\
* Module Name: audit.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines utility routines that deal with the system audit log
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

//
// Exported function prototypes
//


BOOL
GetAuditLogStatus(
    PGLOBALS
    );

BOOL
DisableAuditing(
    );

DWORD
GenerateCachedUnlockAudit(
    IN PSID pUserSid,
    IN PCWSTR pszUser,
    IN PCWSTR pszDomain
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\chngepwd.h ===
/****************************** Module Header ******************************\
* Module Name: chngepwd.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis used to implement change password functionality of winlogon
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//

#define CHANGEPWD_OPTION_EDIT_DOMAIN    0x00000001      // Allow domain field to be changed
#define CHANGEPWD_OPTION_SHOW_DOMAIN    0x00000002      // Show domain field
#define CHANGEPWD_OPTION_SHOW_NETPROV   0x00000004      // Include network providers
#define CHANGEPWD_OPTION_KEEP_ARRAY     0x00000008      // Use existing domain cache array
#define CHANGEPWD_OPTION_NO_UPDATE      0x00000010      // don't update in-memory hash

#define CHANGEPWD_OPTION_ALL            0x00000007

INT_PTR
ChangePassword(
    IN HWND    hwnd,
    IN PGLOBALS pGlobals,
    IN PWCHAR   UserName,
    IN PWCHAR   Domain,
    IN ULONG    Options
    );

INT_PTR
ChangePasswordLogon(
    IN HWND    hwnd,
    IN PGLOBALS pGlobals,
    IN PWCHAR   UserName,
    IN PWCHAR   Domain,
    IN PWCHAR   OldPassword
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\chngepwd.c ===
/****************************** Module Header ******************************\
* Module Name: chngpwd.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implementation of change-password functionality of winlogon
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>
#include <align.h>
#include <keymgr.h>
#include <netlib.h>

typedef void (WINAPI *RUNDLLPROC)(HWND hWndStub,HINSTANCE hInstance,LPWSTR szCommandLine,int nShow);

// #define VERBOSE_UTILS

#ifdef VERBOSE_UTILS
#define VerbosePrint(s) WLPrint(s)
#else
#define VerbosePrint(s)
#endif

//
// Define the structure used to pass data into the change password dialog
//

typedef struct {
    PGLOBALS    pGlobals;
    PWCHAR      UserName;
    PWCHAR      Domain;
    PWCHAR      OldPassword;
    ULONG       Options ;
    BOOL        Impersonate;
    BOOL        AllowProviderOnly;
    WCHAR       UserNameBuffer[MAX_STRING_BYTES];
} CHANGE_PASSWORD_DATA;
typedef CHANGE_PASSWORD_DATA *PCHANGE_PASSWORD_DATA;



typedef 
NTSTATUS 
(WINAPI * GINA_CHANGEPW_FUNC)(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );

//
// Private prototypes
//

NTSTATUS
ProviderChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );

NTSTATUS
MitChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );

NTSTATUS
NtChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );


INT_PTR WINAPI ChangePasswordDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL ChangePasswordDlgInit(HWND, LPARAM);
INT_PTR AttemptPasswordChange(HWND);

BOOL IsAutologonUser(LPCTSTR szUser, LPCTSTR szDomain);
NTSTATUS SetAutologonPassword(LPCTSTR szPassword);

INT_PTR
HandleFailedChangePassword(
    HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    PWCHAR UserName,
    PWCHAR Domain,
    NTSTATUS SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    );


//
// This table corresponds to the DOMAIN_ENTRY_TYPE from domain.h
//
GINA_CHANGEPW_FUNC
ChangePasswordWorkers[] = {
    NULL,                       // DomainInvalid
    NtChangePassword,           // DomainUPN
    NtChangePassword,           // DomainMachine
    NtChangePassword,           // DomainNt4
    NtChangePassword,           // DomainNt5
    MitChangePassword,          // DomainMitRealm
    MitChangePassword,          // DomainMitUntrusted
    ProviderChangePassword      // DomainNetworkProvider
};



// Control arrays for dynamically dorking with the dialog
static UINT ctrlNoDomain[] =
{
    IDD_CHANGEPWD_OLD_LABEL,
    IDD_CHANGEPWD_OLD,
    IDD_CHANGEPWD_NEW_LABEL,
    IDD_CHANGEPWD_NEW,
    IDD_CHANGEPWD_CONFIRM_LABEL,
    IDD_CHANGEPWD_CONFIRM,
    IDD_KBLAYOUT_ICON,
    IDC_BACKUP,
    IDOK,
    IDCANCEL
};


// Do not show the [Backup] button on the msgina dialog if:
//
//  1.  The default domain is not the local machine
//  2.  Over a terminal server session
//  3.  The user name is a UPN name (domain combo box also disabled but not by this fn)
//
BOOL ShowBackupButton(HWND hDlg, PGLOBALS pGlobals)
{
    INT_PTR iItem;
    LPARAM lp;
    int cchBuffer;
    TCHAR* pszLogonName = NULL;
    HWND hwU = GetDlgItem(hDlg,IDD_CHANGEPWD_NAME);
    HWND hwD = GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN);
    HWND hwB = GetDlgItem(hDlg,IDC_BACKUP);
    BOOL fEnable = TRUE;
    
    cchBuffer = (int)SendMessage(hwU, WM_GETTEXTLENGTH, 0, 0) + 1;

    pszLogonName = (TCHAR*) Alloc(cchBuffer * sizeof(TCHAR));
    if (pszLogonName != NULL)
    {
        SendMessage(hwU, WM_GETTEXT, (WPARAM) cchBuffer, (LPARAM) pszLogonName);
        // turn off the button if the user is using a
        // UPN (if there is a "@") - ie foo@microsoft.com OR
        // domain\username
        fEnable = (NULL == wcspbrk(pszLogonName, TEXT("@\\")));
        Free(pszLogonName);
    }
    
    if (fEnable) 
    {
        // turn off button if is remote session
        fEnable = (0 == GetSystemMetrics(SM_REMOTESESSION));
    }

    if (fEnable)
    {
        // turn off button if selected domain is not local machine
        if (hwD) 
        {
            iItem = SendMessage(hwD,CB_GETCURSEL,0,0);
            if (LB_ERR != iItem)
            {
                // now window active and something selected
                fEnable = FALSE;
                lp = SendMessage(hwD, CB_GETITEMDATA,iItem,0);
                if ((LB_ERR != lp) && (0 != lp))
                {
                    if (DomainMachine == ((PDOMAIN_CACHE_ENTRY)lp)->Type)
                    {
                        fEnable = TRUE;
                    }
                }
            }
        }
    }
    
    //EnableWindow(hwB,fEnable);
    if (fEnable) ShowWindow(hwB,SW_SHOWNORMAL);
    else ShowWindow(hwB,SW_HIDE);
    
    return fEnable;
}

BOOL 
NetworkProvidersPresent(
    VOID
    )
{
    HKEY ProviderKey;
    DWORD Error;
    DWORD ValueType;
    LPTSTR Value;
    BOOL NeedToNotify = TRUE;

#define NET_PROVIDER_ORDER_KEY TEXT("system\\CurrentControlSet\\Control\\NetworkProvider\\Order")
#define NET_PROVIDER_ORDER_VALUE  TEXT("ProviderOrder")
#define NET_ORDER_SEPARATOR  TEXT(',')


    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,     // hKey
                NET_PROVIDER_ORDER_KEY, // lpSubKey
                0,                      // Must be 0
                KEY_QUERY_VALUE,        // Desired access
                &ProviderKey            // Newly Opened Key Handle
                );

    if (Error == ERROR_SUCCESS) {

        Value = AllocAndRegQueryValueEx(
                    ProviderKey,            // Key
                    NET_PROVIDER_ORDER_VALUE,// Value name
                    NULL,                   // Must be NULL
                    &ValueType              // Type returned here
                    );

        if (Value != NULL) {
            if (ValueType == REG_SZ) {

                LPTSTR p = Value;
                while (*p) {
                    if (*p == NET_ORDER_SEPARATOR) {
                        break;
                    }
                    p = CharNext(p);
                }

                if (*p == 0) {

                    //
                    // We got to the end without finding a separator
                    // Only one provider is installed.
                    //

#pragma prefast(suppress: 400, "PREfast noise: lstrcmpi")
                    if (lstrcmpi(Value, SERVICE_WORKSTATION) == 0) {

                        //
                        // it's Lanman, don't notify
                        //

                        NeedToNotify = FALSE;


                    } else {

                        //
                        //  it isn't Lanman, notify
                        //

                        NeedToNotify = TRUE;
                    }
                }

            } else {
                DebugLog((DEB_ERROR, "NoNeedToNotify - provider order key unexpected type: %d, assuming notification is necessary", ValueType));
            }

            Free(Value);

        } else {
            DebugLog((DEB_ERROR, "NoNeedToNotify - failed to query provider order value, assuming notification is necessary\n"));
        }

        Error = RegCloseKey(ProviderKey);
        ASSERT(Error == ERROR_SUCCESS);
    }

    return NeedToNotify ;
}


BOOL
ShowDomain(
    VOID
    )
{
    return (SafeBootMode != SAFEBOOT_MINIMAL);
}


/***************************************************************************\
* FUNCTION: ChangePassword
*
* PURPOSE:  Attempts to change a user's password
*
* ARGUMENTS:
*
*   hwnd            - the most recent parent window
*   pGlobals        - pointer to global data for this instance.
*                     The password information of this data will be
*                     updated upon successful change of the primary
*                     authenticator's password information.
*   UserName        - the name of the user to change
*   Domain          - the domain name to change the password on
*   AnyDomain       - if TRUE the user may select any trusted domain, or
*                     enter the name of any other domain
*
* RETURNS:
*
*   MSGINA_DLG_SUCCESS     - the password was changed successfully.
*   MSGINA_DLG_FAILURE     - the user's password could not be changed.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
ChangePassword(
    HWND    hwnd,
    PGLOBALS pGlobals,
    PWCHAR   UserName,
    PWCHAR   Domain,
    ULONG    Options
    )
{
    CHANGE_PASSWORD_DATA    PasswordData;
    INT_PTR Result;
    HWND hwndOldFocus = GetFocus();
    ULONG LocalOptions = 0 ;

    PasswordData.pGlobals = pGlobals;


    PasswordData.UserName = UserName;
    PasswordData.Domain = Domain;
    PasswordData.OldPassword = NULL;
    PasswordData.Impersonate = TRUE;
    PasswordData.AllowProviderOnly = TRUE;

    if ( NetworkProvidersPresent() )
    {
        LocalOptions |= CHANGEPWD_OPTION_SHOW_NETPROV |
                        CHANGEPWD_OPTION_SHOW_DOMAIN ;

    }

    if ( ShowDomain() )
    {
        LocalOptions |= CHANGEPWD_OPTION_EDIT_DOMAIN |
                        CHANGEPWD_OPTION_SHOW_DOMAIN ;
    }

    if ( SafeBootMode == SAFEBOOT_MINIMAL )
    {
        LocalOptions = 0 ;
    }

    PasswordData.Options = (Options & LocalOptions);

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LOGON_TIMEOUT);

    Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            MAKEINTRESOURCE(IDD_CHANGEPWD_DIALOG),
                                            hwnd,
                                            ChangePasswordDlgProc,
                                            (LPARAM)&PasswordData);
    SetFocus(hwndOldFocus);
    return(Result);
}


/***************************************************************************\
* FUNCTION: ChangePasswordLogon
*
* PURPOSE:  Attempts to change a user's password during the logon process.
*           This is the same as a normal change password except that the user
*           does not have to enter the old password and can only change the
*           password in the specified domain. This routine is intended to be
*           called during logon when it is discovered that the user's
*           password has expired.
*
* ARGUMENTS:
*
*   hwnd            - the most recent parent window
*   pGlobals        - pointer to global data for this instance
*   UserName        - the name of the user to change
*   Domain          - the domain name to change the password on
*   OldPassword     - the old user password
*   NewPassword     - points to a buffer that the new password is written
*                     into if the password is changed successfully.
*   NewPasswordMaxBytes - the size of the newpassword buffer.
*
* RETURNS:
*
*   MSGINA_DLG_SUCCESS     - the password was changed successfully, NewPassword
*                     contains the new password text.
*   MSGINA_DLG_FAILURE     - the user's password could not be changed.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
ChangePasswordLogon(
    HWND    hwnd,
    PGLOBALS pGlobals,
    PWCHAR   UserName,
    PWCHAR   Domain,
    PWCHAR   OldPassword
    )
{
    CHANGE_PASSWORD_DATA PasswordData;
    INT_PTR Result;

    PasswordData.pGlobals = pGlobals;

    PasswordData.UserName = UserName;
    PasswordData.Domain = Domain;
    PasswordData.OldPassword = OldPassword;
    PasswordData.Options =  CHANGEPWD_OPTION_NO_UPDATE ;
    PasswordData.Impersonate = FALSE;
    PasswordData.AllowProviderOnly = FALSE;

    if ( ShowDomain() )
    {
        PasswordData.Options |= CHANGEPWD_OPTION_SHOW_DOMAIN |
                                CHANGEPWD_OPTION_KEEP_ARRAY ;
    }

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LOGON_TIMEOUT);

    Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            MAKEINTRESOURCE( IDD_CHANGEPWD_DIALOG ),
                                            hwnd,
                                            ChangePasswordDlgProc,
                                            (LPARAM)&PasswordData);

    return(Result);
}



/****************************************************************************\
*
* FUNCTION: ChangePasswordDlgProc
*
* PURPOSE:  Processes messages for ChangePassword dialog
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

INT_PTR WINAPI
ChangePasswordDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PCHANGE_PASSWORD_DATA pPasswordData = (PCHANGE_PASSWORD_DATA)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PGLOBALS pGlobals;
    INT_PTR Result;

    switch (message) {

        case WM_INITDIALOG:
            {
                if (!ChangePasswordDlgInit(hDlg, lParam)) {
                    EndDialog(hDlg, MSGINA_DLG_FAILURE);
                }

                return(SetPasswordFocus(hDlg));
            }

        case WM_DESTROY:

            pGlobals = pPasswordData->pGlobals ;

            if ( pGlobals->ActiveArray &&
                 ((pPasswordData->Options & CHANGEPWD_OPTION_KEEP_ARRAY) == 0 ) )
            {
                DCacheFreeArray( pGlobals->ActiveArray );
                pGlobals->ActiveArray = NULL ;
            }

            FreeLayoutInfo(LAYOUT_CUR_USER);

            return( TRUE );

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_SYSCOMMAND:
            if ( wParam == SC_CLOSE )
            {
                EndDialog( hDlg, MSGINA_DLG_FAILURE );
                return TRUE ;
            }
            break;

        case WM_COMMAND:
            {

            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                ShowBackupButton(hDlg,pPasswordData->pGlobals);
                return TRUE;
            }

            switch (LOWORD(wParam)) {
                case IDD_CHANGEPWD_NAME:

                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            // Ensure the domain box is enabled/disabled correctly
                            // in case of a UPN name
                            
                            if ( pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN )
                            {
                                EnableDomainForUPN((HWND) lParam, GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN));
                                ShowBackupButton(hDlg,pPasswordData->pGlobals);
                            }

                            return TRUE;
                        default:
                            break;
                    }
                    break;
                    
                 case IDC_BACKUP:
                    {
                        BOOL fWrongDomain = TRUE;
                        PDOMAIN_CACHE_ENTRY Entry;
                        HWND hwndDomain = GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN);
                        INT iDomainSelection = (INT)SendMessage(hwndDomain,CB_GETCURSEL,0,0);

                        // Get the user's input.  Decide if he has selected other than the local machine
                        if (pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN)
                        {
                            // see if selected domain is local machine
                            Entry = (PDOMAIN_CACHE_ENTRY)SendMessage(hwndDomain,CB_GETITEMDATA,iDomainSelection,0);
                            // warning.... Entry can turn out to be ffffffff  (CB_ERR)
                            if (CB_ERR == (ULONG_PTR) Entry)
                            {
                                fWrongDomain = TRUE;
                            }
                            else if (NULL != Entry)
                            {
                                if (Entry->Type == DomainMachine)
                                {
                                    fWrongDomain = FALSE;
                                }
                            }
                        }
                        else fWrongDomain = FALSE;

                        // Show UI or message box
                        if (fWrongDomain)
                        {
                            pGlobals = pPasswordData->pGlobals ;
                            if (NULL == pGlobals) return TRUE;
                            TimeoutMessageBox(hDlg, pGlobals, IDS_MBMWRONGDOMAIN,
                                                     IDS_MBTWRONGDOMAIN,
                                                     MB_OK | MB_ICONEXCLAMATION,
                                                     TIMEOUT_CURRENT);
                            return TRUE;
                        }
                        else 
                        {
                            // standalone case
                            // We use a single export from KEYMGR.DLL for this operation.  When this operation completes,
                            //  we don't use the DLL again without unlikely user intervention.  We could DELAYLOAD keymgr.dll,
                            //  but explicitly loading and unloading this DLL permits us to minimize the memory footprint of msgina.
                           RUNDLLPROC fptr;
                           HMODULE hDll;
                           //
                           hDll = LoadLibrary(L"keymgr.dll");
                           if (hDll) 
                           {
                               fptr = (RUNDLLPROC) GetProcAddress(hDll,(LPCSTR)"PRShowSaveFromMsginaW");
                               if (fptr) 
                               {
                                   WCHAR szUser[UNLEN+1];
                                   if (0 != SendMessage(GetDlgItem(hDlg,IDD_CHANGEPWD_NAME),WM_GETTEXT,UNLEN,(LPARAM)szUser))
                                       fptr(hDlg,NULL,szUser,0);
                               }
                               FreeLibrary(hDll);
                           }
                            return TRUE;
                        }
                        
                        // determine if this domain entered is not the local machine
                        //  if not, show a message box and bow out.
                    }
                
                
                 case IDOK:
                    {
                        pGlobals = pPasswordData->pGlobals;

                        //
                        // Deal with combo-box UI requirements
                        //

                        if (HandleComboBoxOK(hDlg, IDD_CHANGEPWD_DOMAIN)) {
                            return(TRUE);
                        }

                        Result = AttemptPasswordChange(hDlg);

                        //
                        // Can't hurt to get the edit controls to forget their contents in
                        // any case. It used to be done only in the failure case
                        //
                        SetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, NULL );
                        SetDlgItemText(hDlg, IDD_CHANGEPWD_NEW, NULL );
                        SetDlgItemText(hDlg, IDD_CHANGEPWD_CONFIRM, NULL );

                        if (Result == MSGINA_DLG_FAILURE) {
                            //
                            // Let the user try again
                            // We always make the user re-enter at least the new password.
                            //

                            SetPasswordFocus(hDlg);

                            //EndDialog(hDlg, Result);
                            return(TRUE);
                        }


                        //
                        // We're finished - either success or an interrupt
                        //

                        EndDialog(hDlg, Result);
                        return(TRUE);
                    }

                case IDCANCEL:
                    {
                        SetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, NULL );
                        SetDlgItemText(hDlg, IDD_CHANGEPWD_NEW, NULL );
                        SetDlgItemText(hDlg, IDD_CHANGEPWD_CONFIRM, NULL );
                        EndDialog(hDlg, MSGINA_DLG_FAILURE);
                        return(TRUE);
                    }

                break;
                }
            }

        case WLX_WM_SAS:
            {
                // Ignore it
                return(TRUE);
            }

        case WM_TIMER:
        {
            if (wParam == TIMER_MYLANGUAGECHECK)
            {
                LayoutCheckHandler(hDlg, LAYOUT_CUR_USER);
            }
            break;
        }

    }

    // We didn't process this message
    return FALSE;
}


/****************************************************************************\
*
* FUNCTION: ChangePasswordDlgInit
*
* PURPOSE:  Handles initialization of change password dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

BOOL
ChangePasswordDlgInit(
    HWND    hDlg,
    LPARAM  lParam
    )
{
    PCHANGE_PASSWORD_DATA pPasswordData = (PCHANGE_PASSWORD_DATA)lParam;
    PGLOBALS pGlobals = pPasswordData->pGlobals;

    // Store our structure pointer
    SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

    // Size for the branding image we are going to add.
    SizeForBranding(hDlg, FALSE);

    // Set up the initial text field contents

    SetDlgItemText(hDlg, IDD_CHANGEPWD_NAME, pPasswordData->UserName);
    SetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, pPasswordData->OldPassword);

    // Limit the maximum password length to 127
    SendDlgItemMessage(hDlg, IDD_CHANGEPWD_OLD, EM_SETLIMITTEXT, (WPARAM) 127, 0);
    SendDlgItemMessage(hDlg, IDD_CHANGEPWD_NEW, EM_SETLIMITTEXT, (WPARAM) 127, 0);
    SendDlgItemMessage(hDlg, IDD_CHANGEPWD_CONFIRM, EM_SETLIMITTEXT, (WPARAM) 127, 0);

    // ShowBackupButton(hDlg,pPasswordData->pGlobals); moved to after populate domain list
    
    // If this is the domain case and we aren't force to hide the domain ui

    if (( pPasswordData->Options & CHANGEPWD_OPTION_SHOW_DOMAIN ) && 
        (!ForceNoDomainUI()))
    {
        // If the user can choose their domain, fill the domain combobox
        // with the known domains and the local machine name.  Otherwise
        // disable the domain combobox.

        if ( pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN ) {

            ASSERT( (pPasswordData->Options & CHANGEPWD_OPTION_KEEP_ARRAY) == 0 );


            if ( !DCacheValidateCache( pGlobals->Cache ) )
            {
                ASSERT( pGlobals->ActiveArray == NULL );

                DCacheUpdateFull( pGlobals->Cache, 
                                  pGlobals->Domain );

            }

            pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

            if ( pPasswordData->Options & CHANGEPWD_OPTION_SHOW_NETPROV )
            {
                DCacheAddNetworkProviders( pGlobals->ActiveArray );
            }

            if ( pGlobals->ActiveArray )
            {
                // Fill combo box list, set domain type item data
                DCachePopulateListBoxFromArray( pGlobals->ActiveArray,
                                                GetDlgItem( hDlg, IDD_CHANGEPWD_DOMAIN ),
                                                NULL );

            }
            else 
            {
                EndDialog( hDlg, MSGINA_DLG_FAILURE );
            }


            EnableDomainForUPN( GetDlgItem( hDlg, IDD_CHANGEPWD_NAME),
                                GetDlgItem(hDlg,IDD_CHANGEPWD_DOMAIN) );

        } else {

            SendDlgItemMessage(hDlg, IDD_CHANGEPWD_DOMAIN, CB_ADDSTRING, 0, (LPARAM)pPasswordData->Domain);
            SendDlgItemMessage(hDlg, IDD_CHANGEPWD_DOMAIN, CB_SETCURSEL, 0, 0);
            EnableDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN, FALSE);
        }
    }
    else // workgroup case or we're forced to hide the domain UI
    {
        RECT rcDomain, rcUsername;


        // Hide the domain box
        ShowWindow(GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN_LABEL), SW_HIDE);

        EnableDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN, FALSE);

        // Shorten the window since the domain box isn't used
        GetWindowRect(GetDlgItem(hDlg, IDD_CHANGEPWD_NAME), &rcUsername);
        GetWindowRect(GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN), &rcDomain);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rcDomain.bottom-rcUsername.bottom),
                     TRUE);        
    }
    
    ShowBackupButton(hDlg,pPasswordData->pGlobals);
    
    DisplayLanguageIcon(hDlg, LAYOUT_CUR_USER, GetKeyboardLayout(0));

    CentreWindow(hDlg);

    SetupSystemMenu(hDlg);

    return TRUE;
}

VOID
UpdateWithChangedPassword(
    PGLOBALS pGlobals,
    HWND    ActiveWindow,
    BOOL    Hash,
    PWSTR   UserName,
    PWSTR   Domain,
    PWSTR   Password,
    PWSTR   NewPassword,
   PMSV1_0_INTERACTIVE_PROFILE NewProfile
    )
{
    WLX_MPR_NOTIFY_INFO MprInfo;
    int MprResult;
    PDOMAIN_CACHE_ENTRY Entry ;
    UNICODE_STRING String ;
    DWORD ChangeInfo = 0;
    HWND hwndOwner;
    PMSV1_0_CHANGEPASSWORD_REQUEST Request = NULL;
    ULONG RequestSize = 0;
    ULONG PackageId = 0;
    PVOID Response = NULL;
    ULONG ResponseSize;
    NTSTATUS SubStatus = STATUS_SUCCESS, Status = STATUS_SUCCESS;
    PBYTE Where;
    STRING Name;
    DWORD MaxPasswordAge ;
    LARGE_INTEGER Now ;
    LARGE_INTEGER EndOfPassword ;
    HANDLE ImpHandle ;
    BOOL InteractiveUser = FALSE;

    if (pGlobals->AutoAdminLogon)
    {
        if (IsAutologonUser(UserName, Domain))
        {
            SetAutologonPassword(NewPassword);
        }
    }

    //
    // Determine if this is the interactive user
    //

    if ( (_wcsicmp( Domain, pGlobals->Domain ) == 0 ) &&
         (_wcsicmp( UserName, pGlobals->UserName ) == 0 ) )
    {
        InteractiveUser = TRUE ;
    }
    else if ( ( pGlobals->FlatDomain.Buffer ) &&
              ( _wcsicmp( Domain, pGlobals->FlatDomain.Buffer ) == 0 ) &&
              ( _wcsicmp( UserName, pGlobals->FlatUserName.Buffer ) == 0 ) )
    {
        InteractiveUser = TRUE ;
    }
    else 
    {
            // More complicated stuff for the domain\username NT4 style
	    PWSTR   BackSlash;

        if ((BackSlash = wcschr(pGlobals->UserName, L'\\')) != NULL)
        {
               // size of domain in domain\username
            ResponseSize = (ULONG)(BackSlash - pGlobals->UserName);

            if ((ResponseSize == (ULONG)wcslen(Domain)) &&
                (_wcsnicmp(Domain, pGlobals->UserName, ResponseSize) == 0) &&
                (_wcsicmp(UserName, BackSlash+1 ) == 0))
            {
                InteractiveUser = TRUE ;
            }
        }
    }



    if ( InteractiveUser )
    {
        //
        // Update the in-memory copy of the password for unlock.
        //

        RtlInitUnicodeString( &String, NewPassword );

        if ( Hash )
        {
            HashPassword( &String, pGlobals->PasswordHash );
        }
        else 
        {
            //
            // Don't hash the password away.  This is only 
            // set when the password is changed during logon.
            // (all the callers stored NewPassword in buffer of same length)

            // Erase the old password first as it might be shorter than the new one
            // It is still in cleartext at this point!
            ErasePassword( &pGlobals->PasswordString );
            wcscpy( pGlobals->Password, NewPassword );

            RtlInitUnicodeString(
                &pGlobals->PasswordString,
                pGlobals->Password);


            HidePassword(
                &pGlobals->Seed,
                &pGlobals->PasswordString);
        }


        //
        // Update password expiration time
        //

        if ( pGlobals->Profile )
        {
            if ( NewProfile )
            {
                pGlobals->Profile->PasswordMustChange = NewProfile->PasswordMustChange;
            }
            else
            {
                GetSystemTimeAsFileTime( (PFILETIME)&Now );

                if ( GetMaxPasswordAge( Domain, &MaxPasswordAge ) == 0 )
                {
                    EndOfPassword.QuadPart = Now.QuadPart + (LONGLONG)MaxPasswordAge * (LONGLONG)10000000 ;
                }
                else
                {
                    //
                    // Compute the new expiration based on the last delta
                    //
                    EndOfPassword.QuadPart = pGlobals->Profile->PasswordMustChange.QuadPart - 
                                             pGlobals->Profile->PasswordLastSet.QuadPart +
                                             Now.QuadPart;
                }

                //
                // Make sure we're not shortening the expiration time
                //
                if ( pGlobals->Profile->PasswordMustChange.QuadPart < EndOfPassword.QuadPart )
                {
                    pGlobals->Profile->PasswordMustChange.QuadPart = EndOfPassword.QuadPart;
                }
            }
        }

        //
        // Update the security packages:
        //

        RtlInitString(
            &Name,
            MSV1_0_PACKAGE_NAME
            );

        Status = LsaLookupAuthenticationPackage(
                    pGlobals->LsaHandle,
                    &Name,
                    &PackageId
                    );

        if ( NT_SUCCESS( Status ) )
        {
            RequestSize = sizeof(MSV1_0_CHANGEPASSWORD_REQUEST) +
                              (DWORD) (wcslen(UserName) +
                                       wcslen(Domain) +
                                       wcslen(NewPassword) + 3) * sizeof(WCHAR);

            Request = (PMSV1_0_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT,RequestSize);

            if ( Request )
            {
                Where = (PBYTE) (Request + 1);
                Request->MessageType = MsV1_0ChangeCachedPassword;
                wcscpy(
                    (LPWSTR) Where,
                    Domain
                    );
                RtlInitUnicodeString(
                    &Request->DomainName,
                    (LPWSTR) Where
                    );
                Where += Request->DomainName.MaximumLength;

                wcscpy(
                    (LPWSTR) Where,
                    UserName
                    );
                RtlInitUnicodeString(
                    &Request->AccountName,
                    (LPWSTR) Where
                    );
                Where += Request->AccountName.MaximumLength;

                wcscpy(
                    (LPWSTR) Where,
                    NewPassword
                    );
                RtlInitUnicodeString(
                    &Request->NewPassword,
                    (LPWSTR) Where
                    );
                Where += Request->NewPassword.MaximumLength;

                //
                // Make the call
                //

                ImpHandle = ImpersonateUser( &pGlobals->UserProcessData, NULL );

                if ( ImpHandle )
                {
                    Request->Impersonating = TRUE ;

                    Status = LsaCallAuthenticationPackage(
                                pGlobals->LsaHandle,
                                PackageId,
                                Request,
                                RequestSize,
                                &Response,
                                &ResponseSize,
                                &SubStatus
                                );

                    StopImpersonating( ImpHandle );
                }

                    // this buffer contains passwords so we zeroize it before freeing it
                ZeroMemory(Request, RequestSize);
                LocalFree( Request );

                if ( NT_SUCCESS( Status ) && ImpHandle )
                {
                    LsaFreeReturnBuffer( Response );
                }
            }
        }
    }

    //
    // Let other providers know about the change
    //

    //
    // If the domain is one from our combo-box
    // then it is valid for logons.
    //

    if ( pGlobals->ActiveArray )
    {
        RtlInitUnicodeString( &String, Domain );

        Entry = DCacheSearchArray( 
                    pGlobals->ActiveArray,
                    &String );

        if ( (Entry) && (Entry->Type != DomainNetworkProvider) )
        {
            ChangeInfo |= WN_VALID_LOGON_ACCOUNT ;   
        }
    }

    //
    // Hide this dialog and pass our parent as the owner
    // of any provider dialogs
    //

    ShowWindow(ActiveWindow, SW_HIDE);
    hwndOwner = GetParent( ActiveWindow );

    MprInfo.pszUserName = DupString(UserName);
    MprInfo.pszDomain = DupString(Domain);
    MprInfo.pszPassword = DupString(NewPassword);
    MprInfo.pszOldPassword = DupString(Password);

    MprResult = pWlxFuncs->WlxChangePasswordNotify(
                                       pGlobals->hGlobalWlx,
                                       &MprInfo,
                                       ChangeInfo | WN_NT_PASSWORD_CHANGED);

}


/****************************************************************************\
*
* FUNCTION: AttemptPasswordChange
*
* PURPOSE:  Tries to change the user's password using the current values in
*           the change-password dialog controls
*
* RETURNS:  MSGINA_DLG_SUCCESS if the password was changed successfully.
*           MSGINA_DLG_FAILURE if the change failed
*           DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* NOTES:    If the password change failed, this routine displays the necessary
*           dialogs explaining what failed and why before returning.
*           This routine also clears the fields that need re-entry before
*           returning so the calling routine can call SetPasswordFocus on
*           the dialog to put the focus in the appropriate place.
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/
void MyZeroMemory(PVOID lpv, SIZE_T size)
{
    ZeroMemory(lpv, size);
}


INT_PTR
AttemptPasswordChange(
    HWND    hDlg
    )
{
    PCHANGE_PASSWORD_DATA pPasswordData = (PCHANGE_PASSWORD_DATA)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PGLOBALS pGlobals = pPasswordData->pGlobals;
    TCHAR   UserName[MAX_STRING_BYTES];
    TCHAR   Domain[MAX_STRING_BYTES];
    TCHAR   Password[MAX_STRING_BYTES];
    TCHAR   NewPassword[MAX_STRING_BYTES];
    TCHAR   ConfirmNewPassword[MAX_STRING_BYTES];
    INT_PTR Result;
    INT_PTR ReturnResult = MSGINA_DLG_SUCCESS;
    NTSTATUS Status;
    NTSTATUS SubStatus ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDOMAIN_CACHE_ENTRY Search ;
    UNICODE_STRING Domain_U ;
    ULONG Size ;
    HWND hwndDomain = GetDlgItem(hDlg, IDD_CHANGEPWD_DOMAIN);
    INT iDomainSelection = (INT)SendMessage(hwndDomain, CB_GETCURSEL, 0, 0);
    DOMAIN_PASSWORD_INFORMATION DomainInfo ;
    PWSTR UpnSuffix = NULL;
    BOOL RetryWithFlat = FALSE ;

    UserName[0] = TEXT('\0');
    Domain[0] = TEXT('\0');
    Password[0] = TEXT('\0');
    NewPassword[0] = TEXT('\0');
    ConfirmNewPassword[0] = TEXT('\0');
    ZeroMemory( &DomainInfo, sizeof( DomainInfo ) );

    GetDlgItemText(hDlg, IDD_CHANGEPWD_NAME, UserName, MAX_STRING_BYTES);
    if (wcschr(UserName, L'\\'))    // Found a backslash
    {       // wcscpy is OK since all buffers have the same size
        wcscpy(Domain, UserName);   // domain\username in Domain
        UpnSuffix = wcschr(Domain, L'\\');
        *UpnSuffix = 0;             // domain in Domain
        UpnSuffix++;                // points to username in Domain
        wcscpy(UserName, UpnSuffix);    // username in Username

            // Force iDomainSelection to CB_ERR since the combo is disabled
        iDomainSelection = CB_ERR;
            // we'll use the UpnSuffix has a trigger below to remember
            // about the backslash
    }

    //
    // The selected domain may really be a special entry: the local machine
    // (this is also set in the logon path (expired password))
    //

    if ( pPasswordData->Options & CHANGEPWD_OPTION_EDIT_DOMAIN )
    {
        Entry = (PDOMAIN_CACHE_ENTRY) SendMessage( hwndDomain, CB_GETITEMDATA, iDomainSelection, 0 );

        if ( CB_ERR == (ULONG_PTR) Entry )
        {
            Entry = NULL ;
        }

        if ( Entry == NULL )
        {
            if (NULL == UpnSuffix)
            {
                //
                // User typed in a new string, so there is no entry for this string.  Create
                // an entry here, and use it later.  
                //

                GetDlgItemText( hDlg, IDD_CHANGEPWD_DOMAIN, Domain, MAX_STRING_BYTES );
            }
            //else Domain was already set above (user entered domain\username)

            RtlInitUnicodeString( &Domain_U, Domain );

            Entry = DCacheCreateEntry( 
                        DomainNt4,
                        &Domain_U,
                        NULL,
                        NULL );


        }
        else 
        {
            //
            // Maybe DNS, maybe not:
            //

            if ( Entry->Type == DomainNt5 )
            {
                wcscpy( Domain, Entry->DnsName.Buffer );
                RetryWithFlat = TRUE ;
            }
            else 
            {
                wcscpy( Domain, Entry->FlatName.Buffer );
            }

            //
            // Reference it here.  The case above will create an entry with a reference
            // that we will need to deref when we're done.  So, bump it now to make it 
            // cleaner later.
            //

            DCacheReferenceEntry( Entry );
        }
    }
    else 
    {
        if (NULL == UpnSuffix)
        {
            //
            // Standalone case.  Force the machine name entry
            //

            Size = MAX_STRING_BYTES ;

            GetDlgItemText( hDlg, IDD_CHANGEPWD_DOMAIN, Domain, MAX_STRING_BYTES );

            //
            // If nothing there, use the domain from the logon:
            //

            if ( Domain[0] == L'\0' )
            {
                wcscpy( Domain, pGlobals->Domain );
            }
        }
        else
        {
            //
            // NT4 style name as detected above
            //
            // No need to do anything as Domain is already set.
        }

        RtlInitUnicodeString( &Domain_U, Domain );

        Entry = DCacheCreateEntry( 
                    (NULL == UpnSuffix) ? DomainMachine : DomainNt4,
                    &Domain_U,
                    NULL,
                    NULL );
    }


    if ( !Entry )
    {
        // No need to do cleanup here as we haven't read the passwords yet
        return DLG_FAILURE ;
    }

    GetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, Password, MAX_STRING_BYTES);
    GetDlgItemText(hDlg, IDD_CHANGEPWD_NEW, NewPassword, MAX_STRING_BYTES);
    GetDlgItemText(hDlg, IDD_CHANGEPWD_CONFIRM, ConfirmNewPassword, MAX_STRING_BYTES);

    // If we are forcing a NoDomainUI, populate the domain with the local machine name now
    if ((NULL == UpnSuffix) && (ForceNoDomainUI()))
    {
        DWORD chSize = ARRAYSIZE(Domain);
        
        if (!GetComputerName(Domain, &chSize))
        {
            *Domain = 0;
        }
    }

    //
    // If there is a at-sign in the name, assume that means that a UPN
    // attempt is being made.  Set the domain to NULL.
    //

    if ( wcschr( UserName, L'@' ) )
    {
        Domain[0] = TEXT('\0');
    }

    //
    // Validate user entries:
    //
    // Check that new passwords match
    //
    if (lstrcmp(NewPassword, ConfirmNewPassword) != 0) {
        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_NO_PASSWORD_CONFIRM,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        if (DLG_INTERRUPTED(Result)) {
            Result = SetInterruptFlag( MSGINA_DLG_FAILURE );
        }
        else
        {
            Result = MSGINA_DLG_FAILURE ;
        }

        ReturnResult = Result;
        goto Exit;
    }

    if ( Domain[0] == L'\0' )
    {
        UpnSuffix = wcschr( UserName, L'@' );

        if ( UpnSuffix == NULL )
        {
            Result = TimeoutMessageBox( hDlg, pGlobals,
                                        IDS_NO_DOMAIN_AND_NO_UPN,
                                        IDS_CHANGE_PASSWORD,
                                        MB_OK | MB_ICONEXCLAMATION,
                                        TIMEOUT_CURRENT );

            if (DLG_INTERRUPTED(Result)) {
                Result = SetInterruptFlag( MSGINA_DLG_FAILURE );
            }
            else
            {
                Result = MSGINA_DLG_FAILURE ;
            }
            ReturnResult = Result;
            goto Exit;
        }
        else
        {
            //
            // Ok, the UPN suffix is present.  Check if it is part of an
            // MIT domain.  MIT domains have the flat and DNS fields identical.
            //

            UpnSuffix++ ;
            Search = DCacheLocateEntry(
                        pGlobals->Cache,
                        UpnSuffix );

            if ( Search )
            {
                DCacheDereferenceEntry( Entry );
                Entry = Search ;
            }
        }
    }

    //
    // Check if the password exceeds the LM limit of 14 characters.
    //

    if ( ( lstrlen( NewPassword ) > LM20_PWLEN ) &&
         ( ( Entry->Type == DomainUPN ) ||
           ( Entry->Type == DomainMachine ) ||
           ( Entry->Type == DomainNt4 ) ||
           ( Entry->Type == DomainNt5 ) ) )
    {
        //
        // For long passwords, confirm with the user.
        //

        Result = TimeoutMessageBox(
                        hDlg, pGlobals,
                        IDS_LONG_PASSWORD_WARNING,
                        IDS_CHANGE_PASSWORD,
                        MB_OKCANCEL | MB_ICONEXCLAMATION,
                        TIMEOUT_CURRENT );


        if ( DLG_INTERRUPTED(Result) ) 
        {
            Result = SetInterruptFlag( MSGINA_DLG_FAILURE );
        }
        else
        {
            if ( Result == IDCANCEL )
            {
                Result = MSGINA_DLG_FAILURE ;
            }
        }

        if ( ResultNoFlags( Result ) == MSGINA_DLG_FAILURE )
        {
            ReturnResult = Result;
            goto Exit;
        }


                                
    }

    //
    // Call the Appropriate Change Password Engine: 
    //

    Status = ChangePasswordWorkers[ Entry->Type ](
                pPasswordData,
                UserName,
                Domain,
                Password,
                NewPassword,
                &SubStatus,
                &DomainInfo );

    if ( RetryWithFlat )
    {
        //
        // If we just used the DNS name, restore the flat name,
        // since all later comparisons on the name for stored
        // password update will be based on this
        //

        wcscpy( Domain, Entry->FlatName.Buffer );
    }

    if ( ( Status == STATUS_DOMAIN_CONTROLLER_NOT_FOUND ) ||
         ( Status == STATUS_CANT_ACCESS_DOMAIN_INFO ) ) 
    {

        Status = ChangePasswordWorkers[ Entry->Type ](
                    pPasswordData,
                    UserName,
                    Domain,
                    Password,
                    NewPassword,
                    &SubStatus,
                    &DomainInfo );

    }

    if ( NT_SUCCESS( Status ) )
    {

        Result = TimeoutMessageBox(hDlg,
                                   pGlobals,
                                   IDS_PASSWORD_CHANGED,
                                   IDS_CHANGE_PASSWORD,
                                   MB_OK | MB_ICONINFORMATION,
                                   TIMEOUT_CURRENT);


    } else {

         ReturnResult = MSGINA_DLG_FAILURE;

        //
        // Failure, explain it to the user
        //

        Result = HandleFailedChangePassword(hDlg,
                                            pGlobals,
                                            Status,
                                            UserName,
                                            Domain,
                                            SubStatus,
                                            &DomainInfo
                                            );
    }


    //
    // Only call other providers if the change password attempt succeeded.
    //

    if (NT_SUCCESS(Status)) {

        //
        // Update our own state:
        //

        UpdateWithChangedPassword(
                pGlobals,
                hDlg,
                (pPasswordData->Options & CHANGEPWD_OPTION_NO_UPDATE ? FALSE : TRUE ),          
                UserName,
                Domain,
                Password,
                NewPassword,
               NULL );

    }


    //
    // Find out what happened to the message box:
    //

    if ( Result != IDOK )
    {
        //
        // mbox was interrupted
        //

        ReturnResult = SetInterruptFlag( ReturnResult );
    }

Exit:
    DCacheDereferenceEntry( Entry );

        // Zeroize these buffers for obvious security reasons
        // Need to call this stub, otherwise the compiler optimize this out!
    MyZeroMemory(Password, sizeof(Password));
    MyZeroMemory(NewPassword, sizeof(NewPassword));
    MyZeroMemory(ConfirmNewPassword, sizeof(ConfirmNewPassword));
    return(ReturnResult);
}


/****************************************************************************\
*
* FUNCTION: HandleFailedChangePassword
*
* PURPOSE:  Tells the user why their change-password attempt failed.
*
* RETURNS:  MSGINA_DLG_FAILURE - we told them what the problem was successfully.
*           DLG_INTERRUPTED() - a set of return values - see winlogon.h
*
* HISTORY:
*
*   21-Sep-92 Davidc       Created.
*
\****************************************************************************/

INT_PTR
HandleFailedChangePassword(
    HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    PWCHAR UserName,
    PWCHAR Domain,
    NTSTATUS SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    INT_PTR Result;
    DWORD Win32Error ;
    TCHAR*    Buffer1 = NULL;
    TCHAR*    Buffer2 = NULL;
    TCHAR*    Buffer3 = NULL;

    LONGLONG  OneDay;

    Buffer1 = (TCHAR*) Alloc(MAX_STRING_BYTES * sizeof(TCHAR));
    Buffer2 = (TCHAR*) Alloc(MAX_STRING_BYTES * sizeof(TCHAR));
    Buffer3 = (TCHAR*) Alloc(MAX_STRING_BYTES * sizeof(TCHAR));

    if( (NULL == Buffer1) || (NULL == Buffer2) || (NULL == Buffer3) )
    {
        return MSGINA_DLG_FAILURE;
    }
    
    Buffer1[ 0 ] = L'\0';
    Buffer2[ 0 ] = L'\0';
    Buffer3[ 0 ] = L'\0';

    switch (Status) {

    case STATUS_CANT_ACCESS_DOMAIN_INFO:
    case STATUS_NO_SUCH_DOMAIN:

        LoadString(hDllInstance,
                   IDS_CHANGE_PWD_NO_DOMAIN,
                   Buffer1,
                   MAX_STRING_BYTES);

        _snwprintf(Buffer2, MAX_STRING_BYTES - 1, Buffer1, Domain);
        Buffer2[MAX_STRING_BYTES - 1] = 0;

        LoadString(hDllInstance,
                   IDS_CHANGE_PASSWORD,
                   Buffer1,
                   MAX_STRING_BYTES);

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
        break;


    case STATUS_NO_SUCH_USER:
    case STATUS_WRONG_PASSWORD_CORE:
    case STATUS_WRONG_PASSWORD:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_INCORRECT_NAME_OR_PWD_CHANGE,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);

        // Force re-entry of the old password
        if (GetWindowLong(GetDlgItem(hDlg, IDD_CHANGEPWD_OLD), GWL_STYLE) & WS_VISIBLE) {
            SetDlgItemText(hDlg, IDD_CHANGEPWD_OLD, NULL);
        }

        break;


    case STATUS_ACCESS_DENIED:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_NO_PERMISSION_CHANGE_PWD,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        break;


    case STATUS_ACCOUNT_RESTRICTION:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_ACCOUNT_RESTRICTION_CHANGE,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        break;

    case STATUS_BACKUP_CONTROLLER:

        Result = TimeoutMessageBox(hDlg, pGlobals, IDS_REQUIRES_PRIMARY_CONTROLLER,
                                         IDS_CHANGE_PASSWORD,
                                         MB_OK | MB_ICONEXCLAMATION,
                                         TIMEOUT_CURRENT);
        break;


    case STATUS_PASSWORD_RESTRICTION:


        if ( SubStatus == STATUS_UNSUCCESSFUL )
        {
            LoadString(hDllInstance, IDS_GENERAL_PASSWORD_SPEC, Buffer2, MAX_STRING_BYTES);
        }
        else 
        {

            if ( SubStatus == STATUS_ILL_FORMED_PASSWORD )
            {
                LoadString(hDllInstance, IDS_COMPLEX_PASSWORD_SPEC, Buffer1, MAX_STRING_BYTES);
            } else {
                LoadString(hDllInstance, IDS_PASSWORD_SPEC, Buffer1, MAX_STRING_BYTES);
            }
            // this is the way filetimes are generated
            OneDay = (LONGLONG)(-10000000) * 60 * 60 * 24;

            _snwprintf(Buffer2, MAX_STRING_BYTES - 1, Buffer1,
                DomainInfo->MinPasswordLength,
                DomainInfo->PasswordHistoryLength,
                (LONG)(DomainInfo->MinPasswordAge.QuadPart / OneDay)
                );
            Buffer2[MAX_STRING_BYTES - 1] = 0;
        }

        LoadString(hDllInstance, IDS_ENTER_PASSWORDS, Buffer1, MAX_STRING_BYTES);
        wcsncat(Buffer2, TEXT(" "), MAX_STRING_BYTES - lstrlen(Buffer2) - 1);
        wcsncat(Buffer2, Buffer1, MAX_STRING_BYTES - lstrlen(Buffer2) - 1);

        LoadString(hDllInstance, IDS_CHANGE_PASSWORD, Buffer1, MAX_STRING_BYTES );

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
        break;


#ifdef LATER
    //
    // LATER Check for minimum password age
    //
    if ( FALSE ) {
        int     PasswordAge = 0, RequiredAge = 0;
        TCHAR    Buffer1[MAX_STRING_BYTES];
        TCHAR    Buffer2[MAX_STRING_BYTES];

        LoadString(hDllInstance, IDS_PASSWORD_MINIMUM_AGE, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
        _snwprintf(Buffer2, sizeof(Buffer2) / sizeof( TCHAR ), Buffer1, PasswordAge, RequiredAge);

        LoadString(hDllInstance, IDS_NO_PERMISSION_CHANGE_PWD, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
        #_#_lstrcat(Buffer1, Buffer2);

        LoadString(hDllInstance, IDS_CHANGE_PASSWORD, Buffer2, sizeof(Buffer2) / sizeof( TCHAR ));

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer1,
                                              Buffer2,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
    }
#endif


    default:

        DebugLog((DEB_ERROR, "Change password failure status = 0x%lx\n", Status));

        LoadString(hDllInstance, IDS_UNKNOWN_CHANGE_PWD_FAILURE, Buffer1, MAX_STRING_BYTES);

        Win32Error = RtlNtStatusToDosError( Status );

        GetErrorDescription( Win32Error, Buffer3, MAX_STRING_BYTES );

        _snwprintf(Buffer2, MAX_STRING_BYTES - 1, Buffer1, Win32Error, Buffer3 );
        Buffer2[MAX_STRING_BYTES - 1] = 0;

        LoadString(hDllInstance, IDS_CHANGE_PASSWORD, Buffer1, MAX_STRING_BYTES);

        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TIMEOUT_CURRENT);
        break;
    }

    Free(Buffer1);
    Free(Buffer2);
    Free(Buffer3);

    return(Result);

    UNREFERENCED_PARAMETER(UserName);
}

BOOL IsAutologonUser(LPCTSTR szUser, LPCTSTR szDomain)
{
    BOOL fIsUser = FALSE;
    HKEY hkey = NULL;
    TCHAR szAutologonUser[UNLEN + 1];
    TCHAR szAutologonDomain[DNLEN + 1];
    TCHAR szTempDomainBuffer[DNLEN + 1];
    DWORD cbBuffer;
    DWORD dwType;

    *szTempDomainBuffer = 0;

    // Domain may be a null string. If this is the case...
    if (0 == *szDomain)
    {
        DWORD cchBuffer;

        // We really mean the local machine name
        // Point to our local buffer
        szDomain = szTempDomainBuffer;
        cchBuffer = ARRAYSIZE(szTempDomainBuffer);

        GetComputerName(szTempDomainBuffer, &cchBuffer);
    }

    // See if the domain and user name
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ, &hkey))
    {
        // Check the user name
        cbBuffer = sizeof (szAutologonUser);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, DEFAULT_USER_NAME_KEY, 0, &dwType, (LPBYTE) szAutologonUser, &cbBuffer))
        {
            // Does it match?
#pragma prefast(suppress: 400, "PREfast noise: lstrcmpi")
            if (0 == lstrcmpi(szAutologonUser, szUser))
            {
                // Yes. Now check domain
                cbBuffer = sizeof(szAutologonDomain);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, DEFAULT_DOMAIN_NAME_KEY, 0, &dwType, (LPBYTE) szAutologonDomain, &cbBuffer))
                {
                    // Make sure domain matches
#pragma prefast(suppress: 400, "PREfast noise: lstrcmpi")
                    if (0 == lstrcmpi(szAutologonDomain, szDomain))
                    {
                        // Success - the users match
                        fIsUser = TRUE;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return fIsUser;
}

NTSTATUS SetAutologonPassword(LPCWSTR szPassword)
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0L, (HANDLE)NULL, NULL);

    Status = LsaOpenPolicy(NULL, &ObjectAttributes, POLICY_CREATE_SECRET, &LsaHandle);
    if (!NT_SUCCESS(Status))
        return Status;

    RtlInitUnicodeString(&SecretName, DEFAULT_PASSWORD_KEY);
    RtlInitUnicodeString(&SecretValue, szPassword);

    Status = LsaStorePrivateData(LsaHandle, &SecretName, &SecretValue);
    LsaClose(LsaHandle);

    return Status;
}

NTSTATUS
NtChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    NTSTATUS Status ;
    NTSTATUS ProtocolStatus = STATUS_SUCCESS;
    PGLOBALS    pGlobals = pChangePasswordData->pGlobals ;
    PMSV1_0_CHANGEPASSWORD_REQUEST pChangePasswordRequest = NULL;
    PMSV1_0_CHANGEPASSWORD_RESPONSE pChangePasswordResponse = NULL;
    PWCHAR DomainU;
    PWCHAR UserNameU;
    PWCHAR PasswordU;
    PWCHAR NewPasswordU;
    int Length;
    ULONG RequestBufferSize;
    ULONG ResponseBufferSize;
    HANDLE ImpersonationHandle = NULL;
    ULONG MsvPackage;
    STRING PackageName;


    //
    // Determine request buffer size needed, including room for
    // strings.  Set string pointers to offsets as we step through
    // sizing each one.
    //
    RequestBufferSize = sizeof(*pChangePasswordRequest);

    UserNameU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(UserName)+1) * sizeof(WCHAR);

    DomainU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(Domain)+1) * sizeof(WCHAR);

    PasswordU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(OldPassword)+1) * sizeof(WCHAR);

    NewPasswordU = UIntToPtr(RequestBufferSize);
    RequestBufferSize += (lstrlen(NewPassword)+1) * sizeof(WCHAR);

    //
    // Allocate request buffer
    //
    pChangePasswordRequest = Alloc(RequestBufferSize);
    if (NULL == pChangePasswordRequest) {
        DebugLog((DEB_ERROR, "cannot allocate change password request buffer (%ld bytes).", RequestBufferSize));
        return MSGINA_DLG_FAILURE;
    }

    //
    // Fixup string offsets to string pointers for request.
    //
    UserNameU    = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)UserNameU);
    DomainU      = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)DomainU);
    PasswordU    = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)PasswordU);
    NewPasswordU = (PVOID) ((PBYTE)pChangePasswordRequest + (ULONG_PTR)NewPasswordU);

    //
    // Setup MSV1_0ChangePassword request.
    //
    pChangePasswordRequest->MessageType = MsV1_0ChangePassword;

    // strings are already unicode, just copy them // lhb tracks //REVIEW
    lstrcpy((LPTSTR)UserNameU,UserName);
    lstrcpy((LPTSTR)DomainU,Domain);
    lstrcpy((LPTSTR)PasswordU,OldPassword);
    lstrcpy((LPTSTR)NewPasswordU,NewPassword);

    Length = lstrlen(UserName);
    UserNameU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->AccountName,
        UserNameU
        );
    Length = lstrlen(Domain);
    DomainU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->DomainName,
        DomainU
        );
    Length = lstrlen(OldPassword);
    PasswordU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->OldPassword,
        PasswordU
        );
    Length = lstrlen(NewPassword);
    NewPasswordU[Length] = 0;
    RtlInitUnicodeString(
        &pChangePasswordRequest->NewPassword,
        NewPasswordU
        );


    //
    // Make sure the passwords are short enough that we can run-encode them.
    //

    if ((pChangePasswordRequest->OldPassword.Length > 127 * sizeof( WCHAR ) ) ||
        (pChangePasswordRequest->NewPassword.Length > 127 * sizeof( WCHAR ) )) {

        Status = STATUS_ILL_FORMED_PASSWORD;

    } else {

        HidePassword(NULL,&pChangePasswordRequest->OldPassword);
        HidePassword(NULL,&pChangePasswordRequest->NewPassword);

        Status = STATUS_SUCCESS ;
    }

    //
    // If that succeeded, try to change the password
    //

    if (NT_SUCCESS(Status)) {
        //
        // This could take some time, put up a wait cursor
        //

        SetupCursor(TRUE);

        //
        // Call off to the authentication package (MSV/NTLM) to do the work,  This
        // is the NT change password function.  The Kerb one calls the kerb package.
        //

        RtlInitString(&PackageName, MSV1_0_PACKAGE_NAME );
        Status = LsaLookupAuthenticationPackage (
                    pGlobals->LsaHandle,
                    &PackageName,
                    &MsvPackage
                    );

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to find %s authentication package, status = 0x%lx",
                    PackageName.Buffer, Status));

            Status = MSGINA_DLG_FAILURE;
            goto Exit;
        }


        //
        // We want to impersonate if and only if the user is actually logged
        // on.  Otherwise we'll be impersonating SYSTEM, which is bad.
        //

        if (pChangePasswordData->Impersonate) {

            ImpersonationHandle = ImpersonateUser(
                                      &pGlobals->UserProcessData,
                                      NULL
                                      );

            if (NULL == ImpersonationHandle) {
                DebugLog((DEB_ERROR, "cannot impersonate user"));
                Status = MSGINA_DLG_FAILURE;
                goto Exit;
            }
        }

        //
        // Tell msv1_0 whether or not we're impersonating.
        //

        pChangePasswordRequest->Impersonating = (UCHAR)pChangePasswordData->Impersonate;

        Status = LsaCallAuthenticationPackage(
                     pGlobals->LsaHandle,
                     MsvPackage,
                     pChangePasswordRequest,
                     RequestBufferSize,
                     (PVOID)&pChangePasswordResponse,
                     &ResponseBufferSize,
                     &ProtocolStatus
                     );

        if (pChangePasswordData->Impersonate) {

            if (!StopImpersonating(ImpersonationHandle)) {

                DebugLog((DEB_ERROR, "AttemptPasswordChange: Failed to revert to self"));

                //
                // Blow up
                //

                ASSERT(FALSE);
            }
        }

        //
        // Restore the normal cursor
        //

        SetupCursor(FALSE);
    }

    //
    // Get the most informative status code
    //

    if ( NT_SUCCESS(Status) ) {
        Status = ProtocolStatus;
    }
    else
    {
        DebugLog((DEB_TRACE, "FAILED in call to LsaCallAuthenticationPackage, status %x\n", Status ));

    }

    if (NT_SUCCESS(Status)) {

        //
        // Success
        //

        //
        // if they changed their logon password, update the
        // change time in their profile info so we don't keep
        // pestering them.
        //

        if ( (_wcsicmp( pGlobals->Domain, Domain ) == 0) &&
             (_wcsicmp( pGlobals->UserName, UserName ) == 0 ))
        {

            //
            // This is code to handle the disconnected (preferred) domain.  This
            // was to be devl-only code and removed eventually, but some customers
            // liked it so much, it stayed.
            //

            {
                HKEY Key ;
                int err ;
                PWSTR PreferredDomain ;
                DWORD Type ;
                DWORD Size ;
                NET_API_STATUS NetStatus ;

                err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TEXT("System\\CurrentControlSet\\Control\\Lsa\\MSV1_0"),
                                    0,
                                    KEY_READ,
                                    &Key );

                if ( err == 0 )
                {
                    Size = 0 ;

                    err = RegQueryValueEx( Key,
                                           TEXT("PreferredDomain" ),
                                           NULL,
                                           &Type,
                                           NULL,
                                           &Size );

                    if ( err == 0 )
                    {
                        PreferredDomain = LocalAlloc( LMEM_FIXED, Size );

                        if ( PreferredDomain )
                        {
                            err = RegQueryValueEx( Key,
                                                   TEXT("PreferredDomain"),
                                                   NULL,
                                                   &Type,
                                                   (PBYTE) PreferredDomain,
                                                   &Size );

                            if ( err == 0 )
                            {
                                //
                                // If we are logged on to our preferred domain, don't
                                // do the update magic.
                                //

                                if ( _wcsicmp( PreferredDomain, pGlobals->Domain ) == 0 )
                                {
                                    err = 2 ;
                                }
                            }

                            if ( err == 0 )
                            {
                                NetStatus = NetUserChangePassword(
                                                PreferredDomain,
                                                UserName,
                                                OldPassword,
                                                NewPassword );

                                if ( NetStatus )
                                {
                                    DebugLog((DEB_ERROR, "Could not update password on %ws, %x\n", PreferredDomain, NetStatus ));
                                }
                            }

                            LocalFree( PreferredDomain );
                        }

                    }

                    RegCloseKey( Key );

                }

            }
        }
    }
    else 
    {
        *SubStatus = STATUS_UNSUCCESSFUL ;

        if ( pChangePasswordResponse )
        {
            if ( pChangePasswordResponse->PasswordInfoValid )
            {
                *DomainInfo = pChangePasswordResponse->DomainPasswordInfo ;
            }
        }

        if ( Status == STATUS_PASSWORD_RESTRICTION )
        {
            *SubStatus = STATUS_PASSWORD_RESTRICTION ;

            if ( pChangePasswordResponse->PasswordInfoValid )
            {
                if ( pChangePasswordResponse->DomainPasswordInfo.PasswordProperties & DOMAIN_PASSWORD_COMPLEX )
                {
                    *SubStatus = STATUS_ILL_FORMED_PASSWORD ;
                }

            }
        }
    }

    //
    // Free up the return buffer
    //

    if (pChangePasswordResponse != NULL) {
        LsaFreeReturnBuffer(pChangePasswordResponse);
    }

Exit:
    //
    // Free up the request buffer
    //
    if (pChangePasswordRequest)
    {
            // this buffer contains passwords so we zeroize it before freeing it
        ZeroMemory(pChangePasswordRequest, RequestBufferSize);
        Free(pChangePasswordRequest);
    }
    return Status ;
}

NTSTATUS
MitChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       DomainName,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   pSubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    PGLOBALS pGlobals = pChangePasswordData->pGlobals ;
    NTSTATUS Status;
    STRING Name;
    ULONG PackageId;
    PVOID Response = NULL ;
    ULONG ResponseSize;
    NTSTATUS SubStatus;
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize = 0;
    UNICODE_STRING User,Domain,OldPass,NewPass;

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                pGlobals->LsaHandle,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    if ( ChangeRequest == NULL )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup ;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    //
    // We are running as the caller, so state we are impersonating
    //

    ChangeRequest->Impersonating = TRUE;

    Status = LsaCallAuthenticationPackage(
                pGlobals->LsaHandle,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
            *pSubStatus = STATUS_UNSUCCESSFUL ;
        } 
        else 
        {
            *pSubStatus = SubStatus;
        }
    }

Cleanup:
    if (Response != NULL)
    {
        LsaFreeReturnBuffer(Response);
    }

    if (ChangeRequest != NULL)
    {
            // this buffer contains passwords so we zeroize it before freeing it
        ZeroMemory(ChangeRequest, ChangeSize);
        LocalFree(ChangeRequest);
    }
    return(Status);
}

NTSTATUS
ProviderChangePassword(
    PCHANGE_PASSWORD_DATA pChangePasswordData,
    PWSTR       UserName,
    PWSTR       Domain,
    PWSTR       OldPassword,
    PWSTR       NewPassword,
    PNTSTATUS   SubStatus,
    DOMAIN_PASSWORD_INFORMATION * DomainInfo
    )
{
    WLX_MPR_NOTIFY_INFO MprInfo;
    DWORD Result ;
    PGLOBALS pGlobals = pChangePasswordData->pGlobals ;

    MprInfo.pszUserName = DupString( UserName );
    MprInfo.pszDomain = DupString( Domain );
    MprInfo.pszOldPassword = DupString( OldPassword );
    MprInfo.pszPassword = DupString( NewPassword );


    //
    // Hide this dialog and pass our parent as the owner
    // of any provider dialogs
    //


    Result = pWlxFuncs->WlxChangePasswordNotifyEx(
                                    pGlobals->hGlobalWlx,
                                    &MprInfo,
                                    0,
                                    Domain,
                                    NULL );



    return STATUS_SUCCESS ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\brand.c ===
/*----------------------------------------------------------------------------
/ Title;
/   util.c
/
/ Authors;
/   David De Vorchik (daviddv)
/
/   Modified by dsheldon
/
/ Notes;
/   Code for handling bitmap images placed in the dialogs
/----------------------------------------------------------------------------*/
#include "msgina.h"

#include <tchar.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <winbrand.h>


//
// Loaded resources for the branding images that we display
//

HPALETTE g_hpalBranding = NULL;           // palette the applies to all images

HBITMAP g_hbmOtherDlgBrand = NULL;
SIZE g_sizeOtherDlgBrand = { 0 };
HBRUSH g_hbrOtherDlgBrand[2] = { 0 };

HBITMAP g_hbmLogonBrand = NULL;
SIZE g_sizeLogonBrand = { 0 };
HBRUSH g_hbrLogonBrand[2] = { 0 };

HBITMAP g_hbmBand = NULL;
SIZE g_sizeBand = { 0 };

BOOL g_fDeepImages = FALSE;
BOOL g_fNoPalleteChanges = FALSE;

VOID ReLoadBrandingImages(
    BOOL fDeepImages,
    BOOL* pfTextOnLarge, 
    BOOL* pfTextOnSmall);


/*-----------------------------------------------------------------------------
/ LoadImageGetSize
/ ----------------
/   Load the image returning the given HBITMAP, having done this we can
/   then get the size from it.
/
/ In:
/   hInstance,resid = object to be loaded.
/   pSize = filled with size information about the object
/
/ Out:
/   HBITMAP / == NULL if nothing loaded
/----------------------------------------------------------------------------*/
HBITMAP LoadBitmapGetSize(HINSTANCE hInstance, UINT resid, SIZE* pSize)
{
    HBITMAP hResult = NULL;
    DIBSECTION ds = {0};

    //
    // Load the image from the resource then lets get the DIBSECTION header
    // from the bitmap object we can then read the size from it and
    // return that to the caller.
    //

    hResult = LoadImage(hInstance, MAKEINTRESOURCE(resid),
                            IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if ( hResult )
    {
        GetObject(hResult, sizeof(ds), &ds);

        pSize->cx = ds.dsBmih.biWidth;
        pSize->cy = ds.dsBmih.biHeight;

        //
        // pSize->cy -ve then make +ve, -ve indicates bits are vertically
        // flipped (bottom left, top left).
        //

        if ( pSize->cy < 0 )
            pSize->cy -= 0;
    }

    return hResult;
}



/*-----------------------------------------------------------------------------
/ MoveChildren
/ ------------
/   Move the controls in the given by the specified delta.

/ In:
/   hWnd = window to move
/   dx/dy = delta to be applied
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID MoveChildren(HWND hWnd, INT dx, INT dy)
{
    HWND hWndSibling;
    RECT rc;

    //
    // walk all the children in the dialog adjusting their positions
    // by the delta.
    //

    for ( hWndSibling = GetWindow(hWnd, GW_CHILD) ; hWndSibling ; hWndSibling = GetWindow(hWndSibling, GW_HWNDNEXT))
    {
        GetWindowRect(hWndSibling, &rc);
        MapWindowPoints(NULL, GetParent(hWndSibling), (LPPOINT)&rc, 2);
        OffsetRect(&rc, dx, dy);

        SetWindowPos(hWndSibling, NULL,
                     rc.left, rc.top, 0, 0,
                     SWP_NOZORDER|SWP_NOSIZE);
    }

    //
    // having done that then lets adjust the parent size accordingl.
    //

    GetWindowRect(hWnd, &rc);
    MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT)&rc, 2);

    SetWindowPos(hWnd, NULL,
                 0, 0, (rc.right-rc.left)+dx, (rc.bottom-rc.top)+dy,
                 SWP_NOZORDER|SWP_NOMOVE);
}


/*-----------------------------------------------------------------------------
/ MoveControls
/ ------------
/   Load the image and add the control to the dialog.
/
/ In:
/   hWnd = window to move controls in
/   aID, cID = array of control ids to be moved
/   dx, dy = deltas to apply to controls
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
VOID MoveControls(HWND hWnd, UINT* aID, INT cID, INT dx, INT dy, BOOL fSizeWnd)
{
    RECT rc;

    // if hWnd is mirrored then move the controls in the other direction.
    if (GetWindowLongPtr(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) 
    {
        dx = -dx;
    }

    while ( --cID >= 0 )
    {
        HWND hWndCtrl = GetDlgItem(hWnd, aID[cID]);

        if ( hWndCtrl )
        {
            GetWindowRect(hWndCtrl, &rc);
            MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);
            OffsetRect(&rc, dx, dy);
            SetWindowPos(hWndCtrl, NULL, rc.left, rc.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
        }
    }

    if ( fSizeWnd )
    {
        GetWindowRect(hWnd, &rc);
        MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT)&rc, 2);
        SetWindowPos(hWnd, NULL,
                     0, 0, (rc.right-rc.left)+dx, (rc.bottom-rc.top)+dy,
                     SWP_NOZORDER|SWP_NOMOVE);
    }
}


/*-----------------------------------------------------------------------------
/ LoadBrandingImages
/ ------------------
/   Load the resources required to brand the gina.  This copes with
/   the depth changes.
/
/ In:
/ Out:
/   -
/----------------------------------------------------------------------------*/

#define REGSTR_CUSTOM_BRAND /*HKEY_LOCAL_MACHINE\*/ \
TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CustomBrand\\")

// bitmap subkeys
#define REGSTR_OTHERDLG_4BIT TEXT("{F20B21BE-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_OTHERDLG_8BIT TEXT("{F20B21BF-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_LOGON_4BIT TEXT("{F20B21C0-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_LOGON_8BIT TEXT("{F20B21C1-5E3D-11d2-8789-68CB20524153}")
#define REGSTR_BAND_4BIT TEXT("{F20B21C4-5E3D-11d2-8789-68CB20524153}")
// The palette is read from the 8-bit band if applicable
#define REGSTR_BAND_8BIT TEXT("{F20B21C5-5E3D-11d2-8789-68CB20524153}")

#define REGSTR_PAINTTEXT_VAL  TEXT("DontPaintText")  

// The default values of these subkeys should be of the form "<dllname>,-<resid>"
// Example: msgina.dll,-130
// The specified bitmap will be loaded from the dll & resid specified.


BOOL GetBrandingModuleAndResid(LPCTSTR szRegKeyRoot, LPCTSTR szRegKeyLeaf, UINT idDefault, 
                               HINSTANCE* phMod, UINT* pidRes, BOOL* pfPaintText)
{
    TCHAR* szRegKey = NULL;
    size_t bufferSize = 0;
    BOOL fCustomBmpUsed = FALSE;
    HKEY hkey;
    LONG lResult;
    *phMod = NULL;
    *pidRes = 0;
    *pfPaintText = TRUE;

    bufferSize =
        (_tcslen(szRegKeyRoot) + _tcslen(szRegKeyLeaf) + 1) * sizeof(TCHAR);
    szRegKey = (TCHAR*)LocalAlloc(LPTR,  bufferSize);
    if( NULL == szRegKey )
    {
        goto recover;
    }

    _tcscpy(szRegKey, szRegKeyRoot);
    _tcscat(szRegKey, szRegKeyLeaf);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0 /*reserved*/,
        KEY_READ, &hkey);
    LocalFree(szRegKey);

    if (lResult == ERROR_SUCCESS)
    {
        TCHAR szUnexpanded[MAX_PATH + 1];
        TCHAR szModAndId[MAX_PATH + 1];
        DWORD dwType;
        DWORD cbData = sizeof(szUnexpanded);

        lResult = RegQueryValueEx(hkey, NULL /*default value*/, NULL /*reserved*/,
            &dwType, (LPBYTE) szUnexpanded, &cbData);

        if (lResult == ERROR_SUCCESS)
        {
            // expand any environment strings here
            if (ExpandEnvironmentStrings(szUnexpanded, szModAndId, 
                ARRAYSIZE(szModAndId)) != 0)
            {
                // Get the module name and id number
                LPTSTR pchComma;
                int NegResId;

                pchComma = _tcsrchr(szModAndId, TEXT(','));
                
                // Ensure that the resid is present
                if (pchComma)
                {
                    *pchComma = TEXT('\0');

                    // Now szModAndId is just the module string - get the resid
                    NegResId = _ttoi(pchComma + 1);

                    // Ensure this is a NEGATIVE number!
                    if (NegResId < 0)
                    {
                        BOOL fDontPaintText;

                        // We're good to go
                        *pidRes = 0 - NegResId;

                        // Now load the specified module
                        *phMod = LoadLibrary(szModAndId);

                        fCustomBmpUsed = (*phMod != NULL);

                        // Now see if we need to paint text on this bitmap
                        cbData = sizeof(BOOL);
                        RegQueryValueEx(hkey, REGSTR_PAINTTEXT_VAL, NULL,
                            &dwType, (LPBYTE) &fDontPaintText, &cbData);

                        *pfPaintText = !fDontPaintText;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

recover:
    // If we didn't get a custom bitmap, use the default
    if (!fCustomBmpUsed)
    {
        *pidRes = idDefault;
        *phMod = hDllInstance;
    }

    return fCustomBmpUsed;
}

void LoadBranding(BOOL fDeepImages, BOOL* pfTextOnLarge, BOOL* pfTextOnSmall)
{
    HINSTANCE hResourceDll;
    UINT idBitmap;
    LPTSTR pszRegkeyLeafLogonBmp;
    LPTSTR pszRegkeyLeafOtherDlgBmp;
    UINT idDefaultSmall;
    UINT idDefaultLarge;
    BOOL fWinBrandDll = FALSE;
    HINSTANCE hWinBrandDll = NULL;

    pszRegkeyLeafOtherDlgBmp = fDeepImages ? REGSTR_OTHERDLG_8BIT : REGSTR_OTHERDLG_4BIT;
    pszRegkeyLeafLogonBmp = fDeepImages ? REGSTR_LOGON_8BIT : REGSTR_LOGON_4BIT;

    if (IsOS(OS_APPLIANCE))
    {
        fWinBrandDll = TRUE;
        idDefaultSmall = fDeepImages ? IDB_SMALL_SRVAPP_8_MSGINA_DLL : IDB_SMALL_SRVAPP_4_MSGINA_DLL;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_SRVAPP_8_MSGINA_DLL : IDB_MEDIUM_SRVAPP_4_MSGINA_DLL;
    }
    else if (IsOS(OS_DATACENTER))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_DCS_8 : IDB_SMALL_DCS_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_DCS_8 : IDB_MEDIUM_DCS_4;
    }
    else if (IsOS(OS_ADVSERVER))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_ADV_8 : IDB_SMALL_ADV_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_ADV_8 : IDB_MEDIUM_ADV_4;
    }
    else if (IsOS(OS_SMALLBUSINESSSERVER))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_SBS_8 : IDB_SMALL_SBS_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_SBS_8 : IDB_MEDIUM_SBS_4;
    }
    else if (IsOS(OS_BLADE))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_BLA_8 : IDB_SMALL_BLA_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_BLA_8 : IDB_MEDIUM_BLA_4;
    }
    else if (IsOS(OS_SERVER))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_SRV_8 : IDB_SMALL_SRV_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_SRV_8 : IDB_MEDIUM_SRV_4;
    }
    else if (IsOS(OS_PERSONAL))
    {
        idDefaultSmall = fDeepImages ? IDB_SMALL_PER_8 : IDB_SMALL_PER_4;
        idDefaultLarge = fDeepImages ? IDB_MEDIUM_PER_8 : IDB_MEDIUM_PER_4;
    }
    else
    {
        if (IsOS(OS_EMBEDDED))
        {
            idDefaultSmall = fDeepImages ? IDB_SMALL_PROEMB_8 : IDB_SMALL_PROEMB_4;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PROEMB_8 : IDB_MEDIUM_PROEMB_4;
        }
        else if (IsOS(OS_TABLETPC))
        {
            fWinBrandDll = TRUE;
            idDefaultSmall = fDeepImages ? IDB_SMALL_PROTAB_8_MSGINA_DLL : IDB_SMALL_PROTAB_4_MSGINA_DLL;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PROTAB_8_MSGINA_DLL : IDB_MEDIUM_PROTAB_4_MSGINA_DLL;
        }
        else if (IsOS(OS_MEDIACENTER))
        {
            fWinBrandDll = TRUE;
            idDefaultSmall = fDeepImages ? IDB_SMALL_PROMED_8_MSGINA_DLL : IDB_SMALL_PROMED_4_MSGINA_DLL;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PROMED_8_MSGINA_DLL : IDB_MEDIUM_PROMED_4_MSGINA_DLL;
        }
        else
        {
            idDefaultSmall = fDeepImages ? IDB_SMALL_PRO_8 : IDB_SMALL_PRO_4;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PRO_8 : IDB_MEDIUM_PRO_4;
        }
    }

    //
    // If this is a resource in the special Windows branding resource DLL,
    // attempt to load the DLL. If this fails, just default to the
    // Professional bitmaps.
    //

    if (fWinBrandDll)
    {
        hWinBrandDll = LoadLibraryEx(TEXT("winbrand.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);

        if (hWinBrandDll == NULL)
        {
            idDefaultSmall = fDeepImages ? IDB_SMALL_PRO_8 : IDB_SMALL_PRO_4;
            idDefaultLarge = fDeepImages ? IDB_MEDIUM_PRO_8 : IDB_MEDIUM_PRO_4;
        }
    }
    
    // Load the bitmap
    GetBrandingModuleAndResid(REGSTR_CUSTOM_BRAND, pszRegkeyLeafOtherDlgBmp, idDefaultSmall,
        &hResourceDll, &idBitmap, pfTextOnSmall);

    if ((hResourceDll == hDllInstance) && (hWinBrandDll != NULL))
    {
        hResourceDll = hWinBrandDll;
    }

    if (g_hbmOtherDlgBrand != NULL)
    {
        DeleteObject(g_hbmOtherDlgBrand);
        g_hbmOtherDlgBrand = NULL;
    }

    g_hbmOtherDlgBrand = LoadBitmapGetSize(hResourceDll, idBitmap, &g_sizeOtherDlgBrand);
    
    //
    // If this is the special Windows branding resource DLL, don't free it
    // just yet; we probably need it for the default large bitmap also.
    //
    
    if ((hResourceDll != hDllInstance) && (hResourceDll != hWinBrandDll))
    {
        FreeLibrary(hResourceDll);
    }

    GetBrandingModuleAndResid(REGSTR_CUSTOM_BRAND, pszRegkeyLeafLogonBmp, idDefaultLarge,
        &hResourceDll, &idBitmap, pfTextOnLarge);

    if ((hResourceDll == hDllInstance) && (hWinBrandDll != NULL))
    {
        hResourceDll = hWinBrandDll;
    }

    if (g_hbmLogonBrand != NULL)
    {
        DeleteObject(g_hbmLogonBrand);
        g_hbmLogonBrand = NULL;
    }

    g_hbmLogonBrand = LoadBitmapGetSize(hResourceDll, idBitmap, &g_sizeLogonBrand);

    //
    // If this is the special Windows branding resource DLL, or a normal custom
    // bitmap DLL, free it now.
    //
    
    if ((hResourceDll != hDllInstance) && (hResourceDll != hWinBrandDll))
    {
        FreeLibrary(hResourceDll);
    }

    //
    // If the special windows branding resource DLL was loaded, free it now.
    //

    if (hWinBrandDll != NULL)
    {
        FreeLibrary(hWinBrandDll);
    }
}

void LoadBand(BOOL fDeepImages)
{
    HINSTANCE hResourceDll;
    UINT idBitmap;
    BOOL fPaintText; // Ignored

    // Workstation bitmap load - see if we have custom bmp
    GetBrandingModuleAndResid(REGSTR_CUSTOM_BRAND,
        fDeepImages ? REGSTR_BAND_8BIT : REGSTR_BAND_4BIT,
        fDeepImages ? IDB_BAND_8 : IDB_BAND_4, &hResourceDll, &idBitmap, &fPaintText);

    if (g_hbmBand != NULL)
    {
        DeleteObject(g_hbmBand);
        g_hbmBand = NULL;
    }

    g_hbmBand = LoadBitmapGetSize(hResourceDll, idBitmap, &g_sizeBand);

    if (hResourceDll != hDllInstance)
    {
        FreeLibrary(hResourceDll);
    }
}

VOID CreateBorderBrushes(HDC hdc, HBITMAP hbm, SIZE* psize, HBRUSH* phbr)
{
    COLORREF crLeft;
    COLORREF crRight;

    //
    // Delete any existing brushes.
    //

    if (phbr[0] != NULL)
    {
        //
        // If we created a separate brush for the right, delete it.
        //

        if (phbr[1] != phbr[0])
        {
            DeleteObject(phbr[1]);
        }
        phbr[1] = NULL;

        DeleteObject(phbr[0]);
        phbr[0] = NULL;
    }

    //
    // Create brushes for filling the border when the dialog box is wider than
    // the branding bitmap. First create a brush matching the upper left pixel
    // of the bitmap. Next, create one for the upper right, if different.
    //

    if (SelectObject(hdc, hbm) != NULL)
    {
        crLeft = GetPixel(hdc, 0, 0);
        if (crLeft != CLR_INVALID)
        {
            phbr[0] = CreateSolidBrush(crLeft);
            if (phbr[0] != NULL)
            {
                crRight = GetPixel(hdc, psize->cx - 1, 0);
                if ((crRight != CLR_INVALID) && (crRight != crLeft))
                {
                    phbr[1] = CreateSolidBrush(crRight);
                }
            }
        }
    }

    if (phbr[0] == NULL)
    {
        phbr[0] = GetStockObject(WHITE_BRUSH);
    }

    //
    // If we don't have a separate brush for the right border, just use the
    // same brush as for the left border.
    //

    if (phbr[1] == NULL)
    {
        phbr[1] = phbr[0];
    }
}

VOID ReLoadBrandingImages(
    BOOL fDeepImages,
    BOOL* pfTextOnLarge, 
    BOOL* pfTextOnSmall)
{
    HDC hDC;
    RGBQUAD rgb[256];
    LPLOGPALETTE pLogPalette;
    INT i;
    BOOL fTextOnLarge;
    BOOL fTextOnSmall;
    
    hDC = CreateCompatibleDC(NULL);

    if ( !hDC )
        return;

    //
    // Load the resources we need
    //

    LoadBranding(
        fDeepImages, 
        (pfTextOnLarge == NULL) ? &fTextOnLarge : pfTextOnLarge, 
        (pfTextOnSmall == NULL) ? &fTextOnSmall : pfTextOnSmall);
    LoadBand(fDeepImages);

    //
    // if we loaded the deep images then take the palette from the 'animated band' bitmap
    // and use that as the one for all the images we are creating.
    //

    if (g_hpalBranding != NULL)
    {
        DeleteObject(g_hpalBranding);
        g_hpalBranding = NULL;
    }

    if ( fDeepImages )
    {
        SelectObject(hDC, g_hbmBand);
        GetDIBColorTable(hDC, 0, 256, rgb);

        pLogPalette = (LPLOGPALETTE)LocalAlloc(LPTR, sizeof(LOGPALETTE)*(sizeof(PALETTEENTRY)*256));

        if ( pLogPalette )
        {
            pLogPalette->palVersion = 0x0300;
            pLogPalette->palNumEntries = 256;

            for ( i = 0 ; i < 256 ; i++ )
            {
                pLogPalette->palPalEntry[i].peRed = rgb[i].rgbRed;
                pLogPalette->palPalEntry[i].peGreen = rgb[i].rgbGreen;
                pLogPalette->palPalEntry[i].peBlue = rgb[i].rgbBlue;
                //pLogPalette->palPalEntry[i].peFlags = 0;
            }
            
            g_hpalBranding = CreatePalette(pLogPalette);
            LocalFree(pLogPalette);
        }
    }

    CreateBorderBrushes(hDC, g_hbmLogonBrand, &g_sizeLogonBrand, g_hbrLogonBrand);
    CreateBorderBrushes(hDC, g_hbmOtherDlgBrand, &g_sizeOtherDlgBrand, g_hbrOtherDlgBrand);

    DeleteDC(hDC);
}


BOOL DeepImages(BOOL fNoPaletteChanges)
{
    BOOL fDeepImages = FALSE;
    HDC hDC;
    INT nDeviceBits;
    
    //
    // Should we load the "nice" 8 bit per pixel images, or the low res
    // 4 bit versions.
    //

    hDC = CreateCompatibleDC(NULL);

    if ( !hDC )
        return(FALSE);

    nDeviceBits = GetDeviceCaps(hDC, BITSPIXEL);

    if (nDeviceBits > 8)
    {
        fDeepImages = TRUE;
    }

    // If the caller doesn't want to deal with 256-color palette
    // changes, give them 4-bit images.
    if (fNoPaletteChanges && (nDeviceBits == 8))
    {
        fDeepImages = FALSE;
    }   

    DeleteDC(hDC);

    return(fDeepImages);
}

VOID LoadBrandingImages(BOOL fNoPaletteChanges, 
                        BOOL* pfTextOnLarge, BOOL* pfTextOnSmall)
{
    BOOL fDeepImages;

    fDeepImages = DeepImages(fNoPaletteChanges);
    
    ReLoadBrandingImages(fDeepImages, pfTextOnLarge, pfTextOnSmall);

    g_fDeepImages = fDeepImages;  
    g_fNoPalleteChanges = fNoPaletteChanges;  
}

/*-----------------------------------------------------------------------------
/ SizeForBranding
/ ---------------
/   Adjust the size of the dialog to allow for branding.
/
/ In:
/   hWnd = size the window to account for the branding images we are going to
/          add to it.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

VOID SizeForBranding(HWND hWnd, BOOL fLargeBrand)
{
    //
    // All windows have two branding imges, the banner and the band.
    // therefore lets adjust for those.
    //

    if (fLargeBrand)
    {
        MoveChildren(hWnd, 0, g_sizeLogonBrand.cy);
    }
    else
    {
        MoveChildren(hWnd, 0, g_sizeOtherDlgBrand.cy);
    }

    MoveChildren(hWnd, 0, g_sizeBand.cy);
}


/*-----------------------------------------------------------------------------
/ PaintFullBranding
/ -------------
/   Paints the full branding, which includes the copyright notice and
/   "Build on NT" into the given DC.  So here we must realize the palette
/   we want to show and then paint the images.  If fBandOnly is TRUE
/   then we only paint the band.  This is used by the animation code.
/
/ In:
/   hDC = DC to paint into
/   fBandOnly = paint the band only
/   nBackground = the system color index for the bkgnd.
/
/ Out:
/   -
/ dsheldon copied from PaintBranding and modified 11/16/98
/----------------------------------------------------------------------------*/
BOOL PaintBranding(HWND hWnd, HDC hDC, INT bandOffset, BOOL fBandOnly, BOOL fLargeBrand, int nBackground)
{
    HDC hdcBitmap;
    HPALETTE oldPalette = NULL;
    HBITMAP oldBitmap;
    RECT rc = { 0 };
    INT cxRect, cxBand;
    SIZE* psizeBrand;
    HBITMAP* phbmBrand;
    HBRUSH *phbrBackground;
    BOOL fTemp;

    fTemp = DeepImages(g_fNoPalleteChanges);
    if (g_fDeepImages != fTemp)
    {
        g_fDeepImages = fTemp;
        ReLoadBrandingImages(fTemp, NULL, NULL);
    }

    // See if we're working with the large or small branding
    if (fLargeBrand)
    {
        psizeBrand = &g_sizeLogonBrand;
        phbmBrand = &g_hbmLogonBrand;
        phbrBackground = g_hbrLogonBrand;
    }
    else
    {
        psizeBrand = &g_sizeOtherDlgBrand;
        phbmBrand = &g_hbmOtherDlgBrand;
        phbrBackground = g_hbrOtherDlgBrand;
    }

    hdcBitmap = CreateCompatibleDC(hDC);

    if ( !hdcBitmap )
        return FALSE;

    GetClientRect(hWnd, &rc);

    if ( g_hpalBranding )
        oldPalette = SelectPalette(hDC, g_hpalBranding, FALSE);

    //
    // paint the band at its animation point (bandOffset)
    //

    oldBitmap = (HBITMAP)SelectObject(hdcBitmap, g_hbmBand);

    cxRect = rc.right-rc.left;
    cxBand = min(g_sizeBand.cx, cxRect);

    StretchBlt(hDC,
               bandOffset, psizeBrand->cy,
               cxRect, g_sizeBand.cy,
               hdcBitmap,
               (g_sizeBand.cx-cxBand)/2, 0,
               cxBand, g_sizeBand.cy,
               SRCCOPY);

    StretchBlt(hDC,
               (-cxRect)+bandOffset, psizeBrand->cy,
               cxRect, g_sizeBand.cy,
               hdcBitmap,
               (g_sizeBand.cx-cxBand)/2, 0,
               cxBand, g_sizeBand.cy,
               SRCCOPY);

    //
    // paint the branding clipped to the current dialog, if for some
    // reason the dialog is wider than the bitmap then lets
    // fill in with white space.
    //

    if ( !fBandOnly )
    {
        int iStretchedPixels;
        RECT rcBackground;

        SelectObject(hdcBitmap, *phbmBrand);

        iStretchedPixels = (cxRect - psizeBrand->cx) / 2;
        if (iStretchedPixels < 0)
        {
            iStretchedPixels = 0;
        }
        BitBlt(hDC, iStretchedPixels, 0, psizeBrand->cx, psizeBrand->cy, hdcBitmap, 0, 0, SRCCOPY);
        if (iStretchedPixels != 0)
        {
            SetRect(&rcBackground, 0, 0, iStretchedPixels, psizeBrand->cy);
            FillRect(hDC, &rcBackground, phbrBackground[0]);
            SetRect(&rcBackground, cxRect - iStretchedPixels - 1, 0, cxRect, psizeBrand->cy);
            FillRect(hDC, &rcBackground, phbrBackground[1]);
        }

        rc.top = psizeBrand->cy + g_sizeBand.cy;
        FillRect(hDC, &rc, (HBRUSH)IntToPtr(1+nBackground));
    }

    if ( oldBitmap )
        SelectObject(hdcBitmap, oldBitmap);

    if ( oldPalette )
        SelectPalette(hDC, oldPalette, TRUE);

    DeleteDC(hdcBitmap);

    return TRUE;
}


/*-----------------------------------------------------------------------------
/ BrandingQueryNewPalette / BrandingPaletteChanged
/ ------------------------------------------------
/   Handle palette change messages from the system so that we can work correctly
/   on <= 8 bit per pixel devices.
/
/ In:
/   -
/ Out:
/   -
/----------------------------------------------------------------------------*/

BOOL BrandingQueryNewPalete(HWND hDlg)
{
    HDC hDC;
    HPALETTE oldPalette;

    if ( !g_hpalBranding )
        return FALSE;

    hDC = GetDC(hDlg);

    if ( !hDC )
        return FALSE;

    oldPalette = SelectPalette(hDC, g_hpalBranding, FALSE);
    RealizePalette(hDC);
    UpdateColors(hDC);

    InvalidateRect(hDlg, NULL, TRUE);
    UpdateWindow(hDlg);

    if ( oldPalette )
        SelectPalette(hDC, oldPalette, FALSE);

    ReleaseDC(hDlg, hDC);
    return TRUE;
}

BOOL BrandingPaletteChanged(HWND hDlg, HWND hWndPalChg)
{
    HDC hDC;
    HPALETTE oldPalette;

    if ( !g_hpalBranding )
        return FALSE;

    if ( hDlg != hWndPalChg )
    {
        hDC = GetDC(hDlg);

        if ( !hDC )
            return FALSE;

        oldPalette = SelectPalette(hDC, g_hpalBranding, FALSE);
        RealizePalette(hDC);
        UpdateColors(hDC);

        if ( oldPalette )
            SelectPalette(hDC, oldPalette, FALSE);

        ReleaseDC(hDlg, hDC);
    }

    return FALSE;
}

// DrawTextAutoSize helper function:
/***************************************************************************\
* FUNCTION: DrawTextAutoSize
*
* PURPOSE:  Takes the same parameters and returns the same values as DrawText.
*           This function adjusts the bottom of the passed in rectangle as
*           necessary to fit all of the text.
*
*   05-06-98 dsheldon   Created.
\***************************************************************************/
LONG DrawTextAutoSize(HDC hdc, LPCTSTR szString, int cchString, LPRECT prc, UINT uFormat)
{
    LONG yHeight;
    LONG left, right;
    left = prc->left;
    right = prc->right;

    yHeight = DrawText(hdc, szString, cchString, prc, uFormat | DT_CALCRECT);
    if (yHeight != 0)
    {
        prc->left = left;
        prc->right = right;

        yHeight = DrawText(hdc, szString, cchString, prc, uFormat & (~DT_CALCRECT));
    }

    return yHeight;
}

/***************************************************************************\
* FUNCTION: MarkupTextOut
*
* PURPOSE:  Paints a line of marked-up text (with bolding, etc)
*
* IN:       hdc, x, y, text, flags (none so far)
*
* RETURNS:  FALSE == failure
*
* HISTORY:
*
*   11-10-98 dsheldon   Created.
*
\***************************************************************************/
BOOL MarkupTextOut(HDC hdc, int x, int y, LPWSTR szText, DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    HFONT hBoldFont = NULL;
    HFONT hNormalFont = NULL;
    
    // Get the normal and bold font
    hNormalFont = GetCurrentObject(hdc, OBJ_FONT);

    if (NULL != hNormalFont)
    {
        LOGFONT lf = {0};

        GetObject(hNormalFont, sizeof(lf), (LPVOID) &lf);

        lf.lfWeight = 1000;

        hBoldFont = CreateFontIndirect(&lf);
    }

    if ((NULL != hNormalFont) || (NULL != hBoldFont))
    {
        BOOL fLoop;
        WCHAR* pszStringPart;
        WCHAR* pszExamine;
        int cchStringPart;
        BOOL fBold;
        BOOL fOutputStringPart;

        // Reset current text point
        SetTextAlign(hdc, TA_UPDATECP);
        MoveToEx(hdc, x, y, NULL);

        fLoop = TRUE;
        pszStringPart = szText;
        pszExamine = szText;
        cchStringPart = 0;
        fBold = FALSE;
        while (fLoop)
        {
            // Assume we'll find the end of the current string part
            fOutputStringPart = TRUE;

            // See how long the current string part is; a '\0' or a
            // 'bold tag' may end the current string part
            if (L'\0' == *pszExamine)
            {
                // String is done; loop is over
                fLoop = FALSE;
                fSuccess = TRUE;
            }
            // See if this is a bold tag or an end bold tag
            else if (0 == _wcsnicmp(pszExamine, L"<B>", 3))
            {
                fBold = TRUE;
                pszExamine += 3;
            }
            else if (0 == _wcsnicmp(pszExamine, L"</B>", 4))
            {
                fBold = FALSE;
                pszExamine += 4;
            }
            // TODO: Look for other tags here if needed
            else
            {
                // No tag (same String Part)
                cchStringPart ++;
                pszExamine ++;
                fOutputStringPart = FALSE;
            }

            if (fOutputStringPart)
            {
                TextOut(hdc, 0, 0, pszStringPart, cchStringPart);
                
                // Next string part
                pszStringPart = pszExamine;
                cchStringPart = 0;

                if (fBold)
                {
                    SelectObject(hdc, hBoldFont);
                }
                else
                {
                    SelectObject(hdc, hNormalFont);
                }
            } //if
        } //while
    } //if

    SelectObject(hdc, hNormalFont);
    SetTextAlign(hdc, TA_NOUPDATECP);

    // Clean up bold font if necessary
    if (NULL != hBoldFont)
    {
        DeleteObject(hBoldFont);
    }

    return fSuccess;
}

/***************************************************************************\
* FUNCTION: PaintBitmapText
*
* PURPOSE:  Paints the copyright notice and release/version text on the
*           Splash and Logon bitmaps
*
* IN:       pGinaFonts - Uses the font handles in this structure
*           Also uses global bitmap handles
*
* RETURNS:  void; modifies global bitmaps
*
* HISTORY:
*
*   05-06-98 dsheldon   Created.
*
\***************************************************************************/
VOID PaintBitmapText(PGINAFONTS pGinaFonts, BOOL fTextOnLarge,
                     BOOL fTextOnSmall)
{
    // Various metrics used to draw the text

    // Horizontal Positioning of copyright
    static const int CopyrightRightMargin = 9;
    static const int CopyrightWidth = 134;

    // Vertical positioning of copyright
    static const int CopyrightTop = 21;

    // Vertical for the logon window Beta3 message
    static const int BetaTopNormal = 28;

    // Horizontal
    static const int BetaRightMargin = 13;
    static const int BetaWidth = 100;

    // If we're showing the copyright, draw the "beta3" here
    static const int BetaTopCopyright = 53;

    // Positioning of "Built on NT"
    static const int BuiltOnNtTop = 68;

    static const int BuiltOnNtTopTerminal = 91;

    static const int BuiltOnNtLeft = 186;

    HDC hdcBitmap;
    HBITMAP hbmOld;
    HFONT hfontOld;
    NT_PRODUCT_TYPE NtProductType;

    TCHAR szCopyright[128];
    TCHAR szBuiltOnNt[256];
    TCHAR szRelease[64];
    
    // Used for calculating text drawing areas
    RECT rc;

    BOOL fTemp;

    szCopyright[0] = 0;
    szBuiltOnNt[0] = 0;
    szRelease[0] = 0;

    // Get the product type
    RtlGetNtProductType(&NtProductType);

    // Load the strings that will be painted on the bitmaps
    LoadString(hDllInstance, IDS_RELEASE_TEXT, szRelease, ARRAYSIZE(szRelease));
    LoadString(hDllInstance, IDS_COPYRIGHT_TEXT, szCopyright, ARRAYSIZE(szCopyright));
    LoadString(hDllInstance, IDS_BUILTONNT_TEXT, szBuiltOnNt, ARRAYSIZE(szBuiltOnNt));

    fTemp = DeepImages(g_fNoPalleteChanges);
    if (g_fDeepImages != fTemp)
    {
        g_fDeepImages = fTemp;
        ReLoadBrandingImages(fTemp, NULL, NULL);
    }
    
    // Create a compatible DC for painting the copyright and release/version notices
    hdcBitmap = CreateCompatibleDC(NULL);

    if (hdcBitmap)
    {
        // Set text transparency and color (black)
        SetTextColor(hdcBitmap, RGB(0,0,0));
        SetBkMode(hdcBitmap, TRANSPARENT);
        SetMapMode(hdcBitmap, MM_TEXT);

        // Work with the splash bitmap
        if (fTextOnLarge && g_hbmLogonBrand)
        {
            hbmOld = SelectObject(hdcBitmap, g_hbmLogonBrand);
            hfontOld = SelectObject(hdcBitmap, pGinaFonts->hCopyrightFont);

            if (GetSystemMetrics(SM_REMOTESESSION))
            {
                // paint the copyright notice for remote sessions

                TEXTMETRIC  textMetric;

                (BOOL)GetTextMetrics(hdcBitmap, &textMetric);
                rc.top = g_sizeLogonBrand.cy - textMetric.tmHeight;
                rc.bottom = g_sizeLogonBrand.cy;
                rc.left = textMetric.tmAveCharWidth;
                rc.right = g_sizeLogonBrand.cx;
                DrawTextAutoSize(hdcBitmap, szCopyright, -1, &rc, 0);
            }

            // paint the release/version notice
            SelectObject(hdcBitmap, pGinaFonts->hBetaFont);

            rc.top = BetaTopNormal;
            rc.left = g_sizeLogonBrand.cx - BetaRightMargin - BetaWidth;
            rc.right = g_sizeLogonBrand.cx - BetaRightMargin;

            SetTextColor(hdcBitmap, RGB(128, 128, 128));
            DrawTextAutoSize(hdcBitmap, szRelease, -1, &rc, DT_RIGHT | DT_WORDBREAK);
            SetTextColor(hdcBitmap, RGB(0,0,0));

            // paint the built on NT message
            SelectObject(hdcBitmap, pGinaFonts->hBuiltOnNtFont);

            MarkupTextOut(hdcBitmap, BuiltOnNtLeft, BuiltOnNtTop, szBuiltOnNt, 0);
            
            SelectObject(hdcBitmap, hfontOld);

            SelectObject(hdcBitmap, hbmOld);
        }

        if (fTextOnSmall && g_hbmOtherDlgBrand)
        {
            hbmOld = SelectObject(hdcBitmap, g_hbmOtherDlgBrand);

            // paint the release notice

            hfontOld = SelectObject(hdcBitmap, pGinaFonts->hBetaFont);

            rc.top = BetaTopNormal;
            rc.left = g_sizeOtherDlgBrand.cx - BetaRightMargin - BetaWidth;
            rc.right = g_sizeOtherDlgBrand.cx - BetaRightMargin;

            SetTextColor(hdcBitmap, RGB(128, 128, 128));
            DrawTextAutoSize(hdcBitmap, szRelease, -1, &rc, DT_RIGHT | DT_WORDBREAK);
            SetTextColor(hdcBitmap, RGB(0, 0, 0));

            SelectObject(hdcBitmap, hfontOld);

            SelectObject(hdcBitmap, hbmOld);
        }

        DeleteDC(hdcBitmap);
    }
}



// Two helpers for CreateFonts

void SetFontFaceFromResource(PLOGFONT plf, UINT idFaceName)
// Sets the font face from a specified resource, or uses a default if string load fails
{
    // Read the face name and point size from the resource file
    if (LoadString(hDllInstance, idFaceName, plf->lfFaceName, LF_FACESIZE) == 0)
    {
        lstrcpy(plf->lfFaceName, TEXT("Tahoma"));
        OutputDebugString(TEXT("Could not read welcome font face from resource"));
    }
}

void SetFontSizeFromResource(PLOGFONT plf, UINT idSizeName)
// Sets the font size from a resource, or uses a default if the string load fails.
// Now uses pixel height instead of point size
{
    TCHAR szPixelSize[10];
    LONG nSize;
    HDC hdcScreen;

    if (LoadString(hDllInstance, idSizeName, szPixelSize, ARRAYSIZE(szPixelSize)) != 0)
    {
        nSize = _ttol(szPixelSize);
    }
    else
    {
        // Make it really obvious something is wrong
        nSize = 40;
    }

    plf->lfHeight = -nSize;

#if (1) //DSIE: Bug 262839  
    if (hdcScreen = GetDC(NULL))
    {         
        double dScaleY = GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0f;
        plf->lfHeight = (int) (plf->lfHeight * dScaleY); // Scale the height based on the system DPI.
        ReleaseDC(NULL, hdcScreen);
    }
#endif
}


/***************************************************************************\
* FUNCTION: CreateFonts
*
* PURPOSE:  Creates the fonts for the welcome and logon screens
*
* IN/OUT:   pGinaFonts - Sets the font handles in this structure
*
* RETURNS:  void; also see IN/OUT above
*
* HISTORY:
*
*   05-05-98 dsheldon   Created.
*
\***************************************************************************/
void CreateFonts(PGINAFONTS pGinaFonts)
{
    LOGFONT lf = {0};
    CHARSETINFO csInfo;

	WCHAR   szFontName[32];

    lf.lfWidth = 0;
    lf.lfWeight = FW_NORMAL;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH;

    // Set charset
    if (TranslateCharsetInfo((DWORD*)IntToPtr(GetACP()), &csInfo,
        TCI_SRCCODEPAGE) == 0)
    {
        csInfo.ciCharset = 0;
    }

    lf.lfCharSet = (UCHAR)csInfo.ciCharset;


    if (pGinaFonts->hWelcomeFont == NULL)
    {
        // Create the welcome font
        SetFontFaceFromResource(&lf, IDS_PRESSCAD_FACENAME);
        SetFontSizeFromResource(&lf, IDS_PRESSCAD_FACESIZE);

        // make sure font is loaded before calling CreateFontIndirect
        if (LoadString(hDllInstance, IDS_PRESSCAD_FONTNAME, szFontName, 32) == 0)
        {
            AddFontResource(L"Tahoma.ttf");
        }
        else
        {
            AddFontResource(szFontName);   
        }
        
        pGinaFonts->hWelcomeFont = CreateFontIndirect(&lf);
    }

    if (pGinaFonts->hBetaFont == NULL)
    {
        // Create the release font for the welcome page
        SetFontFaceFromResource(&lf, IDS_RELEASE_FACENAME);
        SetFontSizeFromResource(&lf, IDS_RELEASE_FACESIZE);

        pGinaFonts->hBetaFont = CreateFontIndirect(&lf);
    }

    if (pGinaFonts->hCopyrightFont == NULL)
    {
        // Create the copyright font
        SetFontFaceFromResource(&lf, IDS_COPYRIGHT_FACENAME);
        SetFontSizeFromResource(&lf, IDS_COPYRIGHT_FACESIZE);

        pGinaFonts->hCopyrightFont = CreateFontIndirect(&lf);
    }

    if (pGinaFonts->hBuiltOnNtFont == NULL)
    {
        // Create the "Built on NT Technology" font
        SetFontFaceFromResource(&lf, IDS_BUILTONNT_FACENAME);
        SetFontSizeFromResource(&lf, IDS_BUILTONNT_FACESIZE);

        lf.lfWeight = FW_NORMAL;

        pGinaFonts->hBuiltOnNtFont = CreateFontIndirect(&lf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\dialogs.h ===
/****************************** Module Header ******************************\
* Module Name: dialogs.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define contants used by dialog edit when editting dialog.dlg
*
* NOTE - this file is maintained by dlgedit. Do not edit directly
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

//
// Hydra Dialogs
//
#define IDD_CONNECT                 2300
#define IDC_CONNECTBOX              2301
#define IDD_CALLBACK                2310
#define IDD_PHONENUMBER             2311
#define IDD_CALLBACK_WAIT           2320
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-94   RichardW   Created
//
//----------------------------------------------------------------------------


#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG

extern  DWORD   GINAInfoLevel;

#define DebugLog(x) LogEvent x


void    LogEvent(long, const char *, ...);
void    InitDebugSupport(void);

#define DEB_ERROR           0x00000001
#define DEB_WARN            0x00000002
#define DEB_TRACE           0x00000004
#define DEB_TRACE_DOMAIN    0x00000008
#define DEB_TRACE_CACHE     0x00000010


#else

#define DebugLog(x)

#endif



#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debugging support functions
//
//  Classes:
//
//  Functions:
//
//  Note:       This file is not compiled for retail builds
//
//  History:    4-29-93   RichardW   Created
//
//----------------------------------------------------------------------------

//
//  For ease of debugging the SPMgr, all the debug support functions have
//  been stuck here.  Basically, we read info from win.ini, since that allows
//  us to configure the debug level via a text file (and DOS, for example).
//
//  Format is:
//
//  win.ini
//
//  [SPMgr]
//      DebugFlags=<Flag>[<,Flag>]*
//      Package=<int>
//      BreakFlags=<BreakFlag>[<,BreakFlags>]*
//
//  WHERE:
//      Flag is one of the following:
//          Error, Warning, Trace, Verbose, BreakOnError, Helpers,
//          RefMon, Locator, WAPI, Init, Audit, Db, Lsa
//
//      Package is the name of the dll implementing the package, e.g.
//          NTLM=3
//
//      BreakFlags will cause SPMgr to break, if BreakOnError is set in
//      DebugFlags:
//          InitBegin, InitEnd, Connect, Exception, Problem, Load
//
//

#if DBG         // NOTE:  This file not compiled for retail builds

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>

FILE *  LogFile;
DWORD   BreakFlags = 0;
extern  DWORD   NoUnload;
DWORD   GINAInfoLevel = 3;



// Debugging support functions.

// These two functions do not exist in Non-Debug builds.  They are wrappers
// to the commnot functions (maybe I should get rid of that as well...)
// that echo the message to a log file.

char   szSection[] = "MSGina";
char * DebLevel[] = {"GINA-Error",
                     "GINA-Warn",
                     "GINA-Trace",
                     "GINA-Domain",
                     "GINA-Cache"
                    };

typedef struct _DebugKeys {
    char *  Name;
    DWORD   Value;
} DebugKeys, *PDebugKeys;

DebugKeys   DebugKeyNames[] = {
                {"Error",       DEB_ERROR},
                {"Warning",     DEB_WARN},
                {"Trace",       DEB_TRACE},
                {"Domain",      DEB_TRACE_DOMAIN},
                {"Cache",       DEB_TRACE_CACHE}
                };

#define NUM_DEBUG_KEYS  sizeof(DebugKeyNames) / sizeof(DebugKeys)
#define NUM_BREAK_KEYS  sizeof(BreakKeyNames) / sizeof(DebugKeys)

//+---------------------------------------------------------------------------
//
//  Function:   LogEvent
//
//  Synopsis:   Logs an event to the console and, optionally, a file.
//
//  Effects:
//
//  Arguments:  [Mask]   --
//              [Format] --
//              [Format] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void
LogEvent(   long            Mask,
            const char *    Format,
            ...)
{
    va_list ArgList;
    int     Level = 0;
    int     PrefixSize = 0;
    char    szOutString[256];


    if (Mask & GINAInfoLevel)
    {
        while (!(Mask & 1))
        {
            Level++;
            Mask >>= 1;
        }
        if (Level >= (sizeof(DebLevel) / sizeof(char *)) )
        {
            Level = (sizeof(DebLevel) / sizeof(char *)) - 1;
        }


        //
        // Make the prefix first:  "Process.Thread> GINA-XXX"
        //

        PrefixSize = sprintf(szOutString, "%d.%d> %s: ",
                GetCurrentProcessId(), GetCurrentThreadId(), DebLevel[Level]);


        va_start(ArgList, Format);

        if (_vsnprintf(&szOutString[PrefixSize], sizeof(szOutString) - PrefixSize,
                            Format, ArgList) < 0)
        {
            //
            // Less than zero indicates that the string could not be
            // fitted into the buffer.  Output a special message indicating
            // that:
            //

            OutputDebugStringA("GINA!LogEvent:  Could not pack string into 256 bytes\n");

        }
        else
        {
            OutputDebugStringA(szOutString);
        }


        if (LogFile)
        {
            SYSTEMTIME  stTime;
            FILETIME    ftTime;
            FILETIME    localtime;

            NtQuerySystemTime((PLARGE_INTEGER) &ftTime);
            FileTimeToLocalFileTime(&ftTime, &localtime);
            FileTimeToSystemTime(&localtime, &stTime);
            fprintf(LogFile, "%02d:%02d:%02d.%03d: %s\n",
                    stTime.wHour, stTime.wMinute, stTime.wSecond,
                    stTime.wMilliseconds, szOutString);

            fflush(LogFile);
        }

    }

}

void
OpenLogFile(LPSTR   pszLogFile)
{
    LogFile = fopen(pszLogFile, "a");
    if (!LogFile)
    {
        OutputDebugStringA("GINA: Could not open logfile for append");
        OutputDebugStringA(pszLogFile);
    }
    DebugLog((DEB_TRACE, "Log file '%s' begins\n", pszLogFile));
}


DWORD
GetDebugKeyValue(
    PDebugKeys      KeyTable,
    int             cKeys,
    LPSTR           pszKey)
{
    int     i;

    for (i = 0; i < cKeys ; i++ )
    {
        if (_strcmpi(KeyTable[i].Name, pszKey) == 0)
        {
            return(KeyTable[i].Value);
        }
    }
    return(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadDebugParameters
//
//  Synopsis:   Loads debug parameters from win.ini
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
LoadDebugParameters(void)
{
    char    szVal[128];
    char *  pszDebug;
    int     cbVal;

    cbVal = GetProfileStringA(szSection, "DebugFlags", "Error,Warning", szVal, ARRAYSIZE(szVal));

    pszDebug = strtok(szVal, ", \t");
    while (pszDebug)
    {
        GINAInfoLevel |= GetDebugKeyValue(DebugKeyNames, NUM_DEBUG_KEYS, pszDebug);
        pszDebug = strtok(NULL, ", \t");
    }

    cbVal = GetProfileStringA(szSection, "LogFile", "", szVal, ARRAYSIZE(szVal));
    if (cbVal)
    {
        OpenLogFile(szVal);
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   InitDebugSupport
//
//  Synopsis:   Initializes debugging support for the GINAgr
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-29-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


void
InitDebugSupport(void)
{
    LoadDebugParameters();

}



#else // DBG

#pragma warning(disable:4206)   // Disable the empty transation unit
                                // warning/error

#endif  // NOTE:  This file not compiled for retail builds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\envvar.c ===
/****************************** Module Header ******************************\
* Module Name: envvar.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Sets environment variables.
*
* History:
* 2-25-92 JohanneC       Created -
*
\***************************************************************************/

#include "msgina.h"
#pragma hdrstop

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

BOOL ProcessCommand(LPTSTR lpStart, PVOID *pEnv);
BOOL ProcessSetCommand(LPTSTR lpStart, PVOID *pEnv);
LPTSTR ProcessAutoexecPath(PVOID *pEnv, LPTSTR lpValue, DWORD cb);
LONG  AddNetworkConnection(PGLOBALS pGlobals, LPNETRESOURCE lpNetResource);
BOOL UpdateUserEnvironmentVars(  PVOID *pEnv  );
BOOL GetLUIDDeviceMapsEnabled( VOID );

#define KEY_NAME TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Environment")

//
// Max environment variable length
//

#define MAX_VALUE_LEN          1024

#define BSLASH  TEXT('\\')
#define COLON   TEXT(':')
    
//
// These two globals implement ref counting on
// pGlobals->UserProcessData->hCurrentUser (418628)
// managed by OpenHKeyCurrentUser/CloseHKeyCurrentUser below
//
RTL_CRITICAL_SECTION    g_csHKCU;
ULONG                   g_ulHKCURef;

HANDLE    g_hEventLog;
#define EVENTLOG_SOURCE       TEXT("MsGina")

#pragma prefast(push)
#pragma prefast(disable: 400, "PREfast noise: lstrcmpi")

/***************************************************************************\
* ReportWinlogonEvent
*
* Reports winlogon event by calling ReportEvent.
*
\***************************************************************************/
#define MAX_EVENT_STRINGS 8

DWORD
ReportWinlogonEvent(
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    DWORD rv;

    //
    // Initialize log as necessary
    //
    HKEY    hKey;
    DWORD   disp;

    rv = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Services\\EventLog\\Application\\MsGina",
        0,
        L"",
        REG_OPTION_NON_VOLATILE,
        KEY_WRITE,
        NULL,
        &hKey,
        &disp
        );

    if (ERROR_SUCCESS == rv)
    {
        if (disp == REG_CREATED_NEW_KEY)
        {
            PWSTR l_szModulePath = L"%SystemRoot%\\System32\\msgina.dll";
            ULONG l_uLen = (ULONG)( (wcslen(l_szModulePath) + 1)*sizeof(TCHAR) );

            RegSetValueEx(
                hKey,
                TEXT("EventMessageFile"),
                0,
                REG_EXPAND_SZ,
                (PBYTE)l_szModulePath,
                l_uLen
                );

            disp = (DWORD)(
                EVENTLOG_ERROR_TYPE |
                EVENTLOG_WARNING_TYPE |
                EVENTLOG_INFORMATION_TYPE
                );

            RegSetValueEx(
                hKey,
                L"TypesSupported",
                0,
                REG_DWORD,
                (PBYTE) &disp,
                sizeof(DWORD)
                );
        }

        RegCloseKey(hKey);
    }

    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i=0; i<NumberOfStrings; i++) {
        Strings[ i ] = va_arg( arglist, PWSTR );
    }

    if (g_hEventLog == NULL) {

        g_hEventLog = RegisterEventSource(NULL, EVENTLOG_SOURCE);

        if (g_hEventLog == NULL) {
            return ERROR_INVALID_HANDLE;
        }
    }

    if (!ReportEvent( g_hEventLog,
                       EventType,
                       0,            // event category
                       EventId,
                       NULL,
                       (WORD)NumberOfStrings,
                       SizeOfRawData,
                       Strings,
                       RawData) ) {
        rv = GetLastError();
        DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, GetLastError() ));
    } else {
        rv = ERROR_SUCCESS;
    }

    return rv;
}


BOOL
InitHKeyCurrentUserSupport(
    )
{
    NTSTATUS Status ;

    Status = RtlInitializeCriticalSection( &g_csHKCU );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog((DEB_ERROR, "InitHKeyCurrentUserSupport failed to init its lock, error = 0x%08X\n", Status));
        return FALSE;
    }

    g_ulHKCURef = 0;

    return TRUE;
}

VOID
CleanupHKeyCurrentUserSupport(
    )
{
    RtlDeleteCriticalSection( &g_csHKCU );
}

/***************************************************************************\
* OpenHKeyCurrentUser
*
* Opens HKeyCurrentUser to point at the current logged on user's profile.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 06-16-92  Davidc  Created
*
\***************************************************************************/
BOOL
OpenHKeyCurrentUser(
    PGLOBALS pGlobals
    )
{
    HANDLE ImpersonationHandle;
    BOOL Result;
    NTSTATUS Status ;


    //
    // Get in the correct context before we reference the registry
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);
    if (ImpersonationHandle == NULL) {
        DebugLog((DEB_ERROR, "OpenHKeyCurrentUser failed to impersonate user"));
        return(FALSE);
    }

    RtlEnterCriticalSection( &g_csHKCU );

    if (g_ulHKCURef == 0)
    {
        Status = RtlOpenCurrentUser(
                    MAXIMUM_ALLOWED,
                    &pGlobals->UserProcessData.hCurrentUser );
    }

    g_ulHKCURef++;

    RtlLeaveCriticalSection( &g_csHKCU );

    //
    // Return to our own context
    //

    Result = StopImpersonating(ImpersonationHandle);
    ASSERT(Result);


    return(TRUE);
}



/***************************************************************************\
* CloseHKeyCurrentUser
*
* Closes HKEY_CURRENT_USER.
* Any registry reference will automatically re-open it, so this is
* only a token gesture - but it allows the registry hive to be unloaded.
*
* Returns nothing
*
* History:
* 06-16-92  Davidc  Created
*
\***************************************************************************/
VOID
CloseHKeyCurrentUser(
    PGLOBALS pGlobals
    )
{
    RtlEnterCriticalSection( &g_csHKCU );

    if (g_ulHKCURef > 0)
    {
        if (--g_ulHKCURef == 0)
        {
            NtClose( pGlobals->UserProcessData.hCurrentUser );
            pGlobals->UserProcessData.hCurrentUser = NULL ;
        }
    }

    RtlLeaveCriticalSection( &g_csHKCU );
}



/***************************************************************************\
* SetUserEnvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetUserEnvironmentVariable(
    PVOID *pEnv,
    LPTSTR lpVariable,
    LPTSTR lpValue,
    BOOL bOverwrite
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;
    TCHAR szValue[1024];


    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }
        // lpVariable is either a constant string or less than MAX_PATH
    RtlInitUnicodeString(&Name, lpVariable);
    cb = 1024;
    Value.Buffer = Alloc(sizeof(TCHAR)*cb);
    if (Value.Buffer) {
        Value.Length = (USHORT)cb;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

        Free(Value.Buffer);

        if ( NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }
    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!lstrcmpi(lpVariable, TEXT("TEMP"))) ||
            (!lstrcmpi(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}


/***************************************************************************\
* ExpandUserEnvironmentStrings
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
DWORD
ExpandUserEnvironmentStrings(
    PVOID pEnv,
    LPTSTR lpSrc,
    LPTSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;

    Status = RtlInitUnicodeStringEx( &Source, lpSrc );
    if (!NT_SUCCESS( Status ))  // Safe. Should never happen though as all lpSrc
    {                           // should be less than 4096 chars.
        return 0;
    }
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(nSize*sizeof(WCHAR));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( pEnv,
                                          (PUNICODE_STRING)&Source,
                                          (PUNICODE_STRING)&Destination,
                                          &Length
                                        );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length );
        }
    else {
        return( 0 );
        }
}


/***************************************************************************\
* BuildEnvironmentPath
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL BuildEnvironmentPath(PVOID *pEnv,
                          LPTSTR lpPathVariable,
                          LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    TCHAR lpTemp[1026];     // Allows for appending of ; and NULL
    DWORD cb;


    if (!*pEnv) {
        return(FALSE);
    }
        // Always called with short constant string
    RtlInitUnicodeString(&Name, lpPathVariable);
    cb = 1024;
    Value.Buffer = Alloc(sizeof(TCHAR)*cb);
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(TCHAR) * cb);
    Value.MaximumLength = (USHORT)(sizeof(TCHAR) * cb);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        Free(Value.Buffer);
        Value.Length = 0;
        *lpTemp = 0;
    }
    if (Value.Length) {
        memcpy(lpTemp, Value.Buffer, Value.Length);     // Might not be NULL term'd
        lpTemp[Value.Length / sizeof(TCHAR)] = 0;
        if ( *( lpTemp + lstrlen(lpTemp) - 1) != TEXT(';') ) {
            lstrcat(lpTemp, TEXT(";"));
        }
        Free(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(lpTemp) + lstrlen(lpPathValue) + 1) < (INT)cb)) {
        lstrcat(lpTemp, lpPathValue);

        RtlInitUnicodeString(&Value, lpTemp);

        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}


/***************************************************************************\
* SetEnvironmentVariables
*
* Reads the user-defined environment variables from the user registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetEnvironmentVariables(
    PGLOBALS pGlobals,
    LPTSTR pEnvVarSubkey,
    PVOID *pEnv
    )
{
    TCHAR lpValueName[MAX_PATH];
    PWCH  lpDataBuffer;
    DWORD cbDataBuffer;
    PWCH  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;


    /*
     * Open registry key to access USER environment variables.
     */
    if (!OpenHKeyCurrentUser(pGlobals)) {
        DebugLog((DEB_ERROR, "SetEnvironmentVariables: Failed to open HKeyCurrentUser"));
        return(FALSE);
    }

    if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser, pEnvVarSubkey, 0, KEY_READ, &hkey)) {
        CloseHKeyCurrentUser(pGlobals);
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = Alloc(sizeof(TCHAR)*cbDataBuffer);
    if (lpDataBuffer == NULL) {
        DebugLog((DEB_ERROR, "SetEnvironmentVariables: Failed to allocate %d bytes", cbDataBuffer));
        CloseHKeyCurrentUser(pGlobals);
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = sizeof(TCHAR)*cbDataBuffer;
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         (LPBYTE)lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {

                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //
                    SetUserEnvironmentVariable(pEnv, lpValueName, lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = sizeof(TCHAR)*cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = sizeof(TCHAR)*cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         (LPBYTE)lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cb, cbNeeded;

                cb = 1024;
                lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
                if (lpExpandedValue) {
                    cbNeeded = ExpandUserEnvironmentStrings(*pEnv, lpData, lpExpandedValue, cb);
                    if (cbNeeded > cb) {
                        Free(lpExpandedValue);
                        cb = cbNeeded;
                        lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, lpData, lpExpandedValue, cb);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, lpExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //
                    SetUserEnvironmentVariable(pEnv, lpValueName, lpExpandedValue, TRUE);
                }

                Free(lpExpandedValue);
            }
        }
        dwIndex++;
        cbData = sizeof(TCHAR)*cbDataBuffer;
        cbValueName = MAX_PATH;
    }


    Free(lpDataBuffer);
    RegCloseKey(hkey);
    CloseHKeyCurrentUser(pGlobals);

    return(bResult);
}

/***************************************************************************\
* IsUNCPath
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL IsUNCPath(LPTSTR lpPath)
{
    if (lpPath[0] == BSLASH && lpPath[1] == BSLASH) {
        return(TRUE);
    }
    return(FALSE);
}

/***************************************************************************\
* SetHomeDirectoryEnvVars
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL
SetHomeDirectoryEnvVars(
    PVOID *pEnv,                // All callers enforce the sizes below
    LPTSTR lpHomeDirectory,     // MAX_PATH
    LPTSTR lpHomeDrive,         // 4
    LPTSTR lpHomeShare,         // MAX_PATH
    LPTSTR lpHomePath,          // MAX_PATH
    BOOL * pfDeepShare
    )
{
    TCHAR cTmp;
    LPTSTR lpHomeTmp;
    BOOL bFoundFirstBSlash = FALSE;

    if (!*lpHomeDirectory) {
        return(FALSE);
    }

    *pfDeepShare = FALSE;

    if (IsUNCPath(lpHomeDirectory)) {
        lpHomeTmp = lpHomeDirectory + 2;
        while (*lpHomeTmp) {
            if (*lpHomeTmp == BSLASH) {
                if (bFoundFirstBSlash) {
                    break;
                }
                bFoundFirstBSlash = TRUE;
            }
            lpHomeTmp++;
        }
        if (*lpHomeTmp) {
                // safe as lpHomeTmp is a subset of lpHomeDirectory<MAX_PATH
            lstrcpy(lpHomePath, lpHomeTmp);
            *pfDeepShare = TRUE;
        }
        else {
            *lpHomePath = BSLASH;
            *(lpHomePath+1) = 0;

        }

        cTmp = *lpHomeTmp;
        *lpHomeTmp = (TCHAR)0;
            // safe as new lpHomeDirectory was cut short by 2 lines above.
        lstrcpy(lpHomeShare, lpHomeDirectory);
        *lpHomeTmp = cTmp;

        //
        // If no home drive specified, than default to z:
        //
        if (!*lpHomeDrive) {
            lstrcpy(lpHomeDrive, TEXT("Z:"));
        }

    }
    else {  // local home directory

        *lpHomeShare = 0;   // no home share

        cTmp = lpHomeDirectory[2];
        lpHomeDirectory[2] = (TCHAR)0;
            // 3 chars at most thus safe
        lstrcpy(lpHomeDrive, lpHomeDirectory);
        lpHomeDirectory[2] = cTmp;

        if (lstrlen(lpHomeDirectory) >= 2)
        {
                // safe as lpHomeDirectory+2 can only make the string shorter.
            lstrcpy(lpHomePath, lpHomeDirectory + 2);
        }
        else
        {
            *lpHomePath = 0;
        }
    }

    SetUserEnvironmentVariable(pEnv, HOMEDRIVE_VARIABLE, lpHomeDrive, TRUE);
    SetUserEnvironmentVariable(pEnv, HOMESHARE_VARIABLE, lpHomeShare, TRUE);
    SetUserEnvironmentVariable(pEnv, HOMEPATH_VARIABLE, lpHomePath, TRUE);

    return TRUE;
}

/***************************************************************************\
* UpdateHomeVarsInVolatileEnv
*
* Sets the HOMEDRIVE, HOMEPATH and HOMESHARE variables in the user's home
* volatile environment so that SHGetFolderPath is able to expand these
* variables
*
* History:
* 6-5-2000  RahulTh     Created 
*
\***************************************************************************/
VOID
UpdateHomeVarsInVolatileEnv (
    PGLOBALS    pGlobals,
    LPTSTR      lpHomeDrive,
    LPTSTR      lpHomeShare,
    LPTSTR      lpHomePath
    )
{
    BOOL    bOpenedHKCU;
    HANDLE  ImpersonationHandle = NULL;
    HKEY    hUserVolatileEnv = NULL;
    LONG    lResult;
    
    bOpenedHKCU = OpenHKeyCurrentUser (pGlobals);
    
    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

    if (ImpersonationHandle != NULL) {

        //
        // See the registry value to see whether we should really try to map
        // the whole directory or just map to the root..
        //

        if ((pGlobals->UserProcessData).hCurrentUser) {

            lResult = RegOpenKeyEx((pGlobals->UserProcessData).hCurrentUser, L"Volatile Environment", 0, KEY_READ | KEY_WRITE, &hUserVolatileEnv);

            if (lResult == ERROR_SUCCESS) {

                RegSetValueEx (hUserVolatileEnv,
                               HOMEDRIVE_VARIABLE,
                               0,
                               REG_SZ,
                               (LPBYTE) lpHomeDrive,
                               (lstrlen (lpHomeDrive) + 1) * sizeof (TCHAR));

                RegSetValueEx (hUserVolatileEnv,
                               HOMESHARE_VARIABLE,
                               0,
                               REG_SZ,
                               (LPBYTE) lpHomeShare,
                               (lstrlen (lpHomeShare) + 1) * sizeof (TCHAR));
               
                RegSetValueEx (hUserVolatileEnv,
                               HOMEPATH_VARIABLE,
                               0,
                               REG_SZ,
                               (LPBYTE) lpHomePath,
                               (lstrlen (lpHomePath) + 1) * sizeof (TCHAR));
                
                RegCloseKey(hUserVolatileEnv);
            }
        }

        //
        // Revert to being 'ourself'
        //

        if (!StopImpersonating(ImpersonationHandle)) {
            DebugLog((DEB_ERROR, "UpdateHomeVarsInVolatileEnv : Failed to revert to self"));
        }

        //
        // Set it to NULL
        //

        ImpersonationHandle = NULL;
    }
    else {
        DebugLog((DEB_ERROR, "UpdateHomeVarsInVolatileEnv : Failed to impersonate user"));
    }

    if (bOpenedHKCU)
        CloseHKeyCurrentUser (pGlobals);
}


/***************************************************************************\
* ChangeToHomeDirectory
*
* Sets the current directory to the user's home directory. If this fails
* tries to set to the directory in the following order:
*    1. home directory
*    2. c:\users\default
*    3. c:\users
*    4. \ (root)
*    5. leaves directory as is i.e. the present current directory
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
VOID
ChangeToHomeDirectory(
    PGLOBALS pGlobals,
    PVOID *pEnv,                // All callers enforce the sizes below
    LPTSTR lpHomeDir,           // MAX_PATH
    LPTSTR lpHomeDrive,         // 4
    LPTSTR lpHomeShare,         // MAX_PATH
    LPTSTR lpHomePath,          // MAX_PATH
    LPTSTR lpOldDir,            // MAX_PATH
    BOOL   DeepShare
    )
{
    TCHAR lpCurDrive[4]; 
    BOOL bNoHomeDir = FALSE;
    BOOL bTSHomeDir = FALSE;
    HANDLE ImpersonationHandle = NULL;
    DWORD error = ERROR_SUCCESS, dwSize, dwType;
    HKEY hUserPolicy=NULL;
    DWORD dwConnectHomeDirToRoot;
    LONG lResult;

    if (GetCurrentDirectory(MAX_PATH, lpOldDir)) {
        lpCurDrive[0] = lpOldDir[0];
        lpCurDrive[1] = lpOldDir[1];
        lpCurDrive[2] = (TCHAR)0;
    }
    else
        lpCurDrive[0] = (TCHAR)0;

    if (!*lpHomeDir) {
        bNoHomeDir = TRUE;

DefaultDirectory:
        if (!bNoHomeDir) {
#if 0
            ReportWinlogonEvent(pGlobals,
                    EVENTLOG_ERROR_TYPE,
                    EVENT_SET_HOME_DIRECTORY_FAILED,
                    sizeof(error),
                    &error,
                    1,
                    lpHomeDir);
#endif
        }
            // Always safe due to sizes differences
        lstrcpy(lpHomeDir, lpCurDrive);

        if (g_IsTerminalServer) {
            TCHAR szProfileDir[MAX_PATH];
            DWORD cbufSize = MAX_PATH;

            if ( GetUserProfileDirectory(pGlobals->UserProcessData.UserToken, szProfileDir, &cbufSize) &&
                  SetCurrentDirectory(szProfileDir) ) {

                    lstrcpy(lpHomeDir, szProfileDir);
                    bTSHomeDir = TRUE;

            } else {
                    error = GetLastError();
                    DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to GetUserProfileDirectory '%ws', error = %d\n",
                                 lpHomeDir, error));
                    lstrcpy(lpHomeDir, NULL_STRING);
            }
        }

        if (!bTSHomeDir) {
#if 0
            if (SetCurrentDirectory(USERS_DEFAULT_DIRECTORY)) {
                #_#_lstrcat(lpHomeDir, USERS_DEFAULT_DIRECTORY);
            }
            else if (SetCurrentDirectory(USERS_DIRECTORY)) {
                #_#_lstrcat(lpHomeDir, USERS_DIRECTORY);
            }
            else
#endif
            if (SetCurrentDirectory(ROOT_DIRECTORY)) {
#pragma prefast(suppress: 31, "PREfast noise")
                StringCchCat(lpHomeDir, MAX_PATH, ROOT_DIRECTORY);
            }
            else {
                lstrcpy(lpHomeDir, NULL_STRING);
            }

        }

        if (bNoHomeDir || bTSHomeDir) {
            // Update the homedrive variable to reflect the correct value
            // Always safe due to sizes differences
            lstrcpy (lpHomeDrive, lpCurDrive);
            SetUserEnvironmentVariable(pEnv, HOMEDRIVE_VARIABLE, lpCurDrive, TRUE);
            *lpHomeShare = 0; //  null string
            SetUserEnvironmentVariable(pEnv, HOMESHARE_VARIABLE, lpHomeShare, TRUE);
            if (*lpHomeDir) {
                lpHomeDir += 2;
            }
            // Update the homepath variable to reflect the correct value
            // Same sizes thus safe
            lstrcpy (lpHomePath, lpHomeDir);
            SetUserEnvironmentVariable(pEnv, HOMEPATH_VARIABLE, lpHomeDir, TRUE);
        }
        
    goto UpdateHomeVars;
    }
    /*
     * Test if homedir is a local directory.'?:\foo\bar'
     */
    if (IsUNCPath(lpHomeDir)) {
        NETRESOURCE NetResource;
        BOOL bOpenedHKCU;
        /*
         * lpHomeDir is a UNC path, use lpHomedrive.
         */

        //
        // First, try the (possibly) deep path:
        //

        ZeroMemory( &NetResource, sizeof( NetResource ) );

        NetResource.lpLocalName = lpHomeDrive;
        NetResource.lpRemoteName = lpHomeDir;
        NetResource.lpProvider = NULL;
        NetResource.dwType = RESOURCETYPE_DISK;


        dwConnectHomeDirToRoot = 0; // default

        bOpenedHKCU = OpenHKeyCurrentUser(pGlobals);

        //
        // Impersonate the user
        //

        ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

        if (ImpersonationHandle != NULL) {

            //
            // See the registry value to see whether we should really try to map
            // the whole directory or just map to the root..
            //

            if ((pGlobals->UserProcessData).hCurrentUser) {

                lResult = RegOpenKeyEx((pGlobals->UserProcessData).hCurrentUser, WINLOGON_POLICY_KEY, 0, KEY_READ, &hUserPolicy);

                if (lResult == ERROR_SUCCESS) {
                    dwSize = sizeof(DWORD);

                    if (ERROR_SUCCESS == RegQueryValueEx (hUserPolicy,
                                 TEXT("ConnectHomeDirToRoot"),
                                 NULL,
                                 &dwType,
                                 (LPBYTE) &dwConnectHomeDirToRoot,
                                 &dwSize))
                    {
                        if (REG_DWORD != dwType)
                        {
                            // Restore default
                            dwConnectHomeDirToRoot = 0; // default
                        }
                    }

                   RegCloseKey(hUserPolicy);
                }
            }

            //
            // Revert to being 'ourself'
            //

            if (!StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
            }

            //
            // Set it to NULL
            //

            ImpersonationHandle = NULL;
        }
        else {
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to impersonate user"));
        }

        if (bOpenedHKCU)
            CloseHKeyCurrentUser(pGlobals);


        if (!dwConnectHomeDirToRoot) {

            error = AddNetworkConnection( pGlobals, &NetResource );

            if (error == ERROR_SUCCESS) {

                //
                // (possibly) deep path worked!
                //

                if ( DeepShare )
                {
                    //
                    // Set homepath to just "\"
                    //
                    lstrcpy( lpHomePath, TEXT("\\") );

                    // Also update the value of homeshare to reflect the correct value
                    lstrcpy (lpHomeShare, lpHomeDir);

                    SetUserEnvironmentVariable(pEnv, HOMESHARE_VARIABLE, lpHomeShare, TRUE);
                    SetUserEnvironmentVariable(pEnv, HOMEPATH_VARIABLE, lpHomePath, TRUE);
                }
            }
            else {
                dwConnectHomeDirToRoot = TRUE;
            }
        }


        if (dwConnectHomeDirToRoot)  {


            NetResource.lpLocalName = lpHomeDrive;
            NetResource.lpRemoteName = lpHomeShare;
            NetResource.lpProvider = NULL;
            NetResource.dwType = RESOURCETYPE_DISK;

            error = AddNetworkConnection( pGlobals, &NetResource );

            if ( error )
            {
                ReportWinlogonEvent(
                        EVENTLOG_ERROR_TYPE,
                        EVENT_SET_HOME_DIRECTORY_FAILED,
                        sizeof(error),
                        &error,
                        2,
                        lpHomeDrive,
                        lpHomeShare);

                goto DefaultDirectory;
            }
        }

        lstrcpy(lpHomeDir, lpHomeDrive);

        if ( lpHomePath &&
            (*lpHomePath != TEXT('\\')))
        {
#pragma prefast(suppress: 31, "PREfast noise")
            StringCchCat(lpHomeDir, MAX_PATH, TEXT("\\"));

        }

#pragma prefast(suppress: 31, "PREfast noise")
        StringCchCat(lpHomeDir, MAX_PATH, lpHomePath);

        //
        // Impersonate the user
        //

        ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

        if (ImpersonationHandle == NULL) {
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to impersonate user"));
        }

        if (!SetCurrentDirectory(lpHomeDir)) {
            error = GetLastError();
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to SetCurrentDirectory '%ws', error = %d\n",
                             lpHomeDir, error));
            //
            // Revert to being 'ourself'
            //

            if (ImpersonationHandle && !StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
            }

            goto DefaultDirectory;
        }
    }
    else {
        /*
         * lpHomeDir is a local path or absolute local path.
         */

        //
        // Impersonate the user
        //

        ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

        if (ImpersonationHandle == NULL) {
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to impersonate user"));
        }

        if (!SetCurrentDirectory(lpHomeDir)) {
            error = GetLastError();
            DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to SetCurrentDirectory '%ws', error = %d",
                             lpHomeDir, error));
            //
            // Revert to being 'ourself'
            //

            if (ImpersonationHandle && !StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
            }

            goto DefaultDirectory;
        }
    }

    //
    // Revert to being 'ourself'
    //

    if (ImpersonationHandle && !StopImpersonating(ImpersonationHandle)) {
        DebugLog((DEB_ERROR, "ChangeToHomeDirectory : Failed to revert to self"));
    }
    
    
UpdateHomeVars:
    //
    // Update the value of the home variables in the volatile environment
    // so that SHGetFolderPath expands these variables correctly. However,
    // no need to do this, if we did not have a homedir in the first place
    // This prevents us from overwriting the homedir variables set up by
    // logon scripts which some customers like CSFB do.
    //
    if (!bNoHomeDir)
        UpdateHomeVarsInVolatileEnv (pGlobals, lpHomeDrive, lpHomeShare, lpHomePath);

    return;
}

/***************************************************************************\
* ProcessAutoexec
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL
ProcessAutoexec(
    PVOID *pEnv,
    LPTSTR lpPathVariable
    )
{
    HANDLE fh;
    DWORD dwFileSize;
    DWORD dwBytesRead;
    CHAR *lpBuffer = NULL;
    CHAR *token;
    CHAR Seps[] = "&\n\r";   // Seperators for tokenizing autoexec.bat
    BOOL Status = FALSE;
    TCHAR szAutoExecBat [] = TEXT("c:\\autoexec.bat");
    UINT uiErrMode;


    uiErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    fh = CreateFile (szAutoExecBat, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    SetErrorMode (uiErrMode);

    if (fh ==  INVALID_HANDLE_VALUE) {
        return(FALSE);  //could not open autoexec.bat file, we're done.
    }

    dwFileSize = GetFileSize(fh, NULL);
    if (dwFileSize == -1) {
        goto Exit;      // can't read the file size
    }

    lpBuffer = Alloc(dwFileSize+1);
    if (!lpBuffer) {
        goto Exit;
    }

    Status = ReadFile(fh, lpBuffer, dwFileSize, &dwBytesRead, NULL);
    if (!Status) {
        goto Exit;      // error reading file
    }

    //
    // Zero terminate the buffer so we don't walk off the end
    //

    ASSERT(dwBytesRead <= dwFileSize);
    lpBuffer[dwBytesRead] = 0;

    //
    // Search for SET and PATH commands
    //

    token = strtok(lpBuffer, Seps);
    while (token != NULL) {
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (*token == TEXT('@'))
            token++;
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (!_strnicmp(token, "PATH", 4)) {
            STRING String;
            UNICODE_STRING UniString;

            RtlInitString(&String, (LPSTR)token);
            RtlAnsiStringToUnicodeString(&UniString, &String, TRUE);

            ProcessCommand(UniString.Buffer, pEnv);
            //ProcessCommand(token, pEnv);

            RtlFreeUnicodeString(&UniString);
        }
        if (!_strnicmp(token, "SET", 3)) {
            STRING String;
            UNICODE_STRING UniString;

            RtlInitString(&String, (LPSTR)token);
            RtlAnsiStringToUnicodeString(&UniString, &String, TRUE);

            ProcessSetCommand(UniString.Buffer, pEnv);
            //ProcessSetCommand(token, pEnv);

            RtlFreeUnicodeString(&UniString);
        }
        token = strtok(NULL, Seps);
    }
Exit:
    CloseHandle(fh);
    if (lpBuffer) {
        Free(lpBuffer);
    }
    if (!Status) {
        DebugLog((DEB_ERROR, "Cannot process autoexec.bat."));
    }
    return(Status);
}

/***************************************************************************\
* ProcessCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessCommand(LPTSTR lpStart, PVOID *pEnv)
{
    LPTSTR lpt, lptt;
    LPTSTR lpVariable;
    LPTSTR lpValue;
    LPTSTR lpExpandedValue = NULL;
    TCHAR c;
    DWORD cb, cbNeeded;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt == TEXT(' '); lpt++) //skip spaces
        ;

    if (!*lpt)
       return(FALSE);

    lptt = lpt;
    for (; *lpt && *lpt != TEXT(' ') && *lpt != TEXT('='); lpt++) //find end of variable name
        ;

    c = *lpt;
    *lpt = 0;
    cb = lstrlen(lptt) + 1;
    if (cb > MAX_PATH)          // Same limit as when read from the registry
    {
        cb = MAX_PATH;
    }
    lpVariable = Alloc(sizeof(TCHAR)*cb);
    if (!lpVariable)
        return(FALSE);
    lstrcpyn(lpVariable, lptt, cb);
    *lpt = c;

    //
    // Find environment variable value.
    //
    for (; *lpt && (*lpt == TEXT(' ') || *lpt == TEXT('=')); lpt++)
        ;

    if (!*lpt) {
       // if we have a blank path statement in the autoexec file,
       // then we don't want to pass "PATH" as the environment
       // variable because it trashes the system's PATH.  Instead
       // we want to change the variable AutoexecPath.  This would have
       // be handled below if a value had been assigned to the
       // environment variable.
       if (lstrcmpi(lpVariable, PATH_VARIABLE) == 0)
          {
          SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, TEXT(""), TRUE);
          }
       else
          {
          SetUserEnvironmentVariable(pEnv, lpVariable, TEXT(""), TRUE);
          }
       Free(lpVariable);
       return(FALSE);
    }

    lptt = lpt;
    for (; *lpt; lpt++)  //find end of varaible value
        ;

    c = *lpt;
    *lpt = 0;
    cb = lstrlen(lptt) + 1;
    if (cb > 4096)                  // Same limit as when reading from the registry
    {
        cb = 4096;
    }
        
    lpValue = Alloc(sizeof(TCHAR)*cb);
    if (!lpValue) {
        Free(lpVariable);
        return(FALSE);
    }

    lstrcpyn(lpValue, lptt, cb);
    *lpt = c;

    cb = 1024;
    lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
    if (lpExpandedValue) {
        if (!lstrcmpi(lpVariable, PATH_VARIABLE)) {
            lpValue = ProcessAutoexecPath(pEnv, lpValue, lstrlen(lpValue)+1);
        }
        cbNeeded = ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
        if (cbNeeded > cb) {
            Free(lpExpandedValue);
            cb = cbNeeded;
            lpExpandedValue = Alloc(sizeof(TCHAR)*cb);
            if (lpExpandedValue) {
                ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
            }
        }
    }

    if (!lpExpandedValue) {
        lpExpandedValue = lpValue;
    }
    if (lstrcmpi(lpVariable, PATH_VARIABLE)) {
        SetUserEnvironmentVariable(pEnv, lpVariable, lpExpandedValue, FALSE);
    }
    else {
        SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, lpExpandedValue, TRUE);

    }

    if (lpExpandedValue != lpValue) {
        Free(lpExpandedValue);
    }
    Free(lpVariable);
    Free(lpValue);

    return(TRUE);
}

/***************************************************************************\
* ProcessSetCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessSetCommand(LPTSTR lpStart, PVOID *pEnv)
{
    LPTSTR lpt;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt != TEXT(' '); lpt++)
        ;

    if (!*lpt || !_wcsnicmp(lpt,TEXT("COMSPEC"), 7))
       return(FALSE);

    return (ProcessCommand(lpt, pEnv));

}

/***************************************************************************\
* ProcessAutoexecPath
*
* Creates AutoexecPath environment variable using autoexec.bat
* LpValue may be freed by this routine.
*
* History:
* 06-02-92  Johannec     Created.
*
\***************************************************************************/
LPTSTR ProcessAutoexecPath(PVOID *pEnv, LPTSTR lpValue, DWORD cb)
{
    LPTSTR lpt;
    LPTSTR lpStart;
    LPTSTR lpPath;
    DWORD cbt;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    BOOL bPrevAutoexecPath;
    WCHAR ch;
    DWORD dwTemp, dwCount = 0;

    cbt = 1024;
    lpt = Alloc(sizeof(TCHAR)*cbt);
    if (!lpt) {
        return(lpValue);
    }
    *lpt = 0;
    lpStart = lpValue;

    RtlInitUnicodeString(&Name, AUTOEXECPATH_VARIABLE);
    Value.Buffer = Alloc(sizeof(TCHAR)*cbt);
    if (!Value.Buffer) {
        goto Fail;
    }

    // lpt always points to the beggining of the allocated buffer
    // Its size is always sizeof(TCHAR)*cbt AND cbt=1024
    // At all times dwCount is the number of TCHARs in lpt

    while (lpPath = wcsstr (lpValue, TEXT("%"))) {
        if (!_wcsnicmp(lpPath+1, TEXT("PATH%"), 5)) {
            //
            // check if we have an autoexecpath already set, if not just remove
            // the %path%
            //
            Value.Length = (USHORT)cbt;
            Value.MaximumLength = (USHORT)cbt;
            bPrevAutoexecPath = (BOOL)!RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
               lstrcat(lpt, lpValue);
               dwCount = dwTemp;
            }
            if (bPrevAutoexecPath) {
                dwTemp = dwCount + Value.Length/sizeof(WCHAR);
                if (dwTemp < cbt) {
                    memcpy(lpt, Value.Buffer, Value.Length);
                    dwCount = dwTemp;
                    Value.Buffer[dwCount] = 0;
                 }
            }

            *lpPath++ = TEXT('%');
            lpPath += 5;  // go passed %path%
            lpValue = lpPath;
        }
        else {
            lpPath = wcsstr(lpPath+1, TEXT("%"));
            if (!lpPath) {
                lpStart = NULL;
                goto Fail;
            }
            lpPath++;
            ch = *lpPath;
            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
                lstrcat(lpt, lpValue);
                dwCount = dwTemp;
            }
            *lpPath = ch;
            lpValue = lpPath;
        }
    }

    if (*lpValue) {
       dwTemp = dwCount + lstrlen (lpValue);
       if (dwTemp < cbt) {
           lstrcat(lpt, lpValue);
           dwCount = dwTemp;
       }
    }

    Free(lpStart);

    Free(Value.Buffer);

    return(lpt);
Fail:

    if ( Value.Buffer )
    {
        Free(Value.Buffer);
    }

    Free(lpt);
    return(lpStart);
}


/***************************************************************************\
* AppendNTPathWithAutoexecPath
*
* Gets the AutoexecPath created in ProcessAutoexec, and appends it to
* the NT path.
*
* History:
* 05-28-92  Johannec     Created.
*
\***************************************************************************/
BOOL
AppendNTPathWithAutoexecPath(
    PVOID *pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    TCHAR AutoexecPathValue[1024];
    DWORD cb;
    BOOL Success;

    if (!*pEnv) {
        return(FALSE);
    }

        // Always called with short constant name
    RtlInitUnicodeString(&Name, lpAutoexecPath);
    cb = sizeof(WCHAR)*1023;
    Value.Buffer = Alloc(cb);
    if (!Value.Buffer) {
        return(FALSE);
    }

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        Free(Value.Buffer);
        return(FALSE);
    }

    if (Value.Length) {
        memcpy(AutoexecPathValue, Value.Buffer, Value.Length);
        AutoexecPathValue[Value.Length/sizeof(WCHAR)] = 0;
    }

    Free(Value.Buffer);

    Success = BuildEnvironmentPath(pEnv, lpPathVariable, AutoexecPathValue);
    RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    return(Success);
}


/***************************************************************************\
* AddNetworkConnection
*
* calls WNetAddConnection in the user's context.
*
* History:
* 6-26-92  Johannec     Created
*
\***************************************************************************/
LONG
AddNetworkConnection(PGLOBALS pGlobals, LPNETRESOURCE lpNetResource)
{
    HANDLE ImpersonationHandle;
    TCHAR szMprDll[] = TEXT("mpr.dll");
    CHAR szWNetAddConn[] = "WNetAddConnection2W";
    CHAR szWNetCancelConn[] = "WNetCancelConnection2W";
    DWORD (APIENTRY *lpfnWNetAddConn)(LPNETRESOURCE, LPTSTR, LPTSTR, DWORD);
    DWORD (APIENTRY *lpfnWNetCancelConn)(LPCTSTR, DWORD, BOOL);
    DWORD (APIENTRY *lpfnWNetGetConn)(LPCTSTR, LPTSTR, LPDWORD);
    DWORD WNetResult;

    //
    // Impersonate the user
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

    if (ImpersonationHandle == NULL) {
        DebugLog((DEB_ERROR, "AddNetworkConnection : Failed to impersonate user"));
        return(ERROR_ACCESS_DENIED);
    }


    //
    // Call the add connection api in the users context
    //

    if (!pGlobals->hMPR) {
        // wasn't loaded, try to load it now.
        pGlobals->hMPR = LoadLibrary(szMprDll);
    }

    if (pGlobals->hMPR) {

        if (lpfnWNetAddConn = (DWORD (APIENTRY *)(LPNETRESOURCE, LPTSTR, LPTSTR, DWORD))
                GetProcAddress(pGlobals->hMPR, (LPSTR)szWNetAddConn)) {

            LPTSTR lpRemoteName = NULL;
            DWORD nLength;
            BOOL fSame = FALSE;

            WNetResult = (*lpfnWNetAddConn)(lpNetResource,
                                            NULL,
                                            NULL,
                                            0);

            //
            // When LUID DosDevices are disabled,
            //     console users share the same DosDevices
            // With LUID DosDevices enabled,
            //     users each get their own DosDevices
            //

            if ( (WNetResult == ERROR_ALREADY_ASSIGNED) ||
                 (WNetResult == ERROR_DEVICE_ALREADY_REMEMBERED) )
            {
                if (lpfnWNetGetConn = (DWORD (APIENTRY *)(LPCTSTR, LPTSTR, LPDWORD))
                    GetProcAddress(pGlobals->hMPR, "WNetGetConnectionW")) {

                    nLength = (DWORD) (wcslen(lpNetResource->lpRemoteName) + 1);
                    lpRemoteName = Alloc(nLength * sizeof(TCHAR));

                    if (lpRemoteName) {
                        if (NO_ERROR ==  lpfnWNetGetConn(lpNetResource->lpLocalName, 
                                                         lpRemoteName,
                                                         &nLength)) {
                            if (wcscmp(lpRemoteName, lpNetResource->lpRemoteName) == 0)
                            {
                                fSame = TRUE;
                                WNetResult = ERROR_SUCCESS;
                            }
                        }

                        Free(lpRemoteName);
                    }                        
                }


                if (!fSame) {
                    // Drive is already assigned -- undo it and retry.  This is to prevent a
                    // user from subst-ing a drive to another user's home drive so the other
                    // user's home drive points somewhere inappropriate on next logon.

                    if (lpfnWNetCancelConn = (DWORD (APIENTRY *)(LPCTSTR, DWORD, BOOL))
                            GetProcAddress(pGlobals->hMPR, (LPSTR)szWNetCancelConn)) {

                        WNetResult = lpfnWNetCancelConn(lpNetResource->lpLocalName,
                                                        0,
                                                        TRUE);
                    }

                    if ( (WNetResult != NO_ERROR) &&
                         (WNetResult == ERROR_ALREADY_ASSIGNED) && 
                         (GetLUIDDeviceMapsEnabled() == FALSE) )

                    {

                        // WNet didn't work -- try DefineDosDevice (as the user)
                        // to undo any drive substitutions that aren't background
                        // admin-level symlinks

                        DefineDosDevice(DDD_REMOVE_DEFINITION,
                                        lpNetResource->lpLocalName,
                                        NULL);
                    }
                
                    // Retry the connection

                    WNetResult = (*lpfnWNetAddConn)(lpNetResource,
                                                    NULL,
                                                    NULL,
                                                    0);
                }
            }

            if (WNetResult != ERROR_SUCCESS) {
                DebugLog((DEB_ERROR,
                          "WNetAddConnection2W to %ws failed, error = %d\n",
                          lpNetResource->lpRemoteName,
                          WNetResult));

                FreeLibrary(pGlobals->hMPR);
                pGlobals->hMPR = NULL;
                SetLastError( WNetResult );
            }

            if (!StopImpersonating(ImpersonationHandle)) {
                DebugLog((DEB_ERROR, "AddNetworkConnection : Failed to revert to self"));
            }

            return( WNetResult );


        } else {
            DebugLog((DEB_ERROR, "Failed to get address of WNetAddConnection2W from mpr.dll"));
        }

    } else {
        DebugLog((DEB_ERROR, "Winlogon failed to load mpr.dll for add connection"));
    }

    //
    // Unload mpr.dll.  Keeping it open messes up Novell and Banyan.
    //

    if ( pGlobals->hMPR ) {

        FreeLibrary(pGlobals->hMPR);
        pGlobals->hMPR = NULL;
    }

    //
    // Revert to being 'ourself'
    //

    if (!StopImpersonating(ImpersonationHandle)) {
        DebugLog((DEB_ERROR, "AddNetworkConnection : Failed to revert to self"));
    }

    //
    // This is the failure return.

    return( GetLastError() );
}


/***************************************************************************\
* GetLUIDDeviceMapsEnabled
*
* This function calls NtQueryInformationProcess() to determine if
* LUID device maps are enabled
*
* Return Value:
*
*   TRUE - LUID device maps are enabled
*
*   FALSE - LUID device maps are disabled
*
\***************************************************************************/

BOOL
GetLUIDDeviceMapsEnabled( VOID )
{
    ULONG LUIDDeviceMapsEnabled;
    NTSTATUS Status;

    //
    // Check if LUID Device Maps are enabled
    //
    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
        return( FALSE );
    }
    else {
        return (LUIDDeviceMapsEnabled != 0);
    }
}

#pragma prefast(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\dirtydlg.c ===
#include "msgina.h"

// This gives me a yucky feeling, but we
// use CRT all over the place in gina.
#include <stdio.h>

#include <windowsx.h>
#include <regstr.h>
#include <help.h>

#include <Wtsapi32.h>

#include "shtdnp.h"

#define DIRTY_SHUTDOWN_TIMEOUT 120

typedef struct _DIRTYDLGDATA
{
    REASONDATA ReasonData;

    DWORD dwFlags;
    BOOL fEndDialogOnActivate;
} DIRTYDLGDATA, *PDIRTYDLGDATA;

// Internal function prototypes
BOOL Dirty_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

BOOL Dirty_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

BOOL Dirty_OnEraseBkgnd(HWND hwnd, HDC hdc);

INT_PTR CALLBACK Dirty_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR DialogItemToGinaResult(DWORD dwDialogItem, BOOL fAutoPowerdown);

// Enable the OK button based on the selected reason code and the comments / bug id.
void Enable_OK( HWND hwnd, PDIRTYDLGDATA pdata ) {
    if ( ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect )
        || ReasonCodeNeedsBugID( pdata->ReasonData.dwReasonSelect )) {
        // See if we have a comment.
        if ( pdata->ReasonData.cCommentLen == 0 ) {
            EnableWindow( GetDlgItem( hwnd, IDOK ), FALSE );
            return;
        }
    }
    // Don't care about bugID anymore.
#if 0
    if ( ReasonCodeNeedsBugID( pdata->ReasonData.dwReasonSelect )) {
        // See if we have a BugID.
        if ( pdata->ReasonData.cBugIDLen == 0 ) {
            EnableWindow( GetDlgItem( hwnd, IDOK ), FALSE );
            return;
        }
    }
#endif
    EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE );
}

BOOL Dirty_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    PDIRTYDLGDATA pdata = (PDIRTYDLGDATA) lParam;
    HWND hwndCombo;
    int iOption;
    int iComboItem;
    int nComboItemCnt;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);

    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        // Move all our controls down so the branding fits
        SizeForBranding(hwnd, FALSE);
    }

    // Set up the reason data.
    // Add the items specified to the combo box
    hwndCombo = GetDlgItem(hwnd, IDC_DIRTYREASONS_COMBO);

    for (iOption = 0; iOption < pdata->ReasonData.cReasons; iOption ++)
    {
        // Add the option
        iComboItem = ComboBox_AddString(hwndCombo,
            pdata->ReasonData.rgReasons[iOption]->szName);

        if (iComboItem != (int) CB_ERR)
        {
            // Store a pointer to the option
            ComboBox_SetItemData(hwndCombo, iComboItem,
                pdata->ReasonData.rgReasons[iOption]);

            // See if we should select this option
            if (pdata->ReasonData.rgReasons[iOption]->dwCode == pdata->ReasonData.dwReasonSelect)
            {
                ComboBox_SetCurSel(hwndCombo, iComboItem);
            }
        }
    }

    nComboItemCnt = ComboBox_GetCount(hwndCombo);
    if (nComboItemCnt > 0 && pdata->ReasonData.cCommentLen != 0)
    {
        int iItem;
        for (iItem = 0; iItem < nComboItemCnt; iItem++)
        {
            PREASON pReason = (PREASON) ComboBox_GetItemData(hwndCombo, iItem);
            if (pReason->dwCode ==  (UDIRTYUI | SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_BLUESCREEN))
            {
                ComboBox_SetCurSel(hwndCombo, iItem);
                Edit_SetText(GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT), pdata->ReasonData.szComment);
                EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE );
                break;
            }
        }
        if (iItem == nComboItemCnt) // failed to find the needed reason
        {
            ComboBox_SetCurSel(hwndCombo, 0);
            Edit_SetText(GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT), pdata->ReasonData.szComment);
            EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE );
        }

        SetReasonDescription(hwndCombo,
            GetDlgItem(hwnd, IDC_DIRTYREASONS_DESCRIPTION));
    }
    else
    {
        // If we don't have a selection in the combo, do a default selection
        if (ComboBox_GetCurSel(hwndCombo) == CB_ERR)
        {
            pdata->ReasonData.dwReasonSelect = pdata->ReasonData.rgReasons[ 0 ]->dwCode;
            ComboBox_SetCurSel(hwndCombo, 0);
        }

        SetReasonDescription(hwndCombo,
            GetDlgItem(hwnd, IDC_DIRTYREASONS_DESCRIPTION));

        // Enable the OK button
        Enable_OK( hwnd, pdata );
    }

    // Setup the comment box and BugId boxes
    // We must fix the maximum characters.
    SendMessage( GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT), EM_LIMITTEXT, (WPARAM)MAX_REASON_COMMENT_LEN-1, (LPARAM)0 );
    SendMessage( GetDlgItem(hwnd, IDC_DIRTYREASONS_BUGID), EM_LIMITTEXT, (WPARAM)MAX_REASON_BUGID_LEN-1, (LPARAM)0 );

    // If we get an activate message, dismiss the dialog, since we just lost
    // focus
    pdata->fEndDialogOnActivate = TRUE;

    CentreWindow(hwnd);

    return TRUE;
}


BOOL Dirty_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL fHandled = FALSE;
    DWORD dwDlgResult = TRUE;
    PDIRTYDLGDATA pdata = (PDIRTYDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (id)
    {
    case IDOK:
        if (codeNotify == BN_CLICKED)
        {
            LPWSTR  szComment           = NULL;
            LPWSTR  szBugID             = NULL;
            LPWSTR  szBugCheckString    = NULL;
            DWORD  dwCommentLen, dwBugIDLen, dwBugCheckStringLen;
            int    ilen = 0;

            pdata->ReasonData.dwReasonSelect = GetReasonSelection(GetDlgItem(hwnd, IDC_DIRTYREASONS_COMBO));
            if (pdata->ReasonData.dwReasonSelect == SHTDN_REASON_UNKNOWN )
            {
                fHandled = TRUE;
                EndDialog(hwnd, (int) dwDlgResult);
                break;
            }

            dwBugCheckStringLen = (DWORD) wcslen (pdata->ReasonData.szComment);

            szComment = (LPWSTR)LocalAlloc(LPTR, (MAX_REASON_COMMENT_LEN)*sizeof(WCHAR));
            szBugID   = (LPWSTR)LocalAlloc(LPTR, (MAX_REASON_BUGID_LEN)*sizeof(WCHAR));
            szBugCheckString = (LPWSTR)LocalAlloc(LPTR, (dwBugCheckStringLen+1)*sizeof(WCHAR));

            if ( szComment && szBugID && szBugCheckString )
            {
                wcscpy(szBugCheckString, pdata->ReasonData.szComment);

                // Fill the comment field with the Problem Id followed by the comment on a new line.
                dwBugIDLen = GetWindowText( GetDlgItem(hwnd, IDC_DIRTYREASONS_BUGID), szBugID, MAX_REASON_BUGID_LEN);

                dwCommentLen = GetWindowText( GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT),
                                                                szComment,
                                                                MAX_REASON_COMMENT_LEN);

                szComment[MAX_REASON_COMMENT_LEN-1] = szBugID[MAX_REASON_BUGID_LEN-1] = 0;

                ilen = _snwprintf (pdata->ReasonData.szComment,
                            MAX_REASON_COMMENT_LEN,
                            L"%d\n%s%d\n%s%d\n%s",
                            dwBugIDLen, szBugID,
                            dwBugCheckStringLen, szBugCheckString,
                            dwCommentLen, szComment);
                pdata->ReasonData.szComment[MAX_REASON_COMMENT_LEN-1] = 0;
                if (ilen <= 0)
                    pdata->ReasonData.cCommentLen = MAX_REASON_COMMENT_LEN-1;
                else
                    pdata->ReasonData.cCommentLen = ilen;

                pdata->fEndDialogOnActivate = FALSE;
            }
            else
            {
                pdata->ReasonData.cCommentLen = 0;
                pdata->ReasonData.szComment[0] = 0;
            }

            LocalFree( szComment );
            LocalFree( szBugID  );
            LocalFree( szBugCheckString );

            fHandled = TRUE;
            EndDialog(hwnd, (int) dwDlgResult);
        }
        break;
    case IDC_DIRTYREASONS_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetReasonDescription(hwndCtl,
                GetDlgItem(hwnd, IDC_DIRTYREASONS_DESCRIPTION));
            pdata->ReasonData.dwReasonSelect = GetReasonSelection(hwndCtl);
            Enable_OK( hwnd, pdata );

            fHandled = TRUE;
        }
        break;
    case IDC_DIRTYREASONS_COMMENT:
        if ( codeNotify == EN_CHANGE)
        {
            pdata->ReasonData.cCommentLen = GetWindowTextLength( GetDlgItem(hwnd, IDC_DIRTYREASONS_COMMENT));
            Enable_OK( hwnd, pdata );
            fHandled = TRUE;
        }
        break;
    case IDC_DIRTYREASONS_BUGID:
        if ( codeNotify == EN_CHANGE)
        {
            pdata->ReasonData.cBugIDLen = GetWindowTextLength( GetDlgItem(hwnd, IDC_DIRTYREASONS_BUGID));
            Enable_OK( hwnd, pdata );
            fHandled = TRUE;
        }
        break;
    case IDHELP:
        if (codeNotify == BN_CLICKED)
        {
            WinHelp(hwnd, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
        }
        break;
    }
    return fHandled;
}

BOOL Dirty_OnEraseBkgnd(HWND hwnd, HDC hdc)
{
    BOOL fRet;
    PDIRTYDLGDATA pdata = (PDIRTYDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // Draw the branding bitmap
    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        fRet = PaintBranding(hwnd, hdc, 0, FALSE, FALSE, COLOR_BTNFACE);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

INT_PTR CALLBACK Dirty_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Dirty_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Dirty_OnCommand);
        HANDLE_MSG(hwnd, WM_ERASEBKGND, Dirty_OnEraseBkgnd);
        case WLX_WM_SAS:
        {
            // If this is someone hitting C-A-D, swallow it.
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
                return TRUE;
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            return FALSE;
        }
        break;
        case WM_INITMENUPOPUP:
        {
            EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        }
        break;
        case WM_SYSCOMMAND:
            // Blow off moves (only really needed for 32bit land).
            if ((wParam & ~0x0F) == SC_MOVE)
                return TRUE;
            break;
    }

    return FALSE;
}

/****************************************************************************
 WinlogonDirtyDialog
 --------------

  Launches the shutdown dialog.

  If hWlx and pfnWlxDialogBoxParam are non-null, pfnWlxDialogBoxParam will
  be used to launch the dialog box so we can intelligently respond to WLX
  messages. Only if WinLogon is the caller should this be done.

  Other flags are listed in shtdndlg.h.
****************************************************************************/
INT_PTR
WinlogonDirtyDialog(
    HWND hwndParent,
    PGLOBALS pGlobals
    )
{
    // Array of shutdown options - the dialog data
    DIRTYDLGDATA data;
    DWORD dwResult = WLX_SAS_ACTION_LOGON;

    HKEY            hKey = 0;
    DWORD           rc;
    DWORD           DirtyShutdownHappened;
    DWORD           ValueSize = sizeof (DWORD);
    DWORD            dwBugcheckStringSize = (MAX_REASON_COMMENT_LEN - 1)* sizeof(WCHAR);
    BOOL            fNeedToWriteBack = FALSE;

    if (!pGlobals)
        return dwResult;

    if (! TestUserPrivilege (pGlobals->UserProcessData.UserToken, SE_SHUTDOWN_PRIVILEGE))
        goto cleanup;

    // Set the initially selected item
    data.ReasonData.dwReasonSelect = 0;
    data.ReasonData.rgReasons = 0;
    data.ReasonData.cReasons = 0;
    data.ReasonData.cReasonCapacity = 0;

    //
    //    We only show this dialog if SET is enabled.
    //
    if (IsSETEnabled()) {

        //
        //    We need to open the reliability key.
        //
        rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE, REGSTR_PATH_RELIABILITY, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hKey, NULL);

        ValueSize = sizeof(DWORD);
        if (rc == ERROR_SUCCESS)
        {
            rc = RegQueryValueEx (hKey, L"DirtyShutDown", NULL, NULL, (UCHAR *)&DirtyShutdownHappened, &ValueSize);
            if ( (rc == ERROR_SUCCESS) && (DirtyShutdownHappened) ) {
                
                // Read in the strings for the shutdown option names and descriptions
                if ( BuildReasonArray( &data.ReasonData, FALSE, TRUE ))
                {
                    data.ReasonData.szBugID[ 0 ] = 0;
                    data.ReasonData.cBugIDLen = 0;

                    //If a bugcheck happenned, get the bugcheck string from registry.
                    rc = RegQueryValueEx (hKey, L"BugcheckString", NULL, NULL, (LPBYTE)data.ReasonData.szComment, &dwBugcheckStringSize);
                    if (rc != ERROR_SUCCESS)
                    {
                        data.ReasonData.szComment[ 0 ] = 0;
                        data.ReasonData.cCommentLen = 0;
                    }
                    else
                    {
                        data.ReasonData.cCommentLen = dwBugcheckStringSize / sizeof(WCHAR);
                        data.ReasonData.szComment[MAX_REASON_COMMENT_LEN - 1] = 0;
                    }

                    // Display the dialog and return the user's selection

                    // Figure out what flags to pass
                    // for sure no help button
                    data.dwFlags = SHTDN_NOHELP;

                    // On terminal server, no branding bitmap either
                    if ( GetSystemMetrics( SM_REMOTESESSION ))
                    {
                        data.dwFlags |= SHTDN_NOBRANDINGBITMAP;
                    }

                    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, DIRTY_SHUTDOWN_TIMEOUT);
                    dwResult = ( DWORD )pWlxFuncs->WlxDialogBoxParam( pGlobals->hGlobalWlx,
                        hDllInstance, MAKEINTRESOURCE( IDD_DIRTY_DIALOG ),
                        hwndParent, Dirty_DialogProc, ( LPARAM )&data );

                    // If we timed out then log the user off.
                    if ( (int)dwResult <= 0 )
                    {
                        DestroyReasons( &data.ReasonData );
                        dwResult = WLX_SAS_ACTION_LOGOFF;
                    }
                    else
                    {
                        dwResult = WLX_SAS_ACTION_LOGON;

                        if ( RegDeleteValue( hKey, L"DirtyShutDown" ) == ERROR_SUCCESS )
                        {
                            // Record the event.
                            SHUTDOWN_REASON sr;
                            sr.cbSize = sizeof(SHUTDOWN_REASON);
                            sr.uFlags = EWX_SHUTDOWN;
                            sr.dwReasonCode = data.ReasonData.dwReasonSelect;
                            sr.dwEventType = SR_EVENT_DIRTY;
                            sr.lpszComment = data.ReasonData.szComment;

                            if (ImpersonateLoggedOnUser(pGlobals->UserProcessData.UserToken))
                            {
                                RecordShutdownReason(&sr);
                                RevertToSelf();
                                RegDeleteValue( hKey, L"BugcheckString");
                                dwResult = TRUE;
                            }
                            else
                            {
                                fNeedToWriteBack = TRUE;
                            }
                        }

                        // Destroy the allocated data.
                        DestroyReasons( &data.ReasonData );
                    }
                }
            }
        }
        else
        {
            hKey = NULL;
        }
    }

cleanup:
    if (hKey && fNeedToWriteBack)
    {
        DWORD dwDirtyShutdownFlag = 1;
        RegSetValueEx(  hKey,
                        L"DirtyShutDown",
                        0,
                        REG_DWORD,
                        (PUCHAR) &dwDirtyShutdownFlag,
                        sizeof(DWORD));
    }

    if (hKey)
        RegCloseKey (hKey);

    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\langicon.c ===
#include "msgina.h"
#include <shellapi.h>

typedef struct
{
    HKL dwHkl;
    HICON hIcon;

} LAYOUTINFO, *PLAYOUTINFO;

typedef struct
{
    HKL hklLast;
    PLAYOUTINFO pLayoutInfo;
    UINT uNumLayouts;
} USERLAYOUTINFO, *PUSERLAYOUTINFO;

HICON
CreateLangIdIcon(
    WORD LangId);
int
CreateIconList(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs); 

HICON
GetIconFromHkl(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs); 


USERLAYOUTINFO UserLayoutInfo[2];

typedef BOOL  (WINAPI *LPFNIMMGETIMEFILENAME)(HKL, LPTSTR, UINT);
LPFNIMMGETIMEFILENAME pfnImmGetImeFileName = NULL;
TCHAR szImm32DLL[] = TEXT("imm32.dll");

typedef UINT (WINAPI *PFNEXTRACTICONEXW)(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons);
 



/***************************************************************************\
* FUNCTION: CreateLangIdIcon
*
* PURPOSE:  Create an icon that displays the first two letters of the 
*           supplied language ID.
*
* RETURNS:  Icon that shows displays Language ID.
*
* HISTORY:
*
*   04-17-98  ShanXu       Borrowed from internat.exe
*
\***************************************************************************/

HICON
CreateLangIdIcon(
    WORD langID
    )
{
    HBITMAP hbmColour = NULL;
    HBITMAP hbmMono;
    HBITMAP hbmOld;
    HICON hicon = NULL;
    ICONINFO ii;
    RECT rc;
    DWORD rgbText;
    DWORD rgbBk = 0;
    HDC hdc = NULL;
    HDC hdcScreen;
    LOGFONT lf;
    HFONT hfont;
    HFONT hfontOld;
    TCHAR szData[20];
    UINT cxSmIcon, cySmIcon;
    

    cxSmIcon =  GetSystemMetrics(SM_CXSMICON);
    cySmIcon =  GetSystemMetrics(SM_CYSMICON);
    //
    //  Get the indicator by using the first 2 characters of the
    //  abbreviated language name.
    //
    if (GetLocaleInfo( MAKELCID(langID, SORT_DEFAULT),
                       LOCALE_SABBREVLANGNAME | LOCALE_NOUSEROVERRIDE,
                       szData,
                       sizeof(szData) / sizeof(szData[0]) ))
    {
        //
        //  Only use the first two characters.
        //
        szData[2] = TEXT('\0');
    }
    else
    {
        //
        //  Id wasn't found.  Use question marks.
        //
        szData[0] = TEXT('?');
        szData[1] = TEXT('?');
        szData[2] = TEXT('\0');
    }

    if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
#if (1) //DSIE: Bug 351507
        if (hdcScreen = GetDC(NULL))
        {         
            double dScaleY = GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0f;
            lf.lfHeight = (int) (lf.lfHeight * dScaleY); // Scale the height based on the system DPI.
            ReleaseDC(NULL, hdcScreen);
        }
#endif
        if ((hfont = CreateFontIndirect(&lf)))
        {
            hdcScreen = GetDC(NULL);
            if ( hdcScreen )
            {
                hdc = CreateCompatibleDC(hdcScreen);
                hbmColour = CreateCompatibleBitmap(hdcScreen, cxSmIcon, cySmIcon);
                ReleaseDC(NULL, hdcScreen);
            }

            if (hbmColour && hdc)
            {
                hbmMono = CreateBitmap(cxSmIcon, cySmIcon, 1, 1, NULL);
                if (hbmMono)
                {
                    hbmOld    = SelectObject(hdc, hbmColour);
                    rc.left   = 0;
                    rc.top    = 0;
                    rc.right  = cxSmIcon;
                    rc.bottom = cySmIcon;

                    rgbBk = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                    rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));

                    ExtTextOut( hdc,
                                rc.left,
                                rc.top,
                                ETO_OPAQUE,
                                &rc,
                                TEXT(""),
                                0,
                                NULL );
                    SelectObject(hdc, GetStockObject(DEFAULT_GUI_FONT));
                    hfontOld = SelectObject(hdc, hfont);
                    DrawText( hdc,
                              szData,
                              2,
                              &rc,
                              DT_CENTER | DT_VCENTER | DT_SINGLELINE );
#ifdef USE_MIRRORING
                    {
                        DWORD dwLayout;

                        GetProcessDefaultLayout(&dwLayout);
                        if (dwLayout & LAYOUT_RTL)
                        {
                            MirrorBitmapInDC(hdc, hbmColour);
                        }
                    }
#endif
                    SelectObject(hdc, hbmMono);
                    PatBlt(hdc, 0, 0, cxSmIcon, cySmIcon, BLACKNESS);
                    SelectObject(hdc, hbmOld);

                    ii.fIcon    = TRUE;
                    ii.xHotspot = 0;
                    ii.yHotspot = 0;
                    ii.hbmColor = hbmColour;
                    ii.hbmMask  = hbmMono;
                    hicon       = CreateIconIndirect(&ii);

                    DeleteObject(hbmMono);
                    SelectObject(hdc, hfontOld);
                }
                DeleteObject(hbmColour);
                DeleteDC(hdc);
            }
            DeleteObject(hfont);
        }
    }

    return (hicon);
}

/***************************************************************************\
* FUNCTION: CreateIconList
*
* PURPOSE:  Create the table that contains the relationship between an hkl
*           and an icon.
*
* RETURNS:  Index of the current hkl in the table.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
int
CreateIconList(
    PLAYOUTINFO pLayoutInfo,
    HKL hklCur,
    UINT uLangs)
{
    HKL *pLanguages;
    UINT uCount;
    int nCurIndex = -1;

    pLanguages = (HKL *)LocalAlloc(LPTR, uLangs * sizeof(HKL));
    if (!pLanguages)
    {
        return -1;
    }
    GetKeyboardLayoutList(uLangs, (HKL *)pLanguages);


    for (uCount = 0; uCount < uLangs; uCount++)
    {
        pLayoutInfo[uCount].dwHkl = pLanguages[uCount];
        if (pLanguages[uCount] == hklCur)
        {
            nCurIndex = uCount;
        }
        if ((HIWORD(pLanguages[uCount]) & 0xf000) == 0xe000)
        {
            WCHAR szIMEFile[32];   // assume long filename up to 32 byte

            if (!pfnImmGetImeFileName)
            {
                HMODULE hMod;
                hMod = GetModuleHandle(szImm32DLL);
                if (hMod)
                {
                    pfnImmGetImeFileName = (LPFNIMMGETIMEFILENAME) 
                                            GetProcAddress(
                                                hMod, 
                                                "ImmGetIMEFileNameW");
                }
            }
            if (pfnImmGetImeFileName &&
                (*pfnImmGetImeFileName) (pLanguages[uCount],
                                         szIMEFile,
                                         sizeof(szIMEFile) ))
            {
                HINSTANCE hInstShell32;
                PFNEXTRACTICONEXW pfnExtractIconExW;

                hInstShell32 = LoadLibrary (TEXT("shell32.dll"));

                if (hInstShell32)
                {
                    pfnExtractIconExW = (PFNEXTRACTICONEXW) GetProcAddress (hInstShell32,
                                        "ExtractIconExW");

                    if (pfnExtractIconExW)
                    {

                        //
                        //  First one of the file.
                        //
                        pfnExtractIconExW(
                                szIMEFile,
                                0,
                                NULL,
                                &pLayoutInfo[uCount].hIcon,
                                1);
                    }

                    FreeLibrary (hInstShell32);
                }
                continue;
            }
        }

        //
        // for non-ime layout
        //
        pLayoutInfo[uCount].hIcon = CreateLangIdIcon(LOWORD(pLanguages[uCount]));
        
    }

    LocalFree(pLanguages);

    return nCurIndex;
}

/***************************************************************************\
* FUNCTION: GetIconFromHkl
*
* PURPOSE:  Find the icon in our table that has a matching hkl
*           with the supplied hkl. Create the table if it does not
*           exist.
*
* RETURNS:  Icon of the macthing hkl.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created 
*
\***************************************************************************/
HICON
GetIconFromHkl(
    PLAYOUTINFO pLayoutInfo,
    HKL hkl,
    UINT uLangs)
{
    UINT uCount;
    int nIndex = -1;

    if (pLayoutInfo[0].dwHkl == 0)
    {
        //
        //  Icon/hkl list no exsists yet.  Create it.
        //
        nIndex = CreateIconList(pLayoutInfo, hkl, uLangs);
    }
    else
    {
        //  
        //  Find the icon with a matching hkl
        //
        for (uCount = 0; uCount < uLangs; uCount++)
        {
            if (pLayoutInfo[uCount].dwHkl == hkl)
            {
                nIndex = uCount;
                break;
            }
        }
    }

    if (nIndex == -1)
    {
        return NULL;
    }
    

    return ( pLayoutInfo[nIndex].hIcon);
}

/***************************************************************************\
* FUNCTION: DisplayLanguageIcon
*
* PURPOSE:  Displays the icon of the currently selected hkl in the
*           dlg window.
*
* RETURNS:  TRUE - The icon is displayed.
*           FALSE - No icon displayed.
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
BOOL
DisplayLanguageIcon(
    HWND hwnd,
    LAYOUT_USER LayoutUser,
    HKL  hkl)

{
    HICON hIconLayout;
    UINT uLangs;
    PLAYOUTINFO pLayout;
    
    uLangs = GetKeyboardLayoutList(0, NULL);
    if (uLangs < 2)
    {
        return FALSE;
    }

    pLayout = UserLayoutInfo[LayoutUser].pLayoutInfo;

    if (!pLayout)
    {
        pLayout = (PLAYOUTINFO)LocalAlloc(LPTR, uLangs * sizeof(LAYOUTINFO));

        if (!pLayout)
        {
            return FALSE;
        }

        UserLayoutInfo[LayoutUser].pLayoutInfo = pLayout;
        UserLayoutInfo[LayoutUser].uNumLayouts = uLangs;
    }
        

    hIconLayout = GetIconFromHkl(
                        pLayout, 
                        hkl,    
                        uLangs);

    if (!hIconLayout)
    {
        return FALSE;
    }

    SendMessage( 
        GetDlgItem(hwnd, IDD_KBLAYOUT_ICON),
        STM_SETICON,
        (WPARAM)hIconLayout,
        0 );

    UserLayoutInfo[LayoutUser].hklLast = hkl;

    SetTimer(hwnd, TIMER_MYLANGUAGECHECK, 500, NULL);
    return TRUE;
    
}

/***************************************************************************\
* FUNCTION: FreeLayoutInfo
*
* PURPOSE:  Delete the icon/hkl table and destroy all icons.
*
* RETURNS:  -
*
* HISTORY:
*
*   04-17-98  ShanXu      Created
*
\***************************************************************************/
void
FreeLayoutInfo(
    LAYOUT_USER LayoutUser)
{
    UINT uLangs;
    UINT uCount;

    PLAYOUTINFO pLayoutInfo;

    pLayoutInfo = UserLayoutInfo[LayoutUser].pLayoutInfo;

    if (!pLayoutInfo)
    {
        return;
    }

    uLangs = UserLayoutInfo[LayoutUser].uNumLayouts;
    for (uCount = 0; uCount < uLangs; uCount++)
    {
        DestroyIcon (pLayoutInfo[uCount].hIcon);
    }

    LocalFree(pLayoutInfo);
    UserLayoutInfo[LayoutUser].pLayoutInfo = NULL;
    UserLayoutInfo[LayoutUser].uNumLayouts = 0;

    return;
}

/***************************************************************************\
* FUNCTION: LayoutCheckHandler
*
* PURPOSE:  Handle layout check.  Set appropriate icon if there is
*           a change in keyboard layout.
*
* RETURNS:  -
*
* HISTORY:
*
*   04-22-98  ShanXu      Created
*
\***************************************************************************/
void
LayoutCheckHandler(
    HWND hwnd,
    LAYOUT_USER LayoutUser)
{
    HKL hklCurrent;

    KillTimer(hwnd, TIMER_MYLANGUAGECHECK);

    hklCurrent = GetKeyboardLayout(0);

    if (hklCurrent != UserLayoutInfo[LayoutUser].hklLast)
    {
        DisplayLanguageIcon(
            hwnd,
            LayoutUser,
            hklCurrent);

    }else{
        SetTimer(hwnd, TIMER_MYLANGUAGECHECK, 500, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\glue.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: glue.cpp
//
//  Copyright (c) 2000-2001, Microsoft Corporation
//
//  C File containing "glue" functions that the shell depot component of
//  msgina uses.
//
//  History:    2001-01-03  vtan        created
//              2001-01-11  vtan        added stub functions for imp library
//  --------------------------------------------------------------------------

extern "C"
{
    #include "msgina.h"
    #include "shtdnp.h"
}

//  --------------------------------------------------------------------------
//  ::_Gina_SasNotify
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              dwSASType       =   SAS type.
//
//  Returns:    <none>
//
//  Purpose:    Notifies winlogon of a generated SAS.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _Gina_SasNotify (void *pWlxContext, DWORD dwSASType)

{
    pWlxFuncs->WlxSasNotify(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx, dwSASType);
}

//  --------------------------------------------------------------------------
//  ::_Gina_SetTimeout
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              dwTimeout       =   Timeout value.
//
//  Returns:    BOOL
//
//  Purpose:    Sets the internal msgina timeout value for dialogs.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL        _Gina_SetTimeout (void *pWlxContext, DWORD dwTimeout)

{
    return(pWlxFuncs->WlxSetTimeout(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx, dwTimeout));
}

//  --------------------------------------------------------------------------
//  ::_Gina_DialogBoxParam
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              See the platform SDK under DialogBoxParam.
//
//  Returns:    See the platform SDK under DialogBoxParam.
//
//  Purpose:    Calls winlogon's implementation of DialogBoxParam.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    INT_PTR     _Gina_DialogBoxParam (void *pWlxContext, HINSTANCE hInstance, LPCWSTR pszTemplate, HWND hwndParent, DLGPROC pfnDlgProc, LPARAM lParam)

{
    return(pWlxFuncs->WlxDialogBoxParam(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx,
                                        hInstance,
                                        const_cast<LPWSTR>(pszTemplate),
                                        hwndParent,
                                        pfnDlgProc,
                                        lParam));
}

//  --------------------------------------------------------------------------
//  ::_Gina_MessageBox
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              See the platform SDK under MessageBox.
//
//  Returns:    See the platform SDK under MessageBox.
//
//  Purpose:    Calls winlogon's implementation of MessageBox.
//
//  History:    2001-03-02  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    INT_PTR     _Gina_MessageBox (void *pWlxContext, HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uiType)

{
    return(pWlxFuncs->WlxMessageBox(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx,
                                    hwnd,
                                    const_cast<LPWSTR>(pszText),
                                    const_cast<LPWSTR>(pszCaption),
                                    uiType));
}

//  --------------------------------------------------------------------------
//  ::_Gina_SwitchDesktopToUser
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    int
//
//  Purpose:    Calls winlogon's implementation for SwitchDesktopToUser.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int         _Gina_SwitchDesktopToUser (void *pWlxContext)

{
    return(pWlxFuncs->WlxSwitchDesktopToUser(static_cast<PGLOBALS>(pWlxContext)->hGlobalWlx));
}

//  --------------------------------------------------------------------------
//  ::_Gina_ShutdownDialog
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//              hwndParent      =   Parent HWND for dialog.
//              dwExcludeItems  =   Items to exclude from dialog.
//
//  Returns:    INT_PTR
//
//  Purpose:    Displays the shutdown that is hosted from winlogon not
//              explorer.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    INT_PTR     _Gina_ShutdownDialog (void *pWlxContext, HWND hwndParent, DWORD dwExcludeItems)

{
    return(static_cast<DWORD>(WinlogonShutdownDialog(hwndParent, static_cast<PGLOBALS>(pWlxContext), dwExcludeItems)));
}

//  --------------------------------------------------------------------------
//  ::_Gina_GetUserToken
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    HANDLE
//
//  Purpose:    Returns the user token handle. This handle must not be closed.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HANDLE      _Gina_GetUserToken (void *pWlxContext)

{
    return(static_cast<PGLOBALS>(pWlxContext)->UserProcessData.UserToken);
}

//  --------------------------------------------------------------------------
//  ::_Gina_GetUsername
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns the user name. Read only string.
//
//  History:    2001-03-28  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    const WCHAR*    _Gina_GetUsername (void *pWlxContext)

{
    return(static_cast<PGLOBALS>(pWlxContext)->UserName);
}

//  --------------------------------------------------------------------------
//  ::_Gina_GetDomain
//
//  Arguments:  pWlxContext     =   PGLOBALS struct.
//
//  Returns:    const WCHAR*
//
//  Purpose:    Returns the domain. Read only string.
//
//  History:    2001-03-28  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    const WCHAR*    _Gina_GetDomain (void *pWlxContext)

{
    return(static_cast<PGLOBALS>(pWlxContext)->Domain);
}

//  --------------------------------------------------------------------------
//  ::_Gina_SetTextFields
//
//  Arguments:  hwndDialog      =   HWND of the dialog.
//              pwszUsername    =   Username to set.
//              pwszDomain      =   Domain to set.
//              pwszPassword    =   Password to set.
//
//  Returns:    <none>
//
//  Purpose:    Sets the values of the msgina logon dialog to the given
//              values. This allows pass thru of credentials from the UI host
//              to msgina to do the work.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void        _Gina_SetTextFields (HWND hwndDialog, const WCHAR *pwszUsername, const WCHAR *pwszDomain, const WCHAR *pwszPassword)

{
    WCHAR   szDomain[DNLEN + sizeof('\0')];

    SetDlgItemText(hwndDialog, IDD_LOGON_NAME, pwszUsername);
    if ((pwszDomain == NULL) || (pwszDomain[0] == L'\0'))
    {
        DWORD   dwComputerNameSize;
        TCHAR   szComputerName[CNLEN + sizeof('\0')];

        dwComputerNameSize = ARRAYSIZE(szComputerName);
        if (GetComputerName(szComputerName, &dwComputerNameSize) != FALSE)
        {
            lstrcpyn(szDomain, szComputerName, ARRAYSIZE(szDomain));
        }
        pwszDomain = szDomain;
    }
    (LRESULT)SendMessage(GetDlgItem(hwndDialog, IDD_LOGON_DOMAIN),
                         CB_SELECTSTRING,
                         static_cast<WPARAM>(-1),
                         reinterpret_cast<LPARAM>(pwszDomain));
    SetDlgItemText(hwndDialog, IDD_LOGON_PASSWORD, pwszPassword);
}

//  --------------------------------------------------------------------------
//  ::_Gina_SetPasswordFocus
//
//  Arguments:  hwndDialog  =   HWND of dialog to set password focus.
//
//  Returns:    BOOL
//
//  Purpose:    Sets the focus to the password field in the dialog.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL        _Gina_SetPasswordFocus (HWND hwndDialog)

{
    return(SetPasswordFocus(hwndDialog));
}

//  --------------------------------------------------------------------------
//  ::ShellGetUserList
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    LONG    WINAPI  ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList)

{
    return(_ShellGetUserList(fRemoveGuest, pdwUserCount, pUserList));
}

//  --------------------------------------------------------------------------
//  ::ShellIsSingleUserNoPassword
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain)

{
    return(_ShellIsSingleUserNoPassword(pwszUsername, pwszDomain));
}

//  --------------------------------------------------------------------------
//  ::ShellIsFriendlyUIActive
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsFriendlyUIActive (void)

{
    return(_ShellIsFriendlyUIActive());
}

//  --------------------------------------------------------------------------
//  ::ShellIsMultipleUsersEnabled
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsMultipleUsersEnabled (void)

{
    return(_ShellIsMultipleUsersEnabled());
}

//  --------------------------------------------------------------------------
//  ::ShellIsRemoteConnectionsEnabled
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsRemoteConnectionsEnabled (void)

{
    return(_ShellIsRemoteConnectionsEnabled());
}

//  --------------------------------------------------------------------------
//  ::ShellEnableFriendlyUI
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellEnableFriendlyUI (BOOL fEnable)

{
    return(_ShellEnableFriendlyUI(fEnable));
}

//  --------------------------------------------------------------------------
//  ::ShellEnableMultipleUsers
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellEnableMultipleUsers (BOOL fEnable)

{
    return(_ShellEnableMultipleUsers(fEnable));
}

//  --------------------------------------------------------------------------
//  ::ShellEnableRemoteConnections
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellEnableRemoteConnections (BOOL fEnable)

{
    return(_ShellEnableRemoteConnections(fEnable));
}

//  --------------------------------------------------------------------------
//  ::ShellTurnOffDialog
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellTurnOffDialog (HWND hwndParent)

{
    return(_ShellTurnOffDialog(hwndParent));
}

//  --------------------------------------------------------------------------
//  ::ShellACPIPowerButtonPressed
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int     WINAPI  ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked)

{
    return(_ShellACPIPowerButtonPressed(pWlxContext, uiEventType, fLocked));
}

//  --------------------------------------------------------------------------
//  ::ShellIsSuspendAllowed
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellIsSuspendAllowed (void)

{
    return(_ShellIsSuspendAllowed());
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostBegin
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostBegin (UINT uiStartType)

{
    _ShellStatusHostBegin(uiStartType);
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostEnd
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostEnd (UINT uiEndType)

{
    _ShellStatusHostEnd(uiEndType);
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostShuttingDown
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostShuttingDown (void)

{
    _ShellStatusHostShuttingDown();
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostPowerEvent
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostPowerEvent (void)

{
    _ShellStatusHostPowerEvent();
}

//  --------------------------------------------------------------------------
//  ::ShellSwitchWhenInteractiveReady
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext)

{
    return(_ShellSwitchWhenInteractiveReady(eSwitchType, pWlxContext));
}

//  --------------------------------------------------------------------------
//  ::ShellDimScreen
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    HRESULT     WINAPI  ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed)

{
    return(_ShellDimScreen(ppIUnknown, phwndDimmed));
}

//  --------------------------------------------------------------------------
//  ::ShellInstallAccountFilterData
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellInstallAccountFilterData (void)

{
    _ShellInstallAccountFilterData();
}

//  --------------------------------------------------------------------------
//  ::ShellSwitchUser
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellSwitchUser (BOOL fWait)

{
    return(_ShellSwitchUser(fWait));
}

//  --------------------------------------------------------------------------
//  ::ShellIsUserInteractiveLogonAllowed
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    int     WINAPI  ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername)

{
    return(_ShellIsUserInteractiveLogonAllowed(pwszUsername));
}

//  --------------------------------------------------------------------------
//  ::ShellNotifyThemeUserChange
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken)

{
    _ShellNotifyThemeUserChange(eUserLogType, hToken);
}

//  --------------------------------------------------------------------------
//  ::ShellReturnToWelcome
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-01-11  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellReturnToWelcome (BOOL fUnlock)

{
    return(_ShellReturnToWelcome(fUnlock));
}

//  --------------------------------------------------------------------------
//  ::ShellStartCredentialServer
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-03  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    DWORD   WINAPI  ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout)

{
    return(_ShellStartCredentialServer(pwszUsername, pwszDomain, pwszPassword, dwTimeout));
}

//  --------------------------------------------------------------------------
//  ::ShellAcquireLogonMutex
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellAcquireLogonMutex (void)

{
    _ShellAcquireLogonMutex();
}

//  --------------------------------------------------------------------------
//  ::ShellReleaseLogonMutex
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellReleaseLogonMutex (BOOL fSignalEvent)

{
    _ShellReleaseLogonMutex(fSignalEvent);
}

//  --------------------------------------------------------------------------
//  ::ShellSignalShutdown
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellSignalShutdown (void)

{
    _ShellSignalShutdown();
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostHide
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-12  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostHide (void)

{
    _ShellStatusHostHide();
}

//  --------------------------------------------------------------------------
//  ::ShellStatusHostShow
//
//  Arguments:  See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Returns:    See %SDXROOT%\shell\ext\gina\exports.cpp
//
//  Purpose:    Stub function for export.
//
//  History:    2001-04-12  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    void    WINAPI  ShellStatusHostShow (void)

{
    _ShellStatusHostShow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\domain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       domcache.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-29-96   RichardW   Created
//
//----------------------------------------------------------------------------


#ifdef DATA_TYPES_ONLY

//
// Domain specific types
//

//
// Define the structure that controls the trusted domain cache
//

typedef enum _DOMAIN_ENTRY_TYPE {
    DomainInvalid,                      // 0 never valid
    DomainUPN,                          // Special UPN domain
    DomainMachine,                      // Local machine domain
    DomainNt4,                          // An NT4 domain
    DomainNt5,                          // An NT5 domain
    DomainMitRealm,                     // An MIT realm
    DomainMitUntrusted,                 // An untrusted MIT realm
    DomainNetworkProvider,              // A fake entry 
    DomainTypeMax
} DOMAIN_ENTRY_TYPE ;


typedef struct _DOMAIN_CACHE_ENTRY {

    LONG RefCount ;                         // Ref Count

    ULONG Flags ;                           // Flags (below)

    DOMAIN_ENTRY_TYPE Type ;                // Type of entry

    UNICODE_STRING FlatName ;               // Flat name of object (OPTIONAL)

    UNICODE_STRING DnsName ;                // Dns name of object (OPTIONAL)

    UNICODE_STRING DisplayName ;            // Display Name
    
} DOMAIN_CACHE_ENTRY, * PDOMAIN_CACHE_ENTRY ;

#define DCE_DEFAULT_ENTRY   0x00000001      // This is displayed by default
#define DCE_REACHABLE_MIT   0x00000002      // This MIT realm is reachable

#define DCacheReferenceEntry( x )   InterlockedIncrement( &(x)->RefCount );

typedef struct _DOMAIN_CACHE_ARRAY {

    ULONG Count ;

    ULONG MaxCount ;

    BOOL Sorted ;

    PDOMAIN_CACHE_ENTRY * List ;

} DOMAIN_CACHE_ARRAY, * PDOMAIN_CACHE_ARRAY ;


//
// Keep these in order.  They're used to determine UI behavior
//
typedef enum _DOMAIN_CACHE_STATE {
    DomainCacheEmpty,               // got nothing
    DomainCacheDefaultOnly,         // default values only (machine and primary domain)
    DomainCacheRegistryCache,       // default + cached values
    DomainCacheReady                // Fully up-to-date.
} DOMAIN_CACHE_STATE ;

typedef struct _DOMAIN_CACHE {

    //
    // Critical section that protects the data in this structure
    //

    CRITICAL_SECTION CriticalSection;

    //
    // Fields protected by that critical section:
    //

    //
    // Task that gets invoked if the domain changes.
    //

    HANDLE Task ;

    //
    // Window to be notified when the update thread completes
    //

    HWND UpdateNotifyWindow;
    UINT Message;

    //
    // last update time
    //

    LARGE_INTEGER   CacheUpdateTime;
    LARGE_INTEGER   RegistryUpdateTime ;

    HANDLE Key ;
    DOMAIN_CACHE_STATE State ;

    //
    // Default domain.  Used only when there is an async thread running
    // so it can set the appropriate default name.
    //

    PWSTR   DefaultDomain ;

    //
    // Flag indicating if we are in a MIT or Safemode state, which means
    // we shouldn't pester netlogon about trusted domains.
    //

    ULONG Flags ;

#define DCACHE_MIT_MODE     0x00000001  // In MIT mode
#define DCACHE_READ_ONLY    0x00000002  // Read-only copy of cache
#define DCACHE_ASYNC_UPDATE 0x00000004  // Async thread running
#define DCACHE_MEMBER       0x00000008  // This is a domain member
#define DCACHE_NO_CACHE     0x00000010  // No cache was found
#define DCACHE_DEF_UNKNOWN  0x00000020  // The default domain could not be found


    //
    // This pointer may *only* be accessed under the critical 
    // section.  This array will get swapped in and out, and
    // only references to it while it is locked are safe.
    //

    PDOMAIN_CACHE_ARRAY Array ;

} DOMAIN_CACHE, *PDOMAIN_CACHE;

#define DCACHE_UPDATE_CONFLICT      3
#define DCACHE_UPDATE_COMBOBOX      2
#define DCACHE_UPDATE_SUCCESSFUL    1
#define DCACHE_UPDATE_FAILURE       0




#else // DATA_TYPES_ONLY


#define WM_CACHE_UPDATE_COMPLETE    WM_USER+256

//
// Exported function prototypes
//

BOOL
DCacheInitialize(
    VOID
    );


VOID
DCacheDereferenceEntry(
    PDOMAIN_CACHE_ENTRY Entry
    );


PDOMAIN_CACHE_ENTRY
DCacheSearchArray(
    PDOMAIN_CACHE_ARRAY Array,
    PUNICODE_STRING DomainName
    );

PDOMAIN_CACHE
DCacheCreate(
    VOID 
    );

PDOMAIN_CACHE_ENTRY
DCacheCreateEntry(
    DOMAIN_ENTRY_TYPE Type,
    PUNICODE_STRING FlatName OPTIONAL,
    PUNICODE_STRING DnsName OPTIONAL,
    PUNICODE_STRING DisplayName OPTIONAL
    );

BOOL
DCacheUpdateMinimal(
    PDOMAIN_CACHE Cache,
    PWSTR DefaultDomain OPTIONAL,
    BOOL CompleteAsync
    );

BOOL
DCacheUpdateFull(
    PDOMAIN_CACHE Cache,
    PWSTR Default OPTIONAL
    );

void
DCacheUpdateFullAsync(
    PDOMAIN_CACHE Cache
    );

PDOMAIN_CACHE_ARRAY
DCacheCopyCacheArray(
    PDOMAIN_CACHE Cache
    );

VOID
DCacheFreeArray(
    PDOMAIN_CACHE_ARRAY Array
    );

BOOL
DCacheSetNotifyWindowIfNotReady(
    PDOMAIN_CACHE Cache,
    HWND Window,
    UINT Message
    );

BOOL
DCachePopulateListBoxFromArray(
    PDOMAIN_CACHE_ARRAY Array,
    HWND ComboBox,
    LPWSTR LastKey OPTIONAL
    );

BOOL
DCacheAddNetworkProviders(
    PDOMAIN_CACHE_ARRAY Array
    );

BOOL
DCacheValidateCache(
    PDOMAIN_CACHE Cache
    );

DOMAIN_CACHE_STATE
DCacheGetCacheState(
    PDOMAIN_CACHE Cache
    );

ULONG
DCacheGetFlags(
    PDOMAIN_CACHE Cache 
    );

BOOL
DCacheAddNetworkProviders(
    PDOMAIN_CACHE_ARRAY Array
    );

BOOL
DCacheSetDefaultEntry(
    PDOMAIN_CACHE Cache,
    PWSTR FlatName OPTIONAL,
    PWSTR DnsName OPTIONAL
    );

PDOMAIN_CACHE_ENTRY
DCacheLocateEntry(
    PDOMAIN_CACHE Cache,
    PWSTR Domain
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\langicon.h ===
/****************************** Module Header ******************************\
* Module Name: langicon.h
*
* Copyright (c) 1998, Microsoft Corporation
*
* Define apis in langicon.c
*
\***************************************************************************/

//
// Prototypes
//

typedef enum _LAYOUT_USER {
    LAYOUT_DEF_USER,
    LAYOUT_CUR_USER
} LAYOUT_USER;

#define TIMER_MYLANGUAGECHECK     1

BOOL
DisplayLanguageIcon(
    HWND hwnd,
    LAYOUT_USER LayoutUser,
    HKL  hkl);

void
FreeLayoutInfo(
    LAYOUT_USER LayoutUser);

void
LayoutCheckHandler(
    HWND hwnd,
    LAYOUT_USER LayoutUser);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\envvar.h ===
/****************************** Module Header ******************************\
* Module Name: envvar.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis in envvar.c
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

//
// Prototypes
//

BOOL
AppendNTPathWithAutoexecPath(
    PVOID *pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    );

BOOL
SetUserEnvironmentVariable(
    PVOID *pEnv,
    LPTSTR lpVariable,
    LPTSTR lpValue,
    BOOL bOverwrite
    );

DWORD
ExpandUserEnvironmentStrings(
    PVOID pEnv,
    LPTSTR lpSrc,
    LPTSTR lpDst,
    DWORD nSize
    );

BOOL
SetEnvironmentVariables(
    PGLOBALS pGlobals,
    LPTSTR pEnvVarSubkey,
    PVOID *pEnv
    );

BOOL
SetHomeDirectoryEnvVars(
    PVOID *pEnv,
    LPTSTR lpHomeDirectory,
    LPTSTR lpHomeDrive,
    LPTSTR lpHomeShare,
    LPTSTR lpHomePath,
    BOOL * pfDeepShare
    );

BOOL
ProcessAutoexec(
    PVOID *pEnv,
    LPTSTR lpPathVariable
    );

VOID
ChangeToHomeDirectory(
    PGLOBALS pGlobals,
    PVOID  *pEnv,
    LPTSTR lpHomeDir,
    LPTSTR lpHomeDrive,
    LPTSTR lpHomeShare,
    LPTSTR lpHomePath,
    LPWSTR pszOldPath,
    BOOL   DeepShare
    );

BOOL
OpenHKeyCurrentUser(
    PGLOBALS pGlobals
    );

VOID
CloseHKeyCurrentUser(
    PGLOBALS pGlobals
    );

BOOL
InitHKeyCurrentUserSupport(
    );

VOID
CleanupHKeyCurrentUserSupport(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\domain.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       domcache.c
//
//  Contents:   Restructuring the Domain Cache to get away from direct LSA
//              calls whenever possible.
//
//  Classes:
//
//  Functions:
//
//  History:    3-29-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <msgina.h>
#include <stdio.h>

#define LockDomainCache( x )    RtlEnterCriticalSection( &(x)->CriticalSection )
#define UnlockDomainCache( x )  RtlLeaveCriticalSection( &(x)->CriticalSection )

#define TWO_MINUTES ((LONGLONG) 0x47868C00)
#define TWO_WEEKS   ((LONGLONG) 0xB0051C88000I64)

WCHAR szCache[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\DomainCache");
WCHAR szCacheValue[] = TEXT("DCache");
WCHAR szCacheUpdate[] = TEXT("DCacheUpdate");
WCHAR szCacheInterval[] = TEXT("DCacheMinInterval");
WCHAR szCachePrimary[] = TEXT("CachePrimaryDomain");

LONGLONG CacheUpdateMin;
LONGLONG CacheUpdateMax;

BOOL CacheAppendDomainInfo = FALSE ;
BOOL CacheShowDnsNames = FALSE ;

#define DOMAIN_MOD_ALWAYS   0x00000001

typedef struct _DOMAIN_MODIFIER {
    ULONG StringId ;
    ULONG Flags ;
    UNICODE_STRING String ;
} DOMAIN_MODIFIER ;


DOMAIN_MODIFIER CacheDomainModifiers[ DomainTypeMax ] = {
    { 0 },                                              // Invalid
    { IDS_DTYPE_UPNDOMAIN, 0 },                         // UPN Domain
    { IDS_DTYPE_THISCOMPUTER, DOMAIN_MOD_ALWAYS },      // This computer
    { IDS_DTYPE_NT4DOMAIN, 0 },                         // NT4 domains
    { IDS_DTYPE_NT5DOMAIN, 0 },                         // NT5 domains
    { IDS_DTYPE_MITDOMAIN, DOMAIN_MOD_ALWAYS },         // MIT domains
    { IDS_DTYPE_MITXDOMAIN, DOMAIN_MOD_ALWAYS },        // Untrusted MIT domains
    { IDS_DTYPE_NETPROVIDER, DOMAIN_MOD_ALWAYS }        // Network provider
};


DWORD
DCacheUpdateThread(
    PDOMAIN_CACHE Cache
    );


VOID
DCacheDereferenceEntry(
    PDOMAIN_CACHE_ENTRY Entry
    )
{
    if ( InterlockedDecrement( &Entry->RefCount ) == 0 )
    {
        LocalFree( Entry );
    }
}


PDOMAIN_CACHE_ARRAY
DCacheCreateArray(
    ULONG Size,
    BOOL Sorted
    )
{
    PDOMAIN_CACHE_ARRAY Array ;

    Array = LocalAlloc( LMEM_FIXED, sizeof( DOMAIN_CACHE_ARRAY ) );

    if ( Array )
    {
        Array->List = LocalAlloc( LMEM_FIXED, sizeof( PDOMAIN_CACHE_ENTRY ) * Size );

        if ( Array->List )
        {

            Array->Count = 0 ;
            Array->MaxCount = Size ;
            Array->Sorted = Sorted ;

            return Array ;
        }

        LocalFree( Array );
    }

    return NULL ;
}

BOOL
DCachepExpandArray(
    PDOMAIN_CACHE_ARRAY Array,
    ULONG Size
    )
{
    PDOMAIN_CACHE_ENTRY * NewArray ;

    NewArray = LocalReAlloc( Array->List,
                             (Array->Count + Size) * sizeof( PDOMAIN_CACHE_ENTRY ),
                             0 );

    if ( NewArray )
    {
        Array->List = NewArray ;

        Array->MaxCount = Array->Count + Size ;

        return TRUE ;
    }

    return FALSE ;

}


BOOL
DCacheInsertArray(
    PDOMAIN_CACHE_ARRAY Array,
    PDOMAIN_CACHE_ENTRY Entry
    )
{
    ULONG i ;
    LONG Compare ;
    PDOMAIN_CACHE_ENTRY Scan ;

    if ( Array->Count == Array->MaxCount )
    {
        if ( !DCachepExpandArray( Array, 10 ) )
        {
            return FALSE ;
        }
    }

    DCacheReferenceEntry( Entry );


    if ( ( Array->Sorted == FALSE ) ||
         ( Array->Count == 0 ) )
    {
        Array->List[ Array->Count ] = Entry ;

        Array->Count++ ;

        return TRUE ;

    }
    else 
    {
        Scan = Array->List[ Array->Count - 1 ];

        Compare = RtlCompareUnicodeString( &Entry->FlatName,
                                           &Scan->FlatName,
                                           TRUE );

        //
        // Efficient check for sorted input:
        //

        if ( Compare > 0 )
        {
            Array->List[ Array->Count ] = Entry ;

            Array->Count ++ ;

            return TRUE ;

        }

        //
        // this is not a terribly efficient sort.
        // However, we're expecting
        // on the order of <100 objects in the array, so it
        // shouldn't be too bad.
        //

        for ( i = 0 ; i < Array->Count ; i++ )
        {
            Scan = Array->List[ i ];

            Compare = RtlCompareUnicodeString( & Entry->FlatName,
                                               & Scan->FlatName,
                                               TRUE );

            if ( Compare == 0 )
            {
                DCacheDereferenceEntry( Entry );

                return FALSE ;
            }

            if ( Compare < 0 )
            {
                break;
            }
            
        }

        RtlMoveMemory(
            &Array->List[ i + 1 ],
            &Array->List[ i ],
            (Array->Count - i) * sizeof( PVOID ) );

        Array->List[ i ] = Entry ;

        Array->Count++ ;

        return TRUE ;

    }

}

PDOMAIN_CACHE_ENTRY
DCacheSearchArray(
    PDOMAIN_CACHE_ARRAY Array,
    PUNICODE_STRING DomainName
    )
{
    ULONG i ;
    PDOMAIN_CACHE_ENTRY Scan = NULL ;
    LONG Compare ;


    for (i = 0 ; i < Array->Count ; i++ )
    {
        Scan = Array->List[ i ];

        if ( Scan->FlatName.Length == 0 )
        {
            Scan = NULL ;

            continue;
        }

        Compare = RtlCompareUnicodeString( &Scan->FlatName,
                                           DomainName,
                                           TRUE );

        if ( Compare == 0 )
        {
            break;
        }

        if ( ( Compare > 0 ) && 
             ( Array->Sorted ) )
        {
            Scan = NULL ;

            break;
        }
    }

    return Scan ;

}

PDOMAIN_CACHE_ENTRY
DCacheSearchArrayByDns(
    PDOMAIN_CACHE_ARRAY Array,
    PUNICODE_STRING DnsDomainName
    )
{
    ULONG i ;
    PDOMAIN_CACHE_ENTRY Scan = NULL ;


    for (i = 0 ; i < Array->Count ; i++ )
    {
        Scan = Array->List[ i ];

        if ( Scan->DnsName.Length )
        {
            if ( RtlEqualUnicodeString( &Scan->DnsName,
                                        DnsDomainName,
                                        TRUE ) )
            {
                break;
            }
        }

        Scan = NULL ;

    }

    return Scan ;

}

PDOMAIN_CACHE_ENTRY
DCacheFindDefaultEntry(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    ULONG i ;
    PDOMAIN_CACHE_ENTRY Scan = NULL ;


    for (i = 0 ; i < Array->Count ; i++ )
    {
        Scan = Array->List[ i ];

        if ( Scan->Flags & DCE_DEFAULT_ENTRY )
        {
            break;
        }

        Scan = NULL ;
    }

    return Scan ;

}

VOID
DCacheFreeArray(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    ULONG i ;

    for ( i = 0 ; i < Array->Count ; i++ )
    {
        DCacheDereferenceEntry( Array->List[ i ] );
    }

    LocalFree( Array->List );

    LocalFree( Array );

}

PDOMAIN_CACHE_ARRAY
DCacheCopyArray(
    PDOMAIN_CACHE_ARRAY Source
    )
{
    PDOMAIN_CACHE_ARRAY Array ;
    ULONG i ;

    Array = DCacheCreateArray( Source->MaxCount,
                               Source->Sorted );

    if ( Array )
    {
        for (i = 0 ; i < Source->Count ; i++ )
        {
            Array->List[ i ] = Source->List[ i ];

            DCacheReferenceEntry( Array->List[ i ] );
        }

        Array->Count = Source->Count ;
    }

    return Array ;
}



PDOMAIN_CACHE_ENTRY
DCacheCreateEntry(
    DOMAIN_ENTRY_TYPE Type,
    PUNICODE_STRING FlatName OPTIONAL,
    PUNICODE_STRING DnsName OPTIONAL,
    PUNICODE_STRING DisplayName OPTIONAL
    )
{
    ULONG Size ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PUNICODE_STRING DisplayBase = NULL ;
    PUNICODE_STRING Modifier = NULL ;
    PUCHAR Current ;

    //
    // Validation rules:
    //
    // Display Name is optional if either of FlatName or
    // DNS name is present.  If both are present, FlatName
    // is defaulted over Dns name
    //

    Size = sizeof( DOMAIN_CACHE_ENTRY );

    if ( FlatName )
    {
        Size += FlatName->Length + sizeof( WCHAR );
    }

    if ( DnsName )
    {
        Size += DnsName->Length + sizeof( WCHAR );
    }

    if ( DisplayName )
    {
        Size += DisplayName->Length + sizeof( WCHAR );

        DisplayBase = DisplayName ;
    }
    else 
    {
        if ( CacheShowDnsNames ||
             ( ( Type == DomainMitRealm ) ||
               ( Type == DomainMitUntrusted ) ) )
        {
            if ( DnsName )
            {
                DisplayBase = DnsName ;
            }
            else if ( FlatName )
            {
                DisplayBase = FlatName ;
            }
            else 
            {
                return NULL ;
            }
        }
        else 
        {
            if ( FlatName )
            {
                DisplayBase = FlatName ;
            }
            else if ( DnsName )
            {
                DisplayBase = DnsName ;
            }
            else 
            {
                return NULL ;
            }

        }

        Size += DisplayBase->Length + sizeof( WCHAR );

        if ( ( CacheAppendDomainInfo ) ||
             ( CacheDomainModifiers[ Type ].Flags & DOMAIN_MOD_ALWAYS ) )
        {
            Modifier = &CacheDomainModifiers[ Type ].String ;

            if ( Modifier->Length )
            {
                Size += CacheDomainModifiers[ Type ].String.Length;
            }
            else 
            {
                Modifier = NULL ;
            }
        }

    }

    Entry = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size );

    if ( !Entry )
    {
        return NULL ;
    }

    Entry->RefCount = 1 ;
    Entry->Flags = 0 ;
    Entry->Type = Type ;

    Current = (PUCHAR) ( Entry + 1 );

    //
    // Copy and pack the strings:
    //

    if ( FlatName )
    {
        Entry->FlatName.Buffer = (PWSTR) Current ;
        Entry->FlatName.Length = FlatName->Length ;
        Entry->FlatName.MaximumLength = FlatName->Length + sizeof( WCHAR );

        RtlCopyMemory(
            Current,
            FlatName->Buffer,
            FlatName->Length );

        Current += FlatName->Length ;

        *Current++ = '\0';
        *Current++ = '\0';

    }

    if ( DnsName )
    {
        Entry->DnsName.Buffer = (PWSTR) Current ;
        Entry->DnsName.Length = DnsName->Length ;
        Entry->DnsName.MaximumLength = DnsName->Length + sizeof( WCHAR );

        RtlCopyMemory(
            Current,
            DnsName->Buffer,
            DnsName->Length );

        Current += DnsName->Length ;

        *Current++ = '\0';
        *Current++ = '\0';
    }

    ASSERT( DisplayBase );

    Entry->DisplayName.Buffer = (PWSTR) Current ;
    Entry->DisplayName.Length = DisplayBase->Length ;
    if ( Modifier )
    {
        Entry->DisplayName.Length = Entry->DisplayName.Length + Modifier->Length ;
    }

    Entry->DisplayName.MaximumLength = Entry->DisplayName.Length + sizeof( WCHAR );

    RtlCopyMemory(
        Current,
        DisplayBase->Buffer,
        DisplayBase->Length );

    Current += DisplayBase->Length ;

    if ( Modifier )
    {
        RtlCopyMemory(
            Current,
            Modifier->Buffer,
            Modifier->Length );

        Current += Modifier->Length ;
    }

    *Current++ = '\0';
    *Current++ = '\0';

    return Entry ;

}

LONG 
DCacheGetTrustedDomains(
    PDOMAIN_CACHE_ARRAY * pArray
    )
{
    LONG NetStatus ;
    PDOMAIN_CACHE_ARRAY Array ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDS_DOMAIN_TRUSTS Trusts ;
    ULONG TrustCount ;
    ULONG i ;
    UNICODE_STRING Flat ;
    UNICODE_STRING Dns ;
    DOMAIN_ENTRY_TYPE Type ;

    *pArray = NULL ;

    NetStatus = DsEnumerateDomainTrusts(
                    NULL,
                    DS_DOMAIN_IN_FOREST |
                        DS_DOMAIN_DIRECT_OUTBOUND,
                    &Trusts,
                    &TrustCount );

    if ( NetStatus != NERR_Success )
    {
        return NetStatus ;
    }

    Array = DCacheCreateArray( TrustCount + 5,
                               TRUE );

    if ( !Array )
    {
        NetApiBufferFree( Trusts );

        return ERROR_NOT_ENOUGH_MEMORY ;
    }

    for ( i = 0 ; i < TrustCount ; i++ )
    {

        if ( Trusts[ i ].NetbiosDomainName )
        {
            RtlInitUnicodeString( &Flat, Trusts[ i ].NetbiosDomainName );
        }
        else 
        {
            ZeroMemory( &Flat, sizeof( Flat ) );
        }

        if ( Trusts[ i ].DnsDomainName )
        {
            RtlInitUnicodeString( &Dns, Trusts[ i ].DnsDomainName );
        }
        else 
        {
            ZeroMemory( &Dns, sizeof( Dns ) );
        }

        switch ( Trusts[ i ].TrustType )
        {
            case TRUST_TYPE_DOWNLEVEL :
                Type = DomainNt4 ;
                break;

            case TRUST_TYPE_UPLEVEL:
                Type = DomainNt5 ;
                break;

            case TRUST_TYPE_MIT:
                Type = DomainMitRealm ;
                break;

            default:
                continue;
        }


        DebugLog(( DEB_TRACE_CACHE, "Processing domain (%d) %ws\n",
                   Type,
                   Trusts[ i ].NetbiosDomainName ));

        Entry = DCacheCreateEntry(
                    Type,
                    ( Flat.Buffer ? &Flat : NULL ),
                    ( Dns.Buffer ? &Dns : NULL ),
                    NULL );

        if ( Entry )
        {
            DCacheInsertArray( 
                Array, 
                Entry );

            DCacheDereferenceEntry( Entry );
        }

    }

    NetApiBufferFree( Trusts );

    *pArray = Array ;

    return 0 ;

}

BOOL
DCacheAddMitRealms(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    HKEY MitKey ;
    DWORD Index ;
    PWSTR Realms;
    DWORD RealmSize;
    int err ;
    DWORD NumRealms;
    DWORD MaxRealmLength ;
    FILETIME KeyTime ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDOMAIN_CACHE_ENTRY TrustedDomain ;
    UNICODE_STRING DnsName ;

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains"),
                0,
                KEY_READ,
                &MitKey );

    if ( err == 0 )
    {
        err = RegQueryInfoKey( MitKey,
                               NULL,
                               NULL,
                               NULL,
                               &NumRealms,
                               &MaxRealmLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        MaxRealmLength++ ;

        Realms = LocalAlloc( LMEM_FIXED, MaxRealmLength * sizeof( WCHAR ));


        if ( Realms)
        {

            for ( Index = 0 ; Index < NumRealms ; Index++ )
            {
                RealmSize = MaxRealmLength ;

                err = RegEnumKeyEx( MitKey,
                                  Index,
                                  Realms,
                                  &RealmSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &KeyTime );


                if ( err == 0 )
                {
                    DebugLog(( DEB_TRACE_CACHE, "Found realm %ws\n", Realms ));

                    RtlInitUnicodeString( &DnsName, Realms );

                    Entry = DCacheCreateEntry( 
                                DomainMitUntrusted,
                                &DnsName,
                                &DnsName,
                                NULL );

                    if ( Entry )
                    {
                        Entry->Flags |= DCE_REACHABLE_MIT ;

                        if ( !DCacheInsertArray( Array, Entry ) )
                        {
                            //
                            // If the insert failed, then there's already an entry
                            // in the list for this domain.  Locate it, and tag it
                            // so that it will be displayed
                            //

                            TrustedDomain = DCacheSearchArray( Array, &DnsName );

                            if ( TrustedDomain )
                            {
                                TrustedDomain->Flags |= DCE_REACHABLE_MIT ;
                            }

                        }

                        DCacheDereferenceEntry( Entry );
                    }
                    
                }

            }

            LocalFree( Realms );

        }

        RegCloseKey( MitKey );
    }

    return TRUE ;

}

BOOL
DCacheAddNetworkProviders(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    WCHAR   szProviderName[128];
    WCHAR   szKeyPath[MAX_PATH];
    PWSTR   pszProviders;
    PWSTR   pszScan;
    PWSTR   pszStart;
    WCHAR   Save;
    HKEY    hKey;
    DWORD   dwType;
    DWORD   dwLen;
    DWORD   Class;
    int     err;
    PDOMAIN_CACHE_ENTRY Entry ;
    UNICODE_STRING String ;


    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\NetworkProvider\\Order"),
                      0,
                      KEY_READ,
                      &hKey );

    if ( err )
    {
        return FALSE ;
    }

    err = RegQueryValueEx(  hKey,
                            TEXT("ProviderOrder"),
                            NULL,
                            &dwType,
                            NULL,
                            &dwLen );

    if ( (err) || (dwType != REG_SZ) )
    {
        RegCloseKey( hKey );
        return FALSE ;
    }

    pszProviders = LocalAlloc( LMEM_FIXED, dwLen );

    if ( !pszProviders )
    {
        RegCloseKey( hKey );
        return FALSE ;
    }

    err = RegQueryValueEx(  hKey,
                            TEXT("ProviderOrder"),
                            NULL,
                            &dwType,
                            (PUCHAR) pszProviders,
                            &dwLen );

    RegCloseKey( hKey );

    if ( err )
    {
        LocalFree( pszProviders );
        return FALSE ;
    }

    //
    // Initialize things.
    //

    pszStart = pszProviders;


    szProviderName[0] = TEXT('<');
    szProviderName[1] = TEXT(' ');


    while ( *pszStart )
    {
        pszScan = pszStart;
        while ( (*pszScan) && (*pszScan != TEXT(',') ) )
        {
            pszScan++;
        }

        Save = *pszScan;

        *pszScan = TEXT('\0');

        wsprintf( szKeyPath,
                TEXT("System\\CurrentControlSet\\Services\\%s\\networkprovider"),
                pszStart );

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szKeyPath,
                          0,
                          KEY_READ,
                          &hKey );

        if ( err == 0 )
        {

            dwLen = sizeof(DWORD) ;

            err = RegQueryValueEx( hKey,
                                   TEXT("Class"),
                                   NULL,
                                   &dwType,
                                   (PUCHAR) &Class,
                                   &dwLen );

            if ( (err == 0) && (dwType == REG_DWORD) )
            {
                if ( Class & WN_CREDENTIAL_CLASS )
                {
                    
                    dwLen = 126 * sizeof(WCHAR);

                    err = RegQueryValueEx(  hKey,
                                            TEXT("Name"),
                                            NULL,
                                            &dwType,
                                            (PUCHAR) &szProviderName[2],
                                            &dwLen );

                    wcscpy( &szProviderName[ (dwLen / sizeof(WCHAR) ) + 2 ],
                            TEXT(" >") );

                    RtlInitUnicodeString( &String, szProviderName );

                    Entry = DCacheCreateEntry(
                                DomainNetworkProvider,
                                &String,
                                NULL,
                                NULL );

                    if ( Entry )
                    {
                        DCacheInsertArray( Array, Entry );

                        DCacheDereferenceEntry( Entry );
                    }

                }
            }

            RegCloseKey( hKey );

        }

        *pszScan = Save;
        if ( *pszScan )
        {
            pszStart = pszScan + 1;
        }
        else
        {
            pszStart = NULL;
            break;
        }

    }

    LocalFree( pszProviders );

    return TRUE ;

}

BOOL
DCacheGetDomainsFromCache(
    PDOMAIN_CACHE_ARRAY *pArray,
    PLARGE_INTEGER RegistryTime
    )
{
    HKEY Key ;
    int err ;
    DWORD NumDomains ;
    DWORD i ;
    WCHAR FlatName[ DNLEN + 2 ];
    WCHAR DnsDomain[ MAX_PATH ];
    DWORD dwType ;
    DWORD FlatNameSize ;
    DWORD DnsDomainSize ;
    UNICODE_STRING Flat ;
    UNICODE_STRING Dns ;
    PDOMAIN_CACHE_ENTRY Entry ;
    PDOMAIN_CACHE_ARRAY Array = NULL;
    DWORD dwSize ;
    PWSTR DomainBuffer ;
    PWSTR DomainBufferEnd ;
    PWSTR Scan ;
    ULONG Disp ;
    BOOL ReturnFalseAnyway = FALSE ;

    if ( SafeBootMode == SAFEBOOT_MINIMAL )
    {
        RegistryTime->QuadPart = 0 ;
        return FALSE ;
    }

        //
        // The following appears to be a transfer of
        // HKLM\Microsoft\Windows NT\CurrentVersion\Winlogon\DCache
        // in the form of a multistring to the current DomainCache format
        // Legacy migration?
        // In any case, let's not worry if any of this fails.
        // 
    dwSize = 0 ;
    err = RegQueryValueEx(
                WinlogonKey,
                szCacheValue,
                NULL,
                &dwType,
                NULL,
                &dwSize );

    if ( ( err == ERROR_MORE_DATA ) ||
         ( err == ERROR_BUFFER_OVERFLOW ) ||
         ( err == 0 ) )
    {
        //
        // 

        DomainBuffer = LocalAlloc( LMEM_FIXED, dwSize );

        if ( DomainBuffer )
        {
            err = RegQueryValueEx(
                        WinlogonKey,
                        szCacheValue,
                        NULL,
                        &dwType,
                        (PUCHAR) DomainBuffer, 
                        &dwSize );

            if ( err == 0 )
            {
                DomainBufferEnd = (PWSTR)((PUCHAR) DomainBuffer + dwSize);

                Scan = DomainBuffer ;

                err = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,
                            szCache,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &Key,
                            &Disp );

                if ( err == 0 )
                {
                    while ( Scan != DomainBufferEnd )
                    {
                        err = RegSetValueEx(
                                    Key,
                                    Scan,
                                    0,
                                    REG_SZ,
                                    (PUCHAR) TEXT(""),
                                    sizeof( WCHAR ) );

                        Scan += wcslen(Scan) ;

                        while ( (*Scan == L'\0' ) &&
                                (Scan != DomainBufferEnd ) )
                        {
                            Scan++ ;
                        }

                    }

                    RegCloseKey( Key );
                }

            }

            LocalFree( DomainBuffer );
        }

        RegDeleteValue( WinlogonKey, szCacheValue );

        ReturnFalseAnyway = TRUE ;
    }
        // End of Legacy migration


        // Since the DomainCache is "managed" by all sessions w/o protection,
        // we need to implement a little bit of retry logic here
        //
    Key = NULL;
    dwSize = 10;     // Number of retries
    do
    {
        if (dwSize < 10)
        {
            Sleep(100);     // Let the other session finish its work
        }

        err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szCache,
                    0,
                    KEY_READ,
                    &Key );

        if ( err == ERROR_SUCCESS)
        {
                // Query the number of values in the DomainCache
            err = RegQueryInfoKey( Key,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &NumDomains,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL );

            if (err == ERROR_SUCCESS)
            {
                if (Array)  // Initialized during a previous attempt
                {
                    DCacheFreeArray(Array);
                }
                Array = DCacheCreateArray( NumDomains + 5, TRUE );

                if ( Array )
                {
                    for ( i = 0 ; i < NumDomains ; i++ )
                    {
                        FlatNameSize = DNLEN + 2 ;
                        DnsDomainSize = MAX_PATH ;

                        err = RegEnumValue(
                                    Key,
                                    i,
                                    FlatName,
                                    &FlatNameSize,
                                    NULL,
                                    &dwType,
                                    (PUCHAR) DnsDomain,
                                    &DnsDomainSize );

                        if ( err == 0 )
                        {
                            RtlInitUnicodeString( &Flat, FlatName );

                            RtlInitUnicodeString( &Dns, DnsDomain );

                            Entry = DCacheCreateEntry(
                                        ( Dns.Length ? DomainNt5 : DomainNt4),
                                        &Flat,
                                        ( Dns.Length ? &Dns : NULL ),
                                        NULL );

                            if ( Entry )
                            {
                                DCacheInsertArray( Array, Entry );

                                DCacheDereferenceEntry( Entry );
                            }
                            else
                            {
                                err = ERROR_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            break;    
                        }
                    }

                    if ((i < NumDomains) && (err == ERROR_NO_MORE_ITEMS))
                    {
                            // Hit the end of enumeration although we
                            // knew how many values we had?
                            // The key was probably deleted in another
                            // session. Retry.
                        err = ERROR_FILE_NOT_FOUND;
                    }
                }
                else
                {
                    err = ERROR_OUTOFMEMORY;
                }
            }
            RegCloseKey( Key );
        }
    } while (((err == ERROR_FILE_NOT_FOUND) || (err == ERROR_KEY_DELETED)) && (--dwSize));

    //
    // Note that we may not have succeeded in the end
    // We will return success anyway, with no array or a partial array.
    // The callers seem to handle that.
    //

    if ( RegistryTime )
    {
        dwSize = sizeof( LARGE_INTEGER ) ;

        if ( RegQueryValueEx( WinlogonKey,
                              szCacheUpdate,
                              0,
                              &dwType,
                              (PUCHAR) RegistryTime,
                              &dwSize ) ||
             (dwType != REG_BINARY ) ||
             (dwSize != sizeof( LARGE_INTEGER ) ) )
        {
            RegistryTime->QuadPart = 0 ;
        }

    }


    *pArray = Array ;

    if ( ReturnFalseAnyway )
    {
        return FALSE ;
    }
    else 
    {
        return TRUE ;
    }
}


PDOMAIN_CACHE_ENTRY
DCacheEntryFromRegistry(
    PUNICODE_STRING FlatName
    )
{
    PDOMAIN_CACHE_ENTRY Entry = NULL ;
    HKEY Key ;
    int err ;
    DWORD dwType ;
    WCHAR DnsName[ MAX_PATH ];
    DWORD dwSize ;
    UNICODE_STRING Dns ;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        szCache,
                        0,
                        KEY_READ,
                        &Key );

    if ( err == 0 )
    {
        dwSize = MAX_PATH ;
        DnsName[ 0 ] = L'\0';

        err = RegQueryValueEx(
                    Key,
                    FlatName->Buffer,
                    NULL,
                    &dwType,
                    (PUCHAR) DnsName,
                    &dwSize );

        if ( err == 0 )
        {
            if ( dwType == REG_SZ )
            {
                RtlInitUnicodeString( &Dns, DnsName );

                Entry = DCacheCreateEntry(
                            ( Dns.Length ? DomainNt5 : DomainNt4 ),
                            FlatName,
                            ( Dns.Length ? &Dns : NULL ),
                            NULL );

            }
        }

        RegCloseKey( Key );

    }

    return Entry ;
}

VOID
DCacheWriteDomainsToCache(
    PDOMAIN_CACHE_ARRAY Array
    )
{
    HKEY Key ;
    ULONG i ;
    ULONG Disp ;
    int err ;
    PDOMAIN_CACHE_ENTRY Entry ;
    LARGE_INTEGER Now ;


    //
    // Delete what's there.  Ignore the error, since we are
    // just going to rewrite all the values, anyway.
    //

    err = RegDeleteKey( HKEY_LOCAL_MACHINE,
                        szCache );


    err = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                szCache,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &Key,
                &Disp );

    if ( err )
    {
        return ;
    }

    for ( i = 0 ; i < Array->Count ; i++ )
    {
        Entry = Array->List[ i ];

        if ( ( Entry->Type == DomainNt5 ) )
        {
            if ( ( Entry->FlatName.Buffer == NULL ) ||
                 ( Entry->DnsName.Buffer == NULL ) )
            {
                DebugLog(( DEB_ERROR, "Corrupt uplevel domain cache entry at %p\n", Entry ));
                continue;
            }
            RegSetValueEx(
                Key,
                Entry->FlatName.Buffer,
                0,
                REG_SZ,
                (PUCHAR) Entry->DnsName.Buffer,
                Entry->DnsName.Length + sizeof(WCHAR) );
        }
        else if ( Entry->Type == DomainNt4 )
        {
            if ( Entry->FlatName.Buffer == NULL )
            {
                DebugLog(( DEB_ERROR, "Corrupt downlevel domain cache entry at %p\n", Entry ));
            }

            RegSetValueEx(
                Key,
                Entry->FlatName.Buffer,
                0,
                REG_SZ,
                (PUCHAR) TEXT(""),
                sizeof(WCHAR) );
        }
        else 
        {
            //
            // Other types don't get to live in the cache
            //

            NOTHING ;
        }

    }

    RegCloseKey( Key );

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    RegSetValueEx(
        WinlogonKey,
        szCacheUpdate,
        0,
        REG_BINARY,
        (PUCHAR) &Now,
        sizeof( LARGE_INTEGER ) );


}



BOOL
DCacheInitialize(
    VOID
    )
{
    DOMAIN_ENTRY_TYPE Types ;
    WCHAR StringBuffer[ MAX_PATH ];
    LONG Size ;
    int err ;
    DWORD dwSize ;
    DWORD dwType ;

    for (Types = 0 ; Types < DomainTypeMax ; Types++ )
    {
        if ( CacheDomainModifiers[ Types ].StringId )
        {
            Size = LoadString( hDllInstance,
                               CacheDomainModifiers[ Types ].StringId,
                               StringBuffer,
                               MAX_PATH );

            if ( Size )
            {
                RtlCreateUnicodeString( &CacheDomainModifiers[ Types ].String,
                                        StringBuffer );
            }
        }
    }

    dwSize = sizeof( CacheShowDnsNames );

    err = RegQueryValueEx(
                WinlogonKey,
                DCACHE_SHOW_DNS_NAMES,
                NULL,
                &dwType,
                (PUCHAR) &CacheShowDnsNames,
                &dwSize );

    dwSize = sizeof( CacheAppendDomainInfo );
    err = RegQueryValueEx(
                WinlogonKey,
                DCACHE_SHOW_DOMAIN_TAGS,
                NULL,
                &dwType,
                (PUCHAR) &CacheAppendDomainInfo,
                &dwSize );

    //
    // Convert and delete old cache:
    //


    return TRUE ;
}

BOOL
DCachepInitializeCache(
    PDOMAIN_CACHE pCache 
    )
{
    NTSTATUS Status ;

    ZeroMemory( pCache, sizeof(DOMAIN_CACHE) );

    Status = RtlInitializeCriticalSectionAndSpinCount( 
                        & pCache->CriticalSection, 
                        0x80000000 );

    return NT_SUCCESS( Status );
}



PDOMAIN_CACHE
DCacheCreate(
    VOID
    )
{
    PDOMAIN_CACHE Cache ;

    Cache = (PDOMAIN_CACHE) LocalAlloc( LMEM_FIXED, sizeof( DOMAIN_CACHE ) );

    if ( !Cache )
    {
        return NULL ;
    }

    if ( !DCachepInitializeCache( Cache ) )
    {
        LocalFree( Cache );

        return NULL ;

    }

    Cache->State = DomainCacheEmpty ;

    if ( !g_Console )
    {
        Cache->Flags |= DCACHE_READ_ONLY ;
    }

    if ( SafeBootMode == SAFEBOOT_MINIMAL ) 
    {
        Cache->Flags |= DCACHE_MIT_MODE ;
    }

    return Cache ;
}

BOOL
DCacheGetMinimalArray(
    PDOMAIN_CACHE_ARRAY Array,
    PWSTR DefaultDomain OPTIONAL,
    PBOOL DomainMember OPTIONAL,
    PBOOL NewDomain OPTIONAL
    )
{
    BOOL SidPresent = FALSE ;
    UNICODE_STRING String = { 0 } ;
    UNICODE_STRING DnsDomain = { 0 } ;
    PDOMAIN_CACHE_ENTRY Entry = NULL ;
    PDOMAIN_CACHE_ENTRY ComputerEntry = NULL ;
    PDOMAIN_CACHE_ENTRY OldDefault = NULL ;
    NT_PRODUCT_TYPE ProductType = NtProductWinNt;
    WCHAR ComputerName[ CNLEN + 1 ];
    ULONG Size ;
    ULONG Type ;
    WCHAR LastPrimary[ DNLEN + 1 ];
    UNICODE_STRING LastPrimary_U ;

    //
    // First, find out what we are
    //

    RtlGetNtProductType( &ProductType );

    if ( Array == NULL )
    {
        Array = DCacheCreateArray( 5, TRUE );
    }

    if ( Array == NULL )
    {
        return FALSE ;
    }

    if ( SafeBootMode != SAFEBOOT_MINIMAL )
    {
        if ( GetPrimaryDomainEx( &String, &DnsDomain, NULL, &SidPresent ) )
        {
            //
            // Ok, we are configured to be part of a domain.
            //

            if ( SidPresent )
            {

                //
                // Ok, this is an NT domain.
                //

                Entry = DCacheCreateEntry(
                            ( DnsDomain.Buffer ? DomainNt5 : DomainNt4 ),
                            &String,
                            ( DnsDomain.Buffer ? &DnsDomain : NULL),
                            NULL );


                if ( Entry )
                {
                    if ( ProductType == NtProductLanManNt )
                    {
                        //
                        // We're a DC.  Until we know otherwise, tag this as the default
                        //

                        Entry->Flags |= DCE_DEFAULT_ENTRY ;
                    }

                    DCacheInsertArray( Array, Entry );

                    DCacheDereferenceEntry( Entry );

                    Entry = NULL ;
                }

                //
                // Check to see if we've changed domains:
                //

                if ( NewDomain )
                {
                    Size = sizeof( LastPrimary );

                    if ( RegQueryValueEx(
                            WinlogonKey,
                            szCachePrimary,
                            0,
                            &Type,
                            (PUCHAR) LastPrimary,
                            &Size ) == 0 )
                    {
                        RtlInitUnicodeString( &LastPrimary_U, LastPrimary );

                        *NewDomain = !RtlEqualUnicodeString( &LastPrimary_U,
                                                            &String,
                                                            TRUE );
                    }
                    else
                    {
                        //
                        // If the value can't be read for any reason, assume that it's
                        // missing and we're in a different domain than last time.
                        //

                        *NewDomain = TRUE ;
                    }
                }


                RegSetValueEx( 
                    WinlogonKey,
                    szCachePrimary,
                    0,
                    REG_SZ,
                    (PUCHAR) String.Buffer,
                    String.Length + sizeof(WCHAR));
            }
            else 
            {
                //
                // Part of an MIT realm, skip for now.  It will get added
                // below when all the MIT realms are added.
                //

                NOTHING ;
            }

            if ( String.Buffer )
            {
                LocalFree( String.Buffer );
            }

            if ( DnsDomain.Buffer )
            {
                LocalFree( DnsDomain.Buffer );
            }

        }
    }



    if ( ( ProductType != NtProductLanManNt ) ||
         ( SafeBootMode == SAFEBOOT_MINIMAL ) )
    {
        //
        // Do the machine name:
        //

        Size = CNLEN + 1;

        GetComputerName( ComputerName, &Size );

        RtlInitUnicodeString( &String, ComputerName );

        ComputerEntry = DCacheCreateEntry(
                    DomainMachine,
                    &String,
                    NULL,
                    NULL );

        if ( ComputerEntry )
        {
            DCacheInsertArray( Array, ComputerEntry );

            DCacheDereferenceEntry( ComputerEntry );
        }
    }

    DCacheAddMitRealms( Array );

    if ( DefaultDomain && (*DefaultDomain) )
    {
        RtlInitUnicodeString( &String, DefaultDomain );

        OldDefault = DCacheFindDefaultEntry( Array );

        if ( Entry )
        {
            Entry->Flags &= ~(DCE_DEFAULT_ENTRY);
        }

        Entry = DCacheSearchArray( Array, &String );

        if ( !Entry )
        {
            Entry = DCacheEntryFromRegistry( &String );

            if ( Entry )
            {
                DCacheInsertArray( Array, Entry );
            }
        }
        else 
        {
            DCacheReferenceEntry( Entry );
        }

        if ( Entry )
        {
            Entry->Flags |= DCE_DEFAULT_ENTRY ;

            DCacheDereferenceEntry( Entry );

            if ( OldDefault )
            {
                OldDefault->Flags &= ~(DCE_DEFAULT_ENTRY);
            }
        }
    }

    if ( DomainMember )
    {
        *DomainMember = SidPresent ;
    }

    return TRUE ;

}


BOOL
DCacheUpdateMinimal(
    PDOMAIN_CACHE Cache,
    PWSTR DefaultDomain OPTIONAL,
    BOOL CompleteAsync 
    )
{
    PDOMAIN_CACHE_ARRAY Array = NULL ;
    LARGE_INTEGER RegistryTime = { 0 };
    BOOL DomainMember = FALSE ;
    BOOL NewDomain = FALSE ;
    BOOL RetryDomain = FALSE ;
    BOOL NoCache = FALSE ;
    BOOL StartThread = FALSE ;
    WCHAR ComputerName[ 20 ];
    ULONG Size ;

    if ( !DCacheGetDomainsFromCache( &Array, &RegistryTime ) ||
         ( Array == NULL ) )
    {
        NoCache = TRUE ;
    }

    //
    // In rare events, we will leave a domain, and the cache
    // will still be in the registry.  This is caught later,
    // and deleted, and this is the retry point.
    //

ReloadWithoutCache: 

    if ( !Array )
    {
        Array = DCacheCreateArray( 5, TRUE );

        if ( !Array )
        {
            return FALSE ;
        }
    }
    

    if ( !DCacheGetMinimalArray( Array, 
                                 DefaultDomain,
                                 &DomainMember,
                                 &NewDomain ) )
    {
        DCacheFreeArray( Array );

        return FALSE ;
    }


    //
    // If we are no longer in the same domain, either in a workgroup, or
    // in a different domain, toss the cache.  If we just retried this
    // don't keep doing it...
    //

    if ( ( RetryDomain == FALSE ) &&
         ( ( ( NoCache == FALSE ) &&
             ( DomainMember == FALSE ) ) ||
           ( NewDomain == TRUE ) ) )
    {
        //
        // Cleanup.  The cache is still present, but we are no longer part of a domain
        //

        DCacheFreeArray( Array );

        RegDeleteKey( HKEY_LOCAL_MACHINE, szCache );

        RegDeleteValue( WinlogonKey, szCachePrimary );

        if ( DefaultDomain )
        {
            Size = 20 ;

            if ( GetComputerName( ComputerName, &Size ) )
            {
                if ( _wcsicmp( DefaultDomain, ComputerName ) )
                {
                    DefaultDomain = NULL ;

                    RegSetValueEx(
                            WinlogonKey,
                            DEFAULT_DOMAIN_NAME_KEY,
                            0,
                            REG_SZ,
                            (PUCHAR) ComputerName,
                            (Size + 1) * sizeof( WCHAR ) );
                }
            }
        }


        NoCache = TRUE ;

        Array = NULL ;

        RetryDomain = TRUE ;

        goto ReloadWithoutCache; 

    }

    LockDomainCache( Cache );

    if ( Cache->Array )
    {
        DCacheFreeArray( Cache->Array );
    }

    Cache->Array = Array ;

    Cache->RegistryUpdateTime = RegistryTime ;

    if ( NoCache )
    {
        Cache->Flags |= DCACHE_NO_CACHE ;
    }


    GetSystemTimeAsFileTime( (LPFILETIME) &Cache->CacheUpdateTime );

    if ( DomainMember )
    {
        if ( !NoCache )
        {
            if ( Cache->CacheUpdateTime.QuadPart - Cache->RegistryUpdateTime.QuadPart < TWO_WEEKS )
            {
                Cache->State = DomainCacheRegistryCache ;
            }
            else 
            {
                Cache->State = DomainCacheDefaultOnly ;
            }
        }
        else 
        {
            Cache->State = DomainCacheDefaultOnly ;
        }

        Cache->Flags |= DCACHE_MEMBER ;
    }
    else 
    {
        Cache->State = DomainCacheReady ;
    }

    if ( DCacheFindDefaultEntry( Array ) == NULL )
    {
        Cache->Flags |= DCACHE_DEF_UNKNOWN ;
    }


    if ( ( Cache->State != DomainCacheReady ) &&
         ( CompleteAsync ) )
    {
        StartThread = TRUE ;

        if ( DefaultDomain )
        {
            Cache->DefaultDomain = DupString( DefaultDomain );
        }
        else 
        {
            Cache->DefaultDomain = NULL ;
        }
    }

    UnlockDomainCache( Cache );

    if ( StartThread )
    {
        DCacheUpdateFullAsync( Cache );
    }

    return TRUE ;
}

void
DCacheUpdateFullAsync(
    PDOMAIN_CACHE Cache
    )
{
    HANDLE hThread ;
    DWORD tid ;

    hThread = CreateThread( NULL,
                            0,
                            DCacheUpdateThread,
                            Cache,
                            0,
                            &tid );

    if ( hThread )
    {
        CloseHandle( hThread );
    }
    else 
    {
        LockDomainCache( Cache );

        Cache->State = DomainCacheReady ;

        UnlockDomainCache( Cache );
    }
}


BOOL
DCacheUpdateFull(
    PDOMAIN_CACHE Cache,
    PWSTR Default OPTIONAL
    )
{
    PDOMAIN_CACHE_ARRAY Array = NULL ;
    ULONG NetStatus = 0 ;
    ULONG RetryCount = 3 ;
    BOOL DomainMember = FALSE ;
    NT_PRODUCT_TYPE ProductType = NtProductWinNt;
    LARGE_INTEGER RegistryTime = { 0 };

    if ( ( Cache->Flags & DCACHE_MEMBER ) != 0 )
    {

        DomainMember = TRUE ;

        RtlGetNtProductType( &ProductType );

        if ( ProductType == NtProductLanManNt )
        {
            RetryCount = 3600 ;
        }
        //
        // now, call netlogon, and see if it has the list.
        //

        NetStatus = DCacheGetTrustedDomains( &Array );

        if ( NetStatus != 0 )
        {
            while ( RetryCount-- )
            {
                Sleep( 3000 );

                NetStatus = DCacheGetTrustedDomains( &Array );

                if ( NetStatus == 0 )
                {
                    break;
                }

                if ( RPC_S_UNKNOWN_IF == NetStatus )
                {
                     // exit the loop if no interface (netlogon stopped)
                    RetryCount = 0;
                }
            }

        }

        if ( NetStatus != 0 )
        {
            //
            // Try to read from the cache
            //

            DCacheGetDomainsFromCache( &Array, &RegistryTime );
        }

    }


    if ( Array )
    {
        DCacheGetMinimalArray( Array, Default, &DomainMember, NULL );
    }

    if ( Array )
    {
        LockDomainCache( Cache );

        if ( Cache->Array )
        {
            DCacheFreeArray( Cache->Array );
        }

        Cache->Array = Array ;

        if ( DomainMember )
        {
            Cache->Flags |= DCACHE_MEMBER ;
        }
        else 
        {
            Cache->Flags &= ~( DCACHE_MEMBER ) ;
        }

        if ( NetStatus == 0 )
        {
            Cache->State = DomainCacheReady ;

            if ( ( Cache->Flags & DCACHE_READ_ONLY ) == 0 )
            {
                DCacheWriteDomainsToCache( Array );
            }

            GetSystemTimeAsFileTime( (LPFILETIME) &Cache->RegistryUpdateTime );

            Cache->Flags &= ~(DCACHE_NO_CACHE);
        }
        else if ( (Cache->Flags & DCACHE_NO_CACHE) == 0 )
        {
            Cache->State = DomainCacheRegistryCache ;

            Cache->RegistryUpdateTime = RegistryTime ;
        }
        else 
        {
            Cache->State = DomainCacheDefaultOnly ;

            Cache->RegistryUpdateTime.QuadPart = 0 ;
        }


        if ( Cache->DefaultDomain )
        {
            DCacheSetDefaultEntry(  Cache, 
                                    Cache->DefaultDomain, 
                                    NULL );

            Free( Cache->DefaultDomain );

            Cache->DefaultDomain = NULL ;

        }

        UnlockDomainCache( Cache );

    }

    return ( Array != NULL ) ;


}

DWORD
DCacheUpdateThread(
    PDOMAIN_CACHE Cache
    )
{
    HWND Notify ;
    UINT Message ;

    LockDomainCache( Cache );

    if ( ( Cache->Flags & DCACHE_ASYNC_UPDATE ) != 0 )
    {
        //
        // Another thread is already doing this.
        //

        UnlockDomainCache( Cache );

        return 0 ;
    }

    Cache->Flags |= DCACHE_ASYNC_UPDATE ;

    UnlockDomainCache( Cache );

    DCacheUpdateFull( Cache, NULL );

    LockDomainCache( Cache );

    Notify = Cache->UpdateNotifyWindow ;
    Message = Cache->Message ;

    Cache->UpdateNotifyWindow = NULL ;
    Cache->Message = 0 ;

    Cache->Flags &= ~( DCACHE_ASYNC_UPDATE );

    UnlockDomainCache( Cache );

    if ( Notify )
    {
        DebugLog(( DEB_TRACE_CACHE, "Notifying window %x of cache complete\n" ));
        PostMessage( Notify, Message, 0, 0 );
    }

    return 0;

}


BOOL
DCachePopulateListBoxFromArray(
    PDOMAIN_CACHE_ARRAY Array,
    HWND ComboBox,
    LPWSTR LastKey OPTIONAL
    )
{
    ULONG i ;
    ULONG_PTR Index ;
    PDOMAIN_CACHE_ENTRY Default = NULL ;
    LRESULT Result ;

    //
    // Reset the combo box
    //

    DebugLog((DEB_TRACE_CACHE, "Flushing listbox\n" ));
    SendMessage( ComboBox, CB_RESETCONTENT, 0, 0);

    for ( i = 0 ; i < Array->Count ; i++ )
    {
        DebugLog(( DEB_TRACE_CACHE, "Adding domain %ws (%d) to listbox\n",
                   Array->List[ i ]->DisplayName.Buffer,
                   Array->List[ i ]->Type ));

        if ( Array->List[ i ]->Type == DomainMitRealm )
        {
            if ( (Array->List[ i ]->Flags & DCE_REACHABLE_MIT ) == 0 )
            {
                DebugLog(( DEB_TRACE_CACHE, "MIT Realm %ws is not reachable, skipping\n",
                            Array->List[ i ]->FlatName.Buffer ));

                continue;
            }
        }

        Index = SendMessage( ComboBox, 
                     CB_ADDSTRING,
                     0,
                     (LPARAM) Array->List[ i ]->DisplayName.Buffer );

        if ( Index != CB_ERR )
        {
            SendMessage( ComboBox,
                         CB_SETITEMDATA,
                         (WPARAM) Index,
                         (LPARAM) Array->List[ i ] );

        }

        if ( ( Array->List[ i ]->Type == DomainMachine ) &&
             ( Default == NULL ) )
        {
            Default = Array->List[ i ] ;
        }

        if ( Array->List[ i ]->Flags & DCE_DEFAULT_ENTRY )
        {
            Default = Array->List[ i ];
        }

    }

    //
    // Select the default entry:
    //

    if ( LastKey && (*LastKey) )
    {
        Result = SendMessage( ComboBox,
                     CB_SELECTSTRING,
                     (WPARAM) -1,
                     (LPARAM) LastKey );

#if DBG
        if ( Result != CB_ERR )
        {
            DebugLog(( DEB_TRACE_CACHE, "Selected first entry starting with %ws\n", LastKey ));
        }
        else 
        {
            DebugLog(( DEB_TRACE_CACHE, "No entry found starting with %ws.  Trying default\n", LastKey ));
        }
#endif 
    } 
    else 
    {
        Result = CB_ERR ;
    }

    if ( ( Result == CB_ERR ) && 
         ( Default != NULL ) )
    {
        SendMessage( ComboBox, 
                     CB_SELECTSTRING, 
                     (WPARAM) -1, 
                     (LPARAM) Default->DisplayName.Buffer );

        DebugLog(( DEB_TRACE_CACHE, "Selecting '%ws' as the default entry\n", 
                    Default->DisplayName.Buffer ));
    }


    return TRUE ;
}

BOOL
DCacheSetNotifyWindowIfNotReady(
    PDOMAIN_CACHE Cache,
    HWND Window,
    UINT Message
    )
{
    BOOL IsReady = FALSE ;
    HANDLE hThread ;
    DWORD tid ;

    LockDomainCache( Cache );

    IsReady = ( Cache->State == DomainCacheReady );

    if ( !IsReady )
    {
        Cache->UpdateNotifyWindow = Window ;
        Cache->Message = Message ;
    }
    else 
    {
        if ( ( Cache->Flags & DCACHE_ASYNC_UPDATE ) == 0 )
        {
            hThread = CreateThread( NULL,
                                    0,
                                    DCacheUpdateThread,
                                    Cache,
                                    0,
                                    &tid );

        }
    }

    UnlockDomainCache( Cache );

    return IsReady ;

}


PDOMAIN_CACHE_ARRAY
DCacheCopyCacheArray(
    PDOMAIN_CACHE Cache
    )
{
    PDOMAIN_CACHE_ARRAY Array = NULL ;

    LockDomainCache( Cache );

    if ( Cache->Array )
    {
        Array = DCacheCopyArray( Cache->Array );
    }

    UnlockDomainCache( Cache );

    return Array ;
}

BOOL
DCacheValidateCache(
    PDOMAIN_CACHE Cache
    )
{
    LARGE_INTEGER Now ;
    LARGE_INTEGER Diff ;

    LockDomainCache( Cache );

    GetSystemTimeAsFileTime( (LPFILETIME) &Now );

    Diff.QuadPart = Now.QuadPart - Cache->CacheUpdateTime.QuadPart ;

    UnlockDomainCache( Cache );

    return (Diff.QuadPart < TWO_MINUTES );

}

DOMAIN_CACHE_STATE
DCacheGetCacheState(
    PDOMAIN_CACHE Cache
    )
{
    DOMAIN_CACHE_STATE State ;

    LockDomainCache( Cache );

    State = Cache->State ;

    UnlockDomainCache( Cache );

    return State ;
}

BOOL
DCacheSetDefaultEntry(
    PDOMAIN_CACHE Cache,
    PWSTR FlatName OPTIONAL,
    PWSTR DnsName OPTIONAL
    )
{
    UNICODE_STRING String ;
    PDOMAIN_CACHE_ENTRY Entry ;
    BOOL Result ;

    if ( ( FlatName == NULL ) &&
        ( DnsName == NULL ) )
    {
        return FALSE ;
    }

    LockDomainCache( Cache );

    Entry = DCacheFindDefaultEntry( Cache->Array );

    if ( Entry )
    {
        Entry->Flags &= ~(DCE_DEFAULT_ENTRY) ;
    }

    if ( FlatName )
    {
        RtlInitUnicodeString( &String, FlatName );

        Entry = DCacheSearchArray( Cache->Array,
                                   &String );

        
    }
    else 
    {         
        RtlInitUnicodeString( &String, DnsName );

        Entry = DCacheSearchArrayByDns( Cache->Array,
                                        &String );

    }

    if ( Entry )
    {
        Entry->Flags |= DCE_DEFAULT_ENTRY ;

        Result = TRUE ;

        DebugLog(( DEB_TRACE_CACHE, "Setting '%ws' to be the default\n", 
                   Entry->DisplayName.Buffer ));
    }
    else 
    {
        Result = FALSE ;
    }

    if ( Result )
    {
        Cache->Flags &= ~(DCACHE_DEF_UNKNOWN) ;
    }
    else 
    {
        Cache->Flags |= DCACHE_DEF_UNKNOWN ;
    }

    UnlockDomainCache( Cache );

    return Result ;
}

PDOMAIN_CACHE_ENTRY
DCacheLocateEntry(
    PDOMAIN_CACHE Cache,
    PWSTR Domain
    )
{
    PDOMAIN_CACHE_ENTRY Entry = NULL ;
    UNICODE_STRING String ;

    LockDomainCache( Cache );

    if ( Domain )
    {
        RtlInitUnicodeString( &String, Domain );

        Entry = DCacheSearchArray( Cache->Array,
                                   &String );

        if ( Entry )
        {
            DCacheReferenceEntry( Entry );
        }
    }

    UnlockDomainCache( Cache );

    return Entry ;
}


ULONG
DCacheGetFlags(
    PDOMAIN_CACHE Cache 
    )
{
    ULONG Flags ;

    LockDomainCache( Cache );

    Flags = Cache->Flags ;

    UnlockDomainCache( Cache );

    return Flags ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\makefile.inc ===
!if exist(..\$(TARGET_DIRECTORY).inc)
!include ..\$(TARGET_DIRECTORY).inc
!endif

STRING_FILES=strings.rc $(SHELL_INC_PATH)\ginastrs.rc
DIALOG_FILES=dialogs.rc $(SHELL_INC_PATH)\ginadlgs.rc
BITMAP_FILES=bitmaps.rc res\* $(SHELL_INC_PATH)\ginabmps.rc
ICON_FILES=nodc.ico

res.rc: $(STRING_FILES) $(DIALOG_FILES) $(BITMAP_FILES) $(ICON_FILES) $(O)\wlevents.rc

precomp.h: wlevents.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\lock.h ===
/****************************** Module Header ******************************\
* Module Name: lock.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis used to lock the workstation
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//


INT_PTR
CALLBACK
LockedDlgProc(HWND, UINT, WPARAM, LPARAM);


INT_PTR
CALLBACK
UnlockDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\lockout.h ===
/****************************** Module Header ******************************\
* Module Name: lockout.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis and data types used to implement account lockout
*
* History:
* 05-27-92 Davidc       Created.
\***************************************************************************/


#ifdef DATA_TYPES_ONLY

//
// Lockout specific types
//


//
// FailedLogonTimes is an array holding the time of the previous
// consecutive failed logons.
// FailedLogonIndex points into the array at the last bad logon time.
//
// The following values in the array are valid at any particular time
//
// FailedLogonTime[FailedLogonIndex] // Most recent failed logon
// FailedLogonTime[FailedLogonIndex - 1]
// ...
// FailedLogonTime[FailedLogonIndex - ConsecutiveFailedLogons + 1]
//
// No values in the array are valid if ConsecutiveFailedLogons == 0
//

typedef struct _LOCKOUT_DATA {
    ULONG   ConsecutiveFailedLogons;
    ULONG   FailedLogonIndex;
    TIME    FailedLogonTimes[LOCKOUT_BAD_LOGON_COUNT];
} LOCKOUT_DATA;
typedef LOCKOUT_DATA *PLOCKOUT_DATA;




#else // DATA_TYPES_ONLY


//
// Exported function prototypes
//

BOOL
LockoutInitialize(
    PGLOBALS pGlobals
    );

BOOL
LockoutHandleFailedLogon(
    PGLOBALS pGlobals
    );

BOOL
LockoutHandleSuccessfulLogon(
    PGLOBALS pGlobals
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\lsa.c ===
/****************************************************************************

   PROGRAM: LSA.C

   PURPOSE: Utility routines that access the LSA.

****************************************************************************/

#include "msgina.h"



// #define DEBUG_LSA

#ifdef DEBUG_LSA
#define VerbosePrint(s) WLPrint(s)
#else
#define VerbosePrint(s)
#endif

NTSTATUS NtStatusGPDEx = 0;

/***************************************************************************\
* GetPrimaryDomainEx
*
* Purpose : Returns the primary domain name for authentication
*
* Returns : TRUE if primary domain exists and returned, otherwise FALSE
*
* The primary domain name should be freed using RtlFreeUnicodeString().
* The primary domain sid should be freed using Free()
*
* History:
* 02-13-92 Davidc       Created.
\***************************************************************************/
BOOL
GetPrimaryDomainEx(
    PUNICODE_STRING PrimaryDomainName OPTIONAL,
    PUNICODE_STRING PrimaryDomainDnsName OPTIONAL,
    PSID    *PrimaryDomainSid OPTIONAL,
    PBOOL SidPresent OPTIONAL
    )
{
    NTSTATUS IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;
    BOOL    PrimaryDomainPresent = FALSE;
    DWORD dwRetry = 10;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //
Retry:
    NtStatusGPDEx = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );

    if (!NT_SUCCESS(NtStatusGPDEx)) {
        DebugLog((DEB_ERROR, "Failed to open local LsaPolicyObject, Status = 0x%lx\n", NtStatusGPDEx));
        if ((NtStatusGPDEx == RPC_NT_SERVER_TOO_BUSY) && (--dwRetry))
        {
            Sleep(100);
            goto Retry;     // Likely to be too soon to call Lsa
        }
        return(FALSE);
    }

    //
    // Get the primary domain info
    //
    NtStatusGPDEx = LsaQueryInformationPolicy(LsaHandle,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&DnsDomainInfo);
    if (!NT_SUCCESS(NtStatusGPDEx)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", NtStatusGPDEx));

        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(FALSE);
    }

    //
    // Copy the primary domain name into the return string
    //

    if ( SidPresent )
    {
        *SidPresent = ( DnsDomainInfo->Sid != NULL );
    }

    if (DnsDomainInfo->Sid != NULL) {

        PrimaryDomainPresent = TRUE;

        if (PrimaryDomainName)
        {

            if (DuplicateUnicodeString(PrimaryDomainName, &(DnsDomainInfo->Name))) {

                if (PrimaryDomainSid != NULL) {

                    ULONG SidLength = RtlLengthSid(DnsDomainInfo->Sid);

                    *PrimaryDomainSid = Alloc(SidLength);
                    if (*PrimaryDomainSid != NULL) {

                        NtStatusGPDEx = RtlCopySid(SidLength, *PrimaryDomainSid, DnsDomainInfo->Sid);
                        ASSERT(NT_SUCCESS(NtStatusGPDEx));

                    } else {
                        RtlFreeUnicodeString(PrimaryDomainName);
                        PrimaryDomainPresent = FALSE;
                    }
                }

            } else {
                PrimaryDomainPresent = FALSE;
            }
        }
    } else if (DnsDomainInfo->DnsDomainName.Length != 0) {
        PrimaryDomainPresent = TRUE;
        if (PrimaryDomainName) {
            if (DuplicateUnicodeString(
                    PrimaryDomainName,
                    &DnsDomainInfo->DnsDomainName)) {

                ASSERT(!ARGUMENT_PRESENT(PrimaryDomainSid));

            } else {
                PrimaryDomainPresent = FALSE;
            }

        }
    }

    if ( ( DnsDomainInfo->DnsDomainName.Length != 0 ) &&
         ( PrimaryDomainDnsName != NULL ) )
    {
        DuplicateUnicodeString( PrimaryDomainDnsName, 
                                &DnsDomainInfo->DnsDomainName );
    }

    //
    // We're finished with the Lsa
    //

    IgnoreStatus = LsaFreeMemory(DnsDomainInfo);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = LsaClose(LsaHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(PrimaryDomainPresent);
}


//
// Since this isn't going to change without a reboot, we can easily cache the info
//
BOOL
IsMachineDomainMember(
    VOID
    )
{
    static BOOL s_bIsDomainMember = FALSE;
    static BOOL s_bDomainCached = FALSE;

    if (!s_bDomainCached)
    {
        s_bIsDomainMember = GetPrimaryDomainEx(NULL, NULL, NULL, NULL);
        if (NT_SUCCESS(NtStatusGPDEx))
            s_bDomainCached = TRUE;
    }

    return s_bIsDomainMember;
}

ULONG
GetMaxPasswordAge(
    LPWSTR Domain,
    PULONG MaxAge
    )
{
    DWORD Error;
    PUSER_MODALS_INFO_0 Modals;
    WCHAR ComputerName[ CNLEN+2 ];
    ULONG Length ;
    PDOMAIN_CONTROLLER_INFO DcInfo ;
    PWSTR DcNameBuffer ;

    Length = CNLEN + 2;

    GetComputerName( ComputerName, &Length );

    if (_wcsicmp( ComputerName, Domain ) == 0 )
    {
        DcNameBuffer = NULL ;
        DcInfo = NULL ;
    }
    else
    {

        Error = DsGetDcName( NULL,
                             Domain,
                             NULL,
                             NULL,
                             0,
                             &DcInfo );

        if ( Error )
        {
            return Error ;
        }

        DcNameBuffer = DcInfo->DomainControllerAddress ;
    }

    Error = NetUserModalsGet( DcNameBuffer,
                                  0,
                                  (PUCHAR *) &Modals );

    if ( Error == 0 )
    {
        *MaxAge = Modals->usrmod0_max_passwd_age ;

        NetApiBufferFree( Modals );
    }

    if ( DcInfo )
    {
        NetApiBufferFree( DcInfo );
    }

    return Error ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\msgina.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.h
//
//  Contents:   Main header file for MSGINA.DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "pragma.h"

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>

#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>
#endif


#include <windows.h>
#include <windowsx.h>
#include <winuserp.h>
#include <winbasep.h>
#include <winwlx.h>
#include <rasdlg.h>
#include <dsgetdc.h>
#include <userenv.h>
#include <userenvp.h>

#include <winsta.h>
#include <safeboot.h>
#include <msginaexports.h>

#include "commctrl.h"

#ifndef RC_INVOKED

#include <lm.h>
#include <npapi.h>

//
// Handy Defines
//

#define AUTO_LOGON      // Enable automatic logon to configure netlogon stuff.

#define DLG_FAILURE IDCANCEL

typedef int TIMEOUT, * PTIMEOUT;


//
// Macro to determine if the current session is the active console session
//

#define IsActiveConsoleSession() (BOOLEAN)(USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)


#include "structs.h"
#include "strings.h"
#include "debug.h"

#include "welcome.h"
#include "winutil.h"
#include "wlsec.h"
//
//  Global Variables
//

extern  HINSTANCE                   hDllInstance;   // My instance, for resource loading
extern  HINSTANCE                   hAppInstance;   // App instance, for dialogs, etc.
extern  PWLX_DISPATCH_VERSION_1_4   pWlxFuncs;      // Ptr to table of functions
extern  PSID                        pWinlogonSid;
extern  DWORD                       SafeBootMode;

extern  HKEY                        WinlogonKey ;

//
// Terminal Server definitions
//
extern  BOOL                        g_IsTerminalServer;
extern  BOOL                        g_Console;

//
//
// GetProcAddr Prototype for winsta.dll function WinStationQueryInformationW
//

typedef BOOLEAN (*PWINSTATION_QUERY_INFORMATION) (
                    HANDLE hServer,
                    ULONG SessionId,
                    WINSTATIONINFOCLASS WinStationInformationClass,
                    PVOID  pWinStationInformation,
                    ULONG WinStationInformationLength,
                    PULONG  pReturnLength
                    );

//
// GetProcAddr Proto for regapi.dll function RegUserConfigQuery
//
typedef LONG ( * PREGUSERCONFIGQUERY) ( WCHAR *,
                                        WCHAR *,
                                        PUSERCONFIGW,
                                        ULONG,
                                        PULONG );

typedef LONG ( * PREGDEFAULTUSERCONFIGQUERY) ( WCHAR *,
                                               PUSERCONFIGW,
                                               ULONG,
                                               PULONG );

//
// tsnotify.dll export
//
typedef BOOL ( * PTERMSRVCREATETEMPDIR) (   PVOID *pEnv, 
                                            HANDLE UserToken,
                                            PSECURITY_DESCRIPTOR SD
                                        );


//
// Module header files:
//
#include "mslogon.h"
#include "audit.h"
#include "chngepwd.h"
#include "domain.h"
#include "lockout.h"
#include "lsa.h"
#include "lock.h"
#include "options.h"
#include "envvar.h"
#include "rasx.h"
#include "brand.h"
#include "langicon.h"


BOOL
GetErrorDescription(
    DWORD   ErrorCode,
    LPWSTR  Description,
    DWORD   DescriptionSize
    );

VOID FreeAutoLogonInfo( PGLOBALS pGlobals );

BOOL DisconnectLogon( HWND, PGLOBALS );

BOOL GetDisableCad(PGLOBALS);
DWORD GetAnimationTimeInterval(PGLOBALS pGlobals);
BOOL GetSCForceOption();

VOID
UpdateWithChangedPassword(
    PGLOBALS pGlobals,
    HWND    ActiveWindow,
    BOOL    Hash,
    PWSTR   UserName,
    PWSTR   Domain,
    PWSTR   Password,
    PWSTR   NewPassword,
	PMSV1_0_INTERACTIVE_PROFILE	NewProfile
    );

#endif // not RC_INVOKED

//
// Include resource header files
//
#include "stringid.h"
#include "wlevents.h"
#include "resource.h"
#include "shutdown.h"

//
// Shutdown "reason" stuff.
//
DWORD GetReasonSelection(HWND hwndCombo);
void SetReasonDescription(HWND hwndCombo, HWND hwndStatic);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\msgina.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       msgina.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------
#include "msgina.h"

// Link Window
#include "shlobj.h"
#include "shlobjp.h"

#include <accctrl.h>
#include <aclapi.h>

#include "tsperf.h"


HINSTANCE                   hDllInstance;   // My instance, for resource loading
HINSTANCE                   hAppInstance;   // App instance, for dialogs, etc.
PWLX_DISPATCH_VERSION_1_4   pWlxFuncs;      // Ptr to table of functions
PWLX_DISPATCH_VERSION_1_4   pTrueTable ;    // Ptr to table in winlogon
DWORD                       SafeBootMode;


BOOL    g_IsTerminalServer;
BOOL    g_Console = TRUE;
BOOL    VersionMismatch ;
DWORD   InterfaceVersion ;
HKEY    WinlogonKey ;

int TSAuthenticatedLogon(PGLOBALS pGlobals);

BOOL
WINAPI
DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );
            hDllInstance = hInstance;
            g_IsTerminalServer = !!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));
#if DBG
            InitDebugSupport();
#endif
            InitializeSecurityGlobals();
            _Shell_DllMain(hInstance, dwReason);
            return(TRUE);
        case DLL_PROCESS_DETACH:
            _Shell_DllMain(hInstance, dwReason);
            FreeSecurityGlobals();
            return(TRUE);
        default:
            return(TRUE);
    }
}

BOOL
WINAPI
WlxNegotiate(
    DWORD                   dwWinlogonVersion,
    DWORD                   *pdwDllVersion
    )
{
    InterfaceVersion = dwWinlogonVersion ;

    if (dwWinlogonVersion < WLX_CURRENT_VERSION)
    {
        DebugLog(( DEB_WARN, "Old WLX interface (%x)\n", dwWinlogonVersion ));

        if ( dwWinlogonVersion < WLX_VERSION_1_1 )
        {
            return FALSE ;
        }

        VersionMismatch = TRUE ;
    }

    *pdwDllVersion = WLX_CURRENT_VERSION;

    DebugLog((DEB_TRACE, "Negotiate:  successful!\n"));

    return(TRUE);

}

BOOL GetDefaultCADSetting(void)
{
    BOOL bDisableCad = FALSE;
    NT_PRODUCT_TYPE NtProductType;


    //
    // Servers and workstations in a domain will default to requiring CAD.
    // Workstations in a workgroup won't require CAD (by default).  Note,
    // the default CAD setting can be overwritten by either a machine
    // preference or machine policy.
    //

    RtlGetNtProductType(&NtProductType);

    if ( IsWorkstation(NtProductType) )
    {
        if ( !IsMachineDomainMember() )     // This function is doing some caching
        {                                   // so we don't need to be brighter here
            bDisableCad = TRUE;
        }
    }

    return bDisableCad;
}

#define MSGINA_ANIM_FAST_TIME   20
#define MSGINA_ANIM_REMOTE_TIME 100
#define MSGINA_ANIM_SLOW_TIME   500


//
// GetAnimationTimeInterval
// Purpose:
//  Retreive animation time interval in ms. There are different settings depending
//  on w/not we are remote
//
//
// Params:
//  pGlobals - IN global settings
//
// Returns:
//  Animation timeslice in milliseconds.
//
DWORD GetAnimationTimeInterval(PGLOBALS pGlobals)
{
    DWORD dwAnimationTimeSlice;

    if (IsActiveConsoleSession()) {

        //Console defaults
        dwAnimationTimeSlice = MSGINA_ANIM_FAST_TIME;
    }
    else if (pGlobals->MuGlobals.fSlowAnimationRate) {

        //Remote but reduced animation
        dwAnimationTimeSlice = MSGINA_ANIM_SLOW_TIME;
    }
    else {

        //Remote but with anim
        dwAnimationTimeSlice = MSGINA_ANIM_REMOTE_TIME;
    }

    return dwAnimationTimeSlice;
}


BOOL GetDisableCad(PGLOBALS pGlobals)
// Returns whether or not the user should be required to press C-A-D before
// logging on. TRUE == Disable CAD, FALSE == Require CAD
{
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey;

    BOOL fDisableCad = GetDefaultCADSetting();

    dwSize = sizeof(fDisableCad);

    RegQueryValueEx (WinlogonKey, DISABLE_CAD, NULL, &dwType,
                        (LPBYTE) &fDisableCad , &dwSize);

    //
    // Check if C+A+D is disabled via policy
    //

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY, 0, KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(fDisableCad);

        RegQueryValueEx (hKey, DISABLE_CAD, NULL, &dwType,
                            (LPBYTE) &fDisableCad , &dwSize);

        RegCloseKey (hKey);
    }

    //
    // By default do a fast animation for the progress band
    //
    pGlobals->MuGlobals.fSlowAnimationRate = FALSE;


    //
    // Check if C+A+D is disabled for remote Hydra clients and copy the client name
    //

    if (g_IsTerminalServer  ) {

        HANDLE          dllHandle;

        //
        // Load winsta.dll
        //
        dllHandle = LoadLibraryW(L"winsta.dll");

        if (dllHandle) {

            PWINSTATION_QUERY_INFORMATION pfnWinstationQueryInformation;

            pfnWinstationQueryInformation = (PWINSTATION_QUERY_INFORMATION) GetProcAddress(
                                                                   dllHandle,
                                                                   "WinStationQueryInformationW"
                                                                   );
            if (pfnWinstationQueryInformation) {


                WINSTATIONCLIENT ClientData;
                ULONG Length;


                //
                // Get the CAD disable data from the client
                //
                if ( pfnWinstationQueryInformation( SERVERNAME_CURRENT,
                                                  LOGONID_CURRENT,
                                                  WinStationClient,
                                                  &ClientData,
                                                  sizeof(ClientData),
                                                  &Length ) ) {


                    //
                    // Take the client settings only if the CAD is not globally disabled for the server,
                    // and, if this is not the console active session.
                    //
                    if (!fDisableCad && !IsActiveConsoleSession() ) 
                    {

                        fDisableCad = ClientData.fDisableCtrlAltDel;

                    }

                    //
                    // Copy the Client Name, even console has a client name now, due to PTS and console disconnect features.
                    //
                    //
                    lstrcpyn(pGlobals->MuGlobals.ClientName, ClientData.ClientName, CLIENTNAME_LENGTH);

                    if (ClientData.PerformanceFlags &
                        TS_PERF_DISABLE_MENUANIMATIONS) {
                        pGlobals->MuGlobals.fSlowAnimationRate = TRUE;
                    }
                }
                else
                {
                    if (!IsActiveConsoleSession()) {
                       fDisableCad = TRUE;
                    }

                    // TS start could have been delayed until 60seconds post first console login.
                    // Hence, it is safe to assume that this is the console session, besides, 
                    // we are initing some benign env var.

                    lstrcpyn(pGlobals->MuGlobals.ClientName,L"Console", CLIENTNAME_LENGTH );
                }
            }

            FreeLibrary(dllHandle);
        }
    }

    // Friendly UI on -> ALWAYS disable CAD.

    if (ShellIsFriendlyUIActive())
    {
        fDisableCad = TRUE;
    }

    return fDisableCad;
}

BOOL GetSCForceOption()
// Returns whether or not the user should be required to use a SC to logon
// TRUE == ForceSCLogon, FALSE == Non ForceSCLogon
{
    DWORD dwSize;
    DWORD dwType;
    HKEY hKey;

    BOOL fForceSCLogon = FALSE;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY, 0, KEY_READ,
                     &hKey) == ERROR_SUCCESS )
    {
        dwSize = sizeof(fForceSCLogon);

        RegQueryValueEx(hKey, FORCE_SC_LOGON, NULL, &dwType,
                        (LPBYTE) &fForceSCLogon , &dwSize);

        RegCloseKey (hKey);
    }

    return fForceSCLogon;
}


BOOL
MsGinaSetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR Value,
    ULONG_PTR * OldValue
    )
{
    return FALSE ;
}


BOOL
MsGinaGetOption(
    HANDLE hWlx,
    DWORD Option,
    ULONG_PTR * Value
    )
{
    return FALSE ;
}


PWLX_DISPATCH_VERSION_1_4
GetFixedUpTable(
    PVOID FakeTable
    )
{
    int err ;
    PVOID p ;
    PWLX_DISPATCH_VERSION_1_4 pNewTable ;
    DWORD dwSize ;
    DWORD dwType ;

    pNewTable = LocalAlloc( LMEM_FIXED, sizeof( WLX_DISPATCH_VERSION_1_4 ) );

    if ( !pNewTable )
    {
        return NULL ;
    }

    dwSize = sizeof( PVOID );
    err = RegQueryValueEx(
                WinlogonKey,
                TEXT("Key"),
                NULL,
                &dwType,
                (PUCHAR) &p,
                &dwSize );

    if ( (err == 0) &&
         (dwType == REG_BINARY) &&
         (dwSize == sizeof( PVOID ) ) )
    {
        pTrueTable = p ;

        switch ( InterfaceVersion )
        {
            case WLX_VERSION_1_1:
                dwSize = sizeof( WLX_DISPATCH_VERSION_1_1 );
                break;

            case WLX_VERSION_1_2:
            case WLX_VERSION_1_3:
            case WLX_VERSION_1_4:
                dwSize = sizeof( WLX_DISPATCH_VERSION_1_2 );
                break;

        }

        RtlCopyMemory(
            pNewTable,
            FakeTable,
            dwSize );

        pNewTable->WlxGetOption = MsGinaGetOption ;
        pNewTable->WlxSetOption = MsGinaSetOption ;
        pNewTable->WlxCloseUserDesktop = pTrueTable->WlxCloseUserDesktop ;
        pNewTable->WlxWin31Migrate = pTrueTable->WlxWin31Migrate ;
        pNewTable->WlxQueryClientCredentials = pTrueTable->WlxQueryClientCredentials ;
        pNewTable->WlxQueryInetConnectorCredentials = pTrueTable->WlxQueryInetConnectorCredentials ;
        pNewTable->WlxDisconnect = pTrueTable->WlxDisconnect ;
        pNewTable->WlxQueryTerminalServicesData = pTrueTable->WlxQueryTerminalServicesData ;
        pNewTable->WlxQueryConsoleSwitchCredentials = pTrueTable->WlxQueryConsoleSwitchCredentials ;
        pNewTable->WlxQueryTsLogonCredentials = pTrueTable->WlxQueryTsLogonCredentials;
    }
    else
    {
        LocalFree( pNewTable );
        pNewTable = NULL ;
    }

    return pNewTable ;
}

extern DWORD g_dwMainThreadId;  // declared in status.c (used to "fix" a thread safety issue)

BOOL
WINAPI
WlxInitialize(
    LPWSTR                  lpWinsta,
    HANDLE                  hWlx,
    PVOID                   pvReserved,
    PVOID                   pWinlogonFunctions,
    PVOID                   *pWlxContext
    )
{
    PGLOBALS    pGlobals;
    HKEY        hKey;
    DWORD       dwSize, dwType;
    DWORD       dwStringMemory;
    DWORD       dwAutoLogonCount ;
    DWORD       dwNoLockWksta ;
    // Upon which bitmaps should our text be painted.
    BOOL        fTextOnLarge;
    BOOL        fTextOnSmall;
    ULONG_PTR   ProbeValue ;
    PWLX_GET_OPTION GetOptCall ;
    BOOL        DoFixup ;
    BOOL        DidFixup ;
    int err ;

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                WINLOGON_KEY,
                0,
                KEY_READ | KEY_WRITE,
                &WinlogonKey );
    if ( err != 0 )
    {
        return FALSE ;
    }

    DoFixup = TRUE ;
    DidFixup = FALSE ;

    if ( VersionMismatch )
    {
        pWlxFuncs = GetFixedUpTable( pWinlogonFunctions );
        if ( pWlxFuncs )
        {
            DidFixup = TRUE ;
        }
        else
        {
            pWlxFuncs = (PWLX_DISPATCH_VERSION_1_4) pWinlogonFunctions ;
            DidFixup = FALSE ;
        }
    }
    else
    {
        pWlxFuncs = (PWLX_DISPATCH_VERSION_1_4) pWinlogonFunctions ;
    }

    //
    // Probe the callback table to make sure we're ok:
    //
    try
    {
        GetOptCall = pWlxFuncs->WlxGetOption ;

        if ( GetOptCall( hWlx,
                         WLX_OPTION_DISPATCH_TABLE_SIZE,
                         &ProbeValue ) )
        {
            if ( ProbeValue == sizeof( WLX_DISPATCH_VERSION_1_4 ) )
            {
                DoFixup = FALSE ;
            }
        }
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        NOTHING ;
    }

    if ( DoFixup && !DidFixup )
    {
        pWlxFuncs = GetFixedUpTable( pWinlogonFunctions );
    }

    if ( !pWlxFuncs )
    {
        return FALSE ;
    }

    pGlobals = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(GLOBALS));

    if ( !pGlobals )
    {
        return FALSE ;
    }

    if ( !NT_SUCCESS ( RtlInitializeCriticalSection( &pGlobals->csGlobals ) ) )
    {
        LocalFree( pGlobals );
        return FALSE ;
    }

    if ( !InitHKeyCurrentUserSupport() )
    {
        RtlDeleteCriticalSection( &pGlobals->csGlobals );
        LocalFree( pGlobals );
        return FALSE ;
    }

    // Reserve enough memory for 4 strings of length MAX_STRING_BYTES
    dwStringMemory = (MAX_STRING_BYTES * sizeof (WCHAR)) * 4;
    pGlobals->LockedMemory = VirtualAlloc(
            NULL,
            dwStringMemory,
            MEM_COMMIT,
            PAGE_READWRITE);
    if ( pGlobals->LockedMemory == NULL )
    {
        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection( &pGlobals->csGlobals );
        LocalFree( pGlobals );
        return FALSE ;
    }

    VirtualLock( pGlobals->LockedMemory, dwStringMemory);

    memset( pGlobals->LockedMemory, 0, dwStringMemory );
    pGlobals->UserName = pGlobals->LockedMemory ;
    pGlobals->Domain = pGlobals->UserName + MAX_STRING_BYTES ;
    pGlobals->Password = pGlobals->Domain + MAX_STRING_BYTES ;
    pGlobals->OldPassword = pGlobals->Password + MAX_STRING_BYTES ;

    *pWlxContext = (PVOID) pGlobals;

    pGlobals->hGlobalWlx = hWlx;

    pWlxFuncs->WlxUseCtrlAltDel(hWlx);

    if ( DCacheInitialize() )
    {
        pGlobals->Cache = DCacheCreate();
    }
    else
    {
        pGlobals->Cache = NULL ;
    }

    if ( pGlobals->Cache == NULL )
    {
        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection(&pGlobals->csGlobals);

        VirtualFree( pGlobals->LockedMemory, 0, MEM_RELEASE );

        LocalFree (pGlobals);

        DebugLog((DEB_ERROR, "Failed to init domain cache!\n"));

        return(FALSE);

    }



    dwSize = sizeof( dwNoLockWksta );
    if ( RegQueryValueEx(
            WinlogonKey,
            DISABLE_LOCK_WKSTA,
            0,
            &dwType,
            (PUCHAR) &dwNoLockWksta,
            &dwSize ) == 0 )
    {
        if ( dwNoLockWksta == 2 )
        {
            dwNoLockWksta = 0 ;

            RegSetValueEx(
                WinlogonKey,
                DISABLE_LOCK_WKSTA,
                0,
                REG_DWORD,
                (PUCHAR) &dwNoLockWksta,
                sizeof( DWORD ) );
        }
    }

    if (!InitializeAuthentication(pGlobals))
    {
        *pWlxContext = NULL;

        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection(&pGlobals->csGlobals);

        VirtualFree( pGlobals->LockedMemory, 0, MEM_RELEASE );
        LocalFree (pGlobals);
        DebugLog((DEB_ERROR, "Failed to init authentication!\n"));
        return(FALSE);
    }

    //
    // Start by clearing the entire Multi-User Globals
    //
    RtlZeroMemory( &pGlobals->MuGlobals, sizeof(pGlobals->MuGlobals) );

    //
    // Get our SessionId and save in globals
    //

    pGlobals->MuGlobals.SessionId = NtCurrentPeb()->SessionId;
    if (pGlobals->MuGlobals.SessionId != 0) {
        g_Console = FALSE;
    }

    //
    // if this is a TS session, we can't run if there is a version
    // mismatch.  Fail out now.
    //
    if ( (!g_Console) &&
            (VersionMismatch ) )
    {
        *pWlxContext = NULL;
        CleanupHKeyCurrentUserSupport();
        RtlDeleteCriticalSection(&pGlobals->csGlobals);
        LocalFree (pGlobals);
        DebugLog((DEB_ERROR, "Failed to init authentication!\n"));
        return(FALSE);
    }


    //
    // this actually starts the s/c thread.
    //
    if( g_Console )
    {
        ULONG_PTR Value ;
        pWlxFuncs->WlxGetOption(pGlobals->hGlobalWlx,
                                WLX_OPTION_SMART_CARD_PRESENT,
                                &Value);
    }

    //
    // If this is auto admin logon, or ctrl+alt+del is disabled,
    // generate a fake SAS right now. Don't attempt AutoLogon unless on Console
    //
    if ((g_Console && GetProfileInt( APPLICATION_NAME, TEXT("AutoAdminLogon"), 0) ) ||
           GetDisableCad(pGlobals))
    {
        dwSize = sizeof( DWORD );
        if ( RegQueryValueEx( WinlogonKey, AUTOLOGONCOUNT_KEY, NULL,
                              &dwType, (LPBYTE) &dwAutoLogonCount,
                              &dwSize ) == 0 )
        {
            //
            // AutoLogonCount value was present.  Check the value:
            //
            if ( dwAutoLogonCount == 0 )
            {
                //
                // Went to zero.  Reset everything:
                //

                RegDeleteValue( WinlogonKey, AUTOLOGONCOUNT_KEY );
                RegDeleteValue( WinlogonKey, DEFAULT_PASSWORD_KEY );
                RegSetValueEx( WinlogonKey, AUTOADMINLOGON_KEY, 0,
                        REG_SZ, (LPBYTE) TEXT("0"), 2 * sizeof(WCHAR) );
            }
            else
            {
                //
                // Decrement the count, and try the logon:
                //
                dwAutoLogonCount-- ;

                RegSetValueEx( WinlogonKey, AUTOLOGONCOUNT_KEY,
                               0, REG_DWORD, (LPBYTE) &dwAutoLogonCount,
                               sizeof( DWORD ) );

                KdPrint(( "AutoAdminLogon = 1\n" ));
                pWlxFuncs->WlxSasNotify(pGlobals->hGlobalWlx, WLX_SAS_TYPE_CTRL_ALT_DEL);
            }
        }
        else
        {
            //
            // AutoLogonCount not present
            //

            KdPrint(( "AutoAdminLogon = 1\n" ));
            pWlxFuncs->WlxSasNotify( pGlobals->hGlobalWlx, WLX_SAS_TYPE_CTRL_ALT_DEL );
        }

    }

    //
    // get the safeboot mode
    //
    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("system\\currentcontrolset\\control\\safeboot\\option"),
            0,
            KEY_READ,
            & hKey
            ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        RegQueryValueEx (
                hKey,
                TEXT("OptionValue"),
                NULL,
                &dwType,
                (LPBYTE) &SafeBootMode,
                &dwSize
                );
        RegCloseKey( hKey );
    }

    //
    // Load branding images
    //
    LoadBrandingImages(FALSE, &fTextOnLarge, &fTextOnSmall);

    //
    // Create fonts
    //
    CreateFonts(&pGlobals->GinaFonts);

    //
    // Draw localized text on branding images
    //
    PaintBitmapText(&pGlobals->GinaFonts, fTextOnLarge, fTextOnSmall);

    //
    // Initialize consumer windows changes
    //
    _Shell_Initialize(pGlobals);

    //
    // Initialize this global that's used in status.c. We know that WlxInitialize is called
    // on the main thread of winlogon.
    //
    g_dwMainThreadId = GetCurrentThreadId();

    return(TRUE);
}


VOID
WINAPI
WlxDisplaySASNotice(PVOID   pContext)
{
    PGLOBALS pGlobals = (PGLOBALS)pContext;
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof (icce);
    icce.dwICC = ICC_ANIMATE_CLASS;
    InitCommonControlsEx(&icce);

    // Need to register the link window
    LinkWindow_RegisterClass();

    pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                   hDllInstance,
                                   (LPTSTR) IDD_WELCOME_DIALOG,
                                   NULL,
                                   WelcomeDlgProc,
                                   (LPARAM) pContext );
}


PWSTR
AllocAndExpandProfilePath(
        PGLOBALS    pGlobals,
        LPWSTR      lpUserName)
{
    WCHAR szPath[MAX_PATH];
    WCHAR szFullPath[MAX_PATH];
    WCHAR szServerName[UNCLEN+1];
    WCHAR szUserName[100];
    DWORD cFullPath;
    PWSTR pszFullPath;
    DWORD dwPathLen=0;

    //
    // Set up the logon server environment variable:
    //
    dwPathLen = pGlobals->Profile->LogonServer.Length;
        // Truncation would be bad but should never happen (all machine names less
        // UNCLEN chars). But LogonServer.Buffer might not be NULL terminated.
    ASSERT(sizeof(szServerName) >= 2*sizeof(WCHAR) + dwPathLen + sizeof(WCHAR));
    if (sizeof(szServerName) < 2*sizeof(WCHAR) + dwPathLen + sizeof(WCHAR))   // all lengths in bytes
    {
        dwPathLen = sizeof(szServerName) - 3*sizeof(WCHAR); // Won't overflow now
    }
    szServerName[0] = L'\\';
    szServerName[1] = L'\\';
    CopyMemory( &szServerName[2],
                pGlobals->Profile->LogonServer.Buffer,
                dwPathLen );

    szServerName[dwPathLen / sizeof(WCHAR) + 2] = L'\0';

        SetEnvironmentVariable(LOGONSERVER_VARIABLE, szServerName);

    dwPathLen = lstrlen(pGlobals->MuGlobals.TSData.ProfilePath);

    if (!g_Console && (dwPathLen > 0)) {
        //
        // See if the user specified a Terminal Server profile path.
        // If so, we override the regular profile path
        //
        if (dwPathLen < MAX_PATH)
        {
            lstrcpy(szPath, pGlobals->MuGlobals.TSData.ProfilePath);
        }
        else
        {
            lstrcpy(szPath, NULL_STRING);
        }
    } else {

        dwPathLen = pGlobals->Profile->ProfilePath.Length;

        if (dwPathLen == 0)
        {
            return(NULL);
        }

        //
        // Copy the profile path locally
        //
        if (dwPathLen <= (MAX_PATH-1)*sizeof(WCHAR))
        {
            CopyMemory( szPath,
                        pGlobals->Profile->ProfilePath.Buffer,
                        dwPathLen);
            szPath[dwPathLen / sizeof(WCHAR)] = L'\0';
        }
        else
        {
            lstrcpy(szPath, NULL_STRING);
        }
    }

    if (lpUserName && *lpUserName) {
        szUserName[0] = TEXT('\0');
        GetEnvironmentVariableW (USERNAME_VARIABLE, szUserName, 100);
        SetEnvironmentVariableW (USERNAME_VARIABLE, lpUserName);
    }

    //
    // Expand the profile path using current settings:
    //
    cFullPath = ExpandEnvironmentStrings(szPath, szFullPath, MAX_PATH);
    if ((cFullPath) && (cFullPath <= MAX_PATH))
    {
        pszFullPath = LocalAlloc(LMEM_FIXED, cFullPath * sizeof(WCHAR));
        if (pszFullPath)
        {
            CopyMemory( pszFullPath, szFullPath, cFullPath * sizeof(WCHAR));
        }
    }
    else
    {
        pszFullPath = NULL;
    }

    if (lpUserName && *lpUserName) {
        if (szUserName[0] != TEXT('\0'))
            SetEnvironmentVariableW (USERNAME_VARIABLE, szUserName);
        else
            SetEnvironmentVariableW (USERNAME_VARIABLE, NULL);
    }

    return(pszFullPath);
}


PWSTR
AllocPolicyPath(
    PGLOBALS pGlobals)
{
    LPWSTR   pszPath = NULL;

    if (2 * sizeof(WCHAR) + pGlobals->Profile->LogonServer.Length + sizeof(L"\\netlogon\\ntconfig.pol") <= MAX_PATH * sizeof(WCHAR))
    {
        pszPath = LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
        if ( pszPath )
        {
            pszPath[0] = L'\\';
            pszPath[1] = L'\\';
            CopyMemory( &pszPath[2],
                        pGlobals->Profile->LogonServer.Buffer,
                        pGlobals->Profile->LogonServer.Length );

            wcscpy( &pszPath[ pGlobals->Profile->LogonServer.Length / sizeof(WCHAR) + 2],
                    L"\\netlogon\\ntconfig.pol" );
        }
    }

    return(pszPath);
}


PWSTR
AllocNetDefUserProfilePath(
    PGLOBALS pGlobals)
{
    LPWSTR   pszPath = NULL;

    if (2 * sizeof(WCHAR) + pGlobals->Profile->LogonServer.Length + sizeof(L"\\netlogon\\Default User") <= MAX_PATH * sizeof(WCHAR))
    {
        pszPath = LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
        if ( pszPath )
        {
            //
            // Set up the logon server environment variable:
            //

            pszPath[0] = L'\\';
            pszPath[1] = L'\\';
            CopyMemory( &pszPath[2],
                        pGlobals->Profile->LogonServer.Buffer,
                        pGlobals->Profile->LogonServer.Length );

            wcscpy( &pszPath[ pGlobals->Profile->LogonServer.Length / sizeof(WCHAR) + 2],
                    L"\\netlogon\\Default User" );
        }
    }

    return(pszPath);
}


PWSTR
AllocServerName(
    PGLOBALS pGlobals)
{
    LPWSTR   pszPath = NULL;

    if (2 * sizeof(WCHAR) + pGlobals->Profile->LogonServer.Length + 1 <= MAX_PATH * sizeof(WCHAR))
    {
        pszPath = LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));
        if ( pszPath )
        {
            //
            // Set up the logon server environment variable:
            //
            pszPath[0] = L'\\';
            pszPath[1] = L'\\';
            CopyMemory( &pszPath[2],
                        pGlobals->Profile->LogonServer.Buffer,
                        pGlobals->Profile->LogonServer.Length );

            pszPath[pGlobals->Profile->LogonServer.Length / sizeof(WCHAR) + 2] = L'\0';
        }
    }

    return(pszPath);
}


VOID
DetermineDnsDomain(
    PGLOBALS pGlobals
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;

    pGlobals->DnsDomain = NULL;

    if ( ImpersonateLoggedOnUser( pGlobals->UserProcessData.UserToken ) )
    {

        ulUserNameSize = 75;    // Pick a default size. We'll expand if necessary

        lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

        if (!lpUserName)
        {
            dwError = GetLastError();
            if( dwError == ERROR_SUCCESS )
            {
                ASSERT(FALSE && "LocalAlloc failed w/out setting last error");
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            DWORD dwCount = 0;

            while (TRUE)
            {
                if (GetUserNameEx (NameDnsDomain, lpUserName, &ulUserNameSize))
                {
                    dwError = ERROR_SUCCESS;
                    break;
                }
                else
                {
                    dwError = GetLastError();

                    //
                    // If the call failed due to insufficient memory, realloc
                    // the buffer and try again.
                    //

                    if ((dwError == ERROR_INSUFFICIENT_BUFFER) || (dwError == ERROR_MORE_DATA))
                    {
                        LocalFree(lpUserName);
                        lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

                        if (!lpUserName) {
                            dwError = GetLastError();
                            if( dwError == ERROR_SUCCESS )
                            {
                                ASSERT(FALSE && "LocalAlloc failed w/out setting last error");
                                dwError = ERROR_NOT_ENOUGH_MEMORY;
                            }
                            break;      // Can't recover
                        }
                    }
                    else if (dwError == ERROR_NO_SUCH_DOMAIN)
                    {
                        // We just logged on so we know that the domain exists
                        // This is what happens with NT4 domain though since we try
                        // to query the DNS domain name and it doesn't exists
                        // Let's fall back to our old logic
                        break;
                    }
                    else if (dwError == ERROR_NONE_MAPPED)
                    {
                        // That's what's returned for local users.
                        break;
                    }
                    else
                    {
                        dwCount++;

                        if (dwCount > 3)
                        {
                            break;
                        }
                    }
                }
            }
        }

        RevertToSelf();
    }
    else
    {
        dwError = GetLastError();
    }

    if (dwError == ERROR_SUCCESS)
    {
        //
        // At this point lpUserName contains something like domain.company.com\someuser
        // We are only interested in the dns domain name
        lpTemp = lpUserName;

        while (*lpTemp && ((*lpTemp) != TEXT('\\')))
            lpTemp++;


        if (*lpTemp != TEXT('\\'))
        {
            DebugLog((DEB_ERROR, "DetermineDnsDomain: Failed to find slash in DNS style name\n"));
            dwError = ERROR_INVALID_DATA;
        }
        else
        {
            *lpTemp = TEXT('\0');
            pGlobals->DnsDomain = DupString(lpUserName);
        }
    }

    if (dwError != ERROR_SUCCESS)
    {
            //
            // If GetUserNameEx didn't yield a DNS name, fall back on the old code.
            //

        PDOMAIN_CACHE_ENTRY Entry ;

        Entry = DCacheLocateEntry(
                    pGlobals->Cache,
                    pGlobals->FlatDomain.Buffer );

        if ( Entry )
        {
            if ( Entry->Type == DomainNt5 )
            {
                pGlobals->DnsDomain = DupString( Entry->DnsName.Buffer );
            }
            else
            {
                //
                // For all intended purposes, this is good enough.
                // winlogon needs to know for sure for policy (419926)
                //
                pGlobals->DnsDomain = DupString( L"\\NT4" );
            }

            DCacheDereferenceEntry( Entry );
        }
        else
        {
            //
            // winlogon needs to know this as well. errors and not-found
            // were assumed NT5
            //
            pGlobals->DnsDomain = DupString( L"\\XFOREST" );
        }

    }

    if (lpUserName)
    {
        LocalFree(lpUserName);
    }

    //
    // Don't leave with pGlobals->DnsDomain set to NULL
    //
    if ( pGlobals->DnsDomain == NULL)
    {
        pGlobals->DnsDomain = DupString( L"" );
    }
}

PWSTR
AllocVolatileEnvironment(
    PGLOBALS    pGlobals)
{
    BOOL    DeepShare;
    LPWSTR  pszEnv;
    DWORD   dwSize;
    TCHAR   lpHomeShare[MAX_PATH] = TEXT("");
    TCHAR   lpHomePath[MAX_PATH] = TEXT("");
    TCHAR   lpHomeDrive[4] = TEXT("");
    TCHAR   lpHomeDirectory[MAX_PATH] = TEXT("");
    BOOL    TSHomeDir = FALSE;
    PVOID   lpEnvironment = NULL;       // Dummy environment
    BOOL    bUserHasHomedir = TRUE; 


    //
    // Set the home directory environment variables
    // in a dummy environment block
    //

    if ( !g_Console ) {
        // See if the user specified a TerminalServer Home Directory.
        // If so, we override the regular directory
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDir) > 0) {
            ASSERT(sizeof(lpHomeDirectory) >= sizeof(pGlobals->MuGlobals.TSData.HomeDir));
            lstrcpy(lpHomeDirectory, pGlobals->MuGlobals.TSData.HomeDir);
            TSHomeDir = TRUE;
        }
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDirDrive) > 0) {
            ASSERT(sizeof(lpHomeDrive) >= sizeof(pGlobals->MuGlobals.TSData.HomeDirDrive));
            lstrcpy(lpHomeDrive, pGlobals->MuGlobals.TSData.HomeDirDrive);
            TSHomeDir = TRUE;
        }
    }

    if (!TSHomeDir) {
        if (pGlobals->Profile->HomeDirectoryDrive.Length &&
                (pGlobals->Profile->HomeDirectoryDrive.Length + sizeof(TCHAR)) <= sizeof(lpHomeDrive)) {
            memcpy(lpHomeDrive, pGlobals->Profile->HomeDirectoryDrive.Buffer,
                                pGlobals->Profile->HomeDirectoryDrive.Length);
            lpHomeDrive[pGlobals->Profile->HomeDirectoryDrive.Length / sizeof(TCHAR)] = 0;
        }

        if (pGlobals->Profile->HomeDirectory.Length &&
                (pGlobals->Profile->HomeDirectory.Length + sizeof(TCHAR)) <= (MAX_PATH*sizeof(TCHAR))) {
            memcpy(lpHomeDirectory, pGlobals->Profile->HomeDirectory.Buffer,
                                    pGlobals->Profile->HomeDirectory.Length);
            lpHomeDirectory[pGlobals->Profile->HomeDirectory.Length / sizeof(TCHAR)] = 0;
        }
    }

    //
    // Note : we are passing in a null environment because here we are only
    //        interested in parsing the homedirectory and set it in the volatile
    //        environment. We are not interested in setting it in the
    //        environment block here.
    //
    //        Also over here, we are only interested in setting up the
    //        HOMESHARE and HOMEPATH variables in such a way that 
    //        %HOMESHARE%%HOMEPATH% points to the homedir. This is done
    //        so that when folder redirection calls SHGetFolderPath, it will be
    //        able to expand the paths properly. Therefore, at this point
    //        it is not really necessary to pay attention to the
    //        ConnectHomeDirToRoot policy because that policy might get changed
    //        during policy processing anyway and will be picked up when the 
    //        shell starts up. Note: the values of HOMESHARE, HOMEPATH and 
    //        HOMEDRIVE will be updated correctly when the shell starts up
    //
    //        At this point we do not map the home directory for 2 reasons:
    //        (a) We are not aware of the ConnectHomeDirToRoot setting here.
    //        (b) We do not want to do the network mapping twice : once here
    //            and once when the shell starts up. 
    //
    //        Also, we do not want to set the home directory variables in the
    //        volatile environment if it is not specified in the user object.
    //        This prevents us from stomping over logon scripts that might
    //        be setting the homedirectory variables themselves rather than
    //        relying on the values set on the user object.
    //
    if (!lpHomeDirectory[0])
        bUserHasHomedir = FALSE;
    
    if (bUserHasHomedir)
        SetHomeDirectoryEnvVars(&lpEnvironment,
                                lpHomeDirectory,
                                lpHomeDrive,
                                lpHomeShare,
                                lpHomePath,
                                &DeepShare);

    if ( pGlobals->DnsDomain == NULL )
    {
        DetermineDnsDomain( pGlobals );
    }

    dwSize = lstrlen (LOGONSERVER_VARIABLE) + 3
                + lstrlen (pGlobals->Profile->LogonServer.Buffer) + 3;

    if (bUserHasHomedir)
    {
        if (L'\0' == lpHomeShare[0]) 
        {
            // Set the homedrive variable only if the home directory is not
            // a UNC path
            dwSize += lstrlen (HOMEDRIVE_VARIABLE) + 1 + lstrlen (lpHomeDrive) + 3;
        }
        else
        {
            // Set the homeshare variable only if the home directory is a UNC path
            dwSize += lstrlen (HOMESHARE_VARIABLE) + 1 + lstrlen (lpHomeShare) + 3;
        }
        dwSize += lstrlen (HOMEPATH_VARIABLE) + 1 + lstrlen (lpHomePath) + 3;
    }

    if ( pGlobals->DnsDomain )
    {
        dwSize += (lstrlen( USERDNSDOMAIN_VARIABLE ) + 3 +
                   lstrlen( pGlobals->DnsDomain ) + 3 );
    }

    if (g_IsTerminalServer) {
        dwSize += lstrlen (CLIENTNAME_VARIABLE) + 1 + lstrlen (pGlobals->MuGlobals.ClientName) + 3;
    }

    pszEnv = LocalAlloc(LPTR, dwSize * sizeof(WCHAR));
    if ( pszEnv )
    {
        LPWSTR  pszEnvTmp;

        lstrcpy (pszEnv, LOGONSERVER_VARIABLE);
        lstrcat (pszEnv, L"=\\\\");
        lstrcat (pszEnv, pGlobals->Profile->LogonServer.Buffer);

        pszEnvTmp = pszEnv + (lstrlen( pszEnv ) + 1);

        if (bUserHasHomedir)
        {
            if (L'\0' == lpHomeShare[0]) 
            {
                // Set the homedrive variable only if it is not a UNC path
                lstrcpy (pszEnvTmp, HOMEDRIVE_VARIABLE);
                lstrcat (pszEnvTmp, L"=");
                lstrcat (pszEnvTmp, lpHomeDrive);

                pszEnvTmp += (lstrlen(pszEnvTmp) + 1);
            }
            else
            {
                // Set the homeshare variable only if it is a UNC path
                lstrcpy (pszEnvTmp, HOMESHARE_VARIABLE);
                lstrcat (pszEnvTmp, L"=");
                lstrcat (pszEnvTmp, lpHomeShare);

                pszEnvTmp += (lstrlen(pszEnvTmp) + 1);
            }

            // Set the homepath variable
            lstrcpy (pszEnvTmp, HOMEPATH_VARIABLE);
            lstrcat (pszEnvTmp, L"=");
            lstrcat (pszEnvTmp, lpHomePath);

            pszEnvTmp += (lstrlen(pszEnvTmp) + 1);
        }

            // This check doesn't match the check above
            // It is safe though.
        if (( pGlobals->DnsDomain ) && (*(pGlobals->DnsDomain)))
        {
            lstrcpy( pszEnvTmp, USERDNSDOMAIN_VARIABLE );
            lstrcat( pszEnvTmp, L"=" );
            lstrcat( pszEnvTmp, pGlobals->DnsDomain );

            pszEnvTmp += (lstrlen( pszEnvTmp ) + 1 );
        }

        if (g_IsTerminalServer) {
            lstrcpy (pszEnvTmp, CLIENTNAME_VARIABLE);
            lstrcat (pszEnvTmp, L"=");
            lstrcat (pszEnvTmp, pGlobals->MuGlobals.ClientName);

            pszEnvTmp += (lstrlen( pszEnvTmp ) + 1 );
        }

        *pszEnvTmp++ = L'\0';
    }

    return(pszEnv);
}


BOOL
ForceAutoLogon(
    VOID
    )
{
    HKEY hkey;
    BOOL fForceKeySet = FALSE;
    BOOL fHaveAutoLogonCount = FALSE;


    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ, &hkey))
    {
        DWORD dwValue;
        DWORD dwType;
        DWORD dwSize = sizeof (dwValue);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             AUTOLOGONCOUNT_KEY,
                                             NULL,
                                             &dwType,
                                             (LPBYTE) &dwValue,
                                             &dwSize ))
        {
            fHaveAutoLogonCount = TRUE;
        }

        dwSize = sizeof (dwValue);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             FORCEAUTOLOGON_KEY,
                                             NULL,
                                             &dwType,
                                             (LPBYTE) &dwValue,
                                             &dwSize ))
        {
            //
            // Check the value as a REG_SZ since all the other autologon values
            // are stored as REG_SZs.  Check it as a REG_DWORD for back-compat.
            //

            if (dwType == REG_DWORD)
            {
                if (0 != dwValue)
                {
                    fForceKeySet = TRUE;
                }
            }
            else if (dwType == REG_SZ)
            {
                //
                // Reread the value for consistency with the way other
                // autologon values are read/checked.
                //

                if (GetProfileInt(APPLICATION_NAME, FORCEAUTOLOGON_KEY, 0) != 0)
                {
                    fForceKeySet = TRUE;
                }
            }
        }

        RegCloseKey(hkey);
    }

    return (fHaveAutoLogonCount || fForceKeySet);
}


/****************************************************************************\
*
* FUNCTION: CreateFolderAndACLit_Worker
*
* PURPOSE:  Create a home-dir folder for the user, and set the proper security
*           such that only the user and the admin have access to the folder.
*
* PARAMS:   [in ] szPath      the full path, could be UNC or local
*           [in ] pUserSID    user SID
*           [out] pdwErr      error code if anything fails.
*
* RETURNS:  TRUE if all went ok
*           FALSE if a bad home dir path was specified.
*
* HISTORY:
*           TsUserEX ( Alhen's code which was based on EricB's DSPROP_CreateHomeDirectory )
*
*
\****************************************************************************/
#define ACE_COUNT   2
BOOLEAN CreateFolderAndACLit_Worker ( PWCHAR szPath , PSID pUserSID, PDWORD pdwErr , BOOLEAN pathIsLocal )
{
    SECURITY_ATTRIBUTES securityAttributes;
    BOOLEAN             rc;
    PSID                psidAdmins = NULL;

    *pdwErr = 0;
    ZeroMemory( &securityAttributes , sizeof( SECURITY_ATTRIBUTES ) );

    //
    // Apply ACL on the TS Home Dir irrespective of whether its a local or UNC Path
    // Add the ACE for the owner and administrators only
    //

    {
        // build a DACL
        PSID pAceSid[ACE_COUNT];
        
        PACL pDacl;
        
        SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
        SECURITY_DESCRIPTOR securityDescriptor;
        PSECURITY_DESCRIPTOR pSecurityDescriptor = &securityDescriptor;
        int i;
        
        EXPLICIT_ACCESS rgAccessEntry[ACE_COUNT] = {0};
        OBJECTS_AND_SID rgObjectsAndSid[ACE_COUNT] = {0};

        if (!AllocateAndInitializeSid(&NtAuth,
                                                  2,
                                                  SECURITY_BUILTIN_DOMAIN_RID,
                                                  DOMAIN_ALIAS_RID_ADMINS,
                                                  0, 0, 0, 0, 0, 0,
                                                  &psidAdmins  ) )
        {               
            DebugLog(( DEB_ERROR, "AllocateAndInitializeSid failed\n" ));
            *pdwErr = GetLastError( );
            rc=FALSE;
            goto done;
        }

        pAceSid[0] = pUserSID;
        pAceSid[1] = psidAdmins;

        for ( i = 0 ; i < ACE_COUNT; i++)
        {
                rgAccessEntry[i].grfAccessPermissions = GENERIC_ALL;
                rgAccessEntry[i].grfAccessMode = GRANT_ACCESS;
                rgAccessEntry[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

                // build the trustee structs
                //
                BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[i].Trustee),
                                                  &(rgObjectsAndSid[i]),
                                                      NULL,
                                                      NULL,
                                                      pAceSid[i]);
        }

        // add the entries to the ACL
        //
        *pdwErr = SetEntriesInAcl( ACE_COUNT, rgAccessEntry, NULL, &pDacl );

        if( *pdwErr != 0 )
        {
                DebugLog(( DEB_ERROR, "SetEntriesInAcl() failed\n"  ));
                rc = FALSE;
                goto done;
        }

        // build a security descriptor and initialize it
        // in absolute format
        if( !InitializeSecurityDescriptor( pSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) )
        {
            DebugLog(( DEB_ERROR, "InitializeSecurityDescriptor() failed\n" ) );

            *pdwErr = GetLastError( );
            rc=FALSE;
            goto done;
        }

        // add DACL to security descriptor (must be in absolute format)
        
        if( !SetSecurityDescriptorDacl( pSecurityDescriptor,
                                            TRUE, // bDaclPresent
                                            pDacl,
                                            FALSE // bDaclDefaulted
                                                       ) )
        {
            DebugLog(( DEB_ERROR,  "SetSecurityDescriptorDacl() failed\n"  ));

            *pdwErr = GetLastError( );
            rc=FALSE;
            goto done;
        }


        // set the owner of the directory
        if( !SetSecurityDescriptorOwner( pSecurityDescriptor ,
                                             pUserSID ,
                                                 FALSE // bOwnerDefaulted
                                                   ) )
        {
            DebugLog(( DEB_ERROR, "SetSecurityDescriptorOwner() failed\n"  ));
            *pdwErr = GetLastError( );
            rc= FALSE;
            goto done;
        }

        if ( ! IsValidSecurityDescriptor( pSecurityDescriptor ) )
        {
            DebugLog(( DEB_ERROR , "BAD security desc\n") );
        }

        // build a SECURITY_ATTRIBUTES struct as argument for
        // CreateDirectory()
        
        securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);

        securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;

        securityAttributes.bInheritHandle = FALSE;

        if( !CreateDirectory( szPath , &securityAttributes ) )
        {
            *pdwErr = GetLastError( );
            rc = FALSE;
            goto done;
        }       
        else
        {
            rc = TRUE;
        }

    }

done:
    if( psidAdmins != NULL )
    {
        FreeSid( psidAdmins );
    }

    return rc;
}

/****************************************************************************\
*
* FUNCTION: TermServ_CreateHomePathAndACLit
*
* PURPOSE:  create the TS specific user home folder and ACL it such that only
*           user and Admins have access to it.
*
* PARAMS:   PGLOABLS, from which TSData and userSid are used
*
* RETURNS:  TRUE if all went ok
*           FALSE if a bad home dir path was specified.
*
* HISTORY:
*
*
\****************************************************************************/
BOOLEAN TermServ_CreateHomePathAndACLit( PGLOBALS pG )
{
    BOOLEAN     rc;
    DWORD       dwErr = NO_ERROR;
    BOOLEAN     pathIsLocal;
    DWORD       dwFileAttribs;
    WLX_TERMINAL_SERVICES_DATA  *pTSData;

    pTSData =    & pG->MuGlobals.TSData;

    DebugLog((DEB_ERROR, "pTSData->HomeDir = %ws \n", pTSData->HomeDir ));

    if (pTSData->HomeDir[0] == L'\0')
    {
        // no TS specific path, we are done.
        return TRUE;
    }

    // check for empty strings, which means no TS specific path.

    // decide if this is a UNC path to home dir or a local path
    if( pTSData->HomeDir[1] == TEXT( ':' ) && pTSData->HomeDir[2] == TEXT( '\\' ) )
    {
        pathIsLocal = TRUE;   // we have a string starting with something like "D:\"
    }
    else if ( pTSData->HomeDir[0] == TEXT( '\\' ) && pTSData->HomeDir[1] == TEXT( '\\' ) ) 
    {
        pathIsLocal = FALSE;  // we have a string like "\\", which means a UNC path
    }
    else
    {
        // we seem to have a bad path, set it to empty so that  
        // the default paths will be used by userenv's code for settin up
        // stuff
        pTSData->HomeDirDrive[0] = pTSData->HomeDir[0] = TEXT('\0');
        DebugLog((DEB_ERROR, "Bad path for Terminal Services home folder" ));

        return FALSE;
    }

    dwFileAttribs = GetFileAttributes( pTSData->HomeDir );
    
    if (dwFileAttribs == - 1)
    {
        dwErr = GetLastError();
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            // We need to create the home DIR here, userenv does not create home folders.
            rc = CreateFolderAndACLit_Worker(  pTSData->HomeDir , pG->UserProcessData.UserSid , &dwErr , pathIsLocal );
        }
        else
        {
            rc = FALSE;
        }
    }
    else if ( dwFileAttribs & FILE_ATTRIBUTE_DIRECTORY  )
    {
        DebugLog((DEB_WARN , ("Homedir folder already exists\n")));
        rc = TRUE;
    }
    else
    {
        // there is a file there, so we can't create a dir...
        DebugLog((DEB_ERROR , "File with the same name already exists: %s\n", pTSData->HomeDir ));
        rc = FALSE;
    }


    if (!rc)
    {
        DebugLog((DEB_ERROR, "TerminalServerCreatedirWorker() returned error = %d\n",dwErr ));

        // we seem to have a bad path, set it to empty so that  
        // the default paths will be used by userenv's code for settin up
        // stuff
        pTSData->HomeDirDrive[0] = pTSData->HomeDir[0] = TEXT('\0');
    }

    return rc;   
}


int
WINAPI
WlxLoggedOutSAS(
        PVOID                pWlxContext,
        DWORD                dwSasType,
        PLUID                pAuthenticationId,
        PSID                 pLogonSid,
        PDWORD               pdwOptions,
        PHANDLE              phToken,
        PWLX_MPR_NOTIFY_INFO pMprNotifyInfo,
        PVOID *              pProfile
        )
{
    PGLOBALS pGlobals;
    INT_PTR  result = 0;
    PWLX_PROFILE_V2_0 pWlxProfile;
    PUNICODE_STRING FlatUser ;
    PUNICODE_STRING FlatDomain ;
    NTSTATUS Status ;
    DWORD dwNewSasType;

    pGlobals = (PGLOBALS) pWlxContext;
    pGlobals->LogonSid = pLogonSid;

    if (ForceAutoLogon())
    {
        pGlobals->IgnoreAutoAdminLogon = FALSE;
    }
    else
    {
        pGlobals->IgnoreAutoAdminLogon = (*pdwOptions) & WLX_OPTION_IGNORE_AUTO_LOGON;
    }

    // Clear out user process information
    ZeroMemory(&pGlobals->UserProcessData, sizeof(pGlobals->UserProcessData));

    if (dwSasType == WLX_SAS_TYPE_AUTHENTICATED) {

       pGlobals->IgnoreAutoAdminLogon = TRUE;

       result = TSAuthenticatedLogon(pGlobals);

    } else {

        ULONG_PTR ulOption;

        do {

            if (result == MSGINA_DLG_SMARTCARD_INSERTED) {

                dwNewSasType = WLX_SAS_TYPE_SC_INSERT;

            } else {

                dwNewSasType = dwSasType;
            }

                // Make sure we monitor SC events
            ulOption = 1;
            pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_USE_SMART_CARD,
                                     ulOption,
                                     NULL );

            result = Logon(pGlobals, dwNewSasType );          

            if ( result == MSGINA_DLG_SUCCESS )
            {
                if ( (pGlobals->SmartCardOption == 0) || (!pGlobals->SmartCardLogon) )
                {
                        // As no action will be taken on SC removal, we can filter these events
                    ulOption = 0;
                }
                else
                {
                    //
                    // Continue to monitor the s/c device
                    //
                    NOTHING ;
                }
            }
            else
            {
                if (result != MSGINA_DLG_SMARTCARD_INSERTED)
                {
                        // This will force winlogon to forget the last sc event
                    ulOption = 0;
                }
            }
            if (ulOption == 0)
            {
                pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                         WLX_OPTION_USE_SMART_CARD,
                                         0,
                                         NULL );
            }

        } while (result == MSGINA_DLG_SMARTCARD_INSERTED || result == MSGINA_DLG_SMARTCARD_REMOVED);
    }
    if (result == MSGINA_DLG_SUCCESS)
    {
        DebugLog((DEB_TRACE, "Successful Logon of %ws\\%ws\n", pGlobals->Domain, pGlobals->UserName));

        *phToken = pGlobals->UserProcessData.UserToken;
        *pAuthenticationId = pGlobals->LogonId;
        *pdwOptions = 0;

        //
        // Set up the flat/UPN stuff:
        //
        pGlobals->FlatUserName = pGlobals->UserNameString ;
        pGlobals->FlatDomain = pGlobals->DomainString ;

        //
        // Since win2k domains and later support multiple language sets, and map
        // similar names to the same account for accessibility from non-nls
        // systems (e.g., a user account named "User" can be used to log on
        // as both "User" and "U-with-an-umlaut-ser", we need to always do 
        // this lookup to get the "real" name
        //


        if ( ImpersonateLoggedOnUser( pGlobals->UserProcessData.UserToken ) )
        {
            Status = LsaGetUserName( &FlatUser, &FlatDomain );

            if ( NT_SUCCESS( Status ) )
            {
                //
                // Initialize the TS Profile path and Home dir globals. Also get
                // all TS specific user-config data which is used in winlogon
                //
                //For WlxQueryTerminalServicesData() we need NT type names rather than
                //UPN names, if we pass a UPN name it will try to resolve it
                //(through ADS API) to NT name anyway. Besides, ADS API cannot 
                //resolve some UPN names and takes a long time to execute.
                //So let's pass in an NT user and domain names.
                //
                LPWSTR wszFlatUserName, wszFlatDomainName;
                wszFlatUserName = (LPWSTR)LocalAlloc(LPTR,
                    FlatUser->Length+sizeof(WCHAR));
                wszFlatDomainName = (LPWSTR)LocalAlloc(LPTR,
                    FlatDomain->Length+sizeof(WCHAR));

                if(wszFlatUserName && wszFlatDomainName)
                {
                        // Sizes are OK given allocation.
                        // Zero term'ed since LPTR was used.
                    memcpy(wszFlatUserName, FlatUser->Buffer, 
                        FlatUser->Length);

                    memcpy(wszFlatDomainName, FlatDomain->Buffer, 
                        FlatDomain->Length);

                    pWlxFuncs->WlxQueryTerminalServicesData(pGlobals->hGlobalWlx,
                        &pGlobals->MuGlobals.TSData, wszFlatUserName, wszFlatDomainName);
                }
                else
                {
                    pWlxFuncs->WlxQueryTerminalServicesData(pGlobals->hGlobalWlx,
                        &pGlobals->MuGlobals.TSData,pGlobals->UserName , pGlobals->Domain);
                }

                if(wszFlatUserName)
                {
                    LocalFree(wszFlatUserName);
                }
                if(wszFlatDomainName)
                {
                    LocalFree(wszFlatDomainName);
                }

                        
                //
                // if duplication fails revert back to the original string
                //
                if( !DuplicateUnicodeString(&pGlobals->FlatUserName,
                                            FlatUser ) )
                {
                    pGlobals->FlatUserName = pGlobals->UserNameString ;
                }
                if ( !DuplicateUnicodeString(&pGlobals->FlatDomain,
                                           FlatDomain ) )
                {
                    pGlobals->FlatDomain = pGlobals->DomainString ;
                }

                if ( pGlobals->UserName[0] == L'\0' )
                {
                    //
                    // Weird case of UPN/SC, no UPN could be found.  Use
                    // the flat name
                    //
                    dwNewSasType = FlatUser->Length;
                    if (MAX_STRING_BYTES*sizeof(WCHAR) <= dwNewSasType + sizeof(WCHAR))
                    {
                        dwNewSasType = MAX_STRING_BYTES * sizeof(WCHAR) - sizeof(WCHAR);
                    }

                    memcpy( pGlobals->UserName, FlatUser->Buffer, dwNewSasType);
                    pGlobals->UserName[dwNewSasType / sizeof(WCHAR)] = 0;
                    RtlInitUnicodeString( &pGlobals->UserNameString,
                                          pGlobals->UserName );
                }

                LsaFreeMemory( FlatUser->Buffer );
                LsaFreeMemory( FlatUser );
                LsaFreeMemory( FlatDomain->Buffer );
                LsaFreeMemory( FlatDomain );
            }
            else
            {
                pWlxFuncs->WlxQueryTerminalServicesData(pGlobals->hGlobalWlx,
                            &pGlobals->MuGlobals.TSData,pGlobals->UserName , pGlobals->Domain);
            }

            RevertToSelf();
        }

        // TS Specific - Send the credentials used for logging on and smartcard info to TermSrv
        // These credentials are used by TermSrv to send back notification to the client
        // Do this only for remote sessions as this is not relevant for sessions logged on from active console
        if (!IsActiveConsoleSession()) {
            _WinStationUpdateClientCachedCredentials( pGlobals->Domain, pGlobals->UserName, (BOOLEAN) pGlobals->SmartCardLogon );
        }

        DisplayPostShellLogonMessages(pGlobals);
        
        pMprNotifyInfo->pszUserName = DupString( pGlobals->FlatUserName.Buffer );
        pMprNotifyInfo->pszDomain = DupString(pGlobals->FlatDomain.Buffer );

        RevealPassword( &pGlobals->PasswordString );
        pMprNotifyInfo->pszPassword = DupString(pGlobals->Password);
        HidePassword( &pGlobals->Seed, &pGlobals->PasswordString);

        if (pGlobals->OldPasswordPresent)
        {
            RevealPassword( &pGlobals->OldPasswordString );
            pMprNotifyInfo->pszOldPassword = DupString(pGlobals->OldPassword);
            HidePassword( &pGlobals->OldSeed, &pGlobals->OldPasswordString);
        }
        else
        {
            pMprNotifyInfo->pszOldPassword = NULL;
        }

        PostShellPasswordErase(pGlobals);

        if ( !g_Console ) 
        {
            if ( ImpersonateLoggedOnUser( pGlobals->UserProcessData.UserToken ) )
            {
                TermServ_CreateHomePathAndACLit( pGlobals ); 
                RevertToSelf();
            }
        }

        pWlxProfile = (PWLX_PROFILE_V2_0) LocalAlloc(LMEM_FIXED,
                sizeof(WLX_PROFILE_V2_0));
        if (pWlxProfile)
        {
            DWORD  dwSize;
            TCHAR  szComputerName[MAX_COMPUTERNAME_LENGTH+1];
            BOOL   bDomainLogon = TRUE;

            //
            // See if we logged on locally vs domain (vs cached)
            // Optimized logon uses cached logon, but it should be treated
            // as an ordinary domain logon.
            //
            if ((pGlobals->Profile->UserFlags & LOGON_CACHED_ACCOUNT) &&
                (pGlobals->OptimizedLogonStatus != OLS_LogonIsCached)) {
                bDomainLogon = FALSE;
            } else {
                dwSize = MAX_COMPUTERNAME_LENGTH+1;
                if (GetComputerName (szComputerName, &dwSize)) {
                    if (!lstrcmpi (pGlobals->Domain, szComputerName)) {
                        DebugLog((DEB_TRACE, "WlxLoggedOutSAS:  User logged on locally.\n"));
                        bDomainLogon = FALSE;
                    }
                }
            }

            pWlxProfile->dwType = WLX_PROFILE_TYPE_V2_0;
            pWlxProfile->pszProfile = AllocAndExpandProfilePath(pGlobals, pMprNotifyInfo->pszUserName);
            pWlxProfile->pszPolicy = (bDomainLogon ? AllocPolicyPath(pGlobals) : NULL);
            pWlxProfile->pszNetworkDefaultUserProfile =
                         (bDomainLogon ? AllocNetDefUserProfilePath(pGlobals) : NULL);
            pWlxProfile->pszServerName = (bDomainLogon ? AllocServerName(pGlobals) : NULL);
            pWlxProfile->pszEnvironment = AllocVolatileEnvironment(pGlobals);
        }

        *pProfile = (PVOID) pWlxProfile;
        return(WLX_SAS_ACTION_LOGON);
    }
    else if (DLG_SHUTDOWN(result))
    {
        if (result & MSGINA_DLG_REBOOT_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_REBOOT);
        }
        else if (result & MSGINA_DLG_POWEROFF_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_POWER_OFF);
        }
        else if (result & MSGINA_DLG_SLEEP_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_SLEEP);
        }
        else if (result & MSGINA_DLG_SLEEP2_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_SLEEP2);
        }
        else if (result & MSGINA_DLG_HIBERNATE_FLAG)
        {
            return(WLX_SAS_ACTION_SHUTDOWN_HIBERNATE);
        }
        else
            return(WLX_SAS_ACTION_SHUTDOWN);
    }
    else if ( result == MSGINA_DLG_USER_LOGOFF ) {
        return( WLX_SAS_ACTION_LOGOFF );
    }
    else if (result == MSGINA_DLG_SWITCH_CONSOLE)
    {
        return (WLX_SAS_ACTION_SWITCH_CONSOLE);
    }
    else
    {
        if ( pGlobals->RasUsed )
        {
            //
            // Shut down RAS connections on auth failure.
            //

            HangupRasConnections( pGlobals );

        }
        return(WLX_SAS_ACTION_NONE);
    }
}


int
WINAPI
WlxLoggedOnSAS(
    PVOID                   pWlxContext,
    DWORD                   dwSasType,
    PVOID                   pReserved
    )
{
    PGLOBALS            pGlobals;
    INT_PTR             Result;
    DWORD               dwType ;
    DWORD               cbData ;
    DWORD               dwValue ;
    BOOL                OkToLock = TRUE ;
    HKEY                hkeyPolicy ;

    pGlobals = (PGLOBALS) pWlxContext;

    if ( pGlobals->SmartCardOption &&
         dwSasType == WLX_SAS_TYPE_SC_REMOVE &&
         pGlobals->SmartCardLogon )
    {

        if ( pGlobals->SmartCardOption == 1 )
        {
            dwValue = 0;
            cbData = sizeof(dwValue);
            RegQueryValueEx(
                WinlogonKey, DISABLE_LOCK_WKSTA,
                0, &dwType, (LPBYTE)&dwValue, &cbData);

            if (dwValue)
            {
                OkToLock = FALSE ;
            }


            if (OpenHKeyCurrentUser(pGlobals)) {

                if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
                                 WINLOGON_POLICY_KEY,
                                 0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
                {
                     dwValue = 0;
                     cbData = sizeof(dwValue);
                     if ((ERROR_SUCCESS != RegQueryValueEx(hkeyPolicy, DISABLE_LOCK_WKSTA,
                                     0, &dwType, (LPBYTE)&dwValue, &cbData)) ||
                         (dwType != REG_DWORD))
                     {
                         dwValue = 0;
                     }

                     if (dwValue)
                     {
                         OkToLock = FALSE ;
                     }

                     RegCloseKey( hkeyPolicy );
                }

                CloseHKeyCurrentUser(pGlobals);
            }

            if ( OkToLock)
            {
                return WLX_SAS_ACTION_LOCK_WKSTA ;
            }
        }
        else if ( pGlobals->SmartCardOption == 2 )
        {
            if (OpenHKeyCurrentUser(pGlobals)) {

                if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser, EXPLORER_POLICY_KEY,
                                 0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
                {
                     dwValue = 0;
                     cbData = sizeof(dwValue);
                     if ((ERROR_SUCCESS != RegQueryValueEx(hkeyPolicy, NOLOGOFF,
                                     0, &dwType, (LPBYTE)&dwValue, &cbData)) ||
                         (dwType != REG_DWORD))
                     {
                         dwValue = 0;
                     }

                     if (dwValue)
                     {
                         OkToLock = FALSE ;
                     }

                     RegCloseKey( hkeyPolicy );
                }

                CloseHKeyCurrentUser(pGlobals);
            }

            if ( OkToLock)
            {
                return WLX_SAS_ACTION_FORCE_LOGOFF ;
            }
        }

        return WLX_SAS_ACTION_NONE ;
    }
    if ( dwSasType != WLX_SAS_TYPE_CTRL_ALT_DEL ) {

        return( WLX_SAS_ACTION_NONE );
    }

    Result = SecurityOptions(pGlobals);

    DebugLog((DEB_TRACE, "Result from SecurityOptions is %d (%#x)\n", Result, Result));

    switch (Result & ~MSGINA_DLG_FLAG_MASK)
    {
        case MSGINA_DLG_SUCCESS:
        case MSGINA_DLG_FAILURE:
        default:
            return(WLX_SAS_ACTION_NONE);

        case MSGINA_DLG_LOCK_WORKSTATION:
            return(WLX_SAS_ACTION_LOCK_WKSTA);

        case MSGINA_DLG_TASKLIST:
            return(WLX_SAS_ACTION_TASKLIST);

        case MSGINA_DLG_USER_LOGOFF:
            return(WLX_SAS_ACTION_LOGOFF);

        case MSGINA_DLG_FORCE_LOGOFF:
            return(WLX_SAS_ACTION_FORCE_LOGOFF);

        case MSGINA_DLG_SHUTDOWN:
            if (Result & MSGINA_DLG_REBOOT_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_REBOOT);
            }
            else if (Result & MSGINA_DLG_POWEROFF_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_POWER_OFF);
            }
            else if (Result & MSGINA_DLG_SLEEP_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_SLEEP);
            }
            else if (Result & MSGINA_DLG_SLEEP2_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_SLEEP2);
            }
            else if (Result & MSGINA_DLG_HIBERNATE_FLAG)
            {
                return(WLX_SAS_ACTION_SHUTDOWN_HIBERNATE);
            }
            else
                return(WLX_SAS_ACTION_SHUTDOWN);
    }


}

BOOL
WINAPI
WlxIsLockOk(
    PVOID                   pWlxContext
    )
{
    PGLOBALS pGlobals = (PGLOBALS) pWlxContext ;

        // Stop filtering SC events so SC unlock works
    pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_USE_SMART_CARD,
                             1,
                             NULL
                            );

    return(TRUE);
}

BOOL
WINAPI
WlxIsLogoffOk(
    PVOID                   pWlxContext
    )
{
    return(TRUE);
}


VOID
WINAPI
WlxLogoff(
    PVOID                   pWlxContext
    )
{
    PGLOBALS    pGlobals;

    pGlobals = (PGLOBALS) pWlxContext;

    pGlobals->UserName[0] = L'\0';

    pGlobals->UserProcessData.UserToken = NULL;
    if (pGlobals->UserProcessData.RestrictedToken != NULL)
    {
        NtClose(pGlobals->UserProcessData.RestrictedToken);
        pGlobals->UserProcessData.RestrictedToken = NULL;

    }

    if ( pGlobals->FlatUserName.Buffer != pGlobals->UserNameString.Buffer )
    {
        LocalFree( pGlobals->FlatUserName.Buffer );
    }

    if ( pGlobals->FlatDomain.Buffer != pGlobals->DomainString.Buffer )
    {
        LocalFree( pGlobals->FlatDomain.Buffer );
    }

    if (pGlobals->UserProcessData.UserSid != NULL)
    {
        LocalFree(pGlobals->UserProcessData.UserSid);
    }

    if( NULL != pGlobals->UserProcessData.NewThreadTokenSD )
    {
        FreeSecurityDescriptor(pGlobals->UserProcessData.NewThreadTokenSD);
        pGlobals->UserProcessData.NewThreadTokenSD = NULL;
    }

    if (pGlobals->UserProcessData.pEnvironment) {
        VirtualFree(pGlobals->UserProcessData.pEnvironment, 0, MEM_RELEASE);
        pGlobals->UserProcessData.pEnvironment = NULL;
    }

    pGlobals->UserProcessData.Flags = 0 ;

    if ( pGlobals->DnsDomain )
    {
        LocalFree( pGlobals->DnsDomain );

        pGlobals->DnsDomain = NULL ;
    }

    if (pGlobals->Profile)
    {
        LsaFreeReturnBuffer(pGlobals->Profile);
        pGlobals->Profile = NULL;
    }

    //
    // No need to zero/NULL pGlobals->OldPassword since it's hashed
    //

    pGlobals->OldPasswordPresent = 0;

    // reset transfered credentials flag.

    pGlobals->TransderedCredentials = FALSE;


    //
    // Only handle AutoAdminLogon if on the console
    //

    if (!g_Console)
    {
        return;
    }

    if (GetProfileInt( APPLICATION_NAME, TEXT("AutoAdminLogon"), 0))
    {
        //
        // If this is auto admin logon, generate a fake SAS right now.
        //

        pWlxFuncs->WlxSasNotify(pGlobals->hGlobalWlx, WLX_SAS_TYPE_CTRL_ALT_DEL);
    }

    return;
}


VOID
WINAPI
WlxShutdown(
    PVOID                   pWlxContext,
    DWORD                   ShutdownType
    )
{
    //
    // Initialize consumer windows changes
    //
    _Shell_Terminate();
    return;
}

BOOL
WINAPI
WlxScreenSaverNotify(
    PVOID                   pWlxContext,
    BOOL *                  fSecure)
{

    if (*fSecure)
    {       // If it is a secure screen saver,
            // this is equivalent to a lock
        *fSecure = WlxIsLockOk(pWlxContext);
    }

    return( TRUE );
}

BOOL
WINAPI
WlxNetworkProviderLoad(
    PVOID pWlxContext,
    PWLX_MPR_NOTIFY_INFO pMprNotifyInfo
    )
{
    // Obsolete
    return FALSE ;
}

VOID
WINAPI
WlxReconnectNotify(
    PVOID                   pWlxContext)
{
    _Shell_Reconnect();
}

VOID
WINAPI
WlxDisconnectNotify(
    PVOID                   pWlxContext)
{
    _Shell_Disconnect();
}

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorDescription
//
//  Synopsis:   Returns the message from ntdll corresponding to the status
//              code.
//
//  Arguments:  [ErrorCode]       --
//              [Description]     --
//              [DescriptionSize] --
//
//  History:    5-02-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
GetErrorDescription(
    DWORD   ErrorCode,
    LPWSTR  Description,
    DWORD   DescriptionSize
    )
{
    HMODULE Module ;
    //
    // First, try to determine what kind of error code it is:
    //

    //
    // Some people disguise win32 error codes in HRESULTs.  While
    // this is annoying, it can be handled.
    //

    if ( ( ErrorCode & 0xFFFF0000 ) == 0x80070000 )
    {
        ErrorCode = ErrorCode & 0x0000FFFF ;
    }

    if ( (ErrorCode > 0) && (ErrorCode < 0x00010000) )
    {
        //
        // Looks like a winerror:
        //

        Module = GetModuleHandle( TEXT("kernel32.dll") );
    }
    else if ( (0xC0000000 & ErrorCode ) == 0xC0000000 )
    {
        //
        // Looks like an NT status
        //

        Module = GetModuleHandle( TEXT("ntdll.dll" ) );
    }
    else
    {
        Module = GetModuleHandle( TEXT("kernel32.dll" ) );
    }

    return FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
                            FORMAT_MESSAGE_FROM_HMODULE,
                          (LPCVOID) Module,
                          ErrorCode,
                          0,
                          Description,
                          DescriptionSize,
                          NULL );

}




/*=============================================================================
==   Local Procedures Defined
=============================================================================*/

/******************************************************************************
 *
 *  FreeAutoLogonInfo
 *
 *   Free WLX_CLIENT_CREDENTAILS_INFO and data strings returned
 *   from winlogon.
 *
 *  ENTRY:
 *     pGlobals (input)
 *        pointer to GLOBALS struct
 *
 *  EXIT:
 *     nothing
 *
 *****************************************************************************/

VOID
FreeAutoLogonInfo( PGLOBALS pGlobals )
{
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pAutoLogon;

    pAutoLogon = pGlobals->MuGlobals.pAutoLogon;

    if( pAutoLogon == NULL ) {
        return;
    }

    if ( pAutoLogon->pszUserName ) {
        LocalFree( pAutoLogon->pszUserName );
    }
    if ( pAutoLogon->pszDomain ) {
        LocalFree( pAutoLogon->pszDomain );
    }
    if ( pAutoLogon->pszPassword ) {
        ZeroMemory(pAutoLogon->pszPassword, wcslen(pAutoLogon->pszPassword) * sizeof(WCHAR));
        LocalFree( pAutoLogon->pszPassword );
    }

    LocalFree( pAutoLogon );

    pGlobals->MuGlobals.pAutoLogon = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\lockout.c ===
/****************************** Module Header ******************************\
* Module Name: lockout.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implements account lockout support functions.
*
* History:
* 05-27-92 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#pragma hdrstop


#define INDEX_WRAP(i) ((i + LOCKOUT_BAD_LOGON_COUNT) % LOCKOUT_BAD_LOGON_COUNT)

#define TERMSERV_EVENTSOURCE        L"TermService"

// Also defined in icaevent.mc
#define EVENT_EXCEEDED_MAX_LOGON_ATTEMPTS 0x400003F4L


/***************************************************************************\
* FUNCTION: LockoutInitialize
*
* PURPOSE:  Initializes any data used by lockout functions
*
* RETURNS:  TRUE
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
LockoutInitialize(
    PGLOBALS pGlobals
    )
{
    PLOCKOUT_DATA pLockoutData = &pGlobals->LockoutData;

    pLockoutData->ConsecutiveFailedLogons = 0;
    pLockoutData->FailedLogonIndex = 0;

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: LockoutHandleFailedLogon
*
* PURPOSE:  Implements account lockout restrictions if failed logons
*           have exceeded a limit frequency.
*           Account lockout is implemented by imposing an additional delay
*           in a failed logon when the various failed logon conditions are met.
*
* RETURNS:  TRUE
*
* NOTES:    This routine may not return for some time. (typically 30 seconds)
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
LockoutHandleFailedLogon(
    PGLOBALS pGlobals
    )
{
    PLOCKOUT_DATA pLockoutData = &pGlobals->LockoutData;
    ULONG Index = pLockoutData->FailedLogonIndex;

    //
    // Up our bad logon count
    //

    pLockoutData->ConsecutiveFailedLogons ++;

    //
    // See if we have reached our bad logon limit.
    //

    if (pLockoutData->ConsecutiveFailedLogons > LOCKOUT_BAD_LOGON_COUNT) {

        ULONG ElapsedSecondsFirstFailure;
        ULONG ElapsedSecondsNow;
        BOOLEAN Result;

        if ((NtCurrentPeb()->SessionId != 0) && (!IsActiveConsoleSession())) {
           //
           // Forcibly terminate the remote session is we exceed the maximum
           // allowed failed logon attempts
           //

            HANDLE hEventLogSource= RegisterEventSource(NULL,TERMSERV_EVENTSOURCE);
            if (hEventLogSource != NULL)
            {
                PWSTR Strings[ 1 ];
                Strings[0] = pGlobals->MuGlobals.ClientName;

                ReportEvent(hEventLogSource,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            EVENT_EXCEEDED_MAX_LOGON_ATTEMPTS,
                            NULL,
                            1,
                            0,
                            Strings,
                            NULL);

                DeregisterEventSource(hEventLogSource);
            }

            TerminateProcess( GetCurrentProcess(), 0 );
        }

        //
        // Limit the count so we don't have any wrap-round problems
        // (32-bits - that's a lot of failed logons I know)
        //

        pLockoutData->ConsecutiveFailedLogons = LOCKOUT_BAD_LOGON_COUNT + 1;

        //
        // If the first logon in our list occurred too recently, insert
        // the appropriate delay
        //

        Result = RtlTimeToSecondsSince1980(&pLockoutData->FailedLogonTimes[Index],
                                           &ElapsedSecondsFirstFailure);
        ASSERT(Result);

        Result = RtlTimeToSecondsSince1980(&pGlobals->LogonTime,
                                           &ElapsedSecondsNow);
        ASSERT(Result);


        if ((ElapsedSecondsNow - ElapsedSecondsFirstFailure) < LOCKOUT_BAD_LOGON_PERIOD) {

            SetupCursor(TRUE);

            Sleep(LOCKOUT_BAD_LOGON_DELAY * 1000);

            SetupCursor(FALSE);
        }
    }

    //
    // Add this failed logon to the array
    //

    pLockoutData->FailedLogonTimes[Index] = pGlobals->LogonTime;
    pLockoutData->FailedLogonIndex = INDEX_WRAP(pLockoutData->FailedLogonIndex+1);


    return(TRUE);
}


/***************************************************************************\
* FUNCTION: LockoutHandleSuccessfulLogon
*
* PURPOSE:  Resets account lockout statistics since a successful logon occurred.
*
* RETURNS:  TRUE
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
LockoutHandleSuccessfulLogon(
    PGLOBALS pGlobals
    )
{
    //
    // Reset our bad logon count
    //

    pGlobals->LockoutData.ConsecutiveFailedLogons = 0;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\lsa.h ===
/****************************** Module Header ******************************\
* Module Name: lsa.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define utility routines that access the LSA
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//

BOOL
IsMachineDomainMember(
    VOID
    );

BOOL
GetPrimaryDomainEx(
    PUNICODE_STRING PrimaryDomainName,
    PUNICODE_STRING PrimaryDomainDnsName,
    PSID * PrimaryDomainSid OPTIONAL,
    PBOOL SidPresent OPTIONAL
    );

ULONG
GetMaxPasswordAge(
    LPWSTR Domain,
    PULONG MaxAge
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\mslogon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mslogon.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-24-94   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef _MSLOGONH_
#define _MSLOGONH_


INT_PTR
Logon(
    PGLOBALS pGlobals,
    DWORD SasType
    );

DWORD 
GetPasswordExpiryWarningPeriod (
    VOID
    );

BOOL
GetDaysToExpiry (
    IN PLARGE_INTEGER StartTime,
    IN PLARGE_INTEGER ExpiryTime,
    OUT PDWORD DaysToExpiry
    );

BOOL
ShouldPasswordExpiryWarningBeShown(
    PGLOBALS    pGlobals,
    BOOL        LogonCheck,
    PDWORD      pDaysToExpiry
    );

INT_PTR
CheckPasswordExpiry(
    PGLOBALS    pGlobals,
    BOOL        LogonCheck
    );

INT_PTR
DisplayPostShellLogonMessages(
    PGLOBALS    pGlobals
    );

INT_PTR
PostShellPasswordErase(
    PGLOBALS    pGlobals
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\pragma.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    scpragma.h

Abstract:

    This file contains compiler pragmas to disable specific warnings to
    let MSGINA compile at warning level 4

Author:

    Jonathan Schwartz (jschwart)  25-Apr-2000

Environment:

    User Mode -Win32

Revision History:

    25-Apr-2000
        created

--*/

// Unreferenced formal parameter

#pragma warning (disable: 4100)

// Named type definition in parentheses

#pragma warning (disable: 4115)

// Conditional expression is constant

#pragma warning (disable: 4127)

// Nameless struct/union

#pragma warning (disable: 4201)

// Redefined extern to static

#pragma warning (disable: 4211)

// Bit field types other than int

#pragma warning (disable: 4214)

// Address of dllimport is not static

#pragma warning (disable: 4232)

// Cast truncates constant value

#pragma warning (disable: 4310)

// LHS indirection alignment greater than argument alignment

#pragma warning (disable: 4327)

// Pointer indirection alignment greater than argument alignment

#pragma warning (disable: 4328)

// Removal of unused inline functions

#pragma warning (disable: 4514)

// Assignment within conditional expression

#pragma warning (disable: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\ras.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ras.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-09-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include <wchar.h>
#include <wincrypt.h>
#include <sclogon.h>
#include <raserror.h>

#define NP_Nbf      0x1
#define NP_Ipx      0x2
#define NP_Ip       0x4

HANDLE  hRasApi ;

VOID WINAPI
MyRasCallback(
    IN DWORD_PTR  dwCallbackId,
    IN DWORD  dwEventCode,
    IN LPWSTR pszEntry,
    IN LPVOID pEventArgs )

    /* RasPhonebookDlg callback.  'DwCallbackId' is the ID provided in
    ** parameters to RasPhonebookDlg.  'DwEventCode' indicates the
    ** RASPBDEVENT_* event that has occurred.  'PszEntry' is the name of the
    ** entry on which the event occurred.  'PEventArgs' is the event-specific
    ** parameter block passed to us during RasPhonebookDlg callback.
    */
{
    RASNOUSERW* pInfo;
    PGLOBALS    pGlobals;

    DebugLog((DEB_TRACE, "RasCallback: %#x, %#x, %ws, %#x\n",
                dwCallbackId, dwEventCode, pszEntry, pEventArgs ));


    /* Fill in information about the not yet logged on user.
    */
    pInfo = (RASNOUSERW* )pEventArgs;
    pGlobals = (PGLOBALS) dwCallbackId;


    if (dwEventCode == RASPBDEVENT_NoUserEdit)
    {
        if (pInfo->szUserName[0])
        {
            wcscpy( pGlobals->UserName, pInfo->szUserName );
        }

        if (pInfo->szPassword[0])
        {
            wcscpy( pGlobals->Password, pInfo->szPassword );
            RtlInitUnicodeString( &pGlobals->PasswordString, pGlobals->Password );

            pGlobals->Seed = 0;

            HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );
        }

    }
    else if (dwEventCode == RASPBDEVENT_NoUser)
            
    {

        ZeroMemory( pInfo, sizeof( RASNOUSERW ) );

        pInfo->dwTimeoutMs = 2 * 60 * 1000;
        pInfo->dwSize = sizeof( RASNOUSERW );
        wcsncpy( pInfo->szUserName, pGlobals->UserName, UNLEN );
        wcsncpy( pInfo->szDomain, pGlobals->Domain, DNLEN );

        RevealPassword( &pGlobals->PasswordString );
        wcsncpy( pInfo->szPassword, pGlobals->Password, PWLEN );

        HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );
        
    }
    
    if(     pGlobals->SmartCardLogon
        &&  (NULL != pInfo))
    {
        pInfo->dwFlags |= RASNOUSER_SmartCard;
    }
}

DWORD
GetRasDialOutProtocols(
    void )

    /* Returns a bit field containing NP_<protocol> flags for the installed
    ** PPP protocols.  The term "installed" here includes enabling in RAS
    ** Setup.
    */
{

    //
    // Since after the connections checkin, RAS is always installed
    // and there is no way to uninstall it, all we need to check here
    // is if there are protocols installed that can be used by RAS to
    // dial out. By default any protocol installed is available for RAS
    // to dial out on. This can be overridden from the phonebook entry.
    //

    static const TCHAR c_szRegKeyIp[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\Tcpip");

    static const TCHAR c_szRegKeyIpx[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\NwlnkIpx");

    static const TCHAR c_szRegKeyNbf[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\Nbf");

    struct PROTOCOL_INFO
    {
        DWORD dwFlag;
        LPCTSTR pszRegkey;
    };

    static const struct PROTOCOL_INFO c_aProtocolInfo[] =
        {
            {
                NP_Ip,
                c_szRegKeyIp,
            },

            {
                NP_Ipx,
                c_szRegKeyIpx,
            },

            {
                NP_Nbf,
                c_szRegKeyNbf,
            },
        };

    DWORD   dwfInstalledProtocols = 0;
    DWORD   dwNumProtocols = sizeof(c_aProtocolInfo)/sizeof(c_aProtocolInfo[0]);
    DWORD   i;
    HKEY    hkey;


    DebugLog(( DEB_TRACE, "GetRasDialOutProtocols...\n" ));

    for(i = 0; i < dwNumProtocols; i++)
    {
        if(0 == RegOpenKey(HKEY_LOCAL_MACHINE,
                           c_aProtocolInfo[i].pszRegkey,
                           &hkey))
        {
            dwfInstalledProtocols |= c_aProtocolInfo[i].dwFlag;
            RegCloseKey(hkey);
        }
    }

    DebugLog(( DEB_TRACE, "GetRasDialOutProtocols: dwfInstalledProtocols=0x%x\n",
             dwfInstalledProtocols));

    return dwfInstalledProtocols;
}


BOOL
PopupRasPhonebookDlg(
    IN  HWND        hwndOwner,
    IN  PGLOBALS    pGlobals,
    OUT BOOL*       pfTimedOut
    )

    /* Popup the RAS common phonebook dialog to let user establish connection.
    ** 'HwndOwner' is the window to own the RAS dialog or NULL if none.  '*PfTimedOut' is
    ** set TRUE if the dialog timed out, false otherwise.
    **
    ** Returns true if user made a connection, false if not, i.e. an error
    ** occurred, RAS is not installed or user could not or chose not to
    ** connect.
    */
{
    BOOL              fConnected;
    RASPBDLG          info;
    DWORD             Protocols;
    PUCHAR            pvScData = NULL;

    struct EAPINFO
    {
        DWORD dwSizeofEapInfo;
        PBYTE pbEapInfo;
        DWORD dwSizeofPINInfo;
        PBYTE pbPINInfo;
    };

    struct EAPINFO eapinfo;
    struct EAPINFO *pEapInfo = NULL;

    *pfTimedOut = FALSE;

    Protocols = GetRasDialOutProtocols();
    if (Protocols == 0)
    {
        return( FALSE );
    }

    if(pGlobals->SmartCardLogon)
    {
        PULONG pulScData;

        struct FLAT_UNICODE_STRING
        {
            USHORT Length;
            USHORT MaximumLength;
            BYTE   abdata[1];
        };

        struct FLAT_UNICODE_STRING *pFlatUnicodeString;
        PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

        //
        // Get the set of strings indicating the reader and CSP
        // to be used for the smart card. We will pass this info
        // down to RAS.
        //
        pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_SMART_CARD_INFO,
                                 (ULONG_PTR *) &ScInfo);

        if ( !ScInfo )
        {
            return FALSE;
        }

        //
        // Validate the SC info against some common user
        // errors
        //

        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCard == NULL ) )
        {
            //
            // The card could not be read.  Might not be
            // inserted correctly.
            //
            LocalFree(ScInfo);
            return FALSE;
        }

        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCryptoProvider == NULL ) )
        {
            //
            // Got a card, but the CSP for it could not be
            // found.
            //
            LocalFree(ScInfo);
            return FALSE;

        }

        pvScData = ScBuildLogonInfo(ScInfo->pszCard,
                                    ScInfo->pszReader,
                                    ScInfo->pszContainer,
                                    ScInfo->pszCryptoProvider );

        LocalFree(ScInfo);

        if ( ! pvScData )
        {
            return FALSE ;
        }


        pulScData = (PULONG) pvScData;

        ZeroMemory(&eapinfo, sizeof(struct EAPINFO));

        eapinfo.dwSizeofEapInfo = *pulScData;
        eapinfo.pbEapInfo = (BYTE *) pvScData;

        eapinfo.dwSizeofPINInfo = sizeof(UNICODE_STRING) +
                                  (sizeof(TCHAR) *
                                  (1 + lstrlen(pGlobals->PasswordString.Buffer)));

        //
        // Flatten out the unicode string.
        //
        pFlatUnicodeString = LocalAlloc(LPTR, eapinfo.dwSizeofPINInfo);

        if(NULL == pFlatUnicodeString)
        {
            if(NULL != pvScData)
            {
                LocalFree(pvScData);
            }
            return (FALSE);
        }

        pFlatUnicodeString->Length = pGlobals->PasswordString.Length;
        pFlatUnicodeString->MaximumLength = pGlobals->PasswordString.MaximumLength;

        lstrcpy((LPTSTR) pFlatUnicodeString->abdata,
                (LPTSTR) pGlobals->PasswordString.Buffer);


        eapinfo.pbPINInfo = (BYTE *) pFlatUnicodeString;
        pEapInfo = &eapinfo;
    }

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = hwndOwner;
    info.dwFlags = RASPBDFLAG_NoUser;
    info.pCallback = MyRasCallback;
    info.dwCallbackId = (ULONG_PTR) pGlobals;
    info.reserved2 = (ULONG_PTR) pEapInfo;

    fConnected = RasPhonebookDlg( NULL, NULL, &info );
    if (info.dwError == STATUS_TIMEOUT)
        *pfTimedOut = TRUE;

    if(     (pEapInfo)
        &&  (pEapInfo->pbPINInfo))
    {
        LocalFree(pEapInfo->pbPINInfo);
    }

    if(NULL != pvScData)
    {
        LocalFree(pvScData);
    }

    return fConnected;
}


BOOL
IsRASServiceRunning()
{
    BOOL bRet = FALSE;  // assume the service is not running
    SC_HANDLE hServiceMgr;

    hServiceMgr = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hServiceMgr != NULL)
    {
        SC_HANDLE hService = OpenService(hServiceMgr, TEXT("RASMAN"), SERVICE_QUERY_STATUS);

        if (hService != NULL)
        {
            SERVICE_STATUS status;

            if (QueryServiceStatus(hService, &status) &&
                (status.dwCurrentState == SERVICE_RUNNING))
            {
                // the RAS service is running
                bRet = TRUE;
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hServiceMgr);
    }

    return bRet;
}


// we need to treat RAS connections made by the system luid as created by the user.
// this allows us to "do the right thing" when a connection is made from the C-A-D dialog
// before any user is logged in
__inline BOOL IsEqualOrSystemLuid(PLUID pLuid, PLUID pUserLuid)
{
    BOOL bRet = FALSE;
    static LUID luidSystem = SYSTEM_LUID;

    if (RtlEqualLuid(pLuid, pUserLuid) || RtlEqualLuid(pLuid, &luidSystem))
    {
        // return true if pLuid matches the users luid or the system luid 
        bRet = TRUE;
    }

    return bRet;
}


BOOL
HangupRasConnections(
    PGLOBALS    pGlobals
    )
{
    DWORD dwError;
    RASCONN rasconn;
    RASCONN* prc;
    DWORD cbSize;
    DWORD cConnections;
    HLOCAL pBuffToFree = NULL;

    if (!IsRASServiceRunning())
    {
        return TRUE;
    }

    prc = &rasconn;
    prc->dwSize = sizeof(RASCONN);
    cbSize = sizeof(RASCONN);

    dwError = RasEnumConnections(prc, &cbSize, &cConnections);

    if (dwError == ERROR_BUFFER_TOO_SMALL)
    {
        pBuffToFree = LocalAlloc(LPTR, cbSize);

        prc = (RASCONN*)pBuffToFree;
        if (prc)
        {
            prc->dwSize = sizeof(RASCONN);

            dwError = RasEnumConnections(prc, &cbSize, &cConnections);
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        UINT i;

        for (i = 0; i < cConnections; i++)
        {
            if (IsEqualOrSystemLuid(&prc[i].luid, &pGlobals->LogonId))
            {
                RasHangUp(prc[i].hrasconn);
            }
        }
    }

    if (pBuffToFree)
    {
        LocalFree(pBuffToFree);
    }

    return (dwError == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\mslock.c ===
//e+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mslock.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>
#include "shlwapi.h"
#include "shlwapip.h"

#define WM_SMARTCARD_ASYNC_MESSAGE      (WM_USER + 201)
#define WM_SMARTCARD_ERROR_DISPLAY_1    (WM_USER + 202)
#define WM_SMARTCARD_ERROR_DISPLAY_2    (WM_USER + 203)

#define MSGINA_DLG_ASYNC_PROCESSING      122

static UINT ctrlNoDomain[] =
{
    IDOK,
    IDCANCEL,
    IDD_UNLOCK_OPTIONS,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoUserName[] =
{
    IDD_UNLOCK_DOMAIN,
    IDD_UNLOCK_DOMAIN_LABEL,
    IDD_UNLOCK_PASSWORD,
    IDC_UNLOCK_PASSWORD_LABEL,
    IDOK,
    IDCANCEL,
    IDD_UNLOCK_OPTIONS,
    IDD_KBLAYOUT_ICON,
};

//
// Define the structure used to pass data into the lock dialogs
//

typedef enum _LOCKED_STATE_DIALOGS {
    LockedDialog,
    PasswordDialog,
    PINDialog
} LOCKED_STATE_DIALOGS ;

typedef enum _ACTION_TAKEN {
    None,
    SmartCardInserted,
    SmartCardRemoved,
    CancelHit
} ACTION_TAKEN ;

typedef struct {
    PGLOBALS    pGlobals;
    TIME        LockTime;
} LOCK_DATA;
typedef LOCK_DATA *PLOCK_DATA;

typedef struct _UNLOCK_DLG_STATE {
    PGLOBALS        pGlobals ;
    DWORD           dwSasType ;
    ACTION_TAKEN    ActionTaken;
    BOOL            fKillTimer;
    BOOL            fUserBeingPrompted;                    
    BOOL            fCardRemoved;
} UNLOCK_DLG_STATE, * PUNLOCK_DLG_STATE ;

typedef struct _ASYNC_UNLOCK_DATA {
    PGLOBALS            pGlobals;
    HWND                hDlg;
    PUNLOCK_DLG_STATE   pUnlockDlgState;
    UNICODE_STRING      UserName;
    UNICODE_STRING      Domain;
    UNICODE_STRING      Password;
    DWORD               Reserved;
} ASYNC_UNLOCK_DATA, * PASYNC_UNLOCK_DATA;

typedef struct _UNLOCK_MESSAGE {
    NTSTATUS Status ;
    UINT Resource ;
} UNLOCK_MESSAGE, * PUNLOCK_MESSAGE ;

UNLOCK_MESSAGE UnlockMessages[] = {
    { STATUS_LOGON_FAILURE, IDS_UNLOCK_FAILED_BAD_PWD },
    { STATUS_INVALID_LOGON_HOURS, IDS_INVALID_LOGON_HOURS },
    { STATUS_INVALID_WORKSTATION, IDS_INVALID_WORKSTATION },
    { STATUS_ACCOUNT_DISABLED, IDS_ACCOUNT_DISABLED },
    { STATUS_NO_LOGON_SERVERS, IDS_LOGON_NO_DOMAIN },
    { STATUS_LOGON_TYPE_NOT_GRANTED, IDS_LOGON_TYPE_NOT_GRANTED },
    { STATUS_NO_TRUST_LSA_SECRET, IDS_NO_TRUST_LSA_SECRET },
    { STATUS_TRUSTED_DOMAIN_FAILURE, IDS_TRUSTED_DOMAIN_FAILURE },
    { STATUS_TRUSTED_RELATIONSHIP_FAILURE, IDS_TRUSTED_RELATIONSHIP_FAILURE },
    { STATUS_ACCOUNT_EXPIRED, IDS_ACCOUNT_EXPIRED },
    { STATUS_NETLOGON_NOT_STARTED, IDS_NETLOGON_NOT_STARTED },
    { STATUS_ACCOUNT_LOCKED_OUT, IDS_ACCOUNT_LOCKED },
    { STATUS_SMARTCARD_WRONG_PIN, IDS_STATUS_SMARTCARD_WRONG_PIN_UNLOCK },
    { STATUS_SMARTCARD_CARD_BLOCKED, IDS_STATUS_SMARTCARD_CARD_BLOCKED_UNLOCK },
    { STATUS_SMARTCARD_NO_CARD, IDS_STATUS_SMARTCARD_NO_CARD_UNLOCK },
    { STATUS_SMARTCARD_NO_KEY_CONTAINER, IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER_UNLOCK },
    { STATUS_SMARTCARD_NO_CERTIFICATE, IDS_STATUS_SMARTCARD_NO_CERTIFICATE_UNLOCK },
    { STATUS_SMARTCARD_NO_KEYSET, IDS_STATUS_SMARTCARD_NO_KEYSET_UNLOCK },
    { STATUS_SMARTCARD_IO_ERROR, IDS_STATUS_SMARTCARD_IO_ERROR_UNLOCK },
    { STATUS_SMARTCARD_CERT_EXPIRED, IDS_STATUS_SMARTCARD_CERT_EXPIRED_UNLOCK },
    { STATUS_SMARTCARD_CERT_REVOKED, IDS_STATUS_SMARTCARD_CERT_REVOKED_UNLOCK },
    { STATUS_ISSUING_CA_UNTRUSTED, IDS_STATUS_ISSUING_CA_UNTRUSTED_UNLOCK },
    { STATUS_REVOCATION_OFFLINE_C, IDS_STATUS_REVOCATION_OFFLINE_C_UNLOCK },
    { STATUS_PKINIT_CLIENT_FAILURE, IDS_STATUS_PKINIT_CLIENT_FAILURE_UNLOCK },
    { STATUS_SMARTCARD_LOGON_REQUIRED, IDS_STATUS_SMARTCARD_LOGON_REQUIRED_UNLOCK },
    { STATUS_PASSWORD_EXPIRED, IDS_UNLOCK_PWD_CHANGE },
    { STATUS_PASSWORD_MUST_CHANGE, IDS_UNLOCK_PWD_CHANGE }
    };


//
// Private prototypes
//
BOOL LockedDlgInit(HWND, PGLOBALS);
BOOL UnlockDlgInit(HWND, PGLOBALS, DWORD SasType);
INT_PTR AttemptUnlock(HWND, PGLOBALS, PUNLOCK_DLG_STATE);
//INT_PTR CALLBACK LogoffWaitDlgProc(HWND, UINT, WPARAM, LPARAM);
VOID UnlockShowOptions(PGLOBALS pGlobals, HWND hDlg, BOOL fShow);
VOID DisplaySmartCardUnlockErrMessage(PGLOBALS pGlobals, HWND hDlg, DWORD dwErrorType, NTSTATUS Status, INT_PTR *pResult);
BOOL ValidateSC(PGLOBALS pGlobals);

HICON   hLockedIcon = NULL;
HICON   hUnlockIcon = NULL;

// declared in mslogon.c
LRESULT     CALLBACK    DisableEditSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData);
BOOL                    ReplacedPossibleDisplayName (WCHAR *pszUsername, int nUserMax);

void
SetLockedInfo(
    PGLOBALS    pGlobals,
    HWND        hDlg,
    UINT        ControlId)
{
    TCHAR    Buffer1[MAX_STRING_BYTES] = TEXT("");
    TCHAR    Buffer2[MAX_STRING_BYTES] = TEXT("");


    //
    // Set the locked message
    //

    if ( pGlobals->Domain[0] == TEXT('\0') )
    {
        if (lstrlen(pGlobals->UserFullName) == 0) {

            //
            // There is no full name, so don't try to print one out
            //

            LoadString(hDllInstance, IDS_LOCKED_EMAIL_NFN_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->UserName );

        } else {

            LoadString(hDllInstance, IDS_LOCKED_EMAIL_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->UserName, pGlobals->UserFullName);
        }

    }
    else
    {
        if (lstrlen(pGlobals->UserFullName) == 0) {

            //
            // There is no full name, so don't try to print one out
            //

            LoadString(hDllInstance, IDS_LOCKED_NFN_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain, pGlobals->UserName );

        } else {

            LoadString(hDllInstance, IDS_LOCKED_MESSAGE, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain, pGlobals->UserName, pGlobals->UserFullName);
        }
    }

    Buffer2[ sizeof(Buffer2)/sizeof(TCHAR) - 1 ] = 0;
    SetWindowText(GetDlgItem(hDlg, ControlId), Buffer2);

}


/***************************************************************************\
* FUNCTION: LockedDlgProc
*
* PURPOSE:  Processes messages for the workstation locked dialog
*
* RETURNS:
*   DLG_SUCCESS     - the user pressed Ctrl-Alt-Del
*   DLG_LOGOFF()    - the user was asynchronously logged off.
*   DLG_SCREEN_SAVER_TIMEOUT - the screen-saver should be started
*   DLG_FAILURE     - the dialog could not be displayed.
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
CALLBACK
LockedDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    PGLOBALS    pGlobals = (PGLOBALS) GetWindowLongPtr( hDlg, GWLP_USERDATA);

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

            pGlobals = (PGLOBALS) lParam ;

            if (GetDisableCad(pGlobals))
            {
                // Set our size to zero so we we don't appear
                SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE |
                                         SWP_NOREDRAW | SWP_NOZORDER);

                pWlxFuncs->WlxSasNotify( pGlobals->hGlobalWlx,
                                         WLX_SAS_TYPE_CTRL_ALT_DEL );
            }
            else
            {
                if (!LockedDlgInit(hDlg, pGlobals)) {
                    EndDialog(hDlg, DLG_FAILURE);
                }
            }
            return(TRUE);

        case WLX_WM_SAS:
            if ( wParam != WLX_SAS_TYPE_SC_REMOVE && 
                 wParam != WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED && 
                 wParam != WLX_SAS_TYPE_SC_LAST_READER_REMOVED )
            {
                EndDialog(hDlg, MSGINA_DLG_SUCCESS);
            }
            return(TRUE);

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);
    }

    // We didn't process this message
    return FALSE;
}


/***************************************************************************\
* FUNCTION: LockedDlgInit
*
* PURPOSE:  Handles initialization of locked workstation dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

BOOL
LockedDlgInit(
    HWND        hDlg,
    PGLOBALS    pGlobals
    )
{

    ULONG_PTR Value;

    SetWelcomeCaption(hDlg);
    SetLockedInfo(pGlobals, hDlg, IDD_LOCKED_NAME_INFO);
    SetupSystemMenu(hDlg);

    // Size for the branding image we are going to add.
    SizeForBranding(hDlg, FALSE);

    if ( !hLockedIcon )
    {
        hLockedIcon = LoadImage( hDllInstance,
                                 MAKEINTRESOURCE( IDI_LOCKED),
                                 IMAGE_ICON,
                                 0, 0,
                                 LR_DEFAULTCOLOR );
    }

    SendMessage( GetDlgItem(hDlg, IDD_LOCKED_ICON),
                 STM_SETICON,
                 (WPARAM)hLockedIcon,
                 0 );

        // Stop filtering SC events so SC unlock works
    pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_USE_SMART_CARD,
                             1,
                             NULL
                            );

    //
    // is this a smartcard gina?
    //

    pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_SMART_CARD_PRESENT,
                             &Value
                           );

    if ( Value )
    {
        TCHAR szInsertCard[256];
        szInsertCard[0] = 0;

        // Also change unlock message to mention smartcard
        LoadString(hDllInstance, IDS_INSERTCARDORSAS_UNLOCK, szInsertCard, ARRAYSIZE(szInsertCard));

        SetDlgItemText(hDlg, IDD_LOCKED_INSTRUCTIONS, szInsertCard);
    }

    CentreWindow(hDlg);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   WlxDisplayLockedNotice
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pWlxContext] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-16-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


VOID
WINAPI
WlxDisplayLockedNotice(
    PVOID   pWlxContext
    )
{
    PGLOBALS    pGlobals;

    pGlobals = (PGLOBALS) pWlxContext;

    GetSystemTimeAsFileTime( (LPFILETIME) &pGlobals->LockTime);

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LOGON_TIMEOUT);
    pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                   hDllInstance,
                                   (LPWSTR) MAKEINTRESOURCE(IDD_LOCKED_DIALOG),
                                   NULL,
                                   LockedDlgProc,
                                   (LPARAM) pGlobals );

}

BOOL
SmartCardInsterted(
    PGLOBALS    pGlobals)
{
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

    pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_SMART_CARD_INFO,
                             (ULONG_PTR *) &ScInfo );

    if ( ScInfo )
    {       
        LocalFree(ScInfo);
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}



int
WINAPI
WlxWkstaLockedSAS(
    PVOID pWlxContext,
    DWORD dwSasType
    )
{
    PGLOBALS            pGlobals;
    DWORD               Result;
    UNLOCK_DLG_STATE    UnlockDlgState ;
    BOOL                fContinue = FALSE;
    ULONG_PTR ulOption;
    
    LOCKED_STATE_DIALOGS PreviousState; 
    LOCKED_STATE_DIALOGS CurrentState;
    pGlobals = (PGLOBALS) pWlxContext;

    UnlockDlgState.pGlobals    = pGlobals ;
    UnlockDlgState.dwSasType   = dwSasType ;
    UnlockDlgState.ActionTaken = None ;
        
    //
    // Set the previous state based on whether CAD is disabled, and
    // the current SAS type
    //
    if (GetDisableCad(pGlobals))
    {
        PreviousState = PasswordDialog; 

        //
        // If the CAD is disabled, then go directly to the PIN dialog
        //
        if (SmartCardInsterted(pGlobals))
        {
            UnlockDlgState.dwSasType = WLX_SAS_TYPE_SC_INSERT;
            CurrentState = PINDialog;                   
        }
        else
        {
            CurrentState = PasswordDialog;
        }
    }
    else
    {
        PreviousState = LockedDialog;

        //
        // Set the current state based on the SAS we are receiving
        //
        if (dwSasType == WLX_SAS_TYPE_SC_INSERT)
        {
            CurrentState = PINDialog;       
        }
        else
        {
            CurrentState = PasswordDialog;
        }
    }
    
    do
    {
        UnlockDlgState.ActionTaken = None;
        fContinue = FALSE;

            // Make sure we monitor SC events
        ulOption = 1;
        pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_USE_SMART_CARD,
                                 ulOption,
                                 NULL );

        Result = pWlxFuncs->WlxDialogBoxParam(
                                pGlobals->hGlobalWlx,
                                hDllInstance,
                                MAKEINTRESOURCE(IDD_UNLOCK_DIALOG),
                                NULL,
                                UnlockDlgProc,
                                (LPARAM) &UnlockDlgState );
                                    
        //
        // Make a transition based on the current dialog
        // (the one that has just ended)
        //
        switch (CurrentState)
        {
        
        case PasswordDialog:

            //
            // If the password dialog was just being displayed
            // and a smartcard was inserted, then loop back
            // and display the PIN dialog, otherwise, if the
            // password dialog was dismissed for any other reason,
            // then get out.
            //
            if (UnlockDlgState.ActionTaken == SmartCardInserted)
            {
                PreviousState = PasswordDialog;
                CurrentState = PINDialog;
                UnlockDlgState.dwSasType = WLX_SAS_TYPE_SC_INSERT; // go to PIN dlg
                fContinue = TRUE;
            }
            break;

        case PINDialog:

            //
            // If the PIN dialog was just being displayed
            // and a smartcard was removed or cancel was hit, AND
            // the dialog that was displayed before this was the 
            // password dialog, then loop back and display the 
            // password dialog again, otherwise, if the PIN dialog 
            // was dismissed for any other reason, then get out.
            //
            if ((UnlockDlgState.ActionTaken == SmartCardRemoved) ||
                (UnlockDlgState.ActionTaken == CancelHit))
            {
                if (PreviousState == PasswordDialog)
                {
                    CurrentState = PasswordDialog;
                    UnlockDlgState.dwSasType = WLX_SAS_TYPE_CTRL_ALT_DEL; // go to PWD Dlg
                    fContinue = TRUE;     

                        // This will force winlogon to forget the last sc event
                    pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                             WLX_OPTION_USE_SMART_CARD,
                                             0,
                                             NULL );
                }                               
            }
            
            break;
        }
   
    } while (fContinue);   

    if ( Result == MSGINA_DLG_SUCCESS )
    {
        if ( (pGlobals->SmartCardOption == 0) || (!pGlobals->SmartCardLogon) )
        {
                // As no action will be taken on SC removal, we can filter these events
            ulOption = 0;
        }
        else
        {
            //
            // Continue to monitor the s/c device
            //
            NOTHING ;
        }
    }
    else
    {
            // This will force winlogon to forget the last sc event
        ulOption = 0;
    }
    if (ulOption == 0)
    {
        pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_USE_SMART_CARD,
                                 0,
                                 NULL );
    }

    switch (Result)
    {
        case MSGINA_DLG_SUCCESS:

            CheckPasswordExpiry( pGlobals, FALSE );
            return(WLX_SAS_ACTION_UNLOCK_WKSTA);

        case MSGINA_DLG_FAILURE:
        case WLX_DLG_INPUT_TIMEOUT:
        case WLX_DLG_SCREEN_SAVER_TIMEOUT:
            return(WLX_SAS_ACTION_NONE);

        case WLX_DLG_USER_LOGOFF: 
            return(WLX_SAS_ACTION_LOGOFF);

        case MSGINA_DLG_FORCE_LOGOFF:
            return(WLX_SAS_ACTION_FORCE_LOGOFF);

        default:
            DebugLog((DEB_WARN, "Unexpected return code from UnlockDlgProc, %d\n", Result));
            return(WLX_SAS_ACTION_NONE);

    }
}

BOOL
ValidateSC(
    PGLOBALS pGlobals)
{
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

    pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                             WLX_OPTION_SMART_CARD_INFO,
                             (ULONG_PTR *) &ScInfo );

    //
    // Validate the SC info against some common user
    // errors before the PIN dialog appears
    //

    if ( ScInfo )
    {
        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCard == NULL ) )
        {
            //
            // The card could not be read.  Might not be
            // inserted correctly.
            //

            LocalFree(ScInfo);

            TimeoutMessageBox( NULL, pGlobals, IDS_CARD_NOT_RECOGNIZED,
                                    IDS_LOGON_MESSAGE,
                                    MB_OK | MB_ICONEXCLAMATION,
                                    LOGON_TIMEOUT );

            return FALSE;
        }

        if ( ( ScInfo->pszReader ) &&
             ( ScInfo->pszCryptoProvider == NULL ) )
        {
            //
            // Got a card, but the CSP for it could not be
            // found.
            //

            LocalFree(ScInfo);

            TimeoutMessageBox( NULL, pGlobals, IDS_CARD_CSP_NOT_RECOGNIZED,
                                    IDS_LOGON_MESSAGE,
                                    MB_OK | MB_ICONEXCLAMATION,
                                    LOGON_TIMEOUT );

            return FALSE;
        }

        LocalFree(ScInfo);
    }

    return TRUE;

}

/***************************************************************************\
* FUNCTION: UnlockDlgProc
*
* PURPOSE:  Processes messages for the workstation unlock dialog
*
* RETURNS:
*   DLG_SUCCESS     - the user unlocked the workstation successfully.
*   DLG_FAILURE     - the user failed to unlock the workstation.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

static UINT ctrlNoCancel[] =
{
    IDOK,
};

INT_PTR
CALLBACK
UnlockDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PGLOBALS pGlobals = NULL;
    INT_PTR Result;
    PUNLOCK_DLG_STATE pUnlockDlgState;

    pUnlockDlgState = (PUNLOCK_DLG_STATE) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    if (message != WM_INITDIALOG)
    {
        pGlobals = pUnlockDlgState->pGlobals;                  
    }

    switch (message)
    {
        case WM_INITDIALOG:

            pUnlockDlgState = (PUNLOCK_DLG_STATE) lParam ;

            // Screen saver will run if set to expire >= 2 minutes

            pWlxFuncs->WlxSetTimeout(pUnlockDlgState->pGlobals->hGlobalWlx, 
                (GetDisableCad(pUnlockDlgState->pGlobals) ? TIMEOUT_NONE : LOGON_TIMEOUT) );


            // Limit the maximum password length to 127

            SendDlgItemMessage(hDlg, IDD_UNLOCK_PASSWORD, EM_SETLIMITTEXT, (WPARAM) 127, 0);

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (ULONG_PTR) pUnlockDlgState );

            //
            // If this is an sc insert, then make sure the card is inserted correctly.
            //
            if ( pUnlockDlgState->dwSasType == WLX_SAS_TYPE_SC_INSERT )
            {
                if (!ValidateSC( pUnlockDlgState->pGlobals ))
                {
                    EndDialog(hDlg, DLG_FAILURE);                
                }
            }

            if (!UnlockDlgInit(hDlg, pUnlockDlgState->pGlobals, pUnlockDlgState->dwSasType ))
            {
                EndDialog(hDlg, DLG_FAILURE);
            }

            // Disable edits in username / password box
            SetWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_NAME)    , DisableEditSubClassProc, IDD_UNLOCK_NAME    , 0);
            SetWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), DisableEditSubClassProc, IDD_UNLOCK_PASSWORD, 0);


            return(SetPasswordFocus(hDlg));

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDD_UNLOCK_NAME:
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            // Ensure the domain box is enabled/disabled correctly
                            // in case of a UPN name
                            EnableDomainForUPN((HWND) lParam, GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN));
                            return TRUE;
                        default:
                            break;
                    }
                    break;
               case IDCANCEL:

                   pUnlockDlgState->ActionTaken = CancelHit;
                   EndDialog(hDlg, DLG_FAILURE);
                        
                    return TRUE;

                case IDOK:

                    //
                    // Deal with combo-box UI requirements
                    //

                    if (HandleComboBoxOK(hDlg, IDD_UNLOCK_DOMAIN))
                    {
                        return(TRUE);
                    }


                    Result = AttemptUnlock(hDlg, pGlobals, pUnlockDlgState);

                    if (Result != MSGINA_DLG_ASYNC_PROCESSING)
                    {
                        //
                        // If they failed, let them try again, otherwise get out.
                        //
        
                        if (Result != DLG_FAILURE)
                        {
                            EndDialog(hDlg, Result);
                        }
        
                        // Clear the password field
                        SetDlgItemText(hDlg, IDD_UNLOCK_PASSWORD, NULL);
                        SetPasswordFocus(hDlg);   
                    }
                    else
                    {
                        //
                        // Let the async thread do the work, then it will send a 
                        // WM_SMARTCARD_ASYNC_MESSAGE message when it is done.
                        // Meanwhile, disable controls so they don't get mucked with
                        //
                        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDOK), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDCANCEL), FALSE );
                        EnableWindow( GetDlgItem(hDlg, IDC_UNLOCK_PASSWORD_LABEL), FALSE );
                    }
                    
                    return TRUE;

                case IDD_UNLOCK_OPTIONS:
                    UnlockShowOptions(pGlobals, hDlg, !pGlobals->UnlockOptionsShown);
                    return TRUE;
            }
            break;

        case WM_SMARTCARD_ASYNC_MESSAGE:

            switch (wParam)
            {
            case MSGINA_DLG_SUCCESS:

                EndDialog(hDlg, MSGINA_DLG_SUCCESS);
                break;

            case MSGINA_DLG_FORCE_LOGOFF:
                
                EndDialog(hDlg, MSGINA_DLG_FORCE_LOGOFF);
                break;

            case MSGINA_DLG_FAILURE:

                EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), TRUE );
                EnableWindow( GetDlgItem(hDlg, IDOK), TRUE );
                EnableWindow( GetDlgItem(hDlg, IDCANCEL), TRUE );
                EnableWindow( GetDlgItem(hDlg, IDC_UNLOCK_PASSWORD_LABEL), TRUE );

                // Clear the password field
                SetDlgItemText(hDlg, IDD_UNLOCK_PASSWORD, NULL);
                SetPasswordFocus(hDlg);
    
                break;
            }
            
            break;

        case WM_SMARTCARD_ERROR_DISPLAY_1:

            DisplaySmartCardUnlockErrMessage(pGlobals, hDlg, 1, (NTSTATUS) wParam, (INT_PTR *) lParam);            
            return (TRUE);
            break;

        case WM_SMARTCARD_ERROR_DISPLAY_2:

            DisplaySmartCardUnlockErrMessage(pGlobals, hDlg, 2, (NTSTATUS) wParam, (INT_PTR *) lParam);            
            return (TRUE);           
            
            break;

        case WLX_WM_SAS:

            // Ignore it
            if ( wParam == WLX_SAS_TYPE_CTRL_ALT_DEL )
            {
                return( TRUE );
            }

            //
            // If we are in the middle of a smart card unlock then...
            //
            if ( pGlobals->LogonInProgress )
            {
                //
                // SC_REMOVE is really the only interesting SAS, if we get it,
                // kill the dialog.
                //
                if ( wParam == WLX_SAS_TYPE_SC_REMOVE ) 
                {
                    //
                    // If the card removal happened while the user is being 
                    // prompted for a yes/no question, then just note that
                    // we got the removal and deal with it after the questions
                    // is answered.  
                    //
                    // Otherwise, kill the dialog
                    //
                    if ( pUnlockDlgState->fUserBeingPrompted )
                    {
                        pUnlockDlgState->fCardRemoved = TRUE; 
                        ShowWindow(hDlg, SW_HIDE);
                    }
                    else
                    {
                        pUnlockDlgState->ActionTaken = SmartCardRemoved;
                        EndDialog(hDlg, DLG_FAILURE); 
                    }                    
                }
                 
                return( TRUE );
            }

            //
            // If this is an insert and we are in the password state, then
            // go to the PIN state
            //
            if ( ( wParam == WLX_SAS_TYPE_SC_INSERT ) &&
                 ( IsWindowVisible( GetDlgItem( hDlg, IDD_UNLOCK_OPTIONS ) ) == TRUE ) )
            {
                //
                // Check for some common SC problems before ending the dialog and
                // going to the PIN state
                //
                if ( !ValidateSC( pGlobals ) )
                {
                    return( TRUE );
                }

                pUnlockDlgState->ActionTaken = SmartCardInserted;
                EndDialog(hDlg, DLG_FAILURE);  
            }

            //
            // if this is a smart card unlock, if it is removed, kill the dialog.
            //
            if ( ( wParam == WLX_SAS_TYPE_SC_REMOVE ) &&
                 ( IsWindowVisible( GetDlgItem( hDlg, IDD_UNLOCK_OPTIONS ) ) == FALSE ) )
            {
                pUnlockDlgState->ActionTaken = SmartCardRemoved;
                EndDialog(hDlg, DLG_FAILURE);                     
            }
            else if(wParam == WLX_SAS_TYPE_SC_REMOVE)
            {
                // 
                // Already in the password dialog
                //
                return ( TRUE );
            }

            if ( wParam == WLX_SAS_TYPE_AUTHENTICATED ) {
               EndDialog( hDlg, MSGINA_DLG_SUCCESS );
               return TRUE;
            } else if ( wParam == WLX_SAS_TYPE_USER_LOGOFF ) {
               EndDialog( hDlg, MSGINA_DLG_USER_LOGOFF );
               return TRUE;
            }

            return( FALSE );

        case WM_CLOSE:
            break;

        case WM_DESTROY:

            FreeLayoutInfo (LAYOUT_CUR_USER);

            if ( pGlobals->ActiveArray )
            {
                DCacheFreeArray( pGlobals->ActiveArray );
                pGlobals->ActiveArray = NULL ;
            }

            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_NAME),     DisableEditSubClassProc, IDD_UNLOCK_NAME);
            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), DisableEditSubClassProc, IDD_UNLOCK_PASSWORD);

            break;

    case WM_TIMER:

            if ( wParam == 0 )
            {
                HDC hDC;

                RtlEnterCriticalSection(&pGlobals->csGlobals);

                if ( pGlobals->LogonInProgress )
                {
                    if (pGlobals->cxBand != 0)
                    {
                        pGlobals->xBandOffset = (pGlobals->xBandOffset+5) % pGlobals->cxBand;
                    }
                }
                
                if ( !pGlobals->LogonInProgress || pUnlockDlgState->fKillTimer )
                {
                
                    pGlobals->xBandOffset = 0;
                    KillTimer(hDlg, 0);

                    //
                    // Reset timeout to normal
                    //
                    pWlxFuncs->WlxSetTimeout(
                                    pGlobals->hGlobalWlx,
                                    (GetDisableCad(pGlobals) ? TIMEOUT_NONE : LOGON_TIMEOUT));

                }

                RtlLeaveCriticalSection(&pGlobals->csGlobals);

                hDC = GetDC(hDlg);
                if ( hDC )
                {
                    PaintBranding( hDlg, hDC, pGlobals->xBandOffset, TRUE, FALSE, COLOR_BTNFACE );
                    ReleaseDC( hDlg, hDC );
                }

                return FALSE;
            }
            else if ( wParam == TIMER_MYLANGUAGECHECK )
            {
                LayoutCheckHandler(hDlg, LAYOUT_CUR_USER);
            }

            break;
    }

    // We didn't process the message
    return(FALSE);
}


/***************************************************************************\
* FUNCTION: UnlockDlgInit
*
* PURPOSE:  Handles initialization of security options dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

static UINT ctrlNoOptions[] =
{
    IDOK,
    IDCANCEL,
    IDD_KBLAYOUT_ICON,
};

BOOL
UnlockDlgInit(
    HWND        hDlg,
    PGLOBALS    pGlobals,
    DWORD       SasType
    )
{
    RECT rc, rc2;
    WCHAR Label[ MAX_PATH ];

    int err ;
    DWORD dwSize ;
    DWORD dwType ;
    DWORD dwValue ;

    dwSize = sizeof( DWORD );
    dwValue = 0 ;

    err = RegQueryValueEx( WinlogonKey,
                           FORCE_UNLOCK_LOGON,
                           0,
                           &dwType,
                           (PBYTE) &dwValue,
                           &dwSize );

    if ( err || ( dwType != REG_DWORD ) )
    {
        dwValue = 0 ;
    }

    if ( dwValue )
    {
        pGlobals->UnlockBehavior |= UNLOCK_FORCE_AUTHENTICATION ;
    }
    else
    {
        pGlobals->UnlockBehavior &= ~(UNLOCK_FORCE_AUTHENTICATION );
    }

    SetWelcomeCaption( hDlg );

    SetLockedInfo( pGlobals, hDlg, IDD_UNLOCK_NAME_INFO );

    if ( !hLockedIcon )
    {
        hLockedIcon = LoadImage( hDllInstance,
                                 MAKEINTRESOURCE( IDI_LOCKED),
                                 IMAGE_ICON,
                                 0, 0,
                                 LR_DEFAULTCOLOR );
    }

    SendMessage( GetDlgItem( hDlg, IDD_UNLOCK_ICON),
                 STM_SETICON,
                 (WPARAM)hLockedIcon,
                 0 );

    DisplayLanguageIcon (hDlg, LAYOUT_CUR_USER, GetKeyboardLayout(0));

    // Size for the branding image we are going to add.
    SizeForBranding(hDlg, FALSE);

    pGlobals->xBandOffset = 0;

    //
    // Fill in the username
    //

    if ( SasType == WLX_SAS_TYPE_SC_INSERT )
    {
        //
        // No username, hide the field and move other controls up
        //
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_MESSAGE), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc2);

        MoveControls(hDlg, ctrlNoUserName,
                     sizeof(ctrlNoUserName)/sizeof(ctrlNoUserName[0]),
                     0, -(rc2.top-rc.top),
                     TRUE);

        // Hide the unnecessary text for SC insert
        ShowDlgItem( hDlg, IDD_UNLOCK_MESSAGE, FALSE);
        ShowDlgItem( hDlg, IDD_UNLOCK_NAME_INFO, FALSE);

        // Also remove the unlock icon; when the dialog gets this small, there
        // isn't room for this guy and the kblayout icon.
        ShowDlgItem( hDlg, IDD_UNLOCK_ICON, FALSE);


        ShowDlgItem( hDlg, IDD_UNLOCK_NAME, FALSE );
        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_NAME), FALSE );
        ShowDlgItem( hDlg, IDC_UNLOCK_NAME_LABEL, FALSE );

        // Disable and hide domain
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN, FALSE );
        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), FALSE);
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN_LABEL, FALSE);

        LoadString(hDllInstance, IDS_PIN, Label, MAX_PATH);
        SetDlgItemText( hDlg, IDC_UNLOCK_PASSWORD_LABEL, Label );

        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), &rc2);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);

        pGlobals->ShowDomainBox = FALSE;

        //
        // The options button is useless, remove it
        //

        GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_OPTIONS), &rc2);

        MoveControls(hDlg, ctrlNoOptions,
                     sizeof(ctrlNoOptions)/sizeof(ctrlNoOptions[0]),
                     rc2.right-rc.right, 0,
                     FALSE);

        ShowDlgItem(hDlg, IDD_UNLOCK_OPTIONS, FALSE);
    }
    else if (ForceNoDomainUI())
    {
        // Populate username
        SetDlgItemText(hDlg, IDD_UNLOCK_NAME, pGlobals->UserName);

        // Disable and hide domain
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN, FALSE );
        EnableWindow( GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), FALSE);
        ShowDlgItem( hDlg, IDD_UNLOCK_DOMAIN_LABEL, FALSE);

        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), &rc2);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);

        pGlobals->ShowDomainBox = FALSE;
    }
    else
    {
        SetDlgItemText(hDlg, IDD_UNLOCK_NAME, pGlobals->UserName);

        pGlobals->ShowDomainBox = TRUE;
    }

    //
    // Get trusted domain list and select appropriate domain
    //

    if ( !DCacheValidateCache( pGlobals->Cache ) )
    {
        ASSERT( pGlobals->ActiveArray == NULL );

        DCacheUpdateMinimal( pGlobals->Cache, 
                             pGlobals->Domain, 
                             TRUE );

    }

    pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

    if ( pGlobals->ActiveArray )
    {
        DCachePopulateListBoxFromArray( pGlobals->ActiveArray,
                                        GetDlgItem( hDlg, IDD_UNLOCK_DOMAIN ),
                                        pGlobals->Domain );
    }
    else 
    {
        EndDialog( hDlg, MSGINA_DLG_FAILURE );
    }

#if 0
    //
    // Ensure that the domain the user logged on with is always in the
    // combo-box so even if the Lsa is in a bad way the user will always
    // be able to unlock the workstation. Don't do this if the user is logged
    // in locally or else we'll get TWO local machines in the list
    //

    cchComputer = ARRAYSIZE(szComputer);
    szComputer[0] = 0;
    GetComputerName(szComputer, &cchComputer);

    if ( pGlobals->Domain[0] && (0 != lstrcmpi(szComputer, pGlobals->Domain)))
    {
        HWND hwndDomain = GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN);
        if (SendMessage(hwndDomain, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pGlobals->Domain) == CB_ERR)
        {
            DebugLog((DEB_ERROR, "Domain combo-box doesn't contain logged on domain, adding it manually for unlock\n"));
            SendMessage(hwndDomain, CB_ADDSTRING, 0, (LPARAM)pGlobals->Domain);
        }
    }
#endif 

    //
    // If we are not part fo the domain then lets rip out the domain field,
    // and if we do that lets remove the options button.
    //

    if ( !IsMachineDomainMember() )
    {
        //
        // If we're not part of a domain, make sure to hide the domain field
        //

        GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_OPTIONS), &rc2);

        MoveControls(hDlg, ctrlNoOptions,
                     sizeof(ctrlNoOptions)/sizeof(ctrlNoOptions[0]),
                     rc2.right-rc.right, 0,
                     FALSE);

        ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN_LABEL, FALSE);
        ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN, FALSE);
        ShowDlgItem(hDlg, IDD_UNLOCK_OPTIONS, FALSE);
    }

    // remove the cancel button if no C-A-D required
    // NOTE: if we are going to the PIN dialog we always need a cancel button
    if ((GetDisableCad(pGlobals)) && (SasType != WLX_SAS_TYPE_SC_INSERT))
        EnableDlgItem(hDlg, IDCANCEL, FALSE);

    // Position window on screen
    CentreWindow(hDlg);

    // Hide the options pane
    pGlobals->UnlockOptionsShown = TRUE;
    UnlockShowOptions(pGlobals, hDlg, FALSE);

    return TRUE;
}

VOID
DisplaySmartCardUnlockErrMessage(
    PGLOBALS pGlobals,
    HWND hDlg,
    DWORD dwErrorType,
    NTSTATUS Status,
    INT_PTR *pResult)
{
    int     i;
    UINT    Resource = 0;
    TCHAR   Buffer1[MAX_STRING_BYTES] = TEXT("");
    TCHAR   Buffer2[MAX_STRING_BYTES] = TEXT("");
    BOOL    fStringFound = FALSE;

    if ( dwErrorType == 1 )
    {
        *pResult = DisplayForceLogoffWarning(hDlg,
                                   pGlobals,
                                   MB_OKCANCEL | MB_ICONEXCLAMATION | MB_DEFBUTTON2,
                                   TIMEOUT_CURRENT);

        return;         
    }
   
    //
    // At this point we need to display an error message, and the just
    // relinquish control back to the unlock dialog thread
    //
    
    for ( i = 0 ;
          i < sizeof( UnlockMessages ) / sizeof( UNLOCK_MESSAGE ) ;
          i++ )
    {
        if ( UnlockMessages[i].Status == Status )
        {
            if (Status == STATUS_LOGON_FAILURE)
            {
                Resource = IDS_UNLOCK_FAILED_BAD_PIN ;   
            }
            else
            {
                Resource = UnlockMessages[i].Resource ;
            }
            
            break;
        }
    }

    if ( Resource != 0 )
    {
        if( Resource == IDS_LOGON_NO_DOMAIN )
        {
            // Need to build the domain name into the string.
            LoadString(hDllInstance, Resource, Buffer1, MAX_STRING_BYTES);
            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain);
        }
        else
        {
            LoadString(hDllInstance, Resource, Buffer2, MAX_STRING_BYTES);
        }

        fStringFound = TRUE;  
    }   

    if ( !fStringFound )
    {            
        //
        // They're not the logged on user and they're not an admin.
        // Tell them they failed to unlock the workstation.
        //

        if ( lstrlen(pGlobals->UserFullName) == 0 ) 
        {
            if ( pGlobals->Domain[0] == L'\0' )
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL_NFN, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName
                                                         );

            }
            else
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_NFN, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName
                                                             );
            }

        } 
        else 
        {
            if ( pGlobals->Domain[0] == L'\0' )
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName,
                                                         pGlobals->UserFullName
                                                         );

            }
            else
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName,
                                                             pGlobals->UserFullName
                                                             );
            }
        }
    }

        // Covers all _snwprintf(Buffer2 in this function
    Buffer2[ sizeof(Buffer2)/sizeof(TCHAR) - 1 ] = 0;

    Buffer1[0] = 0;
    LoadString(hDllInstance, IDS_WORKSTATION_LOCKED, Buffer1, MAX_STRING_BYTES);

    *pResult = TimeoutMessageBoxlpstr(
                        hDlg,
                        pGlobals,
                        Buffer2,
                        Buffer1,
                        MB_OK | MB_ICONSTOP,
                        TIMEOUT_CURRENT);
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardUnlockLogonThread
//
//  Synopsis:   Does the logon call in an async thread so that a pulsing bar
//              can be shown in the UI.
//
//  Arguments:  [pData] --
//
//  History:    
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SmartCardUnlockLogonThread(
    PASYNC_UNLOCK_DATA  pData)
{
    INT_PTR     Result;
    BOOL        IsLoggedOnUser;
    BOOL        IsAdmin;
    NTSTATUS    Status;
    BOOL        Unlocked;
    PGLOBALS    pGlobals = pData->pGlobals;
    
    //
    // Kick off the call to the LSA
    //
    Unlocked = UnlockLogon(
                    pData->pGlobals,
                    TRUE,
                    pData->UserName.Buffer,
                    pData->Domain.Buffer,
                    &pData->Password,
                    &Status,
                    &IsAdmin,
                    &IsLoggedOnUser,
                    NULL,
                    NULL );

    //
    // Logon thread is done running, so stop showing the pulsing bar
    //
    pData->pUnlockDlgState->fKillTimer = TRUE;

    //
    // Get rid of the PIN
    //
    RtlZeroMemory( pData->Password.Buffer, pData->Password.Length );
    
    if ( Unlocked && IsLoggedOnUser )
    {
        pGlobals->SmartCardLogon = TRUE;  

        //
        // Logon succeeded, so tell the main thread that
        //
        PostMessage( pData->hDlg, WM_SMARTCARD_ASYNC_MESSAGE, MSGINA_DLG_SUCCESS, 0 );

        goto Return;
    }
    else if ( Unlocked && IsAdmin)
    {
        //
        // This is an admin trying to logon over another user, so send a message to the
        // main dialog so it can ask the user if they would like to continue
        //
        pData->pUnlockDlgState->fUserBeingPrompted = TRUE;                                           
        SendMessage( pData->hDlg, WM_SMARTCARD_ERROR_DISPLAY_1, Status, (LPARAM) &Result );
                
        //
        // If the smart card was removed while the user was being prompted, and
        // the user elected not to logoff the current user, then just go back
        // to the locked dialog
        //
        if ( (pData->pUnlockDlgState->fCardRemoved) && (Result != MSGINA_DLG_SUCCESS) )
        {
            //
            // Simulate the "card removed" SAS
            //
            pGlobals->LogonInProgress = FALSE;
            PostMessage( pData->hDlg, WLX_WM_SAS, WLX_SAS_TYPE_SC_REMOVE, (LPARAM) NULL );
        }
        else
        {
            //
            // Post the result of the prompt back to the main thread and then get out of this thread
            //
            PostMessage(
                    pData->hDlg, 
                    WM_SMARTCARD_ASYNC_MESSAGE, 
                    (Result == MSGINA_DLG_SUCCESS) ? MSGINA_DLG_FORCE_LOGOFF : MSGINA_DLG_FAILURE, 
                    Result );
        }
        

        goto Return;         
    }
   
    //
    // At this point an error occurred, so ask the main thread to display an error message, 
    //
    SendMessage( pData->hDlg, WM_SMARTCARD_ERROR_DISPLAY_2, Status, (LPARAM) &Result );
    
    if (DLG_INTERRUPTED(Result)) 
    {
        Result = SetInterruptFlag( MSGINA_DLG_FAILURE ) ;
    }

    //
    // Let the main thread know that this thread is exiting
    //
    PostMessage( pData->hDlg, WM_SMARTCARD_ASYNC_MESSAGE, MSGINA_DLG_FAILURE, Result );

Return:

    pGlobals->LogonInProgress = FALSE;

    LocalFree( pData );

    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   UnlockLogonThread
//
//  Synopsis:   Does the logon call in an async thread so that the user
//              unlock is faster.
//
//  Arguments:  [pData] --
//
//  History:    7-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
UnlockLogonThread(
    PASYNC_UNLOCK_DATA  pData)
{
    BOOL Ignored ;
    NTSTATUS Status ;
    //
    // Give everything a moment to switch back, restart, etc.
    //

    Sleep( 500 );

    //
    // Kick off the call to the LSA
    //

    if( !UnlockLogon(
        pData->pGlobals,
        FALSE,
        pData->UserName.Buffer,
        pData->Domain.Buffer,
        &pData->Password,
        &Status,
        &Ignored,
        &Ignored,
        NULL,
        NULL ) )
    {
        //
        // audit this event as the above call will generate
        // an audit failure and we have already unlocked the workstation
        //
        GenerateCachedUnlockAudit(
            pData->pGlobals->UserProcessData.UserSid,
            pData->UserName.Buffer,
            pData->Domain.Buffer);
    }
            

    //
    // Get rid of the password, then free the parameters
    //

    RtlZeroMemory( pData->Password.Buffer, pData->Password.Length );

    LocalFree( pData );

    return( 0 );

}

//+---------------------------------------------------------------------------
//
//  Function:   UnlockLogonAsync
//
//  Synopsis:   Sets up the async thread so that
//
//  Effects:
//
//  Arguments:  [pGlobals]       --
//              [UserName]       --
//              [Domain]         --
//              [PasswordString] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    7-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


BOOL
UnlockLogonAsync(
    IN PGLOBALS pGlobals,
    IN PUNLOCK_DLG_STATE pUnlockDlgState,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString,
    IN HWND hDlg,
    IN BOOL SmartCardUnlock
    )
{
    DWORD   UserLength;
    DWORD   DomainLength;
    PASYNC_UNLOCK_DATA  pData;
    HANDLE  Thread;
    DWORD   Tid;


    UserLength = (DWORD) wcslen( UserName ) * sizeof(WCHAR);
    DomainLength = (DWORD) wcslen( Domain ) * sizeof(WCHAR);

    pData = LocalAlloc( LMEM_FIXED, sizeof( ASYNC_UNLOCK_DATA ) +
                                UserLength + DomainLength +
                                PasswordString->Length + 3 * sizeof(WCHAR) );

    if ( !pData )
    {
        return FALSE;
    }

    pData->pGlobals = pGlobals;
    pData->hDlg = hDlg;
    pData->pUnlockDlgState = pUnlockDlgState;
    pData->UserName.Length = (WORD)UserLength;
    pData->UserName.MaximumLength = (WORD)(UserLength + sizeof(WCHAR));
    pData->UserName.Buffer = (PWSTR) (pData + 1);
    CopyMemory( pData->UserName.Buffer, UserName, UserLength + sizeof(WCHAR) );

    pData->Domain.Length = (WORD)DomainLength;
    pData->Domain.MaximumLength = (WORD)(DomainLength + sizeof(WCHAR));
    pData->Domain.Buffer = pData->UserName.Buffer + (UserLength / 2) + 1;
    CopyMemory( pData->Domain.Buffer, Domain, DomainLength + sizeof(WCHAR) );

    pData->Password.Length = PasswordString->Length;
    pData->Password.MaximumLength = PasswordString->Length + sizeof(WCHAR) ;
    pData->Password.Buffer = pData->Domain.Buffer + (DomainLength / 2) + 1;
    CopyMemory( pData->Password.Buffer,
                PasswordString->Buffer,
                PasswordString->Length + 2);


    Thread = CreateThread(  NULL, 
                            0,
                            SmartCardUnlock ? SmartCardUnlockLogonThread: UnlockLogonThread, 
                            pData,
                            0, 
                            &Tid );

    if ( Thread )
    {
        CloseHandle( Thread );

    }
    else
    {
        ZeroMemory( pData->Password.Buffer, pData->Password.Length );

        LocalFree( pData );

        return ( FALSE );
    }

    return ( TRUE );
}



/***************************************************************************\
* FUNCTION: AttemptUnlock
*
* PURPOSE:  Tries to unlock the workstation using the current values in the
*           unlock dialog controls
*
* RETURNS:
*   DLG_SUCCESS     - the user unlocked the workstation successfully.
*   DLG_FAILURE     - the user failed to unlock the workstation.
*   DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
AttemptUnlock(
    HWND                hDlg,
    PGLOBALS            pGlobals,
    PUNLOCK_DLG_STATE   pUnlockDlgState)
{
    TCHAR    UserName[MAX_STRING_BYTES];
    TCHAR    Domain[MAX_STRING_BYTES];
    TCHAR    Password[MAX_STRING_BYTES];
    UCHAR   PasswordHash[ PASSWORD_HASH_SIZE ];
    BOOL    Unlocked;
    BOOL    DifferentAccount;
    INT_PTR Result;
    UNICODE_STRING PasswordString;
    TCHAR    Buffer1[MAX_STRING_BYTES];
    TCHAR    Buffer2[MAX_STRING_BYTES];
    DWORD    StringSize;
    BOOL    SmartCardUnlock ;
    BOOL    IsAdmin = FALSE;
    BOOL    IsLoggedOnUser ;
    BOOL    AlreadyLogged ;
    BOOL    NewPassword ;
    NTSTATUS Status = STATUS_SUCCESS ;
    HWND hwndDomain = GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN);
    INT iDomainSelection;
    PDOMAIN_CACHE_ENTRY Entry ;
    BOOL PasswordExpiryWarning;
    PVOID ProfileBuffer;
    ULONG ProfileBufferLength;
    BOOL fStringFound = FALSE;
    RECT    rc;
    DWORD   dwAnimationTimeSlice;

    UserName[0] = TEXT('\0');
    Domain[0] = TEXT('\0');
    Password[0] = TEXT('\0');
    Buffer1[0] = TEXT('\0');
    Buffer2[0] = TEXT('\0');

    //
    // We need to do some things differently when a smart card is used.  The way to
    // tell is find out if the username field is active.
    //

    AlreadyLogged = FALSE ;
    NewPassword = FALSE ;
    Unlocked = FALSE;

    if ( !IsWindowEnabled( GetDlgItem( hDlg, IDD_UNLOCK_NAME ) ) )
    {
        SmartCardUnlock = TRUE ;

        DifferentAccount = TRUE ;
    }
    else
    {
        SmartCardUnlock = FALSE ;

        //
        // Force smart card unlock for normal boot
        //
        if( (SafeBootMode != SAFEBOOT_MINIMAL) && (SafeBootMode != SAFEBOOT_DSREPAIR) &&
             GetSCForceOption() )
        {
            LoadString(hDllInstance,
                       IDS_UNLOCK_SC_REQUIRED,
                       Buffer2, MAX_STRING_BYTES);
            goto FastErrorExit;
        }

        StringSize = GetDlgItemText(hDlg, IDD_UNLOCK_NAME, UserName, MAX_STRING_BYTES);
        if (StringSize == MAX_STRING_BYTES)
        {
            UserName[MAX_STRING_BYTES-1] = TEXT('\0');
        }

        //
        // check to see if this is the fancy "my computer" entry or the somewhat less fancy
        // "use the UPN" entry
        //

        iDomainSelection = (INT)SendMessage(hwndDomain, CB_GETCURSEL, 0, 0);
        Entry = (PDOMAIN_CACHE_ENTRY) SendMessage(hwndDomain, CB_GETITEMDATA, (WPARAM)iDomainSelection, 0);

        if ( Entry == (PDOMAIN_CACHE_ENTRY) CB_ERR )
        {
            //
            // Our list is hosed in some way.
            //

            GetDlgItemText( hDlg, IDD_UNLOCK_DOMAIN, Domain, MAX_STRING_BYTES );
        }
        else 
        {
                // MAX_STRING_BYTES is the size of pGlobals->Domain (WlxInitialize)
                // Truncation should never occur
            lstrcpyn( Domain, Entry->FlatName.Buffer, MAX_STRING_BYTES );
        }

        // If we are forcing a NoDomainUI, populate the domain with the local machine name now
        if (ForceNoDomainUI())
        {
            DWORD chSize = ARRAYSIZE(Domain);
            
            if (!GetComputerName(Domain, &chSize))
            {
                *Domain = 0;
            }
        }


        if ( wcspbrk( UserName, TEXT("@\\") ) )
        {
            Domain[0] = TEXT('\0');
        }

        DifferentAccount = (lstrcmpi(UserName, pGlobals->UserName)) ||
                           (lstrcmpi(Domain, pGlobals->Domain)) ;
    }

    StringSize = GetDlgItemText(hDlg, IDD_UNLOCK_PASSWORD, Password, MAX_STRING_BYTES);
    if (StringSize == MAX_STRING_BYTES)
    {
        Password[MAX_STRING_BYTES-1] = TEXT('\0');
    }

    RtlInitUnicodeString( &PasswordString, Password );
    HashPassword(&PasswordString, PasswordHash );

    //
    // Check if this is the logged-on user.  Do it through the security package
    // if this was a smart card logon to begin with, if this is a smart card unlock,
    // or if we're supposed to under all circumstances.
    //

    //
    // Also check if password expiry warning will appear after unklocking.  If so, then
    // for a hit to the DC to update our profile info to make sure the user didn't
    // already change their password on another machine.
    //
    PasswordExpiryWarning = ShouldPasswordExpiryWarningBeShown(pGlobals, FALSE, NULL);

    if ( ( PasswordExpiryWarning ) ||
         ( pGlobals->UnlockBehavior & UNLOCK_FORCE_AUTHENTICATION ) ||
         ( SmartCardUnlock ) ||
         ( pGlobals->SmartCardLogon ) ||
         ( DifferentAccount ) )
    {
        //
        // Init profile buffer
        //
        ProfileBuffer = NULL;

        AlreadyLogged = TRUE ;

        if ( SmartCardUnlock )
        {
            // 
            // Use the LogonInProgress bool to signal the fact that SmartCardAsyncUnlock
            // is in progress
            //
            pGlobals->LogonInProgress = TRUE;

            GetClientRect( hDlg, &rc );
            pGlobals->cxBand = rc.right-rc.left;
        
            pUnlockDlgState->fKillTimer = FALSE;
            pUnlockDlgState->fUserBeingPrompted = FALSE;
            pUnlockDlgState->fCardRemoved = FALSE;            

            dwAnimationTimeSlice = GetAnimationTimeInterval(pGlobals);
            SetTimer(hDlg, 0, dwAnimationTimeSlice, NULL); 

            // Set timeout to infinite while attempting to logon
            pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, TIMEOUT_NONE );
            
            //
            // Kick off the thread to do the unlock 
            //
            if (UnlockLogonAsync(  pGlobals,
                                   pUnlockDlgState,
                                   UserName,
                                   Domain,
                                   &PasswordString,
                                   hDlg,
                                   TRUE ))
            {
                ErasePassword( &PasswordString );
                return ( MSGINA_DLG_ASYNC_PROCESSING );
            }
            else
            {
                //Status = STATUS_E_FAIL;  // SET THIS TO SOMETHING REASONABLE
                goto AsyncUnlockError;
            }           
        }
        
        Unlocked = UnlockLogon( pGlobals,
                                SmartCardUnlock,
                                UserName,
                                Domain,
                                &PasswordString,
                                &Status,
                                &IsAdmin,
                                &IsLoggedOnUser,
                                &ProfileBuffer,
                                &ProfileBufferLength );

        // Special handling for failed unlock on personal or professional
        // machines that are NOT joined to a domain. In this case it's
        // probably a user who disabled friendly UI and only knows of
        // their "display name" not their real "logon name". This
        // transparently maps one to the other to allow unlocks using
        // the "display name".

        if ((Status == STATUS_LOGON_FAILURE) &&
            (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL)) &&
            !IsMachineDomainMember())       // using our version to optimize caching
        {
            if (ReplacedPossibleDisplayName(UserName, MAX_STRING_BYTES))
            {
                DifferentAccount = (lstrcmpi(UserName, pGlobals->UserName)) ||
                                   (lstrcmpi(Domain, pGlobals->Domain)) ;
                Unlocked = UnlockLogon( pGlobals,
                                        SmartCardUnlock,
                                        UserName,
                                        Domain,
                                        &PasswordString,
                                        &Status,
                                        &IsAdmin,
                                        &IsLoggedOnUser,
                                        &ProfileBuffer,
                                        &ProfileBufferLength );
            }
        }

        //
        // If this unlocked, and is the logged on user,
        // then check to see if we should update all the in-memory passwords
        //

        if ( ( Unlocked ) &&
             ( IsLoggedOnUser ) )
        {
            //
            // Could be a password update.  Check:
            //
            if (RtlEqualMemory( PasswordHash, pGlobals->PasswordHash, PASSWORD_HASH_SIZE ) == FALSE )
            {

                // RevealPassword( &pGlobals->PasswordString );

                UpdateWithChangedPassword(
                        pGlobals,
                        hDlg,
                        TRUE,
                        UserName,
                        Domain,
                        L"",
                        Password,
                        (PMSV1_0_INTERACTIVE_PROFILE)ProfileBuffer );

                //
                // Do not hide!  Update will rehide the global copy of the password.
                //
            }
        }

        //
        // Free profile buffer
        //
        if ( ProfileBuffer )
        {
            LsaFreeReturnBuffer(ProfileBuffer);
        }

        if ( Unlocked )
        {
            DifferentAccount = !IsLoggedOnUser ;
        }
    }

        //
        // Used to be just "else" here, ie:
        // !PasswordExpiryWarning && 
        // !( pGlobals->UnlockBehavior & UNLOCK_FORCE_AUTHENTICATION ) &&
        // !SmartCardUnlock && !pGlobals->SmartCardLogon
        // !DifferentAccount
        // but that's not enough if the user ignored all expiry warnings to date
        // and his password expired while locked (#404780)
        //
        // So the new logic is:
        // If we didn't enter the previous block (tested by means of AlreadyLogged) or
        // we entered it but it failed (and cached unlock is allowed and we didn't 
        // previously unlocked/logged on with a SC)
        //
    if ( ( AlreadyLogged == FALSE ) ||
         ( ( Unlocked == FALSE ) &&
           !( pGlobals->UnlockBehavior & UNLOCK_FORCE_AUTHENTICATION ) &&
           !( pGlobals->SmartCardLogon )
         )
       )
    {
        //
        // un-hide the original password text so that we can
        // do the compare.
        //
        // WARNING: We originally tried doing this comparison
        //          with old and new passwords hidden.  This is
        //          not a good idea because the hide routine
        //          will allow matches that shouldn't match.
        //

        // RevealPassword( &pGlobals->PasswordString );

        Unlocked = ( (lstrcmp(Domain, pGlobals->Domain) == 0) &&
                     (lstrcmpi(UserName, pGlobals->UserName) == 0) &&
                     (RtlEqualMemory( PasswordHash, pGlobals->PasswordHash, PASSWORD_HASH_SIZE ) == TRUE ) );

        //
        // re-hide the original password - use the same seed
        //

        // HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );

        if  ( ( !Unlocked ) &&
              ( AlreadyLogged == FALSE ) ) // We already tried UnlockLogon otherwise
        {
            //
            // The password doesn't match what we have cached.  User
            // could have changed the password from another machine.
            // Let's do the logon, and it if works, we update everything.
            //

            //
            // Init profile buffer
            //
            ProfileBuffer = NULL;

            AlreadyLogged = TRUE ;

            Unlocked = UnlockLogon( pGlobals,
                                    FALSE,
                                    UserName,
                                    Domain,
                                    &PasswordString,
                                    &Status,
                                    &IsAdmin,
                                    &IsLoggedOnUser,
                                    &ProfileBuffer,
                                    &ProfileBufferLength );

            if ( ( Unlocked ) && ( IsLoggedOnUser ) )
            {
                //
                // This logon worked.  Must be a new password.
                //

                // RevealPassword( &pGlobals->PasswordString );

                UpdateWithChangedPassword(
                        pGlobals,
                        hDlg,
                        TRUE,
                        UserName,
                        Domain,
                        L"",
                        Password,
                        (PMSV1_0_INTERACTIVE_PROFILE)ProfileBuffer );

                //
                // Do not hide!  Update will rehide the global copy of the password.
                //
            }

            //
            // Free profile buffer
            //
            if ( ProfileBuffer )
            {
                LsaFreeReturnBuffer(ProfileBuffer);
            }

            if ( Unlocked )
            {
                DifferentAccount = !IsLoggedOnUser ;
            }
        }
    }


    if (Unlocked && !DifferentAccount ) {

        if ( (!AlreadyLogged) &&
             ( ( pGlobals->UnlockBehavior & UNLOCK_NO_NETWORK) == 0 ) )
        {
            UnlockLogonAsync( pGlobals,
                              NULL,
                              UserName,
                              Domain,
                              &PasswordString,
                              NULL,
                              FALSE );
        }

        //
        // Hide the new password to prevent it being paged cleartext.
        //

        ErasePassword( &PasswordString );

        pGlobals->SmartCardLogon = SmartCardUnlock;

        return(MSGINA_DLG_SUCCESS);
    }


    //
    // Check for an admin logon and force the user off
    //

    if ( DifferentAccount )
    {
        if ( !AlreadyLogged )
        {
// PJM... Unreachable.

            IsAdmin = TestUserForAdmin( pGlobals,
                                        UserName,
                                        Domain,
                                        &PasswordString );
        }

        if ( IsAdmin ) {

            //
            // Hide the new password to prevent it being paged cleartext.
            //
            ErasePassword( &PasswordString );

            Result = DisplayForceLogoffWarning(hDlg,
                                       pGlobals,
                                       MB_OKCANCEL | MB_ICONEXCLAMATION | MB_DEFBUTTON2,
                                       TIMEOUT_CURRENT);

            if (Result == MSGINA_DLG_SUCCESS) {

                return(MSGINA_DLG_FORCE_LOGOFF);
            }


            return(Result);
        }
    }
    else
    {

        //
        // Cheap way to force a logon attempt, and hit the lockout yada yada
        //

        if ( !AlreadyLogged )
        {
// PJM... Unreachable.

            UnlockLogon( pGlobals,
                         SmartCardUnlock,
                         UserName,
                         Domain,
                         &PasswordString,
                         &Status,
                         &IsAdmin,
                         &IsLoggedOnUser,
                         NULL,
                         NULL );

        }

    }

AsyncUnlockError:
            //
            // Hide the password to prevent it being paged cleartext.
            //
    ErasePassword( &PasswordString );

    if ( !DifferentAccount )
    {
        int i ;
        UINT Resource = 0 ;

        for ( i = 0 ;
              i < sizeof( UnlockMessages ) / sizeof( UNLOCK_MESSAGE ) ;
              i++ )
        {
            if ( UnlockMessages[i].Status == Status )
            {
                Resource = UnlockMessages[i].Resource ;
                break;
            }
        }

        if ( Resource == 0 )
        {
            Resource = IDS_UNLOCK_FAILED_BAD_PWD ;            
        }

        if(Resource == IDS_LOGON_NO_DOMAIN)
        {
            // Need to build the domain name into the string.
            LoadString(hDllInstance, Resource, Buffer1, MAX_STRING_BYTES);
            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain);
        }
        else
        {
            LoadString(hDllInstance, Resource, Buffer2, MAX_STRING_BYTES);
        }
        
        fStringFound = TRUE;
    } 
    else 
    {            
        //
        // They're not the logged on user and they're not an admin.
        // Tell them they failed to unlock the workstation.
        //

        if ( lstrlen(pGlobals->UserFullName) == 0 ) {

            //
            // No full name.
            //

            if ( pGlobals->Domain[0] == L'\0' )
            {
                //
                // UPN logon:
                //

                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL_NFN, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName
                                                         );

            }
            else
            {
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_NFN, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName
                                                             );

            }

        } else {

            if ( pGlobals->Domain[0] == L'\0' )
            {
                //
                // UPN Logon:
                //
                LoadString(hDllInstance, IDS_UNLOCK_FAILED_EMAIL, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                         pGlobals->UserName,
                                                         pGlobals->UserFullName
                                                         );

            }
            else
            {

                LoadString(hDllInstance, IDS_UNLOCK_FAILED, Buffer1, MAX_STRING_BYTES);

                _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                             pGlobals->UserName,
                                                             pGlobals->UserFullName
                                                             );
            }
        }
    }
        // Covers all _snwprintf(Buffer2 in this function
    Buffer2[ sizeof(Buffer2)/sizeof(TCHAR) - 1 ] = 0;

FastErrorExit:
    Buffer1[0] = 0;
    LoadString(hDllInstance, IDS_WORKSTATION_LOCKED, Buffer1, MAX_STRING_BYTES);

    Result = TimeoutMessageBoxlpstr(hDlg,
                                    pGlobals,
                                    Buffer2,
                                    Buffer1,
                                     MB_OK | MB_ICONSTOP,
                                     TIMEOUT_CURRENT);
    if (DLG_INTERRUPTED(Result)) {
        return( SetInterruptFlag( MSGINA_DLG_FAILURE ) );
    }

    return(MSGINA_DLG_FAILURE);
}


/****************************************************************************\
*
* FUNCTION: UnlockShowOptions
*
* PURPOSE: Hide the options part of the unlock dialog
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   15-dec-97 daviddv - Created
*
\****************************************************************************/

VOID UnlockShowOptions(PGLOBALS pGlobals, HWND hDlg, BOOL fShow)
{
    RECT rc, rc2;
    INT dy;
    TCHAR szBuffer[32];

    if ( pGlobals->UnlockOptionsShown != fShow )
    {
        //
        // Show hide optional fields in the dialog
        //

        if (pGlobals->ShowDomainBox)
        {
            GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_PASSWORD), &rc);
            GetWindowRect(GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN), &rc2);
            dy = rc2.bottom-rc.bottom;

            MoveControls(hDlg, ctrlNoDomain,
                         sizeof(ctrlNoDomain)/sizeof(ctrlNoDomain[0]),
                         0, fShow ? dy:-dy,
                         TRUE);

            ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN_LABEL, fShow);
            ShowDlgItem(hDlg, IDD_UNLOCK_DOMAIN, fShow);
        }

        ShowDlgItem(hDlg, IDD_KBLAYOUT_ICON, fShow);
        //
        // Change the options button to reflect the open/close state
        //

        LoadString(hDllInstance, fShow ? IDS_LESSOPTIONS:IDS_MOREOPTIONS,
                                szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]));

        SetDlgItemText(hDlg, IDD_UNLOCK_OPTIONS, szBuffer);
    }

    pGlobals->UnlockOptionsShown = fShow;

    // Enable or disable the domain box depending on whether a UPN name has been typed
    EnableDomainForUPN(GetDlgItem(hDlg, IDD_UNLOCK_NAME), GetDlgItem(hDlg, IDD_UNLOCK_DOMAIN));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\options.h ===
/****************************** Module Header ******************************\
* Module Name: options.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define apis used to implement security options dialog
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//


INT_PTR
SecurityOptions(
    PGLOBALS
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\rasx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ras.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-09-96   RichardW   Created
//
//----------------------------------------------------------------------------


BOOL
PopupRasPhonebookDlg(
    HWND        hwndOwner,
    PGLOBALS    pGlobals,
    BOOL *      pfTimedOut
    );


DWORD
GetRasDialOutProtocols(
    void );

BOOL
HangupRasConnections(
    PGLOBALS    pGlobals
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\options.c ===
/****************************** Module Header ******************************\
* Module Name: options.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implementation of functions to support security options dialog.
*
* History:
* 12-05-91 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#include "shtdnp.h"

#include <stdio.h>
#include <wchar.h>

#pragma hdrstop

#define CTRL_TASKLIST_SHELL

#define LPTSTR  LPWSTR

#define BOOLIFY(expr)           (!!(expr))

//
// Private prototypes
//

INT_PTR WINAPI
OptionsDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL OptionsDlgInit(HWND);

INT_PTR WINAPI
EndWindowsSessionDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

/******************************************************************************
 *
 *  HandleFailedDisconnect
 *
 *   Tell the user why the disconnect from the current Logon failed.
 *
 *  ENTRY:
 *      hDlg (input)
 *          This dialog's window handle.
 *      SessionId (input)
 *          The user's current SessionId.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
HandleFailedDisconnect( HWND hDlg,
                        ULONG SessionId,
                        PGLOBALS pGlobals )
{
    DWORD Error;
    TCHAR Buffer1[MAX_STRING_BYTES] = TEXT("");
    TCHAR Buffer2[MAX_STRING_BYTES];
    TCHAR Buffer3[MAX_STRING_BYTES] = TEXT("");

    Error = GetLastError();
    switch (Error) {

        default:
            LoadString( hDllInstance, IDS_MULTIUSER_UNEXPECTED_DISCONNECT_FAILURE,
                        Buffer1, MAX_STRING_BYTES );
            FormatMessage(
                   FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL, Error, 0, Buffer3, MAX_STRING_BYTES, NULL );

            _snwprintf(Buffer2, MAX_STRING_BYTES - 1, Buffer1, SessionId, Buffer3);
            Buffer2[MAX_STRING_BYTES - 1] = 0;

            Buffer1[0] = 0;
            LoadString( hDllInstance, IDS_MULTIUSER_DISCONNECT_FAILED,
                        Buffer1, MAX_STRING_BYTES );

            TimeoutMessageBoxlpstr( hDlg, pGlobals,  Buffer2,
                                    Buffer1,
                                    MB_OK | MB_ICONEXCLAMATION,
                                    TIMEOUT_CURRENT );
            break;
    }
}


/***************************************************************************\
* SecurityOptions
*
* Show the user the security options dialog and do what they ask.
*
* Returns:
*     MSGINA_DLG_SUCCESS if everything went OK and the user wants to continue
*     DLG_LOCK_WORKSTAION if the user chooses to lock the workstation
*     DLG_INTERRUPTED() - this is a set of possible interruptions (see winlogon.h)
*     MSGINA_DLG_FAILURE if the dialog cannot be brought up.
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

INT_PTR
SecurityOptions(
    PGLOBALS pGlobals)
{
    int Result;
    DWORD dwTimeOut;

    dwTimeOut = OPTIONS_TIMEOUT;

		// Bring the timeout to 30 sec if the SS timeout is less than 2 minutes.
    if (OpenHKeyCurrentUser(pGlobals))
    {
        HKEY hkeyUserControl;
        DWORD dwType ;
        DWORD cbData ;
        DWORD dwValue = 0;
        TCHAR szBuffer[11];	// Enough for a DWORD

            // Get user preference
        if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
                         SCREENSAVER_KEY,
                         0, KEY_READ, &hkeyUserControl) == ERROR_SUCCESS)
        {

            cbData = sizeof(szBuffer);

            if (ERROR_SUCCESS == RegQueryValueEx(
                                    hkeyUserControl, TEXT("ScreenSaveTimeOut") ,
                                    0, &dwType, (LPBYTE)szBuffer, &cbData))
            {
                if ((dwType == REG_SZ) && (cbData > 1) && (szBuffer[cbData / sizeof(TCHAR) - 1] == 0))
                {
                    dwValue = _wtol(szBuffer);
                }
            }
            
            RegCloseKey( hkeyUserControl );
        }


            // Overide by policy?
        if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
                         SCREENSAVER_POLICY_KEY,
                         0, KEY_READ, &hkeyUserControl) == ERROR_SUCCESS)
        {

            cbData = sizeof(szBuffer);

            if (ERROR_SUCCESS == RegQueryValueEx(
                                    hkeyUserControl, TEXT("ScreenSaveTimeOut") ,
                                    0, &dwType, (LPBYTE)szBuffer, &cbData))
            {
                if ((dwType == REG_SZ) && (cbData > 1) && (szBuffer[cbData / sizeof(TCHAR) - 1] == 0))
                {
                    dwValue = _wtol(szBuffer);
                }
            }
            
            RegCloseKey( hkeyUserControl );
        }

        if (dwValue <= OPTIONS_TIMEOUT)
        {
	        dwTimeOut = 30;
        }

        CloseHKeyCurrentUser(pGlobals);
    }

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, dwTimeOut);

    Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            (LPTSTR)IDD_OPTIONS_DIALOG,
                                            NULL,
                                            OptionsDlgProc,
                                            (LPARAM) pGlobals);

    if (Result == WLX_DLG_INPUT_TIMEOUT)
    {
        Result = MSGINA_DLG_SUCCESS;
    }

    return(Result);
}



/***************************************************************************\
*
* FUNCTION: OptionsDlgProc
*
* PURPOSE:  Processes messages for Security options dialog
*
\***************************************************************************/

INT_PTR WINAPI
OptionsDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    INT_PTR Result;
    HANDLE  UserHandle;
    NTSTATUS Status;
    BOOL EnableResult;
    BOOL ControlKey;


    switch (message) {

        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

            if (!OptionsDlgInit(hDlg))
            {
                EndDialog(hDlg, MSGINA_DLG_FAILURE);
            }
            return(TRUE);

        case WLX_WM_SAS:

            //
            // If this is someone hitting C-A-D, swallow it.
            //
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
            {
                return(TRUE);
            }

            //
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            //
            DebugLog((DEB_TRACE, "Received SAS event %d, which we're letting winlogon cope with\n", wParam));
            return(FALSE);

        case WM_COMMAND:

            ControlKey = (GetKeyState(VK_LCONTROL) < 0) ||
                         (GetKeyState(VK_RCONTROL) < 0) ;

            switch (LOWORD(wParam))
            {

                case IDCANCEL:
                    EndDialog(hDlg, MSGINA_DLG_SUCCESS);
                    return TRUE;

                case IDD_OPTIONS_CHANGEPWD:
                    Result = ChangePassword(hDlg,
                                            pGlobals,
                                            pGlobals->UserName,
                                            pGlobals->Domain,
                                            CHANGEPWD_OPTION_ALL );

                    if (DLG_INTERRUPTED(Result))
                    {
                        EndDialog(hDlg, Result);
                    }
                    return(TRUE);

                case IDD_OPTIONS_LOCK:
                    EndDialog(hDlg, MSGINA_DLG_LOCK_WORKSTATION);
                    return(TRUE);

                case IDD_OPTIONS_LOGOFF:

                    if (ControlKey)
                    {
                        Result = TimeoutMessageBox(hDlg,
                                           pGlobals,
                                           IDS_LOGOFF_LOSE_CHANGES,
                                           IDS_LOGOFF_TITLE,
                                           MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONSTOP,
                                           TIMEOUT_CURRENT);

                        if (Result == MSGINA_DLG_SUCCESS)
                        {
                            EndDialog(hDlg, MSGINA_DLG_FORCE_LOGOFF);
                        }
                    }
                    else
                    {

                        //
                        // Confirm the user really knows what they're doing.
                        //
                        Result = pWlxFuncs->WlxDialogBoxParam(
                                            pGlobals->hGlobalWlx,
                                            hDllInstance,
                                            MAKEINTRESOURCE(IDD_LOGOFFWINDOWS_DIALOG),
                                            hDlg,
                                            EndWindowsSessionDlgProc,
                                            (LPARAM)pGlobals);

                        if (Result == MSGINA_DLG_SUCCESS)
                        {
                            EndDialog(hDlg, MSGINA_DLG_USER_LOGOFF);
                        }
                    }

                    return(TRUE);

                case IDD_OPTIONS_SHUTDOWN:

                    //
                    // If they held down Ctrl while selecting shutdown - then
                    // we'll do a quick and dirty reboot.
                    // i.e. we skip the call to ExitWindows
                    //

                    if ( ControlKey && TestUserPrivilege(pGlobals->UserProcessData.UserToken, SE_SHUTDOWN_PRIVILEGE))
                    {
                        //
                        // Check they know what they're doing
                        //

                        Result = TimeoutMessageBox(hDlg,
                                           pGlobals,
                                           IDS_REBOOT_LOSE_CHANGES,
                                           IDS_EMERGENCY_SHUTDOWN,
                                           MB_OKCANCEL | MB_DEFBUTTON2 | MB_ICONSTOP,
                                           TIMEOUT_CURRENT);
                        if (Result == MSGINA_DLG_SUCCESS)
                        {
                            //
                            // Impersonate the user for the shutdown call
                            //

                            UserHandle = ImpersonateUser( &pGlobals->UserProcessData, NULL );
                            ASSERT(UserHandle != NULL);

                            if ( UserHandle )
                            {

                                //
                                // Enable the shutdown privilege
                                // This should always succeed - we are either system or a user who
                                // successfully passed the privilege check in ExitWindowsEx.
                                //

                                EnableResult = EnablePrivilege(SE_SHUTDOWN_PRIVILEGE, TRUE);
                                ASSERT(EnableResult);


                                //
                                // Do the final system shutdown pass (reboot).  Note, if
                                // the privilege was not enabled, the API will reject this
                                // call.
                                //

                                Status = NtShutdownSystem(ShutdownReboot);
                            }
                        }

                        if (Result != MSGINA_DLG_FAILURE)
                        {
                            EndDialog(hDlg, Result);
                        }

                        return(TRUE);
                    }
                             

                    //
                    // This is a normal shutdown request
                    //
                    // Check they know what they're doing and find
                    // out if they want to reboot too.
                    //

                    Result = WinlogonShutdownDialog(hDlg, pGlobals, 0);

                    // Pre-filter the Disconnect option and handle
                    // it now since it may fail
                    
                    if (Result == MSGINA_DLG_DISCONNECT)
                    {
                        if ( pWlxFuncs->WlxDisconnect() ) 
                        {
                            Result = MSGINA_DLG_SUCCESS;
                        } 
                        else 
                        {
                            HandleFailedDisconnect(hDlg, pGlobals->MuGlobals.SessionId, pGlobals);
                            Result = MSGINA_DLG_FAILURE;
                        }
                    }

                    if (Result != MSGINA_DLG_FAILURE)
                    {
                        EndDialog(hDlg, Result);
                    }

                    return(TRUE);


                case IDD_OPTIONS_TASKLIST:


                    EndDialog(hDlg, MSGINA_DLG_TASKLIST);

                    //
                    // Tickle the messenger so it will display any queue'd messages.
                    // (This call is a kind of NoOp).
                    //
                    NetMessageNameDel(NULL,L"");

                    return(TRUE);
                    break;

            }

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, FALSE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        }

    // We didn't process the message
    return(FALSE);
}


/****************************************************************************

FUNCTION: OptionsDlgInit

PURPOSE:  Handles initialization of security options dialog

RETURNS:  TRUE on success, FALSE on failure
****************************************************************************/

BOOL OptionsDlgInit(
    HWND    hDlg)
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    TCHAR    Buffer1[MAX_STRING_BYTES] = TEXT("");
    TCHAR    Buffer2[MAX_STRING_BYTES];
    BOOL     Result;
    DWORD    dwValue, dwType;
    HKEY     hkeyPolicy;
    DWORD    cbData;
    HANDLE   hImpersonateUser = NULL;
    USHORT   Flags = FT_TIME|FT_DATE;
    LCID     locale;

    SetWelcomeCaption( hDlg );

    //
    // Set the logon info text
    //

    if (pGlobals->Domain[0] == TEXT('\0') )
    {

        //
        // there is no domain name
        //

        if ( lstrlen(pGlobals->UserFullName) == 0)
        {

            //
            // There is no full name
            //


            LoadString(hDllInstance, IDS_LOGON_EMAIL_NAME_NFN_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR) - 1, Buffer1, pGlobals->UserName);


        }
        else
        {

            LoadString(hDllInstance, IDS_LOGON_EMAIL_NAME_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1,
                                                          pGlobals->UserFullName,
                                                          pGlobals->UserName);

        }

    }
    else
    {
        if ( lstrlen(pGlobals->UserFullName) == 0)
        {

            //
            // There is no full name
            //

            LoadString(hDllInstance, IDS_LOGON_NAME_NFN_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->Domain,
                                                          pGlobals->UserName);

        }
        else
        {

            LoadString(hDllInstance, IDS_LOGON_NAME_INFO, Buffer1, MAX_STRING_BYTES);

            _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR), Buffer1, pGlobals->UserFullName,
                                                          pGlobals->Domain,
                                                          pGlobals->UserName);

        }
    }

        // Taking care of all _snwprintf(Buffer2 above
    Buffer2[sizeof(Buffer2)/sizeof(TCHAR) - 1] = 0;

    SetDlgItemText(hDlg, IDD_OPTIONS_LOGON_NAME_INFO, Buffer2);

    //
    // Set the logon time/date - but do it as the logged on user
    //
    hImpersonateUser = ImpersonateUser(&pGlobals->UserProcessData, NULL);

    locale = GetUserDefaultLCID();

    if (((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC)
        || (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW)))
        {
            // Get the real item windows ExStyle.
            HWND hWnd = GetDlgItem(hDlg, IDD_OPTIONS_LOGON_DATE);
            DWORD dwExStyle = GetWindowLong(hWnd, GWL_EXSTYLE);
            
            if ((BOOLIFY(dwExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwExStyle & WS_EX_LAYOUTRTL)))
                Flags |= FT_RTL;
            else
                Flags |= FT_LTR;
        }

    Result = FormatTime(&pGlobals->LogonTime, Buffer1, sizeof(Buffer1) / sizeof(Buffer1[0]), Flags);
    if (hImpersonateUser)
    {
        StopImpersonating(hImpersonateUser);
    }

    ASSERT(Result);
    SetDlgItemText(hDlg, IDD_OPTIONS_LOGON_DATE, Buffer1);


    //
    // Check if DisableLockWorkstation is set for the entire machine
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY,
                     0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
    {
         dwValue = 0;
         cbData = sizeof(dwValue);
         if ((ERROR_SUCCESS == RegQueryValueEx(hkeyPolicy, DISABLE_LOCK_WKSTA,
                         0, &dwType, (LPBYTE)&dwValue, &cbData)) &&
             (REG_DWORD == dwType))
         {
             if (dwValue)
             {
                EnableDlgItem(hDlg, IDD_OPTIONS_LOCK, FALSE);
             }
         }

        RegCloseKey(hkeyPolicy);
    }

    //
    //  Smart card only users can't change the password
    //
    if (pGlobals->Profile && (pGlobals->Profile->UserFlags & UF_SMARTCARD_REQUIRED))
    {
        EnableDlgItem(hDlg, IDD_OPTIONS_CHANGEPWD, FALSE);
    }

    //
    //  Check for policy and then disable corresponding options
    //

    if (OpenHKeyCurrentUser(pGlobals)) {

        if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
                         WINLOGON_POLICY_KEY,
                         0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
        {
             dwValue = 0;
             cbData = sizeof(dwValue);
             if ((ERROR_SUCCESS == RegQueryValueEx(hkeyPolicy, DISABLE_LOCK_WKSTA,
                             0, &dwType, (LPBYTE)&dwValue, &cbData)) &&
                 (REG_DWORD == dwType))
             {
                 if (dwValue)
                 {
                    EnableDlgItem(hDlg, IDD_OPTIONS_LOCK, FALSE);
                 }
             }


             dwValue = 0;
             cbData = sizeof(dwValue);
             if ((ERROR_SUCCESS == RegQueryValueEx(hkeyPolicy, DISABLE_TASK_MGR,
                             0, &dwType, (LPBYTE)&dwValue, &cbData)) &&
                 (REG_DWORD == dwType))
             {
                 if (dwValue)
                 {
                    EnableDlgItem(hDlg, IDD_OPTIONS_TASKLIST, FALSE);
                    ShowDlgItem(hDlg, IDD_OPTIONS_TASKMGR_TEXT, FALSE);
                 }
             }

             dwValue = 0;
             cbData = sizeof(dwValue);
             if ((ERROR_SUCCESS == RegQueryValueEx(hkeyPolicy, DISABLE_CHANGE_PASSWORD,
                             0, &dwType, (LPBYTE)&dwValue, &cbData)) &&
                 (REG_DWORD == dwType))
             {
                 if (dwValue)
                 {
                    EnableDlgItem(hDlg, IDD_OPTIONS_CHANGEPWD, FALSE);
                 }
             }

             RegCloseKey(hkeyPolicy);
        }

        if (RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser, EXPLORER_POLICY_KEY,
                         0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS)
        {
             dwValue = 0;
             cbData = sizeof(dwValue);
             if ((ERROR_SUCCESS == RegQueryValueEx(hkeyPolicy, NOLOGOFF,
                             0, &dwType, (LPBYTE)&dwValue, &cbData)) &&
                 (REG_DWORD == dwType))
             {
                 if (dwValue)
                 {
                    EnableDlgItem(hDlg, IDD_OPTIONS_LOGOFF, FALSE);
                 }
             }

             dwValue = 0;
             cbData = sizeof(dwValue);

             if ((ERROR_SUCCESS != RegQueryValueEx(hkeyPolicy, NOCLOSE,
                             0, &dwType, (LPBYTE)&dwValue, &cbData)) ||
                 (REG_DWORD != dwType))
             {
                 dwValue = 0;
             }


            //
            // If this is not the system console, check the appropriate key in registry
            //
            if ( !g_Console ) {
                if (!TestUserPrivilege(pGlobals->UserProcessData.UserToken, SE_SHUTDOWN_PRIVILEGE)) {
                    DWORD dwVal = 0;

                    cbData = sizeof(dwVal);
                    if ((ERROR_SUCCESS == RegQueryValueEx(hkeyPolicy, NODISCONNECT,
                                     0, &dwType, (LPBYTE)&dwVal, &cbData)) &&
                        (REG_DWORD == dwType))
                    {
                         dwValue = dwVal;
                    }
                }
            }

             if (dwValue)
             {
                EnableDlgItem(hDlg, IDD_OPTIONS_SHUTDOWN, FALSE);
             }
             RegCloseKey(hkeyPolicy);
        }

        CloseHKeyCurrentUser(pGlobals);
    }

    // Position ourselves nicely
    SizeForBranding(hDlg, FALSE);
    CentreWindow(hDlg);

    return TRUE;
}

/***************************************************************************\
* FUNCTION: EndWindowsSessionDlgProc
*
* PURPOSE:  Processes messages for Logging off Windows Nt confirmation dialog
*
* RETURNS:  MSGINA_DLG_SUCCESS     - The user wants to logoff.
*           MSGINA_DLG_FAILURE     - The user doesn't want to logoff.
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* HISTORY:
*
*   05-17-92 Davidc       Created.
*
\***************************************************************************/

INT_PTR WINAPI
EndWindowsSessionDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    static HICON hIcon = NULL;
            
    switch (message)
    {

        case WM_INITDIALOG:
            {

            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

            // Load the 48 x 48 version of the logoff icon
            if( NULL == hIcon )
            {
                hIcon = LoadImage (hDllInstance, MAKEINTRESOURCE(IDI_STLOGOFF),
                                   IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR);
            }

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDD_LOGOFFICON, STM_SETICON, (WPARAM) hIcon, 0);
            }

            // Position ourselves nicely
            CentreWindow(hDlg);

            }
            return(TRUE);

        case WLX_WM_SAS:

            //
            // If this is someone hitting C-A-D, swallow it.
            //
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
            {
                return(TRUE);
            }

            //
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            //
            return(FALSE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {

                case IDOK:
                    EndDialog(hDlg, MSGINA_DLG_SUCCESS);
                    return(TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, MSGINA_DLG_FAILURE);
                    return(TRUE);
            }
            break;
        case WM_DESTROY:
            if (hIcon)
            {
                DestroyIcon(hIcon);
                hIcon = NULL;
            }
            break;

    }

    // We didn't process the message
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\mslogon.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mslogon.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include "shtdnp.h"
#include "authmon.h"
#include <stdio.h>
#include <wchar.h>
#include <wincrypt.h>
#include <sclogon.h>
#include "shlwapi.h"
#include "shlwapip.h"

#include "winsta.h"
#include "wtsapi32.h"
#include <keymgr.h>
#include <passrec.h>

typedef void (WINAPI *RUNDLLPROC)(HWND hWndStub,HINSTANCE hInstance,LPWSTR szCommandLine,int nShow);

typedef struct _MSGINA_LOGON_PARAMETERS {
    PGLOBALS pGlobals;
    DWORD SasType;
} MSGINA_LOGON_PARAMETERS, * PMSGINA_LOGON_PARAMETERS ;

#define WINSTATIONS_DISABLED    TEXT("WinStationsDisabled")

//
// Number of seconds we will display the legal notices
// before timing out.
//

#define LEGAL_NOTICE_TIMEOUT        120

#define LOGON_SLEEP_PERIOD          750

#define WM_LOGONPROMPT              WM_USER + 257
#define WM_LOGONCOMPLETE            WM_USER + 258

#define WM_HANDLEFAILEDLOGON        WM_USER + 259
#define WM_DCACHE_COMPLETE          WM_USER + 260

#define MAX_CAPTION_LENGTH  256

// Maximum size of a UPN name we allow at present
#define MAX_UPN_NAME_SIZE   520

typedef struct FAILEDLOGONINFO_t
{
    PGLOBALS pGlobals;
    NTSTATUS Status;
    NTSTATUS SubStatus;
    TCHAR   UserName[UNLEN + DNLEN + 2];
    TCHAR   Domain[DNLEN + 1];
} FAILEDLOGONINFO, *PFAILEDLOGONINFO;


typedef struct _LEGALINFO
{
    LPTSTR NoticeText;
    LPTSTR CaptionText;
} LEGALINFO, *PLEGALINFO;


// Also defined in wstrpc.c
#define INET_CONNECTOR_EVENT_NAME   L"Global\\TermSrvInetConnectorEvent"

#define TERMSERV_EVENTSOURCE        L"TermService"

// Also defined in icaevent.mc
#define EVENT_BAD_TSINTERNET_USER   1007

//
// Globals:
//
static WNDPROC OldCBWndProc;

HICON   hSteadyFlag;
HICON   hWavingFlag;
HICON   hAuditFull;

extern HICON   hLockedIcon;
BOOL    IsPswBackupAvailable;
BOOL    s_fAttemptedAutoLogon;

BOOL    g_fHelpAssistantLogon = FALSE;
BOOL    g_FirstTime = TRUE;


//
// Prototypes:
//


INT_PTR
DisplayLegalNotices(
    PGLOBALS pGlobals
    );

BOOL
GetLegalNotices(
    LPTSTR lpSubKey,
    LPTSTR *NoticeText,
    LPTSTR *CaptionText
    );

INT_PTR WINAPI
LogonDlgCBProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

INT_PTR WINAPI
LogonDlgUsernameProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

INT_PTR WINAPI
LogonDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
LogonDlgInit(
    HWND    hDlg,
    BOOL    bAutoLogon,
    DWORD   SasType
    );

NTSTATUS
UpnFromCert(
    IN PCCERT_CONTEXT pCert,
    IN OUT DWORD       *pcUpn,
    IN OUT LPWSTR       pUPN
    );

BOOL
WINAPI
QuerySwitchConsoleCredentials(
    PGLOBALS pGlobals,
    HANDLE * phUserToken,
    PLUID    pLogonId);


// Global structure for a failed logon filled in by the worker thread to be consumed
// by the ui thread.
FAILEDLOGONINFO g_failinfo;

void PostFailedLogonMessage(HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    NTSTATUS SubStatus,
    PWCHAR UserName,
    PWCHAR Domain
    );

INT_PTR
HandleFailedLogon(
    HWND hDlg
    );

VOID
ReportBootGood(
    PGLOBALS pGlobals
    );

VOID LogonShowOptions(
    PGLOBALS pGlobals,
    HWND hDlg,
    BOOL fShow,
    BOOL fSticky);

VOID AttemptLogonSetControls(
    PGLOBALS pGlobals,
    HWND hDlg
    );

INT_PTR
AttemptLogon(
    HWND hDlg
    );

DWORD
AttemptLogonThread(
    PGLOBALS pGlobals
    );

BOOL
GetAndAllocateLogonSid(
    HANDLE hToken,
    PSID *pLogonSid
    );

BOOL GetSessionZeroUser(LPTSTR szUser, int nUserMax);
BOOL FastUserSwitchingEnabled();


//
// control tables for showing/hiding options
//

static UINT ctrlNoShutdown[] =
{
    IDOK,
    IDCANCEL,
};

static UINT ctrlNoCancel[] =
{
    IDOK,
};

static UINT ctrlNoDomain[] =
{
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
    IDD_LOGON_RASBOX,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoRAS[] =
{
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoOptions[] =
{
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_KBLAYOUT_ICON,
};

static UINT ctrlNoLegalBanner[] =
{
    IDD_LOGON_NAME_LABEL,
    IDD_LOGON_NAME,
    IDD_LOGON_PASSWORD_LABEL,
    IDD_LOGON_PASSWORD,
    IDD_LOGON_DOMAIN_LABEL,
    IDD_LOGON_DOMAIN,
    IDD_LOGON_RASBOX,
    IDD_KBLAYOUT_ICON,
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
};

static UINT ctrlNoUserName[] =
{
    IDD_LOGON_PASSWORD_LABEL,
    IDD_LOGON_PASSWORD,
    IDD_LOGON_DOMAIN_LABEL,
    IDD_LOGON_DOMAIN,
    IDD_LOGON_RASBOX,
    IDD_KBLAYOUT_ICON,
    IDOK,
    IDCANCEL,
    IDD_LOGON_SHUTDOWN,
    IDD_LOGON_OPTIONS,
};


//  --------------------------------------------------------------------------
//  ::DisableEditSubClassProc
//
//  Arguments:  hwnd        =   See the platform SDK under WindowProc.
//              uMsg        =   See the platform SDK under WindowProc.
//              wParam      =   See the platform SDK under WindowProc.
//              lParam      =   See the platform SDK under WindowProc.
//              uiID        =   ID assigned at subclass time.
//              dwRefData   =   reference data assigned at subclass time.
//
//  Returns:    LRESULT
//
//  Purpose:    comctl32 subclass callback function. This allows us to not
//              process WM_CUT/WM_COPY/WM_PASTE/WM_CLEAR/WM_UNDO and any
//              other messages to be discarded.
//
//  History:    2001-02-18  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CALLBACK    DisableEditSubClassProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uiID, DWORD_PTR dwRefData)

{
    LRESULT     lResult;

    switch (uMsg)
    {
        case WM_CUT:
        case WM_COPY:
        case WM_PASTE:
        case WM_CLEAR:
        case WM_UNDO:
        case WM_CONTEXTMENU:
            lResult = FALSE;
            break;
        default:
            lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}


INT_PTR WINAPI
LegalDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            PLEGALINFO pLegalInfo;

            pLegalInfo = (PLEGALINFO) lParam;

            SetWindowText (hDlg, pLegalInfo->CaptionText);
            SetWindowText (GetDlgItem(hDlg, IDD_LEGALTEXT), pLegalInfo->NoticeText);

            CentreWindow(hDlg);

            // Ensure the window is topmost so it's not obscured by the welcome screen.
            SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

            return( TRUE );
        }

        case WM_COMMAND:
            {
                if (LOWORD(wParam) == IDOK)
                {
                    EndDialog(hDlg, IDOK);
                }
            }
            break;
    }

    return FALSE;
}

/***************************************************************************\
* FUNCTION: DisplayLegalNotices
*
* PURPOSE:  Puts up a dialog box containing legal notices, if any.
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the dialog was shown and dismissed successfully.
*           MSGINA_DLG_FAILURE     - the dialog could not be shown
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* HISTORY:
*
*   Robertre  6-30-93  Created
*
\***************************************************************************/

INT_PTR
DisplayLegalNotices(
    PGLOBALS pGlobals
    )
{
    INT_PTR Result = MSGINA_DLG_SUCCESS;
    LPTSTR NoticeText;
    LPTSTR CaptionText;
    LEGALINFO LegalInfo;

    if (GetLegalNotices( WINLOGON_POLICY_KEY, &NoticeText, &CaptionText ))
    {

        LegalInfo.NoticeText = NoticeText;
        LegalInfo.CaptionText = CaptionText;

        _Shell_LogonStatus_Hide();

        pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LEGAL_NOTICE_TIMEOUT);

        Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                                hDllInstance,
                                                (LPTSTR) IDD_LEGALMSG,
                                                NULL,
                                                LegalDlgProc,
                                                (LPARAM) &LegalInfo );

        _Shell_LogonStatus_Show();

        Free( NoticeText );
        Free( CaptionText );
    }
    else if (GetLegalNotices( WINLOGON_KEY, &NoticeText, &CaptionText ))
    {

        LegalInfo.NoticeText = NoticeText;
        LegalInfo.CaptionText = CaptionText;

        _Shell_LogonStatus_Hide();

        pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, LEGAL_NOTICE_TIMEOUT);

        Result = pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                                                hDllInstance,
                                                (LPTSTR) IDD_LEGALMSG,
                                                NULL,
                                                LegalDlgProc,
                                                (LPARAM) &LegalInfo );

        _Shell_LogonStatus_Show();

        Free( NoticeText );
        Free( CaptionText );
    }

    return( Result );
}

/***************************************************************************\
* FUNCTION: GetLegalNotices
*
* PURPOSE:  Get legal notice information out of the registry.
*
* RETURNS:  TRUE - Output parameters contain valid data
*           FALSE - No data returned.
*
* HISTORY:
*
*   Robertre 6-30-93 Created
*
\***************************************************************************/
BOOL
GetLegalNotices(
    LPTSTR lpSubKey,
    LPTSTR *NoticeText,
    LPTSTR *CaptionText
    )
{
    LPTSTR lpCaption, lpText;
    HKEY hKey;
    DWORD dwSize, dwType, dwMaxSize = 0;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpSubKey,
                     0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        RegQueryInfoKey (hKey, NULL, NULL, NULL, NULL,
                         NULL, NULL, NULL, NULL, &dwMaxSize,
                         NULL, NULL);

        lpCaption = Alloc (dwMaxSize);

        if (!lpCaption) {
            RegCloseKey(hKey);
            return FALSE;
        }


        lpText = Alloc (dwMaxSize);

        if (!lpText) {
            Free(lpCaption);
            RegCloseKey(hKey);
            return FALSE;
        }

        dwSize = dwMaxSize;
        if ((ERROR_SUCCESS != RegQueryValueEx(hKey, LEGAL_NOTICE_CAPTION_KEY,
                        0, &dwType, (LPBYTE)lpCaption, &dwSize)) ||
            (dwType != REG_SZ))
        {
            lpCaption[0] = 0;
        }

        dwSize = dwMaxSize;
        if ((ERROR_SUCCESS != RegQueryValueEx(hKey, LEGAL_NOTICE_TEXT_KEY,
                        0, &dwType, (LPBYTE)lpText, &dwSize)) ||
            (dwType != REG_SZ))
        {
            lpText[0] = 0;
        }

        RegCloseKey(hKey);


        if (*lpCaption && *lpText) {
            *CaptionText = lpCaption;
            *NoticeText = lpText;
            return TRUE;
        }

        Free(lpCaption);
        Free(lpText);
    }

    return FALSE;
}


/***************************************************************************\
* FUNCTION: Logon
*
* PURPOSE:  Display the logon UI depending on the SAS type.
*
* RETURNS:  -
*
* NOTES:    If the logon is successful, the global structure is filled in
*           with the logon information.
*
* HISTORY:
*   12-09-91 daviddv    Comments.
*
\***************************************************************************/

INT_PTR
Logon(
    PGLOBALS pGlobals,
    DWORD SasType
    )
{
    INT_PTR Result;
    MSGINA_LOGON_PARAMETERS Parm ;

    if ( SasType == WLX_SAS_TYPE_SC_REMOVE )
    {
        return WLX_SAS_ACTION_NONE ;
    }

    if( !g_Console )
    {
        //
        // Check if current session is HelpAssistant Session, HelpAssisant
        // session can not be console session.
        //
        g_fHelpAssistantLogon = WinStationIsHelpAssistantSession(
                                                            SERVERNAME_CURRENT,
                                                            LOGONID_CURRENT
                                                        );
    }

    if ( SasType == WLX_SAS_TYPE_SC_INSERT )
    {
        PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

        pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                 WLX_OPTION_SMART_CARD_INFO,
                                 (ULONG_PTR *) &ScInfo );

        //
        // Validate the SC info against some common user
        // errors before the PIN dialog appears
        //

        if ( ScInfo )
        {
            if ( ( ScInfo->pszReader ) &&
                 ( ScInfo->pszCard == NULL ) )
            {
                //
                // The card could not be read.  Might not be
                // inserted correctly.
                //

                LocalFree(ScInfo);

                TimeoutMessageBox( NULL, pGlobals, IDS_CARD_NOT_RECOGNIZED,
                                        IDS_LOGON_MESSAGE,
                                        MB_OK | MB_ICONEXCLAMATION,
                                        LOGON_TIMEOUT );

                return WLX_SAS_ACTION_NONE;
            }

            if ( ( ScInfo->pszReader ) &&
                 ( ScInfo->pszCryptoProvider == NULL ) )
            {
                //
                // Got a card, but the CSP for it could not be
                // found.
                //

                LocalFree(ScInfo);

                TimeoutMessageBox( NULL, pGlobals, IDS_CARD_CSP_NOT_RECOGNIZED,
                                        IDS_LOGON_MESSAGE,
                                        MB_OK | MB_ICONEXCLAMATION,
                                        LOGON_TIMEOUT );

                return WLX_SAS_ACTION_NONE;
            }

            LocalFree(ScInfo);
        }
    }

    //
    // Asynchronously update domain cache if necessary.
    // We won't ask to wait so this routine will do no UI.
    // i.e. we can ignore the result.
    //
//  Result = UpdateDomainCache(pGlobals, NULL, FALSE);
//  ASSERT(!DLG_INTERRUPTED(Result));

    if( !g_fHelpAssistantLogon ) {
        //
        // See if there are legal notices in the registry.
        // If so, put them up in a message box
        //
        Result = DisplayLegalNotices( pGlobals );
        if ( Result != MSGINA_DLG_SUCCESS ) {
            return(WLX_SAS_ACTION_NONE);
        }

        //
        // Get the latest audit log status and store in our globals
        // If the audit log is full we show a different logon dialog.
        //
        GetAuditLogStatus(pGlobals);
    } else {

        //
        // fake it so audit log is not full, setting is from GetAuditLogStatus()
        //
        pGlobals->AuditLogFull = FALSE;
        pGlobals->AuditLogNearFull = FALSE;
    }

    Parm.pGlobals = pGlobals ;
    Parm.SasType = SasType ;

    //
    // Take their username and password and try to log them on
    //
    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx,
            ( (GetDisableCad(pGlobals) && IsActiveConsoleSession()) ? TIMEOUT_NONE : LOGON_TIMEOUT));

    Result = pWlxFuncs->WlxDialogBoxParam(pGlobals->hGlobalWlx,
                                          hDllInstance,
                                          MAKEINTRESOURCE(IDD_LOGON_DIALOG),
                                          NULL,
                                          LogonDlgProc,
                                          (LPARAM) &Parm );

    return(Result);
}


/***************************************************************************\
* FUNCTION: LogonDlgCBProc
*
* PURPOSE:  Processes messages for Logon dialog combo box
*
* RETURNS:  Return value depends on message being sent.
*
* HISTORY:
*
*   05-21-93  RobertRe       Created.
*
\***************************************************************************/

INT_PTR WINAPI
LogonDlgCBProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    TCHAR KeyPressed;

//    DbgPrint("message = %X\n",message);

    switch (message) {
        case WM_CHAR:
            {
                KeyPressed = (TCHAR) wParam;
                SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG)KeyPressed);

                //
                // This fake CBN_SELCHANGE message will cause the
                // "Please wait..." dialog box to appear even if
                // the character pressed doesn't exist in the combobox yet.
                //

                PostMessage (GetParent(hwnd), WM_COMMAND,
                             MAKELONG(0, CBN_SELCHANGE), 0);
                break;
            }
    }

    return CallWindowProc(OldCBWndProc,hwnd,message,wParam,lParam);
}

INT_PTR
CALLBACK
DomainCacheDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PGLOBALS pGlobals ;

    DebugLog(( DEB_TRACE_DOMAIN, "DomainCacheDlgProc( %p, %x, %p, %p )\n",
                hDlg, Message, wParam, lParam ));

    switch ( Message )
    {
        case WM_INITDIALOG:

            pGlobals = (PGLOBALS) lParam ;

            if ( DCacheSetNotifyWindowIfNotReady(
                    pGlobals->Cache,
                    hDlg,
                    WM_DCACHE_COMPLETE ) )
            {
                EndDialog( hDlg, TRUE );
            }

            return TRUE ;

        case WM_DCACHE_COMPLETE:

            EndDialog( hDlg, TRUE );

            return TRUE ;

        default:

            return FALSE ;
    }
}

#ifdef ANNOY_AUTOLOGON_REGISTRY

#define TIMER_COUNTDOWN 0

INT_PTR
CALLBACK
AnnoyAutologonDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    LARGE_INTEGER   Now;
    WCHAR szBuild[10];      // Build number or countdown

    switch ( Message )
    {
    case WM_INITDIALOG:

        pGlobals = (PGLOBALS) lParam ;
        SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pGlobals);

        SetTimer(hDlg, TIMER_COUNTDOWN, 1000, NULL);     // 1 sec

        {
            DWORD cbBuild;
            HKEY hKey;

            DWORD dwStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows NT\\CurrentVersion",
                0,
                KEY_READ,
                &hKey
                );

            cbBuild = sizeof(szBuild);
            wcscpy(szBuild, L"");           // OK

            if (dwStatus == ERROR_SUCCESS)
            {
                DWORD dwType = REG_SZ;

                dwStatus = RegQueryValueEx(
                    hKey,
                    L"CurrentBuildNumber",
                    0,
                    &dwType,
                    (LPBYTE) szBuild,
                    &cbBuild
                    );

                if ((dwStatus != ERROR_SUCCESS) || (dwType != REG_SZ))
                {
                    szBuild[0] = 0;
                }

                RegCloseKey(hKey);
            }

                // 10 sec per build penalty, up to 15 minutes
            cbBuild = _wtol(szBuild);
            if ((0 == cbBuild) || (cbBuild <= 3590))
            {
                cbBuild = 3591;
            }
            if (cbBuild - 3590 > 15 * 6)
            {
                cbBuild = 3590 + 15 * 6;
            }

            GetSystemTimeAsFileTime((FILETIME*) &Now);
            Now.QuadPart += (cbBuild - 3590) * 10 * 10000000I64;

            pGlobals->LastNotification.dwHighDateTime = Now.HighPart;
            pGlobals->LastNotification.dwLowDateTime = Now.LowPart;

            cbBuild = (cbBuild - 3590) * 10;

                // SAFE: "00:XX:YY" is 8+1 characters (fits in 10)
            swprintf(szBuild, L"00:%02d:%02d", (cbBuild/60)%100, cbBuild%60);

            SetDlgItemText(hDlg, IDC_COUNTDOWN_STATIC, szBuild);

        }

        return TRUE ;

    case WM_TIMER:

        if (wParam == TIMER_COUNTDOWN)
        {
            LARGE_INTEGER   End;

            End.HighPart = pGlobals->LastNotification.dwHighDateTime;
            End.LowPart = pGlobals->LastNotification.dwLowDateTime;

            GetSystemTimeAsFileTime((FILETIME*) &Now);

            if (Now.QuadPart >= End.QuadPart)
            {
                EndDialog(hDlg, MSGINA_DLG_SUCCESS);
            }
            else
            {
                DWORD dwMins, dwSecs;

                End.QuadPart -= Now.QuadPart;
                End.QuadPart = End.QuadPart / 10000000I64;  // secs

                dwMins = ((DWORD)End.QuadPart) / 60 % 100;
                dwSecs = ((DWORD)End.QuadPart) % 60;

                    // SAFE: "00:XX:YY" is 8+1 characters (fits in 10)
                swprintf(szBuild, L"00:%02d:%02d", dwMins, dwSecs);

                SetDlgItemText(hDlg, IDC_COUNTDOWN_STATIC, szBuild);
            }

            return TRUE;
        }
        break;

    case WM_DESTROY:
        KillTimer(hDlg, TIMER_COUNTDOWN);
        pGlobals->LastNotification.dwHighDateTime = 0;
        pGlobals->LastNotification.dwLowDateTime = 0;
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam))
        {
        case IDCANCEL:
//            EndDialog(hDlg, MSGINA_DLG_FAILURE);
            return(TRUE);
        }
        break;

    case WLX_WM_SAS:
            // Swallow SAS
        return(TRUE);

    
    }
    return FALSE ;
}
#endif

BOOL    IsAutoLogonUserInteractiveLogonRestricted (HWND hDlg)

{
    WCHAR   szUsername[UNLEN + 1];  // sizeof('\0')

    return((GetDlgItemText(hDlg, IDD_LOGON_NAME, szUsername, ARRAYSIZE(szUsername)) != 0) &&
           !ShellIsUserInteractiveLogonAllowed(szUsername));
}

BOOL    HasDefaultPassword (TCHAR *pszPassword, int cchPassword)

{
    DWORD   dwType, dwPasswordSize;

    dwType = REG_NONE;
    dwPasswordSize = cchPassword * sizeof(TCHAR);
    return(ERROR_SUCCESS == RegQueryValueEx(WinlogonKey,
                                            DEFAULT_PASSWORD_KEY,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)pszPassword,
                                            &dwPasswordSize) &&
          (REG_SZ == dwType));
    
}

NTSTATUS RetrieveStoredSecret(LPCWSTR pswSecretName, WCHAR *PasswordBuffer, int nBufferSize)
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    PUNICODE_STRING SecretValue = NULL;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(
            &SecretName,
            pswSecretName
            );

        Status = LsaRetrievePrivateData(
                    LsaHandle,
                    &SecretName,
                    &SecretValue
                    );
        if (NT_SUCCESS(Status)) {

            if ( SecretValue->Length > 0 ) {

                //
                // If the password fits in the buffer, copy it there
                // and null terminate
                //

                if (SecretValue->Length < (nBufferSize - 1) * sizeof(WCHAR)) {

                    RtlCopyMemory(
                        PasswordBuffer,
                        SecretValue->Buffer,
                        SecretValue->Length
                        );
                    PasswordBuffer[SecretValue->Length/sizeof(WCHAR)] = L'\0';

                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }

                ZeroMemory(SecretValue->Buffer, SecretValue->Length);
            }
            else
            {
                PasswordBuffer[0] = L'\0';
            }

            LsaFreeMemory(SecretValue);
        }
        LsaClose(LsaHandle);
    }

    return Status;
}

// ==========================================================================================
// Logon dialog has 2 formats, one that looks like logon dialog box, another that looks like
// unlock desktop dialogbox. When user connects to session 0 from remote (tsclient) the
// dialog that appears at console // need to change to unlock computer. so if session 0 is in
// use, and if this session is created at active console. we change logon dialog to look like
// "unlock computer" dialog.
// This function SwitchLogonLocked does most of the stuff related to switching these
// dialog controls.
// Parameters:
// HWND hDlg - dialog window handle,
// BOOL bShowLocked - if true show locked dialog, if false show normal logon dialog.
// BOOL bInit - TRUE when this function is called for the first time.
// ==========================================================================================

static bLocked = TRUE;
BOOL IsthisUnlockWindowsDialog ()
{
    return bLocked;
}

BOOL SwitchLogonLocked(HWND hDlg, BOOL bShowLocked, BOOL bInit)
{
    UINT rgidLockControls[] = {IDC_GROUP_UNLOCK, IDD_UNLOCK_ICON, IDD_UNLOCK_MESSAGE, IDD_UNLOCK_NAME_INFO};
    static LockedControlHeight = 0;
    BOOL bShutdownWithoutLogon;
    

    int i;

    if (bShowLocked == bLocked && !bInit)
    {
        // nothing to do.
        return TRUE;
    }

    if (bInit)
    {
        
        {
            //
            // remember the reference rectangle height (groupbox) for control movements.
            //
            RECT rectLockedControls;
            HWND hWnd = GetDlgItem(hDlg, rgidLockControls[0]);
            GetWindowRect(hWnd, &rectLockedControls);
            LockedControlHeight =  rectLockedControls.bottom - rectLockedControls.top;

            //
            // this group box was only for reference, now hide it forever.
            //
            ShowWindow(hWnd, SW_HIDE);

        }

        bLocked = TRUE;
        
        if ( !hLockedIcon )
        {
            hLockedIcon = LoadImage( hDllInstance,
                                     MAKEINTRESOURCE( IDI_LOCKED),
                                     IMAGE_ICON,
                                     0, 0,
                                     LR_DEFAULTCOLOR );
        }

        SendMessage( GetDlgItem( hDlg, IDD_UNLOCK_ICON),
                     STM_SETICON,
                     (WPARAM)hLockedIcon,
                     0 );

    }


    // lets move controls arround, depending upon if lock controls are to be shown or not.
    if (bLocked != bShowLocked)
    {
        if (bShowLocked)
        {
            MoveChildren(hDlg, 0, LockedControlHeight);
            for ( i = 1; i < sizeof(rgidLockControls)/sizeof(rgidLockControls[0]); i++)
            {
                HWND hWnd = GetDlgItem(hDlg, rgidLockControls[i]);
                ASSERT(hWnd);
                EnableWindow(hWnd, TRUE);
                ShowWindow(hWnd, SW_SHOW);
            }

        }
        else
        {
            for ( i = 1; i < sizeof(rgidLockControls)/sizeof(rgidLockControls[0]); i++)
            {
                HWND hWnd = GetDlgItem(hDlg, rgidLockControls[i]);
                ASSERT(hWnd);
                ShowWindow(hWnd, SW_HIDE);
                EnableWindow(hWnd, FALSE);
            }
            MoveChildren(hDlg, 0, -LockedControlHeight);
        }
    }

    // some more processing
    
    {
        if (bShowLocked)
        {
            TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
            TCHAR szMessage[MAX_STRING_BYTES] = TEXT("");
            TCHAR szFinalMessage[MAX_STRING_BYTES] = TEXT("");
            if (GetSessionZeroUser(szUser, USERNAME_LENGTH + DOMAIN_LENGTH + 2))
            {
                LoadString(hDllInstance, IDS_LOCKED_EMAIL_NFN_MESSAGE, szMessage, MAX_STRING_BYTES);
                _snwprintf(szFinalMessage, sizeof(szFinalMessage)/sizeof(TCHAR), szMessage, szUser );
                szFinalMessage[sizeof(szFinalMessage)/sizeof(TCHAR) - 1] = 0;   // NULL terminate
            }
            else
            {
                //
                // for some reason we could not get the current session zero user.
                //
                LoadString(hDllInstance, IDS_LOCKED_NO_USER_MESSAGE, szFinalMessage, MAX_STRING_BYTES);
            }

            SetDlgItemText(hDlg, IDD_UNLOCK_NAME_INFO, szFinalMessage);
        }

        //
        // update the dialog box caption, accordingly
        //
        {
            TCHAR szCaption[MAX_CAPTION_LENGTH] = TEXT("");
            LoadString(hDllInstance, bShowLocked ? IDS_CAPTION_UNLOCK_DIALOG : IDS_CAPTION_LOGON_DIALOG, szCaption, ARRAYSIZE(szCaption));
            if ( szCaption[0] != TEXT('\0') )
                SetWindowText( hDlg, szCaption );
        }
    }

    bLocked = bShowLocked;


    if ( SafeBootMode == SAFEBOOT_MINIMAL )
    {
        bShutdownWithoutLogon = TRUE ;
    }
    else if (IsthisUnlockWindowsDialog() || !IsActiveConsoleSession())
    {
        bShutdownWithoutLogon = FALSE ;
    }
    else
    {
        bShutdownWithoutLogon = ReadWinlogonBoolValue(SHUTDOWN_WITHOUT_LOGON_KEY, TRUE);
    }

    EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, bShutdownWithoutLogon);

    InvalidateRect(hDlg, NULL, TRUE);

    return TRUE;
}

/***************************************************************************\
* FUNCTION: LogonDlgProc
*
* PURPOSE:  Processes messages for Logon dialog
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the user was logged on successfully
*           MSGINA_DLG_FAILURE     - the logon failed,
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/
void MyZeroMemory(PVOID lpv, SIZE_T size);
#define WM_HIDEOURSELVES    (WM_USER + 1000)

INT_PTR WINAPI
LogonDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    INT_PTR Result;
    HWND CBHandle;
    BOOL fDisconnectOnTsAutoLogonFailure = FALSE;
    static BOOL bSessionZeroInUse = FALSE;
    static int iSessionRegistrationCount = 0;
    static BOOL bSmartCardInserted = FALSE;

    switch (message)
    {

        case WM_INITDIALOG:
        {
            TCHAR PasswordBuffer[127];
            BOOL bAutoLogon;
            PMSGINA_LOGON_PARAMETERS pParam ;

            pParam = (PMSGINA_LOGON_PARAMETERS) lParam ;
            pGlobals = pParam->pGlobals ;

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LPARAM)pGlobals);

            // Hide the keyboard accelerator keys to start
            SendMessage(hDlg, WM_CHANGEUISTATE, MAKELONG(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0);

            // Limit the maximum password length to 127
            
            SendDlgItemMessage(hDlg, IDD_LOGON_PASSWORD, EM_SETLIMITTEXT, (WPARAM) 127, 0);

            s_fAttemptedAutoLogon = FALSE;

            //
            // Check if auto logon is enabled.
            //

            pGlobals->AutoAdminLogon = GetProfileInt( APPLICATION_NAME, AUTO_ADMIN_LOGON_KEY, 0 ) != 0;
            bAutoLogon = !pGlobals->IgnoreAutoAdminLogon;

            if ( !pGlobals->AutoAdminLogon || (!g_Console) ||
                 ((GetAsyncKeyState(VK_SHIFT) < 0) && (GetProfileInt( APPLICATION_NAME, IGNORE_SHIFT_OVERRIDE_KEY, 0 ) == 0)) )
            {
                bAutoLogon = FALSE;
            }

            KdPrint(("AutoAdminLogon = %d, IgnoreAutoAdminLogon = %d, bAutoLogon = %d\n",
                     pGlobals->AutoAdminLogon,
                     pGlobals->IgnoreAutoAdminLogon,
                     bAutoLogon ));


            //
            // Subclass the domain list control so we can filter messages
            //

            CBHandle = GetDlgItem(hDlg,IDD_LOGON_DOMAIN);
            SetWindowLongPtr(CBHandle, GWLP_USERDATA, 0);
            OldCBWndProc = (WNDPROC) SetWindowLongPtr(CBHandle, GWLP_WNDPROC, (LONG_PTR)LogonDlgCBProc);

            //
            // Subclass the user name and password edit also so we can disable edits
            //

            SetWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_NAME)    , DisableEditSubClassProc, IDD_LOGON_NAME    , 0);
            SetWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), DisableEditSubClassProc, IDD_LOGON_PASSWORD, 0);

            ShellReleaseLogonMutex(FALSE);

            if (!LogonDlgInit(hDlg, bAutoLogon, pParam->SasType ))
            {
                bSmartCardInserted = FALSE;
                EndDialog(hDlg, MSGINA_DLG_FAILURE);
                return(TRUE);
            }


            //
            // If the default user for auto logon is present and the user is
            // restricted (interactive logon denied) then disable auto logon.
            //

            if (bAutoLogon && IsAutoLogonUserInteractiveLogonRestricted(hDlg))
            {
                bAutoLogon = FALSE;
            }


            //
            // If CAD is disabled, then gray out the Cancel button
            // if we are going to the PIN dialog we will need a cancel button
            //
            if (GetDisableCad(pGlobals) &&
                IsActiveConsoleSession() &&
                (pParam->SasType != WLX_SAS_TYPE_SC_INSERT))
            {
                EnableDlgItem(hDlg, IDCANCEL, FALSE);
            }




            //
            // this dialog has 2 formats, one that looks like logon dialog box,
            // another that looks like unlock desktop dialogbox. 
            // we choose locked one, if session 0 is in use, and if this session is created at 
            // active console.
            //
            if (g_IsTerminalServer && 
                IsActiveConsoleSession() && 
                NtCurrentPeb()->SessionId != 0 &&
                !FastUserSwitchingEnabled() &&
                !_ShellIsFriendlyUIActive())
            {
                TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
                //
                // we are at temporary session created at console...
                //
                
                // check if a user is logged on at console session
                bSessionZeroInUse = GetSessionZeroUser(szUser, USERNAME_LENGTH + DOMAIN_LENGTH + 2);
                if (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, hDlg, NOTIFY_FOR_ALL_SESSIONS))
                {
                    iSessionRegistrationCount++;
                }
                
            }
            else
            {
                //
                // this is not active console nonzero session. 
                //
                bSessionZeroInUse = FALSE;
            }

            //
            // 
            // now switch the control, accordigly to show logon or unlock dialog
            //
            SwitchLogonLocked(hDlg, bSessionZeroInUse, TRUE);

            if (g_IsTerminalServer) {
                BOOL    fForceUPN;
                BOOL    fPopulateFields = TRUE;
                BOOL    fResult = FALSE;
                BOOL    fNoAutologon = FALSE;
                PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pAutoLogon;
                
                //
                // Query network WinStation client credentials for
                // auto logon
                //

                pGlobals->MuGlobals.pAutoLogon =
                   LocalAlloc( LPTR, sizeof(WLX_CLIENT_CREDENTIALS_INFO_V2_0) );

                if (pGlobals->MuGlobals.pAutoLogon) {

                   pGlobals->MuGlobals.pAutoLogon->dwType = WLX_CREDENTIAL_TYPE_V2_0;

                   if (NtCurrentPeb()->SessionId != 0) {
                       fResult = pWlxFuncs->WlxQueryTsLogonCredentials(
                                     pGlobals->MuGlobals.pAutoLogon
                                     );
                   }

                   // Query TermSrv if this was a Session directory redirected SmartCard autoLogon

                   if (fResult && !pGlobals->MuGlobals.pAutoLogon->fPromptForPassword && g_FirstTime) {
                       BOOL fSessionDirectoryRedirectedAutoLogon = FALSE;
                       DWORD Length;

                       if (WinStationQueryInformation(
                                   SERVERNAME_CURRENT,
                                   LOGONID_CURRENT,
                                   WinStationSDRedirectedSmartCardLogon,
                                   &fSessionDirectoryRedirectedAutoLogon,
                                   sizeof(BOOL),
                                   &Length)) {

                           if ( fSessionDirectoryRedirectedAutoLogon ) {

                               //
                               // This is a TS Session directory redirected Smartcard autologon
                               // We should not proceed with normal Autologon for this special case
                               // This is so that Winlogon detects the SmartCard and takes the SmartCard route
                               //
                               fNoAutologon = TRUE;
                           } 

                       }

                   }

                   if (FALSE == g_FirstTime)
                   {
                            // We have tried this password once, no need to retry forever...
                        pGlobals->MuGlobals.pAutoLogon->fPromptForPassword = TRUE;
                   }

                   g_FirstTime = FALSE ; 

                   if ( fResult && !fNoAutologon &&
                        (pGlobals->MuGlobals.pAutoLogon->pszUserName[0] || pGlobals->MuGlobals.pAutoLogon->pszDomain[0] )) {

                        pAutoLogon = pGlobals->MuGlobals.pAutoLogon;
                        fDisconnectOnTsAutoLogonFailure = pAutoLogon->fDisconnectOnLogonFailure;

                        SetupCursor(TRUE); // hourglass cursor

                        fForceUPN = GetProfileInt( APPLICATION_NAME, TEXT("TSForceUPN"), FALSE );
                        if (fForceUPN)
                        {
                            fPopulateFields = FALSE;    // never show old SAM style is UPN is forced
                        }

                        if (pAutoLogon->pszDomain[0] == TEXT('\0') && fForceUPN)
                        {
                            fForceUPN = FALSE;          // domain name not provided, can't apply policy
                        }

                        if (fForceUPN && pGlobals->MuGlobals.pAutoLogon->pszUserName[0] )
                        {
                            LRESULT             iDomain;
                            HWND                hwndDomain;
                            PDOMAIN_CACHE_ENTRY Entry ;
                            ULONG   nSize;

                            // Performance issue.  We don't want to perform a UPN conversion
                            // for local machine accounts (or unknown domains).  When this
                            // happens, the lookup will take a LONG time.

                            hwndDomain = GetDlgItem( hDlg, IDD_LOGON_DOMAIN );
                            iDomain = SendMessage( hwndDomain,
                                                   CB_FINDSTRING,
                                                   (WPARAM) -1,
                                                   (LPARAM) pAutoLogon->pszDomain );
                            fForceUPN = FALSE;  // don't do the conversion
                            if (iDomain != CB_ERR)
                            {
                                Entry = (PDOMAIN_CACHE_ENTRY) SendMessage( hwndDomain, CB_GETITEMDATA, (WPARAM)iDomain, 0);
                                if ( Entry != (PDOMAIN_CACHE_ENTRY) CB_ERR && Entry != NULL)
                                {
                                    switch (Entry->Type)
                                    {
                                    case DomainNt5:
                                        fForceUPN = TRUE;   // Attempt the conversion
                                        break;
                                    }
                                }
                            }


                            // Convert the domain\username into UPN format.
                            // and make sure the dialog is in UPN form.

                            //  2000/10/09 vtan: this function used to have two stack variables
                            //  szOldStyle and szUPNName that were TCHARs of MAX_UPN_NAME_SIZE size. The
                            //  fix for this makes these dynamically allocated to save stack space

                            {
                                TCHAR   *pszOldStyle;
                                TCHAR   *pszUPNName;

                                pszOldStyle = (TCHAR*)LocalAlloc(LMEM_FIXED, MAX_UPN_NAME_SIZE * sizeof(TCHAR));
                                pszUPNName = (TCHAR*)LocalAlloc(LMEM_FIXED, MAX_UPN_NAME_SIZE * sizeof(TCHAR));
                                if ((pszOldStyle != NULL) && (pszUPNName != NULL))
                                {
                                    _snwprintf(pszOldStyle, MAX_UPN_NAME_SIZE, TEXT("%s\\%s"), pAutoLogon->pszDomain, pAutoLogon->pszUserName);
                                    pszOldStyle[MAX_UPN_NAME_SIZE - 1] = 0;
                                    nSize = MAX_UPN_NAME_SIZE;
                                    fResult = TranslateName(
                                                  pszOldStyle,
                                                  NameSamCompatible,
                                                  NameUserPrincipal,
                                                  pszUPNName,
                                                  &nSize
                                               );
                                    if (fResult)
                                    {
                                        // We now have the UPN form of the user account.
                                        SetDlgItemText( hDlg, IDD_LOGON_NAME, pszUPNName);
                                    }
                                }
                                if (pszOldStyle != NULL)
                                {
                                    LocalFree(pszOldStyle);
                                }
                                if (pszUPNName != NULL)
                                {
                                    LocalFree(pszUPNName);
                                }
                            }
                        }

                        if (fPopulateFields)
                        {
                            // display the old SAM style
                            SetDlgItemText( hDlg, IDD_LOGON_NAME, pAutoLogon->pszUserName );
                            SendMessage( GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                         CB_SELECTSTRING,
                                         (WPARAM) -1,
                                         (LPARAM) pAutoLogon->pszDomain );
                        }
                        else
                        {
                            // Enable or disable the domain box depending on whether a UPN name has been typed
                            EnableDomainForUPN(GetDlgItem(hDlg, IDD_LOGON_NAME), GetDlgItem(hDlg, IDD_LOGON_DOMAIN));

                            // Since we're forcing UPN, hide the options dialog, but don't make it sticky
                            LogonShowOptions(pGlobals, hDlg, FALSE, FALSE);
                        }

                        // See if the administrator always wants password prompting

                        if ( TRUE == g_fHelpAssistantLogon || !pAutoLogon->fPromptForPassword ) {
                           SetDlgItemText( hDlg, IDD_LOGON_PASSWORD, pAutoLogon->pszPassword );
                        }

                        DCacheSetDefaultEntry(
                            pGlobals->Cache,
                            pAutoLogon->pszDomain,
                            NULL );

                        if( TRUE == g_fHelpAssistantLogon || !pGlobals->MuGlobals.pAutoLogon->fPromptForPassword )
                        {
                            FreeAutoLogonInfo( pGlobals );

                            // Drop through as if Enter had been pressed...
                            wParam = IDOK;

                            goto go_logon;
                        }
                        else
                        {
                           FreeAutoLogonInfo( pGlobals );
                        }
                   }
                   else
                   {
                        FreeAutoLogonInfo( pGlobals );
                   }
               }
            }
            
            if (pGlobals->SmartCardLogon) {

                bAutoLogon = FALSE;
                pGlobals->AutoAdminLogon = FALSE;

                if ( RetrieveStoredSecret( TEXT("DefaultPIN"), PasswordBuffer, ARRAYSIZE(PasswordBuffer)) == STATUS_SUCCESS )
                {
                    // Ensure we never write more than 127 chars into the password box
                    PasswordBuffer[126] = 0;
                    SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, PasswordBuffer);
                    goto go_logon;
                }
            }

            // save off the auto logon attempt.

            s_fAttemptedAutoLogon = (bAutoLogon != FALSE);

            if (bAutoLogon)
            {
                if (_Shell_LogonDialog_UIHostActive())
                {
                    GetWindowRect(hDlg, &pGlobals->rcDialog);
                    SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                    PostMessage(hDlg, WM_HIDEOURSELVES, 0, 0);
                }
            }
            else
            {
                switch (_Shell_LogonDialog_Init(hDlg, SHELL_LOGONDIALOG_LOGGEDOFF))
                {
                    case SHELL_LOGONDIALOG_NONE:
                    default:
                    {
                        //
                        // If auto logon isn't enabled, set the focus to the
                        // password edit control and leave.
                        //

                        return(SetPasswordFocus(hDlg));
                    }
                    case SHELL_LOGONDIALOG_LOGON:
                    {
                        GetWindowRect(hDlg, &pGlobals->rcDialog);
                        SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                        PostMessage(hDlg, WM_HIDEOURSELVES, 0, 0);
                        goto go_logon;
                    }
                    case SHELL_LOGONDIALOG_EXTERNALHOST:
                    {
                        return(TRUE);
                    }
                }
            }

            //
            // Attempt to auto logon.  If no default password
            // specified, then this is a one shot attempt, which handles
            // the case when auto logging on as Administrator.
            //

            if (HasDefaultPassword(PasswordBuffer, ARRAYSIZE(PasswordBuffer)) != FALSE)
            {
                // Ensure we never write more than 127 chars into the password box
                PasswordBuffer[126] = 0;
                SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, PasswordBuffer);

#ifdef ANNOY_AUTOLOGON_REGISTRY
                pWlxFuncs->WlxDialogBoxParam(
                    pGlobals->hGlobalWlx,
                    hDllInstance,
                    (LPTSTR) IDD_ANNOYAUTOLOGON_DIALOG,
                    hDlg,
                    AnnoyAutologonDlgProc,
                    (LPARAM) pGlobals );
#endif
            }
            else
            {
                NTSTATUS Status;

                Status = RetrieveStoredSecret( DEFAULT_PASSWORD_KEY, PasswordBuffer, ARRAYSIZE(PasswordBuffer) );

                if (NT_SUCCESS(Status)) {

                    SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, PasswordBuffer);
                }
                else
                {
                    WriteProfileString( APPLICATION_NAME, AUTO_ADMIN_LOGON_KEY, TEXT("0") );
                }

            }

go_logon:
            // Zeroize this buffer for obvious security reasons
            // Need to call this stub, otherwise the compiler optimizes this out!
            MyZeroMemory(PasswordBuffer, sizeof(PasswordBuffer));

            // Drop through as if Enter had been pressed...
            wParam = IDOK;
        }

        // nb: deliberate drop through from above

        case WM_COMMAND:
            switch (HIWORD(wParam))
            {

                case CBN_DROPDOWN:
                case CBN_SELCHANGE:

                    DebugLog((DEB_TRACE, "Got CBN_DROPDOWN\n"));

                    if ( !pGlobals->ListPopulated )
                    {
                        WCHAR Buffer[ 2 ];

                        if ( DCacheGetCacheState( pGlobals->Cache ) < DomainCacheRegistryCache )
                        {
                            pWlxFuncs->WlxDialogBoxParam(
                                pGlobals->hGlobalWlx,
                                hDllInstance,
                                (LPTSTR) IDD_WAITDOMAINCACHEVALID_DIALOG,
                                hDlg,
                                DomainCacheDlgProc,
                                (LPARAM) pGlobals );



                        }

                        if ( DCacheGetCacheState( pGlobals->Cache ) == DomainCacheReady )
                        {
                            PDOMAIN_CACHE_ARRAY ActiveArrayBackup ;

                            ActiveArrayBackup = pGlobals->ActiveArray;

                            pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

                            if ( pGlobals->ActiveArray )
                            {
                                DCacheFreeArray( ActiveArrayBackup );   // Not needed anymore

                                Buffer[ 0 ] = (WCHAR) GetWindowLongPtr( GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                                                        GWLP_USERDATA );
                                Buffer[ 1 ] = L'\0';

                                DCachePopulateListBoxFromArray(
                                    pGlobals->ActiveArray,
                                    GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                    Buffer );

                                pGlobals->ListPopulated = TRUE ;
                            }
                            else
                            {
                                    //
                                    // Restore the old array, otherwise the pointers in the
                                    // combo items will point to freed memory
                                    //
                                pGlobals->ActiveArray = ActiveArrayBackup ;
                            }
                        }
                    }


                    break;

                default:

                    switch (LOWORD(wParam))
                    {

                        case IDD_LOGON_NAME:
                            {
                                switch(HIWORD(wParam))
                                {
                                case EN_CHANGE:
                                    {
                                        EnableDomainForUPN((HWND) lParam, GetDlgItem(hDlg, IDD_LOGON_DOMAIN));
                                        return TRUE;
                                    }
                                }
                            }
                            break;
                        case IDOK:

                            //
                            // Deal with combo-box UI requirements
                            //

                            if (HandleComboBoxOK(hDlg, IDD_LOGON_DOMAIN))
                            {
                                return(TRUE);
                            }

                            Result = AttemptLogon( hDlg );

                            if (Result == MSGINA_DLG_FAILURE)
                            {
                                if (!fDisconnectOnTsAutoLogonFailure &&
                                    !g_fHelpAssistantLogon ) {
                                    // Let the user try again

                                    // Clear the password field and set focus to it
                                    SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, NULL);
                                    SetPasswordFocus(hDlg);
                                } else {
                                    bSmartCardInserted = FALSE;
                                    EndDialog(hDlg, MSGINA_DLG_USER_LOGOFF);
                                }

                                return(TRUE);
                            }

                            return(TRUE);

                        case IDCANCEL:
                        {
                            if (!_Shell_LogonDialog_Cancel())
                            {
                                // If this is TS and the user hit ESC at the smart card pin prompt 
                                // we want to switch to the password dialog 
                                if (/*!g_Console && !IsActiveConsoleSession() && */pGlobals->SmartCardLogon) {
                                
                                    EndDialog(hDlg, bSmartCardInserted ? MSGINA_DLG_SMARTCARD_REMOVED : MSGINA_DLG_FAILURE);
                                    bSmartCardInserted = FALSE;
                                    return TRUE;
                                }

                                //
                                // Allow logon screen to go away if not at console
                                //

                                bSmartCardInserted = FALSE;
                                EndDialog(hDlg,  !g_Console ? MSGINA_DLG_USER_LOGOFF
                                                            : MSGINA_DLG_FAILURE);

                                if (g_Console && !IsActiveConsoleSession()) {

                                   pWlxFuncs->WlxDisconnect();
                                }
                            }
                            return(TRUE);
                        }

                        case IDD_LOGON_SHUTDOWN:
                            //
                            // This is a normal shutdown request
                            //
                            // Check they know what they're doing and find
                            // out if they want to reboot too.
                            //

                            // Note that we definitely don't want disconnect or logofff
                            // here since no one is logged on
                            Result = WinlogonShutdownDialog(hDlg, pGlobals, (SHTDN_DISCONNECT | SHTDN_LOGOFF));

                            if (DLG_SHUTDOWN(Result))
                            {
                                _Shell_LogonDialog_ShuttingDown();
                                bSmartCardInserted = FALSE;
                                EndDialog(hDlg, Result);
                            }
                            return(TRUE);

                        case IDD_LOGON_OPTIONS:
                            LogonShowOptions(pGlobals, hDlg, !pGlobals->LogonOptionsShown, TRUE);
                            return(TRUE);

                    }
                    break;

            }
            break;

        case WM_TIMER:
        {
            switch (wParam)
            {
                case 0:
                {
                    HDC hDC;

                    RtlEnterCriticalSection(&pGlobals->csGlobals);

                    if ( pGlobals->LogonInProgress )
                    {
                        if (pGlobals->cxBand != 0)
                        {
                            pGlobals->xBandOffset = (pGlobals->xBandOffset+5) % pGlobals->cxBand;
                        }
                    }
                    else
                    {
                        pGlobals->xBandOffset = 0;
                        KillTimer(hDlg, 0);
                    }

                    RtlLeaveCriticalSection(&pGlobals->csGlobals);

                    hDC = GetDC(hDlg);
                    if ( hDC )
                    {
                        PaintBranding(hDlg, hDC, pGlobals->xBandOffset, TRUE, TRUE, COLOR_BTNFACE);
                        ReleaseDC(hDlg, hDC);
                    }

                    return FALSE;
                }
                case TIMER_MYLANGUAGECHECK:
                {
                    LayoutCheckHandler(hDlg, LAYOUT_DEF_USER);
                    break;
                }
            }
            break;
        }

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, TRUE, COLOR_BTNFACE);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_LOGONCOMPLETE:
        {
            _Shell_LogonDialog_LogonCompleted(lParam, pGlobals->UserName, pGlobals->Domain);
            Result = lParam;

            //
            // Discard the logon in progress dialog if one is displayed
            //

            RtlEnterCriticalSection(&pGlobals->csGlobals);
            pGlobals->LogonInProgress = FALSE;
            RtlLeaveCriticalSection(&pGlobals->csGlobals);

            AttemptLogonSetControls(pGlobals, hDlg);

            if (Result == MSGINA_DLG_FAILURE)
            {
                //
                // reset autoadmin logon flag (Bug 532161)
                //
                pGlobals->AutoAdminLogon = FALSE;

                //
                // erase the stored password, that otherwise (on success)
                // would get erased after the dialog finishes with 
                // MSGINA_DLG_SUCCESS in WlxLoggedOutSAS after Logon
                //
                if (!pGlobals->TransderedCredentials)
                {
                    ErasePassword( &pGlobals->PasswordString );
                }

                if (fDisconnectOnTsAutoLogonFailure || g_fHelpAssistantLogon)
                {
                    //
                    // If TermSrv Internet Connector is on
                    // don't allow a second chance at the logon dialog
                    //

                    bSmartCardInserted = FALSE;
                    EndDialog(hDlg, MSGINA_DLG_USER_LOGOFF);
                    break;
                }

                if (s_fAttemptedAutoLogon != FALSE)
                {
                    s_fAttemptedAutoLogon = FALSE;
                    switch (_Shell_LogonDialog_Init(hDlg, SHELL_LOGONDIALOG_LOGGEDOFF))
                    {
                        case SHELL_LOGONDIALOG_LOGON:
                            goto go_logon;
                            break;
                        case SHELL_LOGONDIALOG_EXTERNALHOST:
                            break;
                        case SHELL_LOGONDIALOG_NONE:
                        default:
                            if (!IsWindowVisible(hDlg))
                            {
                                //
                                // The dialog was hidden for automatic logon. An error occurred.
                                // Show the dialog so the error can be seen and the problem corrected.
                                //
                                SetWindowPos(hDlg, NULL, 0, 0, pGlobals->rcDialog.right - pGlobals->rcDialog.left, pGlobals->rcDialog.bottom - pGlobals->rcDialog.top, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                                ShowWindow(hDlg, SW_SHOW);
                            }
                            break;
                    }
                }

                if (!_Shell_LogonDialog_UIHostActive())
                {
                    // Let the user try again - clear the password
                    SetDlgItemText(hDlg, IDD_LOGON_PASSWORD, NULL);
                    SetPasswordFocus(hDlg);

                    // the logon failed, so lets ensure we show the options pane so they can update
                    // their domain selection if needed.

                    if ( !pGlobals->LogonOptionsShown )
                        LogonShowOptions(pGlobals, hDlg, TRUE, FALSE);
                }
                return(TRUE);
            }


            bSmartCardInserted = FALSE;
            EndDialog( hDlg, Result );
            break;
        }

        case WM_HANDLEFAILEDLOGON:
        {
            if (_Shell_LogonDialog_LogonDisplayError(g_failinfo.Status, g_failinfo.SubStatus))
            {
                if (!IsWindowVisible(hDlg))
                {
                    //
                    // The dialog was hidden for automatic logon. An error occurred.
                    // Show the dialog so the error can be seen and the problem corrected.
                    //
                    SetWindowPos(hDlg, NULL, 0, 0, pGlobals->rcDialog.right - pGlobals->rcDialog.left, pGlobals->rcDialog.bottom - pGlobals->rcDialog.top, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                    ShowWindow(hDlg, SW_SHOW);
                }
                Result = HandleFailedLogon(hDlg);
            }
            else
            {
                Result = MSGINA_DLG_FAILURE;
            }
            SendMessage(hDlg, WM_LOGONCOMPLETE, 0, (LPARAM) Result);
            return TRUE;
        }
        case WLX_WM_SAS:

            // Give the consumer logon part a chance to handle the SAS
            // or to key off the fact that a SAS has occurred.
            (BOOL)_Shell_LogonDialog_DlgProc(hDlg, message, wParam, lParam);

            if ((wParam == WLX_SAS_TYPE_TIMEOUT) ||
                (wParam == WLX_SAS_TYPE_SCRNSVR_TIMEOUT) )
            {
                //
                // If this was a timeout, return false, and let winlogon
                // kill us later
                //

                bSmartCardInserted = FALSE;
                return(FALSE);
            }
            if ( wParam == WLX_SAS_TYPE_SC_INSERT ) {

                //
                // If a password logon is already taking place then ignore this sas
                //
                if (pGlobals->LogonInProgress && !pGlobals->SmartCardLogon)
                {
                    return(TRUE);   
                }

                bSmartCardInserted = TRUE;
                EndDialog( hDlg, MSGINA_DLG_SMARTCARD_INSERTED );

            } else if ( wParam == WLX_SAS_TYPE_SC_REMOVE ) {

                //
                // If a password logon is already taking place then ignore this sas
                //
                if (pGlobals->LogonInProgress && !pGlobals->SmartCardLogon)
                {
                    return(TRUE);   
                }

                if ( bSmartCardInserted ) {

                    bSmartCardInserted = FALSE;
                    EndDialog( hDlg, MSGINA_DLG_SMARTCARD_REMOVED );

                } else if ( pGlobals->SmartCardLogon ) {

                    // If this was a s/c initiated logon, then cancel
                    // the dialog.  Otherwise, ignore it.
                    bSmartCardInserted = FALSE;
                    EndDialog( hDlg, MSGINA_DLG_FAILURE );
                }

            } else if ( wParam == WLX_SAS_TYPE_AUTHENTICATED )
            {
                   bSmartCardInserted = FALSE;
                   _Shell_LogonDialog_LogonCompleted(MSGINA_DLG_SWITCH_CONSOLE, pGlobals->UserName, pGlobals->Domain);
                   EndDialog( hDlg, MSGINA_DLG_SWITCH_CONSOLE );
            }

            return(TRUE);

        case WM_WTSSESSION_CHANGE:
            ASSERT(iSessionRegistrationCount < 2);
            
            //
            // its possible, that we unregister for notification in wm_destroy and still receive this notification,
            // as the notification may already have been sent.
            //
            if (iSessionRegistrationCount == 1)
            {
                if (lParam == 0)
                {
                    //
                    // we are interested only in logon/logoff messages from session 0.
                    //

                    if (wParam == WTS_SESSION_LOGON || wParam == WTS_SESSION_LOGOFF)
                    {
                        bSessionZeroInUse = (wParam == WTS_SESSION_LOGON);
                        SwitchLogonLocked(hDlg, bSessionZeroInUse, FALSE);
                    }
                }
            }
            break;
            

        case WM_DESTROY:
            
            // if registered for notification unregister now.
            if (iSessionRegistrationCount)
            {
                WinStationUnRegisterConsoleNotification (SERVERNAME_CURRENT, hDlg);
                iSessionRegistrationCount--;
                ASSERT(iSessionRegistrationCount == 0);
            }
            _Shell_LogonDialog_Destroy();

            FreeLayoutInfo(LAYOUT_DEF_USER);
            if ( pGlobals->ActiveArray )
            {
                DCacheFreeArray( pGlobals->ActiveArray );
                pGlobals->ActiveArray = NULL ;
            }

            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_NAME),     DisableEditSubClassProc, IDD_LOGON_NAME);
            RemoveWindowSubclass(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), DisableEditSubClassProc, IDD_LOGON_PASSWORD);

            break;

        case WM_HIDEOURSELVES:
            ShowWindow(hDlg, SW_HIDE);
            break;

        default:
            if (_Shell_LogonDialog_DlgProc(hDlg, message, wParam, lParam) != FALSE)
            {
                return(TRUE);
            }
    }

    return(FALSE);
}

SECURITY_STATUS PopulateSecPackageList(
    PGLOBALS pGlobals
    )
{
    static UCHAR s_bDoneThat = 0;

    STRING Narrow;
    SECURITY_STATUS Status;

    //
    // Populate Security Package List:
    //

    if ( ( s_bDoneThat & 1) == 0)
    {
        RtlInitString( &Narrow, MICROSOFT_KERBEROS_NAME_A );

        Status = LsaLookupAuthenticationPackage(
                    pGlobals->LsaHandle,
                    &Narrow,
                    &pGlobals->SmartCardLogonPackage );

        if ( NT_SUCCESS( Status ) )
        {
            s_bDoneThat |= 1;
        }

        //
        // this (potential) failure is not critical.  If it fails, then s/c logons later
        // will fail.
        //
    }

    Status = 0;

    if ( ( s_bDoneThat & 2) == 0)
    {
        RtlInitString( &Narrow, NEGOSSP_NAME_A );

        Status = LsaLookupAuthenticationPackage(
                    pGlobals->LsaHandle,
                    &Narrow,
                    &pGlobals->PasswordLogonPackage );

        if ( NT_SUCCESS( Status ) )
        {
            s_bDoneThat |= 2;
        }
    }

    return Status;
}

/***************************************************************************\
* FUNCTION: LogonDlgInit
*
* PURPOSE:  Handles initialization of logon dialog
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

BOOL
LogonDlgInit(
    HWND    hDlg,
    BOOL    bAutoLogon,
    DWORD   SasType
    )
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    LPTSTR String = NULL;
    TCHAR LogonMsg[MAX_PATH];
    BOOL RemoveLegalBanner;
    BOOL ShowOptions = FALSE;
    HKEY hKey;
    int err;
    DWORD RasDisable;
    DWORD RasForce;
    SECURITY_STATUS Status;
    RECT rc, rc2;
    BOOL bHasLangIcon = FALSE;
    ULONG CacheFlags ;

    //
    // Populate Security Package List:
    //

    Status = PopulateSecPackageList(
                pGlobals );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    //
    // Update the caption for certain banks
    //

    SetWelcomeCaption(hDlg);


    //
    // Get username and domain last used to login
    //

    //
    // Ignore the default user name unless on the active console
    //
    if (IsActiveConsoleSession())
    {
        String = NULL;

        if ( pGlobals->AutoAdminLogon && pGlobals->IgnoreAutoAdminLogon)
        {
            String = AllocAndGetProfileString(APPLICATION_NAME, TEMP_DEFAULT_USER_NAME_KEY, TEXT(""));
        }

        if ( (!String) || (!String[0]) )
        {
            if ( String )
            {
                Free(String);
            }

            String = AllocAndGetProfileString(APPLICATION_NAME, DEFAULT_USER_NAME_KEY, TEXT(""));
        }

        if ( String )
        {
            if (!bAutoLogon && (ReadWinlogonBoolValue(DONT_DISPLAY_LAST_USER_KEY, FALSE) == TRUE))
            {
                String[0] = 0;
            }

            SetDlgItemText(hDlg, IDD_LOGON_NAME, String);
            Free(String);
        }
    }

    GetProfileString( APPLICATION_NAME,
                      DEFAULT_DOMAIN_NAME_KEY,
                      TEXT(""),
                      pGlobals->Domain,
                      MAX_STRING_BYTES );

    if ( !DCacheValidateCache( pGlobals->Cache ) )
    {
        ASSERT( pGlobals->ActiveArray == NULL );

        DCacheUpdateMinimal( pGlobals->Cache, pGlobals->Domain, FALSE );

    }
    else
    {
        //
        // Set the current default:
        //

        DCacheSetDefaultEntry( pGlobals->Cache,
                               pGlobals->Domain,
                               NULL );
    }

    CacheFlags = DCacheGetFlags( pGlobals->Cache );

    if ( ( CacheFlags & DCACHE_NO_CACHE ) &&
         ( SafeBootMode != SAFEBOOT_MINIMAL ) &&
         ( ( pGlobals->AutoAdminLogon ) ||
           ( CacheFlags & DCACHE_DEF_UNKNOWN ) ) )
    {
        //
        // Must wait for the cache to be populated
        //

        DCacheUpdateFull( pGlobals->Cache,
                          pGlobals->Domain );

        CacheFlags = DCacheGetFlags( pGlobals->Cache );
    }
    else
    {
        if ( DCacheGetCacheState( pGlobals->Cache ) != DomainCacheReady )
        {
            DCacheUpdateFullAsync( pGlobals->Cache );
        }
    }

    
    pGlobals->ListPopulated = FALSE ;

    pGlobals->ActiveArray = DCacheCopyCacheArray( pGlobals->Cache );

    if ( pGlobals->ActiveArray )
    {
        DCachePopulateListBoxFromArray( pGlobals->ActiveArray,
                                        GetDlgItem( hDlg, IDD_LOGON_DOMAIN ),
                                        NULL );
    }
    else
    {
        return ( FALSE );
    }

    pGlobals->ShowRasBox = FALSE;

    if (g_Console) {

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\RAS"),
                            0,
                            KEY_READ,
                            & hKey );


        if ( err == 0 )
        {
            RegCloseKey( hKey );

            if ( GetRasDialOutProtocols() )
            {
                if ( ( CacheFlags & DCACHE_MEMBER ) != 0 )
                {
                    pGlobals->ShowRasBox = TRUE;
                }
                else
                {
                    UNICODE_STRING DnsDomain = { 0 } ;

                    if ( GetPrimaryDomainEx( NULL, &DnsDomain, NULL, NULL ) &&
                         ( DnsDomain.Buffer != NULL) )
                    {       // We are "joined" to a MIT realm
                        pGlobals->ShowRasBox = TRUE;
                        LocalFree( DnsDomain.Buffer );
                    }
                }
            }
        }

    }

    //
    // If the audit log is full then display the banner, otherwise
    // load the text from the resource if that gives us a string
    // then set the control.
    //
    // Should neither of these apply then remove the control.
    // The log full info is only displayed at the console so we
    // don't disclose too much info in TS sessions.
    //

    RemoveLegalBanner = FALSE;

    if ( pGlobals->AuditLogFull && !GetSystemMetrics(SM_REMOTESESSION))
    {
        if ( LoadString( hDllInstance, IDS_LOGON_LOG_FULL, LogonMsg, MAX_PATH ) )
        {
            SetDlgItemText( hDlg, IDD_LOGON_ANNOUNCE, LogonMsg );
        }
        else
        {
            RemoveLegalBanner = TRUE;
        }
    }
    else
    {
        String = AllocAndGetProfileString(  APPLICATION_NAME,
                                            LOGON_MSG_KEY, TEXT("") );
        if ( String )
        {
            if ( *String )
            {
                SetDlgItemText( hDlg, IDD_LOGON_ANNOUNCE, String );
            }
            else
            {
                RemoveLegalBanner = TRUE;
            }

            Free( String );
        }
        else
        {
            RemoveLegalBanner = TRUE;
        }
    }

    if ( RemoveLegalBanner )
    {
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_ANNOUNCE), &rc);
        MoveControls(hDlg, ctrlNoLegalBanner,
                     sizeof(ctrlNoLegalBanner)/sizeof(ctrlNoLegalBanner[0]),
                     0, rc.top-rc.bottom,
                     TRUE);

        ShowDlgItem(hDlg, IDD_LOGON_ANNOUNCE, FALSE);
    }

    //
    // Smart Card Specific Stuff:
    //

    if ( SasType == WLX_SAS_TYPE_SC_INSERT )
    {
        //
        // remove the user name fields
        //

        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_NAME), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), &rc2);

        MoveControls(hDlg, ctrlNoUserName,
                     sizeof(ctrlNoUserName)/sizeof(ctrlNoUserName[0]),
                     0, -(rc2.top-rc.top),
                     TRUE);

        ShowDlgItem(hDlg, IDD_LOGON_NAME_LABEL, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_NAME_LABEL, FALSE);

        ShowDlgItem(hDlg, IDD_LOGON_NAME, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_NAME, FALSE);
        SetDlgItemText( hDlg, IDD_LOGON_NAME, TEXT(""));

        LogonMsg[0] = 0;
        LoadString(hDllInstance, IDS_PIN, LogonMsg, MAX_PATH);
        SetDlgItemText( hDlg, IDD_LOGON_PASSWORD_LABEL, LogonMsg );

        pGlobals->SmartCardLogon = TRUE;

    }
    else
    {
        pGlobals->SmartCardLogon = FALSE;
    }

    //
    // If this is safe boot and/or we are not part of a domain then lets
    // remove the domain and nix out the RAS box.
    //

    if ((SafeBootMode == SAFEBOOT_MINIMAL)
            || (!IsMachineDomainMember())
            || (SasType == WLX_SAS_TYPE_SC_INSERT)
            || (ForceNoDomainUI()))
    {
        ShowDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, FALSE);
        ShowDlgItem(hDlg, IDD_LOGON_DOMAIN, FALSE);
        EnableDlgItem(hDlg, IDD_LOGON_DOMAIN, FALSE);

        pGlobals->ShowDomainBox = FALSE;

        // Shorten the window since the domain box isn't used

        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_DOMAIN), &rc2);

        MoveControls(hDlg, ctrlNoDomain,
                     ARRAYSIZE(ctrlNoDomain),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);
    }
    else
    {
        pGlobals->ShowDomainBox = TRUE;
    }


    bHasLangIcon = DisplayLanguageIcon(hDlg, LAYOUT_DEF_USER, GetKeyboardLayout(0));

    //
    // Handle showing the RAS box if needed
    //

    if ( pGlobals->ShowRasBox )
    {
        RasDisable = GetProfileInt( APPLICATION_NAME, RAS_DISABLE, 0 );
        RasForce = GetProfileInt( APPLICATION_NAME, RAS_FORCE, 0 );

        if (RasForce)
        {
            CheckDlgButton( hDlg, IDD_LOGON_RASBOX, 1 );
        }
        else
        {
            CheckDlgButton( hDlg, IDD_LOGON_RASBOX, 0 );
        }

        // SM_CLEANBOOT tells us we are in safe mode. In this case, disable since tapisrv isn't started
        if (RasDisable || RasForce || GetSystemMetrics(SM_CLEANBOOT))
        {
            EnableDlgItem(hDlg, IDD_LOGON_RASBOX, FALSE);
        }
        else
        {
            EnableDlgItem(hDlg, IDD_LOGON_RASBOX, TRUE);
        }
    }
    else
    {
        // If the domain box is hidden, then we'll have to shorten the dialog by the distance
        // between the RAS box and the password box instead of the distance between the
        // RAS box and the domain box since the RAS and Domain boxes will be on top of each other
        BOOL fUsePassword = !pGlobals->ShowDomainBox;

        CheckDlgButton( hDlg, IDD_LOGON_RASBOX, 0 );
        EnableDlgItem(hDlg, IDD_LOGON_RASBOX, FALSE);
        ShowDlgItem(hDlg, IDD_LOGON_RASBOX, FALSE);


        GetWindowRect(GetDlgItem(hDlg, fUsePassword ? IDD_LOGON_PASSWORD : IDD_LOGON_DOMAIN), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_RASBOX), &rc2);
        if (!bHasLangIcon)
        {
            MoveControls(hDlg, ctrlNoRAS,
                     sizeof(ctrlNoRAS)/sizeof(ctrlNoRAS[0]),
                     0, -(rc2.bottom-rc.bottom),
                     TRUE);
        }

    }



    // Centre the window on the screen and bring it to the front

    pGlobals->xBandOffset = 0;          // band is not animated yet

    SizeForBranding(hDlg, TRUE);

    // Position the window at the same coords as the welcome window
    if ((pGlobals->rcWelcome.right - pGlobals->rcWelcome.left) != 0)
    {
        SetWindowPos(hDlg, NULL, pGlobals->rcWelcome.left, pGlobals->rcWelcome.top,
            0, 0, SWP_NOZORDER | SWP_NOSIZE);
    }
    else
    {
        CentreWindow(hDlg);
    }


    //
    // Handle showing and hiding the logon bits
    //

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                 &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType, dwSize = sizeof(ShowOptions);

        if ((ERROR_SUCCESS != RegQueryValueEx (hKey, SHOW_LOGON_OPTIONS, NULL, &dwType,
                        (LPBYTE)&ShowOptions, &dwSize)) ||
            (REG_DWORD != dwType))
        {
            ShowOptions = FALSE;    // restore default
        }

        RegCloseKey (hKey);
    }

    pGlobals->LogonOptionsShown = TRUE;

    LogonShowOptions(pGlobals, hDlg, ShowOptions, TRUE);

    // Success
    return TRUE;
}




/****************************************************************************\
*
* FUNCTION: LogonShowOptions
*
* PURPOSE: Hide the options part of the logon dialog
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   15-dec-97 daviddv - Created
*
\****************************************************************************/
VOID LogonShowOptions(PGLOBALS pGlobals, HWND hDlg, BOOL fShow, BOOL fSticky)
{
    HKEY hKey;
    RECT rc, rc2;
    INT dy = 0;
    INT dx = 0;
    TCHAR szBuffer[32] = TEXT("");
    BOOL bHasLangIcon = TRUE;
    DWORD RasDisable;
    DWORD RasForce;

    if ( pGlobals->LogonOptionsShown != fShow )
    {
        BOOL bShutdownWithoutLogon;

        //
        // Show/hide domain if it is present in the dialog
        //
        if (pGlobals->ShowDomainBox)
        {
            GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_PASSWORD), &rc);
            GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_DOMAIN), &rc2);
            dy += rc2.bottom-rc.bottom;
        }

        //
        // If RAS is present then lets ensure that we remove that.
        //

        if (GetKeyboardLayoutList(0,NULL) < 2)
        {
            bHasLangIcon = FALSE;
        }

        if ( pGlobals->ShowRasBox  || bHasLangIcon)
        {
            // Since the domain box may be hidden with the RAS box directly over
            // top of it, we may need to use the space between the RAS box and the password
            // box
            BOOL fUsePassword = !pGlobals->ShowDomainBox;

            GetWindowRect(GetDlgItem(hDlg, fUsePassword ? IDD_LOGON_PASSWORD : IDD_LOGON_DOMAIN), &rc);
            GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_RASBOX), &rc2);
            dy += rc2.bottom-rc.bottom;
        }

        MoveControls(hDlg, ctrlNoRAS,
                     sizeof(ctrlNoRAS)/sizeof(ctrlNoRAS[0]),
                     0, fShow ? dy:-dy,
                     TRUE);


        // Handle showing or hiding the shutdown button
        // and moving other controls.
        ShowDlgItem(hDlg, IDD_KBLAYOUT_ICON, fShow);
        EnableWindow(GetDlgItem(hDlg, IDD_KBLAYOUT_ICON), fShow);
        ShowDlgItem(hDlg, IDD_LOGON_SHUTDOWN, fShow);

        // Move the OK and Cancel buttons over if we are hiding shutdown
        // ..Calculate one "button space". Assumes shutdown will always be on the left of options
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_SHUTDOWN), &rc);
        GetWindowRect(GetDlgItem(hDlg, IDD_LOGON_OPTIONS), &rc2);

        dx = rc2.left - rc.left;

        // Move OK and Cancel left or right 1 button space
        MoveControls(hDlg, ctrlNoShutdown,
            sizeof(ctrlNoShutdown)/sizeof(ctrlNoShutdown[0]),
            fShow ? -dx:dx, 0,
            FALSE);

        //
        // if ShutdownWithoutLogon, use the proper 3 buttons: OK, Shutdown and Cancel
        // instead of the 2 buttons OK and Cancel
        //



        if ( SafeBootMode == SAFEBOOT_MINIMAL )
        {
            bShutdownWithoutLogon = TRUE ;
        }
        else if (IsthisUnlockWindowsDialog() || !IsActiveConsoleSession())
        {
            bShutdownWithoutLogon = FALSE ;
        }
        else
        {
            bShutdownWithoutLogon = ReadWinlogonBoolValue(SHUTDOWN_WITHOUT_LOGON_KEY, TRUE);
        }


        EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, (fShow) &&
            (bShutdownWithoutLogon));


        if ( pGlobals->ShowRasBox )
        {
            ShowDlgItem(hDlg, IDD_LOGON_RASBOX, fShow);
            RasDisable = GetProfileInt(APPLICATION_NAME, RAS_DISABLE,0);
            RasForce = GetProfileInt(APPLICATION_NAME, RAS_FORCE, 0);

            // Never enable RAS for cleanboot
            if (!GetSystemMetrics(SM_CLEANBOOT) && !RasForce && !RasDisable)
            {
                EnableWindow(GetDlgItem(hDlg, IDD_LOGON_RASBOX), fShow);
            }
        }

        if ( pGlobals->ShowDomainBox )
        {
            ShowDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, fShow);
            EnableWindow(GetDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL), fShow);
            ShowDlgItem(hDlg, IDD_LOGON_DOMAIN, fShow);
            EnableWindow(GetDlgItem(hDlg, IDD_LOGON_DOMAIN), fShow);
        }

        if ( fSticky )
        {
            if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(hKey, SHOW_LOGON_OPTIONS, 0, REG_DWORD,
                                        (LPBYTE)&fShow, sizeof(fShow));
                RegCloseKey (hKey);
            }
        }
    }

    //
    // Change the options button to reflect the open/close state
    //

    LoadString(hDllInstance, fShow ? IDS_LESSOPTIONS:IDS_MOREOPTIONS,
                            szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]));

    SetDlgItemText(hDlg, IDD_LOGON_OPTIONS, szBuffer);

    pGlobals->LogonOptionsShown = fShow;

    // Enable or disable the domain box depending on whether a UPN name has been typed
    EnableDomainForUPN(GetDlgItem(hDlg, IDD_LOGON_NAME), GetDlgItem(hDlg, IDD_LOGON_DOMAIN));
}


/***************************************************************************\
* FUNCTION: AttemptLogonSetControls
*
* PURPOSE:  Sets up the logon UI to animating and controls to the
*           correct state.
*
* HISTORY:
*
*   02-05-98 diz Created
*
\***************************************************************************/

VOID AttemptLogonSetControls(
    PGLOBALS pGlobals,
    HWND hDlg
    )
{
    DWORD RasDisable;
    static BOOL sbRasBoxOriginalyEnabled;
    static BOOL sbShutDownOriginallyEnabled;

    RtlEnterCriticalSection( &pGlobals->csGlobals );

    EnableDlgItem(hDlg, IDD_LOGON_NAME_LABEL, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_NAME, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_PASSWORD_LABEL, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_PASSWORD, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_DOMAIN_LABEL, !pGlobals->LogonInProgress);

    EnableDlgItem(hDlg, IDD_LOGON_DOMAIN, !pGlobals->LogonInProgress);

    // If no logon is in progress, we want to enable domain box based on whether
    // a UPN has been typed
    if (!pGlobals->LogonInProgress)
    {
        EnableDomainForUPN(GetDlgItem(hDlg, IDD_LOGON_NAME), GetDlgItem(hDlg, IDD_LOGON_DOMAIN));
    }

    //
    // MakarP: we should not enable all these control when !pGlobals->LogonInProgress, they should really be reverted back to their original state.
    // but for now I am just looking after IDD_LOGON_RASBOX in remote connection cases to fix bug #267270
    //
    if (pGlobals->LogonInProgress)
    {
        sbRasBoxOriginalyEnabled = IsWindowEnabled(GetDlgItem(hDlg, IDD_LOGON_RASBOX));
        RasDisable = GetProfileInt(APPLICATION_NAME, RAS_DISABLE, 0);
        EnableDlgItem(hDlg, IDD_LOGON_RASBOX, !RasDisable && !pGlobals->LogonInProgress);

        sbShutDownOriginallyEnabled = IsWindowEnabled(GetDlgItem(hDlg, IDD_LOGON_SHUTDOWN));
        EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, !pGlobals->LogonInProgress);
    }
    else
    {
        EnableDlgItem(hDlg, IDD_LOGON_RASBOX, sbRasBoxOriginalyEnabled);
        EnableDlgItem(hDlg, IDD_LOGON_SHUTDOWN, sbShutDownOriginallyEnabled);
    }



    EnableDlgItem(hDlg, IDD_KBLAYOUT_ICON, !pGlobals->LogonInProgress);
    EnableDlgItem(hDlg, IDD_LOGON_OPTIONS, !pGlobals->LogonInProgress);

    //
    // if ShutdownWithoutLogon, use the proper 3 buttons: OK, Shutdown and Cancel
    // instead of the 2 buttons OK and Cancel
    //


    EnableDlgItem(hDlg, IDOK, !pGlobals->LogonInProgress);

    //
    // the logic of enabling the CANCEL button is as follows
    //  - if a logon is in progress always disable it (not allowed to cancel)
    //  - else if a SC logon always enable it (always allow to get to CAD)
    //  - else gray it only when DisableCAD and is set and we're in
    //    the active session (i.e. TS always allows Cancel)
    //
    if( pGlobals->LogonInProgress )
    {
        EnableDlgItem(hDlg, IDCANCEL, FALSE);
    }
    else
    {
        if( pGlobals->SmartCardLogon )
        {
            EnableDlgItem(hDlg, IDCANCEL, TRUE);
        }
        else
        {
            EnableDlgItem(hDlg, IDCANCEL,
                          !(GetDisableCad(pGlobals) &&
                            IsActiveConsoleSession()) );
        }
    }

    RtlLeaveCriticalSection( &pGlobals->csGlobals );
}



/***************************************************************************\
* FUNCTION: AttemptLogon
*
* PURPOSE:  Tries to the log the user on using the current values in the
*           logon dialog controls
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the user was logged on successfully
*           MSGINA_DLG_FAILURE     - the logon failed,
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* NOTES:    If the logon is successful, the global structure is filled in
*           with the logon information.
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR
AttemptLogon(
    HWND    hDlg
)
{
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PWCHAR  UserName = pGlobals->UserName;
    PWCHAR  Domain = pGlobals->Domain;
    PWCHAR  Password = pGlobals->Password;
    PDOMAIN_CACHE_ENTRY Entry ;
    RECT    rc;
    HANDLE  hThread;
    DWORD   tid;
    BOOL    timeout;
    PUCHAR  Dummy;
    BOOL    RasBox;
    DWORD   dwAnimationTimeSlice;

    UserName[0] = TEXT('\0');
    Domain[0] = TEXT('\0');
    Password[0] = TEXT('\0');

    //
    // Hide the password so it doesn't make it to the pagefile in
    // cleartext.  Do this before getting the username and password
    // so that it can't easily be identified (by association with
    // the username and password) if we should crash or be rebooted
    // before getting a chance to encode it.
    //

    GetDlgItemText(hDlg, IDD_LOGON_PASSWORD, Password, MAX_STRING_BYTES);
    RtlInitUnicodeString(&pGlobals->PasswordString, Password);
    pGlobals->Seed = 0; // Causes the encode routine to assign a seed
    HidePassword( &pGlobals->Seed, &pGlobals->PasswordString );


    //
    // Now get the username and domain
    //

    if ( pGlobals->SmartCardLogon == FALSE )
    {
        HWND hwndDomain = GetDlgItem(hDlg, IDD_LOGON_DOMAIN);

        if (hwndDomain != NULL)
        {
            INT iDomainSel = (INT)SendMessage(hwndDomain, CB_GETCURSEL, 0, 0);

            GetDlgItemText(hDlg, IDD_LOGON_NAME, UserName, MAX_STRING_BYTES);

            //
            // is this the magical "this computer" entry???
            // If so, set local domain flag used by password UI to show/notshow password restore
            //

            pGlobals->fLocalDomain = FALSE;
            Entry = (PDOMAIN_CACHE_ENTRY) SendMessage( hwndDomain, CB_GETITEMDATA, (WPARAM)iDomainSel, 0);
            if (CB_ERR != (ULONG_PTR) Entry)
            {
                if (NULL != Entry)
                {
                    if (Entry->Type == DomainMachine)
                    {
                        pGlobals->fLocalDomain = TRUE;
                    }
                }
            }
        }
        else
        {
            Entry = (PDOMAIN_CACHE_ENTRY) CB_ERR;
        }
        if ( (Entry != (PDOMAIN_CACHE_ENTRY) CB_ERR) && (NULL != Entry))
        {
                // MAX_STRING_BYTES is the size of pGlobals->Domain (WlxInitialize)
                // Truncation should never occur
            lstrcpyn( Domain, Entry->FlatName.Buffer, MAX_STRING_BYTES );
        }
        else
        {
            Domain[0] = L'\0';
        }

    }
    else
    {
        UserName[0] = TEXT('\0');
        Domain[0] = TEXT('\0') ;
    }

    // If we are forcing a NoDomainUI, populate the domain with the local machine name now
    if (ForceNoDomainUI())
    {
        DWORD chSize = MAX_STRING_BYTES;
        pGlobals->fLocalDomain = TRUE;

        if (GetComputerName(Domain, &chSize))
        {
            NOTHING;
        }
        else
        {
            *Domain = 0;
        }
    }

    //
    // If there is a at-sign in the name, assume that means that a UPN logon
    // attempt is being made.  Set the domain to NULL.
    //

    if ( wcspbrk( UserName, L"@\\" ) )
    {
        Domain[0] = TEXT('\0');
    }

    RtlInitUnicodeString(&pGlobals->UserNameString, UserName);
    RtlInitUnicodeString(&pGlobals->DomainString, Domain);

    //
    // Ok, is the RASbox checked?
    //

    RasBox = IsDlgButtonChecked( hDlg, IDD_LOGON_RASBOX );
    pGlobals->RasUsed = FALSE;

    if ( RasBox == BST_CHECKED )
    {
        //
        // Reset the current timeout so that they neatly clean up before
        // winlogon up and blows them away.
        //

        pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, 5 * 60 );

        if ( !PopupRasPhonebookDlg( hDlg, pGlobals, &timeout) )
        {
            return( MSGINA_DLG_FAILURE );
        }

        pGlobals->RasUsed = TRUE;

        //
        // Reinitialize strings in case they've changed
        //

        RtlInitUnicodeString( &pGlobals->UserNameString, UserName );

        //
        // Ping Netlogon to allow us to go out on the net again...
        //

        I_NetLogonControl2(NULL,
                            NETLOGON_CONTROL_TRANSPORT_NOTIFY,
                            1, (LPBYTE) &Dummy, &Dummy );

        Sleep ((DWORD) ReadWinlogonBoolValue(TEXT("RASSleepTime"), 3000));
        RefreshPolicy(TRUE);
    }

    //
    // Process arguments before kicking off the thread
    //
    pGlobals->hwndLogon = hDlg;

    RtlEnterCriticalSection( &pGlobals->csGlobals );
    pGlobals->LogonInProgress = TRUE ;
    RtlLeaveCriticalSection( &pGlobals->csGlobals );

    GetClientRect(hDlg, &rc);
    pGlobals->cxBand = rc.right-rc.left;

    dwAnimationTimeSlice = GetAnimationTimeInterval(pGlobals);

    // setup the progress timer
    SetTimer(hDlg, 0, dwAnimationTimeSlice, NULL); 

    //
    // Kick off real logon thread
    //

    // Set timeout to infinite while attempting to logon
    pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, TIMEOUT_NONE );

    hThread = CreateThread( NULL, 0,
                            AttemptLogonThread,
                            pGlobals,
                            0, &tid );

    if (hThread)
    {
        CloseHandle( hThread );
    }
    else
    {
        //
        // CreateThread failed, likely because of low memory.
        // Inform the user.
        //

        PostFailedLogonMessage(pGlobals->hwndLogon,
                               pGlobals,
                               GetLastError(),
                               0,
                               NULL,
                               NULL);

        RtlEnterCriticalSection( &pGlobals->csGlobals );
        pGlobals->LogonInProgress = FALSE ;
        RtlLeaveCriticalSection( &pGlobals->csGlobals );
        return MSGINA_DLG_FAILURE ;
    }

    AttemptLogonSetControls(pGlobals, hDlg);

    return MSGINA_DLG_SUCCESS;
}

BOOL    ReplacedPossibleDisplayName (WCHAR *pszUsername, int nUserMax)

{
    BOOL                fReplaced;
    DWORD               dwIndex, dwReturnedEntryCount;
    NET_API_STATUS      nasCode;
    NET_DISPLAY_USER    *pNDU;

    fReplaced = FALSE;
    if (*pszUsername)   // Name is not empty (Admin has empty full name by default...)
    {
        dwIndex = 0;
        nasCode = NetQueryDisplayInformation(NULL,
                                             1,
                                             dwIndex,
                                             1,
                                             sizeof(NET_DISPLAY_USER),
                                             &dwReturnedEntryCount,
                                             (void**)&pNDU);
        while (!fReplaced &&
               (dwReturnedEntryCount > 0) &&
               (NERR_Success == nasCode) || (ERROR_MORE_DATA == nasCode))
        {
            fReplaced = (lstrcmpiW(pNDU->usri1_full_name, pszUsername) == 0);
            if (fReplaced)
            {
                lstrcpyn(pszUsername, pNDU->usri1_name, nUserMax);   // Zero terminated
            }
            nasCode = NetApiBufferFree(pNDU);
            if (!fReplaced)
            {
                nasCode = NetQueryDisplayInformation(NULL,
                                                     1,
                                                     ++dwIndex,
                                                     1,
                                                     sizeof(NET_DISPLAY_USER),
                                                     &dwReturnedEntryCount,
                                                     (void**)&pNDU);
            }
        }
    }
    return(fReplaced);
}

BOOL    ReplacedLogonName (PGLOBALS pGlobals)

{
    BOOL    fReplaced;

        // MAX_STRING_BYTES is the size of pGlobals->UserName (WlxInitialize)
    fReplaced = ReplacedPossibleDisplayName(pGlobals->UserName, MAX_STRING_BYTES);
    if (fReplaced)
    {
        RtlInitUnicodeString(&pGlobals->UserNameString, pGlobals->UserName);
    }
    return(fReplaced);
}

DWORD
AttemptLogonThread(
    PGLOBALS pGlobals
    )
{
    STRING  PackageName;
    PSID    LogonSid;
    PSID    DuplicatedLogonSID;
    LUID    LogonId = { 0, 0 };
    HANDLE  UserToken = NULL;
    HANDLE  RestrictedToken;
    BOOL    PasswordExpired, ChangedLogonName;
    NTSTATUS FinalStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus = STATUS_SUCCESS;
    INT_PTR Result = MSGINA_DLG_FAILURE;
    ULONG   LogonPackage;
    BYTE    GroupsBuffer[sizeof(TOKEN_GROUPS)+sizeof(SID_AND_ATTRIBUTES)];
    PTOKEN_GROUPS TokenGroups = (PTOKEN_GROUPS) GroupsBuffer;
    PVOID   AuthInfo ;
    ULONG   AuthInfoSize ;
    UCHAR   UserBuffer[ SID_MAX_SUB_AUTHORITIES * sizeof( DWORD ) + 8 + sizeof( TOKEN_USER ) ];
    PTOKEN_USER pTokenUser ;
    ULONG   TokenInfoSize ;
    PUCHAR  SmartCardInfo ;
    SECURITY_LOGON_TYPE     logonType;
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL ;

#ifdef SMARTCARD_DOGFOOD
    DWORD StartTime = 0, EndTime = 0;
#endif

    //
    // Store the logon time
    // Do this before calling Lsa so we know if logon is successful that
    // the password-must-change time will be greater than this time.
    // If we grabbed this time after calling the lsa, this might not be true.
    //


    if ( IsActiveConsoleSession()  )
    {
        // this is the console logon;
        logonType = Interactive;
    }
    else
    {
        // remote sessions user must have the SeRemoteInteractiveLogonRight right which
        // is granted to a user due to their membership in the new Remote-Desktop Users group.
        logonType = RemoteInteractive;
    }

    GetSystemTimeAsFileTime( (LPFILETIME) &pGlobals->LogonTime );

    DebugLog((DEB_TRACE, "In Attempt Logon!\n"));

    if ( pGlobals->RasUsed )
    {
        if ( DCacheGetCacheState( pGlobals->Cache ) < DomainCacheRegistryCache )
        {
            //
            // We are using really stale data.  Poke the cache to get it to use the
            // now made RAS connection
            //

            DCacheUpdateMinimal( pGlobals->Cache, NULL, TRUE );
        }
    }

    SetupCursor( TRUE );

    FinalStatus = STATUS_SUCCESS;

    //
    // Generate a unique sid for this logon.
    // Duplicate the SID. It is possible that the function that called
    // the thread (and created the SID originally) may return causing
    // the SID to be freed while this thread is still running.
    // (see bug# 478186).
    // the solution was to duplicate the SID here and free it at the end
    // This still leaves a "small" window between starting the thread
    // and duplicating the token where freeing may potentially cause the
    // same problem (if the pGlobal->LogonSID is freed but not NULL'ed in
    // which case duplication will fail)
    // Notes:
    //  - if the duplication fails abort this
    //  - there is no need to actually verify the SID on free time
    //    at this point.
    //
    LogonSid = DuplicatedLogonSID = DuplicateSID(pGlobals->LogonSid);
    if( NULL == LogonSid )
    {
        FinalStatus = STATUS_NO_MEMORY ;
        Status = FinalStatus ;
    }
    else
    {
        if ( !wcspbrk( pGlobals->UserName, L"@\\" ) &&
             wcschr( pGlobals->UserName, L'/' ))
        {
            FinalStatus = STATUS_LOGON_FAILURE ;
            Status = FinalStatus ;
        }
    }

    // clear card and reader name
    pGlobals->Smartcard[0] = TEXT('\0');
    pGlobals->SmartcardReader[0] = TEXT('\0');

    if ( NT_SUCCESS( FinalStatus ) )
    {
        if ( pGlobals->SmartCardLogon )
        {
            pGlobals->AuthenticationPackage = pGlobals->SmartCardLogonPackage ;
        }
        else
        {
            pGlobals->AuthenticationPackage = pGlobals->PasswordLogonPackage ;

        }

        if ( pGlobals->SmartCardLogon )
        {
            pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_SMART_CARD_INFO,
                                     (ULONG_PTR *) &ScInfo );

            if ( !ScInfo )
            {
                goto exit;
            }


            SmartCardInfo = ScBuildLogonInfo(
                                ScInfo->pszCard,
                                ScInfo->pszReader,
                                ScInfo->pszContainer,
                                ScInfo->pszCryptoProvider );

            if(ScInfo->pszCard && ScInfo->pszReader) {

                lstrcpyn(
                    pGlobals->Smartcard, 
                    ScInfo->pszCard, 
                    sizeof(pGlobals->Smartcard) / sizeof(TCHAR)
                    );

                lstrcpyn(
                    pGlobals->SmartcardReader, 
                    ScInfo->pszReader, 
                    sizeof(pGlobals->SmartcardReader) / sizeof(TCHAR)
                    );

            }

#ifndef SMARTCARD_DOGFOOD
            LocalFree( ScInfo );
#endif

            AuthInfo = FormatSmartCardCredentials(
                            &pGlobals->PasswordString,
                            SmartCardInfo,
                            FALSE,
                            NULL,
                            &AuthInfoSize );

            LocalFree( SmartCardInfo );

        }
        else
        {
            AuthInfo = FormatPasswordCredentials(
                            &pGlobals->UserNameString,
                            &pGlobals->DomainString,
                            &pGlobals->PasswordString,
                            FALSE,
                            NULL,
                            &AuthInfoSize );

        }

        //
        // Actually try to logon the user
        //

#ifdef SMARTCARD_DOGFOOD
        StartTime = GetTickCount();
#endif

        FinalStatus = WinLogonUser(
                            pGlobals->LsaHandle,
                            pGlobals->AuthenticationPackage,
                            logonType,
                            AuthInfo,
                            AuthInfoSize,
                            LogonSid,
                            &LogonId,
                            &UserToken,
                            &pGlobals->UserProcessData.Quotas,
                            (PVOID *)&pGlobals->Profile,
                            &pGlobals->ProfileLength,
                            &SubStatus,
                            &pGlobals->OptimizedLogonStatus);

#ifdef SMARTCARD_DOGFOOD
        EndTime = GetTickCount();
#endif

        Status = FinalStatus;
    }

    SetupCursor( FALSE );

    RtlEnterCriticalSection( &pGlobals->csGlobals );
    pGlobals->LogonInProgress = FALSE;
    RtlLeaveCriticalSection( &pGlobals->csGlobals );

    DebugLog((DEB_TRACE, "WinLogonUser returned %#x\n", Status));

    PasswordExpired = (((Status == STATUS_ACCOUNT_RESTRICTION) && (SubStatus == STATUS_PASSWORD_EXPIRED)) ||
                           (Status == STATUS_PASSWORD_MUST_CHANGE));

    //
    // If the account has expired we let them change their password and
    // automatically retry the logon with the new password.
    //

    if (PasswordExpired)
    {
        _Shell_LogonDialog_HideUIHost();

        if( pGlobals->SmartCardLogon )
        {
            //
            // this was a SC logon that failed because the account had
            // a password that expired. Put an error message and exit
            //
            TimeoutMessageBox(pGlobals->hwndLogon, pGlobals,
                              IDS_LOGON_SMARTCARD_PWD_CHANGE,
                              IDS_LOGON_MESSAGE,
                              MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                              LOGON_TIMEOUT);
            Result = MSGINA_DLG_FAILURE;
            goto exit;
        }

        if (Status == STATUS_PASSWORD_MUST_CHANGE)
        {

            Result = TimeoutMessageBox(pGlobals->hwndLogon, pGlobals, IDS_PASSWORD_MUST_CHANGE,
                                             IDS_LOGON_MESSAGE,
                                             MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                                             LOGON_TIMEOUT);

        }
        else
        {

            Result = TimeoutMessageBox(pGlobals->hwndLogon, pGlobals, IDS_PASSWORD_EXPIRED,
                                             IDS_LOGON_MESSAGE,
                                             MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                                             LOGON_TIMEOUT);

        }

        if (DLG_INTERRUPTED(Result) || (WLX_DLG_INPUT_TIMEOUT == Result))
            goto exit;

        //
        // Copy the old password for mpr notification later
        //

        RevealPassword( &pGlobals->PasswordString  );
            // pGlobals->Password has the same size as pGlobals->OldPassword (WlxInitialize)
            // so no need to zero terminate
        wcsncpy(pGlobals->OldPassword, pGlobals->Password, MAX_STRING_BYTES);
        pGlobals->OldSeed = 0;
        RtlInitUnicodeString(&pGlobals->OldPasswordString, pGlobals->OldPassword);
        HidePassword( &pGlobals->OldSeed, &pGlobals->OldPasswordString);
        pGlobals->OldPasswordPresent = 1;

        //
        // Let the user change their password
        //

        LogonPackage = pGlobals->AuthenticationPackage ;

        RtlInitString(&PackageName, MSV1_0_PACKAGE_NAME );
        Status = LsaLookupAuthenticationPackage (
                    pGlobals->LsaHandle,
                    &PackageName,
                    &pGlobals->AuthenticationPackage
                    );

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to find %s authentication package, status = 0x%lx",
                    MSV1_0_PACKAGE_NAME, Status));

            Result = MSGINA_DLG_FAILURE;
            goto exit;
        }


        Result = ChangePasswordLogon(pGlobals->hwndLogon, pGlobals,
                                     pGlobals->UserName,
                                     pGlobals->Domain,
                                     pGlobals->Password);

        pGlobals->AuthenticationPackage = LogonPackage ;

        if (DLG_INTERRUPTED(Result))
            goto exit;

        if (Result == MSGINA_DLG_FAILURE)
        {
            // The user doesn't want to, or failed to change their password.
                goto exit;
        }
    }

    // Special handling for failed logon on personal or professional
    // machines that are NOT joined to a domain. In this case it's
    // probably a user who disabled friendly UI and only knows of
    // their "display name" not their real "logon name". This
    // transparently maps one to the other to allow logons using
    // the "display name".

    ChangedLogonName = ((FinalStatus == STATUS_LOGON_FAILURE) &&
                        (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL)) &&
                        !IsMachineDomainMember() &&
                        ReplacedLogonName(pGlobals));

    if (PasswordExpired || ChangedLogonName)
    {

        //
        // Retry the logon with the changed password
        //

        //
        // Generate a unique sid for this logon
        //
        LogonSid = DuplicatedLogonSID;

        AuthInfo = FormatPasswordCredentials(
                        &pGlobals->UserNameString,
                        &pGlobals->DomainString,
                        &pGlobals->PasswordString,
                        FALSE,
                        NULL,
                        &AuthInfoSize );


        Status = WinLogonUser(
                            pGlobals->LsaHandle,
                            pGlobals->AuthenticationPackage,
                            logonType,
                            AuthInfo,
                            AuthInfoSize,
                            LogonSid,
                            &LogonId,
                            &UserToken,
                            &pGlobals->UserProcessData.Quotas,
                            (PVOID *)&pGlobals->Profile,
                            &pGlobals->ProfileLength,
                            &SubStatus,
                            &pGlobals->OptimizedLogonStatus);

    }

    //
    // Deal with a terminally failed logon attempt
    //
    if (!NT_SUCCESS(Status))
    {
        //
        // Do lockout processing
        //

        LockoutHandleFailedLogon(pGlobals);

        Result = MSGINA_DLG_FAILEDMSGSENT;

        PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, Status, SubStatus, pGlobals->UserName, pGlobals->Domain);

        goto exit;
    }


    //
    // The user logged on successfully
    //


    //
    // Do lockout processing
    //

    LockoutHandleSuccessfulLogon(pGlobals);



    //
    // If the audit log is full, check they're an admin
    //

    if (pGlobals->AuditLogFull)
    {

        //
        // The audit log is full, so only administrators are allowed to logon.
        //

        if (!UserToken || !TestTokenForAdmin(UserToken))
        {

            //
            // The user is not an administrator, boot 'em.
            //

            LsaFreeReturnBuffer(pGlobals->Profile);
            pGlobals->Profile = NULL;
            NtClose(UserToken);

            Result = MSGINA_DLG_FAILEDMSGSENT;

                // Post a specific substatus so we can display a meaningful error message
            PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, STATUS_LOGON_FAILURE, IDS_LOGON_LOG_FULL, pGlobals->UserName, pGlobals->Domain);

            goto exit;
        }
        else
        {
            //
            // If we are in a session, we didn't display the log full onfo on the welcome
            // screen, so tell the admin
            //

            if (GetSystemMetrics(SM_REMOTESESSION))
            {
                TimeoutMessageBox(
                    pGlobals->hwndLogon,
                    pGlobals,
                    IDS_LOGON_LOG_FULL_ADMIN,
                    IDS_LOGON_MESSAGE,
                    MB_OK | MB_ICONSTOP | MB_SETFOREGROUND,
                    TIMEOUT_CURRENT);
            }
        }
    }

    //
    // Force smart card logon for normal boot
    //
    if(!pGlobals->SmartCardLogon &&
      (SafeBootMode != SAFEBOOT_MINIMAL) && (SafeBootMode != SAFEBOOT_DSREPAIR) &&
       GetSCForceOption() )
    {
        //
        // not a safe boot - boot 'em.
        //
        LsaFreeReturnBuffer(pGlobals->Profile);
        pGlobals->Profile = NULL;
        NtClose(UserToken);

        Result = MSGINA_DLG_FAILEDMSGSENT;

        // Post a specific substatus so we can display a meaningful error message
        PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals,
                               STATUS_LOGON_FAILURE, IDS_LOGON_SC_REQUIRED,
                               pGlobals->UserName, pGlobals->Domain);

        goto exit;
    }

    //
    // Hide ourselves before letting other credential managers put
    // up dialogs
    //

#if 0
    ShowWindow(hDlg, SW_HIDE);
#endif

    //
    // Create a filtered version of the token for running normal applications
    // if so indicated by a registry setting
    //


    if (GetProfileInt( APPLICATION_NAME, RESTRICT_SHELL, 0) != 0) {

        TokenGroups->Groups[0].Attributes = 0;
        TokenGroups->Groups[0].Sid = gAdminSid;
        TokenGroups->GroupCount = 1;

        Status = NtFilterToken(
                    UserToken,
                    DISABLE_MAX_PRIVILEGE,
                    TokenGroups,   // disable the administrators sid
                    NULL,           // no privileges
                    NULL,
                    &RestrictedToken
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to filter token: 0x%%x\n", Status));
            RestrictedToken = NULL;
        }

        //
        // Now set the default dacl for the token
        //

        {
            PACL Dacl = NULL;
            ULONG DaclLength = 0;
            TOKEN_DEFAULT_DACL DefaultDacl;

            DaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(LogonSid);
            Dacl = Alloc(DaclLength);
            Status = RtlCreateAcl(Dacl,DaclLength, ACL_REVISION);
            ASSERT(NT_SUCCESS(Status));
            Status = RtlAddAccessAllowedAce(
                        Dacl,
                        ACL_REVISION,
                        GENERIC_ALL,
                        LogonSid
                        );
            ASSERT(NT_SUCCESS(Status));
            DefaultDacl.DefaultDacl = Dacl;
            Status = NtSetInformationToken(
                        RestrictedToken,
                        TokenDefaultDacl,
                        &DefaultDacl,
                        sizeof(TOKEN_DEFAULT_DACL)
                        );
            ASSERT(NT_SUCCESS(Status));

            Free(Dacl);
        }


    } else {
        RestrictedToken = NULL;
    }

    //
    // Notify credential managers of the successful logon
    //

    pTokenUser = (PTOKEN_USER) UserBuffer ;
    Status = NtQueryInformationToken( UserToken,
                                      TokenUser,
                                      pTokenUser,
                                      sizeof( UserBuffer ),
                                      &TokenInfoSize );

    if ( NT_SUCCESS( Status ) )
    {
        pGlobals->UserProcessData.UserSid = LocalAlloc( LMEM_FIXED,
                                            RtlLengthSid( pTokenUser->User.Sid ) );

        if ( pGlobals->UserProcessData.UserSid )
        {
            RtlCopyMemory( pGlobals->UserProcessData.UserSid,
                           pTokenUser->User.Sid,
                           RtlLengthSid( pTokenUser->User.Sid ) );
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {

        if (pGlobals->Profile)
        {
            LsaFreeReturnBuffer(pGlobals->Profile);
            pGlobals->Profile = NULL;
        }
        NtClose(UserToken);

        Result = MSGINA_DLG_FAILEDMSGSENT;

        PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, Status, 0, pGlobals->UserName, pGlobals->Domain);

        goto exit;
    }

    pGlobals->UserProcessData.NewThreadTokenSD = CreateUserThreadTokenSD(LogonSid, pWinlogonSid);
    if ( NULL == pGlobals->UserProcessData.NewThreadTokenSD )
    {
        if (pGlobals->Profile)
        {
            LsaFreeReturnBuffer(pGlobals->Profile);
            pGlobals->Profile = NULL;
        }
        NtClose(UserToken);

        Result = MSGINA_DLG_FAILEDMSGSENT;
        Status = STATUS_NO_MEMORY;

        PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, Status, 0, pGlobals->UserName, pGlobals->Domain);

        goto exit;
    }
    pGlobals->UserProcessData.RestrictedToken = RestrictedToken;
    pGlobals->UserProcessData.UserToken = UserToken;

    pGlobals->MprLogonScripts = NULL;

     // Run the dirty dialog box.
    if ( WinlogonDirtyDialog( NULL, pGlobals ) == WLX_SAS_ACTION_LOGOFF )
    {
        //
        // If this returns logoff, it means that the dialog timed out and
        // we need to force the user back off.  Not the best user experience,
        // but that's what the PMs want.
        //
        FreeSecurityDescriptor( pGlobals->UserProcessData.NewThreadTokenSD );

        LsaFreeReturnBuffer(pGlobals->Profile);
        pGlobals->Profile = NULL;
        NtClose(UserToken);

        Result = MSGINA_DLG_FAILEDMSGSENT;

        // Post a specific substatus so we can display a meaningful error message
        PostFailedLogonMessage(pGlobals->hwndLogon, pGlobals, STATUS_LOGON_FAILURE, IDS_SET_DIRTY_UI_TIMEOUT, pGlobals->UserName, pGlobals->Domain);

        goto exit;
    }
    
    //
    // If we get here, the system works well enough for the user to have
    // actually logged on.  Profile failures aren't fixable by last known
    // good anyway.  Therefore, declare the boot good.
    //

    ReportBootGood(pGlobals);

    //
    // Set up the system for the new user
    //

    pGlobals->LogonId = LogonId;
    if ((pGlobals->Profile != NULL) && (pGlobals->Profile->FullName.Length > 0)) {
        DWORD cb = pGlobals->Profile->FullName.Length;
        if (cb + sizeof(WCHAR) > MAX_STRING_LENGTH * sizeof(WCHAR))
            cb = MAX_STRING_LENGTH * sizeof(WCHAR) - sizeof(WCHAR);

        memcpy(pGlobals->UserFullName, pGlobals->Profile->FullName.Buffer, cb);
        pGlobals->UserFullName[cb / sizeof(WCHAR)] = UNICODE_NULL;

    } else {

        //
        // No profile - set full name = NULL

        pGlobals->UserFullName[0] = 0;
        ASSERT( lstrlen(pGlobals->UserFullName) == 0);
    }

    if ( pGlobals->SmartCardLogon )
    {
        PCCERT_CONTEXT Cert ;
        PKERB_SMART_CARD_PROFILE ScProfile ;

        //
        // Need to fix up the user name with the name (UPN) from the
        // certificate, so that unlock, etc. work correctly.
        //

        ScProfile = (PKERB_SMART_CARD_PROFILE) pGlobals->Profile ;

        pGlobals->UserName[0] = 0 ;

        try
        {
            Cert = CertCreateCertificateContext( X509_ASN_ENCODING,
                                                 ScProfile->CertificateData,
                                                 ScProfile->CertificateSize );

            if ( Cert )
            {
                // Even though the name is MAX_STRING_BYTES, the way it is used
                // throughout the code, it is used as a character counter
                // (Grrr, crappy gina code)
                //
                DWORD  dwLen = MAX_STRING_BYTES;
                if(STATUS_SUCCESS == UpnFromCert(Cert, &dwLen, pGlobals->UserName))
                {
                    RtlInitUnicodeString( &pGlobals->UserNameString,
                                          pGlobals->UserName );
                }

                CertFreeCertificateContext( Cert );
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            pGlobals->UserName[0] = L'\0';
        }

        //
        // If this is still 0 on exit, the code that sets up the flat name
        // will copy the flat name into UserName, so the failure case is
        // easy.
        //

    }

    pGlobals->SmartCardOption = GetProfileInt( APPLICATION_NAME, SC_REMOVE_OPTION, 0 );

    //
    // WE SHOULD NOT WRITE INTO THE REGISTRY.
    // CLupu
    //

    //
    // Update our default username and domain ready for the next logon
    //

    //
    // Update the default username & domain only if on the console. Otherwise
    // we'll break AutoAdminLogon by changing the user name.
    //
    if ( g_Console )
    {
        if ( (!pGlobals->AutoAdminLogon) &&
             (SafeBootMode != SAFEBOOT_MINIMAL ) )
        {
            WriteProfileString(APPLICATION_NAME, DEFAULT_USER_NAME_KEY, pGlobals->UserName);
            WriteProfileString(APPLICATION_NAME, DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);
        }

        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_USER_NAME_KEY, pGlobals->UserName);
        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);

    }

    if ( pGlobals->Domain[0] )
    {
        DCacheSetDefaultEntry( pGlobals->Cache,
                               pGlobals->Domain,
                               NULL );
    }

    Result = MSGINA_DLG_SUCCESS;

exit:

#ifdef SMARTCARD_DOGFOOD

    if (pGlobals->SmartCardLogon) {

        switch (SubStatus)
        {
            case STATUS_SMARTCARD_WRONG_PIN:
            case STATUS_SMARTCARD_CARD_BLOCKED:
            case STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED:
            case STATUS_SMARTCARD_NO_CARD:
            case STATUS_SMARTCARD_NO_KEY_CONTAINER:
            case STATUS_SMARTCARD_NO_CERTIFICATE:
            case STATUS_SMARTCARD_NO_KEYSET:
            case STATUS_SMARTCARD_IO_ERROR:
            case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
            case STATUS_SMARTCARD_CERT_EXPIRED:
            case STATUS_SMARTCARD_CERT_REVOKED:
            case STATUS_ISSUING_CA_UNTRUSTED:
            case STATUS_REVOCATION_OFFLINE_C:
            case STATUS_PKINIT_CLIENT_FAILURE:
                FinalStatus = SubStatus;
                break;

            default:
                break; // do NOTHING
        }

        // write logon data to database
        AuthMonitor(
                AuthOperLogon,
                g_Console,
                &pGlobals->UserNameString,
                &pGlobals->DomainString,
                (ScInfo ? ScInfo->pszCard : NULL),
                (ScInfo ? ScInfo->pszReader : NULL),
                (PKERB_SMART_CARD_PROFILE) pGlobals->Profile,
                EndTime - StartTime,
                FinalStatus
                );
    }

    if (ScInfo)
    {
        LocalFree( ScInfo );
    }
#endif
    // Only send a logon complete message if we haven't sent a failed
    // message. The failed message will send a logon complete message
    // when its done.
    if (Result != MSGINA_DLG_FAILEDMSGSENT)
    {
        if (WLX_DLG_INPUT_TIMEOUT == Result)
        {
            //
            // this came from a timeout when:
            // - we want to go back to CAD screen w/out an extra error dialog
            // - we want this to look like a logon failure code
            // the solution is to send WM_LOGONCOMPLETE / MSGINA_DLG_FAILURE
            // 
            //
            Result = MSGINA_DLG_FAILURE;
        }
        PostMessage(pGlobals->hwndLogon, WM_LOGONCOMPLETE, 0, Result);
    }

    //
    // free the duplicated SID
    //
    if( DuplicatedLogonSID && RtlValidSid(DuplicatedLogonSID) )
    {
        Free(DuplicatedLogonSID);
    }

    return 0L;
}


/****************************************************************************\
*
* FUNCTION: PostFailedLogonMessage
*
* PURPOSE:  Posts a message to the UI thread telling it to display a dialog that
*           tells the user why their logon attempt failed.
*
*           The window on the UI thread must correctly handle WM_HANDLEFAILEDLOGON
*           by calling HandleFailedLogon and the Free'ing the structure
*
* RETURNS:  void
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/
void PostFailedLogonMessage(HWND hDlg,
    PGLOBALS pGlobals,
    NTSTATUS Status,
    NTSTATUS SubStatus,
    PWCHAR UserName,
    PWCHAR Domain
    )

{
    g_failinfo.pGlobals = pGlobals;
    g_failinfo.Status = Status;
    g_failinfo.SubStatus = SubStatus;
    if ( UserName )
    {
        lstrcpyn(g_failinfo.UserName, UserName, ARRAYSIZE(g_failinfo.UserName));
    }
    else
    {
        g_failinfo.UserName[0] = L'\0';
    }

    if ( Domain )
    {
        lstrcpyn(g_failinfo.Domain, Domain, ARRAYSIZE(g_failinfo.Domain));
    }
    else
    {
        g_failinfo.Domain[0] = L'\0' ;
    }


    PostMessage(hDlg, WM_HANDLEFAILEDLOGON, 0 , 0);
}

INT_PTR
CALLBACK
FailDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    RUNDLLPROC fptr;
    HMODULE hDll;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            CentreWindow(hDlg);
            return( TRUE );
        }

        case WM_COMMAND:
            {
                if (LOWORD(wParam) == IDOK)
                {
                    EndDialog(hDlg, IDOK);
                }
                if (LOWORD(wParam) == IDC_RECOVER)
                {
                    // Will eventually supply username to the recover wizard
                    // We use a single export from KEYMGR.DLL for this operation.  When this operation completes,
                    //  we don't use the DLL again without unlikely user intervention.  We could DELAYLOAD keymgr.dll,
                    //  but explicitly loading and unloading this DLL permits us to minimize the memory footprint of msgina.
                    hDll = LoadLibraryW(L"keymgr.dll");
                    if (hDll) 
                    {
                        fptr = (RUNDLLPROC) GetProcAddress(hDll,(LPCSTR)"PRShowRestoreFromMsginaW");
                        // next stmt will be removed eventually when we pass the username
                        if (fptr) 
                        {
                            fptr(hDlg,NULL,g_failinfo.UserName,0);
                        }
                        FreeLibrary(hDll);
                        EndDialog(hDlg,IDOK);
                    }
                }
            }
            break;
    }

    return FALSE;
}

/****************************************************************************\
*
* FUNCTION: HandleFailedLogon
*
* PURPOSE:  Tells the user why their logon attempt failed.
*
* RETURNS:  MSGINA_DLG_FAILURE - we told them what the problem was successfully.
*           DLG_INTERRUPTED() - a set of return values - see winlogon.h
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

INT_PTR
HandleFailedLogon(
    HWND hDlg
    )
{
    INT_PTR Result = 0xffffffff;
    DWORD Win32Error ;
    TCHAR    *Buffer1 = NULL;
    TCHAR    *Buffer2 = NULL;
    TCHAR    *Buffer3 = NULL;
    PGLOBALS pGlobals = g_failinfo.pGlobals;
    NTSTATUS Status = g_failinfo.Status;
    NTSTATUS SubStatus = g_failinfo.SubStatus;
    PWCHAR Domain = g_failinfo.Domain;
    DWORD BUStatus = 0xffffffff;

    UINT uiMsgId = 0xabab;     // abab is out of range value for default handler at the bottom of this
                            // routine.  0 indicates that the user has a psw reset disk
                            // -1 means that Buffer1 & 2 contain the message
                            // otherwise there is a corresponding resource message


    //
    // for remote sessions, we must set finite timeout value for messagebox.
    // so that the session does not remain there forever
    //
    DWORD TimeOut = IsActiveConsoleSession() ? TIMEOUT_CURRENT : 20;

    switch (Status)
    {

        case STATUS_LOGON_FAILURE:
        case STATUS_NAME_TOO_LONG: // Returned if username is too long

            if (SubStatus == IDS_LOGON_LOG_FULL)
            {
                uiMsgId = IDS_LOGON_LOG_FULL;
            }
            else if( SubStatus == IDS_LOGON_SC_REQUIRED )
            {
                uiMsgId = IDS_LOGON_SC_REQUIRED;
            }
            else if ( SubStatus == IDS_SET_DIRTY_UI_TIMEOUT )
            {
                uiMsgId = IDS_SET_DIRTY_UI_TIMEOUT;
            }
            else if (pGlobals->SmartCardLogon)
            {
                switch(SubStatus)
                {
                    case STATUS_SMARTCARD_WRONG_PIN:
                        uiMsgId = IDS_STATUS_SMARTCARD_WRONG_PIN;
                        break;
                    case STATUS_SMARTCARD_CARD_BLOCKED:
                        uiMsgId = IDS_STATUS_SMARTCARD_CARD_BLOCKED;
                        break;
                    case STATUS_SMARTCARD_NO_CARD:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_CARD;
                        break;
                    case STATUS_SMARTCARD_NO_KEY_CONTAINER:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER;
                        break;
                    case STATUS_SMARTCARD_NO_CERTIFICATE:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_CERTIFICATE;
                        break;
                    case STATUS_SMARTCARD_NO_KEYSET:
                        uiMsgId = IDS_STATUS_SMARTCARD_NO_KEYSET;
                        break;
                    case STATUS_SMARTCARD_IO_ERROR:
                        uiMsgId = IDS_STATUS_SMARTCARD_IO_ERROR;
                        break;
                    case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
                        uiMsgId = IDS_STATUS_SMARTCARD_SUBSYSTEM_FAILURE;
                        break;
                    case STATUS_SMARTCARD_CERT_REVOKED:
                        uiMsgId = IDS_STATUS_SMARTCARD_CERT_REVOKED;
                        break;
                    case STATUS_ISSUING_CA_UNTRUSTED:
                        uiMsgId = IDS_STATUS_ISSUING_CA_UNTRUSTED;
                        break;
                    case STATUS_REVOCATION_OFFLINE_C:
                        uiMsgId = IDS_STATUS_REVOCATION_OFFLINE_C;
                        break;
                    case STATUS_PKINIT_CLIENT_FAILURE:
                        uiMsgId = IDS_STATUS_PKINIT_CLIENT_FAILURE;
                        break;
                    case STATUS_SMARTCARD_CERT_EXPIRED:
                        uiMsgId = IDS_STATUS_SMARTCARD_CERT_EXPIRED;
                        break;
                    default:
                        uiMsgId = IDS_INCORRECT_NAME_OR_PWD_SC;
                }
            }
            else
            {
                
                // Non-smartcard logon case:
                // Find out if the user who attempted logon has a password backup disk
                //  that could be used to reset the password.  If so, present a dialog that
                //  offers that possibility.  Else simple message box. (see passrec.h)
                if (pGlobals->fLocalDomain) 
                {
                    if ((0 == PRQueryStatus(NULL,g_failinfo.UserName,&BUStatus)) && (0 == GetSystemMetrics(SM_REMOTESESSION)))
                    {
                        if (BUStatus == 0) 
                        {
                            uiMsgId = 0;
                            break;
                        }
                    }
                }
                // Else UI message is generic one
                uiMsgId = IDS_INCORRECT_NAME_OR_PWD;
            }
            break;

        case STATUS_NOT_SUPPORTED:
        case STATUS_PKINIT_NAME_MISMATCH:
        case STATUS_PKINIT_FAILURE:

            Buffer1 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer2 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));

            if ((Buffer1 == NULL) || (Buffer2 == NULL))
            {
                uiMsgId = IDS_STATUS_SERVER_SIDE_ERROR_NOINSERT;
            }
            else
            {
                // Buffer1[0] = 0; unnecessary since LPTR was used
                LoadString(hDllInstance,
                           IDS_STATUS_SERVER_SIDE_ERROR,
                           Buffer1,
                           MAX_STRING_BYTES);

                _snwprintf(Buffer2, MAX_STRING_BYTES, Buffer1, Status );
                Buffer2[MAX_STRING_BYTES - 1] = 0;  // zero terminate

                Buffer1[0] = 0;
                LoadString(hDllInstance,
                           IDS_LOGON_MESSAGE,
                           Buffer1,
                           MAX_STRING_BYTES);

                uiMsgId = (DWORD)-1;
            }

            break;

        case STATUS_ACCOUNT_RESTRICTION:

            switch (SubStatus)
            {
                case STATUS_INVALID_LOGON_HOURS:
                    uiMsgId = IDS_INVALID_LOGON_HOURS;
                    break;

                case STATUS_INVALID_WORKSTATION:
                    uiMsgId = IDS_INVALID_WORKSTATION;
                    break;

                case STATUS_ACCOUNT_DISABLED:
                    uiMsgId = IDS_ACCOUNT_DISABLED;
                    break;

                case STATUS_ACCOUNT_EXPIRED:
                    uiMsgId = IDS_ACCOUNT_EXPIRED2;
                    break;

                case STATUS_SMARTCARD_LOGON_REQUIRED:
                    uiMsgId = IDS_SMARTCARD_REQUIRED;
                    break;

                default:
                    uiMsgId = IDS_ACCOUNT_RESTRICTION;
                    break;
            }
            break;

        case STATUS_NO_LOGON_SERVERS:

            Buffer1 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer2 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));

            if ((Buffer1 == NULL) || (Buffer2 == NULL))
            {
                uiMsgId = IDS_LOGON_NO_DOMAIN_NOINSERT;
            }
            else
            {
                // Buffer1[0] = 0; unnecessary since LPTR was used
                LoadString(hDllInstance, IDS_LOGON_NO_DOMAIN, Buffer1, MAX_STRING_BYTES);
                _snwprintf(Buffer2, MAX_STRING_BYTES, Buffer1, Domain);
                Buffer2[MAX_STRING_BYTES - 1] = 0;  // zero terminate

                Buffer1[0] = 0;
                LoadString(hDllInstance, IDS_LOGON_MESSAGE, Buffer1, MAX_STRING_BYTES);

                uiMsgId = (DWORD)-1;
            }
            break;

        case STATUS_LOGON_TYPE_NOT_GRANTED:
            uiMsgId = IDS_LOGON_TYPE_NOT_GRANTED;
            break;

        case STATUS_NO_TRUST_LSA_SECRET:
            uiMsgId = IDS_NO_TRUST_LSA_SECRET;
            break;

        case STATUS_TRUSTED_DOMAIN_FAILURE:
            uiMsgId = IDS_TRUSTED_DOMAIN_FAILURE;
            break;

        case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
            uiMsgId = IDS_TRUSTED_RELATIONSHIP_FAILURE;
            break;

        case STATUS_ACCOUNT_EXPIRED:
            uiMsgId = IDS_ACCOUNT_EXPIRED;
            break;

        case STATUS_NETLOGON_NOT_STARTED:
            uiMsgId = IDS_NETLOGON_NOT_STARTED;
            break;

        case STATUS_ACCOUNT_LOCKED_OUT:
            uiMsgId = IDS_ACCOUNT_LOCKED;
            break;

        case ERROR_CTX_LOGON_DISABLED:
            uiMsgId = IDS_MULTIUSER_LOGON_DISABLED;
            break;

        case ERROR_CTX_WINSTATION_ACCESS_DENIED:
            uiMsgId = IDS_MULTIUSER_WINSTATION_ACCESS_DENIED;
            break;

        case SCARD_E_NO_SMARTCARD:
        case SCARD_E_UNKNOWN_CARD:
            //
            // Card not recognized (although we should never get this far)
            //
            uiMsgId = IDS_CARD_NOT_RECOGNIZED;
            break;


        case NTE_PROV_DLL_NOT_FOUND:
            //
            // Card's CSP not found (although we should never get this far)
            //
            uiMsgId = IDS_CARD_CSP_NOT_RECOGNIZED;
            break;

        case STATUS_TIME_DIFFERENCE_AT_DC:
            uiMsgId = IDS_TIME_DIFFERENCE_AT_DC;
            break;

        default:

            WLPrint(("Logon failure status = 0x%lx, sub-status = 0x%lx", Status, SubStatus));

            Buffer1 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer2 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));
            Buffer3 = LocalAlloc(LPTR, MAX_STRING_BYTES * sizeof(TCHAR));

            if ((Buffer1 == NULL) || (Buffer2 == NULL) || (Buffer3 == NULL))
            {
                uiMsgId = IDS_UNKNOWN_LOGON_FAILURE_NOINSERT;
            }
            else
            {
                // Buffer1[0] = 0; unnecessary since LPTR was used
                LoadString(hDllInstance,
                           IDS_UNKNOWN_LOGON_FAILURE,
                           Buffer1,
                           MAX_STRING_BYTES);

                if ( NT_ERROR( Status ) )
                {
                    Win32Error = RtlNtStatusToDosError( Status );
                }
                else
                {
                    //
                    // Probably an HRESULT:
                    //

                    Win32Error = Status ;
                }

                // Buffer3[0] = 0; unnecessary since LPTR was used
                GetErrorDescription( Win32Error, Buffer3, MAX_STRING_BYTES);

                _snwprintf(Buffer2, MAX_STRING_BYTES, Buffer1, Buffer3 );
                Buffer2[MAX_STRING_BYTES - 1] = 0;  // zero terminate

                Buffer1[0] = 0;
                LoadString(hDllInstance,
                           IDS_LOGON_MESSAGE,
                           Buffer1,
                           MAX_STRING_BYTES);

                uiMsgId = (DWORD)-1;
            }
            break;
    }

    _Shell_LogonDialog_HideUIHost();

    switch (uiMsgId)
    {
    case 0:
        // User has a password reset disk - present the option to use it along with the usual
        //  help message
        pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx,LOGON_TIMEOUT);
        Result = pWlxFuncs->WlxDialogBoxParam(pGlobals->hGlobalWlx,
                                          hDllInstance,
                                          (LPTSTR) IDD_FAILLOGONHELP_DIALOG,
                                          hDlg,
                                          FailDlgProc,
                                          0);
        break;

    case (DWORD)-1:
        Result = TimeoutMessageBoxlpstr(hDlg, pGlobals,
                                              Buffer2,
                                              Buffer1,
                                              MB_OK | MB_ICONEXCLAMATION,
                                              TimeOut);
        break;

    default:
        Result = TimeoutMessageBox(hDlg, pGlobals,
                                     uiMsgId,
                                     IDS_LOGON_MESSAGE,
                                     MB_OK | MB_ICONEXCLAMATION,
                                     TimeOut);
    }

    if (Buffer1 != NULL)
        LocalFree(Buffer1);
    if (Buffer2 != NULL)
        LocalFree(Buffer2);
    if (Buffer3 != NULL)
        LocalFree(Buffer3);

    if (!DLG_INTERRUPTED(Result))
    {
        Result = MSGINA_DLG_FAILURE;
    }

    return(Result);
}

VOID
ReportBootGoodThread (LPVOID lpDummy)
{
    HANDLE hInstDll;
//    PGLOBALS pGlobals = (PGLOBALS)lpDummy;

//    SetThreadDesktop(pGlobals->hdeskParent);

    hInstDll = LoadLibrary (TEXT("msgina.dll"));

    NotifyBootConfigStatus(TRUE);

    if (hInstDll) {
        FreeLibraryAndExitThread(hInstDll, TRUE);
    } else {
        ExitThread (TRUE);
    }
}


/****************************************************************************\
*
* FUNCTION: ReportBootGood
*
* PURPOSE:  Discover if reporting boot success is responsibility of
*           winlogon or not.
*           If it is, report boot success.
*           Otherwise, do nothing.
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   02-Feb-1993 bryanwi - created
*
\****************************************************************************/
VOID
ReportBootGood(PGLOBALS pGlobals)
{
    static DWORD fDoIt = (DWORD) -1;    // -1 == uninited
                                        // 0  == don't do it, or done
                                        // 1  == do it
    PWCH pchData;
    DWORD   cb, cbCopied;
    HANDLE hThread;
    DWORD dwThreadID;


    if (fDoIt == -1) {

        if ((pchData = Alloc(cb = sizeof(TCHAR)*128)) == NULL) {
            return;
        }

        pchData[0] = TEXT('0');
        cbCopied = GetProfileString(APPLICATION_NAME, REPORT_BOOT_OK_KEY, TEXT("0"),
                                    (LPTSTR)pchData, 128);

        fDoIt = 0;
        if (pchData[0] != TEXT('0')) {

            //
            // "ReportBootGood" is present, and has some value other than
            // '0', so report success.
            //
            fDoIt = 1;
        }

        Free((TCHAR *)pchData);
    }

    if (fDoIt == 1) {

        hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)ReportBootGoodThread,
                                pGlobals, CREATE_SUSPENDED, &dwThreadID);

        if (hThread) {
            SetThreadPriority (hThread, THREAD_PRIORITY_LOWEST);
            ResumeThread (hThread);
            CloseHandle (hThread);

        } else {
            NotifyBootConfigStatus(TRUE);
        }
        fDoIt = 0;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpnFromCert
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
UpnFromCert(
    IN PCCERT_CONTEXT pCert,
    IN OUT DWORD       *pcUpn,
    IN OUT LPWSTR      pUPN
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   ExtensionIndex = 0;
    PCERT_ALT_NAME_INFO AltName=NULL;
    PCERT_NAME_VALUE    PrincipalNameBlob = NULL;

    //
    // Get the client name from the cert
    //

    // See if cert has UPN in AltSubjectName->otherName
    for(ExtensionIndex = 0;
        ExtensionIndex < pCert->pCertInfo->cExtension;
        ExtensionIndex++)
    {
        if(strcmp(pCert->pCertInfo->rgExtension[ExtensionIndex].pszObjId,
                  szOID_SUBJECT_ALT_NAME2) == 0)
        {
            DWORD               AltNameStructSize = 0;
            ULONG               CertAltNameIndex = 0;
            if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                X509_ALTERNATE_NAME,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.pbData,
                                pCert->pCertInfo->rgExtension[ExtensionIndex].Value.cbData,
                                CRYPT_DECODE_ALLOC_FLAG,
                                NULL,
                                (PVOID)&AltName,
                                &AltNameStructSize))
            {

                for(CertAltNameIndex = 0; CertAltNameIndex < AltName->cAltEntry; CertAltNameIndex++)
                {
                    PCERT_ALT_NAME_ENTRY AltNameEntry = &AltName->rgAltEntry[CertAltNameIndex];
                    if((CERT_ALT_NAME_OTHER_NAME  == AltNameEntry->dwAltNameChoice) &&
                       (NULL != AltNameEntry->pOtherName) &&
                       (0 == strcmp(szOID_NT_PRINCIPAL_NAME, AltNameEntry->pOtherName->pszObjId)))
                    {
                        DWORD            PrincipalNameBlobSize = 0;

                        // We found a UPN!
                        if(CryptDecodeObjectEx(pCert->dwCertEncodingType,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameEntry->pOtherName->Value.pbData,
                                            AltNameEntry->pOtherName->Value.cbData,
                                            CRYPT_DECODE_ALLOC_FLAG,
                                            NULL,
                                            (PVOID)&PrincipalNameBlob,
                                            &PrincipalNameBlobSize))
                        {
                            if(PrincipalNameBlob->Value.cbData + sizeof(WCHAR) > *pcUpn)
                            {
                                Status =  STATUS_BUFFER_OVERFLOW;
                            }
                            else
                            {
                                *pcUpn = PrincipalNameBlob->Value.cbData + sizeof(WCHAR);

                                CopyMemory(pUPN, PrincipalNameBlob->Value.pbData, PrincipalNameBlob->Value.cbData);
                                *(WCHAR *)((PBYTE)pUPN+PrincipalNameBlob->Value.cbData) = 0;
                            }

                            LocalFree(PrincipalNameBlob);
                            PrincipalNameBlob = NULL;
                            LocalFree(AltName);
                            AltName = NULL;

                            goto Finished;
                        }
                    }
                }
                LocalFree(AltName);
                AltName = NULL;
            }
        }
    }

    //
    // If the name was not found in the UPN, then
    // we grab it the old way.

    if ( !CertGetNameString( pCert,
                        CERT_NAME_ATTR_TYPE,
                        0,
                        szOID_COMMON_NAME,
                        pUPN,
                        *pcUpn ) )
    {
        Status = GetLastError();
    }

Finished:


    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:TSAuthenticatedLogon  
//
//  Notes: This routine gets called in response to WLX_SAS_TYPE_AUTHENTICATED  
//  in the context of the console session (sessionid 0) winlogon.
//  This type of logon is for Single Session Terminal Server. When a user
//  logs on from a remote TS session, we pass the credentials from the remote session
//  to the console session and do an auto-logon. This routine queries the credentials
//  logs on the user on the console sesion 
//
//
//----------------------------------------------------------------------------


INT_PTR TSAuthenticatedLogon(PGLOBALS pGlobals)
{
    PSID    LogonSid;
    LUID    LogonId;
    HANDLE  UserToken;
    HANDLE  RestrictedToken;
    INT_PTR Result = MSGINA_DLG_SUCCESS;
    UCHAR   UserBuffer[ SID_MAX_SUB_AUTHORITIES * sizeof( DWORD ) + 8 + sizeof( TOKEN_USER ) ];
    PTOKEN_USER pTokenUser ;
    ULONG   TokenInfoSize ;
    NTSTATUS Status;
    BYTE    GroupsBuffer[sizeof(TOKEN_GROUPS)+sizeof(SID_AND_ATTRIBUTES)];
    PTOKEN_GROUPS TokenGroups = (PTOKEN_GROUPS) GroupsBuffer;
    PACL Dacl = NULL;


    if (!QuerySwitchConsoleCredentials(pGlobals,&UserToken,&LogonId)) {
       Result = MSGINA_DLG_FAILEDMSGSENT;
       goto exit;
    }

    if (pGlobals->SmartCardLogon) {

        wcscpy(pGlobals->Password,L"");
        wcscpy(pGlobals->OldPassword,L"");

        {
            KERB_REFRESH_SCCRED_REQUEST PurgeRequest = {0};
            PVOID Response = NULL;
            ULONG ResponseSize;
            NTSTATUS SubStatus;
            
            PopulateSecPackageList(
                        pGlobals );

            PurgeRequest.LogonId = LogonId;
            PurgeRequest.MessageType = KerbRefreshSmartcardCredentialsMessage;
            PurgeRequest.Flags = KERB_REFRESH_SCCRED_RELEASE;
 
            Status = LsaCallAuthenticationPackage(
                        pGlobals->LsaHandle,
                        pGlobals->SmartCardLogonPackage,
                        &PurgeRequest,
                        sizeof(KERB_REFRESH_SCCRED_REQUEST),
                        &Response,
                        &ResponseSize,
                        &SubStatus
                        );

            if (NT_SUCCESS(Status) && NT_SUCCESS(SubStatus))
            {
                if (Response)
                {
                    LsaFreeReturnBuffer(Response);
                }
            }
            else
            {
                DebugLog((DEB_ERROR, "KerbRefreshSmartcardCredentials failed: (0x%x - 0x%x)\n", Status, SubStatus));
            }
        }
    }
    else
    {
        wcscpy(pGlobals->Password,L"");
        RtlInitUnicodeString(&pGlobals->PasswordString,pGlobals->Password);
        wcscpy(pGlobals->OldPassword,L"");
        RtlInitUnicodeString(&pGlobals->OldPasswordString,pGlobals->OldPassword);
    }

    RtlInitUnicodeString(&pGlobals->UserNameString, pGlobals->UserName);
    RtlInitUnicodeString(&pGlobals->DomainString, pGlobals->Domain);
    
    pGlobals->RasUsed = FALSE;

    pGlobals->hwndLogon = NULL;

    //
    // Generate a unique sid for this logon
    //
    if (!GetAndAllocateLogonSid(UserToken,&(pGlobals->LogonSid))) {

        goto error_exit;
    }

    LogonSid = pGlobals->LogonSid;


    //
    // The user logged on successfully
    //


    //
    // Create a filtered version of the token for running normal applications
    // if so indicated by a registry setting
    //
   
   
    if (GetProfileInt( APPLICATION_NAME, RESTRICT_SHELL, 0) != 0) {
   
       TokenGroups->Groups[0].Attributes = 0;
       TokenGroups->Groups[0].Sid = gAdminSid;
       TokenGroups->GroupCount = 1;
   
       Status = NtFilterToken(
                   UserToken,
                   DISABLE_MAX_PRIVILEGE,
                   TokenGroups,   // disable the administrators sid
                   NULL,           // no privileges
                   NULL,
                   &RestrictedToken
                   );
       if (!NT_SUCCESS(Status))
       {
           DebugLog((DEB_ERROR, "Failed to filter token: 0x%%x\n", Status));
           RestrictedToken = NULL;
       }
   
       //
       // Now set the default dacl for the token
       //
   
       {
           ULONG DaclLength = 0;
           TOKEN_DEFAULT_DACL DefaultDacl;
   
           DaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(LogonSid);
           Dacl = Alloc(DaclLength);

           // Check for memory allocation failure
           if (Dacl == NULL) {
               goto error_exit ;
           }

           Status = RtlCreateAcl(Dacl,DaclLength, ACL_REVISION);
           ASSERT(NT_SUCCESS(Status));

           if (Status != STATUS_SUCCESS) {
               goto error_exit;
           }

           Status = RtlAddAccessAllowedAce(
                       Dacl,
                       ACL_REVISION,
                       GENERIC_ALL,
                       LogonSid
                       );
           ASSERT(NT_SUCCESS(Status));

           if (Status != STATUS_SUCCESS) {
               goto error_exit;
           }


           DefaultDacl.DefaultDacl = Dacl;
           Status = NtSetInformationToken(
                       RestrictedToken,
                       TokenDefaultDacl,
                       &DefaultDacl,
                       sizeof(TOKEN_DEFAULT_DACL)
                       );
           ASSERT(NT_SUCCESS(Status));

           if (Status != STATUS_SUCCESS) {
               goto error_exit;
           }
   
           Free(Dacl);
           Dacl = NULL;
       }
   
   
    } else {
        RestrictedToken = NULL;
    }
    //
    // Notify credential managers of the successful logon
    //

    pTokenUser = (PTOKEN_USER) UserBuffer ;
    Status = NtQueryInformationToken( UserToken,
                                      TokenUser,
                                      pTokenUser,
                                      sizeof( UserBuffer ),
                                      &TokenInfoSize );

    if ( NT_SUCCESS( Status ) )
    {
        pGlobals->UserProcessData.UserSid = LocalAlloc( LMEM_FIXED,
                                            RtlLengthSid( pTokenUser->User.Sid ) );

        if ( pGlobals->UserProcessData.UserSid )
        {
            RtlCopyMemory( pGlobals->UserProcessData.UserSid,
                           pTokenUser->User.Sid,
                           RtlLengthSid( pTokenUser->User.Sid ) );
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        NtClose(UserToken);
        goto error_exit;
    }

    pGlobals->UserProcessData.NewThreadTokenSD = CreateUserThreadTokenSD(LogonSid, pWinlogonSid);
    if ( NULL == pGlobals->UserProcessData.NewThreadTokenSD )
    {
        if (pGlobals->Profile)
        {
           VirtualFree(pGlobals->Profile, 0, MEM_RELEASE);
           pGlobals->Profile = NULL;
           pGlobals->ProfileLength = 0;
        }
        NtClose(UserToken);

        Result = MSGINA_DLG_FAILEDMSGSENT;
        Status = STATUS_NO_MEMORY;

        goto exit;
    }
    pGlobals->UserProcessData.RestrictedToken = RestrictedToken;
    pGlobals->UserProcessData.UserToken = UserToken;


    pGlobals->MprLogonScripts = NULL;

    //
    // If we get here, the system works well enough for the user to have
    // actually logged on.  Profile failures aren't fixable by last known
    // good anyway.  Therefore, declare the boot good.
    //

    ReportBootGood(pGlobals);

    //
    // Set up the system for the new user
    //

    pGlobals->LogonId = LogonId;
    if ((pGlobals->Profile != NULL) && (pGlobals->Profile->FullName.Length > 0)) {

        DWORD cb = pGlobals->Profile->FullName.Length;
        if (cb + sizeof(WCHAR) > MAX_STRING_LENGTH * sizeof(WCHAR))
            cb = MAX_STRING_LENGTH * sizeof(WCHAR) - sizeof(WCHAR);

        memcpy(pGlobals->UserFullName, pGlobals->Profile->FullName.Buffer, cb);
        pGlobals->UserFullName[cb / sizeof(WCHAR)] = UNICODE_NULL;

    } else {

        //
        // No profile - set full name = NULL

        pGlobals->UserFullName[0] = 0;
        ASSERT( lstrlen(pGlobals->UserFullName) == 0);
    }


    //
    // Update our default username and domain ready for the next logon
    //

    //
    // Update the default username & domain only if on the console. Otherwise
    // we'll break AutoAdminLogon by changing the user name.
    //
    if ( g_Console )
    {
        if ( (!pGlobals->AutoAdminLogon) &&
             (SafeBootMode != SAFEBOOT_MINIMAL ) )
        {
            WriteProfileString(APPLICATION_NAME, DEFAULT_USER_NAME_KEY, pGlobals->UserName);
            WriteProfileString(APPLICATION_NAME, DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);
        }

        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_USER_NAME_KEY, pGlobals->UserName);
        WriteProfileString(APPLICATION_NAME, TEMP_DEFAULT_DOMAIN_NAME_KEY, pGlobals->Domain);

    }

    if ( pGlobals->Domain[0] == '\0' )
    {

       GetProfileString( APPLICATION_NAME,
                         DEFAULT_DOMAIN_NAME_KEY,
                         TEXT(""),
                         pGlobals->Domain,
                         MAX_STRING_BYTES );
    }
   

    if ( !DCacheValidateCache( pGlobals->Cache ) )
    {
        ASSERT( pGlobals->ActiveArray == NULL );

        DCacheUpdateMinimal( pGlobals->Cache, pGlobals->Domain, TRUE );

    }
    else
    {
        //
        // Set the current default:
        //

        DCacheSetDefaultEntry( pGlobals->Cache,
                               pGlobals->Domain,
                               NULL );
    }

    Result = MSGINA_DLG_SUCCESS;

exit:

    return Result;

error_exit:

    Result = MSGINA_DLG_FAILEDMSGSENT;

    if (pGlobals->Profile) {
       VirtualFree(pGlobals->Profile, 0, MEM_RELEASE);
       pGlobals->Profile = NULL;
       pGlobals->ProfileLength = 0;
    }

    if (Dacl != NULL) {
        Free(Dacl);
        Dacl = NULL;
    }

    return Result;

}


PWSTR
AllocAndDuplicateString(
    PWSTR   pszString,
    int     len)
{
    PWSTR   pszNewString;

    if (!pszString || !len)
    {
        return(NULL);
    }

    pszNewString = LocalAlloc(LMEM_FIXED, (len + 2)*sizeof(WCHAR));
    if (pszNewString)
    {
        wcsncpy(pszNewString, pszString, len);
        pszNewString[len] = UNICODE_NULL;
    }

    return(pszNewString);

}


BOOL
WINAPI
WlxGetConsoleSwitchCredentials (
   PVOID                pWlxContext,
   PVOID                pInfo
   )
{
    PGLOBALS pGlobals = (PGLOBALS) pWlxContext;
    PWLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 pReq = (PWLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0)pInfo;
    BOOL bReturn = FALSE;


    if (pReq->dwType != WLX_CONSOLESWITCHCREDENTIAL_TYPE_V1_0) {
       return FALSE;
    }

    //
    // Initialize allocated pointers.
    //

    pReq->UserName = NULL;
    pReq->Domain = NULL;
    pReq->LogonScript = NULL;
    pReq->HomeDirectory = NULL;
    pReq->FullName = NULL;
    pReq->ProfilePath = NULL;
    pReq->HomeDirectoryDrive = NULL;
    pReq->LogonServer = NULL;
    pReq->PrivateData = NULL;



    pReq->LogonId         = pGlobals->LogonId;
    pReq->UserToken       = pGlobals->UserProcessData.UserToken;
    pReq->LogonTime       = pGlobals->LogonTime;
    pReq->SmartCardLogon  = pGlobals->SmartCardLogon;

    pReq->UserName        = AllocAndDuplicateString(pGlobals->UserName,
                                                    (DWORD) wcslen(pGlobals->UserName));

    pReq->Domain          = AllocAndDuplicateString(pGlobals->Domain,
                                                    (DWORD) wcslen(pGlobals->Domain));
                                                                                                   
    //
    // Quota Information
    //
    pReq->Quotas.PagedPoolLimit         = pGlobals->UserProcessData.Quotas.PagedPoolLimit;
    pReq->Quotas.NonPagedPoolLimit      = pGlobals->UserProcessData.Quotas.NonPagedPoolLimit;
    pReq->Quotas.MinimumWorkingSetSize  = pGlobals->UserProcessData.Quotas.MinimumWorkingSetSize;
    pReq->Quotas.MaximumWorkingSetSize  = pGlobals->UserProcessData.Quotas.MaximumWorkingSetSize;
    pReq->Quotas.PagefileLimit          = pGlobals->UserProcessData.Quotas.PagefileLimit;
    pReq->Quotas.TimeLimit              = pGlobals->UserProcessData.Quotas.TimeLimit;
 
    //
    // Profile Information
    //
    pReq->ProfileLength              = pGlobals->ProfileLength;
    pReq->UserFlags                  = pGlobals->Profile->UserFlags;
    pReq->MessageType                = pGlobals->Profile->MessageType;
    pReq->LogonCount                 = pGlobals->Profile->LogonCount;
    pReq->BadPasswordCount           = pGlobals->Profile->BadPasswordCount;
    pReq->ProfileLogonTime           = pGlobals->Profile->LogonTime;
    pReq->LogoffTime                 = pGlobals->Profile->LogoffTime;
    pReq->KickOffTime                = pGlobals->Profile->KickOffTime;
    pReq->PasswordLastSet            = pGlobals->Profile->PasswordLastSet;
    pReq->PasswordCanChange          = pGlobals->Profile->PasswordCanChange;
    pReq->PasswordMustChange         = pGlobals->Profile->PasswordMustChange;

    pReq->LogonScript          = AllocAndDuplicateString(pGlobals->Profile->LogonScript.Buffer, pGlobals->Profile->LogonScript.Length/sizeof(WCHAR));
    pReq->HomeDirectory        = AllocAndDuplicateString(pGlobals->Profile->HomeDirectory.Buffer, pGlobals->Profile->HomeDirectory.Length/sizeof(WCHAR));
    pReq->FullName             = AllocAndDuplicateString(pGlobals->Profile->FullName.Buffer, pGlobals->Profile->FullName.Length/sizeof(WCHAR));

    pReq->ProfilePath          = AllocAndDuplicateString(pGlobals->Profile->ProfilePath.Buffer, pGlobals->Profile->ProfilePath.Length/sizeof(WCHAR));

    pReq->HomeDirectoryDrive   = AllocAndDuplicateString(pGlobals->Profile->HomeDirectoryDrive.Buffer, pGlobals->Profile->HomeDirectoryDrive.Length/sizeof(WCHAR));
    pReq->LogonServer          = AllocAndDuplicateString(pGlobals->Profile->LogonServer.Buffer, pGlobals->Profile->LogonServer.Length/sizeof(WCHAR));
    pReq->PrivateDataLen       = PASSWORD_HASH_SIZE;
    pReq->PrivateData          = LocalAlloc(LMEM_FIXED, PASSWORD_HASH_SIZE );
    if (pReq->PrivateData == NULL) {
        goto done;
    }

    memcpy(pReq->PrivateData, pGlobals->PasswordHash, PASSWORD_HASH_SIZE );

    bReturn = TRUE;
    
done:
    if (!bReturn) {
        if (pReq->UserName != NULL) {
            LocalFree(pReq->UserName);
        }
        if (pReq->Domain != NULL) {
            LocalFree(pReq->Domain);
        }
        if (pReq->LogonScript != NULL) {
            LocalFree(pReq->LogonScript);
        }
        if (pReq->HomeDirectory != NULL) {
            LocalFree(pReq->HomeDirectory);
        }
        if (pReq->FullName != NULL) {
            LocalFree(pReq->FullName);
        }
        if (pReq->ProfilePath != NULL) {
            LocalFree(pReq->ProfilePath);
        }
        if (pReq->HomeDirectoryDrive != NULL) {
            LocalFree(pReq->HomeDirectoryDrive);
        }
        if (pReq->LogonServer != NULL) {
            LocalFree(pReq->LogonServer);
        }
        if (pReq->PrivateData != NULL) {
            LocalFree(pReq->PrivateData);
        }
    }
    return bReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   QuerySwitchConsoleCredentials
//
//  Notes:
//
// Query credentials from session connecting to console to do switch console
//  This routine gets called in response to WLX_SAS_TYPE_AUTHENTICATED  
//  in the context of the console session (sessionid 0) winlogon.
//  This type of logon is for Single Session Terminal Server. When a user
//  logs on from a remote TS session, we pass the credentials from the remote session
//  to the console session and do an auto-logon. This routine queries the credentials,
//  logs on the user on the console sesion
//
//
//----------------------------------------------------------------------------

BOOL
WINAPI
QuerySwitchConsoleCredentials(PGLOBALS pGlobals, HANDLE * phUserToken, PLUID pLogonId)
{
    WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 CredInfo;

    RtlZeroMemory(&CredInfo,sizeof(CredInfo));

    CredInfo.dwType = WLX_CONSOLESWITCHCREDENTIAL_TYPE_V1_0;

    if (!pWlxFuncs->WlxQueryConsoleSwitchCredentials(&CredInfo)){
       return FALSE;
    }

    if (!CredInfo.UserToken || !CredInfo.UserName) {
       //return false if any of the critical information is missing
       return FALSE;
    }

    pGlobals->Profile = (PMSV1_0_INTERACTIVE_PROFILE) VirtualAlloc(NULL,
                                                                   sizeof(MSV1_0_INTERACTIVE_PROFILE),
                                                                   MEM_COMMIT,
                                                                   PAGE_READWRITE);
    

    if (pGlobals->Profile == NULL) {
       goto returnerror;
    }

    //
    // Token, LUID
    //
    *pLogonId           = CredInfo.LogonId;
    *phUserToken        = CredInfo.UserToken;
    pGlobals->LogonTime = CredInfo.LogonTime;
    pGlobals->SmartCardLogon = CredInfo.SmartCardLogon;

    pGlobals->SmartCardOption = GetProfileInt( APPLICATION_NAME, SC_REMOVE_OPTION, 0 );
 
    //
    // Quota Information
    //
    pGlobals->UserProcessData.Quotas.PagedPoolLimit         = CredInfo.Quotas.PagedPoolLimit ;
    pGlobals->UserProcessData.Quotas.NonPagedPoolLimit      = CredInfo.Quotas.NonPagedPoolLimit;
    pGlobals->UserProcessData.Quotas.MinimumWorkingSetSize  = CredInfo.Quotas.MinimumWorkingSetSize;
    pGlobals->UserProcessData.Quotas.MaximumWorkingSetSize  = CredInfo.Quotas.MaximumWorkingSetSize;
    pGlobals->UserProcessData.Quotas.PagefileLimit          = CredInfo.Quotas.PagefileLimit;
    pGlobals->UserProcessData.Quotas.TimeLimit              = CredInfo.Quotas.TimeLimit;
 
    //
    // Profile Information
    //
    pGlobals->ProfileLength               = CredInfo.ProfileLength;
    pGlobals->Profile->UserFlags          = CredInfo.UserFlags;
    pGlobals->Profile->MessageType        = CredInfo.MessageType;
    pGlobals->Profile->LogonCount         = CredInfo.LogonCount;
    pGlobals->Profile->BadPasswordCount   = CredInfo.BadPasswordCount;
    pGlobals->Profile->LogonTime          = CredInfo.ProfileLogonTime;
    pGlobals->Profile->LogoffTime         = CredInfo.LogoffTime;
    pGlobals->Profile->KickOffTime        = CredInfo.KickOffTime;
    pGlobals->Profile->PasswordLastSet    = CredInfo.PasswordLastSet;
    pGlobals->Profile->PasswordCanChange  = CredInfo.PasswordCanChange;
    pGlobals->Profile->PasswordMustChange = CredInfo.PasswordMustChange;
    
    
    RtlInitUnicodeString(&pGlobals->Profile->LogonScript, CredInfo.LogonScript);
    RtlInitUnicodeString(&pGlobals->Profile->HomeDirectory, CredInfo.HomeDirectory);
    RtlInitUnicodeString(&pGlobals->Profile->FullName, CredInfo.FullName);
    RtlInitUnicodeString(&pGlobals->Profile->ProfilePath, CredInfo.ProfilePath);
    RtlInitUnicodeString(&pGlobals->Profile->HomeDirectoryDrive, CredInfo.HomeDirectoryDrive);
    RtlInitUnicodeString(&pGlobals->Profile->LogonServer, CredInfo.LogonServer);


    if (CredInfo.UserName) {
            // CredInfo.UserName is a copy of pGlobals->UserName in another session (OK)
       wcscpy(pGlobals->UserName,CredInfo.UserName);
       LocalFree(CredInfo.UserName);
    } else {
       wcscpy(pGlobals->UserName,L"");
    }

    if (CredInfo.Domain) {
            // CredInfo.Domain is a copy of pGlobals->Domain in another session (OK)
       wcscpy(pGlobals->Domain,CredInfo.Domain);
       LocalFree(CredInfo.Domain);
    } else {
       wcscpy(pGlobals->Domain,L"");
    }

    if (CredInfo.PrivateDataLen) {
       RtlCopyMemory(pGlobals->PasswordHash,CredInfo.PrivateData, CredInfo.PrivateDataLen );
       LocalFree(CredInfo.PrivateData);
    } else {

       RtlZeroMemory(pGlobals->PasswordHash,PASSWORD_HASH_SIZE);
    }
    pGlobals->TransderedCredentials = TRUE;
   

   return TRUE;

returnerror:
        
       if (CredInfo.UserName) {
          LocalFree(CredInfo.UserName);
       }

       if (CredInfo.Domain) {
          LocalFree(CredInfo.Domain);
       }

       if (CredInfo.LogonScript) {
          LocalFree(CredInfo.LogonScript);
       }

       if (CredInfo.HomeDirectory) {
          LocalFree(CredInfo.HomeDirectory);
       }

       if (CredInfo.FullName) {
          LocalFree(CredInfo.FullName);
       }

       if (CredInfo.ProfilePath) {
          LocalFree(CredInfo.ProfilePath);
       }

       if (CredInfo.HomeDirectoryDrive) {
          LocalFree(CredInfo.HomeDirectoryDrive);
       }

       if (CredInfo.LogonServer) {
          LocalFree(CredInfo.LogonServer);
       }

       if (CredInfo.UserToken) {
         CloseHandle(CredInfo.UserToken);
       }
       if (pGlobals->Profile) {
          VirtualFree(pGlobals->Profile, 0, MEM_RELEASE);
          pGlobals->Profile = NULL;
          pGlobals->ProfileLength = 0;
       }
       return FALSE;

}


BOOL
GetAndAllocateLogonSid(
    HANDLE hToken,
    PSID *pLogonSid
    )
{
    PTOKEN_GROUPS ptgGroups = NULL;
    PTOKEN_GROUPS ptgOldGroups = NULL;
    DWORD cbBuffer          = 512;  // allocation size
    DWORD dwSidLength;              // required size to hold Sid
    UINT i;                         // Sid index counter
    BOOL bSuccess           = FALSE; // assume this function will fail

    *pLogonSid = NULL; // invalidate pointer

    //
    // initial allocation attempts
    //
    ptgGroups=(PTOKEN_GROUPS)Alloc(cbBuffer);
    if(ptgGroups == NULL) return FALSE;

    __try {

    //
    // obtain token information.  reallocate memory if necessary
    //
    while(!GetTokenInformation(
                hToken, TokenGroups, ptgGroups, cbBuffer, &cbBuffer)) {

        //
        // if appropriate, reallocate memory, otherwise bail
        //
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // attempt to reallocate buffer
            //
            ptgOldGroups = ptgGroups;
#pragma prefast(suppress: 308, "PREfast noise: LocalRealloc use is valid since old pointer was saved")
            if((ptgGroups=(PTOKEN_GROUPS)ReAlloc(
                ptgGroups, cbBuffer)) == NULL)
            {
                Free(ptgOldGroups);
                __leave;
            }
        }
        else __leave;
    }

    //
    // Get the logon Sid by looping through the Sids in the token
    //
    for(i = 0 ; i < ptgGroups->GroupCount ; i++) {
        if(ptgGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) {

            //
            // insure we are dealing with a valid Sid
            //
            if(!IsValidSid(ptgGroups->Groups[i].Sid)) __leave;

            //
            // get required allocation size to copy the Sid
            //
            dwSidLength=GetLengthSid(ptgGroups->Groups[i].Sid);

            //
            // allocate storage for the Logon Sid
            //
            if((*pLogonSid=(PSID *)Alloc(
                                    dwSidLength)) == NULL) __leave;

            //
            // copy the Logon Sid to the storage we just allocated
            //
            if(!CopySid(dwSidLength, *pLogonSid, ptgGroups->Groups[i].Sid)) __leave;

            bSuccess=TRUE; // indicate success...
            break;         // ...and get out
        }
    }

    } // try
    __finally {

    //
    // free allocated resources
    //
    if(ptgGroups != NULL) Free(ptgGroups);

    if(!bSuccess) {
        if(*pLogonSid != NULL) {
            Free(*pLogonSid);
            *pLogonSid = NULL;
        }
    }

    } // finally

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\shell.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       shell.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include "shtdnp.h"
#include <stdio.h>
#include <wchar.h>
#include <regapi.h>
#include <ginacomn.h>

HICON   hNoDCIcon;

#if DBG
DWORD   DebugAllowNoShell = 1;
#else
DWORD   DebugAllowNoShell = 0;
#endif

//
// Parsing information for autoexec.bat
//
#define PARSE_AUTOEXEC_KEY     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define PARSE_AUTOEXEC_ENTRY   TEXT("ParseAutoexec")
#define PARSE_AUTOEXEC_DEFAULT TEXT("1")
#define MAX_PARSE_AUTOEXEC_BUFFER 2

BOOL
SetLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    );

BOOL
SetAutoEnrollVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    );

VOID
DeleteLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    );

void CtxCreateMigrateEnv( PVOID );
void CtxDeleteMigrateEnv( VOID );

BOOL
DoAutoexecStuff(
    PGLOBALS    pGlobals,
    PVOID *     ppEnvironment,
    LPTSTR      pszPathVar)
{
    HKEY  hKey;
    DWORD dwDisp, dwType, dwMaxBufferSize;
    //
    // Set the default case
    //
    TCHAR szParseAutoexec[MAX_PARSE_AUTOEXEC_BUFFER] = PARSE_AUTOEXEC_DEFAULT;

    //
    // Impersonate the user, and check the registry
    //

    if (OpenHKeyCurrentUser(pGlobals)) {


        if (RegCreateKeyEx (pGlobals->UserProcessData.hCurrentUser, PARSE_AUTOEXEC_KEY, 0, 0,
                        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                        NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {


            //
            // Query the current value.  If it doesn't exist, then add
            // the entry for next time.
            //

            dwMaxBufferSize = sizeof (TCHAR) * MAX_PARSE_AUTOEXEC_BUFFER;
            if (RegQueryValueEx (hKey, PARSE_AUTOEXEC_ENTRY, NULL, &dwType,
                            (LPBYTE) szParseAutoexec, &dwMaxBufferSize)
                             != ERROR_SUCCESS) {

                //
                // Set the default value
                //

                RegSetValueEx (hKey, PARSE_AUTOEXEC_ENTRY, 0, REG_SZ,
                               (LPBYTE) szParseAutoexec,
                               sizeof (TCHAR) * (lstrlen (szParseAutoexec) + 1));
            }

            //
            // Close key
            //

            RegCloseKey (hKey);
         }

    //
    // Close HKCU
    //

    CloseHKeyCurrentUser(pGlobals);

    }


    //
    // Process the autoexec if appropriate
    //

    if (szParseAutoexec[0] == TEXT('1')) {
        ProcessAutoexec(ppEnvironment, PATH_VARIABLE);
    }

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   UpdateUserEnvironment
//
//  Synopsis:
//
//  Arguments:  [pGlobals]      --
//              [ppEnvironment] --
//
//  History:    11-01-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
UpdateUserEnvironment(
    PGLOBALS    pGlobals,
    PVOID *     ppEnvironment,
    PWSTR       pszOldDir
    )
{
    BOOL  DeepShare;
    TCHAR lpHomeShare[MAX_PATH] = TEXT("");
    TCHAR lpHomePath[MAX_PATH] = TEXT("");
    TCHAR lpHomeDrive[4] = TEXT("");
    TCHAR lpHomeDirectory[MAX_PATH] = TEXT("");
    BOOL  TSHomeDir   = FALSE;
    TCHAR lpSmartcard[sizeof(pGlobals->Smartcard) + 1 + sizeof(pGlobals->SmartcardReader) + 1];

    /*
     * Initialize user's environment.
     */

    SetUserEnvironmentVariable(ppEnvironment, USERNAME_VARIABLE, (LPTSTR)pGlobals->FlatUserName.Buffer, TRUE);
    SetUserEnvironmentVariable(ppEnvironment, USERDOMAIN_VARIABLE, (LPTSTR)pGlobals->FlatDomain.Buffer, TRUE);

    if (pGlobals->Smartcard[0] && pGlobals->SmartcardReader[0]) {

        _snwprintf(
                lpSmartcard, 
                sizeof(lpSmartcard) / sizeof(TCHAR), 
                TEXT("%s;%s"), 
                pGlobals->Smartcard, 
                pGlobals->SmartcardReader
                );
        // Will always be 0 terminated given the size of lpSmartcard

        SetUserEnvironmentVariable(ppEnvironment, SMARTCARD_VARIABLE, lpSmartcard, TRUE);
    }

    if ( !g_Console ) {
        // See if the user specified a TerminalServer Home Directory.
        // If so, we override the regular directory
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDir) > 0) {
            ASSERT (sizeof(lpHomeDirectory) >= sizeof(pGlobals->MuGlobals.TSData.HomeDir));
            lstrcpy(lpHomeDirectory, pGlobals->MuGlobals.TSData.HomeDir);
            TSHomeDir = TRUE;
        }
        if (lstrlen(pGlobals->MuGlobals.TSData.HomeDirDrive) > 0) {
            ASSERT(sizeof(lpHomeDrive) >= sizeof(pGlobals->MuGlobals.TSData.HomeDirDrive));
            lstrcpy(lpHomeDrive, pGlobals->MuGlobals.TSData.HomeDirDrive);
            TSHomeDir = TRUE;
        }
    }

    if (!TSHomeDir && pGlobals->Profile) {
        if (pGlobals->Profile->HomeDirectoryDrive.Length &&
                (pGlobals->Profile->HomeDirectoryDrive.Length + sizeof(WCHAR)) <= sizeof(lpHomeDrive)) {
            memcpy(lpHomeDrive, pGlobals->Profile->HomeDirectoryDrive.Buffer, 
                                pGlobals->Profile->HomeDirectoryDrive.Length);
            lpHomeDrive[pGlobals->Profile->HomeDirectoryDrive.Length / sizeof(WCHAR)] = 0;
        }

        if (pGlobals->Profile->HomeDirectory.Length &&
                (pGlobals->Profile->HomeDirectory.Length + sizeof(WCHAR)) <= (MAX_PATH*sizeof(TCHAR))) {
            memcpy(lpHomeDirectory, pGlobals->Profile->HomeDirectory.Buffer, 
                                    pGlobals->Profile->HomeDirectory.Length);
            lpHomeDirectory[pGlobals->Profile->HomeDirectory.Length / sizeof(WCHAR)] = 0;
        }
    }

    SetHomeDirectoryEnvVars(ppEnvironment,
                            lpHomeDirectory,
                            lpHomeDrive,
                            lpHomeShare,
                            lpHomePath,
                            &DeepShare);

    ChangeToHomeDirectory(  pGlobals,
                            ppEnvironment,
                            lpHomeDirectory,
                            lpHomeDrive,
                            lpHomeShare,
                            lpHomePath,
                            pszOldDir,
                            DeepShare
                            );

    DoAutoexecStuff(pGlobals, ppEnvironment, PATH_VARIABLE);

    SetEnvironmentVariables(pGlobals, USER_ENV_SUBKEY, ppEnvironment);
    SetEnvironmentVariables(pGlobals, USER_VOLATILE_ENV_SUBKEY, ppEnvironment);

    AppendNTPathWithAutoexecPath(ppEnvironment,
                                 PATH_VARIABLE,
                                 AUTOEXECPATH_VARIABLE);

    if (!g_Console) {
        HKEY   Handle;
        DWORD  fPerSessionTempDir = 0;
        DWORD  dwValueData;

        /*
         *  Open registry value set thru TSCC
         */
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           REG_CONTROL_TSERVER,
                           0,
                           KEY_READ,
                           &Handle ) == ERROR_SUCCESS )
        {
            DWORD ValueSize;
            DWORD ValueType;
            LONG   rc;

            ValueSize = sizeof(fPerSessionTempDir);

            /*
             *  Read registry value
             */
            rc = RegQueryValueExW( Handle,
                                   REG_TERMSRV_PERSESSIONTEMPDIR,
                                   NULL,
                                   &ValueType,
                                   (LPBYTE) &fPerSessionTempDir,
                                   &ValueSize );

            /*
             *  Close registry and key handle
             */
            RegCloseKey( Handle );
        }

        /*
         * Check the machine wide policy set thru Group Policy
         */

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           TS_POLICY_SUB_TREE,
                           0,
                           KEY_READ,
                           &Handle ) == ERROR_SUCCESS )
        {
            DWORD ValueSize;
            DWORD ValueType;
            LONG   rc;

            ValueSize = sizeof(dwValueData);

            /*
             *  Read registry value
             */
            rc = RegQueryValueExW( Handle,
                                   REG_TERMSRV_PERSESSIONTEMPDIR,
                                   NULL,
                                   &ValueType,
                                   (LPBYTE) &dwValueData,
                                   &ValueSize );

            if (rc == ERROR_SUCCESS )
            {
                fPerSessionTempDir = dwValueData;
            }

            /*
             *  Close registry and key handle
             */
            RegCloseKey( Handle );
        }


        if (fPerSessionTempDir) {
            PTERMSRVCREATETEMPDIR pfnTermsrvCreateTempDir;
            HANDLE dllHandle;

            dllHandle = LoadLibrary(TEXT("wlnotify.dll"));
            if (dllHandle) {
                pfnTermsrvCreateTempDir = (PTERMSRVCREATETEMPDIR) GetProcAddress(
                                                                       dllHandle,
                                                                       "TermsrvCreateTempDir"
                                                                       );
                if (pfnTermsrvCreateTempDir)  {
                    pfnTermsrvCreateTempDir( ppEnvironment,
                                             pGlobals->UserProcessData.UserToken,
                                             pGlobals->UserProcessData.NewThreadTokenSD);
                }

                FreeLibrary(dllHandle);
            }
        }
    }
}


BOOL
ExecApplication(
    IN LPTSTR    pch,
    IN LPTSTR    Desktop,
    IN PGLOBALS pGlobals,
    IN PVOID    pEnvironment,
    IN DWORD    Flags,
    IN DWORD    StartupFlags,
    IN BOOL     RestrictProcess,
    OUT PPROCESS_INFORMATION ProcessInformation
    )
{
    STARTUPINFO si;
    BOOL Result, IgnoreResult;
    HANDLE ImpersonationHandle;
    HANDLE ProcessToken;


    //
    // Initialize process startup info
    //
    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = pch;
    si.lpTitle = pch;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = StartupFlags;
    si.wShowWindow = SW_SHOW;   // at least let the guy see it
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = Desktop;

    //
    // Impersonate the user so we get access checked correctly on
    // the file we're trying to execute
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);
    if (ImpersonationHandle == NULL) {
        WLPrint(("ExecApplication failed to impersonate user"));
        return(FALSE);
    }


    if (RestrictProcess &&
        (pGlobals->UserProcessData.RestrictedToken != NULL) )
    {
        ProcessToken = pGlobals->UserProcessData.RestrictedToken;
    }
    else
    {
        ProcessToken = pGlobals->UserProcessData.UserToken;
    }

    //
    // Create the app suspended
    //
    DebugLog((DEB_TRACE, "About to create process of %ws, on desktop %ws\n", pch, Desktop));
    Result = CreateProcessAsUser(
                      ProcessToken,
                      NULL,
                      pch,
                      NULL,
                      NULL,
                      FALSE,
                      Flags | CREATE_SUSPENDED | CREATE_UNICODE_ENVIRONMENT,
                      pEnvironment,
                      NULL,
                      &si,
                      ProcessInformation);


    IgnoreResult = StopImpersonating(ImpersonationHandle);
    ASSERT(IgnoreResult);

    return(Result);

}

BOOL
SetProcessQuotas(
    PGLOBALS pGlobals,
    PPROCESS_INFORMATION ProcessInformation,
    PUSER_PROCESS_DATA UserProcessData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL Result;
    QUOTA_LIMITS RequestedLimits;
    UINT MessageId ;


    RequestedLimits = UserProcessData->Quotas;
    RequestedLimits.MinimumWorkingSetSize = 0;
    RequestedLimits.MaximumWorkingSetSize = 0;

    if (UserProcessData->Quotas.PagedPoolLimit != 0) {

        Result = EnablePrivilege(SE_INCREASE_QUOTA_PRIVILEGE, TRUE);
        if (!Result) {
            WLPrint(("failed to enable increase_quota privilege"));
            return(FALSE);
        }

        Status = NtSetInformationProcess(
                    ProcessInformation->hProcess,
                    ProcessQuotaLimits,
                    (PVOID)&RequestedLimits,
                    (ULONG)sizeof(QUOTA_LIMITS)
                    );

        Result = EnablePrivilege(SE_INCREASE_QUOTA_PRIVILEGE, FALSE);
        if (!Result) {
            WLPrint(("failed to disable increase_quota privilege"));
        }
    }

    if (STATUS_QUOTA_EXCEEDED == Status)
    {

        if ( TestTokenForAdmin( UserProcessData->UserToken )  )
        {
            MessageId = IDS_QUOTAEXHAUSTED ;
            Status = STATUS_SUCCESS ;
        }
        else
        {
            MessageId = IDS_COULDNTSETQUOTAS ;
        }
        // Display a warning in this case
        TimeoutMessageBox(pGlobals->hwndLogon,
                          pGlobals,
                          MessageId,
                          IDS_LOGON_MESSAGE,
                          MB_OK | MB_ICONERROR,
                          TIMEOUT_NONE);
    }

#if DBG
    if (!NT_SUCCESS(Status)) {
        WLPrint(("SetProcessQuotas failed. Status: 0x%lx", Status));
    }
#endif //DBG

    return (NT_SUCCESS(Status));
}

DWORD
ExecProcesses(
    PVOID       pWlxContext,
    IN LPTSTR   Desktop,
    IN PWSTR    Processes,
    PVOID       *ppEnvironment,
    DWORD       Flags,
    DWORD       StartupFlags
    )
{
    PWCH pchData;
    PROCESS_INFORMATION ProcessInformation;
    DWORD dwExecuted = 0 ;
    PWSTR   pszTok;
    PGLOBALS pGlobals = (PGLOBALS) pWlxContext;
    WCHAR   szCurrentDir[MAX_PATH];

    pchData = Processes;

    szCurrentDir[0] = L'\0';

    if (*ppEnvironment) {
        UpdateUserEnvironment(pGlobals, ppEnvironment, szCurrentDir);
    }

    SetLogonScriptVariables(pGlobals, ppEnvironment);

    //we should not lauch autoenrollment in this case as it blocks the shell
    //SetAutoEnrollVariables( pGlobals, ppEnvironment );

    if (g_IsTerminalServer) {
        CtxCreateMigrateEnv( *ppEnvironment );
        pWlxFuncs->WlxWin31Migrate(pGlobals->hGlobalWlx);
        CtxDeleteMigrateEnv( );
    }

    pszTok = wcstok(pchData, TEXT(","));
    while (pszTok)
    {
        if (*pszTok == TEXT(' '))
        {
            while (*pszTok++ == TEXT(' '))
                ;
        }
        if (ExecApplication((LPTSTR)pszTok,
                             Desktop,
                             pGlobals,
                             *ppEnvironment,
                             Flags,
                             StartupFlags,
                             TRUE,              // restrict application
                             &ProcessInformation)) {
            dwExecuted++;

            if (SetProcessQuotas(pGlobals,
                                 &ProcessInformation,
                                 &pGlobals->UserProcessData))
            {
                ResumeThread(ProcessInformation.hThread);
            }
            else
            {
                    // OK as the process was created suspended
                TerminateProcess(ProcessInformation.hProcess,
                                ERROR_ACCESS_DENIED);
            }

            CloseHandle(ProcessInformation.hThread);
            CloseHandle(ProcessInformation.hProcess);

        } else {

            DebugLog((DEB_WARN, "Cannot start %ws on %ws, error %d.", pszTok, Desktop, GetLastError()));
        }

        pszTok = wcstok(NULL, TEXT(","));

    }

    DeleteLogonScriptVariables(pGlobals, ppEnvironment);

    if ( szCurrentDir[0] )
    {
        SetCurrentDirectory(szCurrentDir);
    }

    return dwExecuted ;
}


INT_PTR
NoDCDlgProc(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam )
{
    DWORD   Button;
    HWND    hwnd;

    switch (Message)
    {
        case WM_INITDIALOG:
            CentreWindow( hDlg );
            if ( !hNoDCIcon )
            {
                hNoDCIcon = LoadImage(  hDllInstance,
                                        MAKEINTRESOURCE( IDI_NODC_ICON ),
                                        IMAGE_ICON,
                                        64, 64,
                                        LR_DEFAULTCOLOR );
            }
            SendMessage(    GetDlgItem( hDlg, IDD_NODC_FRAME ),
                            STM_SETICON,
                            (WPARAM) hNoDCIcon,
                            0 );

            if ( GetProfileInt( WINLOGON, TEXT("AllowDisableDCNotify"), 0 ) )
            {
                hwnd = GetDlgItem( hDlg, IDD_NODC_TEXT2 );
                ShowWindow( hwnd, SW_HIDE );
                EnableWindow( hwnd, FALSE );
            }
            else
            {
                hwnd = GetDlgItem( hDlg, IDD_NODC_CHECK );
                CheckDlgButton( hDlg, IDD_NODC_CHECK, BST_UNCHECKED );
                ShowWindow( hwnd, SW_HIDE );
                EnableWindow( hwnd, FALSE );

            }

            return( TRUE );

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                Button = IsDlgButtonChecked( hDlg, IDD_NODC_CHECK );
                EndDialog( hDlg, Button );
                return( TRUE );
            }


    }

    return( FALSE );
}

VOID
DoNoDCDialog(
    PGLOBALS    pGlobals )
{
    HKEY    hKey;
    int     err;
    DWORD   disp;
    DWORD   Flag;
    DWORD   dwType;
    DWORD   cbData;
    BOOL    MappedHKey;
    PWSTR   ReportControllerMissing;

    Flag = 1;
    hKey = NULL ;

    if (OpenHKeyCurrentUser(pGlobals))
    {
        MappedHKey = TRUE;

        err = RegCreateKeyEx(   pGlobals->UserProcessData.hCurrentUser,
                                WINLOGON_USER_KEY,
                                0, NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &hKey,
                                &disp );
        if (err == 0)
        {
            cbData = sizeof(DWORD);

            err = RegQueryValueEx(    hKey,
                                NODCMESSAGE,
                                NULL,
                                &dwType,
                                (LPBYTE) &Flag,
                                &cbData );

            if (err != ERROR_SUCCESS || dwType != REG_DWORD)
            {
                Flag = 1;
            }

        }
        else
        {
            hKey = NULL;
        }


    }
    else
    {
        MappedHKey = FALSE;
    }

    if ( Flag )
    {
        ReportControllerMissing = AllocAndGetProfileString( APPLICATION_NAME,
                                                            REPORT_CONTROLLER_MISSING,
                                                            TEXT("FALSE")
                                                            );

        if ( ReportControllerMissing )
        {
            if ( lstrcmp( ReportControllerMissing, TEXT("TRUE")) == 0 )
            {
                Flag = 1;
            }
            else
            {
                Flag = 0;
            }

            Free( ReportControllerMissing );
        }
        else
        {
            Flag = 1;
        }

    }


    if (Flag)
    {
        pWlxFuncs->WlxSetTimeout( pGlobals->hGlobalWlx, 120 );

        Flag = pWlxFuncs->WlxDialogBoxParam(    pGlobals->hGlobalWlx,
                                                hDllInstance,
                                                (LPTSTR) IDD_NODC_DIALOG,
                                                NULL,
                                                NoDCDlgProc,
                                                0 );
    }
    else
    {
        Flag = BST_CHECKED;
    }

    if (hKey)
    {
        if (Flag == BST_CHECKED)
        {
            Flag = 0;
        }
        else
        {
            Flag = 1;
        }

        RegSetValueEx(  hKey,
                        NODCMESSAGE,
                        0,
                        REG_DWORD,
                        (LPBYTE) &Flag,
                        sizeof(DWORD) );

        RegCloseKey( hKey );

    }

    if (MappedHKey)
    {
        CloseHKeyCurrentUser(pGlobals);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetPasswordExpiryWarningPeriod
//
//  Synopsis:   Returns the password expiry warning period in days: either
//              the value in the registry or the default value.
//
//  Arguments:  None
//
//  Returns:    Password expiry warning period in days.
//
//  History:    10-09-01 CenkE Copied from ShouldPasswordExpiryWarningBeShown
//
//----------------------------------------------------------------------------
DWORD 
GetPasswordExpiryWarningPeriod (
    VOID
    )
{
    HKEY    hKey;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   DaysToCheck;

    DaysToCheck = PASSWORD_EXPIRY_WARNING_DAYS;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, WINLOGON_USER_KEY, &hKey) == 0)
    {
        dwSize = sizeof(DWORD);

        if (RegQueryValueEx(hKey,
                            PASSWORD_EXPIRY_WARNING,
                            0,
                            &dwType,
                            (LPBYTE) &DaysToCheck,
                            &dwSize ) ||
            (dwType != REG_DWORD) )
        {
            DaysToCheck = PASSWORD_EXPIRY_WARNING_DAYS;
        }

        RegCloseKey(hKey);
    }
    
    return DaysToCheck;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDaysToExpiry
//
//  Synopsis:   If the passed in times can be converted to seconds since 1980,
//              returns how many days there are from CurrentTime to ExpiryTime
//
//  Arguments:  CurrentTime   -- This can be the current time or the time of a 
//                               logon etc. as FILETIME.
//              ExpiryTime    -- PasswordMustChange time from profile.
//              DaysToExpiry  -- If successful, days to password expiry is 
//                               returned here.
//
//  Returns:    TRUE - DaysToExpiry could be calculated.
//              FALSE - DaysToExpiry could not be calculated, or the password
//                      never expires.
//
//  History:    10-09-01 CenkE Copied from ShouldPasswordExpiryWarningBeShown
//
//----------------------------------------------------------------------------

#define SECONDS_PER_DAY (60*60*24)

BOOL
GetDaysToExpiry (
    IN PLARGE_INTEGER CurrentTime,
    IN PLARGE_INTEGER ExpiryTime,
    OUT PDWORD DaysToExpiry
    )
{
    ULONG ElapsedSecondsNow;
    ULONG ElapsedSecondsPasswordExpires;

    //
    // Convert the expiry time to seconds.
    //

    if (!RtlTimeToSecondsSince1980(ExpiryTime, &ElapsedSecondsPasswordExpires))
    {
        //
        // The time was not expressable in 32-bit seconds
        // Set seconds to password expiry based on whether the expiry
        // time is way in the past or way in the future.
        //

        // Never expires?
        if (ExpiryTime->QuadPart > CurrentTime->QuadPart)
        {
            return FALSE;
        }

        ElapsedSecondsPasswordExpires = 0; // Already expired
    }

    //
    // Convert the start time to seconds.
    //

    if (!RtlTimeToSecondsSince1980(CurrentTime, &ElapsedSecondsNow)) {
        return FALSE;
    }

    if (ElapsedSecondsPasswordExpires < ElapsedSecondsNow)
    {
        (*DaysToExpiry) = 0;
    }
    else
    {
        (*DaysToExpiry) = (ElapsedSecondsPasswordExpires - ElapsedSecondsNow)/SECONDS_PER_DAY;
    }

    return TRUE;
}
    
BOOL
ShouldPasswordExpiryWarningBeShown(
    IN  PGLOBALS    pGlobals,
    IN  BOOL        LogonCheck,
        OUT     PDWORD          pDaysToExpiry )
{
    ULONG   DaysToExpiry;
    DWORD   DaysToCheck;
    LARGE_INTEGER   Now;
    LARGE_INTEGER   Last;
    PLARGE_INTEGER  StartTime;

    if (pGlobals->TransderedCredentials) {

        // do not display password expiry in this case as it 
        // would otherwise display the password expiry twice
        return FALSE;
    }

    Last.LowPart = pGlobals->LastNotification.dwLowDateTime;
    Last.HighPart = pGlobals->LastNotification.dwHighDateTime;

    GetSystemTimeAsFileTime((FILETIME*) &Now);

    Last.QuadPart += (24 * 60 * 60 * 10000000I64);

    //
    // Only if last shown more than 24 hours ago
    //

    if (Now.QuadPart < Last.QuadPart)
    {
            return FALSE;
    }

    //
    // Get password expiry warning period
    //

    DaysToCheck = GetPasswordExpiryWarningPeriod();

    //
    // Go get parameters from our user's profile
    //

    if (!pGlobals->Profile)
    {
        return FALSE;
    }

    if ( LogonCheck )
    {
        StartTime = &pGlobals->LogonTime;
    }
    else
    {
        StartTime = &Now;
    }

    //
    // Determine number of days till the password expires.
    //

    if (!GetDaysToExpiry(StartTime, 
                         &(pGlobals->Profile->PasswordMustChange),
                         &DaysToExpiry)) 
    {
        return FALSE;                    
    }
                                   
    // Not within warning period?
    if (DaysToExpiry > DaysToCheck)
    {
        return FALSE;
    }

    // If return pointer... fill in
    if ( pDaysToExpiry )
    {
        *pDaysToExpiry = DaysToExpiry;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckPasswordExpiry
//
//  Synopsis:   Does the password expiration check on demand
//
//  Arguments:  [pGlobals]   --
//              [LogonCheck] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-13-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INT_PTR
CheckPasswordExpiry(
    PGLOBALS    pGlobals,
    BOOL        LogonCheck)
{
    LARGE_INTEGER           Now;
    ULONG                   DaysToExpiry;
    TCHAR                   Buffer1[MAX_STRING_BYTES];
    TCHAR                   Buffer2[MAX_STRING_BYTES];
    INT_PTR                 Result = IDOK;
    LPTSTR                  UserSidString;

        // Get current time
    GetSystemTimeAsFileTime((FILETIME*) &Now);

        if (ShouldPasswordExpiryWarningBeShown(pGlobals, LogonCheck, &DaysToExpiry))
        {
                //
                // Disable optimized logon for this user for next time if
                // we are entering the password expiry warning period, so 
                // password expiry warning dialogs will be shown if the user
                // does not change the password right now. Otherwise
                // for cached logons password expiry time is invented to be
                // forever in the future.
                //

                if (pGlobals->UserProcessData.UserToken) 
                {
                    UserSidString = GcGetSidString(pGlobals->UserProcessData.UserToken);

                    if (UserSidString) 
                    {
                        GcSetNextLogonCacheable(UserSidString, FALSE);
                        GcDeleteSidString(UserSidString);
                    }   
                }
                
                if (DaysToExpiry > 0)
                {
                        LoadString(hDllInstance, IDS_PASSWORD_WILL_EXPIRE, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ));
                        _snwprintf(Buffer2, sizeof(Buffer2)/sizeof(TCHAR) - 1, Buffer1, DaysToExpiry);
                        Buffer2[sizeof(Buffer2)/sizeof(TCHAR) - 1] = 0;
                }
                else
                {
                        LoadString(hDllInstance, IDS_PASSWORD_EXPIRES_TODAY, Buffer2, sizeof(Buffer2) / sizeof( TCHAR ));
                }

                LoadString(hDllInstance, IDS_LOGON_MESSAGE, Buffer1, sizeof(Buffer1) / sizeof( TCHAR ) );

                pGlobals->LastNotification.dwHighDateTime = Now.HighPart;
                pGlobals->LastNotification.dwLowDateTime = Now.LowPart;

                Result = TimeoutMessageBoxlpstr(NULL,
                                                                                pGlobals,
                                                                                Buffer2,
                                                                                Buffer1,
                                                                                MB_YESNO | MB_ICONEXCLAMATION,
                                                                                (LogonCheck ? LOGON_TIMEOUT : 60));
                if (Result == IDYES)
                {
                        //
                        // Let the user change their password now
                        //

                        if ( LogonCheck && pGlobals->SmartCardLogon )
                        {
                                LogonCheck = FALSE ;
                        }

                        if ( LogonCheck )
                        {
                                RevealPassword( &pGlobals->PasswordString );

                                Result = ChangePasswordLogon(NULL,
                                                           pGlobals,
                                                           pGlobals->UserName,
                                                           pGlobals->Domain,
                                                           pGlobals->Password);

                                if ( Result == IDCANCEL )
                                {
                                        //
                                        // If we got cancelled, then the string won't get
                                        // updated, so rehide it so that unlocks work later
                                        //

                                        HidePassword(   &pGlobals->Seed,
                                                                        &pGlobals->PasswordString );
                                }

                        }
                        else
                        {
                                Result = ChangePassword(
                                                                NULL,
                                                                pGlobals,
                                                                pGlobals->UserName,
                                                                pGlobals->Domain,
                                                                CHANGEPWD_OPTION_ALL );

                        }

                }

                if (DLG_INTERRUPTED(Result))
                {
                        return(Result);
                }
        }

        return MSGINA_DLG_SUCCESS;
}

/****************************************************************************\
*
* FUNCTION: DisplayPostShellLogonMessages
*
* PURPOSE:  Displays any security warnings to the user after a successful logon
*           The messages are displayed while the shell is starting up.
*
* RETURNS:  DLG_SUCCESS - the dialogs were displayed successfully.
*           DLG_INTERRUPTED() - a set defined in winlogon.h
*
* NOTE:     Screen-saver timeouts are handled by our parent dialog so this
*           routine should never return DLG_SCREEN_SAVER_TIMEOUT
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\****************************************************************************/

INT_PTR
DisplayPostShellLogonMessages(
    PGLOBALS    pGlobals
    )
{
    INT_PTR Result = IDOK;

    //
    // Check to see if the system time is properly set
    //

    {
        SYSTEMTIME Systime;

        GetSystemTime(&Systime);

        if ( Systime.wYear < 2000 ) {

            Result = TimeoutMessageBox(
                             NULL,
                             pGlobals,
                             IDS_INVALID_TIME_MSG,
                             IDS_INVALID_TIME,
                             MB_OK | MB_ICONSTOP,
                             TIMEOUT_NONE
                             );

            if (DLG_INTERRUPTED(Result)) {
                return(Result);
            }
        }
    }

    pGlobals->LastNotification.dwHighDateTime = 0;
    pGlobals->LastNotification.dwLowDateTime = 0;

    if (!pGlobals->TransderedCredentials) {

        // do not display password expiry in this case as it 
        // would otherwise display the password expiry twice
        Result = CheckPasswordExpiry( pGlobals, TRUE );
    }

    if (pGlobals->Profile != NULL) {

        //
        // Logon cache used
        //

        if (pGlobals->Profile->UserFlags & LOGON_CACHED_ACCOUNT)
        {

            //
            // Don't display any warning messages if we did an optimized logon.
            //

            if (pGlobals->OptimizedLogonStatus != OLS_LogonIsCached) {
                DoNoDCDialog( pGlobals );
            }
        }
    }

    return(IDOK);
}


INT_PTR
PostShellPasswordErase(
    PGLOBALS    pGlobals
    )
{
    //
    // Hash the password away, then destroy the text copy completely.
    //


    if (!pGlobals->TransderedCredentials) {
       RevealPassword( &pGlobals->PasswordString );
       if (pGlobals->SmartCardLogon)
       {
                // We don't want the SC PIN hash
                // (prevents password unlocks using the PIN)
           memset(pGlobals->PasswordHash, 0, sizeof(pGlobals->PasswordHash));
       }
       else
       {
           HashPassword( &pGlobals->PasswordString, pGlobals->PasswordHash );
       }
       ErasePassword( &pGlobals->PasswordString );

       if (pGlobals->OldPasswordPresent)
       {
           ErasePassword( &pGlobals->OldPasswordString );
           pGlobals->OldPasswordPresent = 0;
       }
    }


    return(IDOK);
}


/***************************************************************************\
* FUNCTION: SetLogonScriptVariables
*
* PURPOSE:  Sets the appropriate environment variables in the user
*           process environment block so that the logon script information
*           can be passed into the userinit app.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   21-Aug-92 Davidc       Created.
*
\***************************************************************************/

BOOL
SetLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    )
{
    NTSTATUS Status;
    LPWSTR EncodedMultiSz;
    UNICODE_STRING Name, Value;

    //
    // Note whether we performed an optimized logon.
    //

    RtlInitUnicodeString(&Name,  OPTIMIZED_LOGON_VARIABLE);

    if (pGlobals->OptimizedLogonStatus == OLS_LogonIsCached) {
        RtlInitUnicodeString(&Value, L"1");
    } else {
        RtlInitUnicodeString(&Value, L"0");
    }

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to set environment variable <%Z> to value <%Z>", &Name, &Value));
        goto CleanupAndExit;
    }

    //
    // Set our primary authenticator logon script variables
    //

    if (pGlobals->Profile != NULL) {

        //
        // Set the server name variable
        //

        RtlInitUnicodeString(&Name,  LOGON_SERVER_VARIABLE);
        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &pGlobals->Profile->LogonServer);
        if (!NT_SUCCESS(Status)) {
            WLPrint(("Failed to set environment variable <%Z> to value <%Z>", &Name, &pGlobals->Profile->LogonServer));
            goto CleanupAndExit;
        }

        //
        // Set the script name variable
        //

        RtlInitUnicodeString(&Name, LOGON_SCRIPT_VARIABLE);
        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &pGlobals->Profile->LogonScript);
        if (!NT_SUCCESS(Status)) {
            WLPrint(("Failed to set environment variable <%Z> to value <%Z>", &Name, &pGlobals->Profile->LogonScript));
            goto CleanupAndExit;
        }
    }

    //
    // Set the multiple provider script name variable
    //

    if (pGlobals->MprLogonScripts != NULL) {

        RtlInitUnicodeString(&Name, MPR_LOGON_SCRIPT_VARIABLE);

        EncodedMultiSz = EncodeMultiSzW(pGlobals->MprLogonScripts);
        if (EncodedMultiSz == NULL) {
            WLPrint(("Failed to encode MPR logon scripts into a string"));
            goto CleanupAndExit;
        }

        RtlInitUnicodeString(&Value, EncodedMultiSz);
        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);
        Free(EncodedMultiSz);
        if (!NT_SUCCESS(Status)) {
            WLPrint(("Failed to set mpr scripts environment variable <%Z>", &Name));
            goto CleanupAndExit;
        }
    }


    return(TRUE);


CleanupAndExit:

    DeleteLogonScriptVariables(pGlobals, pEnvironment);
    return(FALSE);
}



BOOL
SetAutoEnrollVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    )
{
    BOOL Result = FALSE ;
    UNICODE_STRING Name, Value ;


    // we should check for safe boot, domain member, and policy flag in registry
    // but we will always spawn userinit, so instead of duplicationg code, let 
    // autoenrollment do those checks.

    /*
    if (OpenHKeyCurrentUser(pGlobals))
    {

        if ( RegOpenKeyEx( pGlobals->UserProcessData.hCurrentUser,
                           WINLOGON_POLICY_KEY,
                           0,
                           KEY_READ,
                           &hKey ) == 0 )
        {
            dwSize = sizeof( Result );

            RegQueryValueEx( hKey,
                             DISABLE_AUTOENROLLMENT,
                             0,
                             &dwType,
                             (PBYTE) &Result,
                             &dwSize );

            RegCloseKey( hKey );

        }

        CloseHKeyCurrentUser(pGlobals);
    }
    */
    //
    // If the Disable flag hasn't been turned on, add the env var
    //

    if ( !Result )
    {
        RtlInitUnicodeString( &Name, USER_INIT_AUTOENROLL );
        RtlInitUnicodeString( &Value, AUTOENROLL_NONEXCLUSIVE );
        RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);

        RtlInitUnicodeString( &Name, USER_INIT_AUTOENROLLMODE );
        RtlInitUnicodeString( &Value, AUTOENROLL_STARTUP );
        RtlSetEnvironmentVariable(pEnvironment, &Name, &Value);
    }

    return TRUE ;
}

/***************************************************************************\
* FUNCTION: DeleteLogonScriptVariables
*
* PURPOSE:  Deletes the environment variables in the user process
*           environment block that we use to communicate logon script
*           information to the userinit app
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   21-Aug-92 Davidc       Created.
*
\***************************************************************************/

VOID
DeleteLogonScriptVariables(
    PGLOBALS pGlobals,
    PVOID * pEnvironment
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;

    RtlInitUnicodeString(&Name, OPTIMIZED_LOGON_VARIABLE);

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
    if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
        WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
    }

    RtlInitUnicodeString(&Name, LOGON_SERVER_VARIABLE);

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
    if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
        WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
    }

    RtlInitUnicodeString(&Name, LOGON_SCRIPT_VARIABLE);

    Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
    if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
        WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
    }

    if (pGlobals->MprLogonScripts != NULL) {
        RtlInitUnicodeString(&Name, MPR_LOGON_SCRIPT_VARIABLE);

        Status = RtlSetEnvironmentVariable(pEnvironment, &Name, NULL);
        if (!NT_SUCCESS(Status) && (Status != STATUS_UNSUCCESSFUL) ) {
            WLPrint(("Failed to delete environment variable <%Z>, status = 0x%lx", &Name, Status));
        }
    }
}


BOOL
WINAPI
WlxActivateUserShell(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktop,
    PWSTR                   pszMprLogonScript,
    PVOID                   pEnvironment
    )
{
    BOOL        bExec;
    PGLOBALS    pGlobals;
    PWSTR       pchData;
    BOOL        fReturn = FALSE;

    _ShellReleaseLogonMutex(TRUE);
    pchData = AllocAndGetPrivateProfileString(APPLICATION_NAME,
                                              USERINIT_KEY,
                                              TEXT("%SystemRoot%\\system32\\userinit.exe"),
                                              NULL);

    if ( !pchData )
    {
        if (pszMprLogonScript) {
            LocalFree(pszMprLogonScript);
        }
        goto WlxAUSEnd;
    }

    pGlobals = (PGLOBALS) pWlxContext;

    if (pGlobals->MprLogonScripts) {
        LocalFree(pGlobals->MprLogonScripts);
    }

    pGlobals->MprLogonScripts = pszMprLogonScript;

    bExec = ExecProcesses(pWlxContext, pszDesktop, pchData, &pEnvironment, 0, 0);

    Free( pchData );

    if (!bExec && (DebugAllowNoShell == 0))
    {
        goto WlxAUSEnd;
    }

    pGlobals->UserProcessData.pEnvironment = pEnvironment;

    // Write out the current user name to a place where shell logoff can read it
    if (OpenHKeyCurrentUser(pGlobals))
    {
        HKEY hkeyExplorer = NULL;
        if (ERROR_SUCCESS == RegOpenKeyEx(pGlobals->UserProcessData.hCurrentUser,
            SHUTDOWN_SETTING_KEY, 0, KEY_SET_VALUE, &hkeyExplorer))
        {
            RegSetValueEx(hkeyExplorer, LOGON_USERNAME_SETTING, 0, REG_SZ,
                (CONST BYTE *) pGlobals->UserName,
                ((lstrlen(pGlobals->UserName) + 1) * sizeof(WCHAR)));

            RegCloseKey(hkeyExplorer);
        }

        CloseHKeyCurrentUser(pGlobals);
    }

    fReturn = TRUE ;
    
WlxAUSEnd:

    return fReturn;

}


BOOL
WINAPI
WlxStartApplication(
    PVOID                   pWlxContext,
    PWSTR                   pszDesktop,
    PVOID                   pEnvironment,
    PWSTR                   pszCmdLine
    )
{
    PROCESS_INFORMATION ProcessInformation;
    BOOL        bExec;
    PGLOBALS    pGlobals = (PGLOBALS) pWlxContext;
    WCHAR       szCurrentDir[MAX_PATH];
    WCHAR       localApp[ MAX_PATH ];

    szCurrentDir[0] = L'\0';
    if (pEnvironment) {
        UpdateUserEnvironment(pGlobals, &pEnvironment, szCurrentDir);
    }

    if ( (_wcsicmp(pszCmdLine, L"explorer.exe" ) == 0 ) ||
         (_wcsicmp(pszCmdLine, L"explorer" ) == 0 )  ) {

        //
        // Avoid security problem since explorer is in SystemRoot,
        // not SystemRoot\system32
        //

        if ( ExpandEnvironmentStrings(
                    L"%SystemRoot%\\explorer.exe",
                    localApp,
                    MAX_PATH ) != 0 ) {

            pszCmdLine = localApp ;
        }
    }
    


    bExec = ExecApplication (pszCmdLine,
                             pszDesktop,
                             pGlobals,
                             pEnvironment,
                             0,
                             STARTF_USESHOWWINDOW,
                             _wcsicmp(pszCmdLine, TEXT("taskmgr.exe")),                     // don't restrict application
                             &ProcessInformation);

    if (pEnvironment)
    {       // We don't need it anymore
        VirtualFree(pEnvironment, 0, MEM_RELEASE);
    }


    if (!bExec) {
        if ( szCurrentDir[0] )
        {
            SetCurrentDirectory(szCurrentDir);
        }
        return(FALSE);
    }

    if (SetProcessQuotas(pGlobals,
                         &ProcessInformation,
                         &pGlobals->UserProcessData))
    {
        ResumeThread(ProcessInformation.hThread);
    }
    else
    {
            // OK as the process was created suspended
        TerminateProcess(ProcessInformation.hProcess,
                        ERROR_ACCESS_DENIED);
    }

    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);

    if ( szCurrentDir[0] )
    {
        SetCurrentDirectory(szCurrentDir);
    }

    return(TRUE);
}


void
CtxCreateMigrateEnv( PVOID pEnv )
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;

    cb = 1024;
    Value.Buffer = Alloc(sizeof(TCHAR)*cb);

    if (!Value.Buffer)
        return;

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString( &Name, HOMEDRIVE_VARIABLE );
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( HOMEDRIVE_VARIABLE, Value.Buffer );

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString( &Name, HOMEPATH_VARIABLE );
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( HOMEPATH_VARIABLE, Value.Buffer );

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString( &Name, INIDRIVE_VARIABLE );
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( INIDRIVE_VARIABLE, Value.Buffer );

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    RtlInitUnicodeString(&Name, INIPATH_VARIABLE);
    Status = RtlQueryEnvironmentVariable_U( pEnv, &Name, &Value );
    if ( NT_SUCCESS(Status) )
        SetEnvironmentVariable( INIPATH_VARIABLE, Value.Buffer );

    Free(Value.Buffer);
}


void
CtxDeleteMigrateEnv( )
{
    SetEnvironmentVariable( HOMEDRIVE_VARIABLE, NULL);
    SetEnvironmentVariable( HOMEPATH_VARIABLE, NULL);
    SetEnvironmentVariable( INIDRIVE_VARIABLE, NULL);
    SetEnvironmentVariable( INIPATH_VARIABLE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\shtdndlg.c ===
#include "msgina.h"

// This gives me a yucky feeling, but we
// use CRT all over the place in gina.
#include <stdio.h>

#include <windowsx.h>
#include <regstr.h>
#include <help.h>

#include <Wtsapi32.h>

#include "shtdnp.h"


#define MAX_SHTDN_OPTIONS               8

typedef struct _SHUTDOWNOPTION
{
    DWORD dwOption;
    TCHAR szName[MAX_REASON_NAME_LEN];
    TCHAR szDesc[MAX_REASON_DESC_LEN];
} SHUTDOWNOPTION, *PSHUTDOWNOPTION;


typedef struct _SHUTDOWNDLGDATA
{
    SHUTDOWNOPTION rgShutdownOptions[MAX_SHTDN_OPTIONS];
    int cShutdownOptions;
    DWORD dwItemSelect;

    REASONDATA ReasonData;
        
    BOOL fShowReasons;

    DWORD dwFlags;
    BOOL fEndDialogOnActivate;
} SHUTDOWNDLGDATA, *PSHUTDOWNDLGDATA;

// Internal function prototypes
void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc,
                               PSHUTDOWNOPTION pOption);

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata);

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

DWORD GetOptionSelection(HWND hwndCombo);

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic);

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

BOOL Shutdown_OnEraseBkgnd(HWND hwnd, HDC hdc);

INT_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);
INT_PTR DialogItemToGinaResult(DWORD dwDialogItem, BOOL fAutoPowerdown);


BOOL LoadShutdownOptionStrings(int idStringName, int idStringDesc,
                               PSHUTDOWNOPTION pOption)
{
    BOOL fSuccess = (LoadString(hDllInstance, idStringName, pOption->szName,
        ARRAYSIZE(pOption->szName)) != 0);

    if (fSuccess)
    {
        fSuccess = (LoadString(hDllInstance, idStringDesc, pOption->szDesc,
            ARRAYSIZE(pOption->szDesc)) != 0);
    }

    return fSuccess;
}

BOOL BuildShutdownOptionArray(DWORD dwItems, LPCTSTR szUsername,
                              PSHUTDOWNDLGDATA pdata)
{
    pdata->cShutdownOptions = 0;

    if (dwItems & SHTDN_LOGOFF && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        TCHAR szTemp[ARRAYSIZE(pdata->rgShutdownOptions[0].szName)];
        BOOL fFormatSuccessful = FALSE;

        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_LOGOFF;

        // Note that logoff is a special case: format using a user name ala
        // "log off <username>".
        if (!LoadShutdownOptionStrings(IDS_LOGOFF_NAME,
            IDS_LOGOFF_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions])))
            return FALSE;

        // If we have a username, format the "log off <username>" string
        if (szUsername != NULL)
        {
            fFormatSuccessful = (_snwprintf(szTemp, ARRAYSIZE(szTemp),
                pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                szUsername) > 0);
        }

        // If we didn't have a username or if the buffer got overrun, just use
        // "log off "
        if (!fFormatSuccessful)
        {
            fFormatSuccessful = (_snwprintf(szTemp, ARRAYSIZE(szTemp),
                pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                TEXT("")) > 0);
        }

        // Now we have the real logoff title in szTemp; copy it back
        if (fFormatSuccessful)
        {
            lstrcpy(pdata->rgShutdownOptions[pdata->cShutdownOptions].szName,
                szTemp);
        }
        else
        {
            // Should never happen! There should always be enough room in szTemp to hold
            // "log off ".
            ASSERT(FALSE);
            return FALSE;
        }

        // Success!
        pdata->cShutdownOptions ++;
    }

    if (dwItems & SHTDN_SHUTDOWN && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SHUTDOWN;
        if (!LoadShutdownOptionStrings(IDS_SHUTDOWN_NAME,
            IDS_SHUTDOWN_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++])))
            return FALSE;
    }

    if (dwItems & SHTDN_RESTART && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART;
        if (!LoadShutdownOptionStrings(IDS_RESTART_NAME,
            IDS_RESTART_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++])))
            return FALSE;
    }

    if (dwItems & SHTDN_RESTART_DOS && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_RESTART_DOS;
        if (!LoadShutdownOptionStrings(IDS_RESTARTDOS_NAME,
            IDS_RESTARTDOS_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++])))
            return FALSE;
    }

    if (dwItems & SHTDN_SLEEP && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP;
        if (!LoadShutdownOptionStrings(IDS_SLEEP_NAME,
            IDS_SLEEP_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++])))
            return FALSE;
    }

    if (dwItems & SHTDN_SLEEP2 && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_SLEEP2;
        if (!LoadShutdownOptionStrings(IDS_SLEEP2_NAME,
            IDS_SLEEP2_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++])))
            return FALSE;
    }

    if (dwItems & SHTDN_HIBERNATE && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_HIBERNATE;
        if (!LoadShutdownOptionStrings(IDS_HIBERNATE_NAME,
            IDS_HIBERNATE_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++])))
            return FALSE;
    }

    if (dwItems & SHTDN_DISCONNECT && pdata->cShutdownOptions < MAX_SHTDN_OPTIONS)
    {
        pdata->rgShutdownOptions[pdata->cShutdownOptions].dwOption = SHTDN_DISCONNECT;
        if (!LoadShutdownOptionStrings(IDS_DISCONNECT_NAME,
            IDS_DISCONNECT_DESC,
            &(pdata->rgShutdownOptions[pdata->cShutdownOptions ++])))
            return FALSE;
    }

    return TRUE;
}


void DisableReasons( HWND hwnd, BOOL fEnable ) 
{
    EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_COMBO), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), fEnable);
	EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_CHECK), fEnable);
}

BOOL Shutdown_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) lParam;
    HWND hwndCombo;
    int iOption;
    int iComboItem;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) lParam);

    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        // Move all our controls down so the branding fits
        SizeForBranding(hwnd, FALSE);
    }

    // Hide the help button and move over OK and Cancel if applicable
    if (pdata->dwFlags & SHTDN_NOHELP)
    {
        static UINT rgidNoHelp[] = {IDOK, IDCANCEL};
        RECT rc1, rc2;
        int dx;
        HWND hwndHelp = GetDlgItem(hwnd, IDHELP);

        if (hwndHelp)
        {
            EnableWindow(hwndHelp, FALSE);
            ShowWindow(hwndHelp, SW_HIDE);

            if(GetWindowRect(hwndHelp, &rc1) && GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc2))
            {
                dx = rc1.left - rc2.left;
                MoveControls(hwnd, rgidNoHelp, ARRAYSIZE(rgidNoHelp), dx, 0, FALSE);
            }
            else
                return FALSE;
        }
        else
            return FALSE;
    }

    // Add the items specified to the combo box
    hwndCombo = GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO);
    if (hwndCombo == NULL)
        return FALSE;

    for (iOption = 0; iOption < pdata->cShutdownOptions; iOption ++)
    {
        // Add the option
        iComboItem = ComboBox_AddString(hwndCombo,
            pdata->rgShutdownOptions[iOption].szName);

        if (iComboItem != (int) CB_ERR)
        {
            // Store a pointer to the option
            ComboBox_SetItemData(hwndCombo, iComboItem,
                &(pdata->rgShutdownOptions[iOption]));

            // See if we should select this option
            if (pdata->rgShutdownOptions[iOption].dwOption == pdata->dwItemSelect) 
            {
                ComboBox_SetCurSel(hwndCombo, iComboItem);
            }
        }
    }

    // If we don't have a selection in the combo, do a default selection
    if (ComboBox_GetCount(hwndCombo) && ComboBox_GetCurSel(hwndCombo) == CB_ERR)
    {
        PSHUTDOWNOPTION pso = (PSHUTDOWNOPTION)ComboBox_GetItemData(hwndCombo, 0);
        ComboBox_SetCurSel(hwndCombo, 0);
        pdata->dwItemSelect = pso->dwOption;
    }

    SetShutdownOptionDescription(hwndCombo,
        GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));


    // Set up the reason data.
    if( pdata->fShowReasons )
    {
		HWND	hwndCheck;
		DWORD	dwCheckState = 0x0;
		
		//
		//	Get the window handles we need.
		//
		hwndCombo = GetDlgItem(hwnd, IDC_EXITREASONS_COMBO);
		hwndCheck = GetDlgItem(hwnd, IDC_EXITREASONS_CHECK);

		//
		//	Set the default to be planned.
		//
		CheckDlgButton(hwnd, IDC_EXITREASONS_CHECK, BST_CHECKED);
		dwCheckState = SHTDN_REASON_FLAG_PLANNED;

		//
		//	Now populate the combo according to the current check state.
		//
		for (iOption = 0; iOption < pdata->ReasonData.cReasons; iOption++)
		{
			if(((pdata->ReasonData.rgReasons[iOption]->dwCode) & SHTDN_REASON_FLAG_PLANNED) == dwCheckState)
			{
				iComboItem = ComboBox_AddString(hwndCombo,
					pdata->ReasonData.rgReasons[iOption]->szName);

				if (iComboItem != (int) CB_ERR)
				{
					// Store a pointer to the option
					ComboBox_SetItemData(hwndCombo, iComboItem,
						pdata->ReasonData.rgReasons[iOption]);

					// See if we should select this option
					if (pdata->ReasonData.rgReasons[iOption]->dwCode == pdata->ReasonData.dwReasonSelect)
					{
						ComboBox_SetCurSel(hwndCombo, iComboItem);
					}
				}
			}
		}

		// If we don't have a selection in the combo, do a default selection
		if (ComboBox_GetCount(hwndCombo) && (ComboBox_GetCurSel(hwndCombo) == CB_ERR))
		{
			PREASON pr = (PREASON)ComboBox_GetItemData(hwndCombo, 0);
			if(pr != (PREASON)CB_ERR)
			{
				pdata->ReasonData.dwReasonSelect = pr->dwCode;
				ComboBox_SetCurSel(hwndCombo, 0);
			}
		}

        if (ComboBox_GetCount(hwndCombo))
        {
            SetReasonDescription(hwndCombo,
                GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION));

            // Disable the reasons if applicable
	        DisableReasons( hwnd, pdata->dwItemSelect & (SHTDN_SHUTDOWN | SHTDN_RESTART));

            // Disable the ok button if a comment is required.
            EnableWindow(GetDlgItem(hwnd, IDOK), !( pdata->dwItemSelect & (SHTDN_SHUTDOWN | SHTDN_RESTART)) || !ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ));
        }
        else
        {
            ComboBox_ResetContent(hwndCombo);
            if ((pdata->dwItemSelect & (SHTDN_SHUTDOWN | SHTDN_RESTART)) == 0)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_COMBO), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_CHECK), FALSE);
            }
            SetWindowText(GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION), L"");
            EnableWindow(GetDlgItem(hwnd, IDOK), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), pdata->dwItemSelect & (SHTDN_SHUTDOWN | SHTDN_RESTART));
        }

        // Setup the comment box.
        // We must fix the maximum characters.
        SendMessage( GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), EM_LIMITTEXT, (WPARAM)MAX_REASON_COMMENT_LEN-1, (LPARAM)0 );
    }
    else {
        // Hide the reasons, move the buttons up and shrink the dialog.
        HWND hwndCtl;

		hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_CHECK);
		EnableWindow(hwndCtl, FALSE);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_COMBO);
        EnableWindow(hwndCtl, FALSE);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT);
        EnableWindow(hwndCtl, FALSE);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_EXITREASONS_HEADER);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_STATIC_REASON_OPTION);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_STATIC_REASON_COMMENT);
        ShowWindow(hwndCtl, SW_HIDE);

        hwndCtl = GetDlgItem(hwnd, IDC_RESTARTEVENTTRACKER_GRPBX);
        ShowWindow(hwndCtl, SW_HIDE);

        // Move controls and shrink window
        {
            static UINT rgid[] = {IDOK, IDCANCEL, IDHELP};
            RECT rc, rc1, rc2;
            int dy;
            HWND hwndHelp = GetDlgItem(hwnd, IDHELP);

            GetWindowRect(hwndHelp, &rc1);
            GetWindowRect(GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION), &rc2);

            dy = rc1.top - rc2.bottom;

            MoveControls(hwnd, rgid, ARRAYSIZE(rgid), 0, -dy, FALSE);

            // Shrink
            GetWindowRect(hwnd, &rc);
            SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left, ( rc.bottom - rc.top ) - dy, SWP_NOZORDER|SWP_NOMOVE);

        }
    }

    // If we get an activate message, dismiss the dialog, since we just lost
    // focus
    pdata->fEndDialogOnActivate = TRUE;

    CentreWindow(hwnd);

    return TRUE;
}

DWORD GetOptionSelection(HWND hwndCombo)
{
    DWORD dwResult;
    PSHUTDOWNOPTION pOption;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != (int) CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);
        dwResult = pOption->dwOption;
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    return dwResult;
}

void SetShutdownOptionDescription(HWND hwndCombo, HWND hwndStatic)
{
    int iItem;
    PSHUTDOWNOPTION pOption;

    iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != CB_ERR)
    {
        pOption = (PSHUTDOWNOPTION) ComboBox_GetItemData(hwndCombo, iItem);

        SetWindowText(hwndStatic, pOption->szDesc);
    }
}

BOOL WillCauseShutdown(DWORD dwOption)
{
    switch (dwOption)
    {
    case SHTDN_SHUTDOWN:
    case SHTDN_RESTART:
    case SHTDN_RESTART_DOS:
    case SHTDN_HIBERNATE:
    case SHTDN_SLEEP:
    case SHTDN_SLEEP2:
        return TRUE;
        break;

    case SHTDN_LOGOFF:
    case SHTDN_DISCONNECT:
    default:
        break;
    }

    return FALSE;
}

BOOL Shutdown_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    BOOL fHandled = FALSE;
    DWORD dwDlgResult;
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA)
        GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (id)
    {
    case IDOK:
        if (codeNotify == BN_CLICKED)
        {
            pdata->ReasonData.dwReasonSelect = 0;
            dwDlgResult = GetOptionSelection(GetDlgItem(hwnd, IDC_EXITOPTIONS_COMBO));

            // Are the reasons enabled?
            if( pdata->fShowReasons && ( dwDlgResult & (SHTDN_SHUTDOWN | SHTDN_RESTART))) 
            {
                pdata->ReasonData.dwReasonSelect = GetReasonSelection(GetDlgItem(hwnd, IDC_EXITREASONS_COMBO));
                if (pdata->ReasonData.dwReasonSelect == SHTDN_REASON_UNKNOWN ) 
                {
                    // We still want to have the right planned flag.
                    if ( BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_EXITREASONS_CHECK) )
                        pdata->ReasonData.dwReasonSelect |= PCLEANUI;
                    else
                    {
                        pdata->ReasonData.dwReasonSelect |= SHTDN_REASON_FLAG_CLEAN_UI;
                        pdata->ReasonData.dwReasonSelect = pdata->ReasonData.dwReasonSelect & ~SHTDN_REASON_FLAG_PLANNED;
                    }
                }
               
                // Fill the comment
                pdata->ReasonData.cCommentLen = GetWindowText( GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), pdata->ReasonData.szComment, MAX_REASON_COMMENT_LEN );
                pdata->ReasonData.szComment[MAX_REASON_COMMENT_LEN-1] = 0;
            }
            
            if (dwDlgResult != SHTDN_NONE)
            {
                pdata->fEndDialogOnActivate = FALSE;            
                fHandled = TRUE;
                EndDialog(hwnd, (int) dwDlgResult);
            }
        }
        break;
    case IDCANCEL:
        if (codeNotify == BN_CLICKED)
        {
            pdata->fEndDialogOnActivate = FALSE;
            EndDialog(hwnd, (int) SHTDN_NONE);
            fHandled = TRUE;
        }
        break;
    case IDC_EXITOPTIONS_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetShutdownOptionDescription(hwndCtl,
                GetDlgItem(hwnd, IDC_EXITOPTIONS_DESCRIPTION));
            // Does this change the status of the reasons.
            if(pdata->fShowReasons ) 
            {
                BOOL fEnabled = GetOptionSelection(hwndCtl) & (SHTDN_SHUTDOWN | SHTDN_RESTART);
                DisableReasons( hwnd, fEnabled );
                
                // Make sure that we have a comment if we need one.
                if (fEnabled)
                {
                    EnableWindow(GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT), TRUE);
                }

                if(fEnabled && ComboBox_GetCount(GetDlgItem(hwnd, IDC_EXITREASONS_COMBO))) 
                {    
                    EnableWindow(GetDlgItem(hwnd, IDOK), !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));
                }
                else 
                {
                    EnableWindow(GetDlgItem(hwnd, IDOK), TRUE);
                }
            }
                
            fHandled = TRUE;
        }
        break;
	case IDC_EXITREASONS_CHECK:
		//
		//	We assume that if the user can click on the check button.
		//	we are required to show the shutdown reasons.
		//
		if (codeNotify == BN_CLICKED)
		{
			DWORD	iOption;
			DWORD	iComboItem;
			HWND	hwndCombo;
			HWND	hwndCheck;
			DWORD	dwCheckState = 0x0;
			
			//
			//	Get the window handles we need.
			//
			hwndCombo = GetDlgItem(hwnd, IDC_EXITREASONS_COMBO);
			hwndCheck = GetDlgItem(hwnd, IDC_EXITREASONS_CHECK);

			//
			//	Set the planned flag according to the check state.
			//
			if ( BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_EXITREASONS_CHECK) )
				dwCheckState = SHTDN_REASON_FLAG_PLANNED;

			//
			//	Remove all items from combo
			//
			while (ComboBox_GetCount(hwndCombo))
				ComboBox_DeleteString(hwndCombo, 0);

			//
			//	Now populate the combo according the current check state.
			//
			for (iOption = 0; iOption < (DWORD)pdata->ReasonData.cReasons; iOption ++)
			{
				if(((pdata->ReasonData.rgReasons[iOption]->dwCode) & SHTDN_REASON_FLAG_PLANNED) == dwCheckState)
				{
					iComboItem = ComboBox_AddString(hwndCombo,
						pdata->ReasonData.rgReasons[iOption]->szName);

					if (iComboItem != (int) CB_ERR)
					{
						// Store a pointer to the option
						ComboBox_SetItemData(hwndCombo, iComboItem,
							pdata->ReasonData.rgReasons[iOption]);

						// See if we should select this option
						if (pdata->ReasonData.rgReasons[iOption]->dwCode == pdata->ReasonData.dwReasonSelect)
						{
							ComboBox_SetCurSel(hwndCombo, iComboItem);
						}
					}
				}
			}

			// If we don't have a selection in the combo, do a default selection
			if (ComboBox_GetCount(hwndCombo) && (ComboBox_GetCurSel(hwndCombo) == CB_ERR))
			{
				PREASON pr = (PREASON)ComboBox_GetItemData(hwndCombo, 0);
				if(pr != (PREASON)CB_ERR)
				{
					pdata->ReasonData.dwReasonSelect = pr->dwCode;
					ComboBox_SetCurSel(hwndCombo, 0);
				}
			}

            // We need to deal with the case where no item is in the combo.
            if (!ComboBox_GetCount(hwndCombo))
            {
                ComboBox_ResetContent(hwndCombo);
                SetWindowText(GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION), L"");
                EnableWindow(GetDlgItem(hwnd, IDOK), TRUE);
            }
            else
            {
                SetReasonDescription(hwndCombo,
	                GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION));

                // Disable the ok button if a comment is required.
                EnableWindow(GetDlgItem(hwnd, IDOK),  !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));
            }
		}
		break;
    case IDC_EXITREASONS_COMBO:
        if (codeNotify == CBN_SELCHANGE && ComboBox_GetCount(GetDlgItem(hwnd, IDC_EXITREASONS_COMBO)))
        {
            SetReasonDescription(hwndCtl,
                GetDlgItem(hwnd, IDC_EXITREASONS_DESCRIPTION));
            pdata->ReasonData.dwReasonSelect = GetReasonSelection(hwndCtl);
            EnableWindow(GetDlgItem(hwnd, IDOK), !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));
        
            fHandled = TRUE;
        }
        break;
    case IDC_EXITREASONS_COMMENT:
        if( codeNotify == EN_CHANGE) 
        {
            pdata->ReasonData.cCommentLen = GetWindowTextLength( GetDlgItem(hwnd, IDC_EXITREASONS_COMMENT));
            EnableWindow(GetDlgItem(hwnd, IDOK), !(ReasonCodeNeedsComment( pdata->ReasonData.dwReasonSelect ) && ( pdata->ReasonData.cCommentLen == 0 )));

            fHandled = TRUE;
        }
        break;
    case IDHELP:
        if (codeNotify == BN_CLICKED)
        {
            WinHelp(hwnd, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
        }
        break;
    }
    return fHandled;
}

BOOL Shutdown_OnEraseBkgnd(HWND hwnd, HDC hdc)
{
    BOOL fRet;
    PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // Draw the branding bitmap
    if (!(pdata->dwFlags & SHTDN_NOBRANDINGBITMAP))
    {
        fRet = PaintBranding(hwnd, hdc, 0, FALSE, FALSE, COLOR_BTNFACE);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

INT_PTR CALLBACK Shutdown_DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                  LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, Shutdown_OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, Shutdown_OnCommand);
        HANDLE_MSG(hwnd, WM_ERASEBKGND, Shutdown_OnEraseBkgnd);
        case WLX_WM_SAS:
        {
            // If this is someone hitting C-A-D, swallow it.
            if (wParam == WLX_SAS_TYPE_CTRL_ALT_DEL)
                return TRUE;
            // Other SAS's (like timeout), return FALSE and let winlogon
            // deal with it.
            return FALSE;
        }
        break;
        case WM_INITMENUPOPUP:
        {
            EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        }
        break;
        case WM_SYSCOMMAND:
            // Blow off moves (only really needed for 32bit land).
            if ((wParam & ~0x0F) == SC_MOVE)
                return TRUE;
            break;
        case WM_ACTIVATE:
            // If we're loosing the activation for some other reason than
            // the user click OK/CANCEL then bail.
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                PSHUTDOWNDLGDATA pdata = (PSHUTDOWNDLGDATA) GetWindowLongPtr(hwnd, GWLP_USERDATA);

                if (pdata->fEndDialogOnActivate)
                {
                    pdata->fEndDialogOnActivate = FALSE;
                    EndDialog(hwnd, SHTDN_NONE);
                }
            }
            break;
    }

    return FALSE;
}

/****************************************************************************
 ShutdownDialogEx
 --------------

  Launches the shutdown dialog.

  If hWlx and pfnWlxDialogBoxParam are non-null, pfnWlxDialogBoxParam will
  be used to launch the dialog box so we can intelligently respond to WLX
  messages. Only if WinLogon is the caller should this be done.

  Other flags are listed in shtdndlg.h.
****************************************************************************/
DWORD ShutdownDialogEx(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect,
                     LPCTSTR szUsername, DWORD dwFlags, HANDLE hWlx,
                     PWLX_DIALOG_BOX_PARAM pfnWlxDialogBoxParam,
                     DWORD dwReasonSelect, PDWORD pdwReasonResult, PGLOBALS pGlobals )
{
	// Array of shutdown options - the dialog data
	PSHUTDOWNDLGDATA pData;
	DWORD dwResult;
	
	pData = (PSHUTDOWNDLGDATA)LocalAlloc(LMEM_FIXED, sizeof(*pData));
	if (pData == NULL)
	{
		return SHTDN_NONE;
	}

	// Set the flags
	pData->dwFlags = dwFlags;

	// Set the initially selected item
	pData->dwItemSelect = dwItemSelect;
	pData->ReasonData.dwReasonSelect = dwReasonSelect;
	pData->ReasonData.rgReasons = 0;
	pData->ReasonData.cReasons = 0;
	pData->ReasonData.cReasonCapacity = 0;

    // Read in the strings for the shutdown option names and descriptions
    if (BuildShutdownOptionArray(dwItems, szUsername, pData))
    {
        // See if we should display the shutdown reason dialog
        pData->fShowReasons = FALSE;
        pData->ReasonData.szComment[ 0 ] = 0;
        pData->ReasonData.cCommentLen = 0;

		if ( IsSETEnabled() ) {
			// See if any of the shutdown options will cause an actual shutdown.  If not then don't show the reasons at all.
			int i;
			for( i = 0; i < pData->cShutdownOptions; ++i ) {
				pData->fShowReasons |= pData->rgShutdownOptions[ i ].dwOption & (SHTDN_RESTART | SHTDN_SHUTDOWN);
			}

			// Read in the strings for the shutdown option names and descriptions
			if( pData->fShowReasons && BuildReasonArray( &pData->ReasonData, TRUE, FALSE )) {
				// Set the initial reason to display.
				if( dwReasonSelect >= ( DWORD )pData->ReasonData.cReasons ) {
					dwReasonSelect = 0;
				}
			}
			else {
				pData->fShowReasons = FALSE;
			}
		}

        // Display the dialog and return the user's selection

       // ..if the caller wants, use a Wlx dialog box function
        if ((hWlx != NULL) && (pfnWlxDialogBoxParam != NULL))
        {
            // Caller must be winlogon - they want us to display the
            // shutdown dialog using a Wlx function
            dwResult = (DWORD) pfnWlxDialogBoxParam(hWlx,
                hDllInstance, MAKEINTRESOURCE(IDD_EXITWINDOWS_DIALOG),
                hwndParent, Shutdown_DialogProc, (LPARAM) pData);
        }
        else
        {
            // Use standard dialog box
            dwResult = (DWORD) DialogBoxParam(hDllInstance, MAKEINTRESOURCE(IDD_EXITWINDOWS_DIALOG), hwndParent,
                Shutdown_DialogProc, (LPARAM) pData);
        }

        // Record shutdown reasons
        if( dwResult & (SHTDN_SHUTDOWN | SHTDN_RESTART)) 
        {
            if( pData->fShowReasons) 
            {
                SHUTDOWN_REASON sr;
                sr.cbSize = sizeof(SHUTDOWN_REASON);
                sr.uFlags = dwResult == SHTDN_SHUTDOWN ? EWX_SHUTDOWN : EWX_REBOOT;
                sr.dwReasonCode = pData->ReasonData.dwReasonSelect;
                sr.dwEventType = SR_EVENT_INITIATE_CLEAN; 
                sr.lpszComment = pData->ReasonData.szComment;
                if (pGlobals && pGlobals->UserProcessData.UserToken) 
                {
                    if (ImpersonateLoggedOnUser(pGlobals->UserProcessData.UserToken)) 
                    {
                        RecordShutdownReason(&sr);
                        RevertToSelf();
                    }
                } 
                else 
                {
                    RecordShutdownReason(&sr);
                }
            }
        }
    }
    else
    {
        dwResult = SHTDN_NONE;
    }

    DestroyReasons( &pData->ReasonData );

    LocalFree(pData);

    return dwResult;
}

DWORD ShutdownDialog(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect,
                     LPCTSTR szUsername, DWORD dwFlags, HANDLE hWlx,
                     PWLX_DIALOG_BOX_PARAM pfnWlxDialogBoxParam )
{
    DWORD dummy;
    return ShutdownDialogEx(hwndParent, dwItems, dwItemSelect,
                     szUsername, dwFlags, hWlx,
                     pfnWlxDialogBoxParam,
                     0, &dummy, NULL);
}

INT_PTR DialogItemToGinaResult(DWORD dwDialogItem, BOOL fAutoPowerdown)
{
    INT_PTR Result;

    // Map the return value from ShutdownDialog into
    // our internal shutdown values
    switch (dwDialogItem)
    {
    case SHTDN_LOGOFF:
        Result = MSGINA_DLG_USER_LOGOFF;
        break;
    case SHTDN_SHUTDOWN:
        if (fAutoPowerdown)
            Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_POWEROFF_FLAG;
        else
            Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SHUTDOWN_FLAG;
        break;
    case SHTDN_RESTART:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_REBOOT_FLAG;
        break;
    case SHTDN_SLEEP:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SLEEP_FLAG;
        break;
    case SHTDN_SLEEP2:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_SLEEP2_FLAG;
        break;
    case SHTDN_HIBERNATE:
        Result = MSGINA_DLG_SHUTDOWN | MSGINA_DLG_HIBERNATE_FLAG;
        break;
    case SHTDN_DISCONNECT:
        Result = MSGINA_DLG_DISCONNECT;
        break;
    default:
        // Cancel click, or else invalid item was selected
        Result = MSGINA_DLG_FAILURE;
        break;
    }

    return Result;
}

BOOL GetBoolPolicy(HKEY hkeyCurrentUser, LPCTSTR pszPolicyKey, LPCTSTR pszPolicyValue, BOOL fDefault)
{
    HKEY hkeyMachinePolicy = NULL;
    HKEY hkeyUserPolicy = NULL;
    BOOL fPolicy = fDefault;
    BOOL fMachinePolicyRead = FALSE;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbData;
    LRESULT res;

    // Check machine policy first
    res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszPolicyKey, 0, KEY_READ, &hkeyMachinePolicy); 
    if (ERROR_SUCCESS == res)
    {
        cbData = sizeof(dwValue);
              
        res = RegQueryValueEx(hkeyMachinePolicy, pszPolicyValue, 0, &dwType, (LPBYTE)&dwValue, &cbData);
        
        if (ERROR_SUCCESS == res)
        {
            fPolicy = (dwValue != 0);
            fMachinePolicyRead = TRUE;
        }

        RegCloseKey(hkeyMachinePolicy);
    }

    if (!fMachinePolicyRead)
    {
        // Machine policy check failed, check user policy
        res = RegOpenKeyEx(hkeyCurrentUser, pszPolicyKey, 0, KEY_READ, &hkeyUserPolicy); 
        if (ERROR_SUCCESS == res)
        {
            cbData = sizeof(dwValue);
          
            res = RegQueryValueEx(hkeyUserPolicy, pszPolicyValue, 0, &dwType, (LPBYTE)&dwValue, &cbData);

            if (ERROR_SUCCESS == res)
            {
                fPolicy = (dwValue != 0);
            }

            RegCloseKey(hkeyUserPolicy);
        }
    }

    return fPolicy;
}

DWORD GetAllowedShutdownOptions(HKEY hkeyCurrentUser, HANDLE UserToken, BOOL fRemoteSession)
{
    DWORD dwItemsToAdd = 0;
    BOOL fNoDisconnect = TRUE;

    // Does computer automatically shut off on shutdown
    BOOL fAutoPowerdown = FALSE;
    SYSTEM_POWER_CAPABILITIES spc = {0};

    // See if we should add Logoff and/or disconnect to the dialog
    // - don't even try if we don't have a current user!

    BOOL fNoLogoff = GetBoolPolicy(hkeyCurrentUser, EXPLORER_POLICY_KEY, NOLOGOFF, FALSE);
    
    if (!fNoLogoff)
    {
        dwItemsToAdd |= SHTDN_LOGOFF;
    }

    // Do not allow disconnects by default. Allow disconnects when either this is
    // a remote session or terminal server is enabled on Workstation (PTS).

    {
        
      // The disconnect menu can be disabled by policy. Respect that. It should
      // also be removed in the friendly UI case WITHOUT multiple users.
        fNoDisconnect = ( IsActiveConsoleSession() || 
                          GetBoolPolicy(hkeyCurrentUser, EXPLORER_POLICY_KEY, NODISCONNECT, FALSE) ||
                          (ShellIsFriendlyUIActive() && !ShellIsMultipleUsersEnabled()) );  
    }
   
   
    if (!fNoDisconnect)
    {
       dwItemsToAdd |= SHTDN_DISCONNECT;
    }

    // All items besides logoff and disconnect require SE_SHUTDOWN
    if (TestUserPrivilege(UserToken, SE_SHUTDOWN_PRIVILEGE))
    {
        // Add shutdown and restart
        dwItemsToAdd |= SHTDN_RESTART | SHTDN_SHUTDOWN;

        NtPowerInformation (SystemPowerCapabilities,
                            NULL, 0, &spc, sizeof(spc));

        if (spc.SystemS5)
            fAutoPowerdown = TRUE;
        else
            fAutoPowerdown = GetProfileInt(APPLICATION_NAME, POWER_DOWN_AFTER_SHUTDOWN, 0);

        // Is hibernate option supported?
        //

        if ((spc.SystemS4 && spc.HiberFilePresent))
        {
            dwItemsToAdd |= SHTDN_HIBERNATE;
        }

        //
        // If one of the SystemS* values is true, then the machine
        // has ACPI suspend support.
        //

        if (spc.SystemS1 || spc.SystemS2 || spc.SystemS3)
        {
            HKEY hKey;
            DWORD dwAdvSuspend = 0;
            DWORD dwType, dwSize;

            // Check if we should offer advanced suspend options

            if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power"),
                              0, KEY_READ, &hKey) == ERROR_SUCCESS)
            {
                dwSize = sizeof(dwAdvSuspend);
                RegQueryValueEx (hKey, TEXT("Shutdown"), NULL, &dwType,
                                     (LPBYTE) &dwAdvSuspend, &dwSize);

                RegCloseKey (hKey);
            }


            if (dwAdvSuspend != 0)
            {
                dwItemsToAdd |= SHTDN_SLEEP2 | SHTDN_SLEEP;
            }
            else
            {
                // Only basic suspend support
                dwItemsToAdd |= SHTDN_SLEEP;
            }
        }
    }

    return dwItemsToAdd;
}

// Helper function for calling ShutdownDialog within winlogon
// This function handles all the registry goop, power management
// settings goop, and translating of codes into MSGINA's system
// of shutdown codes and flags. Ack.
INT_PTR WinlogonShutdownDialog(HWND hwndParent, PGLOBALS pGlobals, DWORD dwExcludeItems)
{
    INT_PTR Result = MSGINA_DLG_FAILURE;
    DWORD dwDialogResult = IDCANCEL;
    DWORD dwReasonResult = SHTDN_REASON_UNKNOWN;
    DWORD dwItemsToAdd = 0;
    DWORD dwFlags = 0;

    // Items to add to the shutdown dialog

    if (OpenHKeyCurrentUser(pGlobals))
    {
        dwItemsToAdd = GetAllowedShutdownOptions(pGlobals->UserProcessData.hCurrentUser,
            pGlobals->UserProcessData.UserToken, !g_Console);

        CloseHKeyCurrentUser(pGlobals);
    }


    dwItemsToAdd &= (~dwExcludeItems);

    if (0 != dwItemsToAdd)
    {
        // Item to select
        DWORD dwItemToSelect = 0;

        DWORD dwReasonToSelect = 0;

        // Does computer automatically shut off on shutdown
        BOOL fAutoPowerdown = FALSE;
        SYSTEM_POWER_CAPABILITIES spc = {0};

        NtPowerInformation (SystemPowerCapabilities,
                            NULL, 0, &spc, sizeof(spc));

        if (spc.SystemS5)
            fAutoPowerdown = TRUE;
        else
            fAutoPowerdown = GetProfileInt(APPLICATION_NAME, POWER_DOWN_AFTER_SHUTDOWN, 0);

        // Get the default item from the registry
        if (OpenHKeyCurrentUser(pGlobals))
        {
            LONG lResult;
            HKEY hkeyShutdown;
            DWORD dwType = 0;

            //
            // Check the button which was the users last shutdown selection.
            //
            if (RegCreateKeyEx(pGlobals->UserProcessData.hCurrentUser,
                               SHUTDOWN_SETTING_KEY, 0, 0, 0,
                               KEY_READ | KEY_WRITE,
                               NULL, &hkeyShutdown, &dwType) == ERROR_SUCCESS)
            {
                DWORD cbData = sizeof(dwItemToSelect);

                lResult = RegQueryValueEx(hkeyShutdown,
                                          SHUTDOWN_SETTING,
                                          0,
                                          &dwType,
                                          (LPBYTE) &dwItemToSelect,
                                          &cbData);

                RegQueryValueEx(hkeyShutdown,
                                REASON_SETTING,
                                0,
                                &dwType,
                                (LPBYTE) &dwReasonToSelect,
                                &cbData);

                RegCloseKey(hkeyShutdown);
            }

            CloseHKeyCurrentUser(pGlobals);
        }

        // Figure out what flags to pass
        // for sure no help button
        dwFlags = SHTDN_NOHELP;

        // On terminal server, no branding bitmap either
        if (GetSystemMetrics(SM_REMOTESESSION))
        {
            dwFlags |= SHTDN_NOBRANDINGBITMAP;
        }

        // Call ShutdownDialog
        dwDialogResult = ShutdownDialogEx(hwndParent, dwItemsToAdd,
            dwItemToSelect, pGlobals->UserName, dwFlags, pGlobals->hGlobalWlx,
            pWlxFuncs->WlxDialogBoxParam,
            dwReasonToSelect, &dwReasonResult ,pGlobals );

        Result = DialogItemToGinaResult(dwDialogResult, fAutoPowerdown);

        // If everything is okay so far, write the selection to the registry
        // for next time.
        if (Result != MSGINA_DLG_FAILURE)
        {
            HKEY hkeyShutdown;
            DWORD dwDisposition;

            //
            // Get in the correct context before we reference the registry
            //

            if (OpenHKeyCurrentUser(pGlobals))
            {
                if (RegCreateKeyEx(pGlobals->UserProcessData.hCurrentUser, SHUTDOWN_SETTING_KEY, 0, 0, 0,
                                KEY_READ | KEY_WRITE,
                                NULL, &hkeyShutdown, &dwDisposition) == ERROR_SUCCESS)
                {
                    RegSetValueEx(hkeyShutdown, SHUTDOWN_SETTING, 0, REG_DWORD, (LPBYTE)&dwDialogResult, sizeof(dwDialogResult));
                    RegSetValueEx(hkeyShutdown, REASON_SETTING, 0, REG_DWORD, (LPBYTE)&dwReasonResult, sizeof(dwDialogResult));
                    RegCloseKey(hkeyShutdown);
                }

                CloseHKeyCurrentUser(pGlobals);
            }
        }
    }

    return Result;
}

STDAPI_(DWORD) ShellShutdownDialog(HWND hwndParent, LPCTSTR szUnused, DWORD dwExcludeItems)
{
    DWORD dwSelect = 0;
    DWORD dwReasonToSelect = 0;
    DWORD dwDialogResult = 0;
    DWORD dwReasonResult = SHTDN_REASON_UNKNOWN;
    DWORD dwFlags = 0;
    BOOL fTextOnLarge;
    BOOL fTextOnSmall;
    GINAFONTS fonts = {0};

    HKEY hkeyShutdown;
    DWORD dwType;
    DWORD dwDisposition;
    LONG lResult;

    // De facto limit for usernames is 127 due to clunky gina 'encryption'
    TCHAR szUsername[127];
    DWORD dwItems = GetAllowedShutdownOptions(HKEY_CURRENT_USER,
        NULL, (BOOL) GetSystemMetrics(SM_REMOTESESSION));

    dwItems &= (~dwExcludeItems);

    // Create the bitmaps we need
    LoadBrandingImages(TRUE, &fTextOnLarge, &fTextOnSmall);

    CreateFonts(&fonts);
    PaintBitmapText(&fonts, fTextOnLarge, fTextOnSmall);

    // get the User's last selection.
    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, SHUTDOWN_SETTING_KEY,
                0, 0, 0, KEY_READ, NULL, &hkeyShutdown, &dwDisposition);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD cbData = sizeof(dwSelect);
        lResult = RegQueryValueEx(hkeyShutdown, SHUTDOWN_SETTING,
            0, &dwType, (LPBYTE)&dwSelect, &cbData);

        RegQueryValueEx(hkeyShutdown, REASON_SETTING,
            0, &dwType, (LPBYTE)&dwReasonToSelect, &cbData);

        cbData = sizeof(szUsername);

        if (ERROR_SUCCESS != RegQueryValueEx(hkeyShutdown, LOGON_USERNAME_SETTING,
            0, &dwType, (LPBYTE)szUsername, &cbData))
        {
            // Default to "Log off" with no username if this fails.
            *szUsername = 0;
        }

        // Ensure null-termination
        szUsername[ARRAYSIZE(szUsername) - 1] = 0;

        RegCloseKey(hkeyShutdown);
    }

    if (dwSelect == SHTDN_NONE)
    {
        dwSelect = SHTDN_SHUTDOWN;
    }

    // Figure out what flags to pass
    // for sure we don't want any palette changes - this means
    // force 16-colors for 256 color displays.
    dwFlags = SHTDN_NOPALETTECHANGE;

    // On TS, don't show bitmap
    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        dwFlags |= SHTDN_NOBRANDINGBITMAP;
    }

    dwDialogResult = ShutdownDialogEx(hwndParent, dwItems, dwSelect,
        szUsername, dwFlags, NULL, NULL,
        dwReasonToSelect, &dwReasonResult, NULL );

    if (dwDialogResult != SHTDN_NONE)
    {
        // Save back the user's choice to the registry
        if (RegCreateKeyEx(HKEY_CURRENT_USER, SHUTDOWN_SETTING_KEY,
            0, 0, 0, KEY_WRITE, NULL, &hkeyShutdown, &dwDisposition) == ERROR_SUCCESS)
        {
            RegSetValueEx(hkeyShutdown, SHUTDOWN_SETTING,
                0, REG_DWORD, (LPBYTE)&dwDialogResult, sizeof(dwDialogResult));

            RegSetValueEx(hkeyShutdown, REASON_SETTING,
                0, REG_DWORD, (LPBYTE)&dwReasonResult, sizeof(dwReasonResult));

            RegCloseKey(hkeyShutdown);
        }
    }

    // Clean up fonts and bitmaps we created
    if (g_hpalBranding)
    {
        DeleteObject(g_hpalBranding);
    }

    if (g_hbmOtherDlgBrand)
    {
        DeleteObject(g_hbmOtherDlgBrand);
    }

    if (g_hbmLogonBrand)
    {
        DeleteObject(g_hbmLogonBrand);
    }

    if (g_hbmBand)
    {
        DeleteObject(g_hbmBand);
    }

    if (fonts.hWelcomeFont)
    {
        DeleteObject(fonts.hWelcomeFont);
    }

    if (fonts.hCopyrightFont)
    {
        DeleteObject(fonts.hCopyrightFont);
    }

    if (fonts.hBuiltOnNtFont)
    {
        DeleteObject(fonts.hBuiltOnNtFont);
    }

    if (fonts.hBetaFont)
    {
        DeleteObject(fonts.hBetaFont);
    }

    return dwDialogResult;
}

/****************************************************************************

  Function: GetSessionCount

  Returns: The number of user sessions that are active
            on your terminal server. If this value is more than 1, then
            operations such as shutdown or restart will end these other
            sessions.

  History: dsheldon 04/23/99 - created
****************************************************************************/

// Termsrv dll delayload stuff
#define WTSDLLNAME  TEXT("WTSAPI32.DLL")
HINSTANCE g_hWTSDll = NULL;
typedef BOOL (WINAPI*WTSEnumerateSessionsW_t)(IN HANDLE hServer,
    IN DWORD Reserved,
    IN DWORD Version,
    OUT PWTS_SESSION_INFOW * ppSessionInfo,
    OUT DWORD * pCount
    );

WTSEnumerateSessionsW_t g_pfnWTSEnumerateSessions = NULL;

typedef VOID (WINAPI*WTSFreeMemory_t)(IN PVOID pMemory);
    
WTSFreeMemory_t g_pfnWTSFreeMemory = NULL;

typedef BOOL (WINAPI*WTSQuerySessionInformationW_t)(IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WtsInfoClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pCount
    );

WTSQuerySessionInformationW_t g_pfnWTSQuerySessionInformation = NULL;


DWORD GetSessionCount()
{
    BOOL fSessionsEnumerated;
    PWTS_SESSION_INFO pSessionInfo;
    DWORD cSessionInfo;

    // Return value
    DWORD nOtherSessions = 0;

    // Try to load termsrv dll if necessary
    if (NULL == g_hWTSDll)
    {
        g_hWTSDll = LoadLibrary(WTSDLLNAME);

        if (g_hWTSDll)
        {
            g_pfnWTSEnumerateSessions = (WTSEnumerateSessionsW_t) GetProcAddress(g_hWTSDll, "WTSEnumerateSessionsW");
            g_pfnWTSQuerySessionInformation = (WTSQuerySessionInformationW_t) GetProcAddress(g_hWTSDll, "WTSQuerySessionInformationW");
            g_pfnWTSFreeMemory = (WTSFreeMemory_t) GetProcAddress(g_hWTSDll, "WTSFreeMemory");
        }
    }

    // Continue only if we have the functions we need
    if (g_pfnWTSEnumerateSessions && g_pfnWTSFreeMemory && g_pfnWTSQuerySessionInformation)
    {
        // Enumerate all sessions on this machine
        pSessionInfo = NULL;
        cSessionInfo = 0;
        fSessionsEnumerated = g_pfnWTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, &cSessionInfo);

        if (fSessionsEnumerated)
        {
            DWORD iSession;
        
            ASSERT((pSessionInfo != NULL) || (cSessionInfo == 0));

            // Check each session to see if it is one we should count
            for (iSession = 0; iSession < cSessionInfo; iSession ++)
            {
                switch (pSessionInfo[iSession].State)
                {
                // We count these cases:
                case WTSActive:
                case WTSShadow:
                    {
                        nOtherSessions ++;                   
                    }
                    break;

                case WTSDisconnected:
                    {
                        LPWSTR pUserName = NULL;
                        DWORD  cSize;
                        // Only count the disconnected sessions that have a user logged on
                        if (g_pfnWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE, pSessionInfo[iSession].SessionId,
                                                            WTSUserName, &pUserName, &cSize)) {

                            if (pUserName && (pUserName[0] != L'\0')) {

                                nOtherSessions ++; 
                            }

                            if (pUserName != NULL)
                            {
                                g_pfnWTSFreeMemory(pUserName);
                            }

                        }
                    }
                    break;
                // And ignore the rest:
                default:
                    break;
                }
            }

            if (pSessionInfo != NULL)
            {
                g_pfnWTSFreeMemory(pSessionInfo);
            }
        }
    }

    return nOtherSessions;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\shtdnp.h ===
// include semi-private header
#include <shlobj.h>
#include <shlobjp.h>

/****************************************************
 Option flags (dwFlags)
 ----------------------
****************************************************/
#define SHTDN_NOHELP                            0x000000001
#define SHTDN_NOPALETTECHANGE                   0x000000002
#define SHTDN_NOBRANDINGBITMAP                  0x000000004

// Private function prototypes
DWORD ShutdownDialog(HWND hwndParent, DWORD dwItems, DWORD dwItemSelect, 
                     LPCTSTR szUsername, DWORD dwFlags, HANDLE hWlx, 
                     PWLX_DIALOG_BOX_PARAM pfnWlxDialogBoxParam);

INT_PTR WinlogonShutdownDialog( HWND hwndParent, PGLOBALS pGlobals, DWORD dwExcludeItems );
INT_PTR WinlogonDirtyDialog( HWND hwndParent, PGLOBALS pGlobals );

DWORD GetSessionCount();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dialogs.rc
//
#define IDB_SMALL_PRO_8                 101
//#define IDB_LARGE_SRV_4                 102       // large BMPs no longer used
#define IDB_BAND_8                      103
#define IDD_WAITDOMAINCACHEVALID_DIALOG 104
//#define ANNOY_AUTOLOGON_REGISTRY
#ifdef ANNOY_AUTOLOGON_REGISTRY
#define IDD_ANNOYAUTOLOGON_DIALOG       105
#define IDC_COUNTDOWN_STATIC            106
#endif
#define IDB_MEDIUM_PRO_8                107
#define IDI_KEYBOARD                    109
#define IDD_WELCOMEHELP_DIALOG          109
#define IDI_SMARTCARD                   110
#define IDB_MEDIUM_PRO_4                111
#define IDB_MEDIUM_SRV_4                112
#define IDB_SMALL_PRO_4                 113
#define IDB_SMALL_SRV_4                 114
#define IDI_LOCKED                      115
#define IDI_UNLOCKED                    116
#define IDI_UNLOCK                      116
#define IDB_BAND_4                      117
#define IDB_SMALL_ADV_4                 118
#define IDB_MEDIUM_ADV_4                119
//#define IDB_LARGE_ADV_4                 120       // large BMPs no longer used
#define IDB_SMALL_DCS_4                 121
#define IDB_MEDIUM_DCS_4                122
//#define IDB_LARGE_DCS_4                 123       // large BMPs no longer used
//#define IDB_LARGE_PRO_4                 124       // large BMPs no longer used
#define IDB_SMALL_PER_4                 125
#define IDB_MEDIUM_PER_4                126
//#define IDB_LARGE_PER_4                 127       // large BMPs no longer used
#define IDB_SMALL_PER_8                 128
#define IDB_MEDIUM_PER_8                129
#define IDB_SMALL_SRV_8                 130
#define IDB_MEDIUM_SRV_8                131
#define IDB_SMALL_ADV_8                 132
#define IDB_MEDIUM_ADV_8                133
#define IDB_SMALL_DCS_8                 134
#define IDB_MEDIUM_DCS_8                135
#define IDB_SMALL_PROEMB_8              136
#define IDB_MEDIUM_PROEMB_8             137
#define IDB_MEDIUM_PROEMB_4             138
#define IDB_SMALL_PROEMB_4              139
#define IDB_MEDIUM_SBS_4                140
#define IDB_MEDIUM_BLA_4                141
#define IDB_SMALL_SBS_4                 142
#define IDB_SMALL_BLA_4                 143
#define IDB_MEDIUM_SBS_8                144
#define IDB_MEDIUM_BLA_8                145
#define IDB_SMALL_SBS_8                 146
#define IDB_SMALL_BLA_8                 147

#define IDD_WELCOME_DIALOG              1400
#define IDD_LOGON_DIALOG                1500
#define IDD_LOGON_SHUTDOWN              1501
#define IDD_LOGON_NAME                  1502
#define IDD_LOGON_PASSWORD              1503
#define IDD_LOGON_DOMAIN                1504
#define IDD_LOGON_RASBOX                1505
#define IDD_LOGON_NAME_LABEL            1506
#define IDD_LOGON_PASSWORD_LABEL        1507
#define IDD_LOGON_DOMAIN_LABEL          1508
#define IDD_LOGON_OPTIONS               1514
#define IDD_NODC_DIALOG                 1600
#define IDD_NODC_TEXT1                  1601
#define IDD_NODC_TEXT2                  1602
#define IDD_NODC_CHECK                  1603
#define IDD_NODC_FRAME                  1604
#define IDD_CHANGEPWD_DIALOG            1700
#define IDD_CHANGEPWD_NAME_LABEL        1701
#define IDD_CHANGEPWD_NAME              1702
#define IDD_CHANGEPWD_DOMAIN_LABEL      1703
#define IDD_CHANGEPWD_DOMAIN            1704
#define IDD_CHANGEPWD_OLD_LABEL         1705
#define IDD_CHANGEPWD_OLD               1706
#define IDD_CHANGEPWD_NEW_LABEL         1707
#define IDD_CHANGEPWD_NEW               1708
#define IDD_CHANGEPWD_CONFIRM_LABEL     1709
#define IDD_CHANGEPWD_CONFIRM           1710
#define IDD_LOCKED_LINE                 1752
#define IDD_LOCKED_INSTRUCTIONS         1754
#define IDD_OPTIONS_DIALOG              1800
#define IDD_OPTIONS_LOCK                1800
#define IDD_OPTIONS_LOGOFF              1801
#define IDD_OPTIONS_SHUTDOWN            1802
#define IDD_OPTIONS_CHANGEPWD           1803
#define IDD_OPTIONS_TASKLIST            1804
#define IDD_OPTIONS_TASKMGR_TEXT        1805
#define IDD_OPTIONS_LOGON_NAME_INFO     1806
#define IDD_OPTIONS_LOGON_DATE          1807
#define IDD_UNLOCK_MESSAGE              1852
#define IDC_UNLOCK_NAME_LABEL           1858
#define IDD_LOCKED_DIALOG               1900
#define IDD_LOCKED_NAME_INFO            1902
#define IDC_UNLOCK_PASSWORD_LABEL       1931
#define IDD_UNLOCK_DIALOG               1950
#define IDD_UNLOCK_NAME_INFO            1952
#define IDD_UNLOCK_NAME                 1953
#define IDD_UNLOCK_PASSWORD             1954
#define IDD_UNLOCK_DOMAIN               1956
#define IDD_UNLOCK_DOMAIN_LABEL         1957
#define IDD_PROGRESS_DIALOG             2000
#define IDD_EXITWINDOWS_DIALOG          2200
#define IDC_EXITOPTIONS_COMBO           2201
#define IDC_EXITOPTIONS_DESCRIPTION     2202
#define IDC_EXITREASONS_COMBO           2204
#define IDC_EXITREASONS_DESCRIPTION     2205
#define IDC_EXITREASONS_CHECK     	2206

#define IDD_DIRTY_DIALOG                2210
#define IDC_DIRTYREASONS_COMBO          2211
#define IDC_DIRTYREASONS_DESCRIPTION    2212
#define IDC_DIRTYREASONS_COMMENT        2213
#define IDC_DIRTYREASONS_BUGID          2214

#define IDD_LOGOFFWINDOWS_DIALOG        2250
#define IDD_LOGOFFICON                  2251
#define IDD_RESTART                     2302
#define IDD_SHUTDOWN                    2305
#define IDD_LOGON_ANNOUNCE              2400
#define IDD_UNLOCK_OPTIONS              2401
#define IDD_LOGON_ANIMATE               2402
#define IDD_LOCKED_ICON                 2403
#define IDD_UNLOCK_ICON                 2404
#define IDD_KBLAYOUT_ICON               2406
#define IDC_SMARTCARD                   2407
#define IDC_KEYBOARD                    2408
#define IDC_PRESSCAD                    2409
#define IDC_HELPLINK                    2410
#define IDC_HELPTEXT                    2411
#define IDC_ANIMATE                     2412
#define IDA_ANIMATE                     2413
#define IDC_HELPTITLE                   2414
#define IDC_CTRL                        2415
#define IDC_ALT                         2416
#define IDC_DEL                         2417
#define IDC_STATIC_WELCOMEGROUP         2418
#define IDC_STATIC_LOCKEDGROUP          2419
#define IDD_CTRL_DEL_MSG                2420
#define IDC_GROUP_UNLOCK                2421
#define IDD_STATUS_MESSAGE_DIALOG       2450
#define IDC_STATUS_MESSAGE_TEXT         2451
#define IDD_LEGALMSG                    2500
#define IDD_LEGALTEXT                   2501
#define IDC_EXITREASONS_COMMENT         2502
#define IDC_EXITREASONS_HEADER          2503
#define IDC_STATIC_REASON_COMMENT	    2504
#define IDC_STATIC_REASON_OPTION	    2505
#define IDC_RESTARTEVENTTRACKER_GRPBX	2506
#define IDD_FAILLOGONHELP_DIALOG        2507
#define IDC_RECOVER                     2508
#define IDC_BACKUP                     2509
#define IDC_STATIC                      -1


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        124
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2422
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\shutdown.h ===
//
//  The Shutdown Query dialog and Logoff Windows NT dialog
//  are shared by Progman (included in windows\shell\progman\progman.dlg),
//  and therefore changes to them or the filename should not be made
//  unless tested with Progman first.
//  This header file is included in windows\shell\progman\pmdlg.h
//
//  11/10/92  johannec
//

#define DLGSEL_LOGOFF                   0
#define DLGSEL_SHUTDOWN                 1
#define DLGSEL_SHUTDOWN_AND_RESTART     2
#define DLGSEL_SHUTDOWN_AND_RESTART_DOS 3
#define DLGSEL_SLEEP                    4
#define DLGSEL_SLEEP2                   5
#define DLGSEL_HIBERNATE                6


#define WINLOGON_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"
#define SHUTDOWN_SETTING_KEY L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
#define SHUTDOWN_SETTING L"Shutdown Setting"
#define REASON_SETTING L"Reason Setting"
#define LOGON_USERNAME_SETTING L"Logon User Name"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\status.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       status.c
//
//  Contents:   Status UI
//
//  History:    11-19-98   EricFlo   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"

#define WM_HIDEOURSELVES    (WM_USER + 1000)

//*************************************************************
//
//  StatusMessageDlgProc()
//
//  Purpose:    Dialog box procedure for the status dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/19/98    EricFlo    Created
//
//*************************************************************

INT_PTR APIENTRY StatusMessageDlgProc (HWND hDlg, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam)
{

    switch (uMsg) {

        case WM_INITDIALOG:
            {
            RECT rc;
            DWORD dwAnimationTimeSlice;
            PGLOBALS pGlobals = (PGLOBALS) lParam;

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGlobals);

            SizeForBranding(hDlg, FALSE);
            CentreWindow (hDlg);

            pGlobals->xStatusBandOffset = 0;

            if (GetClientRect(hDlg, &rc)) {
                pGlobals->cxStatusBand = rc.right-rc.left;
            } else {
                pGlobals->cxStatusBand = 100;
            }

            if (_Shell_LogonStatus_Exists())
            {
                SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOZORDER);
                PostMessage(hDlg, WM_HIDEOURSELVES, 0, 0);
            }

            if ((pGlobals->dwStatusOptions & STATUSMSG_OPTION_NOANIMATION) == 0) {
                dwAnimationTimeSlice = GetAnimationTimeInterval(pGlobals);
                SetTimer(hDlg, 0, dwAnimationTimeSlice, NULL);
            }
            }
            return TRUE;

        case WM_HIDEOURSELVES:
            ShowWindow(hDlg, SW_HIDE);
            break;

        case WM_TIMER:

            if (wParam == 0)
            {
                PGLOBALS pGlobals = (PGLOBALS) GetWindowLongPtr(hDlg, DWLP_USER);
                HDC hDC;

                if (pGlobals)
                {
                     pGlobals->xStatusBandOffset = (pGlobals->xStatusBandOffset+5) % pGlobals->cxStatusBand;
                     
                     hDC = GetDC(hDlg);
                     if ( hDC )
                     {
                         PaintBranding(hDlg, hDC, pGlobals->xStatusBandOffset, TRUE, FALSE, COLOR_BTNFACE);
                         ReleaseDC(hDlg, hDC);
                     }
                }
            }
            break;

        case WM_ERASEBKGND:
            {
            PGLOBALS pGlobals = (PGLOBALS) GetWindowLongPtr(hDlg, DWLP_USER);

            if (pGlobals) {
                return PaintBranding(hDlg, (HDC)wParam, pGlobals->xStatusBandOffset, FALSE, FALSE, COLOR_BTNFACE);
            }

            return 0;
            }

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_DESTROY:
            KillTimer (hDlg, 0);
            break;

        default:
            break;
    }

    return FALSE;
}

//*************************************************************
//
//  StatusMessageThread()
//
//  Purpose:    Status message thread
//
//  Parameters: hDesktop  - Desktop handle to put UI on
//
//  Return:     void
//
//  History:    Date        Author     Comment
//              11/19/98    EricFlo    Created
//
//*************************************************************

void StatusMessageThread (PGLOBALS pGlobals)
{
    HANDLE hInstDll;
    MSG msg;
    DWORD dwResult;
    HANDLE hObjects[2];


    hInstDll = LoadLibrary (TEXT("msgina.dll"));

    if (pGlobals->hStatusDesktop) {
        SetThreadDesktop (pGlobals->hStatusDesktop);
    }

    pGlobals->hStatusDlg = CreateDialogParam (hDllInstance,
                                              MAKEINTRESOURCE(IDD_STATUS_MESSAGE_DIALOG),
                                              NULL, StatusMessageDlgProc,
                                              (LPARAM) pGlobals);

    SetEvent (pGlobals->hStatusInitEvent);

    if (pGlobals->hStatusDlg) {

        hObjects[0] = pGlobals->hStatusTermEvent;

        while (TRUE) {
            dwResult = MsgWaitForMultipleObjectsEx (1, hObjects, INFINITE,
                                                   (QS_ALLPOSTMESSAGE | QS_ALLINPUT),
                                                   MWMO_INPUTAVAILABLE);

            if (dwResult == WAIT_FAILED) {
                break;
            }

            if (dwResult == WAIT_OBJECT_0) {
                break;
            }

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                if (!IsDialogMessage (pGlobals->hStatusDlg, &msg)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

                if (WaitForSingleObject (pGlobals->hStatusTermEvent, 0) == WAIT_OBJECT_0) {
                    goto ExitLoop;
                }
            }
        }

ExitLoop:
        DestroyWindow(pGlobals->hStatusDlg);
        pGlobals->hStatusDlg = NULL;
    }


    if (hInstDll) {
        FreeLibraryAndExitThread(hInstDll, TRUE);
    } else {
        ExitThread (TRUE);
    }
}


//
// Creates and displays the initial status message
//

        // Set in WlxInitialize
DWORD g_dwMainThreadId = 0;     // Creation or removal of the status dialog is not thread safe.
                                // It is kind of difficult to fix with a critsec because of
                                // the mix of objects and windows messages. one can't hold
                                // a critsec accross a window message call as it would introduce
                                // the possibility of deadlocks
                                

BOOL
WINAPI
WlxDisplayStatusMessage(PVOID pWlxContext,
                        HDESK hDesktop,
                        DWORD dwOptions,
                        PWSTR pTitle,
                        PWSTR pMessage)
{
    PGLOBALS  pGlobals = (PGLOBALS) pWlxContext;
    DWORD dwThreadId;
    HANDLE hProcess;

    if (!pGlobals) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (g_dwMainThreadId == GetCurrentThreadId())   // Denies creation/deletion on other threads
    {                                               // than the main thread of winlogon
        if (!pGlobals->hStatusDlg) {

            if (!ReadWinlogonBoolValue(DISABLE_STATUS_MESSAGES, FALSE)) {

                pGlobals->hStatusInitEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
                pGlobals->hStatusTermEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

                if (pGlobals->hStatusInitEvent && pGlobals->hStatusTermEvent) {
                    hProcess = GetCurrentProcess();
                    if ( FALSE == DuplicateHandle(
                                        hProcess,
                                        hDesktop,
                                        hProcess,
                                        &(pGlobals->hStatusDesktop),
                                        0,      // ignored, DUPLICATE_SAME_ACCESS is set
                                        FALSE,  // no inherit on the handle
                                        DUPLICATE_SAME_ACCESS) )
                    {
                        DebugLog((DEB_ERROR, "DuplicateHandle failed: %#x", GetLastError()));
                        return FALSE;
                    }

                    //
                    // Set the globals here so that StatusMessageDlgProc can look at them in WM_INITDIALOG.
                    //
                
                    pGlobals->dwStatusOptions = dwOptions;

                    pGlobals->hStatusThread = CreateThread (NULL,
                                                  0,
                                                  (LPTHREAD_START_ROUTINE) StatusMessageThread,
                                                  (LPVOID) pGlobals,
                                                  0,
                                                  &dwThreadId);
                    if (pGlobals->hStatusThread) {

                        DWORD   dwWaitResult;

                        do {

                            dwWaitResult = WaitForSingleObject(pGlobals->hStatusInitEvent, 0);
                            if (dwWaitResult != WAIT_OBJECT_0) {

                                dwWaitResult = MsgWaitForMultipleObjects(1,
                                                   &pGlobals->hStatusInitEvent,
                                                   FALSE,
                                                   INFINITE,
                                                   QS_ALLPOSTMESSAGE | QS_ALLINPUT);
                                if (dwWaitResult == WAIT_OBJECT_0 + 1) {

                                    MSG     msg;

                                    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                    }
                                }
                             }
                        } while (dwWaitResult == WAIT_OBJECT_0 + 1);
                    }
                }
            }
        }
    }

    if (pGlobals->hStatusDlg) {

        if (pTitle) {
            SetWindowText (pGlobals->hStatusDlg, pTitle);
        }

        SetDlgItemText (pGlobals->hStatusDlg, IDC_STATUS_MESSAGE_TEXT, pMessage);

        _Shell_LogonStatus_ShowStatusMessage(pMessage);

        if (dwOptions & STATUSMSG_OPTION_SETFOREGROUND) {
            SetForegroundWindow (pGlobals->hStatusDlg);
        }
    }

    return TRUE;
}

//
// Gets the current status message
//

BOOL
WINAPI
WlxGetStatusMessage(PVOID pWlxContext,
                    DWORD *pdwOptions,
                    PWSTR pMessage,
                    DWORD dwBufferSize)
{
    PGLOBALS  pGlobals = (PGLOBALS) pWlxContext;
    DWORD dwLen;


    if (!pGlobals || !pMessage) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    dwLen = (DWORD) SendDlgItemMessage (pGlobals->hStatusDlg, IDC_STATUS_MESSAGE_TEXT,
                                        WM_GETTEXTLENGTH, 0, 0);

    if (dwBufferSize < dwLen) {
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    GetDlgItemText (pGlobals->hStatusDlg, IDC_STATUS_MESSAGE_TEXT,
                    pMessage, dwBufferSize);

    if (pdwOptions) {
        *pdwOptions = pGlobals->dwStatusOptions;
    }

    return TRUE;
}


//
// Removes the status dialog
//

BOOL
WINAPI
WlxRemoveStatusMessage(PVOID pWlxContext)
{
    PGLOBALS  pGlobals = (PGLOBALS) pWlxContext;


    if (!pGlobals) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (g_dwMainThreadId != GetCurrentThreadId()) { // Denies creation/deletion on other threads
        return FALSE;
    }

    if (pGlobals->hStatusTermEvent) {

        SetEvent(pGlobals->hStatusTermEvent);

        if (pGlobals->hStatusThread) {

            if (pGlobals->hStatusDlg) {

                DWORD   dwWaitResult;

                do {

                    dwWaitResult = WaitForSingleObject(pGlobals->hStatusThread, 0);
                    if (dwWaitResult != WAIT_OBJECT_0) {

                        dwWaitResult = MsgWaitForMultipleObjects(1,
                                           &pGlobals->hStatusThread,
                                           FALSE,
                                           10000,
                                           QS_ALLPOSTMESSAGE | QS_ALLINPUT);
                        if (dwWaitResult == WAIT_OBJECT_0 + 1) {

                            MSG     msg;

                            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                     }
                } while (dwWaitResult == WAIT_OBJECT_0 + 1);
            }

            CloseHandle (pGlobals->hStatusThread);
        }

        CloseHandle (pGlobals->hStatusTermEvent);
    }

    if (pGlobals->hStatusInitEvent) {
        CloseHandle (pGlobals->hStatusInitEvent);
    }

    pGlobals->hStatusInitEvent = NULL;
    pGlobals->hStatusTermEvent = NULL;
    pGlobals->hStatusThread = NULL;

    if (pGlobals->hStatusDesktop)
    {
        //
        // We duplicate the handle so we should always close
        //
        // OLD COMMENT:
        // Close the desktop handle here.  Since the status thread
        // was using it, Winlogon was unable to close the handle
        // itself so we have to do it now.
        //
        CloseDesktop(pGlobals->hStatusDesktop);
        pGlobals->hStatusDesktop = NULL;
    }

    pGlobals->hStatusDlg = NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\stringid.h ===
/****************************** Module Header ******************************\
* Module Name: stringid.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines resource ids for resources other than dialogs
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Strings
//
#define IDS_LOCKED_MESSAGE              1500
#define IDS_LOGON_MESSAGE               1501
#define IDS_INCORRECT_NAME_OR_PWD_CHANGE 1502
#define IDS_PASSWORD_WILL_EXPIRE        1503
#define IDS_PASSWORD_EXPIRES_TODAY      1504
#define IDS_INCORRECT_NAME_OR_PWD       1505
#define IDS_LOGON_NO_DOMAIN             1506
#define IDS_PASSWORD_EXPIRED            1507
#define IDS_GENERAL_PASSWORD_SPEC       1508
#define IDS_CHANGE_PASSWORD             1509
#define IDS_NO_PERMISSION_CHANGE_PWD    1510
#define IDS_PASSWORD_MINIMUM_AGE        1511
#define IDS_NO_PASSWORD_CONFIRM         1512
#define IDS_PASSWORD_SPEC               1513
#define IDS_ENTER_PASSWORDS             1514
#define IDS_PASSWORD_CHANGED            1515
#define IDS_CHANGE_PWD_NO_DOMAIN        1516
#define IDS_UNLOCK_FAILED               1517
#define IDS_WORKSTATION_LOCKED          1518
#define IDS_LOGON_NAME_INFO             1519
#define IDS_RESTART_SYSTEM              1520
#define IDS_ACCOUNT_RESTRICTION_CHANGE  1521
#define IDS_ACCOUNT_RESTRICTION         1522
#define IDS_UNKNOWN_LOGON_FAILURE       1523
#define IDS_WINDOWS_MESSAGE             1524
#define IDS_NO_PERMISSION_SHUTDOWN      1525
#define IDS_SAFE_TO_TURN_OFF            1526
#define IDS_SHUTDOWN_MESSAGE            1527
#define IDS_FORCE_LOGOFF_WARNING        1528

#define IDS_LOGON_TYPE_NOT_GRANTED      1529
#define IDS_INVALID_LOGON_HOURS         1530
#define IDS_INVALID_WORKSTATION         1531
#define IDS_ACCOUNT_DISABLED            1532

#define IDS_AUDITING_DISABLED           1533
#define IDS_AUDITING_NOT_DISABLED       1534
#define IDS_CARD_NOT_RECOGNIZED         1535
#define IDS_CARD_CSP_NOT_RECOGNIZED     1536

#define IDS_LOAD_PROFILE                1538
#define IDS_USE_DEFAULT_PROFILE         1539

#define IDS_EMERGENCY_SHUTDOWN          1540
#define IDS_REBOOT_LOSE_CHANGES         1541

#define IDS_NO_TRUST_LSA_SECRET         1542
#define IDS_TRUSTED_DOMAIN_FAILURE      1543
#define IDS_TRUSTED_RELATIONSHIP_FAILURE 1544

#define IDS_LOCKED_NFN_MESSAGE          1550
#define IDS_LOGON_NAME_NFN_INFO         1551
#define IDS_UNLOCK_FAILED_NFN           1552
#define IDS_UNLOCK_FAILED_BAD_PWD       1553

#define IDS_PASSWORD_MUST_CHANGE        1554
#define IDS_INCORRECT_NAME_OR_PWD_SC    1555
#define IDS_UNLOCK_FAILED_BAD_PIN       1556
#define IDS_NO_DOMAIN_AND_NO_UPN        1557
#define IDS_LONG_PASSWORD_WARNING       1558

#define IDS_MBTWRONGDOMAIN              1559
#define IDS_MBMWRONGDOMAIN              1560
#define IDS_FORCE_LOGOFF_UPN_WARNING    1561

#define IDS_SYSTEM_SCREEN_SAVER_NAME    1564


#define IDS_SOUND_DLL                   1570
#define IDS_WAVEOUTGETNUMDEVS           1571
#define IDS_PLAYSOUND                   1572

#define IDS_REQUIRES_PRIMARY_CONTROLLER 1579
#define IDS_NO_PAGING_FILE              1580
#define IDS_LIMITED_RESOURCES           1581

#define IDS_INVALID_TIME                1582
#define IDS_INVALID_TIME_MSG            1583

#define IDS_ACCOUNT_EXPIRED             1584
#define IDS_NETLOGON_NOT_STARTED        1585
#define IDS_UNKNOWN_CHANGE_PWD_FAILURE  1586
#define IDS_FORCE_LOGOFF_FAILURE        1587
#define IDS_CACHED_LOGON                1588
#define IDS_NO_TRUSTED_DOMAINS          1589

#define IDS_SETUP_INCOMPLETE            1590

#define IDS_MANDATORY_PROFILE_ERROR     1591
#define IDS_LOGON_NO_ACCESS_MAN_PROFILE_KEYS    1592
#define IDS_LOGON_NO_ACCESS_MAN_PROFILE         1593

#define IDS_LOGON_CANT_LOAD_PROFILE     1595
#define IDS_LOGON_UPDATE_CENTRAL        1598
#define IDS_LOGON_CACHED_PROFILE_USED   1599
#define IDS_LOGON_UPDATE_CENTRAL_FAILED 1600
#define IDS_LOGON_FAILED_DISK_FULL      1601
#define IDS_LOGON_FAILED_OUTOFMEMORY    1602
#define IDS_ACCOUNT_LOCKED              1603
#define IDS_LOGON_WITH_DISK_FULL        1604
#define IDS_LOGOFF_TITLE                1606
#define IDS_LOGOFF_LOSE_CHANGES         1607
#define IDS_WELCOME_CAPTION             1608
#define IDS_LOGON_BAD_SC                1609
#define IDS_TIME_DIFFERENCE_AT_DC       1621

#define IDS_IDLETIME_INDAYS             1625
#define IDS_IDLETIME_INHOURS            1626
#define IDS_IDLETIME_INMINUTES          1627
#define IDS_IDLETIME_INDAYSANDHOURS     1628
#define IDS_IDLETIME_INHOURSANDMINUTES  1629

#define IDS_STATUS_SMARTCARD_WRONG_PIN  1630
#define IDS_STATUS_SMARTCARD_CARD_BLOCKED   1631
#define IDS_STATUS_SMARTCARD_NO_CARD    1632
#define IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER   1633
#define IDS_STATUS_SMARTCARD_NO_CERTIFICATE 1634
#define IDS_STATUS_SMARTCARD_NO_KEYSET  1635
#define IDS_STATUS_SMARTCARD_IO_ERROR   1636
#define IDS_STATUS_SMARTCARD_SUBSYSTEM_FAILURE  1637
#define IDS_STATUS_NO_TRUST_SAM_ACCOUNT 1638
#define IDS_STATUS_SERVER_SIDE_ERROR    1639
#define IDS_STATUS_SERVER_SIDE_ERROR_NOINSERT   1640
#define IDS_LOGON_NO_DOMAIN_NOINSERT    1641
#define IDS_UNKNOWN_LOGON_FAILURE_NOINSERT      1642
#define IDS_STATUS_SMARTCARD_CERT_REVOKED       1643
#define IDS_STATUS_ISSUING_CA_UNTRUSTED         1644
#define IDS_STATUS_REVOCATION_OFFLINE_C         1645
#define IDS_STATUS_PKINIT_CLIENT_FAILURE        1647
#define IDS_STATUS_SMARTCARD_CERT_EXPIRED       1648

#define IDS_STATUS_SMARTCARD_WRONG_PIN_UNLOCK           1650
#define IDS_STATUS_SMARTCARD_CARD_BLOCKED_UNLOCK        1651
#define IDS_STATUS_SMARTCARD_NO_CARD_UNLOCK             1652     
#define IDS_STATUS_SMARTCARD_NO_KEY_CONTAINER_UNLOCK    1653
#define IDS_STATUS_SMARTCARD_NO_CERTIFICATE_UNLOCK      1654
#define IDS_STATUS_SMARTCARD_NO_KEYSET_UNLOCK           1655
#define IDS_STATUS_SMARTCARD_IO_ERROR_UNLOCK            1656    
#define IDS_STATUS_SMARTCARD_CERT_EXPIRED_UNLOCK        1657
#define IDS_STATUS_SMARTCARD_CERT_REVOKED_UNLOCK        1658
#define IDS_STATUS_ISSUING_CA_UNTRUSTED_UNLOCK          1659
#define IDS_STATUS_REVOCATION_OFFLINE_C_UNLOCK          1660
#define IDS_STATUS_PKINIT_CLIENT_FAILURE_UNLOCK         1661
#define IDS_STATUS_SMARTCARD_LOGON_REQUIRED_UNLOCK      1662

#define IDS_ADMIN_ACCOUNT_NAME          1700
#define IDS_LOGON_LOG_FULL_ADMIN        1701
#define IDS_LOGON_LOG_FULL              1702
#define IDS_DEFAULT_DESKTOP             1703
#define IDS_SET_DIRTY_UI_TIMEOUT        1704

#define IDS_MOREOPTIONS                 1800
#define IDS_LESSOPTIONS                 1801
#define IDS_PIN                         1802

#define IDS_PRESSCAD                    1810
#define IDS_PRESSCADORSMARTCARD         1811

#define IDS_PRESSCAD_FACENAME           1812
#define IDS_PRESSCAD_FACESIZE           1813

#define IDS_RELEASE_TEXT                1814
#define IDS_RELEASE_FACENAME            1815
#define IDS_RELEASE_FACESIZE            1816

#define IDS_COPYRIGHT_TEXT              1818
#define IDS_COPYRIGHT_FACENAME          1819
#define IDS_COPYRIGHT_FACESIZE          1820

#define IDS_THISCOMPUTER                1821

#define IDS_COMPLEX_PASSWORD_SPEC       1824
#define IDS_PASSWORD_TOO_LONG           1825
#define IDS_ACCOUNT_EXPIRED2            1826
#define IDS_SMARTCARD_REQUIRED          1827

#define IDS_PRESSCAE                    1828
#define IDS_PRESSCAEORSMARTCARD         1829

#define IDS_PRESSCAD_FONTNAME           1830

//
// These are the domain modifiers.  Their order is dependent on
// the DOMAIN_CACHE_TYPE in domain.h.  Do not change the
// order without changing that header
//

#define IDS_DTYPE_UPNDOMAIN             1850
#define IDS_DTYPE_THISCOMPUTER          1851
#define IDS_DTYPE_NT4DOMAIN             1852
#define IDS_DTYPE_NT5DOMAIN             1853
#define IDS_DTYPE_MITDOMAIN             1854
#define IDS_DTYPE_MITXDOMAIN            1855
#define IDS_DTYPE_NETPROVIDER           1856

#define IDS_LOGON_SC_REQUIRED           1900
#define IDS_UNLOCK_SC_REQUIRED          1901

#define IDS_LOGON_SMARTCARD_PWD_CHANGE  1910
#define IDS_UNLOCK_PWD_CHANGE           1911

//
// Icons
//


#define IDI_NODC_ICON                   13
#define IDI_STLOGOFF                    21
#define IDI_SHUTDOWN                    22


//
// EMAIL logon support
//

#define IDS_LOCKED_EMAIL_MESSAGE        1610
#define IDS_LOCKED_EMAIL_NFN_MESSAGE    1611
#define IDS_UNLOCK_FAILED_EMAIL         1612
#define IDS_UNLOCK_FAILED_EMAIL_NFN     1613
#define IDS_LOGON_EMAIL_NAME_NFN_INFO   1614
#define IDS_LOGON_EMAIL_NAME_INFO       1615
#define IDS_LOCKED_NO_USER_MESSAGE      1620

// captions 
#define IDS_CAPTION_LOCKED_DIALOG       1616
#define IDS_CAPTION_WELCOME_DIALOG      1617
#define IDS_CAPTION_LOGON_DIALOG        1618
#define IDS_CAPTION_UNLOCK_DIALOG       1619


#define IDS_MULTIUSER_CONNECT_FAILED                   2000
#define IDS_MULTIUSER_CONNECT_NOT_SUPPORTED            2001
#define IDS_MULTIUSER_UNEXPECTED_CONNECT_FAILURE       2002
#define IDS_MULTIUSER_DISCONNECT_FAILED                2003
#define IDS_MULTIUSER_UNEXPECTED_DISCONNECT_FAILURE    2004
#define IDS_MULTIUSER_DISCONNECT_CAPTION               2005
#define IDS_MULTIUSER_DISCONNECT_TEXT                  2006
#define IDS_MULTIUSER_CALLBACK_ROVING_CAPTION          2007
#define IDS_MULTIUSER_CALLBACK_FIXED_CAPTION           2008
#define IDS_MULTIUSER_LOGON_DISABLED                   2009
#define IDS_MULTIUSER_NO_CALLBACK_NUMBER               2010
#define IDS_MULTIUSER_NO_CALLBACK_NUMBER_MESSAGE       2011
#define IDS_MULTIUSER_WINSTATION_ACCESS_DENIED         2012
#define IDS_MULTIUSER_ENCRYPTION_LEVEL_REQUIRED        2013
// #define IDS_MULTIUSER_DISCONNECT_OPTION                2014
#define IDS_MULTIUSER_INVALID_DOMAIN_ADMIN             2015
#define IDS_MULTIUSER_NFR_CAPTION                      2016
#define IDS_MULTIUSER_ADMINGROUP                       2017
#define IDS_MULTIUSER_SYSTEMGROUP                      2018

// Shutdown strings
#define IDS_SHUTDOWN_NAME                              8000
#define IDS_SHUTDOWN_DESC                              8001
#define IDS_RESTART_NAME                               8002
#define IDS_RESTART_DESC                               8003
#define IDS_SLEEP_NAME                                 8004
#define IDS_SLEEP_DESC                                 8005
#define IDS_SLEEP2_NAME                                8006
#define IDS_SLEEP2_DESC                                8007
#define IDS_HIBERNATE_NAME                             8008
#define IDS_HIBERNATE_DESC                             8009
#define IDS_LOGOFF_NAME                                8010
#define IDS_LOGOFF_DESC                                8011
#define IDS_RESTARTDOS_NAME                            8012
#define IDS_RESTARTDOS_DESC                            8013
#define IDS_DISCONNECT_NAME                            8014
#define IDS_DISCONNECT_DESC                            8015

// Build on NT message
#define IDS_BUILTONNT_TEXT                             8100
#define IDS_BUILTONNT_FACENAME                         8101
#define IDS_BUILTONNT_FACESIZE                         8102

// Welcome screen help messages
#define IDS_CADHELP                                    8200
#define IDS_CADSMARTCARDHELP                           8201

#define IDS_INSERTCARDORSAS_UNLOCK                     8202

// #define unused                                      8203
// #define unused                                      8204
// #define unused                                      8205
// #define unused                                      8206

#define IDS_COULDNTSETQUOTAS                           8207
#define IDS_QUOTAEXHAUSTED                             8208
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\strings.h ===
/****************************** Module Header ******************************\
* Module Name: strings.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines strings that do not need to be localized.
*
* History:
* 11-17-92 Davidc       Created.
\***************************************************************************/

//
// App name strings
//

#define WINLOGON_INI        TEXT("WINLOGON.INI")
#define WINLOGON            TEXT("WINLOGON")


//
// Define where we store the most recent logon information
//

#define APPLICATION_NAME                    TEXT("Winlogon")
#define DEFAULT_USER_NAME_KEY               TEXT("DefaultUserName")
#define TEMP_DEFAULT_USER_NAME_KEY          TEXT("AltDefaultUserName")
#define DEFAULT_DOMAIN_NAME_KEY             TEXT("DefaultDomainName")
#define TEMP_DEFAULT_DOMAIN_NAME_KEY        TEXT("AltDefaultDomainName")
#define LEGAL_NOTICE_CAPTION_KEY            TEXT("LegalNoticeCaption")
#define LEGAL_NOTICE_TEXT_KEY               TEXT("LegalNoticeText")
#define AUTO_ADMIN_LOGON_KEY                TEXT("AutoAdminLogon")
#define IGNORE_SHIFT_OVERRIDE_KEY           TEXT("IgnoreShiftOverride")
#define DEFAULT_PASSWORD_KEY                TEXT("DefaultPassword")
#define DONT_DISPLAY_LAST_USER_KEY          TEXT("DontDisplayLastUserName")
#define SHUTDOWN_WITHOUT_LOGON_KEY          TEXT("ShutdownWithoutLogon")
#define REPORT_BOOT_OK_KEY                  TEXT("ReportBootOk")
#define POWER_DOWN_AFTER_SHUTDOWN           TEXT("PowerdownAfterShutdown")

#define REPORT_CONTROLLER_MISSING           TEXT("ReportControllerMissing")
/* Value ReportControllerMissing

  A warning message indicating that a "domain controller could not be found and
  that cached user credentials will be used" will only be generated if:
  
    1. this REG_SZ value, in HKLM exists and contains the string "TRUE", 
       in uppercase, without quotes.

    - AND -

    2. the REG_DWORD value "ReportDC" in HKCU contains a non-zero value (or the value
       doesn't exist or is of the wrong type).

  Any other permutation of these two regvals will cause no message to be displayed and
  cached credentials to be used silently.

  "ReportControllerMissing" is the system-wide policy value, and "ReportDC" is the user's
  preference, which can be set by a checkbox on the warning dialog to force the message
  to be hidden even on systems with the "ReportControllerMissing" value set to "TRUE".

  - dsheldon 11/15/99
*/

#define USERINIT_KEY                        TEXT("Userinit")
#define AUTOADMINLOGON_KEY                  TEXT("AutoAdminLogon")
#define FORCEAUTOLOGON_KEY                  TEXT("ForceAutoLogon")
#define AUTOLOGONCOUNT_KEY                  TEXT("AutoLogonCount")
#define UNLOCKWORKSTATION_KEY               TEXT("ForceUnlockMode")
#define PASSWORD_WARNING_KEY                TEXT("PasswordExpiryWarning")
#define WELCOME_CAPTION_KEY                 TEXT("Welcome")
#define LOGON_MSG_KEY                       TEXT("LogonPrompt")
#define RAS_DISABLE                         TEXT("RasDisable")
#define RAS_FORCE                           TEXT("RasForce")
#define ENABLE_LOGON_HOURS                  TEXT("EnableLogonHours")
#define RESTRICT_SHELL                      TEXT("RestrictShell")

#define SC_REMOVE_OPTION                    TEXT("ScRemoveOption")
//
// Value ScRemoveOption
//
// Definition:  Controls workstation behavior when a smart card is
// used to log on, and then removed.  Range: 0, 1, 2.  Type:  REG_SZ
// 0 - no action
// 1 - lock workstation
// 2 - force logoff

#define FORCE_SC_LOGON                      TEXT("ScForceOption")
//
// Value ScForceOption
//
// Definition:  Controls workstation logon behavior with respect to the
// method used.  Range: 0, 1.  Type:  REG_DWORD
// 
// 0 - allows any kind of logons
// 1 - allows only smart card logons


#define FORCE_UNLOCK_LOGON                  TEXT("ForceUnlockLogon")
//
// Value - ForceUnlockLogon
//
// Definition:  Controls whether a full logon is performed during unlock.
// This will force a validation at the domain controller for the user 
// attempting to unlock.  Range:  0, 1.  Type:  REG_DWORD
//
// 0 - Do not force authentication inline (default)
// 1 - Require online authentication to unlock.
//

#define DCACHE_SHOW_DNS_NAMES               TEXT("DCacheShowDnsNames")
//
// do not document
//

#define DCACHE_SHOW_DOMAIN_TAGS             TEXT("DCacheShowDomainTags")
//
// do not document
//


//
// Environment variables that *we* set.
//
#define PATH_VARIABLE                       TEXT("PATH")
#define LIBPATH_VARIABLE                    TEXT("LibPath")
#define OS2LIBPATH_VARIABLE                 TEXT("Os2LibPath")
#define AUTOEXECPATH_VARIABLE               TEXT("AutoexecPath")
#define HOMEDRIVE_VARIABLE                  TEXT("HOMEDRIVE")
#define HOMESHARE_VARIABLE                  TEXT("HOMESHARE")
#define HOMEPATH_VARIABLE                   TEXT("HOMEPATH")
#define INIDRIVE_VARIABLE                   TEXT("INIDRIVE")
#define INIPATH_VARIABLE                    TEXT("INIPATH")
#define CLIENTNAME_VARIABLE                 TEXT("CLIENTNAME")
#define SMARTCARD_VARIABLE                  TEXT("SMARTCARD")

#define USERNAME_VARIABLE                   TEXT("USERNAME")
#define USERDOMAIN_VARIABLE                 TEXT("USERDOMAIN")
#define LOGONSERVER_VARIABLE                TEXT("LOGONSERVER")
#define USERDNSDOMAIN_VARIABLE              TEXT("USERDNSDOMAIN")

#define USER_ENV_SUBKEY                     TEXT("Environment")
#define USER_VOLATILE_ENV_SUBKEY            TEXT("Volatile Environment")

#define ROOT_DIRECTORY          TEXT("\\")
#define USERS_DIRECTORY         TEXT("\\users")
#define USERS_DEFAULT_DIRECTORY TEXT("\\users\\default")

#define NULL_STRING             TEXT("")
//
// Define where we get screen-saver information
//

#define SCREEN_SAVER_INI_FILE               TEXT("system.ini")
#define SCREEN_SAVER_INI_SECTION            TEXT("boot")
#define SCREEN_SAVER_FILENAME_KEY           TEXT("SCRNSAVE.EXE")
#define SCREEN_SAVER_SECURE_KEY             TEXT("ScreenSaverIsSecure")

#define WINDOWS_INI_SECTION                 TEXT("Windows")
#define SCREEN_SAVER_ENABLED_KEY            TEXT("ScreenSaveActive")

#define OPTIMIZED_LOGON_VARIABLE            TEXT("UserInitOptimizedLogon")
#define LOGON_SERVER_VARIABLE               TEXT("UserInitLogonServer")
#define LOGON_SCRIPT_VARIABLE               TEXT("UserInitLogonScript")
#define MPR_LOGON_SCRIPT_VARIABLE           TEXT("UserInitMprLogonScript")
#define USER_INIT_AUTOENROLL                TEXT("UserInitAutoEnroll")
#define AUTOENROLL_NONEXCLUSIVE             TEXT("1")
#define AUTOENROLL_EXCLUSIVE                TEXT("2")
#define USER_INIT_AUTOENROLLMODE            TEXT("UserInitAutoEnrollMode")
#define AUTOENROLL_STARTUP                  TEXT("1")
#define AUTOENROLL_WAKEUP                   TEXT("2")
#define WINLOGON_USER_KEY                   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SCREENSAVER_KEY                     TEXT("Control Panel\\Desktop")

#define NODCMESSAGE                         TEXT("ReportDC")
// ReportDC Value - see description for ReportControllerMissing above for usage

#define PASSWORD_EXPIRY_WARNING             TEXT("PasswordExpiryWarning")


//
// Policies
//

#define WINLOGON_POLICY_KEY                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")
#define DISABLE_LOCK_WKSTA                  TEXT("DisableLockWorkstation")
#define DISABLE_TASK_MGR                    TEXT("DisableTaskMgr")
#define DISABLE_CHANGE_PASSWORD             TEXT("DisableChangePassword")
#define DISABLE_CAD                         TEXT("DisableCAD")
#define SHOW_LOGON_OPTIONS                  TEXT("ShowLogonOptions")
#define DISABLE_STATUS_MESSAGES             TEXT("DisableStatusMessages")

#define EXPLORER_POLICY_KEY                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")
#define NOLOGOFF                            TEXT("NoLogoff")
#define NOCLOSE                             TEXT("NoClose")
#define NODISCONNECT                        TEXT("NoDisconnect")

#define SCREENSAVER_POLICY_KEY              TEXT("Software\\Policies\\Microsoft\\Windows\\Control Panel\\Desktop")

//
// Things to control auto-enrollment.
//
#define AUTOENROLL_KEY                      TEXT("Software\\Microsoft\\Cryptography\\AutoEnrollment")
#define AUTOENROLL_FLAGS                    TEXT("Flags")

// HKLM\sw\ms\windows nt\currentversion\winlogon DWORD NoDomainUI
// Doesn't exist or 0x0: Show Domain combobox if appropriate
// Does exist and is non-0x0: Hide Domain box in all cases (force UPN or local login)
#define NODOMAINCOMBO                       TEXT("NoDomainUI")

#define ANY_LOGON_PROVIDER                  "<any>"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\win31mig.h ===
/****************************** Module Header ******************************\
* Module Name: win31mig.h
*
* Copyright (c) 1993, Microsoft Corporation
*
* Constants for the Windows 3.1 Migration dialog
*
* NOTE - this file is maintained by dlgedit. Do not edit directly
*
* History:
* 01-08-93 Stevewo      Created.
\***************************************************************************/

#ifndef RC_INVOKED
#if 0
BOOL
Windows31Migration(
    PGLOBALS pGlobals
    );
#endif
#endif  /* !RC_INVOKED */

#define IDD_WIN31MIG                801
#define IDD_WIN31MIG_INIFILES       802
#define IDD_WIN31MIG_GROUPS         803
#define IDD_WIN31MIG_STATUS         804
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\welcome.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       welcome.c
//
//  Contents:   Microsoft Logon GUI DLL
//
//  History:    7-14-94   RichardW   Created
//
//----------------------------------------------------------------------------

#include "msgina.h"
#include "wtsapi32.h"
#include <stdio.h>
#include <wchar.h>



extern HICON   hLockedIcon;


// Welcome help screen stuff --dsheldon (11/16/98)

// Display the help text for the Ctrl-Alt-Del help dlg --dsheldon
void ShowHelpText(HWND hDlg, BOOL fSmartcard)
{
    TCHAR szHelpText[2048];
    UINT idHelpText = fSmartcard ? IDS_CADSMARTCARDHELP : IDS_CADHELP;

    LoadString(hDllInstance, idHelpText, szHelpText, ARRAYSIZE(szHelpText));

    SetDlgItemText(hDlg, IDC_HELPTEXT, szHelpText);
}

// Help dialog wndproc --dsheldon
INT_PTR WINAPI
HelpDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HBRUSH hbrWindow = NULL;
    static HFONT hBoldFont = NULL;
    PGLOBALS pGlobals;
    INT_PTR fReturn = FALSE;
    ULONG_PTR Value = 0;

    switch(message)
    {
    case WM_INITDIALOG:
        {
            HWND hwndAnim;
            HWND hwndHelpTitle;
            HFONT hOld;

            hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            pGlobals = (PGLOBALS) lParam;

            pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_SMART_CARD_PRESENT,
                                     &Value
                                    );
        
            ShowHelpText(hDlg, (0 != Value));

            // Animate the press-cad puppy
            hwndAnim = GetDlgItem(hDlg, IDC_ANIMATE);
            Animate_OpenEx(hwndAnim, hDllInstance, MAKEINTRESOURCE(IDA_ANIMATE));
            Animate_Play(hwndAnim, 0, (UINT) -1, (UINT) -1);
            
            // Bold the help title and the Ctrl Alt Delete words
            hwndHelpTitle = GetDlgItem(hDlg, IDC_HELPTITLE);
            hOld = (HFONT) SendMessage(hwndHelpTitle, WM_GETFONT, 0, 0);

            if (hOld)
            {
                LOGFONT lf;
                if (GetObject(hOld, sizeof(lf), &lf))
                {
                    lf.lfHeight = -13;
                    lf.lfWeight = FW_BOLD;

                    hBoldFont = CreateFontIndirect(&lf);

                    if (hBoldFont)
                    {
                        SendMessage(hwndHelpTitle, WM_SETFONT, (WPARAM) hBoldFont, 0);
                        SendDlgItemMessage(hDlg, IDC_CTRL, WM_SETFONT, (WPARAM) hBoldFont, 0);
                        SendDlgItemMessage(hDlg, IDC_ALT, WM_SETFONT, (WPARAM) hBoldFont, 0);
                        SendDlgItemMessage(hDlg, IDC_DEL, WM_SETFONT, (WPARAM) hBoldFont, 0);
                    }
                }
            }

            // Set the dialog's position - but only do this if the help
            // dialog will be reasonably on-screen
            if (((pGlobals->rcWelcome.left + 70) < 600) && 
                ((pGlobals->rcWelcome.top + 20) < 350))
            {
                SetWindowPos(hDlg, NULL, pGlobals->rcWelcome.left + 70, 
                    pGlobals->rcWelcome.top + 20, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
            }

            fReturn = TRUE;
        }
        break;
    case WM_DESTROY:
        {
            if (hbrWindow)
                DeleteObject(hbrWindow);

            if (hBoldFont)
                DeleteObject(hBoldFont);
        }
        break;
    case WM_COMMAND:
        {
            if ((HIWORD(wParam) == BN_CLICKED) &&
                ((LOWORD(wParam) == IDOK) || (LOWORD(wParam) == IDCANCEL)))
            {
                EndDialog(hDlg, IDOK);
            }
        }
        break;
    case WM_CTLCOLORSTATIC:
        {
            SetBkColor((HDC) wParam, GetSysColor(COLOR_WINDOW));
            SetTextColor((HDC) wParam, GetSysColor(COLOR_WINDOWTEXT));
            fReturn = (INT_PTR) hbrWindow;            
        }
        break;
    case WM_ERASEBKGND:
        {
            RECT rc = {0};
            GetClientRect(hDlg, &rc);
            FillRect((HDC) wParam, &rc, hbrWindow);
            fReturn = TRUE;
        }
        break;

    case WLX_WM_SAS:
        {
            // Post this to our parent (the c-a-d dialog) and exit
            PostMessage(GetParent(hDlg), message, wParam, lParam);
            EndDialog(hDlg, IDOK);
        }
        break;
    }
    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetWelcomeCaption
//
//  Synopsis:   Grabs the Welcome string from the registry, or the default
//              welcome from the resource section and slaps it into the
//              caption.
//
//  Arguments:  [hDlg] --
//
//  History:    10-20-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#define MAX_CAPTION_LENGTH  256

VOID
SetWelcomeCaption(
    HWND    hDlg)
{
    WCHAR   szCaption[MAX_CAPTION_LENGTH];
    WCHAR   szDefaultCaption[MAX_CAPTION_LENGTH];
    DWORD   Length;

    GetWindowText( hDlg, szDefaultCaption, MAX_CAPTION_LENGTH );

    szCaption[0] = TEXT('\0');

        // No big deal if that fails, we already have a default.
    GetProfileString(   APPLICATION_NAME,
                        WELCOME_CAPTION_KEY,
                        TEXT(""),
                        szCaption,
                        ARRAYSIZE(szCaption) );

    if ( szCaption[0] != TEXT('\0') )
    {
        Length = (DWORD) wcslen( szDefaultCaption );

        if (ExpandEnvironmentStrings(szCaption,
                                    &szDefaultCaption[Length + 1],
                                    MAX_CAPTION_LENGTH - Length - 1))
        {
            szDefaultCaption[Length] = L' ';
        }

        SetWindowText( hDlg, szDefaultCaption );
    }
}


void SetCadMessage(HWND hDlg, PGLOBALS pGlobals, BOOL fSmartcard)
{
    TCHAR szCadMessage[256];
    UINT idSzCad;
    RECT rcEdit;
    HWND hwndMessage;

    // Set the Press c-a-d message accordingly depending on
    // if we have a smartcard or not, if TS session or not

    if (!GetSystemMetrics(SM_REMOTESESSION))
    {
        idSzCad = fSmartcard ? IDS_PRESSCADORSMARTCARD : IDS_PRESSCAD;
    }
    else
    {
        idSzCad = fSmartcard ? IDS_PRESSCAEORSMARTCARD : IDS_PRESSCAE;
    }

    LoadString(hDllInstance, idSzCad, szCadMessage, ARRAYSIZE(szCadMessage));
    
    hwndMessage = GetDlgItem(hDlg, IDC_PRESSCAD);
    SetWindowText(hwndMessage, szCadMessage);
    SendMessage(hwndMessage, WM_SETFONT, (WPARAM) pGlobals->GinaFonts.hWelcomeFont, 0);

    // We now have to center the text beside the icons
    if (GetClientRect(hwndMessage, &rcEdit))
    {
        HDC hdcMessage;

        // Calculate the amount of vertical room needed for the text
        hdcMessage = GetDC(hwndMessage);

        if (hdcMessage)
        {
            HGDIOBJ hOldFont;
            long height;
            RECT rcTemp = rcEdit;

            // Make sure font is correct for sizing info.
            hOldFont = SelectObject(hdcMessage, (HGDIOBJ) pGlobals->GinaFonts.hWelcomeFont);

            height = (long) DrawTextEx(hdcMessage, szCadMessage, -1, &rcTemp, DT_EDITCONTROL | DT_CALCRECT | DT_WORDBREAK, NULL);

            SelectObject(hdcMessage, hOldFont);
            
            ReleaseDC(hwndMessage, hdcMessage);
            hdcMessage = NULL;

            if (0 < height)
            {
                rcEdit.top = (rcEdit.bottom / 2) - (height / 2);
                rcEdit.bottom = rcEdit.top + height;

                MapWindowPoints(hwndMessage, hDlg, (POINT*) &rcEdit, 2);

                SetWindowPos(hwndMessage, 0, rcEdit.left, rcEdit.top, rcEdit.right - rcEdit.left,
                    rcEdit.bottom - rcEdit.top, SWP_NOZORDER);
            }
        }
    }           
}

void SetIcons(HWND hDlg, BOOL fSmartcard)
{
    static UINT rgidNoSmartcard[] = {IDC_KEYBOARD, IDC_PRESSCAD};
	static INT iLeftRelPos;
	static INT iDistance;

	if (iDistance == 0) {

		// get the left relative position of the kbd icon
		// and the distance we would have to move it to the left
		// in case we have no reader installed
        RECT rcSC, rcKB, rcDlg;

		GetWindowRect(hDlg, &rcDlg);
        GetWindowRect(GetDlgItem(hDlg, IDC_KEYBOARD), &rcKB);
        GetWindowRect(GetDlgItem(hDlg, IDC_SMARTCARD), &rcSC);

		iDistance = rcSC.left - rcKB.left;
		iLeftRelPos = rcKB.left - rcDlg.left;
	}

    // Hide the smartcard icon if not required and move over the
    // keyboard icon and press c-a-d message
    if (!fSmartcard)
    {
        HWND hwndSmartcard = GetDlgItem(hDlg, IDC_SMARTCARD);

        // Hide the smartcard puppy
        EnableWindow(hwndSmartcard, FALSE);
        ShowWindow(hwndSmartcard, SW_HIDE);

		// move the kbd icon over to the left
        MoveControls(hDlg, rgidNoSmartcard, ARRAYSIZE(rgidNoSmartcard), 
            iDistance, 0, FALSE /*Don't size parent*/);
    } 
	else 
	{
        RECT rcKB, rcDlg;

		GetWindowRect(hDlg, &rcDlg);
        GetWindowRect(GetDlgItem(hDlg, IDC_KEYBOARD), &rcKB);

		if ((rcKB.left - rcDlg.left) != iLeftRelPos)
		{
			// the kbd icon needs to be moved to the right
	        HWND hwndSmartcard = GetDlgItem(hDlg, IDC_SMARTCARD);

			MoveControls(hDlg, rgidNoSmartcard, ARRAYSIZE(rgidNoSmartcard), 
				iDistance * (-1), 0, FALSE /*Don't size parent*/);
		
			EnableWindow(hwndSmartcard, TRUE);
			ShowWindow(hwndSmartcard, SW_SHOW);
		}
	}
}

BOOL FastUserSwitchingEnabled ()
{
	//
	// BUGBUG : isn't there any global variable or function which can provide this information?
	// fast user switching is enabled if multiple users are allowed, and if its not server.
	//

	OSVERSIONINFOEX OsVersion;
    ZeroMemory(&OsVersion, sizeof(OSVERSIONINFOEX));
    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx( (LPOSVERSIONINFO ) &OsVersion);

	return (OsVersion.wProductType == VER_NT_WORKSTATION && ShellIsMultipleUsersEnabled());

}


BOOL GetSessionZeroUser(LPTSTR szUser, int nUserMax)
{
    WINSTATIONINFORMATION WSInfo;
    ULONG Length;


    if (WinStationQueryInformation(
                SERVERNAME_CURRENT,
                0,
                WinStationInformation,
                &WSInfo,
                sizeof(WINSTATIONINFORMATION),
                &Length))
    {
        if ((WSInfo.ConnectState == State_Active ||  WSInfo.ConnectState == State_Disconnected) &&
            WSInfo.UserName[0] )
        {
            if (WSInfo.Domain[0])
            {
                _snwprintf(szUser, nUserMax, TEXT("%s\\%s"), WSInfo.Domain, WSInfo.UserName);
            }
            else
            {
                wcsncpy(szUser, WSInfo.UserName, nUserMax);
            }

            szUser[nUserMax - 1] = 0;   // Zero terminate
            return TRUE;
        }
    }

    return FALSE;
}

// ==========================================================================================
// welcome dialog has 2 formats, one that looks like logon normal welcome dialog , another 
// that looks like "Computer Locked" dialog. When user connects to session 0 from remote (tsclient) 
// the  dialog that appears at console need to change to "Computer Locked". so if session 0 is in 
// use, and if this session is created at active console. we change welcome dialog to look like 
// "Computer locked" dialog.
// This function ComputerInUseMessage does most of the stuff related to switching these 
// dialog controls.
// Parameters:
// HWND hDlg - dialog window handle, 
// BOOL bShowLocked - if true show locked dialog, if false show normal logon dialog. 
// BOOL bInit - TRUE when this function is called for the first time.
// ==========================================================================================

BOOL ComputerInUseMessage(PGLOBALS pGlobals, HWND hDlg, BOOL bShowLocked, BOOL bInit, BOOL bSmartCard)
{
	int i;
	LONG DlgHeight;
	RECT rc;

	// locked controls.
	UINT rgidLocked[] = {IDC_STATIC_LOCKEDGROUP, IDD_LOCKED_ICON, IDD_LOCKED_LINE, IDD_LOCKED_NAME_INFO, IDD_LOCKED_INSTRUCTIONS};
	UINT rgidWelcome[] = {IDC_STATIC_WELCOMEGROUP, IDC_SMARTCARD, IDC_KEYBOARD, IDC_PRESSCAD, IDD_CTRL_DEL_MSG, IDC_HELPLINK};
	int nLockedControls = sizeof(rgidLocked) / sizeof(rgidLocked[0]);
	int nWelcomeControls = sizeof(rgidWelcome) / sizeof(rgidWelcome[0]); 

	struct DlgControl
	{
		HWND hWnd;
		RECT rect;
	};

	static RECT  LockedControls[sizeof(rgidLocked) / sizeof(rgidLocked[0])];
	static RECT  WelcomeControls[sizeof(rgidWelcome) / sizeof(rgidWelcome[0])];
	static bCurrentlyLocked = FALSE;

	
	if (!bInit && bCurrentlyLocked == bShowLocked)
	{
		// nothing to do.
		return TRUE;
	}

	if (bInit)
	{
		// setup locked icon for the locked dialog box.
		if ( !hLockedIcon )
		{
			hLockedIcon = LoadImage( hDllInstance,
									 MAKEINTRESOURCE( IDI_LOCKED),
									 IMAGE_ICON,
									 0, 0,
									 LR_DEFAULTCOLOR );
		}

		SendMessage( GetDlgItem(hDlg, IDD_LOCKED_ICON),
					 STM_SETICON,
					 (WPARAM)hLockedIcon,
					 0 );


		//
		// when this function is called first time, all controls are visible.
		// remember their positions.
		//

		// remember positions Locked Dialog controls.
		for ( i = 0; i < nLockedControls; i++)
		{
			HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
			ASSERT(hWnd);
			GetWindowRect(hWnd, &LockedControls[i] );
			MapWindowPoints(NULL, hDlg, (POINT*) &LockedControls[i], 2);
		}

		// remember positions for Welcome Dialog controls.
		for ( i = 0; i < nWelcomeControls; i++)
		{
			HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
			ASSERT(hWnd);
			GetWindowRect(hWnd, &WelcomeControls[i]);
			
			// in the dialog template welcome controls are placed below locked controls.
			// this is not where they will be placed when dialog is shown. 
			// calculate their actual target positions.
			OffsetRect(&WelcomeControls[i], 0, LockedControls[0].top - LockedControls[0].bottom);

			MapWindowPoints(NULL, hDlg, (POINT*) &WelcomeControls[i], 2);
		}

		// hide group box controls. They were their only for simplifing our control movement calculations.
		ShowWindow(GetDlgItem(hDlg, rgidLocked[0]), SW_HIDE);
		ShowWindow(GetDlgItem(hDlg, rgidWelcome[0]), SW_HIDE);

		// set the dialog right for the first use.
		if (bShowLocked)
		{
			// we want locked desktop dialog, so disable welcome controls.
			for ( i = 0; i < nWelcomeControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}
		}
		else
		{
			// we want to welcome dialog, so remove locked desktop controls.
			for ( i = 1; i < nLockedControls; i++)
			{
				HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}

			// and move welcome controls to their proper positions. (i.e move them up)
			for ( i = 1; i < nWelcomeControls; i++)
			{
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				EnableWindow(hWnd, TRUE);
				ShowWindow(hWnd, SW_SHOW);
				MoveWindow(hWnd, WelcomeControls[i].left,  WelcomeControls[i].top, WelcomeControls[i].right - WelcomeControls[i].left, WelcomeControls[i].bottom - WelcomeControls[i].top, FALSE);
			}

		}

		// set the right size for the dialog window.
		GetWindowRect(hDlg, &rc);
		MapWindowPoints(NULL, GetParent(hDlg), (LPPOINT)&rc, 2);
		DlgHeight = rc.bottom - rc.top;

		if (bShowLocked)
		{
			DlgHeight -= WelcomeControls[0].bottom - WelcomeControls[0].top;
		}
		else
		{
			DlgHeight -= LockedControls[0].bottom - LockedControls[0].top;
		}
		
		SetWindowPos(hDlg, NULL, 0, 0, rc.right - rc.left, DlgHeight, SWP_NOZORDER|SWP_NOMOVE);

	}
	else
	{
		if (bShowLocked)
		{
			for ( i = 1; i < nLockedControls; i++)
			{
				HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
				ASSERT(hWnd);
				EnableWindow(hWnd, TRUE);
				ShowWindow(hWnd, SW_SHOW);
				MoveWindow(hWnd, LockedControls[i].left,  LockedControls[i].top, LockedControls[i].right - LockedControls[i].left, LockedControls[i].bottom - LockedControls[i].top, FALSE);
			}

			for ( i = 1; i < nWelcomeControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}

		}
		else
		{
			for ( i = 1; i < nLockedControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidLocked[i]);
				ASSERT(hWnd);
				MoveWindow(hWnd, 0,  0, 0, 0, FALSE);
				ShowWindow(hWnd, SW_HIDE);
				EnableWindow(hWnd, FALSE);
			}

			for ( i = 1; i < nWelcomeControls; i++)
			{
				
				HWND hWnd = GetDlgItem(hDlg, rgidWelcome[i]);
				ASSERT(hWnd);
				EnableWindow(hWnd, TRUE);
				ShowWindow(hWnd, SW_SHOW);
				MoveWindow(hWnd, WelcomeControls[i].left,  WelcomeControls[i].top, WelcomeControls[i].right - WelcomeControls[i].left, WelcomeControls[i].bottom - WelcomeControls[i].top, FALSE);
			}
		}

		GetWindowRect(hDlg, &rc);
		MapWindowPoints(NULL, GetParent(hDlg), (LPPOINT)&rc, 2);
		if (bShowLocked)
			DlgHeight = rc.bottom - rc.top - (WelcomeControls[0].bottom - WelcomeControls[0].top) + (LockedControls[0].bottom - LockedControls[0].top);
		else
			DlgHeight = rc.bottom - rc.top + (WelcomeControls[0].bottom - WelcomeControls[0].top) - (LockedControls[0].bottom - LockedControls[0].top);
			
		SetWindowPos(hDlg, NULL, 0, 0, rc.right - rc.left, DlgHeight, SWP_NOZORDER|SWP_NOMOVE);
	}

	if (!bShowLocked)
	{
		SetCadMessage(hDlg, pGlobals, bSmartCard);

		// let SetIcons hide SmartCard icon if required.
		SetIcons(hDlg, bSmartCard);
	}
	else
	{
        TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
        TCHAR szMessage[MAX_STRING_BYTES];
        TCHAR szFinalMessage[MAX_STRING_BYTES];
        if (GetSessionZeroUser(szUser, USERNAME_LENGTH + DOMAIN_LENGTH + 2))
        {
            szMessage[0] = 0;
            LoadString(hDllInstance, IDS_LOCKED_EMAIL_NFN_MESSAGE, szMessage, MAX_STRING_BYTES);
            _snwprintf(szFinalMessage, sizeof(szFinalMessage)/sizeof(TCHAR), szMessage, szUser );
            szFinalMessage[MAX_STRING_BYTES - 1] = 0;   // Zero terminate
        }
        else
        {
            //
            // for some reason we could not get the current session zero user.
            //
            szFinalMessage[0] = 0;  // In case the following fails.
            LoadString(hDllInstance, IDS_LOCKED_NO_USER_MESSAGE, szFinalMessage, MAX_STRING_BYTES);
        }
        
        SetDlgItemText(hDlg, IDD_LOCKED_NAME_INFO, szFinalMessage);
	}

	//
	// update the dialog box caption, accordingly
	//
	{
			TCHAR szCaption[MAX_CAPTION_LENGTH];
			LoadString(hDllInstance, bShowLocked ? IDS_CAPTION_LOCKED_DIALOG : IDS_CAPTION_WELCOME_DIALOG, szCaption, ARRAYSIZE(szCaption));
			if ( szCaption[0] != TEXT('\0') )
				SetWindowText( hDlg, szCaption );
	}

	InvalidateRect(hDlg, NULL, TRUE);
	bCurrentlyLocked = bShowLocked;

	return TRUE;
}

/***************************************************************************\
* FUNCTION: WelcomeDlgProc
*
* PURPOSE:  Processes messages for welcome dialog
*
* RETURNS:  MSGINA_DLG_SUCCESS     - the user has pressed the SAS
*           DLG_SCREEN_SAVER_TIMEOUT - the screen-saver should be started
*           DLG_LOGOFF()    - a logoff/shutdown request was received
*
* HISTORY:
*
*   12-09-91 Davidc       Created.
*
\***************************************************************************/

INT_PTR WINAPI
WelcomeDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HBRUSH hbrWindow = NULL;
    PGLOBALS pGlobals = (PGLOBALS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
	static BOOL bSmartCard = FALSE;
	static BOOL bSessionZeroInUse = FALSE;
	static int iSessionRegistrationCount = 0;

    switch (message) {

        case WM_INITDIALOG:
        {
			extern BOOL fEscape;
            ULONG_PTR Value ;

            pGlobals = (PGLOBALS) lParam ;
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pGlobals);

            hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));            

            //
            // The size of the welcome dialog defines the area that
            // we will paint into.
            //

            //
            // Size the window allowing for the caption and other stuff to
            // be dispalyed.
            //


            pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_SMART_CARD_PRESENT,
                                     &Value
                                    );

            if ( Value )
            {
                TCHAR szInsertCard[256];
                bSmartCard = TRUE;
			
                // Also change unlock message to mention smartcard
                LoadString(hDllInstance, IDS_INSERTCARDORSAS_UNLOCK, szInsertCard, ARRAYSIZE(szInsertCard));

                SetDlgItemText(hDlg, IDD_LOCKED_INSTRUCTIONS, szInsertCard);

            }
            else
            {
                bSmartCard = FALSE;
            }

                // Enable SC events (if there is no reader yet, no
                // events will be triggered anyway...)
            pWlxFuncs->WlxSetOption( pGlobals->hGlobalWlx,
                                     WLX_OPTION_USE_SMART_CARD,
                                     1,
                                     NULL
                                    );

            if (GetDisableCad(pGlobals))
            {
                // Set our size to zero so we don't appear
                SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE |
                                         SWP_NOREDRAW | SWP_NOZORDER);

                pWlxFuncs->WlxSasNotify( pGlobals->hGlobalWlx,
                                         WLX_SAS_TYPE_CTRL_ALT_DEL );
            }
            else
            {
                SizeForBranding(hDlg, TRUE);
            }


			if (IsActiveConsoleSession() && 
				NtCurrentPeb()->SessionId != 0 &&
				!FastUserSwitchingEnabled())
			{
				TCHAR szUser[USERNAME_LENGTH + DOMAIN_LENGTH + 2];
				//
				// we are at temporary session created at console...
				//
				
				// check if a user is logged on at console session
				bSessionZeroInUse = GetSessionZeroUser(szUser, USERNAME_LENGTH + DOMAIN_LENGTH + 2);
				if (WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, hDlg, NOTIFY_FOR_ALL_SESSIONS))
					iSessionRegistrationCount++;
				
			}
			else
			{
				//
				// this is not active console nonzero session. 
				//
				bSessionZeroInUse = FALSE;
			}

			ComputerInUseMessage(pGlobals, hDlg, bSessionZeroInUse, TRUE, bSmartCard);

            CentreWindow(hDlg); //Center?? :)

            return( TRUE );
        }

        case WM_ERASEBKGND:
            return PaintBranding(hDlg, (HDC)wParam, 0, FALSE, TRUE, bSessionZeroInUse? COLOR_BTNFACE : COLOR_WINDOW);

        case WM_QUERYNEWPALETTE:
            return BrandingQueryNewPalete(hDlg);

        case WM_PALETTECHANGED:
            return BrandingPaletteChanged(hDlg, (HWND)wParam);

        case WM_NOTIFY:
        {
            LPNMHDR pnmhdr = (LPNMHDR) lParam;
            int id = (int) wParam;

            // See if this is a help-link click
            if (id == IDC_HELPLINK)
            {
                if ((pnmhdr->code == NM_CLICK) || (pnmhdr->code == NM_RETURN))
                {
                    // Save the coords of the welcome window so we can
                    // position the help window relative to it
                    GetWindowRect(hDlg, &pGlobals->rcWelcome);

                    pWlxFuncs->WlxDialogBoxParam(  pGlobals->hGlobalWlx,
                           hDllInstance, MAKEINTRESOURCE(IDD_WELCOMEHELP_DIALOG),
                           hDlg, HelpDlgProc, (LPARAM) pGlobals);
                }
            }
            return FALSE;
        }

        case WM_CTLCOLORSTATIC:
        {
			if (!bSessionZeroInUse)
			{
				SetBkColor((HDC) wParam, GetSysColor(COLOR_WINDOW));
				SetTextColor((HDC) wParam, GetSysColor(COLOR_WINDOWTEXT));
				return (INT_PTR) hbrWindow;
			}
        }
        break;

        case WM_DESTROY:
        {
			// if registered for console notification unregister now.
			if (iSessionRegistrationCount)
			{
				WinStationUnRegisterConsoleNotification (SERVERNAME_CURRENT, hDlg);
				iSessionRegistrationCount--;
				ASSERT(iSessionRegistrationCount == 0);
			}

            // Save the coords of the welcome window so we can
            // position the logon window at the same position
            GetWindowRect(hDlg, &pGlobals->rcWelcome);

            DeleteObject(hbrWindow);
            return FALSE;
        }
        break;

        case WLX_WM_SAS :
			if ( wParam == WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED ||
				 wParam == WLX_SAS_TYPE_SC_LAST_READER_REMOVED) 
			{
				bSmartCard = (wParam == WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED);

				SetCadMessage(hDlg, pGlobals, bSmartCard);
				SetIcons(hDlg, bSmartCard);
				ShowWindow(hDlg, SW_SHOW);
				return TRUE;
			}

            if ( wParam == WLX_SAS_TYPE_SC_REMOVE )
            {
                return TRUE ;
            }
            break;

		case WM_WTSSESSION_CHANGE:
			
			//
			// its possible, that we unregister for notification in wm_destroy and still receive this notification,
			// as the notification may already have been sent.
			//
			ASSERT(iSessionRegistrationCount < 2);
			if (iSessionRegistrationCount == 1)
			{
				if (lParam == 0)
				{
					//
					// we are interested only in logon/logoff messages from session 0.
					//
					if (wParam == WTS_SESSION_LOGON || wParam == WTS_SESSION_LOGOFF)
					{
						bSessionZeroInUse = (wParam == WTS_SESSION_LOGON);
						ComputerInUseMessage(pGlobals, hDlg, bSessionZeroInUse, FALSE, bSmartCard);

					}
				}
			}
			break;
    }

    // We didn't process this message
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\structs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       structs.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-19-94   RichardW   Created
//
//----------------------------------------------------------------------------

//
// Arraysize macro
//

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))


//
// Define the input timeout delay for the security options dialog (seconds)
//

#define OPTIONS_TIMEOUT                     120


//
// Define the number of days warning we give the user before their password expires
//

#define PASSWORD_EXPIRY_WARNING_DAYS        14


//
// Define the maximum time we display the 'wait for user to be logged off'
// dialog. This dialog should be interrupted by the user being logged off.
// This timeout is a safety measure in case that doesn't happen because
// of some system error.
//

#define WAIT_FOR_USER_LOGOFF_DLG_TIMEOUT    120 // seconds


//
// Define the account lockout limits
//
// A delay of LOCKOUT_BAD_LOGON_DELAY seconds will be added to
// each failed logon if more than LOCKOUT_BAD_LOGON_COUNT failed logons
// have occurred in the last LOCKOUT_BAD_LOGON_PERIOD seconds.
//

#define LOCKOUT_BAD_LOGON_COUNT             5
#define LOCKOUT_BAD_LOGON_PERIOD            60 // seconds
#define LOCKOUT_BAD_LOGON_DELAY             30 // seconds



//
// Define the maximum length of strings we'll use in winlogon
//

#define MAX_STRING_LENGTH   511
#define MAX_STRING_BYTES    (MAX_STRING_LENGTH + 1)


//
// Define the typical length of a string
// This is used as an initial allocation size for most string routines.
// If this is insufficient, the block is reallocated larger and
// the operation retried. i.e. Make this big enough for most strings
// to fit first time.
//

#define TYPICAL_STRING_LENGTH   60
//
// Define the structure that contains information used when starting
// user processes.
// This structure should only be modified by SetUserProcessData()
//

typedef struct {
    HANDLE                  UserToken;  // NULL if no user logged on
    HANDLE                  RestrictedToken ;
    PSID                    UserSid;    // == WinlogonSid if no user logged on
    PSECURITY_DESCRIPTOR    NewThreadTokenSD;
    QUOTA_LIMITS            Quotas;
    PVOID                   pEnvironment;
    HKEY                    hCurrentUser ;
    ULONG                   Flags ;
} USER_PROCESS_DATA;
typedef USER_PROCESS_DATA *PUSER_PROCESS_DATA;

#define USER_FLAG_LOCAL     0x00000001


//
// Define the structure that contains information about the user's profile.
// This is used in SetupUserEnvironment and ResetEnvironment (in usrenv.c)
// This data is only valid while a user is logged on.
//

typedef struct {
    LPTSTR ProfilePath;
} USER_PROFILE_INFO;
typedef USER_PROFILE_INFO *PUSER_PROFILE_INFO;



//
// Get any data types defined in module headers and used in GLOBALS
//

#define DATA_TYPES_ONLY
#include "lockout.h"
#include "domain.h"
#undef DATA_TYPES_ONLY

//
// Multi User Global Structure
//

typedef struct _MUGLOBALS {

    //
    // Current SessionId
    //
    ULONG SessionId;

    //
    // Auto logon information
    //
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pAutoLogon;

    //
    // TS-specific data passed to us from WinLogon via WlxPassTerminalServicesData().
    //
    WLX_TERMINAL_SERVICES_DATA TSData;

    //
    // For CLIENTNAME environment variable
    //
    TCHAR ClientName[CLIENTNAME_LENGTH + 1];

    //
    // Flag indicating a slower rate of animation is requested to optimize
    // for slow TS clients
    //
    BOOL fSlowAnimationRate;

} MUGLOBALS, *PMUGLOBALS;

//
// Non paged chunk for passwords and similar goodies
//

typedef struct _NP_GLOBALS {
    WCHAR                   UserName[MAX_STRING_BYTES];     // e.g. Justinm
    WCHAR                   Domain[MAX_STRING_BYTES];
    WCHAR                   Password[MAX_STRING_BYTES];
    WCHAR                   OldPassword[MAX_STRING_BYTES];
} NP_GLOBALS, * PNP_GLOBALS ;

//
// Reasons why we may not have performed an optimized - cached logon
// by default.
//

typedef enum _OPTIMIZED_LOGON_STATUS {
    OLS_LogonIsCached                                   = 0,
    OLS_Unspecified                                     = 1,
    OLS_UnsupportedSKU                                  = 2,
    OLS_LogonFailed                                     = 3,
    OLS_InsufficientResources                           = 4,
    OLS_NonCachedLogonType                              = 5,
    OLS_SyncUserPolicy                                  = 6,
    OLS_SyncMachinePolicy                               = 7,
    OLS_ProfileDisallows                                = 8,
    OLS_SyncLogonScripts                                = 9,
    OLS_NextLogonNotCacheable                           = 10,
    OLS_MachineIsNotDomainMember                        = 11,
} OPTIMIZED_LOGON_STATUS, *POPTIMIZED_LOGON_STATUS;

//
// Define the winlogon global structure.
//

typedef struct _GINAFONTS
{
    HFONT hWelcomeFont;                 // font used for painting the welcome text
    HFONT hCopyrightFont;               // used to paint copyright notice
    HFONT hBuiltOnNtFont;               // used to paint the "Built on NT" line
    HFONT hBetaFont;                    // used to paint the release notice on the welcome page
} GINAFONTS, *PGINAFONTS;

#define PASSWORD_HASH_SIZE      16

typedef struct _GLOBALS {
    struct _GLOBALS         *pNext;

    HANDLE                  hGlobalWlx;
    HDESK                   hdeskParent;

    RTL_CRITICAL_SECTION    csGlobals;

    // Filled in by InitializeGlobals at startup
    PSID                    WinlogonSid;

    //
    PSID                    LogonSid;
    PVOID                   LockedMemory ;

    HANDLE                  hEventLog;

    HANDLE                  hMPR;

    HWND                    hwndLogon;
    BOOL                    LogonInProgress;

    // Filled in during startup
    HANDLE                  LsaHandle; // Lsa authentication handle
    LSA_OPERATIONAL_MODE    SecurityMode;
    ULONG                   AuthenticationPackage;
    BOOL                    AuditLogFull;
    BOOL                    AuditLogNearFull;

    // Always valid, indicates if we have a user logged on
    BOOL                    UserLoggedOn;

    // Always valid - used to start new processes and screen-saver
    USER_PROCESS_DATA       UserProcessData;

    // Filled in by a successful logon
    TCHAR                   UserFullName[MAX_STRING_BYTES]; // e.g. Magaram, Justin
    UNICODE_STRING          UserNameString;
    LPWSTR                  UserName ;
    UNICODE_STRING          DomainString;
    LPWSTR                  Domain ;
    UNICODE_STRING          FlatUserName ;
    UNICODE_STRING          FlatDomain;
    LPWSTR                  DnsDomain ;
    UCHAR                   Seed;
    UCHAR                   OldSeed;
    UCHAR                   OldPasswordPresent;
    UCHAR                   Reserved;
    LUID                    LogonId;
    TIME                    LogonTime;
    TIME                    LockTime;
    PMSV1_0_INTERACTIVE_PROFILE Profile;
    ULONG                   ProfileLength;
    LPWSTR                  MprLogonScripts;
    UNICODE_STRING          PasswordString;   // Run-encoded for password privacy
                                              // (points to Password buffer below)

    LPWSTR                  Password ;
    UNICODE_STRING          OldPasswordString;
    LPWSTR                  OldPassword ;

    UCHAR                   PasswordHash[ PASSWORD_HASH_SIZE ]; // Hash of password

    // Filled in during SetupUserEnvironment, and used in ResetEnvironment.
    // Valid only when a user is logged on.
    USER_PROFILE_INFO       UserProfile;

    BOOL                    BlockForLogon;

    FILETIME                LastNotification;

    //
    // Advanced Logon Stuff:
    //

    ULONG                   PasswordLogonPackage ;
    ULONG                   SmartCardLogonPackage ;
    OPTIMIZED_LOGON_STATUS  OptimizedLogonStatus;

    //
    // Account lockout data
    //
    // Manipulated only by LockInitialize, LockoutHandleFailedLogon
    // and LockoutHandleSuccessfulLogon.
    //

    LOCKOUT_DATA            LockoutData;

    //
    // Flags controlling unlock behavior
    //

    DWORD                   UnlockBehavior ;

    //
    // Trusted domain cache
    //

    PDOMAIN_CACHE Cache ;
    PDOMAIN_CACHE_ARRAY ActiveArray ;
    BOOL ListPopulated ;

    //
    // Hydra specific part of winlogon globals struct
    //
    MUGLOBALS MuGlobals;

    //
    // Folding options state
    //
    BOOL ShowRasBox;
    BOOL RasUsed;
    BOOL SmartCardLogon;
    ULONG SmartCardOption ;
    BOOL LogonOptionsShown;
    BOOL UnlockOptionsShown;
    BOOL AutoAdminLogon;
    BOOL IgnoreAutoAdminLogon;

    INT xBandOffset;                    // used for animated band in dialog
    INT cxBand;                         // width of band being displayed, used for wrapping

    // fonts
    GINAFONTS GinaFonts;

    // Flag indicating whether we are showing the domain box
    BOOL ShowDomainBox;

    // Coordinates of upper-left hand corner of the Welcome screen
    // - We want to position the logon dialog here also!
    RECT rcWelcome;

    // Size of the original "Log On To Windows" dialog
    RECT rcDialog;

    // Status UI information
    HANDLE hStatusInitEvent;
    HANDLE hStatusTermEvent;
    HANDLE hStatusThread;
    HDESK  hStatusDesktop;
    HWND   hStatusDlg;
    INT    cxStatusBand;
    INT    xStatusBandOffset;
    DWORD  dwStatusOptions;
    // flag indicating if user credentials were passed on from an other session
    BOOL TransderedCredentials;

    TCHAR  Smartcard[64];
    TCHAR  SmartcardReader[64];
    BOOL   fLocalDomain;

} GLOBALS, *PGLOBALS;

//
// Unlock behavior bits:
//

#define UNLOCK_FORCE_AUTHENTICATION     0x00000001
#define UNLOCK_NO_NETWORK               0x00000002


//
// Define a macro to determine if we're a workstation or not
// This allows easy changes as new product types are added.
//

#define IsDomainController(prodtype)    (((prodtype) == NtProductWinNt) \
                                            || ((prodtype) == NtProductServer))

#define IsWorkstation(prodtype)         ((prodtype) == NtProductWinNt)


// A WM_HANDLEFAILEDLOGON message was already sent - this message
// will in turn send a WM_LOGONCOMPLETE with the result.
#define MSGINA_DLG_FAILEDMSGSENT            0x10000001

//
// Define common return code groupings
//

#define DLG_TIMEOUT(Result)     ((Result == MSGINA_DLG_INPUT_TIMEOUT) || (Result == MSGINA_DLG_SCREEN_SAVER_TIMEOUT))
#define DLG_LOGOFF(Result)      ((Result & ~MSGINA_DLG_FLAG_MASK) == MSGINA_DLG_USER_LOGOFF)
#define DLG_SHUTDOWNEX(Result)  ((Result & ~MSGINA_DLG_FLAG_MASK) == MSGINA_DLG_SHUTDOWN)
// #define DLG_INTERRUPTED(Result) (DLG_TIMEOUT(Result) || DLG_LOGOFF(Result))
#define DLG_SHUTDOWN(Result)    ((DLG_LOGOFF(Result) || DLG_SHUTDOWNEX(Result)) && (Result & (MSGINA_DLG_SHUTDOWN_FLAG | MSGINA_DLG_REBOOT_FLAG | MSGINA_DLG_POWEROFF_FLAG | MSGINA_DLG_SLEEP_FLAG | MSGINA_DLG_SLEEP2_FLAG | MSGINA_DLG_HIBERNATE_FLAG)))

#define SetInterruptFlag(Result)    ((Result) | MSGINA_DLG_INTERRUPTED )
#define ClearInterruptFlag(Result)  ((Result) & (~MSGINA_DLG_INTERRUPTED ))
#define ResultNoFlags(Result)       ((Result) & (~MSGINA_DLG_INTERRUPTED ))

#define DLG_FAILED(Result)          (ResultNoFlags( Result ) == MSGINA_DLG_FAILURE)
#define DLG_SUCCEEDED(Result)       (ResultNoFlags( Result ) == MSGINA_DLG_SUCCESS)
#define DLG_INTERRUPTED( Result )   ((Result & MSGINA_DLG_INTERRUPTED) == (MSGINA_DLG_INTERRUPTED) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\welcome.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       welcome.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7-18-94   RichardW   Created
//
//----------------------------------------------------------------------------

INT_PTR WINAPI
WelcomeDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );

VOID
SetWelcomeCaption(
    HWND    hDlg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\winutil.c ===
/****************************** Module Header ******************************\
* Module Name: winutil.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Implements windows specific utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

#include "msgina.h"
#include <stdio.h>
#include <wchar.h>

//
// Define this if you want a verbose commentary from these routines
//

// #define VERBOSE_UTILS

#ifdef VERBOSE_UTILS
#define VerbosePrint(s) WLPrint(s)
#else
#define VerbosePrint(s)
#endif

#define LRM 0x200E // UNICODE Left-to-right mark control character
#define RLM 0x200F // UNICODE Left-to-right mark control character



/***************************************************************************\
* SetupSystemMenu
*
* Purpose : Does any manipulation required for a dialog system menu.
*           Should be called during WM_INITDIALOG processing for a dialog
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
VOID
SetupSystemMenu(
    HWND hDlg
    )
{
    // Remove the Close item from the system menu if we don't
    // have a CANCEL button

    if (GetDlgItem(hDlg, IDCANCEL) == NULL) {

        HMENU hMenu = GetSystemMenu(hDlg, FALSE);

        if (hMenu)
        {
            DeleteMenu(hMenu, SC_CLOSE, MF_BYCOMMAND);
        }
    }

}


/***************************************************************************\
* CentreWindow
*
* Purpose : Positions a window so that it is centred in its parent
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
VOID
CentreWindow(
    HWND    hwnd
    )
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    // Get window rect
    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    // Get parent rect
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        // Return the desktop windows size (size of main screen)
        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    // Centre the child in the parent
    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;

    // Move the child into position
    SetWindowPos(hwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);

    SetForegroundWindow(hwnd);
}


/***************************************************************************\
* SetPasswordFocus
*
* Sets the focus window in a dialog to the first empty control in
* the list IDD_LOGON_DOMAIN, IDD_NEW_PASSWORD
* This routine would normally be called during WM_INITDIALOG processing.
*
* Returns FALSE if the focus was set, otherwise TRUE - this value can
* be used as the return value to the WM_INITDIALOG message.
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
BOOL
SetPasswordFocus(
    HWND    hDlg
    )
{
    int     ids[] = {   IDD_LOGON_NAME,
                        IDD_LOGON_DOMAIN,
                        IDD_LOGON_PASSWORD,
                        IDD_UNLOCK_PASSWORD,
                        IDD_CHANGEPWD_OLD,
                        IDD_CHANGEPWD_NEW,
                        IDD_CHANGEPWD_CONFIRM,
                    };
    SHORT   Index;
    HWND    hwndFocus = NULL;

    // Set focus to first enabled, visible, empty field

    for (Index = 0; Index < sizeof(ids)/sizeof(*ids); Index ++) {

        int     idControl = ids[Index];
        HWND    hwndControl;

        hwndControl = GetDlgItem(hDlg, idControl);
        if (hwndControl != NULL) {

            if ( (GetWindowTextLength(hwndControl) == 0) &&
                 ((GetWindowLong(hwndControl, GWL_STYLE) &
                    (WS_VISIBLE | WS_DISABLED)) == WS_VISIBLE)) {

                hwndFocus = hwndControl;
                break;
            }
        }
    }

    if (hwndFocus != NULL) {
        SetFocus(hwndFocus);
    }

    return(hwndFocus == NULL);
}



//
// Globals used to store cursor handles for SetupCursor
//
static  HCURSOR hCursorArrow = NULL;
static  HCURSOR hCursorWait = NULL;


/***************************************************************************\
* SetupCursor
*
* Sets the cursor to an hourglass if fWait = TRUE, otherwise sets it
* to an arrow.
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/
VOID
SetupCursor(
    BOOL    fWait
    )
{
    if (hCursorArrow == NULL) {
        hCursorArrow = LoadCursor(NULL, IDC_ARROW);
    }
    if (hCursorWait == NULL) {
        hCursorWait = LoadCursor(NULL, IDC_WAIT);
    }

    SetCursor(fWait ? hCursorWait : hCursorArrow);
}


/****************************************************************************

   FUNCTION: TimeFieldsToSystemTime

   PURPOSE: Converts a TIME_FIELDS structure into a SYSTEMTIME structure

   RETURNS : nothing

  History:
  05-15-93 RobertRe     Created.
****************************************************************************/

VOID
TimeFieldsToSystemTime(
    IN PTIME_FIELDS TimeFields,
    OUT LPSYSTEMTIME SystemTime
    )
{
    SystemTime->wYear         = TimeFields->Year        ;
    SystemTime->wMonth        = TimeFields->Month       ;
    SystemTime->wDayOfWeek    = TimeFields->Weekday     ;
    SystemTime->wDay          = TimeFields->Day         ;
    SystemTime->wHour         = TimeFields->Hour        ;
    SystemTime->wMinute       = TimeFields->Minute      ;
    SystemTime->wSecond       = TimeFields->Second      ;
    SystemTime->wMilliseconds = TimeFields->Milliseconds;

    return;
}


/****************************************************************************

   FUNCTION: FormatTime

   PURPOSE: Converts a system time into a readable string(in local time).
            if flags contains FT_TIME the time appears in the string
            if flags contains FT_DATE the date appears in the string.
            if both values appear, the string contains date then time.

   RETURNS : TRUE on success, FALSE on failure

****************************************************************************/
BOOL
FormatTime(
   IN PTIME Time,
   IN OUT PWCHAR Buffer,
   IN ULONG BufferLength,
   IN USHORT Flags
   )
{
    NTSTATUS Status;
    TIME_FIELDS TimeFields;
    TIME LocalTime;
    SYSTEMTIME SystemTime;
    DWORD dwDateFlags = DATE_SHORTDATE;

    //
    // Terminate the string in case they didn't pass any flags
    //

    if (BufferLength > 0) {
        Buffer[0] = 0;
    }

    //
    // Convert the system time to local time
    //

    Status = RtlSystemTimeToLocalTime(Time, &LocalTime);
    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to convert system time to local time, status = 0x%lx", Status));
        return(FALSE);
    }

    //
    // Split the time into its components
    //

    RtlTimeToTimeFields(&LocalTime, &TimeFields);

    TimeFieldsToSystemTime( &TimeFields, &SystemTime );

    //
    // Format the string
    //

    if (Flags & FT_LTR)
       dwDateFlags |= DATE_LTRREADING;
    else if(Flags & FT_RTL)
        dwDateFlags |= DATE_RTLREADING;

    if (Flags & FT_DATE) {

        int Length;

        Length = GetDateFormatW(GetUserDefaultLCID(),
                                dwDateFlags,
                                &SystemTime,
                                NULL,
                                Buffer,
                                BufferLength
                                );

        if (Length)
        {
            Length--;   // The returned length includes the trailing 0
            Buffer += Length;
            BufferLength -= Length;
        }
    }

    if (Flags & FT_TIME) {

        int Length;

        if (Flags & FT_DATE) {
            if (BufferLength > 1) {
                *Buffer++ = TEXT(' ');
                *Buffer = 0; // in case GetTimeFormat doesn't add anything
                BufferLength --;
            }

            // [msadek]; need to insert strong a Unicode control character to simulate
            // a strong run in the opposite base direction to enforce
            // correct display of concatinated string in all cases.
            
            if((BufferLength > 2) && (Flags & FT_RTL)) {
                *Buffer++ = LRM; // simulate an opposite run
                *Buffer++ = RLM; // force RTL display of the time part.
                *Buffer = 0; // in case GetTimeFormat doesn't add anything
                BufferLength -= 2;
            }
            else if((BufferLength > 2) && (Flags & FT_LTR)) {
                *Buffer++ = RLM; // simulate an opposite run
                *Buffer++ = LRM; // force LTR display of the time part.
                *Buffer = 0; // in case GetTimeFormat doesn't add anything
                BufferLength -= 2;            
            }

        }

        Length = GetTimeFormatW(GetUserDefaultLCID(),
                                0,
                                &SystemTime,
                                NULL,
                                Buffer,
                                BufferLength
                                );
    }

    return(TRUE);
}



/***************************************************************************\
* DuplicateUnicodeString
*
* Purpose : Allocates space for new string then copies new into old.
*           The new string is always 0 terminated
*           The new string should be free using RtlFreeUnicodeString()
*
* Returns : TRUE on success, FALSE on failure
*
* History:
* 11-04-92 Davidc       Created.
* 05-29-98 DSheldon     Modified so that no uni->ansi->uni translation occurs
\***************************************************************************/

BOOL
DuplicateUnicodeString(
    PUNICODE_STRING OutString,
    PUNICODE_STRING InString
    )
{
    *OutString = *InString ;

    OutString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, InString->Length + sizeof(WCHAR) );
    if ( OutString->Buffer )
    {
        RtlCopyMemory( OutString->Buffer,
                       InString->Buffer,
                       InString->Length );

        OutString->Buffer[ OutString->Length / sizeof( WCHAR ) ] = L'\0';
        OutString->MaximumLength = OutString->Length + sizeof( WCHAR );
    }


    return (OutString->Buffer != NULL);
}

/***************************************************************************\
* FUNCTION: OpenIniFileUserMapping
*
* PURPOSE:  Forces the ini file mapping apis to reference the current user's
*           registry.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*   24-Aug-92 Davidc       Created.
*
\***************************************************************************/

BOOL
OpenIniFileUserMapping(
    PGLOBALS pGlobals
    )
{
    BOOL Result;
    HANDLE ImpersonationHandle;

    //
    // Impersonate the user
    //

    ImpersonationHandle = ImpersonateUser(&pGlobals->UserProcessData, NULL);

    if (ImpersonationHandle == NULL) {
        DebugLog((DEB_ERROR, "OpenIniFileUserMapping failed to impersonate user"));
        return(FALSE);
    }

    Result = OpenProfileUserMapping();

    if (!Result) {
        DebugLog((DEB_ERROR, "OpenProfileUserMapping failed, error = %d", GetLastError()));
    }

    //
    // Revert to being 'ourself'
    //

    if (!StopImpersonating(ImpersonationHandle)) {
        DebugLog((DEB_ERROR, "OpenIniFileUserMapping failed to revert to self"));
    }

    return(Result);
}


/***************************************************************************\
* FUNCTION: CloseIniFileUserMapping
*
* PURPOSE:  Closes the ini file mapping to the user's registry such
*           that future use of the ini apis will fail if they reference
*           the user's registry.
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   24-Aug-92 Davidc       Created.
*
\***************************************************************************/

VOID
CloseIniFileUserMapping(
    PGLOBALS pGlobals
    )
{
    BOOL Result;

    Result = CloseProfileUserMapping();

    if (!Result) {
        DebugLog((DEB_ERROR, "CloseProfileUserMapping failed, error = %d", GetLastError()));
    }

    UNREFERENCED_PARAMETER(pGlobals);
}


/***************************************************************************\
* FUNCTION: AllocAndGetDlgItemText
*
* PURPOSE:  Allocates memory for and returns pointer to a copy of the text
*           in the specified dialog control.
*           The returned string should be freed using Free()
*
* RETURNS:  Pointer to copy of dlg item text, or NULL on failure.
*
* HISTORY:
*
*   9-Sep-92 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndGetDlgItemText(
    HWND hDlg,
    int  iItem
    )
{
    HWND hwnd;
    LPTSTR String;
    LONG Length;
    LONG BytesRequired;
    LONG LengthCopied;

    //
    // Go find the window handle of the control
    //

    hwnd = GetDlgItem(hDlg, iItem);
    if (hwnd == NULL) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : Couldn't find control %d in dialog 0x%lx", iItem, hDlg));
        ASSERT(hwnd != NULL);
        return(NULL);
    }

    //
    // Get the length of the control's text
    //

    Length = (LONG)SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);
    if (Length < 0) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : Dialog control text length < 0 (%d)", Length));
        ASSERT(Length >= 0);
        return(NULL);
    }

    //
    // Calculate the bytes required for the string.
    // The length doesn't include the terminator
    //

    Length ++; // Add one for terminator
    BytesRequired = Length * sizeof(TCHAR);

    String = (LPTSTR)Alloc(BytesRequired);
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : Failed to allocate %d bytes for dialog control text", BytesRequired));
        return(NULL);
    }

    //
    // Fill in the allocated block with the text
    //

    LengthCopied = (LONG)SendMessage(hwnd, WM_GETTEXT, Length, (LPARAM)String);
    if (LengthCopied != (Length - 1)) {
        DebugLog((DEB_ERROR, "AllocAndGetDlgItemText : WM_GETTEXT for %d chars only copied %d chars", Length-1, LengthCopied));
        ASSERT(LengthCopied == (Length - 1));
        Free(String);
        return(NULL);
    }

    String[Length - 1] = TEXT('\0');
    return(String);
}


/***************************************************************************\
* FUNCTION: AllocAndGetPrivateProfileString
*
* PURPOSE:  Allocates memory for and returns pointer to a copy of the
*           specified profile string
*           The returned string should be freed using Free()
*
* RETURNS:  Pointer to copy of profile string or NULL on failure.
*
* HISTORY:
*
*  12-Nov-92 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndGetPrivateProfileString(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    LPCTSTR lpDefault,
    LPCTSTR lpFileName
    )
{
    LPTSTR String;
    LPTSTR NewString ;
    LONG LengthAllocated;
    LONG LengthCopied;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    LengthAllocated = TYPICAL_STRING_LENGTH;

    String = Alloc(LengthAllocated * sizeof(TCHAR));
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndGetPrivateProfileString : Failed to allocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
        return(NULL);
    }

    while (TRUE) {

        LengthCopied = GetPrivateProfileString( lpAppName,
                                                lpKeyName,
                                                lpDefault,
                                                String,
                                                LengthAllocated,
                                                lpFileName
                                              );
        //
        // If the returned value is our passed size - 1 (weird way for error)
        // then our buffer is too small. Make it bigger and start over again.
        //

        if (LengthCopied == (LengthAllocated - 1)) {

            VerbosePrint(("AllocAndGetPrivateProfileString: Failed with buffer length = %d, reallocating and retrying", LengthAllocated));

            LengthAllocated *= 2;
            NewString = ReAlloc(String, LengthAllocated * sizeof(TCHAR));
            if (NewString == NULL) {
                Free( String );
                String = NULL ;
                DebugLog((DEB_ERROR, "AllocAndGetPrivateProfileString : Failed to reallocate %d bytes for string", LengthAllocated * sizeof(TCHAR)));
                break;
            }

            String = NewString ;

            //
            // Go back and try to read it again
            //

        } else {

            //
            // Success!
            //

            break;
        }

    }

    return(String);
}


/***************************************************************************\
* FUNCTION: WritePrivateProfileInt
*
* PURPOSE:  Writes out an integer to a profile file
*
* RETURNS:  TRUE on success, FALSE on failure
*
* HISTORY:
*
*  12-Nov-92 Davidc       Created.
*
\***************************************************************************/

BOOL
WritePrivateProfileInt(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    UINT Value,
    LPCTSTR lpFileName
    )
{
    NTSTATUS Status;
    TCHAR String[30];
    UNICODE_STRING UniString;

    UniString.MaximumLength = 30;
    UniString.Buffer = String;

    Status = RtlIntegerToUnicodeString(Value,10,&UniString);

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    return (WritePrivateProfileString(lpAppName, lpKeyName, UniString.Buffer, lpFileName));

}


/***************************************************************************\
* FUNCTION: AllocAndRegQueryValueEx
*
* PURPOSE:  Version of RegQueryValueEx that returns value in allocated buffer.
*           The returned buffer should be freed using Free()
*
* RETURNS:  Pointer to key value or NULL on failure. The reason for the
*           error can be obtains using GetLastError()
*
* HISTORY:
*
*  15-Jan-93 Davidc       Created.
*
\***************************************************************************/

LPTSTR
AllocAndRegQueryValueEx(
    HKEY hKey,
    LPTSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType
    )
{
    LPTSTR String;
    LPTSTR NewString;
    DWORD BytesAllocated;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    BytesAllocated = TYPICAL_STRING_LENGTH * sizeof(TCHAR);

    String = Alloc(BytesAllocated);
    if (String == NULL) {
        DebugLog((DEB_ERROR, "AllocAndRegQueryValueEx : Failed to allocate %d bytes for string", BytesAllocated));
        return(NULL);
    }

    while (TRUE) {

        DWORD Error;

        DWORD BytesReturned = BytesAllocated;

        Error = RegQueryValueEx(hKey,
                                lpValueName,
                                lpReserved,
                                lpType,
                                (LPBYTE)String,
                                &BytesReturned);
        if (Error == ERROR_SUCCESS) {
            break;
        }

        if (Error != ERROR_MORE_DATA) {

            DebugLog((DEB_ERROR, "AllocAndRegQueryValueEx : RegQueryValueEx failed, error = %d", Error));
            Free(String);
            String = NULL;
            SetLastError(Error);
            break;
        }

        //
        // The buffer was too small, make it bigger and try again
        //

        VerbosePrint(("AllocAndRegQueryValueEx: Failed with buffer length = %d bytes, reallocating and retrying", BytesAllocated));

        BytesAllocated *= 2;
        NewString = ReAlloc(String, BytesAllocated);
        if (NewString == NULL) {
            Free( String );
            String = NULL ;
            DebugLog((DEB_ERROR, "AllocAndRegQueryValueEx : Failed to reallocate %d bytes for string", BytesAllocated));
            break;
        }

        String = NewString;
    }

    return(String);
}

/***************************************************************************\
* FUNCTION: ReadWinlogonBoolValue
*
* PURPOSE:  Determines the correct BOOL value for the requested
*           value name by first looking up the machine preference
*           and then checking for policy
*
* RETURNS:  TRUE or FALSE
*
* HISTORY:
*
*   EricFlo 10-14-98 Created
*
\***************************************************************************/

BOOL
ReadWinlogonBoolValue (LPTSTR lpValueName, BOOL bDefault)
{
    BOOL bResult;
    HKEY hKey;
    DWORD dwSize, dwType;


    //
    // Get the machine preference first
    //

    bResult = GetProfileInt(APPLICATION_NAME, lpValueName, bDefault);


    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY,
                     0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bResult);
        RegQueryValueEx(hKey, lpValueName, 0, &dwType,
                        (LPBYTE)&bResult, &dwSize);

        RegCloseKey (hKey);
    }

    return bResult;
}

/***************************************************************************\
* HandleComboBoxOK
*
* Deals with UI requirements when OK is selected in a dialog when the
* focus is on or in a combo-box.
*
* This routine should be called from a dialog proc that contains a
* combo-box when a WM_COMMAND, IDOK is received.
*
* Returns TRUE if the message was dealt with and the caller should ignore it,
* FALSE if this routine did nothing with it and the caller should process it
* normally.
*
* History:
* 24-Sep-92 Davidc       Created.
\***************************************************************************/
BOOL
HandleComboBoxOK(
    HWND    hDlg,
    int     ComboBoxId
    )
{
    HWND hwndFocus = GetFocus();
    HWND hwndCB = GetDlgItem(hDlg, ComboBoxId);

    //
    // Hitting enter on a combo-box with the list showing should simply
    // hide the list.
    // We check for focus window being a child of the combo-box to
    // handle non-list style combo-boxes which have the focus on
    // the child edit control.
    //

    if ((hwndFocus == hwndCB) || IsChild(hwndCB, hwndFocus)) {

        if (SendMessage(hwndCB, CB_GETDROPPEDSTATE, 0, 0)) {

            //
            // Make the list-box disappear and we're done.
            //

            SendMessage(hwndCB, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0);
            return(TRUE);
        }
    }

    //
    // We didn't do anything
    //

    return(FALSE);
}


/***************************************************************************\
* FUNCTION: EncodeMultiSzW
*
* PURPOSE:  Converts a multi-sz string and encodes it to look like
*           a single string.
*
*           We replace the terminators between strings
*           with the TERMINATOR_REPLACEMENT character. We replace
*           existing occurrences of the replacement character with
*           two of them.
*
* RETURNS:  Pointer to encoded string or NULL on failure.
*           The returned buffer should be freed using Free()
*
* HISTORY:
*
*   01-12-93 Davidc       Created.
*
\***************************************************************************/

#define TERMINATOR_REPLACEMENT  TEXT(',')

LPWSTR
EncodeMultiSzW(
    IN LPWSTR MultiSz
    )
{
    DWORD Length;
    DWORD NewLength;
    LPWSTR NewBuffer;
    LPWSTR p, q;
    DWORD ExtraCharacters;

    //
    // First calculate the length of the new string (with replacements)
    //

    p = MultiSz;
    ExtraCharacters = 0;

    while (*p) {
        while (*p) {
            if (*p == TERMINATOR_REPLACEMENT) {
                ExtraCharacters ++;
            }
            p ++;
        }
        p ++;
    }

    Length = (DWORD)(p - MultiSz); // p points at 'second' (final) null terminator
    NewLength = Length + ExtraCharacters;

    //
    // Allocate space for the new string
    //

    NewBuffer = Alloc((NewLength + 1) * sizeof(WCHAR));
    if (NewBuffer == NULL) {
        DebugLog((DEB_ERROR, "EncodeMultiSz: failed to allocate space for %d bytes", (NewLength + 1) * sizeof(WCHAR)));
        return(NULL);
    }

    //
    // Copy the string into the new buffer making replacements as we go
    //

    p = MultiSz;
    q = NewBuffer;

    while (*p) {
        while (*p) {

            *q = *p;

            if (*p == TERMINATOR_REPLACEMENT) {
                q ++;
                *q = TERMINATOR_REPLACEMENT;
            }

            p ++;
            q ++;
        }

        *q = TERMINATOR_REPLACEMENT;

        p ++;
        q ++;
    }

    ASSERT((DWORD)(q - NewBuffer) == NewLength);

    //
    // Add terminator
    //

    *q = 0;


    return(NewBuffer);
}


/***************************************************************************\
* TimeoutMessageBox
*
* Same as a normal message box, but times out if there is no user input
* for the specified number of seconds
* For convenience, this api takes string resource ids rather than string
* pointers as input. The resources are loaded from the .exe module
*
* 12-05-91 Davidc       Created.
\***************************************************************************/

INT_PTR
TimeoutMessageBox(
    HWND hwnd,
    PGLOBALS pGlobals,
    UINT IdText,
    UINT IdCaption,
    UINT wType,
    TIMEOUT Timeout
    )
{
    PTCHAR   Caption = NULL;
    PTCHAR   Text = NULL;
    INT_PTR result;
    
    Text = (TCHAR*) Alloc(MAX_STRING_BYTES * sizeof(TCHAR));
    if( NULL == Text )
    {
        return MSGINA_DLG_FAILURE;
    }

    Text[0] = '\0';
    LoadString(hDllInstance, IdText, Text, MAX_STRING_BYTES);

    if (IdCaption != 0) {
        Caption = (TCHAR*) Alloc(MAX_STRING_BYTES * sizeof(TCHAR));
        if( NULL != Caption )
        {
            Caption[0] = '\0';
            LoadString(hDllInstance, IdCaption, Caption, MAX_STRING_BYTES);
        }
    }

    result = TimeoutMessageBoxlpstr(hwnd, pGlobals, Text, Caption, wType, Timeout);
    if( NULL != Text )
    {
        Free(Text);
    }

    if( NULL != Caption )
    {
        Free(Caption);
    }

    return result;
}


/***************************************************************************\
* TimeoutMessageBoxlpstr
*
* Same as a normal message box, but times out if there is no user input
* for the specified number of seconds
*
* 12-05-91 Davidc       Created.
\***************************************************************************/

INT_PTR
TimeoutMessageBoxlpstr(
    HWND hwnd,
    PGLOBALS pGlobals,
    LPTSTR Text,
    LPTSTR Caption,
    UINT wType,
    TIMEOUT Timeout
    )
{
    INT_PTR DlgResult;
    BOOL    fStatusHostHidden;

    fStatusHostHidden = _Shell_LogonStatus_IsHidden();
    _Shell_LogonStatus_Hide();

    // Set up input timeout

    pWlxFuncs->WlxSetTimeout(pGlobals->hGlobalWlx, Timeout);

    DlgResult = pWlxFuncs->WlxMessageBox(   pGlobals->hGlobalWlx,
                                            hwnd,
                                            Text,
                                            Caption,
                                            wType);

    if (!fStatusHostHidden)
    {
        _Shell_LogonStatus_Show();
    }

    return(DlgResult);
}

PWSTR
DupString(PWSTR pszString)
{
    DWORD   cbString;
    PWSTR   pszNewString;

    cbString = (DWORD) (wcslen(pszString) + 1) * sizeof(WCHAR);
    pszNewString = LocalAlloc(LMEM_FIXED, cbString);
    if (pszNewString)
    {
        CopyMemory(pszNewString, pszString, cbString);
    }
    return(pszNewString);
}

PWSTR
DupUnicodeString(PUNICODE_STRING    pString)
{
    PWSTR   pszNewString;

    if (pString->Length)
    {
        pszNewString = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pString->Length + sizeof(WCHAR));
        if (pszNewString)
        {
            CopyMemory(pszNewString, pString->Buffer, pString->Length);
        }
    }
    else

        pszNewString = NULL;

    return(pszNewString);
}

/***************************************************************************\
* FUNCTION: EnableDomainForUPN
*
* PURPOSE:  Enables or disables the domain text box based on whether or not
*           a UPN-style name is typed into the username box.
*
* RETURNS:  none
*
* HISTORY:
*
*   04-17-1998 dsheldon created
*
\***************************************************************************/
void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain)
{
    BOOL fEnable;

    // Get the string the user is typing
    TCHAR* pszLogonName;
    int cchBuffer = (int)SendMessage(hwndUsername, WM_GETTEXTLENGTH, 0, 0) + 1;

    pszLogonName = (TCHAR*) Alloc(cchBuffer * sizeof(TCHAR));
    if (pszLogonName != NULL)
    {
        SendMessage(hwndUsername, WM_GETTEXT, (WPARAM) cchBuffer, (LPARAM) pszLogonName);

        // Disable the domain combo if the user is using a
        // UPN (if there is a "@") - ie foo@microsoft.com OR
        // domain\username form
        fEnable = (NULL == wcspbrk(pszLogonName, TEXT("@\\")));

        EnableWindow(hwndDomain, fEnable);

        Free(pszLogonName);
    }
}

// TRUE if we must always hide the domain box (local logon, UPN, smartcard only)
// FALSE if this policy isn't set or is set to 0x0
BOOL ForceNoDomainUI()
{
    DWORD dwPolicyVal = 0;
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_QUERY_VALUE, &hkey))
    {
        DWORD cbData = sizeof (dwPolicyVal);
        DWORD dwType;

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, NODOMAINCOMBO, 0, &dwType, (LPBYTE) &dwPolicyVal, &cbData))
        {
            dwPolicyVal = 0;
        }

        RegCloseKey(hkey);
    }

    return (0 != dwPolicyVal);
}

DWORD GetReasonSelection(HWND hwndCombo)
{
    DWORD dwResult;
    PREASON pReason;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != (int) CB_ERR) {
        pReason = (PREASON) ComboBox_GetItemData(hwndCombo, iItem);
        dwResult = pReason->dwCode;
    } else {
        dwResult = SHTDN_REASON_UNKNOWN;
    }

    return dwResult;
}

VOID SetReasonDescription(HWND hwndCombo, HWND hwndStatic)
{
    PREASON pReason;
    int iItem = ComboBox_GetCurSel(hwndCombo);

    if (iItem != CB_ERR) {
        pReason = (PREASON) ComboBox_GetItemData(hwndCombo, iItem);
        SetWindowText(hwndStatic, pReason->szDesc);
    }
}


#define SMALL_STRING_SIZE 128

/***************************************************************************\
* DisplayForceLogoffWarning
*
* This prompts the warning when one administrator has locked the system and 
* the other administrator is trying to unlock it. The warning message includes
* the idle time that the other user is Same as a normal message box, 
*
\***************************************************************************/

INT_PTR
DisplayForceLogoffWarning(
    HWND hwnd,
    PGLOBALS pGlobals,
    UINT wType,
    TIMEOUT Timeout
    )
{
    TCHAR    *Caption = NULL;
    TCHAR    *Text = NULL;
    TCHAR    Buffer[SMALL_STRING_SIZE];
    TCHAR    *MessageBuf = NULL;
    TIME     Now;
    LONGLONG IdleTime;
    INT_PTR  DlgResult;
    TCHAR    *IdleTimeStr;

    // Calculate the idle time in days, hours, minutes and seconds.
    ULONG Days, Hours, Minutes;

    // Allocate space for console info.
    IdleTimeStr = (TCHAR *)LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES*sizeof(TCHAR));
    if (IdleTimeStr == NULL) {
        return MSGINA_DLG_FAILURE;
    }

    // Allocate space for message buffer.
    MessageBuf = (TCHAR *)LocalAlloc(LMEM_FIXED, (MAX_STRING_BYTES*2)*sizeof(TCHAR));
    if (MessageBuf == NULL) {
        LocalFree(IdleTimeStr);
        return MSGINA_DLG_FAILURE;
    }

    Text = (TCHAR *)LocalAlloc(LMEM_FIXED, (MAX_STRING_BYTES)*sizeof(TCHAR));
    if (Text == NULL) {
        LocalFree(IdleTimeStr);
        LocalFree(MessageBuf);
        return MSGINA_DLG_FAILURE;
    }

    Caption = (TCHAR *)LocalAlloc(LMEM_FIXED, (MAX_STRING_BYTES)*sizeof(TCHAR));
    if (Caption == NULL) {
        LocalFree(IdleTimeStr);
        LocalFree(MessageBuf);
        LocalFree(Text);
        return MSGINA_DLG_FAILURE;
    }

    // Some initializations
    IdleTimeStr[0] = (TCHAR)0;
    MessageBuf[0] = (TCHAR)0;
    Buffer[0] = (TCHAR)0;
    Text[0] = (TCHAR)0;

    GetSystemTimeAsFileTime((FILETIME*) &Now);

    // Get the idle time in seconds.
    IdleTime = Now.QuadPart - pGlobals->LockTime.QuadPart;
    IdleTime /= 600000000L;
    Days = (ULONG) (IdleTime / 1440);
    IdleTime %= 1440;
    Hours = (ULONG) (IdleTime / 60);
    Minutes = (ULONG) (IdleTime % 60);

    if (Days) {
        if (Hours) {
            LoadString(hDllInstance, IDS_IDLETIME_INDAYSANDHOURS, Buffer, SMALL_STRING_SIZE);
            _snwprintf(IdleTimeStr, MAX_STRING_BYTES, Buffer, Days, Hours);
        }
        else {
            LoadString(hDllInstance, IDS_IDLETIME_INDAYS, Buffer, SMALL_STRING_SIZE);
            _snwprintf(IdleTimeStr, MAX_STRING_BYTES, Buffer, Days);
        }
    }
    else {
        if (Hours) {
            if (Minutes) {
                LoadString(hDllInstance, IDS_IDLETIME_INHOURSANDMINUTES, Buffer, SMALL_STRING_SIZE);
                _snwprintf(IdleTimeStr, MAX_STRING_BYTES, Buffer, Hours, Minutes);
            }
            else {
                LoadString(hDllInstance, IDS_IDLETIME_INHOURS, Buffer, SMALL_STRING_SIZE);
                _snwprintf(IdleTimeStr, MAX_STRING_BYTES, Buffer, Hours);
            }
        } 
        else {
            LoadString(hDllInstance, IDS_IDLETIME_INMINUTES, Buffer, SMALL_STRING_SIZE);
            _snwprintf(IdleTimeStr, MAX_STRING_BYTES, Buffer, Minutes);
        }
    }

    IdleTimeStr[MAX_STRING_BYTES - 1] = 0;     // Let's make sure it's NULL terminated

    if ( pGlobals->Domain[0] == TEXT('\0') ) {
        LoadString(hDllInstance, IDS_FORCE_LOGOFF_UPN_WARNING, Text, MAX_STRING_BYTES);
        _snwprintf(MessageBuf, (MAX_STRING_BYTES*2), Text, pGlobals->UserName, IdleTimeStr);
    } else {
        LoadString(hDllInstance, IDS_FORCE_LOGOFF_WARNING, Text, MAX_STRING_BYTES);
        _snwprintf(MessageBuf, (MAX_STRING_BYTES*2), Text, pGlobals->Domain, pGlobals->UserName, IdleTimeStr);
    }

    MessageBuf[MAX_STRING_BYTES*2 - 1] = 0;     // Let's make sure it's NULL terminated

    LoadString(hDllInstance, IDS_LOGON_MESSAGE, Caption, MAX_STRING_BYTES);

    DlgResult = TimeoutMessageBoxlpstr(hwnd, pGlobals, MessageBuf, Caption, wType, Timeout);

    if (MessageBuf)
        LocalFree(MessageBuf);

    if (Text)
        LocalFree(Text);

    if (Caption)
        LocalFree(Caption);

    if (IdleTimeStr)
        LocalFree(IdleTimeStr);

    return DlgResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\wlsec.h ===
/****************************** Module Header ******************************\
* Module Name: security.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define various winlogon security-related routines
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/

extern PSID gLocalSid;     // Initialized in 'InitializeSecurityGlobals'
extern PSID gAdminSid;     // Initialized in 'InitializeSecurityGlobals'
extern PSID pWinlogonSid;  // Initialized in 'InitializeSecurityGlobals'

PVOID
FormatPasswordCredentials(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    );

PVOID
FormatSmartCardCredentials(
    IN PUNICODE_STRING Pin,
    IN PVOID SmartCardInfo,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    );


NTSTATUS
WinLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthInfo,
    IN ULONG AuthInfoSize,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PNTSTATUS SubStatus,
    OUT POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    );


BOOL
UnlockLogon(
    PGLOBALS pGlobals,
    IN BOOL SmartCardUnlock,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString,
    OUT PNTSTATUS Status,
    OUT PBOOL IsAdmin,
    OUT PBOOL IsLoggedOnUser,
    OUT PVOID *pProfileBuffer,
    OUT ULONG *pProfileBufferLength
    );


BOOL
EnablePrivilege(
    ULONG Privilege,
    BOOL Enable
    );


BOOL
TestTokenForAdmin(
    HANDLE Token
    );

BOOL
TestUserForAdmin(
    PGLOBALS pGlobals,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString
    );


BOOL
TestUserPrivilege(
    HANDLE UserToken,
    ULONG Privilege
    );

VOID
HidePassword(
    PUCHAR Seed OPTIONAL,
    PUNICODE_STRING Password
    );


VOID
RevealPassword(
    PUNICODE_STRING HiddenPassword
    );

VOID
ErasePassword(
    PUNICODE_STRING Password
    );

BOOL
InitializeAuthentication(
    IN PGLOBALS pGlobals
    );

HANDLE
ImpersonateUser(
    PUSER_PROCESS_DATA UserProcessData,
    HANDLE      ThreadHandle
    );


BOOL
StopImpersonating(
    HANDLE  ThreadHandle
    );


PSECURITY_DESCRIPTOR
CreateUserThreadTokenSD(
    PSID    UserSid,
    PSID    WinlogonSid
    );

PSID
DuplicateSID(
    PSID pSrcSID
    );

VOID
FreeSecurityDescriptor(
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    );

VOID
InitializeSecurityGlobals(
    VOID
    );

VOID
FreeSecurityGlobals(
    VOID
    );

VOID
HashPassword(
    PUNICODE_STRING Password,
    PUCHAR HashBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\wlsec.c ===
/****************************** Module Header ******************************\
* Module Name: security.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Handles security aspects of winlogon operation.
*
* History:
* 12-05-91 Davidc       Created - mostly taken from old winlogon.c
\***************************************************************************/

#include "msgina.h"
#include "authmon.h"
#pragma hdrstop
#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>
#include <secint.h>
#include <wincrypt.h>
#include <sclogon.h>
#include <md5.h>
#include <align.h>
#include <ginacomn.h>

#include <Winsock2.h>

extern BOOL    g_IsTerminalServer;
//
// 'Constants' used in this module only.
//
SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY gLocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
PSID gLocalSid;     // Initialized in 'InitializeSecurityGlobals'
PSID gAdminSid;     // Initialized in 'InitializeSecurityGlobals'
PSID pWinlogonSid;  // Initialized in 'InitializeSecurityGlobals'

//
// This structure wraps parameters passed to the background logon thread.
// The background logon is queued to the thread pool after a fast-cached
// logon to update the cached credentials.
//

typedef struct _BACKGROUND_LOGON_PARAMETERS {
    ULONG AuthenticationPackage;
    ULONG AuthenticationInformationLength;
    PVOID AuthenticationInformation;
    PWCHAR UserSidString;
    HANDLE LsaHandle;
} BACKGROUND_LOGON_PARAMETERS, *PBACKGROUND_LOGON_PARAMETERS;

//
// Routines to check for & perform fast cached logon if policy allows it.
//

NTSTATUS 
AttemptCachedLogon(
    HANDLE LsaHandle,
    PLSA_STRING OriginName,
    SECURITY_LOGON_TYPE LogonType,
    ULONG AuthenticationPackage,
    PVOID AuthenticationInformation,
    ULONG AuthenticationInformationLength,
    PTOKEN_GROUPS LocalGroups,
    PTOKEN_SOURCE SourceContext,
    PVOID *ProfileBuffer,
    PULONG ProfileBufferLength,
    PLUID LogonId,
    PHANDLE UserToken,
    PQUOTA_LIMITS Quotas,
    PNTSTATUS SubStatus,
    POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    );

DWORD 
BackgroundLogonWorker(
    PBACKGROUND_LOGON_PARAMETERS LogonParameters
    );

#define PASSWORD_HASH_STRING    TEXT("Long string used by msgina inside of winlogon to hash out the password")

typedef LONG    ACEINDEX;
typedef ACEINDEX *PACEINDEX;

typedef struct _MYACE {
    PSID    Sid;
    ACCESS_MASK AccessMask;
    UCHAR   InheritFlags;
} MYACE;
typedef MYACE *PMYACE;

BOOL
InitializeWindowsSecurity(
    PGLOBALS pGlobals
    );

BOOL
InitializeAuthentication(
    IN PGLOBALS pGlobals
    );

/***************************************************************************\
* SetMyAce
*
* Helper routine that fills in a MYACE structure.
*
* History:
* 02-06-92 Davidc       Created
\***************************************************************************/
VOID
SetMyAce(
    PMYACE MyAce,
    PSID Sid,
    ACCESS_MASK Mask,
    UCHAR InheritFlags
    )
{
    MyAce->Sid = Sid;
    MyAce->AccessMask= Mask;
    MyAce->InheritFlags = InheritFlags;
}

/***************************************************************************\
* CreateAccessAllowedAce
*
* Allocates memory for an ACCESS_ALLOWED_ACE and fills it in.
* The memory should be freed by calling DestroyACE.
*
* Returns pointer to ACE on success, NULL on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PVOID
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    )
{
    ULONG   LengthSid = RtlLengthSid(Sid);
    ULONG   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)Alloc(LengthACE);
    if (Ace == NULL) {
        DebugLog((DEB_ERROR, "CreateAccessAllowedAce : Failed to allocate ace\n"));
        return NULL;
    }

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (UCHAR)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask = AccessMask;
    RtlCopySid(LengthSid, (PSID)(&(Ace->SidStart)), Sid );

    return(Ace);
}


/***************************************************************************\
* DestroyAce
*
* Frees the memory allocate for an ACE
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
VOID
DestroyAce(
    PVOID   Ace
    )
{
    Free(Ace);
}

/***************************************************************************\
* CreateSecurityDescriptor
*
* Creates a security descriptor containing an ACL containing the specified ACEs
*
* A SD created with this routine should be destroyed using
* DeleteSecurityDescriptor
*
* Returns a pointer to the security descriptor or NULL on failure.
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    PMYACE  MyAce,
    ACEINDEX AceCount
    )
{
    NTSTATUS Status;
    ACEINDEX AceIndex;
    PACCESS_ALLOWED_ACE *Ace;
    PACL    Acl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG   LengthAces;
    ULONG   LengthAcl;
    ULONG   LengthSd;

    //
    // Allocate space for the ACE pointer array
    //

    Ace = (PACCESS_ALLOWED_ACE *)Alloc(sizeof(PACCESS_ALLOWED_ACE) * AceCount);
    if (Ace == NULL) {
        DebugLog((DEB_ERROR, "Failed to allocated ACE array\n"));
        return(NULL);
    }

    //
    // Create the ACEs and calculate total ACE size
    //

    LengthAces = 0;
    for (AceIndex=0; AceIndex < AceCount; AceIndex ++) {
        Ace[AceIndex] = CreateAccessAllowedAce(MyAce[AceIndex].Sid,
                                               MyAce[AceIndex].AccessMask,
                                               0,
                                               MyAce[AceIndex].InheritFlags);
        if (Ace[AceIndex] == NULL) {
            DebugLog((DEB_ERROR, "Failed to allocate ace\n"));
        } else {
            LengthAces += Ace[AceIndex]->Header.AceSize;
        }
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl = sizeof(ACL) + LengthAces;
    LengthSd  = SECURITY_DESCRIPTOR_MIN_LENGTH;

    //
    // Create the ACL
    //

    Acl = Alloc(LengthAcl);

    if (Acl != NULL) {

        Status = RtlCreateAcl(Acl, LengthAcl, ACL_REVISION);
        ASSERT(NT_SUCCESS(Status));

        //
        // Add the ACES to the ACL and destroy the ACEs
        //

        for (AceIndex = 0; AceIndex < AceCount; AceIndex ++) {

            if (Ace[AceIndex] != NULL) {

                Status = RtlAddAce(Acl, ACL_REVISION, 0, Ace[AceIndex],
                                   Ace[AceIndex]->Header.AceSize);

                if (!NT_SUCCESS(Status)) {
                    DebugLog((DEB_ERROR, "AddAce failed, status = 0x%lx", Status));
                }

                DestroyAce( Ace[AceIndex] );
            }
        }

    } else {
        DebugLog((DEB_ERROR, "Failed to allocate ACL\n"));

        for ( AceIndex = 0 ; AceIndex < AceCount ; AceIndex++ )
        {
            if ( Ace[AceIndex] )
            {
                DestroyAce( Ace[ AceIndex ] );
            }
        }
    }

    //
    // Free the ACE pointer array
    //
    Free(Ace);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = Alloc(LengthSd);

    if (SecurityDescriptor != NULL) {

        Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        ASSERT(NT_SUCCESS(Status));

        //
        // Set the DACL on the security descriptor
        //
        Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl, FALSE);
        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "SetDACLSD failed, status = 0x%lx", Status));
        }
    } else {

        DebugLog((DEB_ERROR, "Failed to allocate security descriptor\n"));

        Free( Acl );
    }

    //
    // Return with our spoils
    //
    return(SecurityDescriptor);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeSecurityDescriptor
//
//  Synopsis:   Frees security descriptors created by CreateSecurityDescriptor
//
//  Arguments:  [SecurityDescriptor] --
//
//  History:    5-09-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
FreeSecurityDescriptor(
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    )
{
    PACL    Acl;
    BOOL    Present;
    BOOL    Defaulted;

    Acl = NULL;

    GetSecurityDescriptorDacl( SecurityDescriptor,
                             &Present,
                             &Acl,
                             &Defaulted );

    if ( Acl )
    {
        Free( Acl );
    }

    Free( SecurityDescriptor );

}
/***************************************************************************\
* CreateUserThreadTokenSD
*
* Creates a security descriptor to protect tokens on user threads
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
PSECURITY_DESCRIPTOR
CreateUserThreadTokenSD(
    PSID    UserSid,
    PSID    WinlogonSid
    )
{
    MYACE   Ace[2];
    ACEINDEX AceCount = 0;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    ASSERT(UserSid != NULL);    // should always have a non-null user sid

    //
    // Define the User ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             UserSid,
             TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS |
             TOKEN_ADJUST_DEFAULT | TOKEN_QUERY |
             TOKEN_DUPLICATE | TOKEN_IMPERSONATE | READ_CONTROL,
             0
             );

    //
    // Define the Winlogon ACEs
    //

    SetMyAce(&(Ace[AceCount++]),
             WinlogonSid,
             TOKEN_ALL_ACCESS,
             0
             );

    // Check we didn't goof
    ASSERT((sizeof(Ace) / sizeof(MYACE)) >= AceCount);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = CreateSecurityDescriptor(Ace, AceCount);
    if (SecurityDescriptor == NULL) {
        DebugLog((DEB_ERROR, "failed to create user process token security descriptor\n"));
    }

    return(SecurityDescriptor);

}

/****************************************************************************\
*
* FUNCTION: DuplicateSID
*
* PURPOSE:  Duplicates a given SID
*
* PARAMS:   PSID, the SID to duplicate
*
* RETURNS:  the duplicated SID or
*           NULL.
*
* HISTORY:  10/08/2001 - crisilac created
*
*
\****************************************************************************/
PSID DuplicateSID(PSID pSrcSID)
{
    ULONG uSidLength = 0;
    PSID pOutSID = NULL;

    if ( pSrcSID && RtlValidSid(pSrcSID) )
    {
       uSidLength = RtlLengthSid(pSrcSID);
       pOutSID = Alloc(uSidLength);

       if( NULL != pOutSID )
       {
           if( !NT_SUCCESS(RtlCopySid(uSidLength, pOutSID, pSrcSID)) )
           {
               Free(pOutSID);
               pOutSID = NULL;
           }
       }
    }

    return pOutSID;
}

/***************************************************************************\
* InitializeSecurityGlobals
*
* Initializes the various global constants (mainly Sids used in this module.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
VOID
InitializeSecurityGlobals(
    VOID
    )
{
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    ULONG   SidLength;

    //
    // Get our sid so it can be put on object ACLs
    //

    SidLength = RtlLengthRequiredSid(1);
    pWinlogonSid = (PSID)Alloc(SidLength);
    if (!pWinlogonSid)
    {
        //
        // We're dead.  Couldn't even allocate memory for a measly SID...
        //
        return;
    }

    RtlInitializeSid(pWinlogonSid,  &SystemSidAuthority, 1);
    *(RtlSubAuthoritySid(pWinlogonSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;

    //
    // Initialize the local sid for later
    //

    Status = RtlAllocateAndInitializeSid(
                    &gLocalSidAuthority,
                    1,
                    SECURITY_LOCAL_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &gLocalSid
                    );

    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to initialize local sid, status = 0x%lx", Status));
    }

    //
    // Initialize the admin sid for later
    //

    Status = RtlAllocateAndInitializeSid(
                    &gSystemSidAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &gAdminSid
                    );
    if (!NT_SUCCESS(Status)) {
        WLPrint(("Failed to initialize admin alias sid, status = 0x%lx", Status));
    }

}

VOID
FreeSecurityGlobals(
    VOID
    )

{
    RtlFreeSid(gAdminSid);
    RtlFreeSid(gLocalSid);
    LocalFree(pWinlogonSid);
}

/***************************************************************************\
* InitializeAuthentication
*
* Initializes the authentication service. i.e. connects to the authentication
* package using the Lsa.
*
* On successful return, the following fields of our global structure are
* filled in :
*       LsaHandle
*       SecurityMode
*       AuthenticationPackage
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
BOOL
InitializeAuthentication(
    IN PGLOBALS pGlobals
    )
{
    NTSTATUS Status;
    STRING LogonProcessName;

    if (!EnablePrivilege(SE_TCB_PRIVILEGE, TRUE))
    {
        DebugLog((DEB_ERROR, "Failed to enable SeTcbPrivilege!\n"));
        return(FALSE);
    }

    //
    // Hookup to the LSA and locate our authentication package.
    //

    RtlInitString(&LogonProcessName, "Winlogon\\MSGina");
    Status = LsaRegisterLogonProcess(
                 &LogonProcessName,
                 &pGlobals->LsaHandle,
                 &pGlobals->SecurityMode
                 );

if (!NT_SUCCESS(Status)) {

        DebugLog((DEB_ERROR, "LsaRegisterLogonProcess failed:  %#x\n", Status));
        return(FALSE);
    }

    return TRUE;
}

PVOID
FormatPasswordCredentials(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PUNICODE_STRING Password,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    )
{
    PKERB_INTERACTIVE_LOGON KerbAuthInfo;
    ULONG AuthInfoSize;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    PBYTE Where;
    PWCHAR BackSlash;
    UNICODE_STRING UserNameBackup = {0};
    UNICODE_STRING DomainBackup = {0};

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)(&Password->Length);
    Seed = SeedAndLength->Seed;

    if (NULL != (BackSlash = wcschr(UserName->Buffer, L'\\')))
    {
            // we're going to massage UserName Domain
            // Let's save the current param
        memcpy(&UserNameBackup, UserName, sizeof(UNICODE_STRING));
        memcpy(&DomainBackup, Domain, sizeof(UNICODE_STRING));

        *BackSlash = 0;     // turn \ in 0
        RtlInitUnicodeString(UserName, BackSlash+1);
        RtlInitUnicodeString(Domain, UserNameBackup.Buffer);
    }
    // else BackSlash = NULL will be our trigger

    //
    // Build the authentication information buffer
    //

    if (Seed != 0) {
        RevealPassword( Password );
    }

    AuthInfoSize = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON) +
                    UserName->Length + 2 +
                    Domain->Length + 2 +
                    Password->Length + 2 ;



    KerbAuthInfo = Alloc(AuthInfoSize);
    if (KerbAuthInfo == NULL) {
        DebugLog((DEB_ERROR, "failed to allocate memory for authentication buffer\n"));

        if ( Seed != 0 )
        {
            HidePassword( &Seed, Password);
        }

        return( NULL );
    }

    //
    // This authentication buffer will be used for a logon attempt
    //

    if (Unlock)
    {
        ASSERT(ARGUMENT_PRESENT(LogonId));
        KerbAuthInfo->MessageType = KerbWorkstationUnlockLogon ;
        ((PKERB_INTERACTIVE_UNLOCK_LOGON) KerbAuthInfo)->LogonId = *LogonId;
        Where = (PBYTE) (KerbAuthInfo) + sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
    }
    else
    {
        KerbAuthInfo->MessageType = KerbInteractiveLogon ;
        Where = (PBYTE) (KerbAuthInfo + 1);
    }

    //
    // Copy the user name into the authentication buffer
    //

    KerbAuthInfo->UserName.Length =
                (USHORT) sizeof(TCHAR) * (USHORT) lstrlen(UserName->Buffer);

    KerbAuthInfo->UserName.MaximumLength =
                KerbAuthInfo->UserName.Length + sizeof(TCHAR);

    KerbAuthInfo->UserName.Buffer = (PWSTR)Where;
    lstrcpy(KerbAuthInfo->UserName.Buffer, UserName->Buffer);


    //
    // Copy the domain name into the authentication buffer
    //

    KerbAuthInfo->LogonDomainName.Length =
                 (USHORT) sizeof(TCHAR) * (USHORT) lstrlen(Domain->Buffer);

    KerbAuthInfo->LogonDomainName.MaximumLength =
                 KerbAuthInfo->LogonDomainName.Length + sizeof(TCHAR);

    KerbAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                 ((PBYTE)(KerbAuthInfo->UserName.Buffer) +
                                 KerbAuthInfo->UserName.MaximumLength);

    lstrcpy(KerbAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

    //
    // Copy the password into the authentication buffer
    // Hide it once we have copied it.  Use the same seed value
    // that we used for the original password in pGlobals.
    //

    KerbAuthInfo->Password.Length =
                 (USHORT) sizeof(TCHAR) * (USHORT) lstrlen(Password->Buffer);

    KerbAuthInfo->Password.MaximumLength =
                 KerbAuthInfo->Password.Length + sizeof(TCHAR);

    KerbAuthInfo->Password.Buffer = (PWSTR)
                                 ((PBYTE)(KerbAuthInfo->LogonDomainName.Buffer) +
                                 KerbAuthInfo->LogonDomainName.MaximumLength);
    lstrcpy(KerbAuthInfo->Password.Buffer, Password->Buffer);

    if ( Seed != 0 )
    {
        HidePassword( &Seed, Password);
    }

    HidePassword( &Seed, (PUNICODE_STRING) &KerbAuthInfo->Password);

    *Size = AuthInfoSize ;

    if (NULL != BackSlash)      // We need to restore our parameters
    {
        *BackSlash = L'\\';
        memcpy(UserName, &UserNameBackup, sizeof(UNICODE_STRING));
        memcpy(Domain, &DomainBackup, sizeof(UNICODE_STRING));
    }

    return KerbAuthInfo ;
}

PVOID
FormatSmartCardCredentials(
    PUNICODE_STRING Pin,
    PVOID SmartCardInfo,
    IN BOOLEAN Unlock,
    IN OPTIONAL PLUID LogonId,
    OUT PULONG Size
    )
{
    PKERB_SMART_CARD_LOGON KerbAuthInfo;
    ULONG AuthInfoSize;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    PULONG ScInfo ;
    PUCHAR Where ;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)(&Pin->Length);
    Seed = SeedAndLength->Seed;


    //
    // Build the authentication information buffer
    //

    ScInfo = (PULONG) SmartCardInfo ;


    if (Seed != 0) {
        RevealPassword( Pin );
    }

    AuthInfoSize = sizeof( KERB_SMART_CARD_UNLOCK_LOGON ) +
                    ROUND_UP_COUNT(Pin->Length + 2, 8) + *ScInfo ;

    KerbAuthInfo = (PKERB_SMART_CARD_LOGON) LocalAlloc( LMEM_FIXED, AuthInfoSize );

    if ( !KerbAuthInfo )
    {
        if ( Seed != 0 )
        {
            HidePassword( &Seed, Pin );
        }

        return NULL ;
    }

    if (Unlock)
    {
        ASSERT(ARGUMENT_PRESENT(LogonId));
        KerbAuthInfo->MessageType = KerbSmartCardUnlockLogon ;
        ((PKERB_SMART_CARD_UNLOCK_LOGON) KerbAuthInfo)->LogonId = *LogonId;
        Where = (PUCHAR) (KerbAuthInfo) + sizeof(KERB_SMART_CARD_UNLOCK_LOGON) ;
    }
    else
    {
        KerbAuthInfo->MessageType = KerbSmartCardLogon ;
        Where = (PUCHAR) (KerbAuthInfo + 1) ;
    }


    KerbAuthInfo->Pin.Buffer = (PWSTR) Where ;
    KerbAuthInfo->Pin.Length = Pin->Length ;
    KerbAuthInfo->Pin.MaximumLength = Pin->Length + 2 ;

    RtlCopyMemory( Where, Pin->Buffer, Pin->Length + 2 );

    Where += ROUND_UP_COUNT(Pin->Length + 2, 8) ;

    if ( Seed != 0 )
    {
        HidePassword( &Seed, Pin );
    }


    KerbAuthInfo->CspDataLength = *ScInfo ;
    KerbAuthInfo->CspData = Where ;

    RtlCopyMemory( Where, SmartCardInfo, *ScInfo );

    *Size = AuthInfoSize ;

    return KerbAuthInfo ;

}

/***************************************************************************\
* LogonUser
*
* Calls the Lsa to logon the specified user.
*
* The LogonSid and a LocalSid is added to the user's groups on successful logon
*
* For this release, password lengths are restricted to 255 bytes in length.
* This allows us to use the upper byte of the String.Length field to
* carry a seed needed to decode the run-encoded password.  If the password
* is not run-encoded, the upper byte of the String.Length field should
* be zero.
*
* NOTE: This function will LocalFree the passed in AuthInfo buffer.
*
* On successful return, LogonToken is a handle to the user's token,
* the profile buffer contains user profile information.
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
NTSTATUS
WinLogonUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthInfo,
    IN ULONG AuthInfoSize,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus,
    OUT POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    )
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PTOKEN_GROUPS TokenGroups = NULL;
    PMSV1_0_INTERACTIVE_PROFILE UserProfile;
    PWCHAR UserSidString;
    DWORD ErrorCode;
    DWORD LogonCacheable;
    DWORD DaysToCheck;
    DWORD DaysToExpiry;
    LARGE_INTEGER CurrentTime;
    BOOLEAN UserLoggedOnUsingCache;   

    DebugLog((DEB_TRACE, "  LsaHandle = %x\n", LsaHandle));
    DebugLog((DEB_TRACE, "  AuthenticationPackage = %d\n", AuthenticationPackage));
#if DBG
    if (!RtlValidSid(LogonSid))
    {
        DebugLog((DEB_ERROR, "LogonSid is invalid!\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }
#endif

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "User32  ", sizeof(SourceContext.SourceName)); // LATER from res file
    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "failed to allocate locally unique id, status = 0x%lx", Status));
        goto cleanup;
    }

    //
    // Get any run-encoding information out of the way
    // and decode the password.  This creates a window
    // where the cleartext password will be in memory.
    // Keep it short.
    //
    // Save the seed so we can use the same one again.
    //



    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "Winlogon");

    //
    // Create logon token groups
    //

#define TOKEN_GROUP_COUNT   2 // We'll add the local SID and the logon SID

    TokenGroups = (PTOKEN_GROUPS)Alloc(sizeof(TOKEN_GROUPS) +
                  (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES));
    if (TokenGroups == NULL) {
        DebugLog((DEB_ERROR, "failed to allocate memory for token groups"));
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Fill in the logon token group list
    //

    TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
    TokenGroups->Groups[0].Sid = LogonSid;
    TokenGroups->Groups[0].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
    TokenGroups->Groups[1].Sid = gLocalSid;
    TokenGroups->Groups[1].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT;


    //
    // If logging on Interactive to the console, try cached logon first.
    //

    UserLoggedOnUsingCache = FALSE;

    if (LogonType == Interactive) {

        //
        // Optimized logon that does not hit the network does not
        // make sense for local logins.
        //

        if (IsMachineDomainMember()) {

            Status = AttemptCachedLogon(LsaHandle,
                                        &OriginName,
                                        CachedInteractive,
                                        AuthenticationPackage,
                                        AuthInfo,
                                        AuthInfoSize,
                                        TokenGroups,
                                        &SourceContext,
                                        pProfileBuffer,
                                        pProfileBufferLength,
                                        LogonId,
                                        LogonToken,
                                        Quotas,
                                        pSubStatus,
                                        OptimizedLogonStatus);

            if (NT_SUCCESS(Status)) {

                UserLoggedOnUsingCache = TRUE;

                //
                // AttemptCachedLogon will take care of freeing AuthInfo.
                //

                AuthInfo = NULL;
            }

        } else {

            *OptimizedLogonStatus = OLS_MachineIsNotDomainMember;
        }
            
    } else {

        *OptimizedLogonStatus = OLS_NonCachedLogonType;
    }
    
    //
    // If we have not been able to log the user on using cached credentials,
    // fall back to real network logon.
    //

    if (!UserLoggedOnUsingCache) {

        SOCKADDR_IN sa;
  
        sa.sin_family   = AF_INET;  // initial values in case this is not a TS session
        sa.sin_addr.S_un.S_un_b.s_b1 = 127;  // local host 127.0.0.1:0
        sa.sin_addr.S_un.S_un_b.s_b2 = 0;
        sa.sin_addr.S_un.S_un_b.s_b3 = 0;
        sa.sin_addr.S_un.S_un_b.s_b4 = 1;
        sa.sin_port                  = 0;
       
        if ( g_IsTerminalServer )
        {
            if ( !IsActiveConsoleSession())
            {
                WINSTATIONREMOTEADDRESS WinStationRemoteAddress_Info;
                WINSTATIONINFOCLASS WinStationInformationClass;
                ULONG Length = 0;
                BOOL fResult = FALSE;
            
                WinStationInformationClass = WinStationRemoteAddress;
            
                memset(&WinStationRemoteAddress_Info, 0, sizeof(WINSTATIONREMOTEADDRESS));
                fResult = WinStationQueryInformation(
                    SERVERNAME_CURRENT,
                    LOGONID_CURRENT,
                    WinStationInformationClass,
                    (PVOID)&WinStationRemoteAddress_Info,
                    sizeof(WINSTATIONREMOTEADDRESS),
                    &Length);

                //init for error case
                sa.sin_addr.S_un.S_un_b.s_b1 = 0;  
                sa.sin_addr.S_un.S_un_b.s_b2 = 0;  
                sa.sin_addr.S_un.S_un_b.s_b3 = 0;
                sa.sin_addr.S_un.S_un_b.s_b4 = 0;

                if(fResult)
                {
                    sa.sin_family =   WinStationRemoteAddress_Info.sin_family;

                    switch( sa.sin_family )
                    {
                    case AF_INET:
                        sa.sin_port = WinStationRemoteAddress_Info.ipv4.sin_port;
                        
                        sa.sin_addr.S_un.S_un_b.s_b1 = ( (PUCHAR)&WinStationRemoteAddress_Info.ipv4.in_addr ) [0] ;   
                        sa.sin_addr.S_un.S_un_b.s_b2 = ( (PUCHAR)&WinStationRemoteAddress_Info.ipv4.in_addr ) [1] ;   
                        sa.sin_addr.S_un.S_un_b.s_b3 = ( (PUCHAR)&WinStationRemoteAddress_Info.ipv4.in_addr ) [2] ;   
                        sa.sin_addr.S_un.S_un_b.s_b4 = ( (PUCHAR)&WinStationRemoteAddress_Info.ipv4.in_addr ) [3] ;  
                    break;
                    }
                }
            }
        }
        
        // Either we will use the local host ip, or in TS case, the ip of the remote client.
        SecpSetIPAddress ( (PUCHAR ) &sa,  sizeof( sa ));

        Status = LsaLogonUser (
                     LsaHandle,
                     &OriginName,
                     LogonType,
                     AuthenticationPackage,
                     AuthInfo,
                     AuthInfoSize,
                     TokenGroups,
                     &SourceContext,
                     pProfileBuffer,
                     pProfileBufferLength,
                     LogonId,
                     LogonToken,
                     Quotas,
                     pSubStatus
                     );

        if (NT_SUCCESS(Status))
        {
            ASSERT(*pProfileBuffer != NULL);
            if (*pProfileBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                CloseHandle(*LogonToken);
            }
        }
    }

#if 0
    // If this failed it may be because we are doing a UPN logon. Try again
    // with no domain
    if (!NT_SUCCESS(Status))
    {
        *pfUpnLogon = TRUE;

        PKERB_INTERACTIVE_LOGON pinfo = (PKERB_INTERACTIVE_LOGON) AuthInfo;

        // Null out domain string
        pinfo->LogonDomainName.Length = 0;
        pinfo->LogonDomainName.Buffer[0] = 0;

        Status = LsaLogonUser (
                     LsaHandle,
                     &OriginName,
                     LogonType,
                     AuthenticationPackage,
                     AuthInfo,
                     AuthInfoSize,
                     TokenGroups,
                     &SourceContext,
                     pProfileBuffer,
                     pProfileBufferLength,
                     LogonId,
                     LogonToken,
                     Quotas,
                     pSubStatus
                     );
    }
#endif

    //
    // If this was a successful login perform tasks for optimized logon
    // maintenance.
    //

    if (NT_SUCCESS(Status)) {

        UserProfile = *pProfileBuffer;

        //
        // Get user's SID in string form.
        //

        UserSidString = GcGetSidString(*LogonToken);

        if (UserSidString) {

            //
            // Save whether we did an optimized logon or the reason why
            // we did not.
            //

            GcSetOptimizedLogonStatus(UserSidString, *OptimizedLogonStatus);

            //
            // Check if this was a cached logon.
            //

            if (!(UserProfile->UserFlags & LOGON_CACHED_ACCOUNT))
            {
                FgPolicyRefreshInfo UserPolicyRefreshInfo;

                //
                // If this is not a cached logon because user's profile
                // does not allow it, we have to force group policy to 
                // apply synchronously.
                //

                ErrorCode = GcCheckIfProfileAllowsCachedLogon(&UserProfile->HomeDirectory,
                                                              &UserProfile->ProfilePath,    
                                                              UserSidString,
                                                              &LogonCacheable);

                if (ErrorCode != ERROR_SUCCESS || !LogonCacheable) {

                    //
                    // If policy is already sync, leave it alone.
                    //

                    GetNextFgPolicyRefreshInfo( UserSidString, &UserPolicyRefreshInfo );
                    if ( UserPolicyRefreshInfo.mode == GP_ModeAsyncForeground )
                    {
                        UserPolicyRefreshInfo.reason = GP_ReasonNonCachedCredentials;
                        UserPolicyRefreshInfo.mode = GP_ModeSyncForeground;
                        SetNextFgPolicyRefreshInfo( UserSidString, UserPolicyRefreshInfo );
                    }
                }

                //
                // Determine if we should allow next logon to be optimized.
                // We may have disallowed optimizing next logon via this 
                // mechanism because
                // - Our background logon attempt failed e.g. password has
                //   changed, account has been disabled etc.
                // - We are entering the password expiry warning period.
                //   When we do an optimized logon warning dialogs don't show
                //   because cached logon invents password expiry time field.
                //
                // We will allow optimized logon again if this was a non 
                // cached logon and user got authenticated by the DC, unless
                // we are entering the password expiry warning period.
                //

                if (LogonType == Interactive) {

                    //
                    // Are we entering password expiry warning period?
                    //

                    GetSystemTimeAsFileTime((FILETIME*) &CurrentTime);

                    DaysToCheck = GetPasswordExpiryWarningPeriod();

                    if (GetDaysToExpiry(&CurrentTime,
                                        &UserProfile->PasswordMustChange,
                                        &DaysToExpiry)) {

                        if (DaysToExpiry > DaysToCheck) {                

                            //
                            // We passed this check too. We can allow optimized
                            // logon next time. Note that, even if we allow it,
                            // policy, profile, logon scripts etc. might still
                            // disallow it!
                            //

                            GcSetNextLogonCacheable(UserSidString, TRUE);
                        }
                    }
                }
            }

            GcDeleteSidString(UserSidString);
        }
    }

cleanup:

    if (AuthInfo) {
            // Zeroize this for security reason, even though the password is run encoded
        ZeroMemory(AuthInfo, AuthInfoSize);
        LocalFree(AuthInfo);
    }

    if (TokenGroups) {
        Free(TokenGroups);
    }

    return(Status);
}

/***************************************************************************\
* EnablePrivilege
*
* Enables/disables the specified well-known privilege in the current thread
* token if there is one, otherwise the current process token.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
BOOL
EnablePrivilege(
    ULONG Privilege,
    BOOL Enable
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    //
    // Try the thread token first
    //

    Status = RtlAdjustPrivilege(Privilege,
                                (BOOLEAN)Enable,
                                TRUE,
                                &WasEnabled);

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege(Privilege,
                                    (BOOLEAN)Enable,
                                    FALSE,
                                    &WasEnabled);
    }


    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to %ws privilege : 0x%lx, status = 0x%lx", Enable ? TEXT("enable") : TEXT("disable"), Privilege, Status));
        return(FALSE);
    }

    return(TRUE);
}



/***************************************************************************\
* TestTokenForAdmin
*
* Returns TRUE if the token passed represents an admin user, otherwise FALSE
*
* The token handle passed must have TOKEN_QUERY access.
*
* History:
* 05-06-92 Davidc       Created
\***************************************************************************/
BOOL
TestTokenForAdmin(
    HANDLE Token
    )
{
    BOOL FoundAdmin ;
    TOKEN_TYPE Type ;
    NTSTATUS Status ;
    ULONG Actual ;
    HANDLE ImpToken ;

    Status = NtQueryInformationToken( Token,
                                      TokenType,
                                      (PVOID) &Type,
                                      sizeof( Type ),
                                      &Actual );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( Type == TokenPrimary )
    {
        //
        // Need an impersonation token for this:
        //

        if ( DuplicateTokenEx( Token,
                               TOKEN_IMPERSONATE | TOKEN_READ,
                               NULL,
                               SecurityImpersonation,
                               TokenImpersonation,
                               &ImpToken ) )
        {
            if ( !CheckTokenMembership( ImpToken, gAdminSid, &FoundAdmin ) )
            {
                FoundAdmin = FALSE ;
            }

            CloseHandle( ImpToken );
        }
        else
        {
            FoundAdmin = FALSE ;
        }


    }
    else
    {
        if ( !CheckTokenMembership( Token, gAdminSid, &FoundAdmin ) )
        {
            FoundAdmin = FALSE ;
        }

    }

    return FoundAdmin ;
}


/***************************************************************************\
* TestUserForAdmin
*
* Returns TRUE if the named user is an admin. This is done by attempting to
* log the user on and examining their token.
*
* NOTE: The password will be erased upon return to prevent it from being
*       visually identifiable in a pagefile.
*
* History:
* 03-16-92 Davidc       Created
\***************************************************************************/
BOOL
TestUserForAdmin(
    PGLOBALS pGlobals,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString
    )
{
    NTSTATUS    Status, SubStatus, IgnoreStatus;
    UNICODE_STRING      UserNameString;
    UNICODE_STRING      DomainString;
    PVOID       ProfileBuffer;
    ULONG       ProfileBufferLength;
    QUOTA_LIMITS Quotas;
    HANDLE      Token;
    BOOL        UserIsAdmin;
    LUID        LogonId;
    PVOID       AuthInfo ;
    ULONG       AuthInfoSize ;

    RtlInitUnicodeString(&UserNameString, UserName);
    RtlInitUnicodeString(&DomainString, Domain);

    //
    // Temporarily log this new subject on and see if their groups
    // contain the appropriate admin group
    //

    AuthInfo = FormatPasswordCredentials(
                    &UserNameString,
                    &DomainString,
                    PasswordString,
                    FALSE,                      // no unlock
                    NULL,                       // no logon id
                    &AuthInfoSize );

    if ( !AuthInfo )
    {
        return FALSE ;
    }

    Status = WinLogonUser(
                pGlobals->LsaHandle,
                pGlobals->AuthenticationPackage,
                Interactive,
                AuthInfo,
                AuthInfoSize,
                pGlobals->LogonSid,  // any sid will do
                &LogonId,
                &Token,
                &Quotas,
                &ProfileBuffer,
                &ProfileBufferLength,
                &SubStatus,
                &pGlobals->OptimizedLogonStatus);

    RtlEraseUnicodeString( PasswordString );

    //
    // If we couldn't log them on, they're not an admin
    //

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // Free up the profile buffer
    //

    IgnoreStatus = LsaFreeReturnBuffer(ProfileBuffer);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    //
    // See if the token represents an admin user
    //

    UserIsAdmin = TestTokenForAdmin(Token);

    //
    // We're finished with the token
    //

    IgnoreStatus = NtClose(Token);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(UserIsAdmin);
}

BOOL
UnlockLogon(
    PGLOBALS pGlobals,
    IN BOOL SmartCardUnlock,
    IN PWCHAR UserName,
    IN PWCHAR Domain,
    IN PUNICODE_STRING PasswordString,
    OUT PNTSTATUS pStatus,
    OUT PBOOL IsAdmin,
    OUT PBOOL IsLoggedOnUser,
    OUT PVOID *pProfileBuffer,
    OUT ULONG *pProfileBufferLength
    )
{
    NTSTATUS    Status, SubStatus, IgnoreStatus;
    UNICODE_STRING      UserNameString;
    UNICODE_STRING      DomainString;
    QUOTA_LIMITS Quotas;
    HANDLE      Token;
    HANDLE      ImpToken ;
    LUID        LogonId;
    PVOID       AuthInfo ;
    ULONG       AuthInfoSize ;
    ULONG       SidSize ;
    UCHAR       Buffer[ sizeof( TOKEN_USER ) + 8 + SID_MAX_SUB_AUTHORITIES * sizeof(DWORD) ];
    PTOKEN_USER User ;
    PUCHAR  SmartCardInfo ;
    PWLX_SC_NOTIFICATION_INFO ScInfo = NULL;
    PVOID       LocalProfileBuffer = NULL;
    ULONG       LocalProfileBufferLength;

#ifdef SMARTCARD_DOGFOOD
        DWORD StartTime, EndTime;
#endif
    //
    // Assume no admin
    //

    *IsAdmin = FALSE ;
    *IsLoggedOnUser = FALSE ;

    //
    // Bundle up the credentials for passing down to the auth pkgs:
    //

    if ( !SmartCardUnlock )
    {

        RtlInitUnicodeString(&UserNameString, UserName);
        RtlInitUnicodeString(&DomainString, Domain);

        AuthInfo = FormatPasswordCredentials(
                        &UserNameString,
                        &DomainString,
                        PasswordString,
                        TRUE,                   // unlock
                        &pGlobals->LogonId,
                        &AuthInfoSize );

    }
    else
    {
        if ( !pWlxFuncs->WlxGetOption( pGlobals->hGlobalWlx,
                                       WLX_OPTION_SMART_CARD_INFO,
                                       (PULONG_PTR) &ScInfo ) )
        {
            return FALSE ;
        }

        if ( ScInfo == NULL )
        {
            return FALSE ;
        }

        SmartCardInfo = ScBuildLogonInfo(
                            ScInfo->pszCard,
                            ScInfo->pszReader,
                            ScInfo->pszContainer,
                            ScInfo->pszCryptoProvider );

#ifndef SMARTCARD_DOGFOOD
        LocalFree(ScInfo);
#endif

        if ( SmartCardInfo == NULL )
        {
#ifdef SMARTCARD_DOGFOOD
            LocalFree(ScInfo);
#endif
            return FALSE ;
        }

        AuthInfo = FormatSmartCardCredentials(
                        PasswordString,
                        SmartCardInfo,
                        TRUE,                   // unlock
                        &pGlobals->LogonId,
                        &AuthInfoSize);

        LocalFree( SmartCardInfo );

    }

    //
    // Make sure that worked:
    //

    if ( !AuthInfo )
    {
#ifdef SMARTCARD_DOGFOOD
        if (ScInfo)
            LocalFree(ScInfo);
#endif
        return FALSE ;
    }

#ifdef SMARTCARD_DOGFOOD
        StartTime = GetTickCount();
#endif

    //
    // Initialize profile buffer
    //
    if ( !pProfileBuffer )
    {
        pProfileBuffer = &LocalProfileBuffer;
        pProfileBufferLength = &LocalProfileBufferLength;
    }

    SubStatus = 0;

    Status = WinLogonUser(
                pGlobals->LsaHandle,
                ( SmartCardUnlock ? pGlobals->SmartCardLogonPackage : pGlobals->PasswordLogonPackage ),
                Unlock,
                AuthInfo,
                AuthInfoSize,
                pGlobals->LogonSid,  // any sid will do
                &LogonId,
                &Token,
                &Quotas,
                pProfileBuffer,
                pProfileBufferLength,
                &SubStatus,
                &pGlobals->OptimizedLogonStatus);

     if (SmartCardUnlock) 
     {
        switch (SubStatus)
        {
            case STATUS_SMARTCARD_WRONG_PIN:
            case STATUS_SMARTCARD_CARD_BLOCKED:
            case STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED:
            case STATUS_SMARTCARD_NO_CARD:
            case STATUS_SMARTCARD_NO_KEY_CONTAINER:
            case STATUS_SMARTCARD_NO_CERTIFICATE:
            case STATUS_SMARTCARD_NO_KEYSET:
            case STATUS_SMARTCARD_IO_ERROR:
            case STATUS_SMARTCARD_CERT_EXPIRED:
            case STATUS_SMARTCARD_CERT_REVOKED:
            case STATUS_ISSUING_CA_UNTRUSTED:
            case STATUS_REVOCATION_OFFLINE_C:
            case STATUS_PKINIT_CLIENT_FAILURE:
                
                Status = SubStatus;
                break;
        }
     }

#ifdef SMARTCARD_DOGFOOD
    EndTime = GetTickCount();

    if (SmartCardUnlock) 
    {
        AuthMonitor(
                AuthOperUnlock,
                g_Console,
                &pGlobals->UserNameString,
                &pGlobals->DomainString,
                (ScInfo ? ScInfo->pszCard : NULL),
                (ScInfo ? ScInfo->pszReader : NULL),
                (PKERB_SMART_CARD_PROFILE) pGlobals->Profile,
                EndTime - StartTime,
                Status
                );
    }

    if (ScInfo)
        LocalFree(ScInfo);
#endif

    //
    // Do *NOT* erase the password string.
    //
    // RtlEraseUnicodeString( PasswordString );

    if ( !NT_SUCCESS( Status ) )
    {
        if ( Status == STATUS_ACCOUNT_RESTRICTION )
        {
            Status = SubStatus ;
        }
    }

    *pStatus = Status ;

    //
    // If we couldn't log them on, forget it.
    //

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // No error check - if we can't tell if the user is an admin, then
    // as far as we're concerned, he isn't.
    //

    *IsAdmin = TestTokenForAdmin( Token );

    //
    // Determine if this really is the logged on user:
    //

    User = (PTOKEN_USER) Buffer ;

    Status = NtQueryInformationToken(
                    Token,
                    TokenUser,
                    User,
                    sizeof( Buffer ),
                    &SidSize );

    if ( NT_SUCCESS( Status ) )
    {
        if ( pGlobals->UserProcessData.UserSid )
        {
            if ( DuplicateToken( Token,
                                 SecurityImpersonation,
                                 &ImpToken ) )
            {
                if ( !CheckTokenMembership(ImpToken,
                                           pGlobals->UserProcessData.UserSid,
                                           IsLoggedOnUser ) )
                {
                    *IsLoggedOnUser = FALSE ;
                }

                NtClose( ImpToken );
            }
            else 
            {
                if ( RtlEqualSid( User->User.Sid,
                                  pGlobals->UserProcessData.UserSid ) )
                {
                    *IsLoggedOnUser = TRUE ;
                }
                else 
                {
                    *IsLoggedOnUser = FALSE ;
                }
            }
        }
        else
        {
            *IsLoggedOnUser = FALSE ;
        }
    }

    //
    // If we're using our local buffer pointer, free up the profile buffer
    //
    if ( LocalProfileBuffer )
    {
        IgnoreStatus = LsaFreeReturnBuffer(LocalProfileBuffer);

        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // We're finished with the token
    //

    IgnoreStatus = NtClose(Token);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return( TRUE );
}


/***************************************************************************\
* FUNCTION: ImpersonateUser
*
* PURPOSE:  Impersonates the user by setting the users token
*           on the specified thread. If no thread is specified the token
*           is set on the current thread.
*
* RETURNS:  Handle to be used on call to StopImpersonating() or NULL on failure
*           If a non-null thread handle was passed in, the handle returned will
*           be the one passed in. (See note)
*
* NOTES:    Take care when passing in a thread handle and then calling
*           StopImpersonating() with the handle returned by this routine.
*           StopImpersonating() will close any thread handle passed to it -
*           even yours !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*
\***************************************************************************/

HANDLE
ImpersonateUser(
    PUSER_PROCESS_DATA UserProcessData,
    HANDLE      ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE  UserToken = UserProcessData->UserToken;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ImpersonationToken;
    BOOL ThreadHandleOpened = FALSE;

    if (ThreadHandle == NULL) {

        //
        // Get a handle to the current thread.
        // Once we have this handle, we can set the user's impersonation
        // token into the thread and remove it later even though we ARE
        // the user for the removal operation. This is because the handle
        // contains the access rights - the access is not re-evaluated
        // at token removal time.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),     // Source process
                                    NtCurrentThread(),      // Source handle
                                    NtCurrentProcess(),     // Target process
                                    &ThreadHandle,          // Target handle
                                    THREAD_SET_THREAD_TOKEN,// Access
                                    0L,                     // Attributes
                                    DUPLICATE_SAME_ATTRIBUTES
                                  );
        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "ImpersonateUser : Failed to duplicate thread handle, status = 0x%lx", Status));
            return(NULL);
        }

        ThreadHandleOpened = TRUE;
    }


    //
    // If the usertoken is NULL, there's nothing to do
    //

    if (UserToken != NULL) {

        //
        // UserToken is a primary token - create an impersonation token version
        // of it so we can set it on our thread
        //

        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            UserProcessData->NewThreadTokenSD);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( UserToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES |
                                        TOKEN_QUERY,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenImpersonation,
                                   &ImpersonationToken
                                 );
        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to duplicate users token to create impersonation thread, status = 0x%lx", Status));

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }



        //
        // Set the impersonation token on this thread so we 'are' the user
        //

        Status = NtSetInformationThread( ThreadHandle,
                                         ThreadImpersonationToken,
                                         (PVOID)&ImpersonationToken,
                                         sizeof(ImpersonationToken)
                                       );
        //
        // We're finished with our handle to the impersonation token
        //

        IgnoreStatus = NtClose(ImpersonationToken);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Check we set the token on our thread ok
        //

        if (!NT_SUCCESS(Status)) {

            DebugLog((DEB_ERROR, "Failed to set user impersonation token on winlogon thread, status = 0x%lx", Status));

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }
    }


    return(ThreadHandle);

}


/***************************************************************************\
* FUNCTION: StopImpersonating
*
* PURPOSE:  Stops impersonating the client by removing the token on the
*           current thread.
*
* PARAMETERS: ThreadHandle - handle returned by ImpersonateUser() call.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* NOTES: If a thread handle was passed in to ImpersonateUser() then the
*        handle returned was one and the same. If this is passed to
*        StopImpersonating() the handle will be closed. Take care !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*
\***************************************************************************/

BOOL
StopImpersonating(
    HANDLE  ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE ImpersonationToken;


    //
    // Remove the user's token from our thread so we are 'ourself' again
    //

    ImpersonationToken = NULL;

    Status = NtSetInformationThread( ThreadHandle,
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     sizeof(ImpersonationToken)
                                   );
    //
    // We're finished with the thread handle
    //

    IgnoreStatus = NtClose(ThreadHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to remove user impersonation token from winlogon thread, status = 0x%lx", Status));
    }

    return(NT_SUCCESS(Status));
}


/***************************************************************************\
* TestUserPrivilege
*
* Looks at the user token to determine if they have the specified privilege
*
* Returns TRUE if the user has the privilege, otherwise FALSE
*
* History:
* 04-21-92 Davidc       Created
\***************************************************************************/
BOOL
TestUserPrivilege(
    HANDLE UserToken,
    ULONG Privilege
    )
{
    NTSTATUS Status;
    NTSTATUS IgnoreStatus;
    BOOL TokenOpened;
    LUID LuidPrivilege;
    LUID TokenPrivilege;
    PTOKEN_PRIVILEGES Privileges;
    ULONG BytesRequired;
    ULONG i;
    BOOL Found;

    TokenOpened = FALSE;


    //
    // If the token is NULL, get a token for the current process since
    // this is the token that will be inherited by new processes.
    //

    if (UserToken == NULL) {

        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_QUERY,
                     &UserToken
                     );
        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "Can't open own process token for token_query access"));
            return(FALSE);
        }

        TokenOpened = TRUE;
    }


    //
    // Find out how much memory we need to allocate
    //

    Status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenPrivileges,           // TokenInformationClass
                 NULL,                      // TokenInformation
                 0,                         // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        if (!NT_SUCCESS(Status)) {
            DebugLog((DEB_ERROR, "Failed to query privileges from user token, status = 0x%lx", Status));
        }

        if (TokenOpened) {
            IgnoreStatus = NtClose(UserToken);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        return(FALSE);
    }


    //
    // Allocate space for the privilege array
    //

    Privileges = Alloc(BytesRequired);
    if (Privileges == NULL) {

        DebugLog((DEB_ERROR, "Failed to allocate memory for user privileges"));

        if (TokenOpened) {
            IgnoreStatus = NtClose(UserToken);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        return(FALSE);
    }


    //
    // Read in the user privileges
    //

    Status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenPrivileges,           // TokenInformationClass
                 Privileges,                // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    //
    // We're finished with the token handle
    //

    if (TokenOpened) {
        IgnoreStatus = NtClose(UserToken);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // See if we got the privileges
    //

    if (!NT_SUCCESS(Status)) {

        DebugLog((DEB_ERROR, "Failed to query privileges from user token"));

        Free(Privileges);

        return(FALSE);
    }



    //
    // See if the user has the privilege we're looking for.
    //

    LuidPrivilege = RtlConvertLongToLuid(Privilege);
    Found = FALSE;

    for (i=0; i<Privileges->PrivilegeCount; i++) {

        TokenPrivilege = *((LUID UNALIGNED *) &Privileges->Privileges[i].Luid);
        if (RtlEqualLuid(&TokenPrivilege, &LuidPrivilege))
        {
            Found = TRUE;
            break;
        }

    }


    Free(Privileges);

    return(Found);
}

/***************************************************************************\
* FUNCTION: HidePassword
*
* PURPOSE:  Run-encodes the password so that it is not very visually
*           distinguishable.  This is so that if it makes it to a
*           paging file, it wont be obvious.
*
*           if pGlobals->Seed is zero, then we will allocate and assign
*           a seed value.  Otherwise, the existing seed value is used.
*
*           WARNING - This routine will use the upper portion of the
*           password's length field to store the seed used in encoding
*           password.  Be careful you don't pass such a string to
*           a routine that looks at the length (like and RPC routine).
*
*
* RETURNS:  (None)
*
* NOTES:
*
* HISTORY:
*
*   04-27-93 JimK         Created.
*
\***************************************************************************/
VOID
HidePassword(
    PUCHAR Seed OPTIONAL,
    PUNICODE_STRING Password
    )
{
    PSECURITY_SEED_AND_LENGTH
        SeedAndLength;

    UCHAR
        LocalSeed;

    //
    // If no seed address passed, use our own local seed buffer
    //

    if (Seed == NULL) {
        Seed = &LocalSeed;
        LocalSeed = 0;
    }

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)&Password->Length;
    //ASSERT(*((LPWCH)SeedAndLength+Password->Length) == 0);
    ASSERT((SeedAndLength->Seed) == 0);

    RtlRunEncodeUnicodeString(
        Seed,
        Password
        );

    SeedAndLength->Seed = (*Seed);
    return;
}


/***************************************************************************\
* FUNCTION: RevealPassword
*
* PURPOSE:  Reveals a previously hidden password so that it
*           is plain text once again.
*
* RETURNS:  (None)
*
* NOTES:
*
* HISTORY:
*
*   04-27-93 JimK         Created.
*
\***************************************************************************/
VOID
RevealPassword(
    PUNICODE_STRING HiddenPassword
    )
{
    PSECURITY_SEED_AND_LENGTH
        SeedAndLength;

    UCHAR
        Seed;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)&HiddenPassword->Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    RtlRunDecodeUnicodeString(
           Seed,
           HiddenPassword
           );

    return;
}


/***************************************************************************\
* FUNCTION: ErasePassword
*
* PURPOSE:  zeros a password that is no longer needed.
*
* RETURNS:  (None)
*
* NOTES:
*
* HISTORY:
*
*   04-27-93 JimK         Created.
*
\***************************************************************************/
VOID
ErasePassword(
    PUNICODE_STRING Password
    )
{
    PSECURITY_SEED_AND_LENGTH
        SeedAndLength;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH)&Password->Length;
    SeedAndLength->Seed = 0;

    RtlEraseUnicodeString(
        Password
        );

    return;

}

VOID
HashPassword(
    PUNICODE_STRING Password,
    PUCHAR HashBuffer
    )
{
    MD5_CTX Context ;

    MD5Init( &Context );
    MD5Update( &Context, (PUCHAR) Password->Buffer, Password->Length );
    MD5Update( &Context, (PUCHAR) PASSWORD_HASH_STRING, sizeof( PASSWORD_HASH_STRING ) );
    MD5Final( &Context );

    RtlCopyMemory( HashBuffer, 
                   Context.digest, 
                   MD5DIGESTLEN );

}

/***************************************************************************\
* AttemptCachedLogon
*
* Checks to see if we are allowed to use cached credentials to log the user
* in fast, and does so.
*
* Parameters are the same list of parameters passed to LsaLogonUser.
*
* On successful return, LogonToken is a handle to the user's token,
* the profile buffer contains user profile information.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
NTSTATUS 
AttemptCachedLogon(
    HANDLE LsaHandle,
    PLSA_STRING OriginName,
    SECURITY_LOGON_TYPE LogonType,
    ULONG AuthenticationPackage,
    PVOID AuthenticationInformation,
    ULONG AuthenticationInformationLength,
    PTOKEN_GROUPS LocalGroups,
    PTOKEN_SOURCE SourceContext,
    PVOID *ProfileBuffer,
    PULONG ProfileBufferLength,
    PLUID LogonId,
    PHANDLE UserToken,
    PQUOTA_LIMITS Quotas,
    PNTSTATUS SubStatus,
    POPTIMIZED_LOGON_STATUS OptimizedLogonStatus
    )
{
    PWCHAR UserSidString;
    PMSV1_0_INTERACTIVE_PROFILE UserProfile;
    FgPolicyRefreshInfo UserPolicyRefreshInfo;
    PBACKGROUND_LOGON_PARAMETERS LogonParameters;
    OSVERSIONINFOEXW OsVersion;
    NTSTATUS Status;
    DWORD ErrorCode;
    BOOL Success;
    DWORD NextLogonCacheable;
    BOOLEAN UserLoggedOn;
    BOOL RunSynchronous;

    //
    // Initialize locals.
    //

    UserSidString = NULL;
    UserLoggedOn = FALSE;
    LogonParameters = NULL;
    *OptimizedLogonStatus = OLS_Unspecified;
    
    //
    // Verify parameters.
    //

    ASSERT(LogonType == CachedInteractive);

    //
    // Check if SKU allows cached interactive logons.
    //

    ZeroMemory(&OsVersion, sizeof(OsVersion));
    OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);
    Status = RtlGetVersion((POSVERSIONINFOW)&OsVersion);

    if (!NT_SUCCESS(Status)) {
        *OptimizedLogonStatus = OLS_UnsupportedSKU;
        goto cleanup;
    }

    if (OsVersion.wProductType != VER_NT_WORKSTATION) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_UnsupportedSKU;
        goto cleanup;
    }

    //
    // Attempt a cached logon.
    //

    Status = LsaLogonUser(LsaHandle,
                          OriginName,
                          LogonType,
                          AuthenticationPackage,
                          AuthenticationInformation,
                          AuthenticationInformationLength,
                          LocalGroups,
                          SourceContext,
                          ProfileBuffer,
                          ProfileBufferLength,
                          LogonId,
                          UserToken,
                          Quotas,
                          SubStatus);

    //
    // If cached logon was not successful we cannot continue.
    //

    if (!NT_SUCCESS(Status)) {
        *OptimizedLogonStatus = OLS_LogonFailed;
        goto cleanup;
    }

    UserLoggedOn = TRUE;

    ASSERT(*ProfileBuffer != NULL);
    if (*ProfileBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        *OptimizedLogonStatus = OLS_InsufficientResources;
        goto cleanup;
    }

    //
    // Get user's SID.
    //

    UserSidString = GcGetSidString(*UserToken);

    if (!UserSidString) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        *OptimizedLogonStatus = OLS_InsufficientResources;
        goto cleanup;
    }

    //
    // Check if in last logon of this user we determined we cannot do
    // a cached logon this time.
    //

    ErrorCode = GcGetNextLogonCacheable(UserSidString, &NextLogonCacheable);

    if (ErrorCode == ERROR_SUCCESS && !NextLogonCacheable) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_NextLogonNotCacheable;
        goto cleanup;
    }  

    //
    // Does policy allow cached logons on this machine for the user?
    //

    if (IsSyncForegroundPolicyRefresh(FALSE, *UserToken)) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_SyncMachinePolicy;
        goto cleanup;
    }

    //
    // Check if policy allows cached logon for this user.
    //

    ErrorCode = GetNextFgPolicyRefreshInfo(UserSidString, 
                                           &UserPolicyRefreshInfo);

    if (ErrorCode != ERROR_SUCCESS ||
        UserPolicyRefreshInfo.mode != GP_ModeAsyncForeground) {

        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_SyncUserPolicy;
        goto cleanup;
    }

    //
    // Check if user profile does not support default cached logons.
    // e.g if the user has a remote home directory or a roaming profile etc.
    //

    UserProfile = *ProfileBuffer;

    ErrorCode = GcCheckIfProfileAllowsCachedLogon(&UserProfile->HomeDirectory,
                                                  &UserProfile->ProfilePath,    
                                                  UserSidString,
                                                  &NextLogonCacheable);

    if (ErrorCode != ERROR_SUCCESS || !NextLogonCacheable) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_ProfileDisallows;
        goto cleanup;
    }

    //
    // Check if logon scripts are set to run synchronously.
    //

    RunSynchronous = GcCheckIfLogonScriptsRunSync(UserSidString);

    if (RunSynchronous) {
        Status = STATUS_NOT_SUPPORTED;
        *OptimizedLogonStatus = OLS_SyncLogonScripts;
        goto cleanup;
    }

    //
    // We are fine to run with cached logon. We still need to launch a work 
    // item to do a real interactive logon that will update the cache.
    //

    LogonParameters = Alloc(sizeof(*LogonParameters));

    if (!LogonParameters) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        *OptimizedLogonStatus = OLS_InsufficientResources;
        goto cleanup;
    }

    //
    // Initialize the structure so we know what to cleanup.
    //

    ZeroMemory(LogonParameters, sizeof(*LogonParameters));

    LogonParameters->LsaHandle = LsaHandle;

    //
    // Hand over the allocated UserSidString to background logon to cleanup.
    //

    LogonParameters->UserSidString = UserSidString;
    UserSidString = NULL;

    //
    // Hand over AuthenticationInfo structure to background logon. 
    // The password is already hidden.
    //

    LogonParameters->AuthenticationPackage = AuthenticationPackage;
    LogonParameters->AuthenticationInformationLength = AuthenticationInformationLength;

    //
    // Background logon will use the authentication information and free it.
    //

    LogonParameters->AuthenticationInformation = AuthenticationInformation;

    //
    // Queue a work item to perform the background logon to update the cache.
    // This background "logon" has nothing to do with the current user 
    // successfully logging on, logging off etc. So we don't have to monitor
    // those. All it does is to update the cache.
    //

    Success = QueueUserWorkItem(BackgroundLogonWorker,
                                LogonParameters,
                                WT_EXECUTELONGFUNCTION);

    if (!Success) {

        //
        // We want to back out from the cached logon if we could not queue
        // an actual logon to update the cache for the next time.
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;
        *OptimizedLogonStatus = OLS_InsufficientResources;
        goto cleanup;
    }

    //
    // We are done.
    //

    Status = STATUS_SUCCESS;
    *OptimizedLogonStatus = OLS_LogonIsCached;

  cleanup:

    if (!NT_SUCCESS(Status)) {
        //
        // If we failed after logging on the user using cached credentials,
        // we have to cleanup.
        //

        if (UserLoggedOn) {

            //
            // Close the user's token.
            //

            CloseHandle(*UserToken);
        
            //
            // Free the profile buffer.
            //

            if (*ProfileBuffer) {
                LsaFreeReturnBuffer(*ProfileBuffer);
            }
        }

        if (LogonParameters) {

            if (LogonParameters->UserSidString) {
                GcDeleteSidString(LogonParameters->UserSidString);
            }

            Free(LogonParameters);
        }
    }

    if (UserSidString) {                                    
        GcDeleteSidString(UserSidString);
    }

    return Status;  
}


/***************************************************************************\
* BackgroundLogonWorker
*
* If the actual interactive logon was performed using cached credentials
* because of policy, this workitem is queued to perform an actual network
* logon to update the cached information in the security packages.
*
* Authentication information to perform the logon is passed in as the 
* parameter and must be freed when the thread is done.
*
* History:
* 03-23-01 Cenke        Created
\***************************************************************************/
DWORD 
BackgroundLogonWorker(
    PBACKGROUND_LOGON_PARAMETERS LogonParameters
    )
{
    PMSV1_0_INTERACTIVE_PROFILE Profile;
    HANDLE UserToken;
    LSA_STRING OriginName;
    TOKEN_SOURCE SourceContext;
    QUOTA_LIMITS Quotas;
    PSECURITY_LOGON_SESSION_DATA LogonSessionData;
    LUID LogonId;
    NTSTATUS SubStatus;
    NTSTATUS Status;
    DWORD ErrorCode;
    ULONG ProfileBufferLength;
    ULONG NameBufferNumChars;
    static LONG LogonServicesStarted = 0;
    DWORD MaxWaitTime;
    BOOLEAN UserLoggedOn;
    BOOLEAN ImpersonatingUser;
    WCHAR NameBuffer[UNLEN + 1];
    DWORD DaysToCheck;
    DWORD DaysToExpiry;
    LARGE_INTEGER CurrentTime;

    //
    // Initialize locals.
    //

    Profile = NULL;
    RtlInitString(&OriginName, "Winlogon-Background");
    LogonSessionData = NULL;
    ZeroMemory(&SourceContext, sizeof(SourceContext));
    strncpy(SourceContext.SourceName, "GinaBkg", TOKEN_SOURCE_LENGTH);
    UserLoggedOn = FALSE;
    ImpersonatingUser = FALSE;
    NameBufferNumChars = sizeof(NameBuffer) / sizeof(NameBuffer[0]);

    //
    // Verify parameters.
    //

    ASSERT(LogonParameters);
    ASSERT(LogonParameters->AuthenticationInformation);
    ASSERT(LogonParameters->UserSidString);
    
    //
    // Make sure workstation and netlogon services have started.
    //

    if (!LogonServicesStarted) {

        MaxWaitTime = 120000; // 2 minutes.

        GcWaitForServiceToStart(SERVICE_WORKSTATION, MaxWaitTime);
        GcWaitForServiceToStart(SERVICE_NETLOGON, MaxWaitTime);

        LogonServicesStarted = 1;
    }

    //
    // Try to log the user in to initiate update of cached credentials.
    //

    Status = LsaLogonUser(LogonParameters->LsaHandle,
                          &OriginName,
                          Interactive,
                          LogonParameters->AuthenticationPackage,
                          LogonParameters->AuthenticationInformation,
                          LogonParameters->AuthenticationInformationLength,
                          NULL,
                          &SourceContext,
                          &(PVOID)Profile,
                          &ProfileBufferLength,
                          &LogonId,
                          &UserToken,
                          &Quotas,
                          &SubStatus);

    if (!NT_SUCCESS(Status)) {

        //
        // If the error is real we will force non-cached logon next time.
        //

        if (Status != STATUS_NO_LOGON_SERVERS) {
            GcSetNextLogonCacheable(LogonParameters->UserSidString, FALSE);
        }

        ErrorCode = LsaNtStatusToWinError(Status);
        goto cleanup;
    }

    UserLoggedOn = TRUE;

    ASSERT(Profile != NULL);
    if (Profile == NULL) {
        ErrorCode = ERROR_NO_SYSTEM_RESOURCES;  // Generic but enough in this case
        goto cleanup;
    }

    //
    // Did we actually end up doing a cached logon?
    //

    if (Profile->UserFlags & LOGON_CACHED_ACCOUNT) {

        //
        // We are done, just cleanup.
        //

        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // If we are entering the password expiry warning period, disable optimized
    // logon for next time so warning dialogs get shown. Otherwise for cached
    // logons password expiry date gets invented to be forever in future.
    //

    if (Profile) {

        GetSystemTimeAsFileTime((FILETIME*) &CurrentTime);

        DaysToCheck = GetPasswordExpiryWarningPeriod();

        if (GetDaysToExpiry(&CurrentTime,
                            &Profile->PasswordMustChange,
                            &DaysToExpiry)) {

            if (DaysToCheck >= DaysToExpiry) {                
                GcSetNextLogonCacheable(LogonParameters->UserSidString, FALSE);
            }
        }
    }

    //
    // Make a GetUserName call to update the user name cache. Ignore errors.
    //

    if (!ImpersonateLoggedOnUser(UserToken)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ImpersonatingUser = TRUE;

    GetUserNameEx(NameSamCompatible, NameBuffer, &NameBufferNumChars);

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

  cleanup:

    //
    // Stop impersonation.
    //

    if (ImpersonatingUser) {
        RevertToSelf();
    }

    //
    // Cleanup passed in LogonParameters.
    //

            // Zeroize this for security reason, even though the password is run encoded
    ZeroMemory(LogonParameters->AuthenticationInformation, LogonParameters->AuthenticationInformationLength);
    LocalFree(LogonParameters->AuthenticationInformation);
    Free(LogonParameters->UserSidString);
    Free(LogonParameters);

    //
    // If the user logged on, cleanup.
    //

    if (UserLoggedOn) {
        CloseHandle(UserToken);
        if (Profile) {
            LsaFreeReturnBuffer(Profile);
        }
    }

    if (LogonSessionData) {
        LsaFreeReturnBuffer(LogonSessionData);
    }

    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\msgina\winutil.h ===
/****************************** Module Header ******************************\
* Module Name: winutil.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Define windows utility functions
*
* History:
* 12-09-91 Davidc       Created.
\***************************************************************************/


//
// Exported function prototypes
//

HWND
CreateAniOnControl(
    HWND        hDlg,
    DWORD       ControlId,
    DWORD       AniId);

VOID
SetupSystemMenu(
    HWND    hwnd
    );


VOID
CentreWindow(
    HWND    hwnd
    );

BOOL
SetPasswordFocus(
    HWND    hDlg
    );

VOID
SetupCursor(
    BOOL    fWait
    );

BOOL
FormatTime(
   IN PTIME Time,
   OUT PWCHAR Buffer,
   IN ULONG BufferLength,
   IN USHORT Flags
   );

//
// Define flags used by FormatTime routine
//
#define FT_TIME 1
#define FT_DATE 2
#define FT_LTR 4
#define FT_RTL 8

BOOL
DuplicateUnicodeString(
    PUNICODE_STRING OutString,
    PUNICODE_STRING InString
    );

LPTSTR
UnicodeStringToString(
    PUNICODE_STRING UnicodeString
    );

BOOL
StringToUnicodeString(
    PUNICODE_STRING UnicodeString,
    LPTSTR String
    );

BOOL
OpenIniFileUserMapping(
    PGLOBALS pGlobals
    );

VOID
CloseIniFileUserMapping(
    PGLOBALS pGlobals
    );

LPTSTR
AllocAndGetDlgItemText(
    HWND hDlg,
    int  iItem
    );

BOOL
ReadWinlogonBoolValue (
    LPTSTR lpValueName,
    BOOL bDefault);

BOOL
HandleComboBoxOK(
    HWND    hDlg,
    int     ComboBoxId
    );

LPTSTR
AllocAndGetPrivateProfileString(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    LPCTSTR lpDefault,
    LPCTSTR lpFileName
    );

#define AllocAndGetProfileString(App, Key, Def) \
            AllocAndGetPrivateProfileString(App, Key, Def, NULL)


BOOL
WritePrivateProfileInt(
    LPCTSTR lpAppName,
    LPCTSTR lpKeyName,
    UINT Value,
    LPCTSTR lpFileName
    );

#define WriteProfileInt(App, Key, Value) \
            WritePrivateProfileInt(App, Key, Value, NULL)


LPTSTR
AllocAndExpandEnvironmentStrings(
    LPCTSTR lpszSrc
    );

LPTSTR
AllocAndRegEnumKey(
    HKEY hKey,
    DWORD iSubKey
    );

LPTSTR
AllocAndRegQueryValueEx(
    HKEY hKey,
    LPTSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType
    );

LPWSTR
EncodeMultiSzW(
    IN LPWSTR MultiSz
    );


//
// Memory macros
//

#define Alloc(c)        ((PVOID)LocalAlloc(LPTR, c))
#define ReAlloc(p, c)   ((PVOID)LocalReAlloc(p, c, LPTR | LMEM_MOVEABLE))
#define Free(p)         ((VOID)LocalFree(p))


//
// Define a winlogon debug print routine
//

#define WLPrint(s)  KdPrint(("WINLOGON: ")); \
                    KdPrint(s);            \
                    KdPrint(("\n"));

INT_PTR TimeoutMessageBox(
    HWND hwnd,
    PGLOBALS pGlobals,
    UINT IdText,
    UINT IdCaption,
    UINT wType,
    TIMEOUT Timeout);

INT_PTR
DisplayForceLogoffWarning(
    HWND hwnd,
    PGLOBALS pGlobals,
    UINT wType,
    TIMEOUT Timeout
    );

INT_PTR TimeoutMessageBoxlpstr(
    HWND hwnd,
    PGLOBALS pGlobals,
    LPTSTR Text,
    LPTSTR Caption,
    UINT wType,
    TIMEOUT Timeout);

#define TIMEOUT_VALUE_MASK  (0x0fffffff)
#define TIMEOUT_NOTIFY_MASK (0x10000000)

#define TIMEOUT_VALUE(t)    (t & TIMEOUT_VALUE_MASK)
#define TIMEOUT_NOTIFY(t)   (t & TIMEOUT_NOTIFY_MASK)

#define TIMEOUT_SS_NOTIFY   (TIMEOUT_NOTIFY_MASK)
#define TIMEOUT_CURRENT     (TIMEOUT_VALUE_MASK)    // Use existing timeout
#define TIMEOUT_NONE        (0)                     // Disable input timeout


PWSTR
DupString(PWSTR pszString);

PWSTR
DupUnicodeString(PUNICODE_STRING pString);

// Utility function used by both logon and unlock code to enable or
// disable the domain combo box based on whether a UPN user name is
// typed into the username edit box
void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain);

BOOL ForceNoDomainUI();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\defaultgpofix\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dcgpofix.rc
//
#define IDS_BANNER1                     1
#define IDS_BANNER2                     2
#define IDS_NOTADMIN                    3
#define IDS_NOAD                        4
#define IDS_CONTINUE                    5
#define IDS_BADSYSVOL                   6
#define IDS_DSAPPSWARN                  7
#define IDS_DISPDDP                     9
#define IDS_DISPDDCP                    10
#define IDS_DISPBOTH                    11
#define IDS_DISPNONE                    12
#define IDS_TOOLFAILED                  13
#define IDS_UNKNOWNERR                  14
#define IDS_CREATEEFS                   15
#define IDS_DIRCREATE                   16
#define IDS_DIRDELETE                   17
#define IDS_INVALIDEFS                  18
#define IDS_DSDELETE                    19
#define IDS_DSATTRIB                    20
#define IDS_DSLINKDO                    21
#define IDS_DSLINKDDP                   22
#define IDS_DIRREAD                     23
#define IDS_DIRWRITE                    24
#define IDS_DDPSUCCESS                  25
#define IDS_DDCPSUCCESS                 26
#define IDS_WARNURA                     27
#define IDS_IGNSCHSWITCH                28
#define IDS_GENDSERR                    29
#define IDS_DSCREATE                    30
#define IDS_EFSACCESSDENIED             31
#define IDS_WRONGSCHEMA                 32
#define IDS_TARGETSWITCH                33
#define IDS_SYSVOLERR                   34
#define IDS_CHARYES                     35
#define IDS_RESTORE_FAIL                36

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\defaultgpofix\main.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <dsrole.h>
#include <scesetup.h>
#include <iads.h>
#include <adshlp.h>
#include <winldap.h>
#include <oaidl.h>
#include <Adshlp.h>
#include <adserr.h>
#include <Sddl.h>
#include <Aclapi.h>
#include <initguid.h>
#include <Gpedit.h>
#include <atlbase.h>
#include <Ntdsapi.h>
#include <secedit.h>
#include "resource.h"
#include <Lmshare.h>
#include <lm.h>
#include <oleauto.h>
#include <adsopenflags.h>
#include <Dsgetdc.h>
#include <sclgntfy.h>
#include <Wincrypt.h>
#include <strsafe.h>
#define  PCOMMON_IMPL
#include "pcommon.h"

#include <locale.h>
#include <winnlsp.h>


#if DBG
#define dbgprint wprintf
#else
#define dbgprint
#endif // DBG   

#define DIFF(d) ((ULONG)(d))

#define TARGET_ARG                L"/target:"
#define TARGET_ARG_LENGTH         (sizeof(TARGET_ARG) - sizeof(WCHAR))
#define TARGET_ARG_COUNT          (TARGET_ARG_LENGTH/sizeof(WCHAR))
#define TARGET_ARG_DOMAIN         L"domain"
#define TARGET_ARG_DC             L"dc"
#define TARGET_ARG_BOTH           L"both"
#define TARGET_ARG_IGNORE_SCHEMA  L"/ignoreschema"
#define STRING_SD                 L"D:P(A;CIOI;GRGX;;;AU)(A;CIOI;GRGX;;;SO)(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)(A;CIOI;GA;;;CO)(A;CIOI;GRGWGXSD;;;PA)"
#define DDP_USEREXT               L"[{3060E8D0-7020-11D2-842D-00C04FA372D4}{3060E8CE-7020-11D2-842D-00C04FA372D4}]"
#define DDP_MACHEXT               L"[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{53D6AB1B-2488-11D1-A28C-00C04FB94F17}][{827D319E-6EAC-11D2-A4EA-00C04F79F83A}{803E14A0-B4FB-11D0-A0D0-00A0C90F574B}][{B1BE8D72-6EAC-11D2-A4EA-00C04F79F83A}{53D6AB1B-2488-11D1-A28C-00C04FB94F17}]"
#define DDC_MACHEXT               L"[{827D319E-6EAC-11D2-A4EA-00C04F79F83A}{803E14A0-B4FB-11D0-A0D0-00A0C90F574B}]"
#define DDP_DS_SD                 L"O:DAG:DAD:P(A;CI;RPWPCCDCLCLOLORCWOWDSDDTSW;;;DA)(A;CI;RPWPCCDCLCLOLORCWOWDSDDTSW;;;EA)(A;CIIO;RPWPCCDCLCLOLORCWOWDSDDTSW;;;CO)(A;CI;RPWPCCDCLCLORCWOWDSDDTSW;;;SY)(A;CI;RPLCLORC;;;AU)(OA;CI;CR;edacfd8f-ffb3-11d1-b41d-00a0c968f939;;AU)(A;CI;LCRPLORC;;;ED)"
#define DDCP_DS_SD                L"O:DAG:DAD:P(A;CI;RPWPCCDCLCLOLORCWOWDSDDTSW;;;DA)(A;CI;RPWPCCDCLCLOLORCWOWDSDDTSW;;;EA)(A;CIIO;RPWPCCDCLCLOLORCWOWDSDDTSW;;;CO)(A;CI;RPWPCCDCLCLORCWOWDSDDTSW;;;SY)(A;CI;RPLCLORC;;;AU)(OA;CI;CR;edacfd8f-ffb3-11d1-b41d-00a0c968f939;;AU)(A;CI;LCRPLORC;;;ED)"
#define SCHEMA_VERSION            30
#define MAX_EFS_KEY               255
#define MAX_VERSION_LENGTH        10
#define FILE_GPTINI               L"\\gpt.ini"
#define FILE_GPTTMPLINF           L"\\MACHINE\\Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf"

// Default Domain Policy need not be localized and can be hard-coded

#define DDP                       L"Default Domain Policy"
#define DEFAULT_DC_POLICY_NAME    L"Default Domain Controllers Policy"

extern "C" {
typedef HRESULT (STDAPICALLTYPE *DLLREGISTERSERVER)(void);
}

typedef enum policyTypeTag{
    DEFAULT_DOMAIN_POLICY, DEFAULT_DOMAIN_CONTROLLER_POLICY
} POLICYTYPE;

#define DOMAIN_GUID L"{31B2F340-016D-11D2-945F-00C04FB984F9}"
#define DC_GUID     L"{6AC1786C-016F-11D2-945F-00C04FB984F9}"
struct GLOBALS {
    WCHAR* Banner1;
    WCHAR* Banner2;
    WCHAR* ErrorNotAdmin;
    WCHAR* ErrorNoAD;
    WCHAR* ErrorContinue;
    WCHAR* ErrorBadSysVol;
    WCHAR* DispDDP;
    WCHAR* DispDDCP;
    WCHAR* DispBoth;
    WCHAR* ToolFailed;
    WCHAR* CreateEFS;
    WCHAR* DirCreate;
    WCHAR* DirDelete;
    WCHAR* InvalidEFS;
    WCHAR* DSDelete;
    WCHAR* DSAttrib;
    WCHAR* DSLinkDO;
    WCHAR* DSLinkDDP;
    WCHAR* DirRead;
    WCHAR* DirWrite;
    WCHAR* DDPSuccess;
    WCHAR* DDCPSuccess;
    WCHAR* WarnURA;
    WCHAR* IgnSchSwitch;
    WCHAR* GenDSErr;
    WCHAR* DSCreate;
    WCHAR* EFSAccessDenied;
    WCHAR* WrongSchema;
    WCHAR* TargetSwitch;
    WCHAR* CharYes;
    WCHAR* RestoreIgnoredGPOFail;

    WCHAR  SysVolPath[MAX_PATH];
    WCHAR  *DomainNamingContext;
    LONG   lDDCPVersionNo;
    LONG   lDDPVersionNo;
    
    LPGROUPPOLICYOBJECT   pGPO;
    SECURITY_DESCRIPTOR   *pDDPSecDesc;
    SECURITY_DESCRIPTOR   *pDDCPSecDesc;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC * pDomainInfo;

    BOOL  hasEFSInfo;
    BOOL  bIgnoreSchema;

    enum {
        RESTORE_DOMAIN = 1 ,
        RESTORE_DC = 2,
        RESTORE_BOTH = 3
    } RestoreType;

    HRESULT Init();
    GLOBALS();
    ~GLOBALS();
};

class CGPOFile
{ 
public:

    CGPOFile( WCHAR* wszGPOPath );

    ~CGPOFile();
    
    DWORD
    Backup();

    DWORD
    Restore();

    WCHAR*
    GetPath();

private:

    WCHAR* _wszFullPath;
    BYTE*  _pFileData;
    DWORD  _cbFileSize;
};

class CIgnoredGPO
{
public:

    CIgnoredGPO(
        WCHAR* wszGPOId,
        WCHAR* wszGPOName );

    ~CIgnoredGPO();
    
    DWORD
    Backup();

    DWORD
    Restore();

private:

    DWORD
    InitializeErrorText( 
        WCHAR* wszGPOName );    

    CGPOFile* _pGptIniFile;
    CGPOFile* _pGptTmplFile;
    WCHAR*    _wszError;
};

GLOBALS _global;
GLOBALS * global = &_global;

HRESULT 
IsDomainController (
    OUT BOOL *pDomainController
    );

HRESULT 
_LoadString (
    OUT WCHAR*& pwsz, 
    IN UINT nID
    );

void
PrintError(
    DWORD pwzError
    );

void
PrintError(
    WCHAR *lpStr1,
    WCHAR *lpStr2
    );

void
DisplayError(
    WCHAR *pwzError
    );

extern "C"    DWORD SetSysvolSecurityFromDSSecurity(
    LPTSTR lpFileSysPath,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
    );

BOOL 
FilePresent(WCHAR *szFileName)
{
    FILE *fPtr = NULL;
    
    fPtr = _wfopen(szFileName, L"r");
    if (NULL == fPtr)
    {
        return FALSE;
    }
    
    fclose(fPtr);
    return TRUE;
}


HRESULT GetDomainFQDN(LPWSTR    szDomainDNSName,
                      LPWSTR   *pszDomainFQDN)
/*++
  
  Routine Description:
  This function gets the domain FQDN given the dns domain name
  
  Arguments:
  [in]    szDomainDNSName         - DNS Domain Name
  [out]   pszDomainFQDN           - Domain FQDN
          Memory need to be freed for pszDomainFQDN using LocalFree. 
  
  Return Value:
  S_OK on success. Corresponding error codes on failures
  
  --*/
{
    HRESULT             hr;
    LPWSTR              pDomainNames[1];    
    LPWSTR              szDNSDomain = NULL;
    DWORD               dwErr;
    DS_NAME_RESULT     *pDSNameResult = NULL;
    LPWSTR              szDomainFQDN = NULL;
    ULONG               ulSize;

    //
    // ALlocate a buffer to add in a '/' at the end
    //            szDomainDNSName     + '/' + '\0';
    //

    ulSize = lstrlen(szDomainDNSName) + 1  +  1;
    szDNSDomain = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulSize);
    if (!szDNSDomain) 
    {
        hr = E_OUTOFMEMORY;
        goto end;
    }

    hr = StringCchPrintf(szDNSDomain, ulSize, L"%s/", szDomainDNSName);
    if (FAILED(hr)) 
    {
        goto end;
    }
    pDomainNames[0] = szDNSDomain;

    //
    // Call DsCrackNames to convert
    //

    dwErr = DsCrackNames(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY, 
                         DS_CANONICAL_NAME, DS_FQDN_1779_NAME,
                         1, pDomainNames, &pDSNameResult);

    if ( (dwErr != DS_NAME_NO_ERROR) || (!pDSNameResult) || (pDSNameResult->cItems != 1)) 
    {
        if ( (!pDSNameResult) || (pDSNameResult->cItems != 1) )  
        {
            //
            // We don't expect this to happen at all
            // 

            dbgprint(L"GetDomainDN: DsCrackNames failed with error 0x%x", E_UNEXPECTED);
            hr =  E_UNEXPECTED;            
            goto end;
        }       
        else 
        {
            dbgprint(L"GetDomainDN: DsCrackNames failed with error %d", dwErr);
            hr = HRESULT_FROM_WIN32(dwErr);
            goto end;
        }
    }

    if (pDSNameResult->rItems[0].status != DS_NAME_NO_ERROR) 
    {
        dwErr = pDSNameResult->rItems[0].status;
        dbgprint(L"GetDomainDN: DsCrackNames failed with error %d", dwErr);
        hr = HRESULT_FROM_WIN32(dwErr);
        goto end;
    }

    //
    // We have a valid FQDN. allocate and copy
    //        pDSNameResult->rItems[0].pName         + '\0'
    //

    ulSize = lstrlen(pDSNameResult->rItems[0].pName) + 1;
    szDomainFQDN = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ulSize);
    if (!szDomainFQDN) 
    {
        DsFreeNameResult(pDSNameResult);
        hr = E_OUTOFMEMORY;
        goto end;
    }

    hr = StringCchCopy(szDomainFQDN, ulSize, pDSNameResult->rItems[0].pName);
    if (FAILED(hr)) 
    {
        DsFreeNameResult(pDSNameResult);
        goto end;
    }

    dbgprint(L"GetDomainDN: Domain FQDN of domain %s = %s\n", szDomainDNSName, szDomainFQDN);
    DsFreeNameResult(pDSNameResult);
    *pszDomainFQDN = szDomainFQDN; 
    
    hr = S_OK;

 end:
    
    if (NULL != szDNSDomain)
    {
        LocalFree(szDNSDomain);
    }
    
    return hr;
}

 


HRESULT 
SetObjectSecurityDescriptor(
    LPWSTR              szObjectPath, 
    SE_OBJECT_TYPE      seObjectType,
    SECURITY_DESCRIPTOR *pSecurityDescriptor) 

/*++
 
Routine Description: 
    
    This ia thin wrapper around GetNamedSecurityInfo
    returns it (in self-relative format).  A new buffer is LocalAlloced for this
    security descriptor.  The caller is responsible for LocalFreeing it.

Arguments:

    [in]    szObjectPath            - Path to the object.
    [in]    seObjectType            - Type of the object 
    [in]    pSecurityDescriptor     - Receives a pointer to the security descriptor.

Return Value:

    S_OK on success.
    On failure the corresponding error code will be returned.
    Any API calls that are made in this function might fail and these error
    codes will be returned directly.
--*/

{

    HRESULT     hr = S_OK;
    DWORD       dwErr;
    PACL        pDacl = NULL;
    BOOL        bDaclPresent;
    BOOL        bDaclDefaulted;
    PACL        pSacl = NULL;
    BOOL        bSaclPresent;
    BOOL        bSaclDefaulted;
    PSID        pSidGroup;
    BOOL        bGroupDefaulted;
    PSID        pSidOwner;
    BOOL        bOwnerDefaulted;
 
    if (!GetSecurityDescriptorDacl(pSecurityDescriptor, &bDaclPresent, &pDacl, &bDaclDefaulted)) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError()); 
        dbgprint(L"GetSecurityDescriptorDacl failed with 0x%x.", hr);
        return hr;
    } 

    if (!GetSecurityDescriptorSacl(pSecurityDescriptor, &bSaclPresent, &pSacl, &bSaclDefaulted)) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbgprint(L"GetSecurityDescriptorSacl failed with 0x%x.", hr);
        return hr;
    } 

    if (!GetSecurityDescriptorGroup(pSecurityDescriptor, &pSidGroup, &bGroupDefaulted)) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbgprint( L"GetSecurityDescriptorGroup failed with 0x%x.", hr);
        return hr;

    }

    if (!GetSecurityDescriptorOwner(pSecurityDescriptor, &pSidOwner, &bOwnerDefaulted)) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError()); 
        dbgprint(L"GetSecurityDescriptorOwner failed with 0x%x.", hr);
        return hr;
    }
    
    dwErr = SetNamedSecurityInfo(szObjectPath, 
                                 seObjectType, 
                                 DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION, 
                                 pSidOwner,
                                 pSidGroup,
                                 pDacl,
                                 pSacl
                                 );

    if (dwErr != ERROR_SUCCESS) 
        {
        hr = HRESULT_FROM_WIN32(dwErr);
        dbgprint(L"SetNamedSecurityInfo for %s failed with 0x%x.", szObjectPath, hr);
        return hr;
    }

    return S_OK;
}



HRESULT SetDSSecurityDescriptor ( 
    POLICYTYPE pType
    )
{
    WCHAR                 *szDsObjectName = NULL;
    ULONG                 uSDSize;
    BOOL                  bError;
    HRESULT               hr;
    SECURITY_DESCRIPTOR   *pSD;
    ULONG                 ulSize;

    ulSize = lstrlen(L"LDAP://CN=%s,CN=Policies,CN=System,%s") + lstrlen(DOMAIN_GUID) + lstrlen(global->DomainNamingContext) + 1 ;
    szDsObjectName = (WCHAR *) LocalAlloc( LPTR, sizeof(WCHAR) * ulSize);
    if( NULL == szDsObjectName )
    {
        return E_OUTOFMEMORY;
    }


    if (DEFAULT_DOMAIN_POLICY == pType) 
    {
        hr = StringCchPrintf( szDsObjectName, 
                              ulSize,
                              L"CN=%s,CN=Policies,CN=System,%s",
                              DOMAIN_GUID,
                              global->DomainNamingContext) ;
        if (FAILED(hr))
        {
            PrintError(hr);
            goto end;
        }

        // Convert the string to a security descriptor

        bError = ConvertStringSecurityDescriptorToSecurityDescriptor (DDP_DS_SD , 
                                                                      SDDL_REVISION_1,
                                                                      (PSECURITY_DESCRIPTOR *) &pSD,
                                                                      &uSDSize) ;
        global->pDDPSecDesc = pSD;
    }
    else
    {
        hr = StringCchPrintf( szDsObjectName,
                              ulSize,
                              L"CN=%s,CN=Policies,CN=System,%s",
                              DC_GUID,
                              global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        // Convert the string to a security descriptor

        bError = ConvertStringSecurityDescriptorToSecurityDescriptor (DDCP_DS_SD , 
                                                                      SDDL_REVISION_1,
                                                                      (PSECURITY_DESCRIPTOR *) &pSD,
                                                                      &uSDSize) ;
        global->pDDCPSecDesc = pSD;
    }

    if ( bError != TRUE)
    {        
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbgprint(L"ConvertStringSecurityDescriptorToSecurityDescriptor failed 0x%x", hr);
        PrintError(szDsObjectName,global->DSAttrib);
        goto end;           
    }

    // then set it to corresponding value

    hr = SetObjectSecurityDescriptor(szDsObjectName, 
                                     SE_DS_OBJECT,
                                     pSD);
    if (FAILED(hr)) 
    {
        dbgprint(L"SetDSSecurityDescriptor: SetObjectSecurityDescriptor failed with %x\n", hr);
        PrintError(szDsObjectName,global->DSAttrib);
        PrintError(hr);
        goto end;
    }

    hr = S_OK;

    end:
        if (NULL != szDsObjectName)
            {
            LocalFree(szDsObjectName);
        }

        return hr;
}



// 
// Gets the version number present in the file / DS
//

HRESULT GetVersionNumber ( 
   POLICYTYPE  polType)
{
    WCHAR           *szFileOrDSName = NULL;
    ULONG           uLength;
    WCHAR           szBuffer[MAX_VERSION_LENGTH];
    LONG            lVersionNo = 0;
    WORD            wUserVersionNo;
    WORD            wMachineVersionNo;
    DWORD           dwRetVal;
    DWORD           dwError;
    HRESULT         hr;
    CComPtr<IADs>   pADs;
    CComVariant     Var;

    CComBSTR        VersionNumber(L"VersionNumber");

    if ( ! VersionNumber )
    {
        return E_OUTOFMEMORY;
    }

    // 
    // Length of the allocated buffer is more than required, since it is the sum of the file path and ds path  
    //

    uLength = lstrlen(global->SysVolPath)+ lstrlen(global->pDomainInfo->DomainNameDns) + lstrlen(DOMAIN_GUID) + lstrlen(L"\\policies") + lstrlen(FILE_GPTINI) + 
        lstrlen( L"LDAP://CN=%s,CN=Policies,CN=System,%s") + lstrlen( DOMAIN_GUID) + lstrlen(global->DomainNamingContext) + 1; 
    szFileOrDSName = ( WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * uLength);
    if(NULL == szFileOrDSName) 
    {
        hr = E_OUTOFMEMORY;
        goto end;
    }

    hr = StringCchPrintf(szFileOrDSName, 
                         uLength,
                         L"%s\\%s\\Policies\\%s" FILE_GPTINI, 
                         global->SysVolPath, 
                         global->pDomainInfo->DomainNameDns, 
                         ( DEFAULT_DOMAIN_POLICY == polType ) ? DOMAIN_GUID : DC_GUID);
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    //
    // Get the version number from the sysvol directory
    //
     
    dwRetVal =  GetPrivateProfileString ( L"General", 
                                         L"Version", 
                                         L"-1", 
                                         szBuffer, 
                                         MAX_VERSION_LENGTH, 
                                         szFileOrDSName);
    if( dwRetVal > 0 )
    {
        // 
        // The casewhere szBuffer has a negetive number will be 
        // taken care of inside the for loop
        //

        for(int i = 0; szBuffer[i] != L'\0' && i < MAX_VERSION_LENGTH ; i++)
        {
            if (!isdigit(szBuffer[i]))
            {
                lVersionNo = 0;
                break;
            }

            lVersionNo *= 10;
            lVersionNo += szBuffer[i] - L'0';
        }
        if ( MAX_VERSION_LENGTH == i )
        {
            lVersionNo = 0;
        }
    }
    else
    {
        dwError = GetLastError();
        if ( ERROR_ACCESS_DENIED == dwError )
        {
            dbgprint(L"GetVersonNumber:GetPrivateProfileString failed with error %x\n, dwError");
            PrintError(szFileOrDSName, global->DirRead);
            hr = HRESULT_FROM_WIN32(dwError);
            goto end;
        }
        else if (dwError != ERROR_FILE_NOT_FOUND && dwError != ERROR_PATH_NOT_FOUND) 
        {
            // 
            // If dwError is either ERROR_FILE_NOT_FOUND or ERROR_PATH_NOT_FOUND, 
            // lVersionNo will have its initialized value
            //

            dbgprint(L"GetVersonNumber:GetPrivateProfileString failed with error %x\n, dwError");
            PrintError(dwError);
            hr = HRESULT_FROM_WIN32(dwError);
            goto end;
        }
    }

    wUserVersionNo = HIWORD(lVersionNo);
    wMachineVersionNo = LOWORD(lVersionNo);

    //
    // Get the version number from the DS
    //

    hr = StringCchPrintf( szFileOrDSName, 
                          uLength,
                          L"LDAP://CN=%s,CN=Policies,CN=System,%s", 
                          ( DEFAULT_DOMAIN_POLICY == polType ) ? DOMAIN_GUID : DC_GUID, 
        global->DomainNamingContext) ;
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    hr = AdminToolsOpenObject(szFileOrDSName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADs, (void**)&pADs);

    if ( SUCCEEDED(hr) )
    {
        hr = pADs->GetInfo();
        if ( SUCCEEDED(hr) )
        {
            Var.Clear();
            hr = pADs->Get(VersionNumber, &Var);
            if(SUCCEEDED(hr))
            {
                lVersionNo = Var.lVal;
            }
            else
            {
                lVersionNo = 0;
            }
        }
        else
        {
            dbgprint(L"AdminToolsOpenObject Failed with error %x\n", hr);
            PrintError(hr);
            goto end;
        }

    }
    else if ( hr != (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT)))
    {
        dbgprint(L"AdminToolsOpenObject failed %x on %s\n", hr, szFileOrDSName);
        PrintError(szFileOrDSName, global->GenDSErr);
        goto end;
    }
    else
    {
        lVersionNo = 0;
    }

    wUserVersionNo = max( wUserVersionNo, HIWORD(lVersionNo)) + 1;
    wMachineVersionNo = max( wMachineVersionNo, LOWORD(lVersionNo)) + 1;
    lVersionNo = (((LONG) wUserVersionNo) << 16) + wMachineVersionNo;

    if (DEFAULT_DOMAIN_POLICY == polType)  
    {
        global->lDDPVersionNo = lVersionNo;
    } 
    else
    { 
        global->lDDCPVersionNo = lVersionNo;
    }

    hr = S_OK;

    end:
        LocalFree(szFileOrDSName);

        return hr;
}


//  
// Gives a pointer to beginnening of the last the substring that
// does not contain a '/'
//

LPWSTR CheckSlash (LPWSTR lpDir)
{
    LPWSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if ( lpDir != lpEnd && *(lpEnd - 1) != L'\\') 
    {
        *lpEnd =  L'\\';
        lpEnd++;
        *lpEnd =  L'\0';
    }

    return lpEnd;
}


//********************************************************************************************
//
//  RegDelnodeExceptEFS()
//
//  Deletes a registry key and all it's subkeys / values except EFS Certificates
//
//      hKeyRoot    -   Root key
//      bEFSFound   -   Indicates whether EFS keys were found
//
//*********************************************************************************************
HRESULT
RegDelnodeExceptEFS(
    IN  HKEY    hKeyRoot,
    OUT BOOL &  bEFSFound
    )
{
    LONG    Status;
    HKEY    hSubKey;
    DWORD   MaxCchSubKey = 0;
    DWORD   EnumIndex;
    PWCHAR  pwszEnumKeyName;
    WCHAR   wszSubKey[72]; // enough to hold a path consisting of the following parts
    PWCHAR  apwszSubKeyNames[] = { L"Software", L"Policies", L"Microsoft", L"SystemCertificates", L"EFS" };

    bEFSFound = FALSE;

    wszSubKey[0] = 0;

    for (DWORD SubKeyIndex = 0; SubKeyIndex < sizeof(apwszSubKeyNames)/sizeof(apwszSubKeyNames[0]); SubKeyIndex++ )
    {
        hSubKey = 0;
        pwszEnumKeyName = 0;

        Status = RegOpenKeyEx( hKeyRoot, wszSubKey, 0, KEY_ALL_ACCESS, &hSubKey );

        if ( ERROR_SUCCESS == Status )
        {
            Status = RegQueryInfoKey( hSubKey, 0, 0, 0, 0, &MaxCchSubKey, 0, 0, 0, 0, 0, 0 );
            MaxCchSubKey++;
        }

        if ( ERROR_SUCCESS == Status )
        {
            pwszEnumKeyName = new WCHAR[MaxCchSubKey];
            if ( ! pwszEnumKeyName )
                Status = ERROR_OUTOFMEMORY;
        }

        for (EnumIndex = 0; ERROR_SUCCESS == Status;)
        {
            DWORD       CchSubKey;

            CchSubKey = MaxCchSubKey;
            Status = RegEnumKeyEx(
                        hSubKey, 
                        EnumIndex, 
                        pwszEnumKeyName, 
                        &CchSubKey, 
                        NULL,
                        NULL, 
                        NULL,
                        NULL );

            if ( ERROR_SUCCESS == Status )
            {
                if ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, apwszSubKeyNames[SubKeyIndex], -1, pwszEnumKeyName, -1) == CSTR_EQUAL )
                {
                    EnumIndex++;
                    continue;
                }
                
                Status = RegDelnode( hSubKey, pwszEnumKeyName );
            }
        }
        
        if ( hSubKey )
            RegCloseKey( hSubKey );
        if ( pwszEnumKeyName )
            delete [] pwszEnumKeyName;

        if ( ERROR_NO_MORE_ITEMS == Status )
            Status = ERROR_SUCCESS;

        if ( Status != ERROR_SUCCESS )
            break;

        StringCbCat( wszSubKey, sizeof(wszSubKey), apwszSubKeyNames[SubKeyIndex] );
        StringCbCat( wszSubKey, sizeof(wszSubKey), L"\\" );
    }

    if ( Status != ERROR_SUCCESS )
        return HRESULT_FROM_WIN32(Status);

    if ( EnumIndex != 0 )
    {
        bEFSFound = TRUE;
    }
    else
    {
        RegDelnode( hKeyRoot, L"Software" );
    }

    return S_OK;
}

HRESULT SetPolicySecurityInfo (LPTSTR lpFileSysPath)
{
    
    PACL pDacl = NULL;
    BOOL bAclPresent, bDefaulted;
    DWORD dwError = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG uSize;
    SECURITY_INFORMATION si =  (DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION);
   
    if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(STRING_SD,SDDL_REVISION_1, &pSD, &uSize) )
    {
        dwError = GetLastError();
        dbgprint(L"SetPolicySecurityInfo: ConvertStringSecurityDescriptorToSecurityDescriptor failed with %d", dwError);
        goto end;
    } 

    //
    // Get the DACL
    //
    
    if (!GetSecurityDescriptorDacl (pSD, &bAclPresent, &pDacl, &bDefaulted))
    {
        dwError = GetLastError();
        dbgprint(L"SetPolicySecurityInfo: GetSecurityDescriptorDacl failed with %d", dwError);
        goto end;
    }
    
    //
    // Set the access control information for the file system portion
    //
    
    dwError = SetNamedSecurityInfo(lpFileSysPath, SE_FILE_OBJECT, si, NULL, NULL, pDacl, NULL);
    
 end:
    
    if (pSD != NULL)
    {
        LocalFree(pSD);
    }
    
    if( dwError != ERROR_SUCCESS)
    {
        PrintError(dwError);
    }

    return HRESULT_FROM_WIN32(dwError);
}




HRESULT DeleteContainerFromDS(WCHAR *szContainerName, IADsContainer *pADsContainer)
{
    HRESULT                 hr;
    CComPtr<IEnumVARIANT>   pEnumVariant;    
    CComPtr<IUnknown>       pUnknown;
    VARIANT                 var;
    CComPtr<IDispatch>      pDisp;
    CComPtr<IADsDeleteOps>  pADsDeleteOps;
    ULONG                   uNoEleReturned;
    
    hr = pADsContainer->get__NewEnum( &pUnknown);
    if (FAILED(hr))
    {
        dbgprint(L"dbg: get_NewEnum failed with error %x on %s", hr, szContainerName);
        goto end;
    }
    
    hr = pUnknown->QueryInterface(IID_IEnumVARIANT, (void **) &pEnumVariant);
    if (FAILED(hr))
    {
        dbgprint(L"dbg: QueryInterface failed with error %x in function DeleteContainerFromDS", hr);
        goto end;
    }

    while(TRUE)
    {
        hr = pEnumVariant->Next( 1, &var, &uNoEleReturned);
        if ( FAILED(hr) )
        {
            dbgprint(L"dbg: Call to Next failed with error %x", hr);
            goto end;
        }
        else if (0 == uNoEleReturned)
        {
            break;
        }
        pDisp = V_DISPATCH( &var );
            
        hr = pDisp->QueryInterface(IID_IADsDeleteOps, (void **) &pADsDeleteOps);
        if (FAILED(hr))
        {
            dbgprint(L"dbg: Could not fetch pointer to interface IID_IADsDeleteOps in function DeleteContainerFromDS- error %x", hr);
            goto end;
        }
        
        hr = pADsDeleteOps->DeleteObject(0);
        if (FAILED(hr))
        {
            dbgprint(L"dbg: DeleteObject failed with error %x in function DeleteContainerFromDS", hr);
            goto end;
        }
    }

 end:

    return hr;
}


HRESULT ResetContainerFromDS ( 
    WCHAR *szContainerName, 
    IADs *pADsParent
    )
{
    HRESULT hr;
    CComPtr<IADsContainer> pADsContainer;
    
    hr = AdminToolsOpenObject(szContainerName, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADsContainer, (void**)&pADsContainer);
    
    if ( FAILED(hr) )
    {
        CComBSTR GroupPolicyContainerName(L"groupPolicyContainer");

        if ( ! GroupPolicyContainerName )
        {
            hr = E_OUTOFMEMORY;
            PrintError(hr);
            goto end;
        }

        if (E_ADS_BAD_PATHNAME == hr)
        {
            CComPtr<IDispatch> pDisp;
            CComPtr<IADs> pADs;
            
            hr = pADsParent->QueryInterface(IID_IADsContainer, (void **) &pADsContainer);
            if (FAILED(hr)) 
            {
                dbgprint(L"dbg: Create failed with %x on parent %s\n", hr, szContainerName);
                PrintError(szContainerName, global->DSCreate);
                goto end;
            }

            CComBSTR ContainerNameString(szContainerName);

            if ( ! ContainerNameString )
            {
                hr = E_OUTOFMEMORY;
                dbgprint(L"dbg: Create failed %x on %s\n", hr, szContainerName);
                PrintError(szContainerName, global->DSCreate);
                goto end;
            }

            hr = pADsContainer->Create(GroupPolicyContainerName, ContainerNameString, &pDisp);
            if (FAILED(hr)) 
            {
                dbgprint(L"dbg: Create failed %x on %s\n", hr, szContainerName);
                PrintError(szContainerName, global->DSCreate);
                goto end;
            }
            
            hr = pDisp->QueryInterface(IID_IADs, (void**)&pADs);
            if (FAILED(hr))
            {
                dbgprint(L"dbg: Query Interface failed %x for Creating IID_IADS\n", hr);
                PrintError(szContainerName, global->DSCreate);
                goto end;
            }
            
            hr = pADs->SetInfo();
            if (FAILED(hr))
            {
                dbgprint(L"SetInfo returned error %x on %s", hr, szContainerName);
                PrintError(szContainerName, global->DSCreate);
                goto end;
            }
            
        }
        else
        {
            dbgprint(L"AdminToolsOpenObject returned error %x on %s", hr, szContainerName);
            PrintError(szContainerName, global->GenDSErr);
            goto end;
        }
    }
    else
    {
        hr = DeleteContainerFromDS(szContainerName, pADsContainer);
        
        if( FAILED(hr))
        {
            dbgprint(L"DeleteContainerFromDS returned error %x on %s", hr, szContainerName);
            PrintError(szContainerName, global->DSDelete);
            goto end;
        }
    }
    
 end:
    
    return hr;
}


HRESULT 
IsDomainController(
    OUT BOOL *pDomainController
    ) 
{
    DWORD dwError;
    
    dwError = DsRoleGetPrimaryDomainInformation( NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *)&global->pDomainInfo );
    if (dwError != ERROR_SUCCESS) 
    {
        dbgprint(L"IsDomainController: DsRoleGetPrimaryDomainInformationfailed");
        PrintError(dwError);
        return( HRESULT_FROM_WIN32(dwError) );
    }
        
    if ((global->pDomainInfo->MachineRole == DsRole_RoleBackupDomainController ||
         global->pDomainInfo->MachineRole == DsRole_RolePrimaryDomainController) && 
        (global->pDomainInfo->Flags & DSROLE_PRIMARY_DS_RUNNING) != 0) 
    {
        *pDomainController = TRUE;
    } 
    else 
    {
        *pDomainController = FALSE;
    }
    
    return S_OK;
    
}   // IsDomainController


HRESULT
LookupMembership (
    WCHAR *Name,
    OUT BOOL *pAdmin
    )
{    
#define MAX_SID_LENGTH (1024*4)
    DWORD             dwError;
    BOOL              bError;
    PSID              pSid = NULL;
    
    // Initialize the out parameter

    *pAdmin = FALSE;

    // Get the sid of the domain admin / enterprise admin group.

    bError = ConvertStringSidToSid(Name, &pSid);
    if (FALSE == bError || NULL == pSid)
    {
        dwError = GetLastError();
        dbgprint(L"LookupMembership: ConvertStringSidToSid failed");
        goto end;
    }

    // check to see if that SID is in our current SD (aka user)
    
    bError = CheckTokenMembership(NULL, pSid, pAdmin);
    if (bError == FALSE) 
    {
        dwError = GetLastError();
        goto end;
    }

    dwError = ERROR_SUCCESS;

 end:

    if (pSid != NULL) 
    {
        LocalFree(pSid);
    }     
    
    if( dwError != ERROR_SUCCESS)
    {
        PrintError(dwError);
    }

    return HRESULT_FROM_WIN32(dwError) ;

} // LookupMembership()

HRESULT
IsAdmin (
    OUT BOOL *pAdmin
    ) 
{    
    HRESULT           hr;
    WCHAR             Name[8];
    
    // Initialize the out parameter
    *pAdmin = FALSE;
    
    hr = StringCbCopy(&Name[0], sizeof(Name), L"DA");
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    hr = LookupMembership(Name, pAdmin);
    if ( FAILED(hr) )
    {
        dbgprint(L"IsAdmin: CheckAccountName returned error %x", hr);
        PrintError(hr);
        goto end;
    }
    if(TRUE == *pAdmin)
    {
        goto end;
    }
    
    hr = StringCbCopy(&Name[0], sizeof(Name), L"EA");
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    hr = LookupMembership(Name, pAdmin);
    if ( FAILED(hr) )
    {
        // We are not printing error in this case, since this function
        // may not be supported in pre wistler servers

        dbgprint(L"IsAdmin: CheckAccountName returned error %x", hr);
        goto end;
    }

 end:
    
    return hr;
    
}   // IsAdmin


HRESULT 
GLOBALS::Init()
{
    HRESULT hr;

    hr = _LoadString(this->ErrorBadSysVol, IDS_BADSYSVOL);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
    }
    hr = _LoadString(this->Banner1, IDS_BANNER1);
    if (FAILED(hr)) 
        {         
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
    }
    hr = _LoadString(this->Banner2, IDS_BANNER2);
    if (FAILED(hr)) 
        {         
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
    }
    hr = _LoadString(this->ErrorContinue, IDS_CONTINUE);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
    }
    hr = _LoadString(this->ErrorNoAD, IDS_NOAD);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
    }
    hr = _LoadString(this->ErrorNotAdmin, IDS_NOTADMIN);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
    }
    hr = _LoadString(this->DispDDP, IDS_DISPDDP);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DispDDCP, IDS_DISPDDCP);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DispBoth, IDS_DISPBOTH);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->ToolFailed, IDS_TOOLFAILED);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->CreateEFS, IDS_CREATEEFS);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DirCreate, IDS_DIRCREATE);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DirDelete, IDS_DIRDELETE);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->InvalidEFS, IDS_INVALIDEFS);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DSDelete, IDS_DSDELETE);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DSAttrib, IDS_DSATTRIB);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DSLinkDO, IDS_DSLINKDO);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DSLinkDDP, IDS_DSLINKDDP);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DirRead, IDS_DIRREAD);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DirWrite, IDS_DIRWRITE);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DDPSuccess, IDS_DDPSUCCESS);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DDCPSuccess, IDS_DDCPSUCCESS);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->WarnURA, IDS_WARNURA);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->IgnSchSwitch, IDS_IGNSCHSWITCH);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->GenDSErr, IDS_GENDSERR);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->DSCreate, IDS_DSCREATE);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
        hr = _LoadString(this->EFSAccessDenied, IDS_EFSACCESSDENIED);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
    hr = _LoadString(this->WrongSchema, IDS_WRONGSCHEMA);
    if (FAILED(hr)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
    }
    hr = _LoadString(this->TargetSwitch, IDS_TARGETSWITCH);
    if (FAILED(hr)) 
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
    hr = _LoadString(this->CharYes, IDS_CHARYES);
    if (FAILED(hr)) 
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
    hr = _LoadString(this->RestoreIgnoredGPOFail, IDS_RESTORE_FAIL);
    if (FAILED(hr)) 
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }


    // all done
    hr = S_OK;
        
 end:
        
        if ( FAILED(hr) )
        {
            PrintError(hr);
        }
        
        return hr;
        
}   // GLOBALS::Init



GLOBALS::GLOBALS()
{
    EFSAccessDenied = NULL;        
    Banner1 = NULL;
    Banner2 = NULL;
    ErrorNotAdmin = NULL;
    ErrorNoAD = NULL;
    ErrorContinue = NULL;
    ErrorBadSysVol = NULL;
    DispDDP = NULL;
    DispDDCP = NULL;
    DispBoth = NULL;
    ToolFailed = NULL;
    CreateEFS = NULL;
    DirCreate = NULL;
    DirDelete = NULL;
    InvalidEFS = NULL;
    DSDelete = NULL;
    DSAttrib = NULL;
    DSLinkDO = NULL;
    DSLinkDDP = NULL;
    DirRead = NULL;
    DirWrite = NULL;
    DDPSuccess = NULL;
    DDCPSuccess = NULL;
    WarnURA = NULL;
    IgnSchSwitch = NULL;
    GenDSErr = NULL;
    DSCreate = NULL;
    CharYes = NULL;
    RestoreIgnoredGPOFail = NULL;

    pGPO = NULL;
    pDDPSecDesc = NULL;
    pDDCPSecDesc = NULL;
    DomainNamingContext = NULL;
    pDomainInfo = NULL;

    hasEFSInfo = FALSE;
    bIgnoreSchema = FALSE;

}




GLOBALS::~GLOBALS()
{
    if (this->pDomainInfo != NULL) 
    {
        DsRoleFreeMemory(this->pDomainInfo);
        this->pDomainInfo = NULL;
    }

    if ( NULL != DomainNamingContext )
    {
        LocalFree(DomainNamingContext);
    }

    if ( pDDPSecDesc != NULL ) 
    {
        LocalFree(pDDPSecDesc);
    }

    if ( pDDCPSecDesc != NULL ) 
    {
        LocalFree(pDDCPSecDesc);
    }

    delete [] EFSAccessDenied;
    delete [] Banner1;
    delete [] Banner2;
    delete [] ErrorNotAdmin;
    delete [] ErrorNoAD;
    delete [] ErrorContinue;
    delete [] ErrorBadSysVol;
    delete [] DispDDP;
    delete [] DispDDCP;
    delete [] DispBoth;
    delete [] ToolFailed;
    delete [] CreateEFS;
    delete [] DirCreate;
    delete [] DirDelete;
    delete [] InvalidEFS;
    delete [] DSDelete;
    delete [] DSAttrib;
    delete [] DSLinkDO;
    delete [] DSLinkDDP;        
    delete [] DirRead;
    delete [] DirWrite;
    delete [] DDPSuccess;
    delete [] DDCPSuccess;
    delete [] WarnURA;
    delete [] IgnSchSwitch;
    delete [] GenDSErr;
    delete [] DSCreate;
    delete [] WrongSchema;
    delete [] TargetSwitch;
    delete [] CharYes;
    delete [] RestoreIgnoredGPOFail;
}




HRESULT 
_LoadString(
    OUT WCHAR*& pwsz,
    IN UINT nID
    )
{
    HRESULT hr;

        hr = S_OK;
    
        pwsz = new WCHAR [ 2048 ];

        if ( ! pwsz )
        {
            return E_OUTOFMEMORY;
        }

    UINT nLen = ::LoadString(GetModuleHandle(NULL), nID, pwsz, 2048);
    
    if (nLen == 0) 
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
                delete [] pwsz;               
                pwsz = NULL;
    }

        return hr;
}




void
PrintError(
    DWORD dwError
    )
{
    BOOL bResult;
    ULONG dwSize = 0;
    WCHAR *lpBuffer;
    
    bResult = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                            NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), (PWSTR ) &lpBuffer, dwSize, NULL);
    if ( 0 == bResult )
    {
        return;
    }
    
    if ( lpBuffer != NULL )
    {
        DisplayError(lpBuffer);
        LocalFree(lpBuffer);
    }
    
    return;
    
} //PrintError


void
PrintError(
    WCHAR *lpStr1,
    WCHAR *lpStr2
    )    
{
    WCHAR    *lpTotStr = NULL;

    // 
    // Here, lpStr2 is a format string. So, no memory is needed for terminating 
    // since lpStr2 contains %s character.
    //

    ULONG    uSize = lstrlen(lpStr1) + lstrlen(lpStr2) ;

    lpTotStr = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * uSize);
    if (NULL == lpTotStr)
    {
        return;
    }
    
    //
    // Here lpStr2 contains one '%ls'...
    // Ignore error here, since error occured while printing error.
    //

    (void) StringCchPrintf(lpTotStr, uSize, lpStr2, lpStr1);
    DisplayError(lpTotStr);
    LocalFree(lpTotStr);
    
    return;
}



void
PrintError(
    WCHAR *lpMes,
    DWORD dwError
    )
{
    BOOL bResult;
    ULONG dwSize = 0;
    WCHAR *lpBuffer;
    
    bResult = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                            NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), (PWSTR ) &lpBuffer, dwSize, NULL);
    if ( 0 == bResult )
    {
        return;
    }

    if ( lpBuffer != NULL )
    {
        WCHAR *lpTotBuf;
        ULONG uSize;

        //
        //       lpMes         +    lpBuffer       + ' ' + ':' + '\0'
        //

        uSize = lstrlen(lpMes) + lstrlen(lpBuffer) +  1  +  1  +  1;
        lpTotBuf = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR)*uSize);
        if(NULL ==  lpTotBuf)
        {
            LocalFree(lpBuffer);
            return;
        }

        //
        // Ignore error here, since error occured while printing error.
        //

        (void) StringCchPrintf(lpTotBuf, uSize, L"%s :%s", lpMes, lpBuffer);
        DisplayError(lpTotBuf);
        LocalFree(lpBuffer);
        LocalFree(lpTotBuf);
    }

    return;

} //PrintError




void 
DisplayError (
    WCHAR *lpBuffer
    )
{
    BOOL                        bError;
    CONSOLE_SCREEN_BUFFER_INFO  Info;
    BOOL                        RestoreColor = FALSE;
    HANDLE                      ErrorOut = NULL;
    ULONG                       Length;
    
    ErrorOut = GetStdHandle(STD_ERROR_HANDLE);
    if (ErrorOut == INVALID_HANDLE_VALUE) 
    {
        ErrorOut = NULL;
    }
    
    if (ErrorOut != NULL) 
    {
        bError = GetConsoleScreenBufferInfo(ErrorOut, &Info);
        if (bError != FALSE) 
        {
            
            bError = SetConsoleTextAttribute( ErrorOut, FOREGROUND_RED | FOREGROUND_INTENSITY | 
                                          ((Info.wAttributes & BACKGROUND_RED) ? 0 : (Info.wAttributes & 0xf0) ) );
            if (bError != FALSE) 
            {
                RestoreColor = TRUE;
            }
        }
        
        bError = WriteConsole(ErrorOut, lpBuffer, lstrlen(lpBuffer), &Length, NULL);
        // ignore error
    }
    
    bError = MessageBeep(MB_ICONEXCLAMATION);
    // ignore error
    
    if (RestoreColor) 
    {
        bError = SetConsoleTextAttribute(ErrorOut, Info.wAttributes);
        // ignore error
    }
    
}   // DisplayError



HRESULT SaveEFSCerts()
{
    HRESULT                 hr;
    GUID                    g_guidRegExt = REGISTRY_EXTENSION_GUID;
    GUID                    clsidDomain;

    hr = CLSIDFromString(DOMAIN_GUID, 
                         &clsidDomain);
    if (FAILED(hr))
    {
        PrintError(hr);
        goto end;
    }

    hr = global->pGPO->Save(TRUE, TRUE, &g_guidRegExt, &clsidDomain);    
    if ( FAILED(hr) )
    {
        PrintError(DDP, global->CreateEFS);
        goto end;
    }

    //
    // The Save method automatically increases the version number value in the DS.
    // So, increment this value so that DS and sysvol will have the same version number

    global->lDDPVersionNo++;
    hr = S_OK;

 end:
     
    return hr;

} // SaveEFSCerts


HRESULT CreateEFSCerts(void)
{
    DWORD          dwError;
    HRESULT        hr;
    PUCHAR         pRecoveryPolicyBlob = NULL;
    ULONG          ulBlobSize;
    PCCERT_CONTEXT pCertContext = NULL;
    HKEY           hKeyPolicyRoot;
    HKEY           hKey;
    ULONG          dwDisposition;
    HCERTSTORE     hCertStore = NULL;
    WCHAR          *szAdsiPath = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;

    hr = CoCreateInstance(CLSID_GroupPolicyObject, 
                      NULL,
                      CLSCTX_SERVER, 
                      IID_IGroupPolicyObject,
                      (void **)&(global->pGPO));
    if ( FAILED(hr) )
    {
        PrintError(hr);
        goto end;
    }

    // 
    // Get the current DC name
    //

    dwError = DsGetDcName(NULL,
                          global->pDomainInfo->DomainNameDns,
                          NULL,
                          NULL,
                          DS_IS_DNS_NAME,
                          &pDcInfo);
    if(dwError != ERROR_SUCCESS)
    {
        PrintError(dwError);
        hr = HRESULT_FROM_WIN32(dwError);
        goto end;
    }

    if (*(pDcInfo->DomainControllerName) != L'\\' || *(pDcInfo->DomainControllerName + 1) != L'\\') 
    {
        hr = E_FAIL;
        goto end;
    }

    ULONG ulNoChars = sizeof(L"LDAP://%s/CN=%s,CN=Policies,CN=System,%s")/sizeof(WCHAR) + 
        lstrlen(pDcInfo->DomainControllerName+2) + 
        sizeof(DOMAIN_GUID)/sizeof(WCHAR) + 
        lstrlen(global->DomainNamingContext);

    szAdsiPath = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * ulNoChars);
    if (!szAdsiPath) 
    {
        hr = E_OUTOFMEMORY;
        PrintError(hr);
        goto end;
    }

    hr = StringCchPrintf(szAdsiPath,
                         ulNoChars,
                         L"LDAP://%s/CN=%s,CN=Policies,CN=System,%s", 
                         pDcInfo->DomainControllerName+2, 
                         DOMAIN_GUID, 
                         global->DomainNamingContext);

    ASSERT(SUCCEEDED(hr));

    //
    // Open the GPO Object
    //

    hr = global->pGPO->OpenDSGPO(szAdsiPath, 
                                 GPO_OPEN_LOAD_REGISTRY);
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    //
    // Get the registry key for the machine section
    //
    
    hr = global->pGPO->GetRegistryKey(GPO_SECTION_MACHINE, &hKeyPolicyRoot);
    if (FAILED(hr))
    {
        PrintError(DDP, global->InvalidEFS);
        dbgprint(L"dbg: CreateEFSCerts: GetRegistryKey failed with 0x%x\n", hr);
        goto end;  
    }

    dwError = GenerateDefaultEFSRecoveryPolicy (&pRecoveryPolicyBlob,
                                                &ulBlobSize,
                                                &pCertContext);
    if (dwError != ERROR_SUCCESS) 
    {
        dbgprint(L"dbg: CreateEFSCerts: GenerateDefaultEFSRecoveryPolicy failed with 0x%x\n", dwError);
        hr = HRESULT_FROM_WIN32(dwError);
        goto end;
    }
    
    //
    // Add the EFS cert to the cert store of this GPO 
    //

    CERT_SYSTEM_STORE_RELOCATE_PARA paraRelocate;

    paraRelocate.hKeyBase = hKeyPolicyRoot;
    paraRelocate.pwszSystemStore = L"EFS";

    hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                               0,
                               NULL,
                               CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY |
                               CERT_SYSTEM_STORE_RELOCATE_FLAG,
                               (void *)&paraRelocate
                               );

    if ( hCertStore ) 
    {
        BOOL bError;

        bError = CertAddCertificateContextToStore(
            hCertStore,
            pCertContext, // pCertContext,
            CERT_STORE_ADD_ALWAYS,
            NULL
            );
        if (!bError) 
        {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto end;
        }
    } 
    else 
    {
        hr = HRESULT_FROM_WIN32 (GetLastError());

    }

    dwError = RegCreateKeyEx (hKeyPolicyRoot,
                              CERT_EFSBLOB_REGPATH,
                              0,
                              TEXT("REG_SZ"),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKey,
                              NULL); 
    if (dwError != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32 (dwError);
        goto end;
    }

    dwError = RegSetValueEx (hKey,
                             CERT_EFSBLOB_VALUE_NAME,
                             0,
                             REG_BINARY,
                             (PBYTE) pRecoveryPolicyBlob,        // EfsBlob
                             ulBlobSize);
    hr = HRESULT_FROM_WIN32 (dwError);

    end:

        if (szAdsiPath) 
        {
            LocalFree(szAdsiPath);
        }

        if (hCertStore) 
        {
            CertCloseStore(hCertStore, 0);
        }

        if (pCertContext) 
        {
            CertFreeCertificateContext(pCertContext);
        }

        if (pRecoveryPolicyBlob) 
        {
            free (pRecoveryPolicyBlob);
        }

        return hr;
}

HRESULT
CreateFolder(
    PWSTR pFolderPath
    )
{
    DWORD dwError;

    dbgprint(L"dbg: CreateFolder(%s)\n", pFolderPath);
    
    if (CreateDirectory(pFolderPath, NULL) == FALSE) 
    {
        dwError = GetLastError();
        if (dwError != ERROR_ALREADY_EXISTS) 
        {
            PrintError(pFolderPath, global->DirCreate);
                
            return HRESULT_FROM_WIN32(dwError);
        }
    }
    
    return S_OK;
    
}   // CreateFolder



HRESULT
CreateSecurityTemplate (
    WCHAR *szSrcFile,
    WCHAR *szDestFile 
    )
{
    DWORD             dwError;
    DWORD             rc=ERROR_SUCCESS;
    PVOID             hProfile=NULL;
    PSCE_PROFILE_INFO pSceInfo=NULL;
    
    rc = SceOpenProfile(
        szSrcFile,
        SCE_INF_FORMAT,
        &hProfile
        );
    if (rc != SCESTATUS_SUCCESS) 
    {
        dwError = GetLastError();
        goto end;
    }

    //
    // load informatin from the template
    //

    rc = SceGetSecurityProfileInfo(
        hProfile,
        SCE_ENGINE_SCP,
        AREA_ALL,
        &pSceInfo,
        NULL
        );
    if (rc != SCESTATUS_SUCCESS) 
    {
        dwError = GetLastError();
        goto end;        
    }
    
    rc = SceWriteSecurityProfileInfo(
        szDestFile,
        AREA_ALL,
        pSceInfo,
        NULL
        );
    if (rc != SCESTATUS_SUCCESS) 
    {
        dwError = GetLastError();
        goto end;        
    }
    
    rc = SceFreeProfileMemory(pSceInfo);
    if (rc != SCESTATUS_SUCCESS) 
    {
        dwError = GetLastError();
        goto end;        
    }
    
    dwError = ERROR_SUCCESS;
     
 end:
    
    if ( NULL != hProfile )
    {
        SceCloseProfile(&hProfile);
    }
    
    if ( dwError != ERROR_SUCCESS )
    {
        PrintError(dwError);
    }

    return HRESULT_FROM_WIN32(dwError);
}



HRESULT 
CreateSysVolDomain(
    )
{
    DWORD     dwError;
    HRESULT   hr;
    WCHAR     *TempPath = NULL;
    HANDLE    PolFile = NULL;
    HMODULE   Module = NULL;
    ULONG     uTempPathLen = 0;
    BOOL      bError;

    //
    // The string that TempPath will be like 
    // <sysvolpath>\<domain name>\policies\<domain guid>\Microsoft\windows NT\\secedit
    // Memory is allocated for each directory name and for '\' if needed.
    //

    uTempPathLen = lstrlen(global->SysVolPath)  + 1 + lstrlen(global->pDomainInfo->DomainNameDns) + lstrlen(L"\\policies") 
    + 1+lstrlen(DOMAIN_GUID)+ lstrlen(L"\\MACHINE\\registry.pol") + lstrlen(L"\\Microsoft\\Windows NT\\secedit") 
    + lstrlen(L"\\USER\\Microsoft\\RemoteInstll\\oscfilter.ini") + 1;

    TempPath = (WCHAR*) LocalAlloc ( LPTR, uTempPathLen * sizeof(WCHAR));
    if(NULL == TempPath)
    {
        hr = E_OUTOFMEMORY;
        goto end;
    }

    hr = StringCchPrintf(TempPath, 
                         uTempPathLen, 
                         L"%s\\%s\\Policies", 
                         global->SysVolPath, 
                         global->pDomainInfo->DomainNameDns);
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = SetPolicySecurityInfo(TempPath);
    if ( FAILED(hr) )
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, DOMAIN_GUID); 
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    // Set security info for this directory

    dwError = SetSysvolSecurityFromDSSecurity(
        TempPath,
        DACL_SECURITY_INFORMATION |  GROUP_SECURITY_INFORMATION , 
        global->pDDPSecDesc);
    if (dwError != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwError);
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\MACHINE");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\Microsoft");
    if (FAILED(hr)) 
    {
        goto end;
    }
    
    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }
    
    hr = StringCchCat(TempPath, uTempPathLen, L"\\Windows NT");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\SecEdit");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchPrintf(TempPath, uTempPathLen, L"%s\\%s\\Policies\\%s\\USER", global->SysVolPath, global->pDomainInfo->DomainNameDns , DOMAIN_GUID);
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\Microsoft");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\RemoteInstall");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\oscfilter.ini");
    if (FAILED(hr))
    {
        goto end;
    }

    bError = WritePrivateProfileString(L"choice", L"custom", L"0", TempPath);
    if (bError == FALSE) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    bError = WritePrivateProfileString(L"choice", L"tools", L"0", TempPath);
    if (bError == FALSE) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    bError = WritePrivateProfileString(L"choice", L"restart", L"0", TempPath);
    if (bError == FALSE) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
    
    hr = S_OK;

    end:
        if (NULL != TempPath)
        {
            LocalFree (TempPath);
        }

        if (PolFile != NULL) 
        {
            CloseHandle(PolFile);
            PolFile = NULL;
        }
        if (Module != NULL) 
        {
            FreeLibrary(Module);
            Module = NULL;
        }
        if (FAILED(hr)) 
        {
            PrintError(hr);
        }

        return hr;

}   // CreateSysVolDomain

HRESULT 
CreateSysVolController(
    )
{
    DWORD dwError;
    HRESULT hr;
    WCHAR *TempPath = NULL;
    ULONG uTempPathLen = 0;

    //
    // The string that TempPath will be holding will be like
    // <sysvolpath>\domain name>\policies\<guid>\MACHINE\Microsoft\windows NT\SecEdit
    // Memory is allocated for each directory name and for '\' if needed.
    //

    uTempPathLen = lstrlen(global->SysVolPath) + 1 + lstrlen(global->pDomainInfo->DomainNameDns ) + lstrlen(L"\\Policies")
        + 1 + lstrlen(DC_GUID) + lstrlen (L"\\MACHINE\\Microsoft\\windows NT\\SecEdit") + lstrlen(L"\\USER") + 1;

    TempPath = (WCHAR *) LocalAlloc( LPTR, sizeof(WCHAR) * uTempPathLen);
    if ( NULL == TempPath )
    {
        hr = E_OUTOFMEMORY;
        goto end;
    }

    hr = StringCchPrintf(TempPath, 
                         uTempPathLen, 
                         L"%s\\%s\\Policies\\%s", 
                         global->SysVolPath, 
                         global->pDomainInfo->DomainNameDns , 
                         DC_GUID);
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    // Set security info for this directory

    dwError = SetSysvolSecurityFromDSSecurity(
        TempPath,
        DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION , 
        global->pDDCPSecDesc);
    if (dwError != ERROR_SUCCESS)
    {
        PrintError(dwError);
        hr = HRESULT_FROM_WIN32(dwError);
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\MACHINE");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\Microsoft");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\Windows NT");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchCat(TempPath, uTempPathLen, L"\\SecEdit");
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }

    hr = StringCchPrintf(TempPath, 
                         uTempPathLen, 
                         L"%s\\%s\\Policies\\%s\\USER", 
                         global->SysVolPath, 
                         global->pDomainInfo->DomainNameDns , 
                         DC_GUID);
    if (FAILED(hr)) 
    {
        goto end;
    }

    hr = CreateFolder(TempPath);
    if (FAILED(hr))
    {
        goto end;
    }


end:

    if ( TempPath != NULL)
    {
        LocalFree (TempPath);
    }

    return hr;

}   // CreateSysVolController

HRESULT 
BackupEfsCert(
    )
{
    HRESULT                 hr;
    WCHAR                   sz[1024];
    HKEY                    hKey = 0;
    DWORD                   dwError;
    FILETIME                fileTime;
    DWORD                   dwSubKeySize;
    ULONG                   uEnumIndex=0;
    WCHAR                   *TempPath = NULL;
    ULONG                   uLength;
    BOOL                    bError;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;

    hr = CoCreateInstance(CLSID_GroupPolicyObject, 
                          NULL,
                          CLSCTX_SERVER, 
                          IID_IGroupPolicyObject,
                          (void **)&(global->pGPO));
    if ( FAILED(hr) )
    {
        PrintError(hr);
        goto end;
    }

    // 
    // Get the current DC name
    //

    dwError = DsGetDcName(NULL,
                          global->pDomainInfo->DomainNameDns,
                          NULL,
                          NULL,
                          DS_IS_DNS_NAME,
                          &pDcInfo);
    if(dwError != ERROR_SUCCESS)
    {
        PrintError(dwError);
        hr = HRESULT_FROM_WIN32(dwError);
        goto end;
    }

    // 
    // Create the USER subdirectory under defaultdomainpolicy, if that don't exist
    // This will make sure that opendsgpo will not fail due to the obsence of USER directory
    // Here, the temppath will hold a string like \\machine\\registry.pol, or \\user\\registry.pol
    // Memory is allocated for each directory name and for '\' if needed.
    // More memory is assigned then actually needed
    //

    uLength = lstrlen(global->SysVolPath) + 1 + lstrlen(global->pDomainInfo->DomainNameDns) + lstrlen( L"\\Policies")  
        + 1 + lstrlen(DOMAIN_GUID) + lstrlen(L"\\USER") + lstrlen(L"\\MACHINE\\Registry.pol") + 1;

    TempPath = (WCHAR *) LocalAlloc( LPTR, sizeof(WCHAR) * uLength);
    if ( NULL == TempPath )
    {
        hr = E_OUTOFMEMORY;
        PrintError(hr);
        goto end;
    }

    hr = StringCchPrintf(TempPath, 
                         uLength, 
                         L"%s\\%s\\Policies\\%s\\USER", 
                         global->SysVolPath, 
                         global->pDomainInfo->DomainNameDns , 
                         DOMAIN_GUID);
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    bError = CreateDirectory(TempPath, NULL);
    if ( FALSE == bError )
    {
        dwError = GetLastError();
        if(ERROR_ALREADY_EXISTS == dwError )
        {
            hr = StringCchCat (TempPath, uLength, L"\\Registry.pol");
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }

            //
            // Delete so that corrupt registry.pol does not cause an error
            //

            (void) DeleteFile (TempPath);
        }
        else if (dwError != ERROR_PATH_NOT_FOUND) 
        {
            if ( ERROR_ACCESS_DENIED == dwError )
            {
                PrintError(TempPath, global->DirCreate);
            }
            else
            {
                PrintError(dwError);
            }
            hr = HRESULT_FROM_WIN32(dwError);
            goto end;
        }
    }

    //
    // Open the GPO Object
    //

    if (*(pDcInfo->DomainControllerName) != L'\\' || *(pDcInfo->DomainControllerName + 1) != L'\\') 
    {
        hr = E_FAIL;
        goto end;
    }

    hr = StringCchPrintf(sz,
                         sizeof(sz)/sizeof(sz[0]), 
                         L"LDAP://%s/CN=%s,CN=Policies,CN=System,%s", 
                         pDcInfo->DomainControllerName+2, 
                         DOMAIN_GUID, 
                         global->DomainNamingContext);

    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    hr = global->pGPO->OpenDSGPO(sz, 
                         GPO_OPEN_LOAD_REGISTRY);
    
    if (FAILED(hr))
    {
        if ((HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr) || (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr))
        {            
            //
            // ERROR_INVALID_PARAMETER is returned when registry key is bigger than maximum 
            // acceptable value: bug 631804
            // ERROR_PATH_NOT_FOUND is returned when sysvol\policies or sysvol\policies\<GPO> 
            // directory is not present
            // 
            //

            global->pGPO->Release();
            global->pGPO = NULL;
            global->hasEFSInfo = FALSE;
            hr = S_OK;
        }
        else if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
        {
            WCHAR *szAccessDenied = NULL;
            
            hr = StringCchPrintf(TempPath, 
                                 uLength, 
                                 L"%s\\%s\\Policies\\%s\\MACHINE\\Registry.pol", 
                                 global->SysVolPath, 
                                 global->pDomainInfo->DomainNameDns , 
                                 DOMAIN_GUID);
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }

            // 
            //  No memory for terminating \0 is required since global->EFSAccessDenied is a format string.
            //        global->EFSAccessDenied          + TempPath          + sz

            uLength = lstrlen(global->EFSAccessDenied) + lstrlen(TempPath) + sizeof(sz)/sizeof(sz[0]) ;
            szAccessDenied = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * uLength);
            if ( NULL == szAccessDenied )
            {
                hr = E_OUTOFMEMORY;
                PrintError(hr);
                goto end;
            }

            hr = StringCchPrintf(szAccessDenied, uLength, global->EFSAccessDenied, TempPath, sz);
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }

            DisplayError(szAccessDenied);
            LocalFree(szAccessDenied);
        }
        
        else
        {
            PrintError(DDP, global->InvalidEFS);
            PrintError(hr);
        }
        goto end;        
    }
    
    //
    // Get the registry key for the machine section
    //
    
    hr = global->pGPO->GetRegistryKey(GPO_SECTION_MACHINE, &hKey);
    if (FAILED(hr))
    {
        PrintError(DDP, global->InvalidEFS);
        PrintError(hr);
        goto end;  
    }

    //
    // Delete all the keys except EFS certs
    //

    hr = RegDelnodeExceptEFS(hKey, global->hasEFSInfo);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) 
    {
        global->hasEFSInfo = FALSE;
        global->pGPO->Release();
        global->pGPO = NULL;
        hr = S_OK;
    }

    if ( hr != S_OK ) 
    {
        PrintError(DDP, global->InvalidEFS);
        PrintError(hr);
    }
    
 end:

     if (pDcInfo) 
     {
         NetApiBufferFree(pDcInfo);
     }
        
    if(TempPath != NULL)
    {
        LocalFree(TempPath);
    }

    if( hKey != 0)
    {
        RegCloseKey(hKey);
    }

    return hr;
    
}   // BackupEfsCert




HRESULT
DeleteTree(
    PWSTR pPath
    )
{
    DWORD             dwError;
    BOOL              bError;
    HRESULT           hr;
    WCHAR             *TempPath = NULL;
    HANDLE            FindHandle = NULL;
    WIN32_FIND_DATA   FindData;
    ULONG             ulSize;

    //
    // TempPath will be in the form <pPath>\<File Name> 
    //              pPath +  '\' + File Name + '\0'
    //

    ulSize = lstrlen(pPath)+  1  + MAX_PATH  +  1;
    TempPath = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * ulSize );
    if ( NULL == TempPath)
    {
        hr = E_OUTOFMEMORY;
        PrintError(hr);
        goto end;
    }

    dbgprint(L"dbg: DeleteTree(%s)\n", pPath);
    hr = StringCchPrintf(TempPath, ulSize, L"%s\\*", pPath);
    if (FAILED(hr)) 
    {
        goto end;
    }

    FindHandle = FindFirstFile(TempPath, &FindData);
    if (FindHandle == INVALID_HANDLE_VALUE) 
    {
        FindHandle = NULL; 
    }
    
    if (NULL == FindHandle )
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        if ( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr )
        {
            hr = S_OK;
        }
        else
        {
            PrintError(TempPath, global->DirDelete);
        }
        goto end;
    }

    while (TRUE) {

        // is this a special file?
        
        if (FindData.cFileName[0] == L'.' ) 
        {
            goto next_file;
        }

        // no? delete it 

        hr = StringCchPrintf(TempPath, ulSize, L"%s\\%s", pPath, FindData.cFileName);
        if (FAILED(hr)) 
        {
            goto end;
        }

        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
        {            
            // recurse.
            hr = DeleteTree(TempPath);
            if (FAILED(hr))
            {
                goto end;
            }

        } 
        else 
        {

            // delete 
            
            dbgprint(L"dbg: DeleteFile(%s)\n", TempPath);
            
            SetFileAttributes(TempPath, FILE_ATTRIBUTE_NORMAL);

            bError = DeleteFile(TempPath);
            if (bError == FALSE) 
            {
                dwError = GetLastError();
                PrintError(TempPath, global->DirDelete);
                hr = HRESULT_FROM_WIN32(dwError);
                goto end;
            }
            
        }
        
next_file:
        
        bError = FindNextFile(FindHandle, &FindData);
        if (bError == FALSE) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES)) 
            {
                hr = S_OK;
                break;
            } 
            else 
            {
                goto end;
            }
        }
    }

    // and remove the directory now

    dbgprint(L"dbg: RemoveDirectory(%s)\n", pPath);

    bError = RemoveDirectory(pPath);
    if (bError == FALSE) 
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) || hr == HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY)) 
        {
            hr = S_OK;
        } 
        else 
        {
            PrintError(pPath, global->DirDelete);
            goto end;
        }
    }


    hr = S_OK;
end:
    LocalFree(TempPath);
    if (FindHandle != NULL) 
    {
        FindClose(FindHandle);
        FindHandle = NULL;
    }

    return hr;
}   // DeleteTree


HRESULT
CheckDSSchemaVersion(
BOOL *bResult
    )
{
    WCHAR sz[256];
    WCHAR szSchema[256];
    CComPtr<IADs> pADs;
    CComVariant Var;
    HRESULT hr;

    CComBSTR ObjectVersion(L"objectVersion");
    CComBSTR SchemaNamingContext( L"schemaNamingContext" );

    if ( ! SchemaNamingContext ||
         ! ObjectVersion )
    {
        hr = E_OUTOFMEMORY;
        PrintError(hr);
        goto end;
    }

    hr = StringCchCopy(sz, sizeof(sz)/sizeof(sz[0]), L"LDAP://rootDSE");
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    hr = AdminToolsOpenObject(sz, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADs, (void**)&pADs);
    if (FAILED(hr)) 
    {
        dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, sz);
        PrintError(sz, global->GenDSErr);
        goto end;
    }

    hr = pADs->GetInfo();
    if (FAILED(hr)) 
    {
        dbgprint(L"dbg: GetInfo failed on rootDSE %x\n", hr);
        PrintError(sz, global->GenDSErr);
        goto end;
    }

    hr = pADs->Get(SchemaNamingContext, &Var);
    if (FAILED(hr))  
    {
        dbgprint(L"dbg: failed to get rootDomainNamingContext %x \n", hr);
        PrintError(sz, global->GenDSErr);
        goto end;
    }
    
    hr = Var.ChangeType(VT_BSTR);
    if (FAILED(hr)) 
    {
        dbgprint(L"dbg: ChangeType failed to BSTR %x\n", hr);
        PrintError(hr);
        goto end;
    }
    hr = StringCchPrintf(szSchema, sizeof(szSchema)/sizeof(szSchema[0]), L"LDAP://%s", Var.bstrVal);
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    hr =  AdminToolsOpenObject(szSchema, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADs, (void**)&pADs);
    if (FAILED(hr)) 
    {
        dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, szSchema);
        PrintError(hr);
        PrintError(szSchema, global->GenDSErr);
        goto end;
    }

    hr = pADs->GetInfo();
    if (FAILED(hr)) 
    {
        dbgprint(L"dbg: GetInfo failed on rootDSE %x\n", hr);
        PrintError(szSchema, global->GenDSErr);
        goto end;
    }

    Var.Clear();
    
    hr = pADs->Get(ObjectVersion, &Var);
    if (FAILED(hr))  
    {
        dbgprint(L"dbg: failed to get schemaDomainNamingContext %x \n", hr);
        PrintError(hr);
        PrintError(szSchema, global->GenDSErr);
        goto end;
    }

    if (SCHEMA_VERSION == Var.lVal)
    {
        *bResult = TRUE;
    }
    else
    {
        *bResult = FALSE;
    }

 end:

    return hr;
}



// clean the domains GPO
// clean the controller GPO
HRESULT 
CleanPolicyObjects(
    )
{
    HRESULT                hr;
    WCHAR                  sz[1024];
    CComPtr<IADs>          pADs;
    CComVariant            Var;
    CComBSTR               GroupPolicyContainerName(L"groupPolicyContainer");
    CComBSTR               DisplayName(L"displayName");
    CComBSTR               GPOFlags(L"flags");
    CComBSTR               GPCFileSysPath(L"gPCFileSysPath");
    CComBSTR               GPCFunctionalityVersion(L"gPCFunctionalityVersion");
    CComBSTR               VersionNumber(L"VersionNumber");
    CComBSTR               GPCUserExtensionNames(L"gPCUserExtensionNames");
    CComBSTR               GPCMachineExtensionNames(L"gPCMachineExtensionNames");
    CComBSTR               GPCWQLFilter(L"gPCWQLFilter");

    if ( ! GroupPolicyContainerName ||
         ! DisplayName ||
         ! GPCFileSysPath ||
         ! GPCFunctionalityVersion ||
         ! VersionNumber ||
         ! GPCUserExtensionNames ||
         ! GPCMachineExtensionNames ||
         ! GPCWQLFilter )
    {
        hr = E_OUTOFMEMORY;
        PrintError(hr);
        goto end;
    }

    if (global->RestoreType & GLOBALS::RESTORE_DOMAIN) 
    {
        hr = StringCchPrintf( sz,
                             sizeof(sz)/sizeof(sz[0]),
                             L"LDAP://CN=%s,CN=Policies,CN=System,%s",
                             DOMAIN_GUID,
                             global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        pADs.Release();

        hr = AdminToolsOpenObject(sz, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADs, (void**)&pADs);
        
        if ( FAILED(hr) && hr != (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT)))
        {
            dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, sz);
            PrintError(sz, global->GenDSErr);
            goto end;
        }
        else
        {
            CComPtr<IADsContainer> pFolder;
            CComPtr<IDispatch> pDisp;
            
            hr = StringCchPrintf( sz, 
                                  sizeof(sz)/sizeof(sz[0]),
                                  L"LDAP://CN=Policies,CN=System,%s",
                                  global->DomainNamingContext) ;
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }
            
            hr = AdminToolsOpenObject(sz, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADsContainer, (void**)&pFolder);
            
            if (FAILED(hr)) 
            {
                dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, sz);
                PrintError(sz, global->DSCreate);
                goto end;
            }
            
            hr = StringCchPrintf( sz,
                                  sizeof(sz)/sizeof(sz[0]),
                                  L"CN=%s",
                                  DOMAIN_GUID );
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }
            
            {
                CComBSTR ContainerPath(sz);

                if ( ContainerPath )
                {
                    hr = pFolder->Create(GroupPolicyContainerName, ContainerPath, &pDisp);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr)) 
                {
                    dbgprint(L"dbg: Create failed %x on %s\n", hr, sz);
                    PrintError(sz, global->DSCreate);
                    goto end;
                }
            }
            
            hr = pDisp->QueryInterface(IID_IADs, (void**)&pADs);
            if (FAILED(hr))
            {
                dbgprint(L"dbg: Query Interface failed %x for Creating IID_IADS\n", hr); 
                PrintError(sz, global->DSCreate);
                goto end;
            } 
            
        }

        hr = StringCchPrintf( sz, 
                              sizeof(sz)/sizeof(sz[0]),
                              L"LDAP://CN=Machine,CN=%s,CN=Policies,CN=System,%s",
                              DOMAIN_GUID,
                              global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
            
        hr = ResetContainerFromDS(sz, pADs);
        if (FAILED(hr))
        {
                dbgprint(L"ResetContainerFromDS failed %x on %s\n", hr, sz);
                goto end;  
        }
        
        hr = StringCchPrintf( sz,
                             sizeof(sz)/sizeof(sz[0]),
                             L"LDAP://CN=User,CN=%s,CN=Policies,CN=System,%s",
                             DOMAIN_GUID,
                             global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        hr = ResetContainerFromDS(sz, pADs);
        if (FAILED(hr))
        {
            dbgprint(L"ResetContainerFromDS failed %x on %s\n", hr, sz);
            goto end;  
        }
            
        hr = StringCchPrintf( sz, 
                             sizeof(sz)/sizeof(sz[0]),
                             L"LDAP://CN=%s,CN=Policies,CN=System,%s",
                             DOMAIN_GUID,
                             global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        hr = ADsGetObject(sz, IID_IADs, (void**)&pADs);
        if (FAILED(hr))
        {
            dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, sz);
            PrintError(sz,global->GenDSErr);
            goto end;   
        }

        // clean the display name (displayName)

        // strip any WQL filters to <not set> (gPCWQLFilter)

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = SysAllocString(L"Default Domain Policy");

        if ( Var.bstrVal )
        {
            hr = pADs->Put(DisplayName, Var);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on displayName %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

        // reset flags to 0 (flags)

        Var.Clear();
        Var.ChangeType(VT_I4);
        Var.lVal = 0;

        hr = pADs->Put(GPOFlags, Var);
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on flags %x\n", hr);
            PrintError(sz,global->DSAttrib);
           goto end;
        }
                 
        // set the filesys path (gPCFileSysPath)        
        hr = StringCchPrintf( sz, 
                             sizeof(sz)/sizeof(sz[0]), 
                             L"\\\\%s\\sysvol\\%s\\Policies\\%s",
                             global->pDomainInfo->DomainNameDns,
                             global->pDomainInfo->DomainNameDns,
                             DOMAIN_GUID );
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
        
        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = SysAllocString(sz);

        if ( Var.bstrVal )
        {
            hr = pADs->Put(GPCFileSysPath, Var);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on gPCFileSysPath %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }



        // set the version to 2 (gPCFunctionalityVersion)

        Var.Clear();
        Var.ChangeType(VT_I4);
        Var.lVal = 2;
        hr = pADs->Put(GPCFunctionalityVersion, Var);
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on gPCFunctionalityVersion %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

        //
        // Increment the version number
        //

        Var.Clear();
        Var.ChangeType(VT_I4);
        Var.lVal = global->lDDPVersionNo;
        hr = pADs->Put(VersionNumber, Var); 
        if( FAILED(hr))
        {
            dbgprint(L"dbg: Put failed on version number %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
            
        }

                
        //
        // set the extensions (gPCUserExtensionNames)
        //
        
        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = SysAllocString(DDP_USEREXT);

        if ( Var.bstrVal )
        {
            hr = pADs->Put(GPCUserExtensionNames, Var); 
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if( FAILED(hr))
        {
            dbgprint(L"dbg: Put failed on gPCUserExtensionNames %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
            
        }

        //
        // set the extensions (gPCMachineExtensionNames)
        //

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = SysAllocString(DDP_MACHEXT);

        if ( Var.bstrVal )
        {
            hr = pADs->Put(GPCMachineExtensionNames, Var); 
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if( FAILED(hr))
        {
            dbgprint(L"dbg: Put failed on gPCMachineExtensionNames %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
            
        }

        // strip any WQL filters to <not set> (gPCWQLFilter)

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = NULL;

        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, GPCWQLFilter, Var);
        if (FAILED(hr)) 
        {
            dbgprint(L"Put failed on gPCWQLFilter %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

        // and update it

        hr = pADs->SetInfo();
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: SetInfo failed %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

    }


    if (global->RestoreType & GLOBALS::RESTORE_DC) 
    {

        hr = StringCchPrintf( sz,
                             sizeof(sz)/sizeof(sz[0]), 
                             L"LDAP://CN=%s,CN=Policies,CN=System,%s",
                             DC_GUID,
                             global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        hr = AdminToolsOpenObject(sz, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADs, (void**)&pADs);

        if ( FAILED(hr) && hr != (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT)) )
        {
            dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, sz);
            PrintError(sz,global->GenDSErr);               
            goto end;
        }
        else
        {
            CComPtr<IADsContainer> pFolder;
            CComPtr<IDispatch> pDisp;
            
            hr = StringCchPrintf( sz, 
                                 sizeof(sz)/sizeof(sz[0]), 
                                 L"LDAP://CN=Policies,CN=System,%s",
                                 global->DomainNamingContext) ;
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }
            
            hr = AdminToolsOpenObject(sz, NULL, NULL, ADS_SECURE_AUTHENTICATION | ADS_SERVER_BIND, IID_IADsContainer, (void**)&pFolder);
            
            if (FAILED(hr)) 
            {
                dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, sz);
                PrintError(sz,global->GenDSErr);
                goto end;
            }
            
            hr = StringCchPrintf( sz, 
                                 sizeof(sz)/sizeof(sz[0]), 
                                 L"CN=%s",
                                 DC_GUID );
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }

            {
                CComBSTR ContainerPath(sz);

                if ( ContainerPath )
                {
                    hr = pFolder->Create(GroupPolicyContainerName, ContainerPath, &pDisp);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if (FAILED(hr)) 
                {
                    dbgprint(L"dbg: Create failed %x on %s\n", hr, sz);
                    PrintError(sz,global->DSCreate);               
                    goto end;
                }
            }
            
            hr = pDisp->QueryInterface(IID_IADs, (void**)&pADs);
            if (FAILED(hr))
            {
                dbgprint(L"dbg: Query Interface failed %x for Creating IID_IADS\n", hr);
                PrintError(sz,global->DSCreate);
                goto end;
            } 
            
        }

        hr = StringCchPrintf( sz, 
                             sizeof(sz)/sizeof(sz[0]), 
                             L"LDAP://CN=Machine,CN=%s,CN=Policies,CN=System,%s",
                             DC_GUID,
                             global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
            
        hr = ResetContainerFromDS(sz, pADs);
        if (FAILED(hr))
        {
                dbgprint(L"ResetContainerFromDS failed %x on %s\n", hr, sz);
                goto end;  
        }
        
        hr = StringCchPrintf( sz,
                             sizeof(sz)/sizeof(sz[0]), 
                             L"LDAP://CN=User,CN=%s,CN=Policies,CN=System,%s",
                             DC_GUID,
                             global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
        
        hr = ResetContainerFromDS(sz, pADs);
        if (FAILED(hr))
        {
            dbgprint(L"ResetContainerFromDS failed %x on %s\n", hr, sz);
            goto end;  
        }

        hr = StringCchPrintf( sz,
                             sizeof(sz)/sizeof(sz[0]), 
                             L"LDAP://CN=%s,CN=Policies,CN=System,%s",
                             DC_GUID,
                             global->DomainNamingContext) ;
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
        
        hr = ADsGetObject(sz, IID_IADs, (void**)&pADs);
        if (FAILED(hr))
        {
            dbgprint(L"dbg: AdminToolsOpenObject failed %x on %s\n", hr, sz);
            PrintError(sz,global->GenDSErr);
            goto end;   
        }

        // clean the display name (displayName)

        // strip any WQL filters to <not set> (gPCWQLFilter)

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = SysAllocString(DEFAULT_DC_POLICY_NAME);

        if ( Var.bstrVal )
        {
            hr = pADs->Put(DisplayName, Var);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on displayName %x\n", hr);
            PrintError(sz, global->DSAttrib);
            goto end;
        }

        // reset flags to 0 (flags)

        Var.Clear();
        Var.ChangeType(VT_I4);
        Var.lVal = 0;

        hr = pADs->Put(GPOFlags, Var);
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on flags %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

        // set the filesys path (gPCFileSysPath)

        hr = StringCchPrintf( sz,
                             sizeof(sz)/sizeof(sz[0]), 
                             L"\\\\%s\\sysvol\\%s\\Policies\\%s",
                             global->pDomainInfo->DomainNameDns,
                             global->pDomainInfo->DomainNameDns,
                             DC_GUID );
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = SysAllocString(sz);

        if ( Var.bstrVal )
        {
            hr = pADs->Put(GPCFileSysPath, Var);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on gPCFileSysPath %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }


        // set the version to 2 (gPCFunctionalityVersion)

        Var.Clear();
        Var.ChangeType(VT_I4);
        Var.lVal = 2;

        hr = pADs->Put(GPCFunctionalityVersion, Var);
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on gPCFunctionalityVersion %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

        //
        // Increment the version number
        //

        Var.Clear();
        Var.ChangeType(VT_I4);
        Var.lVal = global->lDDCPVersionNo;

        hr = pADs->Put(VersionNumber, Var); 
        if( FAILED(hr))
        {
            dbgprint(L"dbg: Put failed on version number %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
            
        }

        //
        // Set the (gPCUserExtensionNames) to <not set>
        //

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = NULL ;

        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, GPCUserExtensionNames, Var);
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on gPCUserExtensionNames %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }


        //
        // set the extensions (gPCMachineExtensionNames)
        //

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = SysAllocString(DDC_MACHEXT);
        
        if ( Var.bstrVal )
        {
            hr = pADs->Put(GPCMachineExtensionNames, Var); 
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if( FAILED(hr))
        {
            dbgprint(L"dbg: Put failed on gPCMachineExtensionNames %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
            
        }

        // strip any WQL filters to <not set> (gPCWQLFilter)

        Var.Clear();
        Var.ChangeType(VT_BSTR);
        Var.bstrVal = NULL;

        hr = pADs->PutEx(ADS_PROPERTY_CLEAR, GPCWQLFilter, Var);
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: Put failed on gPCWQLFilter %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

        // and update it

        hr = pADs->SetInfo();
        if (FAILED(hr)) 
        {
            dbgprint(L"dbg: SetInfo failed %x\n", hr);
            PrintError(sz,global->DSAttrib);
            goto end;
        }

    }
    
    hr = S_OK;

 end:

    return hr;
    
}   // CleanPolicyObjects


CIgnoredGPO::CIgnoredGPO( 
    WCHAR* wszGPOID,
    WCHAR* wszGPOName ) :
    _pGptIniFile( NULL ),
    _pGptTmplFile( NULL ),
    _wszError( NULL )
{
    //
    // Note -- we handle errors in the constructor by leaving members
    // set to NULL -- if these are NULL, other methods will fail
    //

    WCHAR* wszGptTmplPath = NULL;
    WCHAR* wszGptIniPath = NULL;

    ULONG  uLength = 0;

    uLength = lstrlen(global->SysVolPath) + 1 + lstrlen(global->pDomainInfo->DomainNameDns) + lstrlen(L"\\Policies") 
        + 1 + lstrlen(wszGPOID) +  lstrlen(FILE_GPTTMPLINF) 
        + lstrlen(FILE_GPTINI) + 1;

    wszGptTmplPath = (WCHAR*) LocalAlloc( LPTR, uLength * sizeof(WCHAR) );
    
    if( NULL == wszGptTmplPath )
    {
        goto CIgnoredGPO_CIgnoredGPO_Exit;
    }

    wszGptIniPath = (WCHAR*) LocalAlloc( LPTR, uLength * sizeof(WCHAR) );
    
    if( NULL == wszGptIniPath )
    {
        goto CIgnoredGPO_CIgnoredGPO_Exit;
    }

    HRESULT hr;

    hr = StringCchPrintf(
        wszGptTmplPath,
        uLength, 
        L"%s\\%s\\Policies\\%s" FILE_GPTTMPLINF,
        global->SysVolPath, 
        global->pDomainInfo->DomainNameDns, 
        wszGPOID);

    ASSERT( SUCCEEDED(hr) );
        
    hr = StringCchPrintf(
        wszGptIniPath,
        uLength, 
        L"%s\\%s\\Policies\\%s" FILE_GPTINI,
        global->SysVolPath, 
        global->pDomainInfo->DomainNameDns, 
        wszGPOID );

    ASSERT( SUCCEEDED(hr) );            

    _pGptTmplFile = new CGPOFile( wszGptTmplPath );

    if ( _pGptTmplFile )
    {
        DWORD Status = InitializeErrorText(
            wszGPOName );

        if ( ERROR_SUCCESS == Status )
        {
             _pGptIniFile = new CGPOFile( wszGptIniPath );
        }        
    }

CIgnoredGPO_CIgnoredGPO_Exit:

    if ( wszGptIniPath )
    {
        LocalFree( wszGptIniPath );
    }

    if ( wszGptTmplPath )
    {
        LocalFree( wszGptTmplPath );
    }
   
} // CIgnoredGPO::CIgnoredGPO


CIgnoredGPO::~CIgnoredGPO()
{
    delete _pGptIniFile;

    delete _pGptTmplFile;

    LocalFree( _wszError );
}


DWORD
CIgnoredGPO::Backup()
{
    DWORD Status = ERROR_SUCCESS;

    //
    // Detect failure in the constructor by checking
    // that necessary members are properly initialized to non-NULL values
    //
    if ( ! _pGptIniFile || ! _pGptTmplFile )
    {
        Status = ERROR_OUTOFMEMORY;
        goto CIgnoredGPO_Backup_CleanupAndExit;
    }
    
    Status = _pGptIniFile->Backup();

    if ( ERROR_SUCCESS != Status )
    {
        dbgprint(L"Failed to back up gpt.ini file\n");
        goto CIgnoredGPO_Backup_CleanupAndExit;
    }

    Status = _pGptTmplFile->Backup();

    if ( ERROR_SUCCESS != Status )
    {
        dbgprint(L"Failed to back up gpttmpl.inf file\n");
        goto CIgnoredGPO_Backup_CleanupAndExit;
    }

CIgnoredGPO_Backup_CleanupAndExit:

    return Status;
} // CIgnoredGPO::Backup

DWORD
CIgnoredGPO::Restore()
{
    DWORD Status = ERROR_SUCCESS;
    DWORD StatusIniFile;
    DWORD StatusTmplFile;

    StatusIniFile = _pGptIniFile->Restore();

    StatusTmplFile = _pGptTmplFile->Restore();

    if ( ERROR_SUCCESS != StatusIniFile )
    {
        Status = StatusIniFile;
        dbgprint(L"Failed to restore gpt.ini");
    }
    else if ( ERROR_SUCCESS != StatusTmplFile )
    {
        Status = StatusTmplFile;        
        DisplayError(_wszError);
    }

    if ( ERROR_SUCCESS != StatusTmplFile )
    {
        dbgprint(L"Failed to restore gpttmpl.inf\n");
    }
    
    return Status;
} // CIgnoredGPO::Restore

DWORD
CIgnoredGPO::InitializeErrorText(
    WCHAR* wszGPOName )
{
    //
    // global->RestoreIgnoredGPOFail + GPTTmplPath + GPOName + 1
    //

    DWORD  uLength = lstrlen(global->RestoreIgnoredGPOFail) + lstrlen(_pGptTmplFile->GetPath()) + lstrlen(wszGPOName) + 1;
    _wszError = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * uLength);

    if ( NULL == _wszError )
    {
        return ERROR_OUTOFMEMORY;
    }

    HRESULT hr = StringCchPrintf(_wszError, uLength, global->RestoreIgnoredGPOFail, _pGptTmplFile->GetPath(), wszGPOName);
    
    ASSERT(SUCCEEDED(hr));    

    return ERROR_SUCCESS;
}

CGPOFile::CGPOFile( WCHAR* wszFilePath ) :
        _wszFullPath( NULL ),
        _pFileData( NULL ),
        _cbFileSize( 0 )
{    
    //
    // Note -- we handle errors in the constructor by leaving the path
    // set to NULL -- if this is NULL, other methods will fail
    //

    DWORD cchPath = lstrlen( wszFilePath ) + 1;

    _wszFullPath = (WCHAR*) LocalAlloc( LPTR, cchPath * sizeof( *_wszFullPath ) );

    if ( NULL == _wszFullPath )
    {
        return;
    }

    HRESULT hr;

    hr = StringCchCopy(
        _wszFullPath,
        cchPath,
        wszFilePath );

    ASSERT( SUCCEEDED(hr) );
} // CGPOFile::CGPOFile


CGPOFile::~CGPOFile()
{
    if ( _wszFullPath )
    {
        LocalFree( _wszFullPath );
    }

    if ( _pFileData )
    {
        LocalFree( _pFileData );
    }
}

DWORD
CGPOFile::Backup()
{
    DWORD  Status = ERROR_SUCCESS;
    HANDLE hFile = NULL;

    //
    // Detect failure in the constructor by checking
    // that necessary path members is properly initialized to a non-NULL value
    //
    if ( NULL == _wszFullPath )
    {
        Status = ERROR_OUTOFMEMORY;
        goto CGPOFile_Backup_CleanupAndExit;
    }
    
    hFile = CreateFile(
        _wszFullPath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        Status = GetLastError();

        if ( ( ERROR_FILE_NOT_FOUND == Status ) ||
             ( ERROR_PATH_NOT_FOUND == Status ) )
        {
            Status = ERROR_SUCCESS;
        }

        hFile = NULL;
        goto CGPOFile_Backup_CleanupAndExit;
    }

    DWORD cbFileSize;
    DWORD cbFileSizeHigh;

    cbFileSize = GetFileSize(
        hFile,
        &cbFileSizeHigh);

    if ( -1 == cbFileSize )
    {
        Status = GetLastError();
        goto CGPOFile_Backup_CleanupAndExit;
    }

    if ( 0 != cbFileSizeHigh )
    {
        Status = ERROR_INVALID_DATA;
        goto CGPOFile_Backup_CleanupAndExit;
    }

    _pFileData = (BYTE*) LocalAlloc( LPTR, cbFileSize );

    if ( NULL == _pFileData )
    {
        Status = ERROR_OUTOFMEMORY;
        goto CGPOFile_Backup_CleanupAndExit;
    }

    BOOL  bReadSucceeded;
    DWORD cbRead;

    bReadSucceeded = ReadFile(
        hFile,
        _pFileData,
        cbFileSize,
        &cbRead,
        NULL);

    if ( ! bReadSucceeded )
    {
        Status = GetLastError();
        goto CGPOFile_Backup_CleanupAndExit;
    }

    //
    // Don't set this to non-zero until we've successfully read the file --
    // this way a call to Restore() will do nothing if any of these operations
    // have failed (it won't try to write back bogus data)
    //
    _cbFileSize = cbFileSize;

CGPOFile_Backup_CleanupAndExit:

    if ( NULL != hFile )
    {
        CloseHandle( hFile );
    }

    return Status;
} // CGPOFile::Backup


DWORD
CGPOFile::Restore()   
{
    DWORD   Status = ERROR_SUCCESS;
    HANDLE hFile = NULL;

    //
    // Zero sized files are invalid, so if we are called with this, we know
    // the file did not exist and does not need to be restored (or we couldn't
    // back up the file, in which case we shouldn't try to restore anything)
    //
    if ( 0 == _cbFileSize )
    {
        goto RestoreGPOFile_CleanupAndExit;
    }

    hFile = CreateFile(
        _wszFullPath,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        Status = GetLastError();
        goto RestoreGPOFile_CleanupAndExit;
    }

    BOOL bWriteSucceeded;

    //
    // First we need to truncate the file to 0 -- otherwise,
    // if the file is larger than the data we're about to write, the
    // extra data in the current version of the file will still exist
    // when we're done.
    //
    bWriteSucceeded = SetEndOfFile( hFile );

    if ( ! bWriteSucceeded )
    {
        Status = GetLastError();
        goto RestoreGPOFile_CleanupAndExit;
    }

    DWORD dwWritten;

    bWriteSucceeded = WriteFile(
        hFile,
        _pFileData,
        _cbFileSize,
        &dwWritten,
        NULL);

    if ( ! bWriteSucceeded )
    {
        Status = GetLastError();
        goto RestoreGPOFile_CleanupAndExit;
    }
    
RestoreGPOFile_CleanupAndExit:

    if ( NULL != hFile )
    {
        CloseHandle( hFile );
    }

    return Status;
} // CGPOFile::Restore

WCHAR*
CGPOFile::GetPath()
{
    return _wszFullPath;
} // CGPOFile::GetPath

int 
_cdecl 
wmain(
    int argc, 
    WCHAR ** argv
    )
{
    DWORD                  dwError;
    BOOL                   bError;
    HRESULT                hr = E_FAIL;
    BOOL                   bIsDomain;
    BOOL                   bIsAdmin;
    WCHAR                  sz[256];
    ULONG                  Length;
    ULONG                  Type;
    WCHAR                  *TempPath = NULL;
    WCHAR                  *szProfilePath = NULL;
    HKEY                   Key = NULL;
    BOOL                   UnknownArgs = FALSE;
    LONG                   lError;
    LPBYTE                 pShareName = NULL;
    WCHAR                  szVersionNo[MAX_VERSION_LENGTH];
    NET_API_STATUS         netapiStatus;


    dbgprint(L"dbg: wmain started !\n");

    WCHAR achCodePage[13] = L".OCP";

    UINT  CodePage = GetConsoleOutputCP();

    //
    // Set locale to the default
    //
    if ( 0 != CodePage )
    {
       _ultow( CodePage, achCodePage + 1, 10 );
    }

    _wsetlocale(LC_ALL, achCodePage);
    SetThreadUILanguage(0);


    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        PrintError(hr);
        goto end;
    }

    global->RestoreType = GLOBALS::RESTORE_BOTH;

    hr = global->Init();
    if (FAILED(hr))
    {
        PrintError(hr);
        goto end;
    }

    if (argc > 1 && argv[1] != NULL) 
    {
        int iIndex = 1;
        
        
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, argv[1], -1, L"/?", -1) == CSTR_EQUAL) 
        {
            wprintf(global->Banner1);
            wprintf(global->TargetSwitch);
            wprintf(global->IgnSchSwitch);
            hr = S_OK;
            goto end;
        }
        
        Length = lstrlen(argv[1]);
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, argv[1], -1, TARGET_ARG_IGNORE_SCHEMA, -1) == CSTR_EQUAL) 
        {
            global->bIgnoreSchema = TRUE;
            iIndex = 2;
        }
        
        // check if a target was specified
        if (argc == iIndex + 1 && argv[iIndex] != NULL)
        {
            Length = lstrlen(argv[iIndex]);
            
            if ( Length >= TARGET_ARG_COUNT &&
                CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, argv[iIndex], TARGET_ARG_COUNT, TARGET_ARG, TARGET_ARG_COUNT) == CSTR_EQUAL) 
            {    
                WCHAR * p = &argv[iIndex][TARGET_ARG_COUNT];
                
                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, TARGET_ARG_DOMAIN, -1) == CSTR_EQUAL) 
                {
                    global->RestoreType = GLOBALS::RESTORE_DOMAIN;
                } 
                else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, TARGET_ARG_DC, -1) == CSTR_EQUAL) 
                {
                    global->RestoreType = GLOBALS::RESTORE_DC;
                } 
                else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, p, -1, TARGET_ARG_BOTH, -1) == CSTR_EQUAL) 
                {
                    global->RestoreType = GLOBALS::RESTORE_BOTH;
                } 
                else 
                {
                    UnknownArgs = TRUE;
                }
            } 
            else 
            {
                UnknownArgs = TRUE;
            }
        }
        else if(argc > iIndex)
        {
            UnknownArgs = TRUE;
        }
    }

    // print the banner
    
    wprintf(global->Banner1);
    wprintf(global->Banner2);
    
    if (UnknownArgs) 
    {
        hr = E_INVALIDARG;
        PrintError(hr);
        goto end;
    }
    
    if ( FALSE == global->bIgnoreSchema)
    {
        BOOL bSchemaVerCompat;

        hr = CheckDSSchemaVersion( &bSchemaVerCompat);
        if ( FAILED(hr))
        {
            dbgprint(L"CheckDSSchemaVersion Failed");
            goto end;
        }
        
        if (FALSE == bSchemaVerCompat)
        {
            hr = E_FAIL;
            DisplayError(global->WrongSchema);
            goto end;
        }
    } 


    dbgprint(L"dbg: Choice is %d\n", global->RestoreType);
    
    // check to see if we are on a domain controller.
    hr = IsDomainController(&bIsDomain);
    if (FAILED(hr))
    {
        PrintError(hr);
        goto end;
    }

    if (bIsDomain == FALSE) 
    {
        DisplayError(global->ErrorNoAD);
        hr = S_OK;
        goto end;
    }
    
    // Copy the domain name
    
    hr = GetDomainFQDN(global->pDomainInfo->DomainNameDns, &(global->DomainNamingContext));
    if (FAILED(hr))
    {
        PrintError(hr);
        goto end;
    }

    // check to see if we are a member of domain/enterprise admins
    
    hr = IsAdmin(&bIsAdmin);
    if (FAILED(hr))
    {
        goto end;
    }
    
    if (FALSE == bIsAdmin) 
    {
        DisplayError(global->ErrorNotAdmin);            
        hr = S_OK;
        goto end;            
    }             
    
    switch(global->RestoreType)
    {
    case GLOBALS::RESTORE_DOMAIN:
        wprintf(global->DispDDP);
        break;
        
    case GLOBALS::RESTORE_DC:
        wprintf(global->DispDDCP);
        break;
        
    case GLOBALS::RESTORE_BOTH:
        wprintf(global->DispBoth);
        break;
        
    default:
        break;
    }
    
    wprintf(global->pDomainInfo->DomainNameDns);
    wprintf(L"\n");
    

    // is he sure ?

    WCHAR szFirstChar[2];
    
    // Here the first character of the user's input is converted as a string to compare with another string
    szFirstChar[1] = L'\0';

    do
    {
        wprintf(global->ErrorContinue);

        szFirstChar[0] = getwchar();
        
        if (L'\n' != szFirstChar[0] ) 
        {
            if ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, global->CharYes, -1, szFirstChar, -1) != CSTR_EQUAL )
            {
                // The case where szFirstChar[0] is WEOF is also handled here

                hr = S_OK;
                goto end;
            }    
            else
            {
                // Skip until carriage return character
                // We do this because we do not want to take the input until the user presses carriage return

                do{
                    szFirstChar[0] = getwchar();
                }while( szFirstChar[0] != '\n' && szFirstChar[0] != WEOF);

                break;
            }
        }

        // Prompt user again if user enters only carriage return
        // This case is handled by going through this while loop again

    } while(TRUE);
   
    szFirstChar[1] = '\0';
    wprintf(global->WarnURA);
    do
    {
        wprintf(global->ErrorContinue);
        szFirstChar[0] = getwchar();
        if (L'\n' != szFirstChar[0] ) 
        {
            if ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, global->CharYes, -1, szFirstChar, -1) != CSTR_EQUAL )
            {
                hr = S_OK;
                goto end;
            }
            else
            {
                do{
                    szFirstChar[0] = getwchar();
                }while( szFirstChar[0] != '\n' && szFirstChar[0] != WEOF);

                break;
            }
        }
    } while(TRUE);


    // check the state of the sysvol
    
    // find out where the sysvol is .
    
    netapiStatus = NetShareGetInfo(NULL,  L"sysvol", 2, &pShareName);
    if ( NERR_Success == netapiStatus )
    {
        hr = StringCchCopy(global->SysVolPath,  MAX_PATH, ((SHARE_INFO_2 *) pShareName )->shi2_path);
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        NetApiBufferFree(pShareName);
    }
    else
    {
        DisplayError(global->ErrorBadSysVol);
        hr = HRESULT_FROM_WIN32(netapiStatus);
        goto end;
    }

    dbgprint(L"dbg: sysvol = '%s'\n", global->SysVolPath);
    
    //
    // Get the version Number from filesystem and DS
    //

    if (global->RestoreType & GLOBALS::RESTORE_DOMAIN)
    {
        hr = GetVersionNumber(DEFAULT_DOMAIN_POLICY);
        if (FAILED(hr))
        {
            dbgprint(L"GetversionNo failed with error %x\n", hr);
            goto end;
        }
    }

    if (global->RestoreType & GLOBALS::RESTORE_DC)
    {
        hr = GetVersionNumber(DEFAULT_DOMAIN_CONTROLLER_POLICY);
        if (FAILED(hr))
        {
            dbgprint(L"GetversionNo failed with error %x\n", hr);
            goto end;
        }
    }

    if ( global->RestoreType & GLOBALS::RESTORE_DOMAIN )
    {
        hr = SetDSSecurityDescriptor(DEFAULT_DOMAIN_POLICY);
        if (FAILED(hr)) 
        {
            goto end;
        }
    }

    if ( global->RestoreType & GLOBALS::RESTORE_DC ) 
    {
        hr = SetDSSecurityDescriptor(DEFAULT_DOMAIN_CONTROLLER_POLICY);
        if (FAILED(hr)) 
        {
            goto end;
        }
    }

    // clean the domains GPO
    // clean the controller GPO

    hr = CleanPolicyObjects();
    if (FAILED(hr))
    {
        goto end;
    }

    //
    // The string that TempPath will be holding will be like
    // <sysvolpath>\<domain name>\policies\<guid>
    // Memory is allocated for each directory name and for '\' if needed.
    //
    
    ULONG uLength = 0;
    uLength = lstrlen(global->SysVolPath) + 1 + lstrlen(global->pDomainInfo->DomainNameDns) + lstrlen(L"\\Policies") 
        + 1 + lstrlen(DOMAIN_GUID) +  lstrlen(FILE_GPTTMPLINF) 
        + lstrlen(FILE_GPTINI) + 1;

    TempPath = (WCHAR*) LocalAlloc( LPTR, uLength * sizeof(WCHAR) );
    if(NULL == TempPath)
    {
        hr = E_OUTOFMEMORY;
        PrintError(hr);
        goto end;
    }

    // now we need to clean + recreate the file system sysvol files+folders   
    // first, delete the tree's
    
    if (global->RestoreType & GLOBALS::RESTORE_DOMAIN) 
    {  

        // see if we have an EFS cert to backup   
        
        hr = BackupEfsCert();
        if ( FAILED(hr) )
        {
            goto end;
        }

        hr = StringCchPrintf( TempPath, 
                              uLength,
                              L"%s\\%s\\Policies\\%s", 
                              global->SysVolPath, 
                              global->pDomainInfo->DomainNameDns, 
                              DOMAIN_GUID );
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
        
        hr = DeleteTree(TempPath);
        if (FAILED(hr))
        {
            goto end;
        }
    }
    
    if (global->RestoreType & GLOBALS::RESTORE_DC) 
    {
        hr = StringCchPrintf( TempPath, 
                              uLength,
                              L"%s\\%s\\Policies\\%s", 
                              global->SysVolPath, 
                              global->pDomainInfo->DomainNameDns, 
                              DC_GUID );
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
        
        hr = DeleteTree(TempPath);
        if (FAILED(hr))
        {
            goto end;
        }
    }

     // create fresh policy directory
    // + put security permisions on these files + folders

    if (global->RestoreType & GLOBALS::RESTORE_DOMAIN) 
    {
        hr = CreateSysVolDomain();
        if (FAILED(hr))
        {
            goto end;
        }

        if (!global->hasEFSInfo) 
        {
            hr = CreateEFSCerts();
            if (FAILED(hr)) 
            {
                PrintError(DDP, global->CreateEFS);
                PrintError(hr);
                goto end;
            }
        }

        hr = SaveEFSCerts();
        if (FAILED(hr))
        {
            goto end;
        }
    }

    if (global->RestoreType & GLOBALS::RESTORE_DC) 
    {
        hr = CreateSysVolController();
        if (FAILED(hr))
        {
            goto end;
        }
    } 
 
    // for some strange reason the setup helper thinks sysvol should be
    // one level higher than it really is

    hr = StringCchCopy(TempPath, uLength, global->SysVolPath);
    if (FAILED(hr)) 
    {
        PrintError(hr);
        goto end;
    }

    Length = lstrlen(TempPath);
    
    do {
        Length -= 1;
    } while (TempPath[Length] != L'\\');

    TempPath[Length] = UNICODE_NULL;

    {
        WCHAR*       wszIgnoredGPOId = NULL;
        WCHAR*       wszIgnoredGPOName = NULL;
        CIgnoredGPO* pIgnoredGPO = NULL;
        
        dwError = ERROR_SUCCESS;

        if ( ! ( global->RestoreType & GLOBALS::RESTORE_DOMAIN) )
        {
            wszIgnoredGPOId = DOMAIN_GUID;
            wszIgnoredGPOName = DDP;
        } 
        else if ( ! ( global->RestoreType & GLOBALS::RESTORE_DC) )
        {
            wszIgnoredGPOId = DC_GUID;
            wszIgnoredGPOName = DEFAULT_DC_POLICY_NAME;
        }

        if ( wszIgnoredGPOId )
        {
            pIgnoredGPO = new CIgnoredGPO( wszIgnoredGPOId, wszIgnoredGPOName );

            if ( pIgnoredGPO )
            {
                dwError = pIgnoredGPO->Backup();
            }
            else
            {
                dwError = ERROR_OUTOFMEMORY;
            }
        }

        if ( ERROR_SUCCESS == dwError )
        {
            dwError = SceDcPromoCreateGPOsInSysvol( global->pDomainInfo->DomainNameDns,
                                                    TempPath,
                                                    0,
                                                    NULL );

            if ( pIgnoredGPO )
            {
                DWORD RestoreError = pIgnoredGPO->Restore();

                if ( ERROR_SUCCESS != RestoreError )
                {
                    dbgprint(L"Failed to restore ignored gpo id %s with error %X\n", wszIgnoredGPOId, RestoreError );

                    if ( ERROR_SUCCESS == dwError )
                    {
                        dwError = RestoreError;
                    }
                }              
            }

            delete pIgnoredGPO;            
        }        
    }

    if (dwError != 0 ) 
    {
        PrintError(dwError);
        hr = HRESULT_FROM_WIN32(dwError);
        dbgprint(L"SceDcPromoCreateGPOsInSysvol failed %X\n", hr);
        goto end;
    }

    if ( global->RestoreType & GLOBALS::RESTORE_DC )
    {
        ULONG ulProfilePathLength;

        // 
        //                    profile path + '\inf\defdcgpo' + '\0'
        //

        ulProfilePathLength = MAX_PATH     +   lstrlen(L"\\inf\\defdcgpo.inf") + 1;
        szProfilePath = (WCHAR *) LocalAlloc( LPTR, sizeof(WCHAR) * ulProfilePathLength);
        if ( NULL == szProfilePath )
        {
            hr = E_OUTOFMEMORY;
            PrintError(hr);
            goto end;
        }
        
        Length = GetWindowsDirectory(szProfilePath, MAX_PATH);
        if (0 == Length)
        {
            hr = HRESULT_FROM_WIN32(dwError);
            dbgprint(L"GetWindowsDirectory failed %X\n", hr);
            LocalFree(szProfilePath);
            goto end;
        }
        
        hr = StringCchPrintf(szProfilePath, ulProfilePathLength, L"%s\\inf\\defdcgpo.inf", szProfilePath);
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }
        
        if ( FilePresent(szProfilePath) )
        {
            hr = StringCchPrintf(TempPath, 
                                 uLength, 
                                 L"%s\\%s\\Policies\\%s" FILE_GPTTMPLINF,
                                 global->SysVolPath, 
                                 global->pDomainInfo->DomainNameDns, 
                                 DC_GUID);
            if (FAILED(hr)) 
            {
                PrintError(hr);
                goto end;
            }
            
            hr = CreateSecurityTemplate(szProfilePath, TempPath);    
            if (FAILED(hr))
            {
                hr = HRESULT_FROM_WIN32(dwError);
                dbgprint(L"createSecurityTemplate failed %X\n", hr);
                LocalFree(szProfilePath);
                goto end;
            }        
        }
        LocalFree(szProfilePath);
    }

    if (global->RestoreType & GLOBALS::RESTORE_DOMAIN) 
    {
        hr = StringCchPrintf(TempPath, 
                             uLength, 
                             L"%s\\%s\\Policies\\%s" FILE_GPTINI,
                             global->SysVolPath, 
                             global->pDomainInfo->DomainNameDns, 
                             DOMAIN_GUID );
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        hr = StringCchPrintf(szVersionNo,
                             MAX_VERSION_LENGTH,
                             L"%d", 
                             global->lDDPVersionNo);
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        bError = WritePrivateProfileString(L"General", L"Version", szVersionNo, TempPath);
        if (bError == FALSE) 
        {
            dwError = GetLastError();
            PrintError(TempPath, global->DirWrite);
            hr = HRESULT_FROM_WIN32(dwError);
            goto end;
        }
    }

    if (global->RestoreType & GLOBALS::RESTORE_DC) 
    {
        hr = StringCchPrintf(TempPath, 
                             uLength,
                             L"%s\\%s\\Policies\\%s" FILE_GPTINI, 
                             global->SysVolPath, 
                             global->pDomainInfo->DomainNameDns, 
                             DC_GUID );
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        hr = StringCchPrintf(szVersionNo, 
                             MAX_VERSION_LENGTH,
                             L"%d", 
                             global->lDDCPVersionNo);
        if (FAILED(hr)) 
        {
            PrintError(hr);
            goto end;
        }

        bError = WritePrivateProfileString(L"General", L"Version", szVersionNo, TempPath);
        if (bError == FALSE) 
        {
            dwError = GetLastError(); 
            PrintError(TempPath, global->DirWrite);
            hr = HRESULT_FROM_WIN32(dwError);
            goto end;
        }
    }

    if (global->RestoreType & GLOBALS::RESTORE_DOMAIN)
    {
        wprintf(global->DDPSuccess);
    }

    if (global->RestoreType & GLOBALS::RESTORE_DC)
    {
        wprintf(global->DDCPSuccess);
    }

    hr = S_OK;

 end:
    
    if(TempPath != NULL)
    {
        LocalFree(TempPath);
    }

    if (Key != NULL) 
    {
        RegCloseKey(Key);
        Key = NULL;
    }
    
    if (FAILED(hr))
    {
        wprintf(global->ToolFailed);
    }

    if (global->pGPO) 
    {
        global->pGPO->Release();
    }

    CoUninitialize();

    return hr;
    
}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\chkadm\chkadm.c ===
#include <windows.h>
#include <stdio.h>


#define KEYWORD_BUF_SIZE             100
#define STRINGS_BUF_SIZE            8096


typedef struct _ITEM {
    TCHAR szKeyword[KEYWORD_BUF_SIZE];
    struct _ITEM * pNext;
} ITEM, *LPITEM;



LPITEM g_KeywordList = NULL;


LPTSTR GetStringSection (LPCTSTR lpFileName)
{
    DWORD dwSize, dwRead;
    LPTSTR lpStrings;


    //
    // Read in the default strings section
    //

    dwSize = STRINGS_BUF_SIZE;
    lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

    if (!lpStrings)
    {
        printf("(1) Failed to allocate memory with %d\n", GetLastError());
        return NULL;
    }


    do {
        dwRead = GetPrivateProfileSection (TEXT("Strings"),
                                           lpStrings,
                                           dwSize, lpFileName);

        if (dwRead != (dwSize - 2))
        {
            break;
        }

        GlobalFree (lpStrings);

        dwSize *= 2;
        lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

        if (!lpStrings)
        {
            printf("(2) Failed to allocate memory with %d\n", GetLastError());
            return FALSE;
        }

     }  while (TRUE);


    if (dwRead == 0)
    {
        GlobalFree (lpStrings);
        lpStrings = NULL;
    }

    return lpStrings;
}

BOOL DoesKeywordExist (LPTSTR lpKeyword)
{
    LPITEM lpTemp;

    lpTemp = g_KeywordList;

    while (lpTemp) {

        if (!lstrcmpi(lpKeyword, lpTemp->szKeyword)) {
            return TRUE;
        }

        lpTemp = lpTemp->pNext;
    }

    return FALSE;
}

BOOL AddKeywordToList (LPTSTR lpKeyword)
{
    LPITEM lpTemp;


    lpTemp = LocalAlloc (LPTR, sizeof(ITEM));

    if (!lpTemp) {
        printf("(3) Failed to allocate memory with %d\n", GetLastError());
        return FALSE;
    }


    lstrcpyn (lpTemp->szKeyword, lpKeyword, KEYWORD_BUF_SIZE);
    lpTemp->pNext = g_KeywordList;

    g_KeywordList = lpTemp;

    return TRUE;
}


int __cdecl main( int argc, char *argv[])
{
    LPTSTR lpStrings, lpTemp, lpChar, lpEnd;
    TCHAR szKeyword [KEYWORD_BUF_SIZE];
    DWORD dwIndex;


    if (argc != 2) {
        printf("usage:  chkadm admfile\n");
        return 1;
    }


    lpStrings = GetStringSection(argv[1]);

    if (!lpStrings) {
        printf("No strings, or failure reading strings\n");
        return 1;
    }



    lpTemp = lpStrings;

    while (*lpTemp)
    {

        lpChar = szKeyword;
        dwIndex = 0;

        while (*lpTemp && (*lpTemp != TEXT('=')) && (*lpTemp != TEXT('\r'))
               && (*lpTemp != TEXT('\n')) && (dwIndex < (KEYWORD_BUF_SIZE - 1)) ) {
            *lpChar = *lpTemp;
            lpChar++;
            lpTemp++;
            dwIndex++;
        }

        *lpChar = TEXT('\0');


        if (*lpTemp == TEXT('=')) {

            if (DoesKeywordExist (szKeyword)) {
                printf(TEXT("Duplicate string name for:  %s\n"), szKeyword);
            } else {
                if (!AddKeywordToList(szKeyword)) {
                    return 1;
                }
            }

        } else {
            printf("==================\n");
            printf("\nThe following entry in the [Strings] section does not start with a variable name:\n\n%s\n\n", szKeyword);
            printf("==================\n");
        }


        lpEnd = lpTemp += lstrlen (lpTemp) - 1;
        lpTemp += lstrlen (lpTemp) + 1;

        while (*lpEnd == TEXT('\\')) {
            lpEnd = lpTemp += lstrlen (lpTemp) - 1;
            lpTemp += lstrlen (lpTemp) + 1;
        }
    }



    GlobalFree (lpStrings);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\inc\choosusr.h ===
/*****************************************************************************\
*                                                                             *
* choosusr.h -   choose user dialog function, types, and definitions          *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1993, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CHOOSUSR
#define _INC_CHOOSUSR

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */


#define	MAX_BINS	3

// codes in CHOOSEUSER.dwError
#define	CUERR_NO_ERROR				0
#define	CUERR_BUF_TOO_SMALL			80
#define	CUERR_INVALID_PARAMETER 	81
#define	CUERR_PROVIDER_ERROR		82
#define	CUERR_NO_AB_PROVIDER		83
#define	CUERR_INVALID_AB_PROVIDER	84

// codes in CHOOSEUSER.Flags
#define	CUFLG_USR_ONLY				0x00000001
#define	CUFLG_GRP_ONLY				0x00000002

struct tagCHOOSEUSER
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE    hInstance;
    DWORD   Flags;
	UINT	nBins;
	LPSTR	lpszDialogTitle;
	LPSTR	lpszProvider;
	LPSTR	lpszReserved;
	LPSTR	lpszRemote;
	LPSTR	lpszHelpFile;
	LPSTR	lpszBinButtonText[MAX_BINS];
	DWORD	dwBinValue[MAX_BINS];
	DWORD	dwBinHelpID[MAX_BINS];
	LPBYTE	lpBuf;
	DWORD	cbBuf;
	DWORD	nEntries;	// OUT
	DWORD 	cbData;		// OUT
	DWORD	dwError;	// OUT
	DWORD	dwErrorDetails;	// OUT
};
typedef struct tagCHOOSEUSER CHOOSEUSER;
typedef struct tagCHOOSEUSER FAR *LPCHOOSEUSER;

// codes for CHOOSEUSERENTRY.dwEntryAttributes
#define	CUE_ATTR_USER		0x00000001
#define CUE_ATTR_GROUP		0x00000002
#define	CUE_ATTR_WORLD		0x00000004

struct tagCHOOSEUSERENTRY
{
	LPSTR lpszShortName;
	LPSTR lpszLongName;
	DWORD dwBinAttributes;
	DWORD dwEntryAttributes;
};

typedef struct tagCHOOSEUSERENTRY CHOOSEUSERENTRY;
typedef struct tagCHOOSEUSERENTRY FAR *LPCHOOSEUSERENTRY;

BOOL    WINAPI ChooseUser(CHOOSEUSER FAR*);
typedef BOOL (WINAPI *LPFNCU)(LPCHOOSEUSER);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_CHOOSUSR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\inc\sec32api.h ===
/*****************************************************************/
/**                      Microsoft Windows                      **/
/**             Copyright (C) Microsoft Corp., 1993-5           **/
/*****************************************************************/

/*
    SEC32API.H

    This header file contains declarations for the internal versions
    of the 32-bit Access API, as exported by FILESEC.386.  It also
    contains constant definitions used by securty components

    This file relies, in part, on NETVXD.H and VXDCALL.H.

    This file must be H2INC-able.

    FILE HISTORY:
        dannygl 09/25/93    Initial version
        dannygl 09/29/93    Add NetAccessSetInfo
        dannygl 10/04/93    Add security-related string constants
        dannygl 01/17/94    Replace Win32 services with IOCtls
        dannygl 02/10/94    Add NetAccess arg count constants
        dannygl 02/16/94    Update registry string constants
        dannygl 11/17/94    Add Logon2 API (supported by MSSP only)
*/


// Registry string constants
// Security provider information (in HKEY_LOCAL_MACHINE)
#define REGKEY_SP_CONFIG        "Security\\Provider"

#define REGVAL_SP_PLATFORM  "Platform_Type"
#define REGVAL_SP_CONTAINER "Container"
#define REGVAL_SP_ABSERVER  "Address_Server"
#define REGVAL_SP_ONEOFFABSERVER  "One_Off_Address_Server"
#define REGVAL_SP_ABPROVIDER    "Address_Book"
#define	REGVAL_SP_NO_SORT	"NoSort"

// Obsolescent definition -- will be deleted soon
//#define REGVAL_SP_PTPROVIDER    "Pass_Through"

// Definitions for the IOControl interface that FILESEC uses for Win32 API
// support

#define FSIOC_API_Base      100

/*XLATOFF*/

typedef enum
{
    FSIOC_AccessAddAPI = FSIOC_API_Base,
    FSIOC_AccessCheckAPI,
    FSIOC_AccessDelAPI,
    FSIOC_AccessEnumAPI,
    FSIOC_AccessGetInfoAPI,
    FSIOC_AccessGetUserPermsAPI,
    FSIOC_AccessSetInfoAPI
} FSIOC_Ordinal;

/*XLATON*/

// Important: We define this constant separately because we need it
// to be H2INC'able.  It must match the above enumerated type.
#define FSIOC_API_Count     7

// Arg counts for Access functions
//
// Note: These constants are defined for readability purposes and should not
// be modified independently.
#define Argc_AccessAdd          3
#define Argc_AccessCheck        4
#define Argc_AccessDel          1
#define Argc_AccessEnum         7
#define Argc_AccessGetInfo      5
#define Argc_AccessGetUserPerms 3
#define Argc_AccessSetInfo      5

// Definitions used by the Security Provider VxDs to expose interfaces
// to Win32 code via IOCtls

#define SPIOC_API_Base      100

/*XLATOFF*/

typedef enum
{
    SPIOC_PreLogonAPI = SPIOC_API_Base,
    SPIOC_LogonAPI,
    SPIOC_LogoffAPI,
    SPIOC_GetFlagsAPI,
    SPIOC_GetContainerAPI,
    SPIOC_NW_GetUserObjectId,   // NWSP only
    SPIOC_Logon2API,            // Currently MSSP only
    SPIOC_DiscoverDC            // MSSP only
} SPIOC_Ordinal;

/*XLATON*/

// Important: We define this constant separately because we need it
// to be H2INC'able.  It must match the above enumerated type.
#define SPIOC_API_Count     8

/*XLATOFF*/

typedef struct
{
    unsigned char *pbChallenge;
    unsigned long *pcbChallenge;
} AUTHPRELOGONINFO, *PAUTHPRELOGONINFO;

typedef struct
{
    const char *pszContainer;
    const char *pszUserName;
    const char *pszClientName;
    const unsigned char *pbResponse;
    unsigned long cbResponse;
    const unsigned char *pbChallenge;
    unsigned long cbChallenge;
    unsigned long fResponseType;
    unsigned long *pfResult;
} AUTHLOGONINFO, *PAUTHLOGONINFO;

typedef struct
{
    const char *pszContainer;
    char *pszContainerValidated;
    const char *pszUserName;
    char *pszUserValidated;
    const char *pszClientName;
    const unsigned char *pbResponse;
    unsigned long cbResponse;
    const unsigned char *pbResponse2;
    unsigned long cbResponse2;
    const unsigned char *pbChallenge;
    unsigned long cbChallenge;
    unsigned long *pfFlags;
    unsigned long *pfResult;
} AUTHLOGON2INFO, *PAUTHLOGON2INFO;

typedef struct
{
    const char *pszContainer;
    const char *pszUserName;
    const char *pszClientName;
} AUTHLOGOFFINFO, *PAUTHLOGOFFINFO;

typedef struct
{
    unsigned long *pdwFlags;
    unsigned long *pdwSecurity;
} AUTHGETFLAGS, *PAUTHGETFLAGS;

typedef struct
{
    char *pszContainer;
    unsigned long *pcbContainer;
} AUTHGETCONTAINER, *PAUTHGETCONTAINER;

typedef struct
{
    char *pszUserName;
    unsigned long dwObjectId;
} AUTHNWGETUSEROBJECTID, *PAUTHNWGETUSEROBJECTID;

typedef struct
{
    const char *pszDomain;
    char *pszDCs;   // Concatenated strings, ended with an extra null
    unsigned long *pcbDCs;
} AUTHDISCOVERDC, *PAUTHDISCOVERDC;

/*XLATON*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\perftest\gp\main.c ===
#include <windows.h>
#include <stdio.h>

DWORD DeleteGroupPolicyHistory( HKEY hkRoot );
LONG DeleteMachineUserPolicyHistoryKey(HANDLE hToken);

#define MACHINE_USER_GP_KEY L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy"

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;


LONG
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

VOID
RtlFreeUnicodeString(
    PUNICODE_STRING UnicodeString
    );

BOOL
ProcessGPOs( void* );

void
ReadPerfParams  (
                DWORD*  pIterations,
                BOOL*   pbDeleteHistory,
                BOOL*   pbSkipFirstIteration,
                BOOL*   pbUser,
                BOOL*   pbMach,
                WCHAR*  szPath
                );

void
MeasurePerf( void* lpGPOInfo, HANDLE hToken, BOOL bMach )
{
    LARGE_INTEGER   Freq;
    LARGE_INTEGER   Start, Stop, Total;
    HKEY            hkRoot;
    DWORD           Iterations;
    BOOL            bDeleteHistory;
    BOOL            bSkipFirstIteration;
    BOOL            bDoMach;
    BOOL            bDoUser;
    WCHAR           szPath[MAX_PATH+1];

    ReadPerfParams  (
                    &Iterations,
                    &bDeleteHistory,
                    &bSkipFirstIteration,
                    &bDoUser,
                    &bDoMach,
                    szPath
                    );

    if ( ( bDoUser && !bMach ) || ( bDoMach && bMach ) )
    {
        FILE*   file;
        if ( bMach )
        {
            lstrcat( szPath, L"MachPerf.log" );
        }
        else
        {
            lstrcat( szPath, L"UserPerf.log" );
        }

        file = _wfopen( szPath, L"a+" );
        
        if ( file )
        {
            DWORD n;
            
            fwprintf( file, L"\n" );
            
            if ( RegOpenCurrentUser( KEY_READ, &hkRoot ) == ERROR_SUCCESS )
            {
                QueryPerformanceFrequency( &Freq );
                if ( !Freq.QuadPart )
                {
                    Freq.QuadPart = 1;
                }
                
                Total.QuadPart = 0;

                fprintf( file, "\nNew measurement: %d iterations\n\n", Iterations );

                for ( n = 1; n <= Iterations; n++ )
                {
                    if ( bDeleteHistory )
                    {
                        DeleteGroupPolicyHistory( hkRoot );
                        DeleteMachineUserPolicyHistoryKey(hToken);
                    }

                    QueryPerformanceCounter( &Start );
                    ProcessGPOs(lpGPOInfo);
                    QueryPerformanceCounter( &Stop );

                    if ( bSkipFirstIteration && (1 == n) )
                    {
                        bSkipFirstIteration = FALSE;
                        n--;
                    }
                    else
                    {
                        Total.QuadPart += Stop.QuadPart - Start.QuadPart;
                    }
                    fwprintf(
                            file,
                            L"%d\t%f\t%f\n",
                            n,
                            ((double)Start.QuadPart / (double)Freq.QuadPart) * (double) 1000.0,
                            ((double)Stop.QuadPart / (double)Freq.QuadPart) * (double) 1000.0
                            );
                }
                fprintf(
                        file,
                        "Time = %f milliseconds per iteration\n\n",
                        ((double)Total.QuadPart / (double)Freq.QuadPart) / (double)Iterations * (double) 1000.0
                        );
                RegCloseKey( hkRoot );
            }

            fclose( file );
        }
    }
}

DWORD DeleteGroupPolicyHistory( HKEY hkRoot )
{
    return RegDelnode( hkRoot, L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History" );
}

LONG DeleteMachineUserPolicyHistoryKey(HANDLE hToken)
{
    UNICODE_STRING SidString;
    BOOL           bStatus;
    DWORD          Size;
    UCHAR          Buffer[sizeof(TOKEN_USER) + sizeof(SID) + ((SID_MAX_SUB_AUTHORITIES-1) * sizeof(ULONG))];
    LONG           Status;
    HKEY           hKeyGP;
    HKEY           hKeyUserGP;
    PTOKEN_USER    pTokenUser;

    hKeyGP = NULL;
    hKeyUserGP = NULL;

    Size = sizeof(Buffer);

    pTokenUser = (PTOKEN_USER) Buffer;

    bStatus = GetTokenInformation(
        hToken,
        TokenUser,
        pTokenUser,
        Size,
        &Size );

    if ( ! bStatus )
    {
        return GetLastError();
    }

    Status = RtlConvertSidToUnicodeString(
        &SidString,
        pTokenUser->User.Sid,
        TRUE );

    if (ERROR_SUCCESS != Status) {
        return Status;
    }

    Status = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        MACHINE_USER_GP_KEY,
        0,
        KEY_READ,
        &hKeyGP);

    if (ERROR_SUCCESS != Status) {
        goto cleanup;
    }

    Status = RegOpenKeyEx (
        hKeyGP,
        SidString.Buffer,
        0,
        KEY_ALL_ACCESS,
        &hKeyUserGP );

    if (ERROR_SUCCESS != Status) {
        goto cleanup;
    }

    Status = RegDelnode(
        hKeyUserGP,
        L"History");

cleanup:

    if (hKeyGP) {
        RegCloseKey(hKeyGP);
    }

    if (hKeyUserGP) {
        RegCloseKey(hKeyUserGP);
    }

    RtlFreeUnicodeString( &SidString );

    return Status;

}

void
ReadPerfParams  (
                DWORD*  pIterations,
                BOOL*   pbDeleteHistory,
                BOOL*   pbSkipFirstIteration,
                BOOL*   pbUser,
                BOOL*   pbMach,
                WCHAR*  szPath
                )
{
    HKEY    hKey;

    *pIterations = 5;
    *pbDeleteHistory = TRUE;
    *pbSkipFirstIteration = TRUE;
    *pbUser = TRUE;
    *pbMach = TRUE;
    lstrcpy( szPath, L"C:\\" );
    
    if ( RegOpenKeyEx   (
                        HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPPerf",
                        0,
                        KEY_READ,
                        &hKey
                        ) == ERROR_SUCCESS )
    {
        DWORD   dwType = 0;
        DWORD   dwData = 0;
        DWORD   cb = sizeof( DWORD );
        
        if ( RegQueryValueEx( hKey, L"Iterations", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pIterations = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"DeleteHistory", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbDeleteHistory = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"SkipFirst", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbSkipFirstIteration = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"User", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbUser = dwData;
        }
        cb = sizeof( DWORD );
        if ( RegQueryValueEx( hKey, L"Machine", 0, &dwType, (BYTE*)&dwData, &cb ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            *pbMach = dwData;
        }
        cb = MAX_PATH;
        if ( !( RegQueryValueEx( hKey, L"Path", 0, &dwType, (BYTE*)szPath, &cb ) == ERROR_SUCCESS && dwType == REG_SZ ) )
        {
            lstrcpy( szPath, L"C:\\" );
        }
        
        RegCloseKey( hKey );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\perftest\polcreate\main.cxx ===
//*************************************************************
//
//  Group Policy Performance test program
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
//  History:    10-Dec-98   SitaramR    Created from DKays version
//
//*************************************************************

#define UNICODE

#include <windows.h>
#define SECURITY_WIN32
#include <security.h>
#include <stdio.h>
#include <ole2.h>
#include <prsht.h>
#include <initguid.h>
#include <gpedit.h>
#include <iads.h>
#include <adshlp.h>

const MAX_BUF_LEN = 2056;  // Static buffer size
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

void PrintHelp();
BOOL CreateTest2GPOs( WCHAR *pwszDomain );
BOOL CreateTest3GPOs( WCHAR *pwszDomain );
BOOL CreateTest4GPOs( WCHAR *pwszDomain );
BOOL CreateTest5GPOs( WCHAR *pwszDomain );

GUID guidExtensions[] = {  // List of GP client side extension guids
                           { 0x25537BA6, 0x77A8, 0x11D2, {0x9B, 0x6C, 0x00, 0x00, 0xF8, 0x08, 0x08, 0x61}},
                           { 0x35378EAC, 0x683F, 0x11D2, {0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2}},
                           { 0x3610eda5, 0x77ef, 0x11d2, {0x8d, 0xc5, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x66}},
                           { 0x42B5FAAE, 0x6536, 0x11d2, {0xAE, 0x5A, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xE3}},
                           { 0x827d319e, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a}},
                           { 0xb1be8d72, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a}},
                           { 0xc6dc5466, 0x785a, 0x11d2, {0x84, 0xd0, 0x00, 0xc0, 0x4f, 0xb1, 0x69, 0xf7}},
                        };
GUID guidSnapin = { 0xdd7f2e0f, 0x9089, 0x11d2, {0xb2, 0x81, 0x00, 0xc0, 0x4f, 0xbb, 0xcf, 0xa2 }};


int __cdecl main( int argc, char **argv )
{
    for ( int n = 1; n < argc; n++ )
    {
        if ( lstrcmpA(argv[n], "-help") == 0
             || lstrcmpA(argv[n], "/help") == 0
             || lstrcmpA(argv[n], "-?") == 0
             || lstrcmpA(argv[n], "/?") == 0 )
        {
            PrintHelp();
            return 0;
        }

        printf( "Usage: polcreat or polcreat /? to see help info" );
        return 0;
    }

    WCHAR wszUser[MAX_BUF_LEN];
    ULONG ulSize = ARRAYSIZE(wszUser);
    BOOL bOk =  GetUserNameEx( NameFullyQualifiedDN, wszUser, &ulSize  );

    if ( !bOk )
    {
        printf( "GetUserNameEx failed with 0x%x\n", GetLastError() );
        return 0;
    }

    //
    // Get domain path
    //

    WCHAR wszDomain[MAX_BUF_LEN];

    lstrcpy( wszDomain, L"LDAP://" );

    BOOL bFound = FALSE;
    WCHAR *pchCur = wszUser;

    while ( pchCur && *pchCur != 0 && lstrlen(pchCur) > 3 )
    {
        if ( CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                            pchCur, 3, TEXT("DC="), 3) == CSTR_EQUAL)
        {
            bFound = TRUE;
            lstrcat( wszDomain, pchCur );
            break;
        }

        pchCur++;
    }

    if ( !bFound )
    {
        printf( "Unable to create domain path from user path %ws\n", wszUser );
        return 0;
    }

    printf( "Using Domain path, %ws\n", wszDomain );

    CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

    printf( "Creating Test2 GPOs\n" );
    bOk = CreateTest2GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test2 GPOs\n" );
        return 0;
    }

    printf( "Creating Test3 GPOs\n" );
    bOk = CreateTest3GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test3 GPOs\n" );
        return 0;
    }

    printf( "Creating Test4 GPOs\n" );
    bOk = CreateTest4GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test4 GPOs\n" );
        return 0;
    }

    printf( "Creating Test5 GPOs\n" );
    bOk = CreateTest5GPOs( wszDomain );
    if ( !bOk )
    {
        printf( "Failed to create test5 GPOs\n" );
        return 0;
    }

    printf( "Successfully created all OUs and GPOs" );

    return 0;
}

BOOL CreateOU( WCHAR *pwszParent, WCHAR *pwszOU )
{
    //
    // Bind to the parent container and create OU
    //
    IADsContainer *pContainer;
    IDispatch *pIDispatch;
    IADs *pADs;

    HRESULT hr = ADsGetObject( pwszParent,
                               IID_IADsContainer,
                               (void**)&pContainer);
    if ( hr != S_OK )
    {
        printf( "Failed to bind to parent container %ws with 0x%x\n", pwszParent, hr );
        return FALSE;
    }

    hr = pContainer->Create(L"organizationalUnit",
                            pwszOU,          // L"OU=OU1",
                            &pIDispatch );
    if ( hr != S_OK )
    {
        printf( "Failed to bind to create %ws with 0x%x\n", pwszOU, hr );
        return FALSE;
    }

    hr = pIDispatch->QueryInterface( IID_IADs, (void **)&pADs);
    if ( hr != S_OK )
    {
        printf( "Failed to QI %ws with 0x%x\n", pwszOU, hr );
        return FALSE;
    }

    hr = pADs->SetInfo();
    if ( hr != S_OK )
    {
        printf( "Failed to SetInfo %ws with 0x%x\n", pwszOU, hr );
        return FALSE;
    }

    return TRUE;
}


BOOL CreatePolicies( WCHAR *pwszDomain, WCHAR *pwszOUPath, WCHAR *pwszOUName, ULONG cPolicies )
{
    //
    // cPolicies must be a multiple of 7 because there are 7 client side
    // extensions.
    //

    ULONG cPols = cPolicies / 7;
    WCHAR wszGPOName[MAX_BUF_LEN];
    WCHAR wszGPOPath[MAX_BUF_LEN];
    WCHAR wszNum[20];
    LPGROUPPOLICYOBJECT pGPO;

    for ( ULONG i=0; i<cPols; i++ )
    {
        for ( ULONG j=0; j<7; j++ )
        {
            HRESULT hr = CoCreateInstance( CLSID_GroupPolicyObject,
                                           NULL,
                                           CLSCTX_SERVER,
                                           IID_IGroupPolicyObject,
                                           (void**)&pGPO );
            if ( hr != S_OK )
            {
                printf( "CoCreateInstance of pGPO failed 0x%x\n", hr );
                return FALSE;
            }

            wcscpy( wszGPOName, pwszOUName );
            wsprintf( wszNum, L"%d%d", i, j );
            wcscat( wszGPOName, wszNum );

            hr = pGPO->New( pwszDomain, wszGPOName, FALSE );
            if ( hr != S_OK )
            {
                printf( "Creating new GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = pGPO->GetPath( wszGPOPath, ARRAYSIZE(wszGPOPath) );
            if ( hr != S_OK )
            {
                printf( "Getting GPO path of %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = pGPO->Save( TRUE, TRUE, &guidExtensions[j], &guidSnapin ); // machine policy
            if ( hr != S_OK )
            {
                printf( "Saving GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = pGPO->Save( FALSE, TRUE, &guidExtensions[j], &guidSnapin ); // user policy
            if ( hr != S_OK )
            {
                printf( "Saving GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            hr = CreateGPOLink( wszGPOPath, pwszOUPath, FALSE );
            if ( hr != S_OK )
            {
                printf( "Linking GPO %ws failed 0x%x\n", wszGPOName, hr );
                return FALSE;
            }

            pGPO->Release();
        }   // for j
    }   // for i

    return TRUE;
}


BOOL MakeLdapPath( WCHAR *pwszParent, WCHAR *pwszOU, WCHAR *pwszChild )
{
    //
    // Make ldap path to child by prepending OU to parent path
    //

    wcscpy( pwszChild, L"LDAP://" );
    wcscat( pwszChild, pwszOU );
    wcscat( pwszChild, L"," );
    wcscat( pwszChild, &pwszParent[7] );

    return TRUE;
}

BOOL CreateTest2GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN];
    WCHAR wszChild[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );

    // OU_L1_P7_T2
    BOOL bOk = CreateOU( wszParent, L"OU=OU_L1_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L1_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L1_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L1_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L1_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L2_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L1_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L2_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L2_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L3_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L2_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L3_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L3_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L3_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L3_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L3_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L4_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L3_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L4_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L4_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L4_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L4_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L4_P0_T2");
    if ( !bOk )
        return FALSE;

    // OU_L5_P7_T2
    MakeLdapPath( wszParent, L"OU=OU_L4_P0_T2", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L5_P7_T2");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L5_P7_T2", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L5_P7_T2_GP", 7);
    if ( !bOk )
        return FALSE;

    // OU_L5_P0_T2
    bOk = CreateOU( wszParent, L"OU=OU_L5_P0_T2");
    if ( !bOk )
        return FALSE;

    return TRUE;
}

BOOL CreateTest3GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN];
    WCHAR wszChild[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );

    // OU_L1_P0_T3
    BOOL bOk = CreateOU( wszParent, L"OU=OU_L1_P0_T3");
    if ( !bOk )
        return FALSE;

    // OU_L2_P14_T3
    MakeLdapPath( wszParent, L"OU=OU_L1_P0_T3", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P14_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P14_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P14_T3_GP", 14 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P28_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P28_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P28_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P28_T3_GP", 28 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P56_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P56_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P56_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P56_T3_GP", 56 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P70_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P70_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P70_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P70_T3_GP", 70 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P98_T3
    bOk = CreateOU( wszParent, L"OU=OU_L2_P98_T3");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P98_T3", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P98_T3_GP", 98 );
    if ( !bOk )
        return FALSE;

    return TRUE;
}


BOOL CreateTest4GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN];
    WCHAR wszChild[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );

    // OU_L1_P7_T4
    BOOL bOk = CreateOU( wszParent, L"OU=OU_L1_P7_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L1_P7_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L1_P7_T4_GP", 7 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P7_T4
    MakeLdapPath( wszParent, L"OU=OU_L1_P7_T4", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P7_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P7_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P7_T4_GP", 7 );
    if ( !bOk )
        return FALSE;

    // OU_L1_P14_T4
    wcscpy( wszParent, pwszDomain );
    bOk = CreateOU( wszParent, L"OU=OU_L1_P14_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L1_P14_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L1_P14_T4_GP", 14 );
    if ( !bOk )
        return FALSE;

    // OU_L2_P14_T4
    MakeLdapPath( wszParent, L"OU=OU_L1_P14_T4", wszChild );
    wcscpy( wszParent, wszChild );

    bOk = CreateOU( wszParent, L"OU=OU_L2_P14_T4");
    if ( !bOk )
        return FALSE;

    MakeLdapPath( wszParent, L"OU=OU_L2_P14_T4", wszChild );
    bOk = CreatePolicies( pwszDomain, wszChild, L"OU_L2_P14_T4_GP", 14 );
    if ( !bOk )
        return FALSE;

    return TRUE;
}

BOOL CreateTest5GPOs( WCHAR *pwszDomain )
{
    WCHAR wszParent[MAX_BUF_LEN*10];
    WCHAR wszChild[MAX_BUF_LEN*10];
    WCHAR wszOUString[MAX_BUF_LEN];

    wcscpy( wszParent, pwszDomain );
    for ( unsigned i=1; i<60; i++ )
    {
        wsprintf( wszOUString, L"OU=OU_L%d_P0_T5", i );
        BOOL bOk = CreateOU( wszParent, wszOUString );
        if ( !bOk )
            return FALSE;
        
        MakeLdapPath( wszParent, wszOUString, wszChild );
        wcscpy( wszParent, wszChild );
    }

    return TRUE;
}


void PrintHelp()
{
    printf( "Usage: polcreat to create OUs and GPOs or,\n       polcreat /? to get performance test cases\n\n" );\

    printf("   TEST SCENARIOS (Naming covention is: OU_Level#_P#GPOs_T#test)\n");
    printf("\nTest 1:\n");
    printf("   1. User at Domain level\n\n\n");

    printf("Test 2:\n");
    printf("   1. User at OU_L1_P7_T2\n");
    printf("   2. User at OU_L1_P0_T2, OU_L2_P7_T2\n");
    printf("   3. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P7_T2\n");
    printf("   4. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P0_T2, OU_L4_P7_T2\n");
    printf("   5. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P0_T2, OU_L4_P0_T2, OU_L5_P7_T2\n");
    printf("   5. User at OU_L1_P0_T2, OU_L2_P0_T2, OU_L3_P0_T2, OU_L4_P0_T2, OU_L5_P0_T2\n\n\n");

    printf("Test 3:\n");
    printf("   1. User at OU_L1_P0_T3, OU_L2_P14_T3\n");
    printf("   2. User at OU_L1_P0_T3, OU_L2_P28_T3\n");
    printf("   3. User at OU_L1_P0_T3, OU_L2_P70_T3\n\n\n");

    printf("Test 4:\n");
    printf("   1. User at OU_L1_P7_T4, OU_L2_P7_T4\n");
    printf("   2. User at OU_L1_P14_T4, OU_L2_P14_T4\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\perftest\gpolist\gpolist.c ===
//*************************************************************
//
//  Group Policy Performance test program
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
//  History:    11-Jan-99   SitaramR    Created
//
//*************************************************************

#include <windows.h>
#include <userenv.h>
#include <tchar.h>
#include <stdio.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    PGROUP_POLICY_OBJECT pGPOList;
    LARGE_INTEGER   Freq;
    LARGE_INTEGER   Start, Stop, Total;
    DWORD i;
    DWORD nIterations = 10;

    if ( !OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken) )
    {
        printf("Unable to get process token\n");
        return 0;
    }

    QueryPerformanceFrequency( &Freq );

    Total.QuadPart = 0;

    printf( "Starting %d iterations\n", nIterations );

    for ( i=0; i<nIterations; i++) {

        QueryPerformanceCounter( &Start );;

        if (GetGPOList (hToken, NULL, NULL, NULL, 0, &pGPOList))
        {

            QueryPerformanceCounter( &Stop );

            Total.QuadPart += Stop.QuadPart - Start.QuadPart;

            FreeGPOList (pGPOList);
        }
        else
        {
            printf( "GetGPOList failed\n" );
            return 0;
        }
    }

    CloseHandle (hToken);

    printf( "GetGPOList time = %f milliseconds per iteration\n",
            ((float)Total.QuadPart / (float)Freq.QuadPart) * 1000 / nIterations );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\global.h ===
//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#ifdef DBG

#define DEBUGMSG(x) _DebugMsg x

VOID _DebugMsg(UINT mask, PCSTR pszMsg, ...);

#define DMASSERT(x) if (!(x)) \
                        _DebugMsg(DM_ASSERT,"profmap.dll assertion " #x " failed\n, line %u of %s", __LINE__, TEXT(__FILE__));

#else

#define DEBUGMSG(x)
#define DMASSERT(x)

#endif

//
// userenv.c
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define ByteCountW(x)    (lstrlenW(x) * sizeof(WCHAR))
#define SizeOfStringW(x) ((lstrlenW(x) + 1) * sizeof(WCHAR))


#define PROFILE_LIST_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define PROFILE_IMAGE_VALUE_NAME     TEXT("ProfileImagePath")
#define PROFILE_GUID                 TEXT("Guid")
#define PROFILE_GUID_PATH            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileGuid")
#define WINDOWS_POLICIES_KEY         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")
#define ROOT_POLICIES_KEY            TEXT("Software\\Policies")


BOOL OurConvertSidToStringSid (PSID Sid, PWSTR *SidString);
VOID DeleteSidString (PWSTR SidString);

PACL CreateDefaultAcl (PSID pSid);
VOID FreeDefaultAcl (PACL Acl OPTIONAL);

BOOL GetProfileRoot (PSID Sid, PWSTR ProfileDir, UINT cchBuffer);
BOOL UpdateProfileSecurity (PSID Sid);
BOOL DeleteProfileGuidSettings (HKEY hProfile);

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);

LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile);
BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey);
BOOL SetupNewHive(LPTSTR lpSidString, PSID pSid);
DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD);
BOOL SecureUserKey(LPTSTR lpKey, PSID pSid);
LPWSTR ProduceWFromA(LPCSTR pszA);
BOOL IsUserAnAdminMember(HANDLE hToken);

VOID  RegistrySearchAndReplaceW (HKEY hRoot, PCWSTR szKey, PCWSTR Search, PCWSTR Replace);
PWSTR StringSearchAndReplaceW (PCWSTR SourceString, PCWSTR SearchString, PCWSTR ReplaceString, DWORD* pcbNewString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\debug.c ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "pch.h"

VOID
_DebugMsg (
    UINT mask,
    PCSTR Format,
    ...
    )
{
    va_list args;
    DWORD Error;
    WCHAR Output[2048];
    PWSTR UnicodeFormat;
    UINT Size;
    HRESULT hr;

    Error = GetLastError();

    va_start (args, Format);

    Size = (lstrlenA (Format) + 1) * sizeof (WCHAR);

    UnicodeFormat = LocalAlloc (LPTR, Size);
    if (!UnicodeFormat) {
        SetLastError (Error);
        return;
    }

    MultiByteToWideChar (CP_ACP, 0, Format, -1, UnicodeFormat, Size/sizeof(WCHAR));

    hr = StringCchVPrintf(Output, ARRAYSIZE(Output) - 3, UnicodeFormat, args);
    if (FAILED(hr))
        goto Exit;
    hr = StringCchCat(Output, ARRAYSIZE(Output), L"\r\n");
    if (FAILED(hr))
        goto Exit;
    OutputDebugStringW (Output);

Exit:

    if (mask == DM_ASSERT) {
        DebugBreak();
    }

    va_end (args);

    LocalFree (UnicodeFormat);

    SetLastError (Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\policy\polsetup\polsetup.c ===
//*************************************************************
//  File name: POLSETUP.C
//
//  Description:  Uninstall program for the Policy Editor
//
//  Command Line Options:
//
//          No options installs the policy editor
//      -u  Uninstalls the policy editor
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>

//
// Platform specific command lines
//

#define NT_INST_CMD    TEXT("rundll32 syssetup.dll,SetupInfObjectInstallAction DefaultInstall 132 %s")
#define WIN_INST_CMD   TEXT("rundll setupx.dll,InstallHinfSection DefaultInstall 132 %s")

#define NT_UNINST_CMD  TEXT("rundll32 syssetup.dll,SetupInfObjectInstallAction POLEDIT_remove 4 poledit.inf")
#define WIN_UNINST_CMD TEXT("rundll setupx.dll,InstallHinfSection POLEDIT_remove 4 poledit.inf")


//
// ParseCmdLine
//
// Returns TRUE for uninstall
//         FALSE for normal install
//

BOOL ParseCmdLine(LPCTSTR lpCmdLine)
{

    while( *lpCmdLine && *lpCmdLine != TEXT('-') && *lpCmdLine != TEXT('/')) {
        lpCmdLine++;
    }

    if (!(*lpCmdLine)) {
        return FALSE;
    }

    lpCmdLine++;

    if ( (*lpCmdLine == TEXT('u')) || (*lpCmdLine == TEXT('U')) ) {
        return TRUE;
    }

    return FALSE;
}



int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;
    TCHAR szCmdLine[MAX_PATH + MAX_PATH];
    OSVERSIONINFO ver;
    BOOL bNT, bUninstall = FALSE;
    TCHAR szPoleditInf[MAX_PATH];
    LPTSTR lpFileName;


    //
    // Determine if we are running on Windows NT
    //

    ver.dwOSVersionInfoSize = sizeof(ver);
    if (GetVersionEx(&ver)) {
        bNT = (ver.dwPlatformId == VER_PLATFORM_WIN32_NT);
    } else {
        bNT = FALSE;
    }


    //
    // Parse command line
    //

    if (ParseCmdLine(GetCommandLine())) {
        bUninstall = TRUE;
    }


    //
    // Choose the correct command line
    //

    if (bUninstall) {
        if (bNT) {
            lstrcpy (szCmdLine, NT_UNINST_CMD);
        } else {
            lstrcpy (szCmdLine, WIN_UNINST_CMD);
        }
    } else {

        if (!SearchPath (NULL, TEXT("poledit.inf"), NULL, MAX_PATH,
                    szPoleditInf, &lpFileName)) {
            return 1;
        }

        if (bNT) {
            wsprintf (szCmdLine, NT_INST_CMD, szPoleditInf);
        } else {
            wsprintf (szCmdLine, WIN_INST_CMD, szPoleditInf);
        }
    }


    //
    // Spawn the real setup program
    //

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = NULL;
    si.lpDesktop = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWNORMAL;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;


    if (CreateProcess(NULL, szCmdLine, NULL, NULL, FALSE,
                      NORMAL_PRIORITY_CLASS, NULL, NULL,
                      &si, &ProcessInformation)) {

        WaitForSingleObject(ProcessInformation.hProcess, 30000);
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        return 0;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\pch.h ===
#ifdef UNICODE

#ifndef _UNICODE
#define _UNICODE
#endif

#else

#ifndef _MBCS
#define _MBCS
#endif

#endif

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <strsafe.h>
#include <sddl.h>

#define _USERENV_
#include <userenv.h>
#include <userenvp.h>
#include <profmapp.h>

#include <lm.h>
#include <aclapi.h>

#include "global.h"

#include <ntrpcp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\rpc\$(O)\$(@F)
    copy ..\rpc\$(O)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\resource.h ===
// empty
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\regrep.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    regrep.c

Abstract:

    Implements a registry search/replace tool.

Author:

    Jim Schmidt (jimschm) 19-Apr-1999

Revision History:

    jimschm     26-May-1999 Moved from win9xupg, ported to use different
                            utilities
    Santanuc    14-Feb-2002 Rewrite the RegistrySearchAndReplaceW to use
                            standard registry api rather than going through
                            reg & mem wrapper api's.

--*/

#include "pch.h"


UINT
CountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      UINT SearchChars
    )
{
    UINT Count;
    UINT SourceChars;
    PCWSTR End;

    Count = 0;
    SourceChars = lstrlenW (SourceString);

    End = SourceString + SourceChars - SearchChars;

    if (!SearchChars) {
        return 0;
    }

    while (SourceString <= End) {
        if (!_wcsnicmp (SourceString, SearchString, SearchChars)) {
            Count++;
            SourceString += SearchChars;
        } else {
            SourceString++;
        }
    }

    return Count;
}


PWSTR
StringSearchAndReplaceW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString,
    IN      PCWSTR ReplaceString,
    IN      DWORD* pcbNewString
    )
{
    PWSTR NewString;
    PBYTE p;
    PBYTE Dest;
    UINT Count;
    UINT Size;
    UINT SearchBytes;
    UINT ReplaceBytes;
    UINT SearchChars;

    //
    // Count occurances within the string
    //

    if (pcbNewString) {
        *pcbNewString = 0;
    }

    SearchBytes = ByteCountW (SearchString);
    SearchChars = SearchBytes / sizeof (WCHAR);
    ReplaceBytes = ByteCountW (ReplaceString);

    Count = CountInstancesOfSubStringW (
                SourceString,
                SearchString,
                SearchChars
                );

    if (!Count) {
        return NULL;
    }

    Size = SizeOfStringW (SourceString) -
           Count * SearchBytes +
           Count * ReplaceBytes;

    NewString = (PWSTR) LocalAlloc(LPTR, Size);
    if (!NewString) {
        return NULL;
    }

    if (pcbNewString) {
        *pcbNewString = Size;
    }

    p = (PBYTE) SourceString;
    Dest = (PBYTE) NewString;

    while (*((PWSTR) p)) {
        if (!_wcsnicmp ((PWSTR) p, SearchString, SearchChars)) {
            CopyMemory (Dest, ReplaceString, ReplaceBytes);
            Dest += ReplaceBytes;
            p += SearchBytes;
        } else {
            *((PWSTR) Dest) = *((PWSTR) p);
            p += sizeof (WCHAR);
            Dest += sizeof (WCHAR);
        }
    }

    *((PWSTR) Dest) = 0;

    return NewString;
}


VOID
RegistrySearchAndReplaceW (
    IN      HKEY   hRoot,
    IN      PCWSTR szKey,
    IN      PCWSTR Search,
    IN      PCWSTR Replace)
{
    HKEY hKey = NULL;
    HKEY hSubKey = NULL;
    DWORD dwType;
    DWORD cchMaxSubKeyName, cchNewMaxSubKeyName;
    DWORD cchMaxValueName, cchNewMaxValueName, cchLocalValueName;
    DWORD cbMaxValue, cbNewMaxValue, cbLocalValue, cbNewLocalValue;
    PWSTR szValueName = NULL, szNewValueName = NULL;
    PWSTR szSubKeyName = NULL, szNewSubKeyName = NULL;
    PBYTE pbValue = NULL, pbNewValue = NULL;
    LONG  lResult;
    DWORD dwIndex;
    UNICODE_STRING Unicode_String;

    lResult = RegOpenKey(hRoot, szKey, &hKey);
    if (ERROR_SUCCESS != lResult) {
        DEBUGMSG ((DM_VERBOSE, "Fail to open key %s. Error %d", szKey, lResult));
        return;
    }

    lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL,
                             &cchMaxSubKeyName, NULL, NULL,
                             &cchMaxValueName, &cbMaxValue,
                             NULL, NULL);
    if (ERROR_SUCCESS != lResult) {
        DEBUGMSG ((DM_VERBOSE, "Fail to query info for key %s. Error %d", szKey, lResult));
        goto Exit;
    }

    cchMaxSubKeyName++;  // Include the terminating NULL
    cchMaxValueName++;   // Include the terminating NULL
    
    //
    // Now starts enumerating the value and replace value names & 
    // string data with "Replace" string in place of "Search" string
    //

    // Allocate enough memory

    szValueName = (LPWSTR) LocalAlloc(LPTR, cchMaxValueName * sizeof(WCHAR));
    if (!szValueName) {
        goto Exit;
    }

    pbValue = (LPBYTE) LocalAlloc(LPTR, cbMaxValue);
    if (!pbValue) {
        goto Exit;
    }

    dwIndex = 0;
    cchLocalValueName = cchMaxValueName;
    cbLocalValue = cbMaxValue;

    while (RegEnumValue(hKey, dwIndex++, szValueName, 
                        &cchLocalValueName, NULL, 
                        &dwType, pbValue, &cbLocalValue) == ERROR_SUCCESS) {

        if (dwType == REG_SZ || dwType == REG_MULTI_SZ || dwType == REG_EXPAND_SZ) {
            
            // Construct the new data value only if it's a string
            pbNewValue = (LPBYTE) StringSearchAndReplaceW((PCWSTR)pbValue, Search, Replace, &cbNewLocalValue);
        }

        // Now construct the new value name by replacing

        szNewValueName = StringSearchAndReplaceW(szValueName, Search, Replace, NULL);

        // If the value name or data has changed then write a new value

        if (szNewValueName || pbNewValue) {
            lResult = RegSetValueEx(hKey, 
                                    szNewValueName ? szNewValueName : szValueName,
                                    0,
                                    dwType,
                                    pbNewValue ? pbNewValue : pbValue,
                                    pbNewValue ? cbNewLocalValue : cbLocalValue);
        }

        if (pbNewValue) {
            LocalFree(pbNewValue);
            pbNewValue = NULL;
        }

        if (szNewValueName) {
            LocalFree(szNewValueName);            
            szNewValueName = NULL;
            
            if (RegDeleteValue(hKey, szValueName) == ERROR_SUCCESS) {
                //
                // Start from begining, as enumeration index no longer valid 
                // with insertion/deletion of value under the key
                //

                dwIndex = 0;
            
                lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL,
                                          NULL, NULL, NULL, &cchNewMaxValueName, 
                                          &cbNewMaxValue, NULL, NULL);
                if (ERROR_SUCCESS != lResult) {
                    DEBUGMSG ((DM_VERBOSE, "Fail to query info for key %s. Error %d", szKey, lResult));
                    goto Exit;
                }

                cchNewMaxValueName++;   // Include the terminating NULL

                if (cchNewMaxValueName > cchMaxValueName) {
                    LocalFree(szValueName);
                    szValueName = NULL;

                    cchMaxValueName = cchNewMaxValueName;
                    szValueName = (LPWSTR) LocalAlloc(LPTR, cchMaxValueName * sizeof(WCHAR));
                    if (!szValueName) {
                        goto Exit;
                    }
                }

                if (cbNewMaxValue > cbMaxValue) {
                    LocalFree(pbValue);
                    pbValue = NULL;

                    cbMaxValue = cbNewMaxValue;
                    pbValue = (LPBYTE) LocalAlloc(LPTR, cbMaxValue);
                    if (!pbValue) {
                        goto Exit;
                    }
                }
            }
        }

        cchLocalValueName = cchMaxValueName;
        cbLocalValue = cbMaxValue;
    }
    
    LocalFree(szValueName);
    szValueName = NULL;
    LocalFree(pbValue);
    pbValue = NULL;

    //
    // Now enumerate all the sub keys and replace the name as 
    // required in a recursive fashion
    //

    szSubKeyName = (LPWSTR) LocalAlloc(LPTR, cchMaxSubKeyName * sizeof(WCHAR));
    if (!szSubKeyName) {
        goto Exit;
    }

    dwIndex = 0;

    while (RegEnumKey(hKey, dwIndex++, 
                      szSubKeyName, cchMaxSubKeyName) == ERROR_SUCCESS) {

        // recursively replace in the sub key tree
        RegistrySearchAndReplaceW(hKey, szSubKeyName, Search, Replace);

        szNewSubKeyName = StringSearchAndReplaceW(szSubKeyName, Search, Replace, NULL);

        if (szNewSubKeyName) {
            if (RegOpenKey(hKey, szSubKeyName, &hSubKey) == ERROR_SUCCESS) {

                Unicode_String.Length = ByteCountW(szNewSubKeyName);
                Unicode_String.MaximumLength = Unicode_String.Length + sizeof(WCHAR);
                Unicode_String.Buffer = szNewSubKeyName;

                lResult = NtRenameKey(hSubKey, &Unicode_String);

                if (lResult == ERROR_SUCCESS) {
                    //
                    // Start from begining, as enumeration index no longer valid 
                    // with rename of sub-keys under the key
                    //

                    dwIndex = 0;
                
                    lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL,
                                             &cchNewMaxSubKeyName, NULL, NULL,
                                             NULL, NULL, NULL, NULL);
                    if (ERROR_SUCCESS != lResult) {
                        DEBUGMSG ((DM_VERBOSE, "Fail to query info for key %s. Error %d", szKey, lResult));
                        goto Exit;
                    }

                    cchNewMaxSubKeyName++;  // Include the terminating NULL

                    if (cchNewMaxSubKeyName > cchMaxSubKeyName) {
                        LocalFree(szSubKeyName);
                        szSubKeyName = NULL;

                        cchMaxSubKeyName = cchNewMaxSubKeyName;
                        szSubKeyName = (LPWSTR) LocalAlloc(LPTR, cchMaxSubKeyName * sizeof(WCHAR));
                        if (!szSubKeyName) {
                            goto Exit;
                        }

                    }
                }

                RegCloseKey(hSubKey);
            }

            LocalFree(szNewSubKeyName);
            szNewSubKeyName = NULL;
        }
    }

Exit:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (szValueName) {
        LocalFree(szValueName);
    }

    if (pbValue) {
        LocalFree(pbValue);
    }

    if (szSubKeyName) {
        LocalFree(szSubKeyName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\profmap.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    profmap.c

Abstract:

    Implements profile mapping APIs, to move local profile ownership
    from one user to another.

Author:

    Jim Schmidt (jimschm) 27-May-1999

Revision History:

    <alias> <date> <comments>

--*/


#include "pch.h"
#define  PCOMMON_IMPL
#include "pcommon.h"

//
// Worker prototypes
//

DWORD
pRemapUserProfile (
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    );

BOOL
pLocalRemapAndMoveUserW (
    IN      DWORD Flags,
    IN      PCWSTR ExistingUser,
    IN      PCWSTR NewUser
    );

VOID
pFixSomeSidReferences (
    PSID ExistingSid,
    PSID NewSid
    );

VOID
pOurGetProfileRoot (
    IN      PCWSTR SidString,
    OUT     PWSTR ProfileRoot
    );

#define REMAP_KEY_NAME      L"$remap$"

//
// Implementation
//

BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    return TRUE;
}



/*++

Routine Description:

  SmartLocalFree and SmartRegCloseKey are cleanup routines that ignore NULL
  values.

Arguments:

  Mem or Key - Specifies the value to clean up.

Return Value:

  None.

--*/

VOID
SmartLocalFree (
    PVOID Mem               OPTIONAL
    )
{
    if (Mem) {
        LocalFree (Mem);
    }
}


VOID
SmartRegCloseKey (
    HKEY Key                OPTIONAL
    )
{
    if (Key) {
        RegCloseKey (Key);
    }
}


BOOL
WINAPI
pLocalRemapUserProfileW (
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  pLocalRemapUserProfile begins the process of remapping a profile from one
  SID to another. This function validates the caller's arguments, and then
  calls  pRemapUserProfile to do the work.  Top-level exceptions are handled
  here.


Arguments:

  Flags      - Specifies zero or more profile mapping flags.
  SidCurrent - Specifies the SID of the user who's profile is going to be
               remaped.
  SidNew     - Specifies the SID of the user who will own the profile.

Return Value:

  TRUE if success, FALSE if failure.  GetLastError provides failure code.

--*/

{
    DWORD Error;
    PWSTR CurrentSidString = NULL;
    PWSTR NewSidString = NULL;
    INT Order;
    PWSTR p, q;
    HANDLE hToken = NULL;
    DWORD dwErr1 = ERROR_ACCESS_DENIED, dwErr2 = ERROR_ACCESS_DENIED;

    DEBUGMSG((DM_VERBOSE, "========================================================="));
    DEBUGMSG((
        DM_VERBOSE,
        "RemapUserProfile: Entering, Flags = <0x%x>, SidCurrent = <0x%x>, SidNew = <0x%x>",
        Flags,
        SidCurrent,
        SidNew
        ));

    if (!OpenThreadToken (GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &hToken)) {
        if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
            Error = GetLastError();
            DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: OpenProcessToken failed with code %u", Error));
            goto Exit;
        }
    }

    if (!IsUserAnAdminMember (hToken)) {
        Error = ERROR_ACCESS_DENIED;
        DEBUGMSG((DM_VERBOSE, "RemapAndMoveUserW: Caller is not an administrator"));
        goto Exit;
    }

#ifdef DBG

        {
            PSID DbgSid;
            PWSTR DbgSidString;

            DbgSid = GetUserSid (hToken);

            if (OurConvertSidToStringSid (DbgSid, &DbgSidString)) {
                DEBUGMSG ((DM_VERBOSE, "RemapAndMoveUserW: Caller's SID is %s", DbgSidString));
                DeleteSidString (DbgSidString);
            }

            DeleteUserSid (DbgSid);
        }

#endif

    //
    // Validate args
    //

    Error = ERROR_INVALID_PARAMETER;

    if (!IsValidSid (SidCurrent)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfile: received invalid current user sid."));
        goto Exit;
    }

    if (!IsValidSid (SidNew)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfile: received invalid new user sid."));
        goto Exit;
    }

    //
    // All arguments are valid. Lock the users and call a worker.
    //

    if (!OurConvertSidToStringSid (SidCurrent, &CurrentSidString)) {
        Error = GetLastError();
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Can't stringify current sid."));
        goto Exit;
    }

    if (!OurConvertSidToStringSid (SidNew, &NewSidString)) {
        Error = GetLastError();
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Can't stringify new sid."));
        goto Exit;
    }

    //
    // SID arguments must be unique.  We assume the OS uses the same character set
    // to stringify a SID, even if something like a locale change happens in the
    // middle of our code.
    //

    p = CurrentSidString;
    q = NewSidString;

    while (*p && *p == *q) {
        p++;
        q++;
    }

    Order = *p - *q;

    if (!Order) {
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Both sids match (%s=%s)",
                  CurrentSidString, NewSidString));
        Error = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    ASSERT (lstrcmpi (CurrentSidString, NewSidString));

    //
    // Grab the user profile mutexes in wchar-sorted order.  This eliminates
    // a deadlock with another RemapUserProfile call.
    //

    if (Order < 0) {
        dwErr1 = EnterUserProfileLock (CurrentSidString);
        if (dwErr1 == ERROR_SUCCESS) {
            dwErr2 = EnterUserProfileLock (NewSidString);
        }
    } else {
        dwErr2 = EnterUserProfileLock (NewSidString);
        if (dwErr2 == ERROR_SUCCESS) {
            dwErr1 = EnterUserProfileLock (CurrentSidString);
        }
    }

    if (dwErr1 != ERROR_SUCCESS || dwErr2 != ERROR_SUCCESS) {
        Error = GetLastError();
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Failed to grab a user profile lock, error = %u", Error));
        goto Exit;
    }

    __try {
        Error = pRemapUserProfile (Flags, SidCurrent, SidNew);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Error = ERROR_NOACCESS;
        DEBUGMSG((DM_WARNING, "RemapUserProfile: Exception thrown in PrivateRemapUserProfile."));
    }

Exit:
    if (hToken) {
        CloseHandle (hToken);
    }

    if (CurrentSidString) {
        if(dwErr1 == ERROR_SUCCESS) {
            LeaveUserProfileLock (CurrentSidString);
        }
        DeleteSidString (CurrentSidString);
    }

    if (NewSidString) {
        if(dwErr2 == ERROR_SUCCESS) {
            LeaveUserProfileLock (NewSidString);
        }
        DeleteSidString (NewSidString);
    }

    SetLastError (Error);
    return Error == ERROR_SUCCESS;
}


BOOL
GetNamesFromUserSid (
    IN      PCWSTR RemoteTo,
    IN      PSID Sid,
    OUT     PWSTR *User,
    OUT     PWSTR *Domain
    )

/*++

Routine Description:

  GetNamesFromUserSid obtains the user and domain name from a SID.  The SID
  must be a user account (not a group, printer, etc.).

Arguments:

  RemoteTo - Specifies the computer to remote the call to
  Sid      - Specifies the SID to look up
  User     - Receives the user name.  If non-NULL, the caller must free this
             buffer with LocalFree.
  Domain   - Receives the domain name.  If non-NULL, the caller must free the
             buffer with LocalFree.

Return Value:

  TRUE on success, FALSE on failure, GetLastError provides failure code.

--*/

{
    DWORD UserSize = 256;
    DWORD DomainSize = 256;
    PWSTR UserBuffer = NULL;
    PWSTR DomainBuffer = NULL;
    DWORD Result = ERROR_SUCCESS;
    BOOL b;
    SID_NAME_USE use;

    //
    // Allocate initial buffers of 256 chars
    //

    UserBuffer = LocalAlloc (LPTR, UserSize * sizeof (WCHAR));
    if (!UserBuffer) {
        Result = ERROR_OUTOFMEMORY;
        DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
        goto Exit;
    }

    DomainBuffer = LocalAlloc (LPTR, DomainSize * sizeof (WCHAR));
    if (!DomainBuffer) {
        Result = ERROR_OUTOFMEMORY;
        DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
        goto Exit;
    }

    b = LookupAccountSid (
            RemoteTo,
            Sid,
            UserBuffer,
            &UserSize,
            DomainBuffer,
            &DomainSize,
            &use
            );

    if (!b) {
        Result = GetLastError();

        if (Result == ERROR_NONE_MAPPED) {
            DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Account not found"));
            goto Exit;
        }

        if (UserSize <= 256 && DomainSize <= 256) {
            DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Unexpected error %u", Result));
            Result = ERROR_UNEXP_NET_ERR;
            goto Exit;
        }

        //
        // Try allocating new buffers
        //

        if (UserSize > 256) {
            SmartLocalFree (UserBuffer);
            UserBuffer = LocalAlloc (LPTR, UserSize * sizeof (WCHAR));

            if (!UserBuffer) {
                Result = ERROR_OUTOFMEMORY;
                DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
                goto Exit;
            }
        }

        if (DomainSize > 256) {
            SmartLocalFree (DomainBuffer);
            DomainBuffer = LocalAlloc (LPTR, DomainSize * sizeof (WCHAR));

            if (!DomainBuffer) {
                Result = ERROR_OUTOFMEMORY;
                DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Alloc error %u.", GetLastError()));
                goto Exit;
            }
        }

        //
        // Try look up again
        //

        b = LookupAccountSid (
                RemoteTo,
                Sid,
                UserBuffer,
                &UserSize,
                DomainBuffer,
                &DomainSize,
                &use
                );

        if (!b) {
            //
            // All attempts failed.
            //

            Result = GetLastError();

            if (Result != ERROR_NONE_MAPPED) {
                DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: Unexpected error %u (2)", Result));
                Result = ERROR_UNEXP_NET_ERR;
            }

            goto Exit;
        }
    }

    //
    // LookupAccountSid succeeded.  Now verify that the accout type
    // is correct.
    //

    if (use != SidTypeUser) {
        DEBUGMSG((DM_WARNING, "GetNamesFromUserSid: SID specifies bad account type: %u", (DWORD) use));
        Result = ERROR_NONE_MAPPED;
        goto Exit;
    }

    ASSERT (Result == ERROR_SUCCESS);

Exit:
    if (Result != ERROR_SUCCESS) {

        SmartLocalFree (UserBuffer);
        UserBuffer = NULL;
        SmartLocalFree (DomainBuffer);
        DomainBuffer = NULL;

        SetLastError (Result);
    }

    *User = UserBuffer;
    *Domain = DomainBuffer;

    return (Result == ERROR_SUCCESS);
}


DWORD
pRemapUserProfile (
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  pRemapUserProfile changes the security of a profile from one SID to
  another. Upon completion, the original user will not have access to the
  profile, and the new user will.

Arguments:

  Flags      - Specifies zero or more profile remap flags.  Specify
               REMAP_PROFILE_NOOVERWRITE to guarantee no existing user
               setting is overwritten.  Specify
               REMAP_PROFILE_NOUSERNAMECHANGE to make sure the user name does
               not change.
  SidCurrent - Specifies the current user SID. This user must own the profile,
               and upon completion, the user will not have a local profile.
  SidNew     - Specifies the new user SID.  This user will own the profile
               upon completion.

Return Value:

  A Win32 status code.

--*/

{
    PWSTR CurrentUser = NULL;
    PWSTR CurrentDomain = NULL;
    PWSTR CurrentSidString = NULL;
    PWSTR NewUser = NULL;
    PWSTR NewDomain = NULL;
    PWSTR NewSidString = NULL;
    DWORD Size;
    DWORD Result = ERROR_SUCCESS;
    INT UserCompare;
    INT DomainCompare;
    BOOL b;
    HKEY hCurrentProfile = NULL;
    HKEY hNewProfile = NULL;
    HKEY hProfileList = NULL;
    LONG rc;
    DWORD Type;
    BOOL CleanUpFailedCopy = FALSE;
    DWORD Loaded;
    UNICODE_STRING Unicode_String;
    NTSTATUS Status;


    //
    // The caller must make sure we have valid args.
    //

    //
    // Get the names for the user
    //

    b = GetNamesFromUserSid (NULL, SidCurrent, &CurrentUser, &CurrentDomain);

    if (!b) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Current user SID is not a valid user"));
        goto Exit;
    }

    b = GetNamesFromUserSid (NULL, SidNew, &NewUser, &NewDomain);

    if (!b) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: New user SID is not a valid user"));
        goto Exit;
    }

    //
    // Compare them
    //

    UserCompare = lstrcmpi (CurrentUser, NewUser);
    DomainCompare = lstrcmpi (CurrentDomain, NewDomain);

    //
    // Either the user or domain must be different.  If the caller specifies
    // REMAP_PROFILE_NOUSERNAMECHANGE, then user cannot be different.
    //

    if (UserCompare == 0 && DomainCompare == 0) {
        //
        // This case should not be possible.
        //

        ASSERT (FALSE);
        Result = ERROR_INVALID_PARAMETER;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: User and domain names match for different SIDs"));
        goto Exit;
    }

    if ((Flags & REMAP_PROFILE_NOUSERNAMECHANGE) && UserCompare != 0) {
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: User name can't change from %s to %s",
                  CurrentUser, NewUser));
        Result = ERROR_BAD_USERNAME;
        goto Exit;
    }

    //
    // The SID change now makes sense.  Let's change it.  Start by
    // obtaining a string version of the SID.
    //

    if (!OurConvertSidToStringSid (SidCurrent, &CurrentSidString)) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't stringify current sid."));
        goto Exit;
    }

    if (!OurConvertSidToStringSid (SidNew, &NewSidString)) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't stringify new sid."));
        goto Exit;
    }

    //
    // Open the profile list key
    //

    rc = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH, 0, KEY_READ|KEY_WRITE,
                       &hProfileList);

    if (rc != ERROR_SUCCESS) {
        Result = rc;
        DEBUGMSG((DM_WARNING, "PrivateRemapUserProfile: Can't open profile list key."));
        goto Exit;
    }

    //
    // Open the current user's profile list key.  Then make sure the profile is not
    // loaded, and get the profile directory.
    //

    rc = RegOpenKeyEx (hProfileList, CurrentSidString, 0, KEY_READ | KEY_WRITE, &hCurrentProfile);

    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            Result = ERROR_NO_SUCH_USER;
        } else {
            Result = rc;
        }

        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't open current user's profile list key."));
        goto Exit;
    }

    Size = sizeof(Loaded);
    rc = RegQueryValueEx (hCurrentProfile, L"RefCount", NULL, &Type, (PBYTE) &Loaded, &Size);
    if (rc != ERROR_SUCCESS || Type != REG_DWORD) {
        DEBUGMSG((DM_VERBOSE, "pRemapUserProfile: Current user does not have a ref count."));
        Loaded = 0;
    }

    if (Loaded) {
        Result = ERROR_ACCESS_DENIED;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Current user profile is loaded."));
        goto Exit;
    }

    //
    // Now open the new user's key.  If it already exists, then the
    // caller can specify REMAP_PROFILE_NOOVERWRITE to make sure
    // we don't blow away an existing profile setting.
    //

    rc = RegOpenKeyEx(hProfileList, NewSidString, 0, KEY_READ | KEY_WRITE, &hNewProfile);
    
    if (rc == ERROR_SUCCESS) {
        //
        // Did the caller specify REMAP_PROFILE_NOOVERWRITE?
        //

        if (Flags & REMAP_PROFILE_NOOVERWRITE) {
            Result = ERROR_USER_EXISTS;
            DEBUGMSG((DM_VERBOSE, "pRemapUserProfile: Destination profile entry exists."));
            goto Exit;
        }

        //
        // Verify existing profile is not loaded
        //

        Size = sizeof(Loaded);
        rc = RegQueryValueEx (hNewProfile, L"RefCount", NULL, &Type, (PBYTE) &Loaded, &Size);
        if (rc != ERROR_SUCCESS || Type != REG_DWORD) {
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: Existing destination user does not have a ref count."));
            Loaded = 0;
        }

        if (Loaded) {
            Result = ERROR_ACCESS_DENIED;
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: Existing destination user profile is loaded."));
            goto Exit;
        }

        //
        // Remove the key
        //

        RegCloseKey (hNewProfile);
        hNewProfile = NULL;

        rc = RegDelnode (hProfileList, NewSidString);
        if (rc != ERROR_SUCCESS) {
            Result = rc;
            DEBUGMSG((DM_WARNING, "pRemapUserProfile: Can't reset new profile list key."));
            goto Exit;
        }

    }

    //
    // Transfer contents of current user key to new user using NtRenameKey.
    //
    // If an error is encountered, we abandon the successful work above,
    // which includes possibly deletion of an existing profile list key.
    //

    CleanUpFailedCopy = TRUE;

    Unicode_String.Length = ByteCountW(NewSidString);
    Unicode_String.MaximumLength = Unicode_String.Length + sizeof(WCHAR);
    Unicode_String.Buffer = NewSidString;

    Status = NtRenameKey(hCurrentProfile, &Unicode_String);

    if (Status != STATUS_SUCCESS) {
        Result = RtlNtStatusToDosError(Status);
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Error %d in renaming profile list entry.", Result));
        goto Exit;
    }

    // Close the old key
    RegCloseKey (hCurrentProfile);
    hCurrentProfile = NULL;

    //
    // Now open the new key and update SID & GUID information in it
    //

    rc = RegOpenKeyEx(hProfileList, NewSidString, 0, KEY_READ | KEY_WRITE, &hNewProfile);
    
    if (rc != ERROR_SUCCESS) {
        Result = rc;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Error %d in opening new profile list entry.", Result));
        goto Exit;
    }

    //
    // Update new profile's SID
    //

    rc = RegSetValueEx (hNewProfile, L"SID", 0, REG_BINARY, SidNew, GetLengthSid (SidNew));

    if (rc != ERROR_SUCCESS) {
        Result = rc;
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Error %d setting new profile SID.", Result));
        goto Exit;
    }

    //
    // Delete GUID value & associated GUID key if it exists.  
    // It will get re-established on the next logon.
    //

    if (!DeleteProfileGuidSettings (hNewProfile)) {
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Error %d in deleting profile GUID settings"));
    }

    //
    // Set security on the new key.  We pass pNewSid and that is all
    // CreateUserProfile needs.  To get by arg checking, we throw in
    // NewUser as the user name.
    //

    if (!UpdateProfileSecurity (SidNew)) {
        Result = GetLastError();
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: UpdateProfileSecurity returned %u.", Result));
        goto Exit;
    }

    //
    // Success -- the profile was transferred and nothing went wrong
    //

    CleanUpFailedCopy = FALSE;

    RegFlushKey (HKEY_LOCAL_MACHINE);
    ASSERT (Result == ERROR_SUCCESS);

Exit:

    SmartRegCloseKey (hCurrentProfile);
    SmartRegCloseKey (hNewProfile);

    if (CleanUpFailedCopy) {
        DEBUGMSG((DM_WARNING, "pRemapUserProfile: Backing out changes because of failure"));
        RegDelnode (hProfileList, NewSidString);
    }

    SmartLocalFree (CurrentUser);
    SmartLocalFree (CurrentDomain);
    SmartLocalFree (NewUser);
    SmartLocalFree (NewDomain);

    DeleteSidString (CurrentSidString);
    DeleteSidString (NewSidString);

    SmartRegCloseKey (hProfileList);

    return Result;
}


BOOL
WINAPI
RemapUserProfileW (
    IN      PCWSTR Computer,
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  RemapUserProfileW is the exported API.  It calls the local version via RPC.

Arguments:

  Computer   - Specifies the computer to remote the API to.  If NULL or ".",
               the API will run locally.  If non-NULL, the API will run on
               the remote computer.
  Flags      - Specifies the profile mapping flags.  See implementation above
               for details.
  SidCurrent - Specifies the SID of the user who owns the profile.
  SidNew     - Specifies the SID of the user who will own the profile after
               the API completes.

Return Value:

  TRUE if success, FALSE if failure.  GetLastError provides the failure code.

--*/

{
    DWORD Result = ERROR_SUCCESS;
    HANDLE RpcHandle;

    if (!IsValidSid (SidCurrent)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfileW: received invalid current user sid."));
        SetLastError (ERROR_INVALID_SID);
        return FALSE;
    }

    if (!IsValidSid (SidNew)) {
        DEBUGMSG((DM_WARNING, "RemapUserProfileW: received invalid new user sid."));
        SetLastError (ERROR_INVALID_SID);
        return FALSE;
    }

    //
    // We do not support profmap to run in remote computer until we move 
    // the ProfMapApi rpc interface to a LocalService hosted process
    //

    if (Computer) {
        DEBUGMSG((DM_WARNING, "RemapUserProfileW: received computer name"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {
        if (pLocalRemapUserProfileW (Flags, SidCurrent, SidNew)) {
            Result = ERROR_SUCCESS;
        } else {
            Result = GetLastError();
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Result = ERROR_NOACCESS;
    }

    if (Result != ERROR_SUCCESS) {
        SetLastError (Result);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
RemapUserProfileA (
    IN      PCSTR Computer,
    IN      DWORD Flags,
    IN      PSID SidCurrent,
    IN      PSID SidNew
    )

/*++

Routine Description:

  RemapUserProfileA is a wrapper to RemapUserProfileW.

Arguments:

  Computer   - Specifies the computer to remote the API to.  If NULL or ".",
               the API will run locally.  If non-NULL, the API will run on
               the remote computer.
  Flags      - Specifies the profile mapping flags.  See implementation above
               for details.
  SidCurrent - Specifies the SID of the user who owns the profile.
  SidNew     - Specifies the SID of the user who will own the profile after
               the API completes.

Return Value:

  TRUE if success, FALSE if failure.  GetLastError provides the failure code.

--*/

{
    PWSTR UnicodeComputer;
    BOOL b;
    DWORD Err;

    if (!Computer) {
        UnicodeComputer = NULL;
    } else {
        UnicodeComputer = ProduceWFromA (Computer);
        if (!UnicodeComputer) {
            return FALSE;
        }
    }

    b = RemapUserProfileW (UnicodeComputer, Flags, SidCurrent, SidNew);

    Err = GetLastError();
    SmartLocalFree (UnicodeComputer);
    SetLastError (Err);

    return b;
}


BOOL
WINAPI
InitializeProfileMappingApi (
    VOID
    )

/*++

Routine Description:

  InitializeProfileMappingApi is called by winlogon.exe to initialize the RPC
  server interfaces.

Arguments:

  None.

Return Value:

  TRUE if successful, FALSE otherwise.  GetLastError provides the failure
  code.

--*/

{
    // We do not instantiate any rpc interface in console winlogon any more
    return TRUE;
}


BOOL
pHasPrefix (
    IN      PCWSTR Prefix,
    IN      PCWSTR String
    )

/*++

Routine Description:

  pHasPrefix checks String to see if it begins with Prefix.  The check is
  case-insensitive.

Arguments:

  Prefix - Specifies the prefix to check
  String - Specifies the string that may or may not have the prefix.

Return Value:

  TRUE if String has the prefix, FALSE otherwise.

--*/

{
    WCHAR c1 = 0, c2 = 0;

    while (*Prefix && *String) {
        c1 = (WCHAR) CharLower ((PWSTR) (*Prefix++));
        c2 = (WCHAR) CharLower ((PWSTR) (*String++));

        if (c1 != c2) {
            return FALSE;
        }
    }

    if (*Prefix) {
        return FALSE; // String is smaller than Prefix
    }

    return TRUE;
}


PSID
pGetSidForUser (
    IN      PCWSTR Name
    )

/*++

Routine Description:

  pGetSidForUser is a wrapper to LookupAccountSid.  It allocates the SID via
  LocalAlloc.

Arguments:

  Name - Specifies the user name to look up

Return Value:

  A pointer to the SID, which must be freed with LocalFree, or NULL on error.
  GetLastError provides failure code.

--*/

{
    DWORD cbSid = 0;
    PSID  pSid = NULL;
    DWORD cchDomain = 0;
    PWSTR szDomain;
    SID_NAME_USE SidUse;
    BOOL  bRet = FALSE;

    bRet = LookupAccountName( NULL,
                              Name,
                              NULL,
                              &cbSid,
                              NULL,
                              &cchDomain,
                              &SidUse );

    if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        pSid = (PSID) LocalAlloc(LPTR, cbSid);
        if (!pSid) {
            return NULL;
        }

        szDomain = (PWSTR) LocalAlloc(LPTR, cchDomain * sizeof(WCHAR));
        if (!szDomain) {
            LocalFree(pSid);
            return NULL;
        }

        bRet = LookupAccountName( NULL,
                                  Name,
                                  pSid,
                                  &cbSid,
                                  szDomain,
                                  &cchDomain,
                                  &SidUse );
        LocalFree(szDomain);

        if (!bRet) {
            LocalFree(pSid);
            pSid = NULL;
        }
    }

    return pSid;
}


BOOL
WINAPI
RemapAndMoveUserW (
    IN      PCWSTR RemoteTo,
    IN      DWORD Flags,
    IN      PCWSTR ExistingUser,
    IN      PCWSTR NewUser
    )

/*++

Routine Description:

  RemapAndMoveUserW is an API entry point to move settings of one SID to
  another.  In particular, it moves the local user profile, local group
  memberships, some registry use of the SID, and some file system use of the
  SID.

Arguments:

  RemoteTo     - Specifies the computer to remote the call to.  Specify a
                 standard name ("\\computer" or ".").  If NULL, the call will
                 be run locally.
  Flags        - Specifies zero, or REMAP_PROFILE_NOOVERWRITE.
  ExistingUser - Specifies the existing user, in DOMAIN\user format.  This
                 user must have a local profile.
  NewUser      - Specifies the new user who will own ExistingUser's profile
                 after completion.  Specify the user in DOMAIN\User format.

Return Value:

  TRUE on success, FALSE on failure, GetLastError provides the failure code.

--*/

{
    DWORD Result = ERROR_SUCCESS;
    HANDLE RpcHandle;

    //
    // We do not support profmap to run in remote computer until we move 
    // the ProfMapApi rpc interface to a LocalService hosted process
    //

    if (RemoteTo) {
        DEBUGMSG((DM_WARNING, "RemapUserProfileW: received computer name"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try {
        if (pLocalRemapAndMoveUserW (Flags, ExistingUser, NewUser)) {
            Result = ERROR_SUCCESS;
        } else {
            Result = GetLastError();
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Result = ERROR_NOACCESS;
    }
    
    if (Result != ERROR_SUCCESS) {
        SetLastError (Result);
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
RemapAndMoveUserA (
    IN      PCSTR RemoteTo,
    IN      DWORD Flags,
    IN      PCSTR ExistingUser,
    IN      PCSTR NewUser
    )

/*++

Routine Description:

  RemapAndMoveUserA is the ANSI API entry point.  It calls RemapAndMoveUserW.

Arguments:

  RemoteTo     - Specifies the computer to remote the call to.  Specify a
                 standard name ("\\computer" or ".").  If NULL, the call will
                 be run locally.
  Flags        - Specifies zero, or REMAP_PROFILE_NOOVERWRITE.
  ExistingUser - Specifies the existing user, in DOMAIN\user format.  This
                 user must have a local profile.
  NewUser      - Specifies the new user who will own ExistingUser's profile
                 after completion.  Specify the user in DOMAIN\User format.

Return Value:

  TRUE on success, FALSE on failure, GetLastError provides the failure code.

--*/

{
    PWSTR UnicodeRemoteTo = NULL;
    PWSTR UnicodeExistingUser = NULL;
    PWSTR UnicodeNewUser = NULL;
    DWORD Err;
    BOOL b = TRUE;

    Err = GetLastError();
    
    __try {
        
        if (RemoteTo) {
            UnicodeRemoteTo = ProduceWFromA (RemoteTo);
            if (!UnicodeRemoteTo) {
                b = FALSE;
                Err = GetLastError();
            }
        }

        if (b) {
            UnicodeExistingUser = ProduceWFromA (ExistingUser);
            if (!UnicodeExistingUser) {
                b = FALSE;
                Err = GetLastError();
            }
        }

        if (b) {
            UnicodeNewUser = ProduceWFromA (NewUser);
            if (!UnicodeNewUser) {
                b = FALSE;
                Err = GetLastError();
            }
        }

        if (b) {
            b = RemapAndMoveUserW (
                    UnicodeRemoteTo,
                    Flags,
                    UnicodeExistingUser,
                    UnicodeNewUser
                    );

            if (!b) {
                Err = GetLastError();
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_NOACCESS;
    }

    SmartLocalFree (UnicodeRemoteTo);
    SmartLocalFree (UnicodeExistingUser);
    SmartLocalFree (UnicodeNewUser);
    
    SetLastError (Err);
    return b;
}


BOOL
pDoesUserHaveProfile (
    IN      PSID Sid
    )

/*++

Routine Description:

  pDoesUserHaveProfile checks if a profile exists for the user, who is
  specified by the SID.

Arguments:

  Sid - Specifies the SID of the user who may or may not have a local
        profile

Return Value:

  TRUE if the user has a profile and the profile directory exists, FALSE
  otherwise.

--*/

{
    WCHAR ProfileDir[MAX_PATH];

    if (GetProfileRoot (Sid, ProfileDir, ARRAYSIZE(ProfileDir))) {
        return TRUE;
    }

    return FALSE;
}


BOOL
pLocalRemapAndMoveUserW (
    IN      DWORD Flags,
    IN      PCWSTR ExistingUser,
    IN      PCWSTR NewUser
    )

/*++

Routine Description:

  pLocalRemapAndMoveUserW implements the remap and move of a user's security
  settings. This includes moving the user's profile, moving local group
  membership, adjusting some of the SIDs in the registry, and adjusting some
  of the SID directories in the file system. Upon completion, NewUser will
  own ExistingUser's profile.

Arguments:

  Flags        - Specifies the profile remap flags.  See RemapUserProfile.
  ExistingUser - Specifies the user who owns the local profile, in
                 DOMAIN\User format.
  NewUser      - Specifies the user who will own ExistingUser's profile upon
                 completion.  Specify the user in DOMAIN\User format.

Return Value:

  TRUE upon success, FALSE otherwise, GetLastError provides the failure code.

--*/

{
    NET_API_STATUS Status;
    DWORD Entries;
    DWORD EntriesRead;
    BOOL b = FALSE;
    DWORD Error;
    WCHAR Computer[MAX_PATH];
    DWORD Size;
    PSID ExistingSid = NULL;
    PSID NewSid = NULL;
    USER_INFO_0 ui0;
    PLOCALGROUP_USERS_INFO_0 lui0 = NULL;
    LOCALGROUP_MEMBERS_INFO_0 lmi0;
    PCWSTR FixedExistingUser;
    PCWSTR FixedNewUser;
    BOOL NewUserIsOnDomain = FALSE;
    BOOL ExistingUserIsOnDomain = FALSE;
    HANDLE hToken = NULL;
    BOOL NewUserProfileExists = FALSE;
    HRESULT hr;

    Error = GetLastError();

    __try {

        //
        // Guard the API for admins only
        //

        if (!OpenThreadToken (GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &hToken)) {
            if (!OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
                Error = GetLastError();
                DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: OpenProcessToken failed with code %u", Error));
                goto Exit;
            }
        }

        if (!IsUserAnAdminMember (hToken)) {
            Error = ERROR_ACCESS_DENIED;
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Caller is not an administrator"));
            goto Exit;
        }

#ifdef DBG

        {
            PSID DbgSid;
            PWSTR DbgSidString;

            DbgSid = GetUserSid (hToken);

            if (OurConvertSidToStringSid (DbgSid, &DbgSidString)) {
                DEBUGMSG ((DM_VERBOSE, "pLocalRemapAndMoveUserW: Caller's SID is %s", DbgSidString));
                DeleteSidString (DbgSidString);
            }

            DeleteUserSid (DbgSid);
        }

#endif

        //
        // Determine if profile users are domain users or local users.
        // Because the user names are in netbios format of domain\user,
        // we know the user is local only when domain matches the
        // computer name.
        //

        Size = ARRAYSIZE(Computer) - 2;
        if (!GetComputerName (Computer, &Size)) {
            Error = GetLastError();
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: GetComputerName failed with code %u", Error));
            goto Exit;
        }

        hr = StringCchCat(Computer, ARRAYSIZE(Computer), L"\\");
        if (FAILED(hr)) {
            Error = HRESULT_CODE(hr);
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: StringCchCat failed with code %u", Error));
            goto Exit;
        }

        if (pHasPrefix (Computer, ExistingUser)) {
            FixedExistingUser = ExistingUser + lstrlen (Computer);
        } else {
            FixedExistingUser = ExistingUser;
            ExistingUserIsOnDomain = TRUE;
        }

        if (pHasPrefix (Computer, NewUser)) {
            FixedNewUser = NewUser + lstrlen (Computer);
        } else {
            FixedNewUser = NewUser;
            NewUserIsOnDomain = TRUE;
        }

        //
        // Get the SID of the NewUser.  This might fail.
        //

        NewSid = pGetSidForUser (NewUser);

        if (!NewSid) {
            Status = GetLastError();
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Can't get info for %s, rc=%u", NewUser, Status));
        } else {
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: NewUser exists"));

            //
            // Determine if new user has a profile
            //

            NewUserProfileExists = pDoesUserHaveProfile (NewSid);

            if (NewUserProfileExists) {
                DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: NewUser profile exists"));
            }
        }

        if (NewUserProfileExists && (Flags & REMAP_PROFILE_NOOVERWRITE)) {
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Can't overwrite existing user"));
            Error = ERROR_USER_EXISTS;
            goto Exit;
        }

        //
        // Get the SID for ExitingUser.  This cannot fail.
        //

        ExistingSid = pGetSidForUser (ExistingUser);
        if (!ExistingSid) {
            Error = ERROR_NONE_MAPPED;
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: No SID for %s", ExistingUser));
            goto Exit;
        }

        DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Got SIDs for users"));

        //
        // Decide which of the four cases we are doing:
        //
        // Case 1: Local account to local account
        // Case 2: Domain account to local account
        // Case 3: Local account to domain account
        // Case 4: Domain account to domain account
        //

        if (!NewUserIsOnDomain && !ExistingUserIsOnDomain) {

            //
            // For Case 1, all we do is rename the user, and we're done.
            //

            //
            // To rename the user, it may be necessary to delete the
            // existing "new" user.  This abandons a profile.
            //

            if (NewSid) {

                if (Flags & REMAP_PROFILE_NOOVERWRITE) {
                    DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Can't overwrite %s", FixedNewUser));
                    Error = ERROR_USER_EXISTS;
                    goto Exit;
                }

                Status = NetUserDel (NULL, FixedNewUser);

                if (Status != ERROR_SUCCESS) {
                    Error = Status;
                    DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Can't remove %s, code %u", FixedNewUser, Status));
                    goto Exit;
                }

            }

            //
            // Now the NewUser does not exist.  We can move ExistingUser
            // to MoveUser via net apis.  The SID doesn't change.
            //

            ui0.usri0_name = (PWSTR) FixedNewUser;

            Status = NetUserSetInfo (
                        NULL,
                        FixedExistingUser,
                        0,
                        (PBYTE) &ui0,
                        NULL
                        );

            if (Status != ERROR_SUCCESS) {
                Error = Status;

                DEBUGMSG((
                    DM_VERBOSE,
                    "pLocalRemapAndMoveUserW: Error renaming %s to %s, code %u",
                    FixedExistingUser,
                    FixedNewUser,
                    Status
                    ));

                goto Exit;
            }

            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Renamed local user %s to %s", FixedExistingUser, FixedNewUser));

            b = TRUE;
            goto Exit;

        }

        //
        // For cases 2 through 4, we need to verify that the new user
        // already exists, then we adjust the system security and fix
        // SID use.
        //

        if (!NewSid) {
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: User %s must exist", FixedNewUser));
            Error = ERROR_NO_SUCH_USER;
            goto Exit;
        }

        //
        // Move the profile from ExistingUser to NewUser
        //

        if (!pLocalRemapUserProfileW (0, ExistingSid, NewSid)) {
            Error = GetLastError();
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: LocalRemapUserProfileW failed with code %u", Error));
            goto Exit;
        }

        DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Profile was remapped"));

        //
        // Put NewUser in all the same groups as ExistingUser
        //

        Status = NetUserGetLocalGroups (
                    NULL,
                    FixedExistingUser,
                    0,
                    0,
                    (PBYTE *) &lui0,
                    MAX_PREFERRED_LENGTH,
                    &EntriesRead,
                    &Entries
                    );

        if (Status != ERROR_SUCCESS) {
            Error = Status;
            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: NetUserGetLocalGroups failed with code %u for  %s", Status, FixedExistingUser));
            goto Exit;
        }

        DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Local groups: %u", EntriesRead));

        lmi0.lgrmi0_sid = NewSid;

        for (Entries = 0 ; Entries < EntriesRead ; Entries++) {

            Status = NetLocalGroupAddMembers (
                        NULL,
                        lui0[Entries].lgrui0_name,
                        0,
                        (PBYTE) &lmi0,
                        1
                        );

            if (Status == ERROR_MEMBER_IN_ALIAS) {
                Status = ERROR_SUCCESS;
            }

            if (Status != ERROR_SUCCESS) {
                Error = Status;

                DEBUGMSG((
                    DM_VERBOSE,
                    "pLocalRemapAndMoveUserW: NetLocalGroupAddMembers failed with code %u for %s",
                    Status,
                    lui0[Entries].lgrui0_name
                    ));

                goto Exit;
            }
        }

        NetApiBufferFree (lui0);
        lui0 = NULL;

        DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Local groups transferred"));

        //
        // Perform fixups
        //

        pFixSomeSidReferences (ExistingSid, NewSid);

        DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Some SID references fixed"));

        //
        // Remove ExistingUser
        //

        if (!ExistingUserIsOnDomain) {

            //
            // Local user case: delete the user account
            //

            if (Flags & REMAP_PROFILE_KEEPLOCALACCOUNT) {

                DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Keeping local account"));

            } else {

                Status = NetUserDel (NULL, FixedExistingUser);

                if (Status != ERROR_SUCCESS) {
                    Error = Status;
                    DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: NetUserDel failed with code %u for %s", Error, FixedExistingUser));
                    DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Ignoring error because changes cannot be undone!"));
                }

                DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Removed local user %s", FixedExistingUser));
            }

        } else {

            //
            // Non-local user case: remove the user from each local group
            //

            Status = NetUserGetLocalGroups (
                        NULL,
                        FixedExistingUser,
                        0,
                        0,
                        (PBYTE *) &lui0,
                        MAX_PREFERRED_LENGTH,
                        &EntriesRead,
                        &Entries
                        );

            if (Status != ERROR_SUCCESS) {
                Error = Status;

                DEBUGMSG((
                    DM_VERBOSE,
                    "pLocalRemapAndMoveUserW: NetUserGetLocalGroups failed with code %u for %s",
                    Error,
                    FixedExistingUser
                    ));

                goto Exit;
            }

            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Got local groups for %s", FixedExistingUser));

            lmi0.lgrmi0_sid = ExistingSid;

            for (Entries = 0 ; Entries < EntriesRead ; Entries++) {

                Status = NetLocalGroupDelMembers (
                            NULL,
                            lui0[Entries].lgrui0_name,
                            0,
                            (PBYTE) &lmi0,
                            1
                            );

                if (Status != ERROR_SUCCESS) {
                    Error = Status;

                    DEBUGMSG((
                        DM_VERBOSE,
                        "pLocalRemapAndMoveUserW: NetLocalGroupDelMembers failed with code %u for %s",
                        Error,
                        lui0[Entries].lgrui0_name
                        ));

                    goto Exit;
                }
            }

            DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Removed local group membership"));
        }

        DEBUGMSG((DM_VERBOSE, "pLocalRemapAndMoveUserW: Success"));
        b = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Error = ERROR_NOACCESS;
    }

Exit:
    if (hToken) {
        CloseHandle (hToken);
    }

    if (lui0) {
        NetApiBufferFree (lui0);
    }

    SmartLocalFree (ExistingSid);
    SmartLocalFree (NewSid);

    SetLastError (Error);

    return b;
}


typedef struct {
    PCWSTR Path;
    WCHAR ExpandedPath[MAX_PATH];
} IGNOREPATH, *PIGNOREPATH;


BOOL
IsPatternMatchW (
    IN     PCWSTR Pattern,
    IN     PCWSTR Str
    )
{
    WCHAR chSrc, chPat;

    while (*Str) {
        chSrc = (WCHAR) CharLowerW ((PWSTR) *Str);
        chPat = (WCHAR) CharLowerW ((PWSTR) *Pattern);

        if (chPat == L'*') {

            // Skip all asterisks that are grouped together
            while (Pattern[1] == L'*') {
                Pattern++;
            }

            // Check if asterisk is at the end.  If so, we have a match already.
            chPat = (WCHAR) CharLowerW ((PWSTR) Pattern[1]);
            if (!chPat) {
                return TRUE;
            }

            // Otherwise check if next pattern char matches current char
            if (chPat == chSrc || chPat == L'?') {

                // do recursive check for rest of pattern
                Pattern++;
                if (IsPatternMatchW (Pattern, Str)) {
                    return TRUE;
                }

                // no, that didn't work, stick with star
                Pattern--;
            }

            //
            // Allow any character and continue
            //

            Str++;
            continue;
        }

        if (chPat != L'?') {

            //
            // if next pattern character is not a question mark, src and pat
            // must be identical.
            //

            if (chSrc != chPat) {
                return FALSE;
            }
        }

        //
        // Advance when pattern character matches string character
        //

        Pattern++;
        Str++;
    }

    //
    // Fail when there is more pattern and pattern does not end in an asterisk
    //

    chPat = *Pattern;
    if (chPat && (chPat != L'*' || Pattern[1])) {
        return FALSE;
    }

    return TRUE;
}


void FindAndReplaceSD(
    IN  PSECURITY_DESCRIPTOR  pSD, 
    OUT PSECURITY_DESCRIPTOR* ppNewSD,
    IN  PCWSTR                ExistingSidString, 
    IN  PCWSTR                NewSidString)

/*++

Routine Description:

  FindAndReplaceSD replaces ExistingSidString with NewSidString from 
  string representation of pSD and return the newly constructed SD

Arguments:

  pSD               - Security Descriptor to replace
  pNewSD            - New security descriptor place holder
  ExistingSidString - Specifies the string version of the SID to find.
  NewSidString      - Specifies the SID to replace in ACE when
                      ExistingSidString is found.

Return Value:

  None.

--*/

{
    LPWSTR szStringSD;
    LPWSTR szNewStringSD;

    if (ppNewSD) {
        *ppNewSD = pSD;
    }

    if (!ConvertSecurityDescriptorToStringSecurityDescriptor( pSD,
                                                              SDDL_REVISION_1,
                                                              DACL_SECURITY_INFORMATION,
                                                              &szStringSD,
                                                              NULL )) {
        DEBUGMSG((DM_VERBOSE, "FindAndReplaceSD: No string found. Error %d", GetLastError()));
        return;
    }

    szNewStringSD = StringSearchAndReplaceW(szStringSD, ExistingSidString, NewSidString, NULL);

    if (szNewStringSD) {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptor( szNewStringSD,
                                                                  SDDL_REVISION_1,
                                                                  ppNewSD,
                                                                  NULL )) {
            DEBUGMSG((DM_VERBOSE, "FindAndReplaceSD: Fail to convert string to SD. Error %d", GetLastError()));
            if (ppNewSD) {
                *ppNewSD = pSD;
            }
        }

        LocalFree(szNewStringSD);
    }

    LocalFree(szStringSD);
}


VOID
pFixDirReference (
    IN      PCWSTR CurrentPath,
    IN      PCWSTR ExistingSidString,
    IN      PCWSTR NewSidString,
    IN      PIGNOREPATH IgnoreDirList       OPTIONAL
    )

/*++

Routine Description:

  pFixDirReference is a recursive function that renames a directory if it
  matches an existing SID exactly.  It also updates the SIDs.

Arguments:

  CurrentPath       - Specifies the full file system path.
  ExistingSidString - Specifies the string version of the SID to find.
  NewSidString      - Specifies the SID to rename the directory to when
                      ExistingSidString is found.
  IgnoreDirList     - Specifies a list of directories to ignore.  A NULL
                      Path member indicates the end of the list, and the
                      ExpandedPath member must be filled by the caller.

Return Value:

  None.

--*/

{
    WIN32_FIND_DATA fd;
    HANDLE hFind;
    WCHAR SubPath[MAX_PATH];
    WCHAR NewPath[MAX_PATH];
    BOOL  bIgnoreDir;
    UINT  u;
    UINT  cbNeededLen;
    PSECURITY_DESCRIPTOR pSecurityDesc = NULL;
    PSECURITY_DESCRIPTOR pNewSecurityDesc = NULL;
    HRESULT hr;

    if ((lstrlenW (CurrentPath) + lstrlenW (ExistingSidString) + 2) >= MAX_PATH) {
        return;
    }

    if (*CurrentPath == 0) {
        return;
    }

    hr = StringCchPrintf(SubPath, ARRAYSIZE(SubPath), L"%s\\*", CurrentPath);
    if (FAILED(hr)) {
        return;
    }

    hFind = FindFirstFile (SubPath, &fd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            //
            // Ignore dot and dot-dot
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (!lstrcmpi (fd.cFileName, L".") || !lstrcmpi (fd.cFileName, L"..")) {
                    continue;
                }
            }

            //
            // Rename file/directory or recurse on directory
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                hr = StringCchPrintf(SubPath, ARRAYSIZE(SubPath), L"%s\\%s", CurrentPath, fd.cFileName);
                if (FAILED(hr)) {
                    continue;
                }

                bIgnoreDir = FALSE;

                if (IgnoreDirList) {
                    //
                    // Check if this path is to be ignored
                    //

                    for (u = 0 ; IgnoreDirList[u].Path ; u++) {

                        if (IgnoreDirList[u].ExpandedPath[0]) {
                            if (IsPatternMatchW (IgnoreDirList[u].ExpandedPath, SubPath)) {
                                bIgnoreDir = TRUE;
                            }
                        }
                    }
                }

                //
                // If this path is not to be ignored, recursively fix it
                //

                if (!bIgnoreDir) {

                    //
                    // Check for reparse point
                    //

                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
                    {
                        DEBUGMSG((DM_WARNING, "pFixDirReference: Found a reparse point <%s>,  will not recurse into it!", SubPath));
                    }
                    else // Recurse into it
                    {
                        pFixDirReference (SubPath,
                                        ExistingSidString,
                                        NewSidString,
                                        IgnoreDirList);
                    }

                } else {
                    //
                    // This path is to be ignored
                    //

                    DEBUGMSG((DM_VERBOSE, "pFixDirReference:  Ignoring path %s", SubPath));
                    continue;
                }
            }

            if (!lstrcmpi (fd.cFileName, ExistingSidString)) {

                //
                // Rename the SID referenced in the file system
                //

                hr = StringCchPrintf(SubPath, ARRAYSIZE(SubPath), L"%s\\%s", CurrentPath, ExistingSidString);
                if (FAILED(hr)) {
                    continue;
                }
                hr = StringCchPrintf(NewPath, ARRAYSIZE(NewPath), L"%s\\%s", CurrentPath, NewSidString);
                if (FAILED(hr)) {
                    continue;
                }

                if (MoveFile (SubPath, NewPath)) {
                    DEBUGMSG((DM_VERBOSE, "pFixDirReference:  Moved %s to %s", SubPath, NewPath));
                }
                else {
                    DEBUGMSG((DM_WARNING, "pFixDirReference:  Faile to move %s to %s. Error %d", SubPath, NewPath, GetLastError()));
                }
            
                //
                // Obtain security descriptor of the file/dir and replace it if necessary
                //

                if (!GetFileSecurity (NewPath, 
                                      DACL_SECURITY_INFORMATION,
                                      NULL,
                                      0,
                                      &cbNeededLen )) {

                    pSecurityDesc = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, cbNeededLen);
                    if (!pSecurityDesc) {
                        continue;
                    }

                    if (!GetFileSecurity (NewPath, 
                                          DACL_SECURITY_INFORMATION,
                                          pSecurityDesc,
                                          cbNeededLen,
                                          &cbNeededLen )) {
                        DEBUGMSG((DM_WARNING, "pFixDirReference: Path %s has no security descriptor", SubPath));
                        LocalFree(pSecurityDesc);
                        continue;
                    }

                    FindAndReplaceSD(pSecurityDesc, &pNewSecurityDesc, ExistingSidString, NewSidString);

                    if (!SetFileSecurity (NewPath, 
                                          DACL_SECURITY_INFORMATION,
                                          pNewSecurityDesc) ) {
                        DEBUGMSG((DM_WARNING, "pFixDirReference: Fail to update security for %s. Error %d", SubPath, GetLastError()));
                    }
                    else {
                        DEBUGMSG((DM_VERBOSE, "pFixDirReference: Updating security for %s", SubPath));
                    }

                    if (pNewSecurityDesc && pSecurityDesc != pNewSecurityDesc) {
                        LocalFree(pNewSecurityDesc);
                        pNewSecurityDesc = NULL;
                    }

                    if (pSecurityDesc) {
                        LocalFree(pSecurityDesc);
                        pSecurityDesc = NULL;
                    }

                } else {
                    DEBUGMSG((DM_VERBOSE, "pFixDirReference: Path %s has no security descriptor", SubPath));
                }
            
            }

        } while (FindNextFile (hFind, &fd));

        FindClose (hFind);
    }
}


BOOL
pOurExpandEnvironmentStrings (
    IN      PCWSTR String,
    OUT     PWSTR OutBuffer,
    IN      UINT  cchBuffer,
    IN      PCWSTR UserProfile,         OPTIONAL
    IN      HKEY UserHive               OPTIONAL
    )

/*++

Routine Description:

  pOurExpandEnvironmentStrings expands standard environment variables,
  implementing special cases for the variables that have different values
  than what the profmap.dll environment has.  In particular, %APPDATA% and
  %USERPROFILE% are obtained by quering the registry.

  Because this routine is private, certain assumptions are made, such as
  the %APPDATA% or %USERPROFILE% environment variables must appear only
  at the begining of String.

Arguments:

  String      - Specifies the string that might contain one or more
                environment variables.
  OutBuffer   - Receivies the expanded string
  cchBuffer   - Buffer size
  UserProfile - Specifies the root to the user's profile
  UserHive    - Specifies the handle of the root to the user's registry hive

Return Value:

  TRUE if the string was expanded, or FALSE if it is longer than MAX_PATH.
  OutBuffer is always valid upon return. Note that it might be an empty
  string.

--*/

{
    WCHAR TempBuf1[MAX_PATH*2];
    WCHAR TempBuf2[MAX_PATH*2];
    PCWSTR CurrentString;
    DWORD Size;
    HKEY Key;
    LONG rc;
    HRESULT hr;

    CurrentString = String;

    //
    // Special case -- replace %APPDATA% with the app data from the user hive
    //

    if (UserHive && pHasPrefix(L"%APPDATA%", CurrentString)) {

        rc = RegOpenKeyEx (
                UserHive,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders",
                0,
                KEY_READ,
                &Key
                );

        if (rc == ERROR_SUCCESS) {

            Size = MAX_PATH - lstrlen (CurrentString + 1);

            rc = RegQueryValueEx (
                    Key,
                    L"AppData",
                    NULL,
                    NULL,
                    (PBYTE) TempBuf1,
                    &Size
                    );

            RegCloseKey (Key);
        }

        if (rc != ERROR_SUCCESS) {
            //
            // In case of an error, use a wildcard
            //

            hr = StringCchCopy(TempBuf1, ARRAYSIZE(TempBuf1), UserProfile);
            if (FAILED(hr)) {
                goto Exit;
            }
            hr = StringCchCat(TempBuf1, ARRAYSIZE(TempBuf1), L"\\*");
            if (FAILED(hr)) {
                goto Exit;
            }
        } else {
            DEBUGMSG ((DM_VERBOSE, "Got AppData path from user hive: %s", TempBuf1));
        }

        hr = StringCchCat(TempBuf1, ARRAYSIZE(TempBuf1), CurrentString + 9);
        if (FAILED(hr)) {
            goto Exit;
        }

        CurrentString = TempBuf1;
    }

    //
    // Special case -- replace %USERPROFILE% with ProfileRoot, because
    //                 our environment is for another user
    //

    if (UserProfile && pHasPrefix(L"%USERPROFILE%", CurrentString)) {

        hr = StringCchCopy(TempBuf2, ARRAYSIZE(TempBuf2), UserProfile);
        if (FAILED(hr)) {
            goto Exit;
        }
        hr = StringCchCat(TempBuf2, ARRAYSIZE(TempBuf2), CurrentString + 13);
        if (FAILED(hr)) {
            goto Exit;
        }

        CurrentString = TempBuf2;
    }

    //
    // Now replace other environment variables
    //

    Size = ExpandEnvironmentStrings (CurrentString, OutBuffer, cchBuffer);

    if (Size && Size <= cchBuffer) {
        return TRUE;
    }

Exit:

    *OutBuffer = 0;
    return FALSE;
}

typedef struct {
    HKEY   hRoot;
    PCWSTR szKey;
} REGPATH, *PREGPATH;


VOID
pFixSomeSidReferences (
    PSID ExistingSid,
    PSID NewSid
    )

/*++

Routine Description:

  pFixSomeSidReferences adjusts important parts of the system that use SIDs.
  When a SID changes, this function adjusts the system, so the new SID is
  used and no settings are lost.  This function adjusts the registry and file
  system.  It does not attempt to adjust SID use whereever a SID might be
  used.

  For Win2k, this code deliberately ignores crypto sid directories, because
  the original SID is used as part of the recovery encryption key. In future
  versions, proper migration of these settings is expected.

  This routine also blows away the ProtectedRoots subkey for the crypto APIs.
  The ProtectedRoots key has an ACL, and when we delete the key, the cyrpto
  APIs will rebuild it with the proper ACL.

  WARNING: We know there is a risk in loss of access to data that was encrypted
           using the SID.  Normally the original account will not be removed,
           so the SID will exist on the system, and that (in theory) allows the
           original data to be recovered. But because the cyrpto code gets the
           SID from the file system, there is no way for the user to decrypt
           their data.  The future crypto migration code should fix this issue.

Arguments:

  ExistingSid - Specifies the SID that potentially has settings somewhere on
                the system.
  NewSid      - Specifies the SID that is replacing ExistingSid.

Return Value:

  None.

--*/

{
    PWSTR ExistingSidString = NULL;
    PWSTR NewSidString = NULL;
    UINT u;
    WCHAR ExpandedRoot[MAX_PATH];
    WCHAR ProfileRoot[MAX_PATH];
    HKEY UserHive = NULL;
    WCHAR HivePath[MAX_PATH + 14];
    LONG rc;
    HRESULT hr;

    REGPATH RegRoots[] = {
        { HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Protected Storage System Provider" },
        { HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\EventSystem" },
        { HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Installer\\Managed" },
        { HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" },
        { NULL, NULL }
        };

    PCWSTR DirList[] = {
        L"%SYSTEMROOT%\\system32\\appmgmt",
        NULL
        };

    IGNOREPATH IgnoreDirList[] = {
        {L"%APPDATA%\\Microsoft\\Crypto", L""},
        {L"%APPDATA%\\Microsoft\\Protect", L""},
        {NULL, L""}
        };

    //
    // Get the SIDs in text format
    //

    if (!OurConvertSidToStringSid (ExistingSid, &ExistingSidString)) {
        goto Exit;
    }

    if (!OurConvertSidToStringSid (NewSid, &NewSidString)) {
        goto Exit;
    }

    //
    // Initialize directory strings and load the user hive
    //

    if (!GetProfileRoot(NewSid, ProfileRoot, ARRAYSIZE(ProfileRoot))) {
        goto Exit;
    }

    DEBUGMSG ((DM_VERBOSE, "ProfileRoot (NewSid): %s", ProfileRoot));

    hr = StringCchPrintf(HivePath, ARRAYSIZE(HivePath), L"%s\\ntuser.dat", ProfileRoot);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    DEBUGMSG ((DM_VERBOSE, "User hive: %s", HivePath));

    rc = RegLoadKey (HKEY_LOCAL_MACHINE, REMAP_KEY_NAME, HivePath);

    if (rc == ERROR_SUCCESS) {

        rc = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                REMAP_KEY_NAME,
                0,
                KEY_READ|KEY_WRITE,
                &UserHive
                );

        if (rc != ERROR_SUCCESS) {
            RegUnLoadKey (HKEY_LOCAL_MACHINE, REMAP_KEY_NAME);
            DEBUGMSG ((DM_WARNING, "pFixSomeSidReferences: Can't open user hive root, rc=%u", rc));
            UserHive = NULL;
            goto Exit;
        }
    
    } else {
        DEBUGMSG ((DM_WARNING, "RemapAndMoveUserW: Can't load user's hive, rc=%u", rc));
        goto Exit;
    }

    for (u = 0 ; IgnoreDirList[u].Path ; u++) {

        pOurExpandEnvironmentStrings (
            IgnoreDirList[u].Path,
            IgnoreDirList[u].ExpandedPath,
            ARRAYSIZE(IgnoreDirList[u].ExpandedPath),
            ProfileRoot,
            UserHive
            );

        DEBUGMSG((DM_VERBOSE, "pFixSomeSidReferences: Ignoring %s", IgnoreDirList[u].ExpandedPath));
    }

    //
    // Search and replace select parts of the registry where SIDs are used
    //

    for (u = 0 ; RegRoots[u].hRoot ; u++) {
        RegistrySearchAndReplaceW( RegRoots[u].hRoot,
                                   RegRoots[u].szKey,
                                   ExistingSidString,
                                   NewSidString );
    }

    //
    // Test for directories and rename them
    //

    for (u = 0 ; DirList[u] ; u++) {

        if (pOurExpandEnvironmentStrings (DirList[u], ExpandedRoot, ARRAYSIZE(ExpandedRoot), ProfileRoot, UserHive)) {

            pFixDirReference (ExpandedRoot,
                              ExistingSidString,
                              NewSidString,
                              IgnoreDirList );
        }
    }

    //
    // Fix profile directory
    //

    pFixDirReference (ProfileRoot,
                      ExistingSidString,
                      NewSidString,
                      IgnoreDirList );

    //
    // Crypto special case -- blow away ProtectedRoots key (413828)
    //

    DEBUGMSG ((DM_WARNING, "Can't remove protected roots key, code is currently disabled"));

    if (UserHive) {
        rc = RegDelnode (UserHive, L"Software\\Microsoft\\SystemCertificates\\Root\\ProtectedRoots");
        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DM_WARNING, "Can't remove protected roots key, GLE=%u", rc));
        }
    } else {
        DEBUGMSG ((DM_WARNING, "Can't remove protected roots key because user hive could not be opened"));
    }

Exit:

    //
    // Cleanup
    //

    if (UserHive) {
        RegCloseKey (UserHive);
        RegUnLoadKey (HKEY_LOCAL_MACHINE, REMAP_KEY_NAME);
    }

    if (ExistingSidString) {
        DeleteSidString (ExistingSidString);
    }
    if (NewSidString) {
        DeleteSidString (NewSidString);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\dll\userenv.c ===
#include "pch.h"

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//              cchBuffer - Buffer size in char
//              pcchRemaining - buffer remaining after adding '\',
//                              can be NULL if not required
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              02/14/02    santanuc   Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir, UINT cchBuffer, UINT* pcchRemaining)
{
    UINT  cchDir = lstrlen(lpDir);
    LPTSTR lpEnd;

    lpEnd = lpDir + cchDir;
    if (pcchRemaining) {
        *pcchRemaining = cchBuffer - cchDir - 1;
    }

    if (*(lpEnd - 1) != TEXT('\\')) {
        if (cchDir + 1 >= cchBuffer) {  // No space to put \, should never happen
            return NULL;
        }
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
        if (pcchRemaining)
            *pcchRemaining -= 1;
    }

    return lpEnd;
}

//*************************************************************
//
//  SecureProfileDirectory()
//
//  Purpose:    Creates a secure directory that only the user
//              (identified by pSid), admin, and system have 
//              access to.
//
//  Parameters: lpDirectory -   Directory Name
//              pSid        -   Sid for user
//
//  Return:     ERROR_SUCCESS if successful
//              Win32 error code if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/20/95     ericflo    Created
//              2/14/02     santanuc   Changed to secure the directory
//                                     only rather than creating it recursively
//
//*************************************************************

DWORD SecureProfileDirectory (LPTSTR lpDirectory, PSID pSid)
{
    PACL  pAcl = NULL;
    DWORD dwError;


    //
    // Verbose Output
    //

    DEBUGMSG ((DM_VERBOSE, "SecureProfileDirectory: Entering with <%s>", lpDirectory));

    if (!pSid) {
        // Nothing to secure
        
        DEBUGMSG ((DM_VERBOSE, "SecureProfileDirectory: NULL sid specified"));
        return ERROR_SUCCESS;
    }

    //
    // Get the default ACL
    //

    pAcl = CreateDefaultAcl (pSid);
    if (!pAcl) {
        DEBUGMSG ((DM_WARNING, "SecureProfileDirectory: Fail to create ACL"));
    }

    //
    // Attempt to secure the directory
    //

    dwError = SetNamedSecurityInfo( (PTSTR) lpDirectory,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                    NULL, 
                                    NULL,
                                    pAcl,
                                    NULL );

    if (dwError != ERROR_SUCCESS) {
        DEBUGMSG ((DM_WARNING, "SecureProfileDirectory: Failed to set security descriptor dacl for profile directory.  Error = %d", GetLastError()));
    }
    else {
        DEBUGMSG ((DM_VERBOSE, "SecureProfileDirectory: Secure the directory <%s>", lpDirectory));
    }

    FreeDefaultAcl (pAcl);

    return dwError;
}


//*************************************************************
//
//  SetMachineProfileKeySecurity
//
//  Purpose:    Sets the security on the profile key under HKLM/ProfileList
//
//  Parameters: pSid        -   User's sid
//              lpKeyName   -   Name of the registry key
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/22/99     ushaji     adapted
//
//*************************************************************

BOOL SetMachineProfileKeySecurity (PSID pSid, LPTSTR lpKeyName)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidUsers = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    HKEY hKeyProfile=NULL;
    DWORD Error, dwDisp;

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to initialize system sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to initialize admin sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Get the users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, &psidUsers)) {

         DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to initialize authenticated users sid.  Error = %d", GetLastError()));
         goto Exit;
    }

    //
    // Allocate space for the ACL. (No Inheritable Aces)
    //

    cbAcl = (GetLengthSid (psidSystem))    +
            (GetLengthSid (psidAdmin))     +
            (GetLengthSid (psidUsers))     +
            (GetLengthSid (pSid))  +
            sizeof(ACL) +
            (4 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to initialize acl.  Error = %d", GetLastError()));
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUsers)) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER), pSid)) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to initialize security descriptor.  Error = %d", GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Failed to set security descriptor dacl.  Error = %d", GetLastError()));
        goto Exit;
    }

    Error = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           lpKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                           NULL,
                           &hKeyProfile,
                           &dwDisp);

    if (Error != ERROR_SUCCESS) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Couldn't open registry key to set security.  Error = %d", Error));
        SetLastError(Error);
        goto Exit;
    }


    //
    // Set the security
    //

    Error = RegSetKeySecurity(hKeyProfile, DACL_SECURITY_INFORMATION, &sd);

    if (Error != ERROR_SUCCESS) {
        DEBUGMSG((DM_WARNING, "SetMachineProfileKeySecurity: Couldn't set security.  Error = %d", Error));
        SetLastError(Error);
        goto Exit;
    }
    else {
        bRetVal = TRUE;
    }


Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (psidUsers) {
        FreeSid(psidUsers);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    if (hKeyProfile) {
        RegCloseKey(hKeyProfile);
    }

    return bRetVal;
}


PACL
CreateDefaultAcl (
    PSID pSid
    )
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;

    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to initialize system sid.  Error = %d", GetLastError()));
         goto Exit;
    }

    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                              0, 0, 0, 0, &psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to initialize admin sid.  Error = %d", GetLastError()));
        goto Exit;
    }

    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (pSid)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to initialize acl.  Error = %d", GetLastError()));
        goto Exit;
    }

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, pSid)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, pSid)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);



    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to add ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "CreateDefaultAcl: Failed to get ace (%d).  Error = %d", aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    return pAcl;
}


VOID
FreeDefaultAcl (
    PACL pAcl
    )
{
    if (pAcl) {
        GlobalFree (pAcl);
    }
}


BOOL
OurConvertSidToStringSid (
    IN      PSID Sid,
    OUT     PWSTR *SidString
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS NtStatus;

    //
    // Convert the sid into text format
    //

    NtStatus = RtlConvertSidToUnicodeString (&UnicodeString, Sid, TRUE);

    if (!NT_SUCCESS (NtStatus)) {

        DEBUGMSG ((
            DM_WARNING,
            "CreateUserProfile: RtlConvertSidToUnicodeString failed, status = 0x%x",
            NtStatus
            ));

        return FALSE;
    }

    *SidString = UnicodeString.Buffer;
    return  TRUE;
}


VOID
DeleteSidString (
    PWSTR SidString
    )
{
    UNICODE_STRING String;

    if (!SidString) {
        return;
    }

    RtlInitUnicodeString (&String, SidString);
    RtlFreeUnicodeString (&String);

}


BOOL
GetProfileRoot (
    IN      PSID Sid,
    OUT     PWSTR ProfileDir,
    IN      UINT cchBuffer
    )
{
    WCHAR LocalProfileKey[MAX_PATH];
    HKEY hKey;
    DWORD Size;
    DWORD Type;
    DWORD Attributes;
    DWORD cchExpandedRoot;
    PWSTR SidString = NULL;
    WCHAR ExpandedRoot[MAX_PATH];
    HRESULT hr;
    BOOL  bResult = FALSE;

    if (cchBuffer) {
        ProfileDir[0] = 0;
    }

    if (!OurConvertSidToStringSid (Sid, &SidString)) {
        DEBUGMSG ((DM_WARNING, "GetProfileRoot: Can't convert SID to string"));
        goto Exit;
    }

    //
    // Check if this user's profile exists
    //

    hr = StringCchCopy(LocalProfileKey, ARRAYSIZE(LocalProfileKey), PROFILE_LIST_PATH);
    if (FAILED(hr))
        goto Exit;
    hr = StringCchCat(LocalProfileKey, ARRAYSIZE(LocalProfileKey), TEXT("\\"));
    if (FAILED(hr))
        goto Exit;
    hr = StringCchCat(LocalProfileKey, ARRAYSIZE(LocalProfileKey), SidString);
    if (FAILED(hr))
        goto Exit;

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, LocalProfileKey,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        Size = cchBuffer * sizeof(WCHAR);
        RegQueryValueEx (hKey, PROFILE_IMAGE_VALUE_NAME, NULL,
                         &Type, (LPBYTE) ProfileDir, &Size);

        RegCloseKey (hKey);
    }

    if (cchBuffer && ProfileDir[0]) {

        cchExpandedRoot = ExpandEnvironmentStrings (ProfileDir, ExpandedRoot, ARRAYSIZE(ExpandedRoot));
        if (!cchExpandedRoot || cchExpandedRoot > ARRAYSIZE(ExpandedRoot)) {
            ProfileDir[0] = 0;
            DEBUGMSG ((DM_VERBOSE, "GetProfileRoot: ExpandEnvironmentStrings failed."));
            goto Exit;
        }

        Attributes = GetFileAttributes (ExpandedRoot);

        if (Attributes == 0xFFFFFFFF || !(Attributes & FILE_ATTRIBUTE_DIRECTORY)) {
            ProfileDir[0] = 0;
            DEBUGMSG ((DM_VERBOSE, "GetProfileRoot: Profile %s is not vaild", SidString));
        } else {
            if (FAILED(StringCchCopy(ProfileDir, cchBuffer, ExpandedRoot))) {
                ProfileDir[0] = 0;
                DEBUGMSG ((DM_VERBOSE, "GetProfileRoot: Not enough buffer space"));
            }
            else {
                bResult = TRUE;
            }
        }

    } else {
        DEBUGMSG ((DM_VERBOSE, "GetProfileRoot: SID %s does not have a profile directory", SidString));
    }

Exit:

    DeleteSidString (SidString);

    return bResult;
}


BOOL
UpdateProfileSecurity (
    PSID Sid
    )
{
    WCHAR ProfileDir[MAX_PATH];
    WCHAR ExpProfileDir[MAX_PATH];
    WCHAR LocalProfileKey[MAX_PATH];
    PWSTR SidString = NULL;
    PWSTR End, Save;
    LONG rc;
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwSize;
    DWORD dwType;
    DWORD cchExpProfileDir;
    HKEY hKey;
    BOOL b = FALSE;
    BOOL UnloadProfile = FALSE;
    HRESULT hr;
    UINT cchRemaining;

    __try {
        //
        // Convert the sid into text format
        //

        if (!OurConvertSidToStringSid (Sid, &SidString)) {
            dwError = GetLastError();
            DEBUGMSG ((DM_WARNING, "UpdateProfileSecurity: Can't convert SID to string"));
            __leave;
        }

        //
        // Check if this user's profile exists already
        //

        hr = StringCchCopy(LocalProfileKey, ARRAYSIZE(LocalProfileKey), PROFILE_LIST_PATH);
        if (FAILED(hr)) {
            dwError = HRESULT_CODE(hr);
            __leave;
        }
        hr = StringCchCat(LocalProfileKey, ARRAYSIZE(LocalProfileKey), TEXT("\\"));
        if (FAILED(hr)){
            dwError = HRESULT_CODE(hr);
            __leave;
        }
        hr = StringCchCat(LocalProfileKey, ARRAYSIZE(LocalProfileKey), SidString);
        if (FAILED(hr)) {
            dwError = HRESULT_CODE(hr);
            __leave;
        }

        ProfileDir[0] = 0;

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, LocalProfileKey,
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(ProfileDir);
            RegQueryValueEx (hKey, PROFILE_IMAGE_VALUE_NAME, NULL,
                             &dwType, (LPBYTE) ProfileDir, &dwSize);

            RegCloseKey (hKey);
        }

        if (!ProfileDir[0]) {
            DEBUGMSG ((DM_WARNING, "UpdateProfileSecurity: No profile for specified user"));
            dwError = ERROR_BAD_PROFILE;
            __leave;
        }

        if (!SetMachineProfileKeySecurity(Sid, LocalProfileKey)) {
            DEBUGMSG ((DM_WARNING, "UpdateProfileSecurity: Fail to set security for ProfileList entry. Error %d", GetLastError()));
        }

        //
        // The user has a profile, so update the security settings
        //

        cchExpProfileDir = ExpandEnvironmentStrings (ProfileDir, ExpProfileDir, ARRAYSIZE(ExpProfileDir));
        if (!cchExpProfileDir || cchExpProfileDir > ARRAYSIZE(ExpProfileDir)) {
            dwError = cchExpProfileDir ? ERROR_BUFFER_OVERFLOW : GetLastError();
            DEBUGMSG ((DM_WARNING, "UpdateProfileSecurity: ExpandEnvironmentStrings failed. Error %d", dwError));
            __leave;
        }

        //
        // Load the hive temporary so the security can be fixed
        //

        End = CheckSlash (ExpProfileDir, ARRAYSIZE(ExpProfileDir), &cchRemaining);
        if (!End) {
            dwError = ERROR_BUFFER_OVERFLOW;
            __leave;
        }

        Save = End - 1;
        hr = StringCchCopy(End, cchRemaining, L"NTUSER.DAT");
        if (FAILED(hr)) {
            dwError = HRESULT_CODE(hr);
            __leave;
        }

        rc = MyRegLoadKey (HKEY_USERS, SidString, ExpProfileDir);

        *Save = 0;

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG((DM_WARNING, "UpdateProfileSecurity:  Failed to load hive, error = %d.", rc));
            dwError = rc;
            __leave;
        }

        UnloadProfile = TRUE;

        if (!SetupNewHive (SidString, Sid)) {
            dwError = GetLastError();
            DEBUGMSG((DM_WARNING, "UpdateProfileSecurity:  SetupNewHive failed, error = %d.", GetLastError()));
            __leave;

        }

        //
        // Fix the file system security
        //

        dwError = SecureProfileDirectory (ExpProfileDir, Sid);

        if (dwError != ERROR_SUCCESS) {
            DEBUGMSG((DM_WARNING, "UpdateProfileSecurity: SecureProfileDirectory failed, error = %d.", GetLastError()));
            __leave;
        }

        b = TRUE;

    }
    __finally {
        if (UnloadProfile) {
            MyRegUnLoadKey (HKEY_USERS, SidString);
        }

        DeleteSidString (SidString);

        SetLastError (dwError);
    }

    return b;
}

//*************************************************************
//
//  DeleteProfileGuidSettings()
//
//  Purpose:    Deletes the GUID value and associated GUID entry 
//              from ProfileGuid key
//
//  Parameters: hProfile  -   Profile List sid entry key
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              02/13/2002  Santanuc   Created
//
//*************************************************************

BOOL DeleteProfileGuidSettings (HKEY hProfile)
{
    LONG lResult;
    TCHAR szTemp[MAX_PATH];
    TCHAR szUserGuid[MAX_PATH];
    HKEY hKey;
    DWORD dwType, dwSize;
    HRESULT hr;

    //
    // Query for the user guid
    //

    dwSize = MAX_PATH * sizeof(TCHAR);
    lResult = RegQueryValueEx (hProfile, PROFILE_GUID, NULL, &dwType, (LPBYTE) szUserGuid, &dwSize);

    if (lResult == ERROR_SUCCESS) {
        //
        // Delete the profile GUID value
        //

        RegDeleteValue (hProfile, PROFILE_GUID);
        
        hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), PROFILE_GUID_PATH);
        if (FAILED(hr))
            return FALSE;
        hr = StringCchCat(szTemp, ARRAYSIZE(szTemp), TEXT("\\"));
        if (FAILED(hr))
            return FALSE;
        hr = StringCchCat(szTemp, ARRAYSIZE(szTemp), szUserGuid);
        if (FAILED(hr))
            return FALSE;

        //
        // Delete the profile guid from the guid list
        //

        lResult = RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        if (lResult != ERROR_SUCCESS) {
            DEBUGMSG((DM_WARNING, "DeleteProfile:  failed to delete profile guid.  Error = %d", lResult));
        }
    }
    else if (lResult == ERROR_FILE_NOT_FOUND) {
        lResult = ERROR_SUCCESS;
    }

    return (lResult == ERROR_SUCCESS) ? TRUE : FALSE;
}


/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        DEBUGMSG((DM_WARNING, "GetUserSid: Failed to allocate %d bytes",
                  BytesRequired));
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            DEBUGMSG((DM_WARNING, "GetUserSid: Failed to allocate %d bytes",
                      BytesRequired));
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        DEBUGMSG((DM_WARNING, "GetUserSid: Failed to query user info from user token, status = 0x%x",
                  status));
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        DEBUGMSG((DM_WARNING, "GetUserSid: Failed to allocate %d bytes",
                  BytesRequired));
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        DEBUGMSG((DM_WARNING, "GetUserSid: RtlCopySid Failed. status = %d",
                  status));
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}


//*************************************************************
//
//  MyRegLoadKey()
//
//  Purpose:    Loads a hive into the registry
//
//  Parameters: hKey        -   Key to load the hive into
//              lpSubKey    -   Subkey name
//              lpFile      -   hive filename
//
//  Return:     ERROR_SUCCESS if successful
//              Error number if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/22/95     ericflo    Created
//
//*************************************************************

LONG MyRegLoadKey(HKEY hKey, LPTSTR lpSubKey, LPTSTR lpFile)
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    HANDLE hToken;
    BOOLEAN bClient = FALSE;
    int error;
    WCHAR szException[20];

    __try {

        if (OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &hToken)) {
            CloseHandle(hToken);
            bClient = TRUE;    // Enable privilege on thread token
        }

        //
        // Enable the restore privilege
        //

        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, bClient, &WasEnabled);

        if (NT_SUCCESS(Status)) {

            error = RegLoadKey(hKey, lpSubKey, lpFile);

            //
            // Restore the privilege to its previous state
            //

            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, bClient, &WasEnabled);
            if (!NT_SUCCESS(Status)) {
                DEBUGMSG((DM_WARNING, "MyRegLoadKey:  Failed to restore RESTORE privilege to previous enabled state"));
            }


            //
            // Convert a sharing violation error to success since the hive
            // is already loaded
            //

            if (error == ERROR_SHARING_VIOLATION) {
                error = ERROR_SUCCESS;
            }


            //
            // Check if the hive was loaded
            //

            if (error != ERROR_SUCCESS) {
                DEBUGMSG((DM_WARNING, "MyRegLoadKey:  Failed to load subkey <%s>, error =%d", lpSubKey, error));
            }

        } else {
            error = ERROR_ACCESS_DENIED;
            DEBUGMSG((DM_WARNING, "MyRegLoadKey:  Failed to enable restore privilege to load registry key, error %u", error));
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        error = GetExceptionCode();
        if (SUCCEEDED(StringCchPrintf(szException, ARRAYSIZE(szException), L"!!!! 0x%x ", error))) {
            OutputDebugString(szException);
            OutputDebugString(L"Exception hit in MyRegLoadKey in userenv\n");
        }
        ASSERT(error == 0);
    }

    DEBUGMSG((DM_VERBOSE, "MyRegLoadKey: Returning %d.", error));

    return error;
}


//*************************************************************
//
//  MyRegUnLoadKey()
//
//  Purpose:    Unloads a registry key
//
//  Parameters: hKey          -  Registry handle
//              lpSubKey      -  Subkey to be unloaded
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Ported
//
//*************************************************************

BOOL MyRegUnLoadKey(HKEY hKey, LPTSTR lpSubKey)
{
    BOOL bResult = TRUE;
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    HANDLE  hToken;
    BOOLEAN    bClient = FALSE;
    DWORD dwException;
    WCHAR szException[20];


    __try {

        if (OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, FALSE, &hToken)) {
            CloseHandle(hToken);
            bClient = TRUE;    // Enable privilege on thread token
        }

        //
        // Enable the restore privilege
        //

        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, bClient, &WasEnabled);

        if (NT_SUCCESS(Status)) {

            error = RegUnLoadKey(hKey, lpSubKey);

            if ( error != ERROR_SUCCESS) {
                DEBUGMSG((DM_WARNING, "MyRegUnLoadKey:  Failed to unmount hive %x", error));
                SetLastError(error);
                bResult = FALSE;
            }

            //
            // Restore the privilege to its previous state
            //

            Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, bClient, &WasEnabled);
            if (!NT_SUCCESS(Status)) {
                DEBUGMSG((DM_WARNING, "MyRegUnLoadKey:  Failed to restore RESTORE privilege to previous enabled state"));
            }

        } else {
            DEBUGMSG((DM_WARNING, "MyRegUnloadKey:  Failed to enable restore privilege to unload registry key"));
            Status = ERROR_ACCESS_DENIED;
            SetLastError(Status);
            bResult = FALSE;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        
        bResult = FALSE;
        dwException = GetExceptionCode();
        if (SUCCEEDED(StringCchPrintf(szException, ARRAYSIZE(szException), L"!!!! 0x%x ", dwException))) {
            OutputDebugString(szException);
            OutputDebugString(L"Exception hit in MyRegUnLoadKey in userenv\n");
        }
        ASSERT(dwException == 0);
    }

    DEBUGMSG((DM_VERBOSE, "MyRegUnloadKey: Returning %d, error %u.", bResult, GetLastError()));

    return bResult;
}


//*************************************************************
//
//  SetDefaultUserHiveSecurity()
//
//  Purpose:    Initializes a user hive with the
//              appropriate acls
//
//  Parameters: pSid            -   Sid (used by CreateNewUser)
//              RootKey         -   registry handle to hive root
//
//  Return:     ERROR_SUCCESS if successful
//              other error code  if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created as part of
//                                       SetupNewHive
//              3/29/98     adamed     Moved out of SetupNewHive
//                                       to this function
//
//*************************************************************

BOOL SetDefaultUserHiveSecurity(PSID pSid, HKEY RootKey)
{
    DWORD Error;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;


    //
    // Verbose Output
    //

    DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity:  Entering"));


    //
    // Create the security descriptor that will be applied to each key
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    psidUser = pSid;
    bFreeSid = FALSE;

    if (!psidUser) {
        DEBUGMSG((DM_WARNING, "SetDefaultUserHiveSecurity:  Failed to get user sid"));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize system sid.  Error = %d",
                   GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize admin sid.  Error = %d",
                   GetLastError()));
         goto Exit;
    }

    //
    // Get the Restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize restricted sid.  Error = %d",
                   GetLastError()));
         goto Exit;
    }



    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2*GetLengthSid(psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize acl.  Error = %d", GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for Restricted.  Error = %d", GetLastError()));
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to add ace for restricted.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to initialize security descriptor.  Error = %d", GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DEBUGMSG((DM_VERBOSE, "SetDefaultUserHiveSecurity: Failed to set security descriptor dacl.  Error = %d", GetLastError()));
        goto Exit;
    }

    //
    // Set the security descriptor on the entire tree
    //

    Error = ApplySecurityToRegistryTree(RootKey, &sd);

    if (ERROR_SUCCESS == Error) {
        bRetVal = TRUE;
    }
    else
        SetLastError(Error);

Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}



//*************************************************************
//
//  SetupNewHive()
//
//  Purpose:    Initializes the new user hive created by copying
//              the default hive.
//
//  Parameters: lpSidString     -   Sid string
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL SetupNewHive(LPTSTR lpSidString, PSID pSid)
{
    DWORD Error, IgnoreError;
    HKEY RootKey;
    BOOL bRetVal = FALSE;
    HRESULT hr;
    UINT cchRemaining;


    //
    // Verbose Output
    //

    DEBUGMSG((DM_VERBOSE, "SetupNewHive:  Entering"));


    //
    // Open the root of the user's profile
    //

    Error = RegOpenKeyEx(HKEY_USERS,
                         lpSidString,
                         0,
                         KEY_READ | WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &RootKey);

    if (Error != ERROR_SUCCESS) {

        DEBUGMSG((DM_WARNING, "SetupNewHive: Failed to open root of user registry, error = %d", Error));

    } else {

        //
        // First Secure the entire hive -- use security that
        // will be sufficient for most of the hive.
        // After this, we can add special settings to special
        // sections of this hive.
        //

        if (SetDefaultUserHiveSecurity(pSid, RootKey)) {

            TCHAR szSubKey[MAX_PATH];
            LPTSTR lpEnd;

            //
            // Change the security on certain keys in the user's registry
            // so that only Admin's and the OS have write access.
            //

            hr = StringCchCopy(szSubKey, ARRAYSIZE(szSubKey), lpSidString);
            if (FAILED(hr)) {
                SetLastError(HRESULT_CODE(hr));
                return FALSE;
            }
            
            lpEnd = CheckSlash(szSubKey, ARRAYSIZE(szSubKey), &cchRemaining);
            if (!lpEnd) {
                SetLastError(ERROR_BUFFER_OVERFLOW);
                return FALSE;
            }

            hr = StringCchCopy(lpEnd, cchRemaining, WINDOWS_POLICIES_KEY);
            if (FAILED(hr)) {
                SetLastError(HRESULT_CODE(hr));
                return FALSE;
            }

            if (!SecureUserKey(szSubKey, pSid)) {
                DEBUGMSG((DM_WARNING, "SetupNewHive: Failed to secure windows policies key"));
            }

            hr = StringCchCopy(lpEnd, cchRemaining, ROOT_POLICIES_KEY);
            if (FAILED(hr)) {
                SetLastError(HRESULT_CODE(hr));
                return FALSE;
            }

            if (!SecureUserKey(szSubKey, pSid)) {
                DEBUGMSG((DM_WARNING, "SetupNewHive: Failed to secure root policies key"));
            }

            bRetVal = TRUE;

        } else {
            Error = GetLastError();
            DEBUGMSG((DM_WARNING, "SetupNewHive:  Failed to apply security to user registry tree, error = %d", Error));
        }

        RegFlushKey (RootKey);

        IgnoreError = RegCloseKey(RootKey);
        if (IgnoreError != ERROR_SUCCESS) {
            DEBUGMSG((DM_WARNING, "SetupNewHive:  Failed to close reg key, error = %d", IgnoreError));
        }
    }

    //
    // Verbose Output
    //

    DEBUGMSG((DM_VERBOSE, "SetupNewHive:  Leaving with a return value of %d, error %u", bRetVal, Error));

    if (!bRetVal)
        SetLastError(Error);

    return(bRetVal);

}


//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error = ERROR_SUCCESS;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchMaxSubKeySize;



    //
    // First apply security
    //

    RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);

    Error = RegQueryInfoKey(RootKey, NULL, NULL, NULL, NULL,
                            &cchMaxSubKeySize, NULL, NULL, 
                            NULL, NULL, NULL, NULL);
    if (Error != ERROR_SUCCESS) {
        DEBUGMSG ((DM_WARNING, "ApplySecurityToRegistryTree:  Failed to query reg key. error = %d", Error));
        return Error;
    }

    cchMaxSubKeySize++; // Include the null terminator

    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = GlobalAlloc (GPTR, cchMaxSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        DEBUGMSG ((DM_WARNING, "ApplySecurityToRegistryTree:  Failed to allocate memory, error = %d", GetLastError()));
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchMaxSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            } else {

                DEBUGMSG ((DM_WARNING, "ApplySecurityToRegistryTree:  Registry enumeration failed with error = %d", Error));
            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             KEY_READ | WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error == ERROR_SUCCESS) {

            //
            // Apply security to the sub-tree
            //

            ApplySecurityToRegistryTree(SubKey, pSD);


            //
            // We're finished with the sub-key
            //

            RegCloseKey(SubKey);
        }


        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    GlobalFree (SubKeyName);

    return Error;

}


//*************************************************************
//
//  SecureUserKey()
//
//  Purpose:    Sets security on a key in the user's hive
//              so only admin's can change it.
//
//  Parameters: lpKey           -   Key to secure
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/20/95     ericflo    Created
//
//*************************************************************

BOOL SecureUserKey(LPTSTR lpKey, PSID pSid)
{
    DWORD Error;
    HKEY RootKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL, psidRestricted = NULL;
    DWORD cbAcl, AceIndex, dwDisp;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bFreeSid = TRUE;


    //
    // Verbose Output
    //

    DEBUGMSG ((DM_VERBOSE, "SecureUserKey:  Entering"));


    //
    // Create the security descriptor
    //

    //
    // Give the user access by their real sid so they still have access
    // when they logoff and logon again
    //

    psidUser = pSid;
    bFreeSid = FALSE;

    if (!psidUser) {
        DEBUGMSG ((DM_WARNING, "SecureUserKey:  Failed to get user sid"));
        return FALSE;
    }



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize system sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize admin sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Get the restricted sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_RESTRICTED_CODE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidRestricted)) {
         DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize restricted sid.  Error = %d", GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + (2 * GetLengthSid (psidRestricted)) +
            sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize acl.  Error = %d", GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUser)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidRestricted)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for restricted.  Error = %d", GetLastError()));
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidUser)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for user.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for system.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for admin.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidRestricted)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to add ace for restricted.  Error = %d", GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to get ace (%d).  Error = %d", AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to initialize security descriptor.  Error = %d", GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DEBUGMSG ((DM_VERBOSE, "SecureUserKey: Failed to set security descriptor dacl.  Error = %d", GetLastError()));
        goto Exit;
    }


    //
    // Open the root of the user's profile
    //

    Error = RegCreateKeyEx(HKEY_USERS,
                         lpKey,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         NULL,
                         &RootKey,
                         &dwDisp);

    if (Error != ERROR_SUCCESS) {

        DEBUGMSG ((DM_WARNING, "SecureUserKey: Failed to open root of user registry, error = %d", Error));

    } else {

        //
        // Set the security descriptor on the key
        //

        Error = ApplySecurityToRegistryTree(RootKey, &sd);


        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;

        } else {

            DEBUGMSG ((DM_WARNING, "SecureUserKey:  Failed to apply security to registry key, error = %d", Error));
            SetLastError(Error);
        }

        RegCloseKey(RootKey);
    }


Exit:

    //
    // Free the sids and acl
    //

    if (bFreeSid && psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidRestricted) {
        FreeSid(psidRestricted);
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }


    //
    // Verbose Output
    //

    DEBUGMSG ((DM_VERBOSE, "SecureUserKey:  Leaving with a return value of %d", bRetVal));


    return(bRetVal);

}


//*************************************************************
//
//  ProduceWFromA()
//
//  Purpose:    Creates a buffer for a Unicode string and copies
//              the ANSI text into it (converting in the process)
//
//  Parameters: pszA    -   ANSI string
//
//
//  Return:     Unicode pointer if successful
//              NULL if an error occurs
//
//  Comments:   The caller needs to free this pointer.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

LPWSTR ProduceWFromA(LPCSTR pszA)
{
    LPWSTR pszW;
    int cch;

    if (!pszA)
        return (LPWSTR)pszA;

    cch = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);

    if (cch == 0)
        cch = 1;

    pszW = LocalAlloc(LPTR, cch * sizeof(WCHAR));

    if (pszW) {
        if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszA, -1, pszW, cch)) {
            LocalFree(pszW);
            pszW = NULL;
        }
    }

    return pszW;
}


//*************************************************************
//
//  IsUserAnAdminMember()
//
//  Purpose:    Determines if the user is a member of the administrators group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a admin
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              7/25/95     ericflo    Created
//
//*************************************************************

BOOL IsUserAnAdminMember(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundAdmins = FALSE;
    PSID AdminsDomainSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Admins domain sid.
    //


    Status = RtlAllocateAndInitializeSid(
               &authNT,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               DOMAIN_ALIAS_RID_ADMINS,
               0, 0, 0, 0, 0, 0,
               &AdminsDomainSid
               );

    if (Status == STATUS_SUCCESS) {

        //
        // Test if user is in the Admins domain
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hImpToken)) {
            DEBUGMSG((DM_WARNING, "IsUserAnAdminMember: DuplicateTokenEx failed with error %d", GetLastError()));
            FoundAdmins = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, AdminsDomainSid, &FoundAdmins)) {
            DEBUGMSG((DM_WARNING, "IsUserAnAdminmember: CheckTokenMembership failed for AdminsDomainSid with error %d", GetLastError()));
            FoundAdmins = FALSE;
        }
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (AdminsDomainSid)
        RtlFreeSid(AdminsDomainSid);

    return(FoundAdmins);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\moveusr\pch.h ===
#ifdef UNICODE

#ifndef _UNICODE
#define _UNICODE
#endif

#else

#ifndef _MBCS
#define _MBCS
#endif

#endif

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <strsafe.h>

#include <userenv.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <profmapp.h>
#ifdef __cplusplus
}
#endif

#include "msg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\profmap\moveusr\moveusr.c ===
#include "pch.h"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


VOID
pFixSomeSidReferences (
    PSID ExistingSid,
    PSID NewSid
    );

VOID
PrintMessage (
    IN      UINT MsgId,
    IN      PCTSTR *ArgArray
    )
{
    DWORD rc;
    PTSTR MsgBuf;

    rc = FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_HMODULE,
            (LPVOID) GetModuleHandle(NULL),
            (DWORD) MsgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPVOID) &MsgBuf,
            0,
            (va_list *) ArgArray
            );

    if (rc) {
        _tprintf (TEXT("%s"), MsgBuf);
        LocalFree (MsgBuf);
    }
}


PTSTR
GetErrorText (
    IN      UINT Error
    )
{
    DWORD rc;
    PTSTR MsgBuf;

    if (Error == ERROR_NONE_MAPPED) {
        Error = ERROR_NO_SUCH_USER;
    } else if (Error & 0xF0000000) {
        Error = RtlNtStatusToDosError (Error);
    }

    rc = FormatMessageW (
            FORMAT_MESSAGE_ALLOCATE_BUFFER|
                FORMAT_MESSAGE_ARGUMENT_ARRAY|
                FORMAT_MESSAGE_FROM_SYSTEM|
                FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            (DWORD) Error,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPVOID) &MsgBuf,
            0,
            NULL
            );

    if (!rc) {
        MsgBuf = NULL;
    }

    return MsgBuf;
}


VOID
HelpAndExit (
    VOID
    )
{
    //
    // This routine is called whenever command line args are wrong
    //

    PrintMessage (MSG_HELP, NULL);

    exit (1);
}


PSID
GetSidFromName (
    IN      PCTSTR RemoteTo,
    IN      PCTSTR Name
    )
{
    DWORD cbSid = 0;
    PSID  pSid = NULL;
    DWORD cchDomain = 0;
    PWSTR szDomain;
    SID_NAME_USE SidUse;
    BOOL  bRet = FALSE;

    bRet = LookupAccountName( RemoteTo,
                              Name,
                              NULL,
                              &cbSid,
                              NULL,
                              &cchDomain,
                              &SidUse );

    if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        pSid = (PSID) LocalAlloc(LPTR, cbSid);
        if (!pSid) {
            return NULL;
        }

        szDomain = (PWSTR) LocalAlloc(LPTR, cchDomain * sizeof(WCHAR));
        if (!szDomain) {
            LocalFree(pSid);
            return NULL;
        }

        bRet = LookupAccountName( RemoteTo,
                                  Name,
                                  pSid,
                                  &cbSid,
                                  szDomain,
                                  &cchDomain,
                                  &SidUse );
        LocalFree(szDomain);

        if (!bRet) {
            LocalFree(pSid);
            pSid = NULL;
        }
    }

    return pSid;
}


PCTSTR
pSkipUnc (
    PCTSTR Path
    )
{
    if (Path[0] == TEXT('\\') && Path[1] ==  TEXT('\\')) {
        return Path + 2;
    }

    return Path;
}


INT
__cdecl
_tmain (
    INT argc,
    PCTSTR argv[]
    )
{
    INT i;
    DWORD Size;
    PCTSTR User1 = NULL;
    PCTSTR User2 = NULL;
    TCHAR FixedUser1[MAX_PATH];
    TCHAR FixedUser2[MAX_PATH];
    TCHAR Computer[MAX_COMPUTERNAME_LENGTH + 1];
    BOOL Overwrite = FALSE;
    INT c;
    BOOL b;
    PCTSTR RemoteTo = NULL;
    NTSTATUS Status;
    BYTE WasEnabled;
    DWORD Error = ERROR_SUCCESS;
    PCTSTR ArgArray[3];
    PTSTR pErrText;
    TCHAR RemoteToBuf[MAX_PATH];
    BOOL NoDecoration = FALSE;
    BOOL ReAdjust = FALSE;
    BOOL KeepLocalUser = FALSE;
    DWORD Flags;
    HRESULT hr;

    for (i = 1 ; i < argc ; i++) {
        if (argv[i][0] == TEXT('/') || argv[i][0] == TEXT('-')) {

            c = _tcsnextc (argv[i] + 1);

            switch (_totlower ((wint_t) c)) {

            case TEXT('y'):
                if (Overwrite) {
                    HelpAndExit();
                }

                Overwrite = TRUE;
                break;

            case TEXT('d'):
                if (NoDecoration) {
                    HelpAndExit();
                }

                NoDecoration = TRUE;
                break;

            case TEXT('k'):
                if (KeepLocalUser) {
                    HelpAndExit();
                }

                KeepLocalUser = TRUE;
                break;

            case TEXT('c'):
                if (RemoteTo) {
                    HelpAndExit();
                }

                if (argv[i][2] == TEXT(':')) {
                    RemoteTo = &argv[i][3];
                } else {
                    HelpAndExit();
                }

                if (pSkipUnc (RemoteTo) == RemoteTo) {
                    RemoteToBuf[0] = TEXT('\\');
                    RemoteToBuf[1] = TEXT('\\');
                    hr = StringCchCopy(RemoteToBuf + 2, ARRAYSIZE(RemoteToBuf) - 2, RemoteTo);
                    if (FAILED(hr)) {
                        HelpAndExit();
                    }
                    RemoteTo = RemoteToBuf;
                }

                if (!(*RemoteTo)) {
                    HelpAndExit();
                }

                break;

            default:
                HelpAndExit();
            }
        } else {
            if (!User1) {

                User1 = argv[i];
                if (!(*User1)) {
                    HelpAndExit();
                }

            } else if (!User2) {

                User2 = argv[i];
                if (!(*User2)) {
                    HelpAndExit();
                }

            } else {
                HelpAndExit();
            }
        }
    }

    if (!User2) {
        HelpAndExit();
    }

    Size = ARRAYSIZE(Computer);
    if (!GetComputerName (Computer, &Size)) {
        Error = GetLastError();
        goto Exit;
    }

    if (NoDecoration || _tcschr (User1, TEXT('\\'))) {
        hr = StringCchCopy(FixedUser1, ARRAYSIZE(FixedUser1), User1);
        if (FAILED(hr)) {
            Error = HRESULT_CODE(hr);
            goto Exit;
        }
    } else {
        hr = StringCchPrintf(FixedUser1, ARRAYSIZE(FixedUser1), TEXT("%s\\%s"), RemoteTo ? pSkipUnc(RemoteTo) : Computer, User1);
        if (FAILED(hr)) {
            Error = HRESULT_CODE(hr);
            goto Exit;
        }
    }

    if (NoDecoration || _tcschr (User2, TEXT('\\'))) {
        hr = StringCchCopy(FixedUser2, ARRAYSIZE(FixedUser2), User2);
        if (FAILED(hr)) {
            Error = HRESULT_CODE(hr);
            goto Exit;
        }
    } else {
        hr = StringCchPrintf(FixedUser2, ARRAYSIZE(FixedUser2), TEXT("%s\\%s"), RemoteTo ? pSkipUnc(RemoteTo) : Computer, User2);
        if (FAILED(hr)) {
            Error = HRESULT_CODE(hr);
            goto Exit;
        }
    }

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (Status == STATUS_SUCCESS) {
        ReAdjust = TRUE;
    }

    ArgArray[0] = FixedUser1;
    ArgArray[1] = FixedUser2;
    ArgArray[2] = RemoteTo;

    if (!RemoteTo) {
        PrintMessage (MSG_MOVING_PROFILE_LOCAL, ArgArray);
    } else {
        PrintMessage (MSG_MOVING_PROFILE_REMOTE, ArgArray);
    }

    Flags = 0;

    if (KeepLocalUser) {
        Flags |= REMAP_PROFILE_KEEPLOCALACCOUNT;
    }

    if (!Overwrite) {
        Flags |= REMAP_PROFILE_NOOVERWRITE;
    }

    b = RemapAndMoveUser (
            RemoteTo,
            Flags,
            FixedUser1,
            FixedUser2
            );

    if (b) {
        PrintMessage (MSG_SUCCESS, NULL);
    } else {
        Error = GetLastError();
    }

    if (ReAdjust) {
        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }

Exit: 

    if (Error != ERROR_SUCCESS) {
        ArgArray[0] = (PTSTR) IntToPtr (Error);
        ArgArray[1] = pErrText = GetErrorText (Error);

        if (Error < 10000) {
            PrintMessage (MSG_DECIMAL_ERROR, ArgArray);
        } else {
            PrintMessage (MSG_HEXADECIMAL_ERROR, ArgArray);
        }

        if (pErrText) {
            LocalFree(pErrText);
        }
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\proquota\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#if DBG

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);

#else

#define DebugMsg(x)


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\proquota\proquota.h ===
#define WM_QUOTADLG             (WM_USER + 100)
#define WM_REFRESH              (WM_USER + 101)
#define WM_EXITWINDOWS          (WM_USER + 102)
#define WM_WARNUSER             (WM_USER + 103)

#define IDI_ICON                 1
#define IDI_CAUTION              2
#define IDI_STOP                 3

#define IDS_SIZEOK               1
#define IDS_SIZEWARN             2
#define IDS_SIZEBAD              3
#define IDS_COLUMN1              4
#define IDS_COLUMN2              5
#define IDS_SIZEFMT              6
#define IDS_LOGOFFOK             7
#define IDS_CAUTION              8
#define IDS_DEFAULTMSG           9
#define IDS_EXCEEDMSG           10
#define IDS_MSGTITLE            11
#define IDS_QUOTAENUMMSG        12

#define IDD_QUOTA              100
#define IDC_QUOTA_TEXT         101
#define IDC_QUOTA_FILELIST     102
#define IDC_QUOTA_HIDESMALL    103
#define IDC_QUOTA_SIZE         104
#define IDC_QUOTA_MAXSIZE      105
#define IDC_QUOTA_ICON         106

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//
// shell32.dll
//

void WINAPI ExitWindowsDialog(HWND hwndParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\proquota\debug.c ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <strsafe.h>
#include "debug.h"

#if DBG

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
          
//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szProQuota[] = TEXT("PROQUOTA(%x): ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon")
#define DEBUG_KEY_NAME      TEXT("ProQuotaDebugLevel")

TCHAR szLogFileName[] = L"%SystemRoot%\\Debug\\UserMode\\proquota.log";       // Current log


//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

    dwDebugLevel = DL_NORMAL;


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[30];
    TCHAR szDebugBuffer[2*MAX_PATH+40];
    va_list marker;
    DWORD dwErrCode;
    HRESULT hr;


    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {
        hr = StringCchPrintf(szDebugTitle, ARRAYSIZE(szDebugTitle), c_szProQuota, GetCurrentProcessId());
        if (FAILED(hr))
            return;
        OutputDebugString(szDebugTitle);

        va_start(marker, pszMsg);
        hr = StringCchVPrintf(szDebugBuffer, ARRAYSIZE(szDebugBuffer), pszMsg, marker);
        if (FAILED(hr))
            return;
        OutputDebugString(szDebugBuffer);
        OutputDebugString(c_szCRLF);
        va_end(marker);

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;
            TCHAR szExpLogFileName[MAX_PATH+1];

            DWORD dwRet = ExpandEnvironmentStrings ( szLogFileName, szExpLogFileName, ARRAYSIZE(szExpLogFileName));

            if ( dwRet != 0 && dwRet <= MAX_PATH) {

                hFile = CreateFile(szExpLogFileName,
                                   FILE_WRITE_DATA | FILE_APPEND_DATA,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if (hFile != INVALID_HANDLE_VALUE) {

                    if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                        WriteFile (hFile, (LPCVOID) szDebugTitle,
                                   lstrlen (szDebugTitle) * sizeof(TCHAR),
                                   &dwBytesWritten,
                                   NULL);

                        WriteFile (hFile, (LPCVOID) szDebugBuffer,
                                   lstrlen (szDebugBuffer) * sizeof(TCHAR),
                                   &dwBytesWritten,
                                   NULL);

                        WriteFile (hFile, (LPCVOID) c_szCRLF,
                                   lstrlen (c_szCRLF) * sizeof(TCHAR),
                                   &dwBytesWritten,
                                   NULL);
                    }

                    CloseHandle (hFile);
                }
            }
        }

    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\refgp\refgp.cxx ===
////////////////////////////////////////////////////////////////
//
// Refgp.cxx
//
// Refresh Group Policy exe
//
//
////////////////////////////////////////////////////////////////


#include "refgp.h"

#define USER_POLICY_APPLIED_EVENT    TEXT("userenv: User Group Policy has been applied")
#define MACHINE_POLICY_APPLIED_EVENT TEXT("Global\\userenv: Machine Group Policy has been applied")

#define USER_POLICY_DONE_EVENT       TEXT("userenv: User Group Policy Processing is done")
#define MACHINE_POLICY_DONE_EVENT    TEXT("Global\\userenv: Machine Group Policy Processing is done")

#define USER_POLICY_REFRESH_NEEDFG_EVENT    TEXT("userenv: User Group Policy ForcedRefresh Needs Foreground Processing")
#define MACHINE_POLICY_REFRESH_NEEDFG_EVENT TEXT("Global\\userenv: Machine Group Policy ForcedRefresh Needs Foreground Processing")

#define REFRESH_MACHINE 1
#define REFRESH_USER    2

HINSTANCE hInst;

typedef enum _FAILSTATES {
    NO_FAILURE,
    REFRESH_FAILED,
    POLWAIT_FAILED,
    POLWAIT_TIMEDOUT
} FAILSTATES;


typedef struct _REFSTRUCT {
    BOOL        bMachine;
    DWORD       dwOption;
    DWORD       dwTimeOut;
    DWORD       dwError;
    FAILSTATES  fState;
    BOOL        bFGNeeded;
} REFSTRUCT, *LPREFSTRUCT;


REFSTRUCT refMach;
REFSTRUCT refUser;

WCHAR  szUser[200];
WCHAR  szMach[200];
WCHAR  szErr[MAX_PATH*2];

//
// Below we define a mapping so that we can have user and computer
// versions of certain messages.  Note that we could parameterize 
// the messages such that they took the string 'user' or 'computer'
// as an argument, but this can lead to problems with localization,
// especially for languages in which nearby words affect the form
// of other nearby words.  For safety then, we simply have two
// messages for each of these cases -- a user version and computer
// version.
//

enum
{
    ID_REFRESH_FAILED = 0,
    ID_POLWAIT_FAILED,
    ID_POLWAIT_TIMEDOUT,
    ID_REFRESH_BACKGND_SUCCESS,
    ID_REFRESH_BACKGND_TRIGGERED
};

const DWORD REFRESH_STATUS_IDS[][2] =
{
    {
        IDS_REFRESH_FAILED_COMPUTER,
        IDS_REFRESH_FAILED_USER
    },

    {
        IDS_POLWAIT_FAILED_COMPUTER,
        IDS_POLWAIT_FAILED_USER
    },
    
    {
        IDS_POLWAIT_TIMEDOUT_COMPUTER,
        IDS_POLWAIT_TIMEDOUT_USER
    },

    {
        IDS_REFRESH_BACKGND_SUCCESS_COMPUTER,
        IDS_REFRESH_BACKGND_SUCCESS_USER
    },

    {
        IDS_REFRESH_BACKGND_TRIGGERED_COMPUTER,
        IDS_REFRESH_BACKGND_TRIGGERED_USER
    }
};


// Process arg. checks whether argument is present
BOOL ProcessArg(int *pargc, LPWSTR **pargv, DWORD dwStringId, BOOL *bValue)
{
    WCHAR szStr[200];
    LPWSTR *argv = *pargv;

    if (*pargc == 0)
        return TRUE;

    if (!LoadString (hInst, dwStringId, szStr, 200)) {
        return FALSE;
    }

    for (; (*argv); *argv++) {
        if (_wcsicmp(*argv, szStr) == 0) {
            *bValue = TRUE;
            (*pargc)--;
            return TRUE;
        }
    }
    
    return TRUE;
}


// Process arg. checks whether argument is present and what the value is after the ":" in string format
BOOL ProcessArg(int *pargc, WCHAR ***pargv, DWORD dwStringId, WCHAR **szValue)
{
    WCHAR szStr[200];
    LPWSTR *argv = *pargv, szJunk=NULL;
    

    if (*pargc == 0)
        return TRUE;

    if (!LoadString (hInst, dwStringId, szStr, 200)) {
        return FALSE;
    }

    for (; (*argv); *argv++) {
        if (_wcsnicmp(*argv, szStr, lstrlen(szStr)) == 0) {
            *szValue = (*argv)+lstrlen(szStr);
            (*pargc)--;
            return TRUE;
        }
    }

    *szValue = NULL;
    return TRUE;
}

// Process arg. checks whether argument is present and what the value is after the ":" in long format
BOOL ProcessArg(int *pargc, WCHAR ***pargv, DWORD dwStringId, long *plValue)
{
    WCHAR szStr[200];
    LPWSTR *argv = *pargv, szJunk=NULL;


    if (*pargc == 0)
        return TRUE;

    if (!LoadString (hInst, dwStringId, szStr, 200)) {
        return FALSE;
    }

    for (; (*argv); *argv++) {
        if (_wcsnicmp(*argv, szStr, lstrlen(szStr)) == 0) {
            *plValue = wcstol((*argv)+lstrlen(szStr), &szJunk, 10);
            (*pargc)--;
            return TRUE;
        }
    }

    return TRUE;
}

BOOL CompareOptions(WCHAR *szValue, DWORD dwOptionId)
{
    WCHAR szStr[200];
    
    if (!szValue)
        return FALSE;
    
    if (!LoadString (hInst, dwOptionId, szStr, 200)) {
        return FALSE;
    }


    if (_wcsicmp(szValue, szStr) == 0)
        return TRUE;

    return FALSE;
    
}

BOOL GetValue(WCHAR *szValue, DWORD dwOptionId)
{    
    if (!LoadString (hInst, dwOptionId, szValue, 200)) {
        return FALSE;
    }

    return TRUE;
}


void PrintMsg(DWORD dwMsgId, ...)
{
    WCHAR szFmt[200];
    WCHAR szMsg[200];
    va_list marker;    
    
    if (!LoadString (hInst, dwMsgId, szFmt, 200)) {
        return;
    }


   va_start(marker, dwMsgId);
   wvnsprintf(szMsg, 200, szFmt, marker);
   va_end(marker);

   wprintf(szMsg);
   
    return;
}

void PrintUsage()
{
    for (DWORD dwMsgId = IDS_USAGE_FIRST; dwMsgId <= IDS_USAGE_LAST; dwMsgId++) {
        PrintMsg(dwMsgId);
    }

    return;
}


BOOL PromptUserForFG(BOOL bMachine)
{
    WCHAR tTemp, tChar;
    WCHAR Yes[20], No[20];
    
    if (!LoadString (hInst, IDS_YES, Yes, 20)) {
        return FALSE; // safe
    }
    
    if (!LoadString (hInst, IDS_NO, No, 20)) {
        return FALSE; // safe
    }

    for (;;) {
        if (bMachine)
            PrintMsg(IDS_PROMPT_REBOOT);
        else
            PrintMsg(IDS_PROMPT_LOGOFF);

        tChar = getwchar();

        tTemp = tChar;
        while (tTemp != TEXT('\n')) {
            tTemp = getwchar();
        }

        if (towupper(tChar) == towupper(Yes[0]))
            return TRUE;

        if (towupper(tChar) == towupper(No[0]))
            return FALSE;            
    }
    
    
    return FALSE;
}

//***************************************************************************
//
//  GetErrString
//
//  Purpose:    Calls FormatMessage to Get the error string corresp. to a error
//              code
//
//
//  Parameters: dwErr           -   Error Code
//              szErr           -   Buffer to return the error string (MAX_PATH)
//                                  is assumed.!!!
//
//  Return:     szErr
//
//***************************************************************************

LPTSTR GetErrString(DWORD dwErr, LPTSTR szErr)
{
    szErr[0] = TEXT('\0');

    FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                  NULL, dwErr,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  szErr, MAX_PATH, NULL);

    return szErr;
}



void RefreshPolicyAndWait(LPREFSTRUCT   lpRef)
{
    HANDLE  hNotifyEvent=NULL, hFGProcessingEvent=NULL; 
    DWORD   dwRet=0;


    lpRef->fState = REFRESH_FAILED;
    lpRef->dwError = E_FAIL;
    lpRef->bFGNeeded = FALSE;

    if (!RefreshPolicyEx(lpRef->bMachine, lpRef->dwOption)) {
        lpRef->fState = REFRESH_FAILED;
        lpRef->dwError = GetLastError();
        goto Exit;
    }    


    if (lpRef->dwTimeOut != 0) {
        
        lpRef->fState = POLWAIT_FAILED;
        lpRef->dwError = E_FAIL;
        
        hNotifyEvent = OpenEvent(SYNCHRONIZE, FALSE, lpRef->bMachine ? MACHINE_POLICY_DONE_EVENT : USER_POLICY_DONE_EVENT );   

        if (!hNotifyEvent) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = GetLastError();
            goto Exit;
        }


        hFGProcessingEvent = OpenEvent(SYNCHRONIZE, FALSE, lpRef->bMachine ? MACHINE_POLICY_REFRESH_NEEDFG_EVENT : USER_POLICY_REFRESH_NEEDFG_EVENT);   

        if (!hNotifyEvent) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = GetLastError();
            goto Exit;
        }

        
        dwRet = WaitForSingleObject(hNotifyEvent, (lpRef->dwTimeOut == INFINITE) ? INFINITE : 1000*(lpRef->dwTimeOut));

        if (dwRet == WAIT_FAILED) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = GetLastError();
            goto Exit;
        }
        else if (dwRet == WAIT_ABANDONED) {
            lpRef->fState = POLWAIT_FAILED;
            lpRef->dwError = E_UNEXPECTED;
            goto Exit;
        }
        else if (dwRet == WAIT_TIMEOUT) {
            lpRef->fState = POLWAIT_TIMEDOUT;
            lpRef->dwError = 0;
            goto Exit;
        }


        lpRef->bFGNeeded = (lpRef->dwOption == RP_FORCE) && (WaitForSingleObject(hFGProcessingEvent, 0) == WAIT_OBJECT_0);
    }
    

    lpRef->fState = NO_FAILURE;

Exit:
    if (hNotifyEvent) 
        CloseHandle(hNotifyEvent);

    if (hFGProcessingEvent) 
        CloseHandle(hFGProcessingEvent);

    return;
}


void PrintRefreshError(LPREFSTRUCT lpRef)
{
    DWORD dwTarget;

    dwTarget = (lpRef->bMachine) ? COMPUTER_TARGET : USER_TARGET;

    switch (lpRef->fState) {
    case REFRESH_FAILED:
        PrintMsg(REFRESH_ID(ID_REFRESH_FAILED, dwTarget), GetErrString(lpRef->dwError, szErr));
        break;

    case POLWAIT_FAILED:
        PrintMsg(REFRESH_ID(ID_POLWAIT_FAILED, dwTarget), GetErrString(lpRef->dwError, szErr));
        break;

    case POLWAIT_TIMEDOUT:
        PrintMsg(REFRESH_ID(ID_POLWAIT_TIMEDOUT, dwTarget));

    case NO_FAILURE:
        if (lpRef->dwTimeOut == 0)
            PrintMsg(REFRESH_ID(ID_REFRESH_BACKGND_TRIGGERED, dwTarget));
        else
            PrintMsg(REFRESH_ID(ID_REFRESH_BACKGND_SUCCESS, dwTarget));

        break;
    default:
        break;
    }
}



void __cdecl main (int argc, char **argv)
{
    DWORD   uTarget=0; 
    BOOL    bArgValid = TRUE;
    LONG    lTime = 600;
    DWORD   dwTime = 600, dwRet = 0, dwOption = 0, dwThread = 0;


    HANDLE  hNotifyEvent=NULL, hFGProcessingEvent=NULL, hToken = NULL; 
    BOOL    bNeedFG = FALSE;
    LPWSTR  lpCommandLine=0, szTarget=0;
    int     wargc=0;
    LPWSTR *wargv=NULL, *wargv1=NULL;
    BOOL    bForce=FALSE, bOkToLogoff=FALSE, bOkToBoot=FALSE, bNextFgSync = FALSE;
    BOOL    bNeedBoot = FALSE, bNeedLogoff = FALSE;
    BOOL    bError = FALSE;
    HANDLE  hThreads[2] = {0, 0};

    WCHAR achCodePage[13] = L".OCP";

    UINT  CodePage = GetConsoleOutputCP();

    //
    // Set locale to the default
    //
    if ( 0 != CodePage )
    {
       _ultow( CodePage, achCodePage + 1, 10 );
    }

    _wsetlocale(LC_ALL, achCodePage);

    SetThreadUILanguage(0);

    lpCommandLine = GetCommandLine();

    wargv1 = CommandLineToArgvW(lpCommandLine, &wargc);

    wargv = (LPWSTR *)LocalAlloc(LPTR, (1+wargc)*sizeof(LPWSTR));
    if (!wargv) {
        PrintMsg(IDS_OUT_OF_MEMORY);
        goto Exit;
    }    

    memcpy(wargv, wargv1, wargc*sizeof(LPWSTR));
    
    hInst = GetModuleHandle(wargv[0]);

    if ((!GetValue(szUser, IDS_USER)) || (!GetValue(szMach, IDS_MACHINE))) {
        // we cannot read the resource strings. no point continuing
        return;
    }

    //
    // Ignore the first argument 
    //

    wargc--;
    wargv++;
    
    //
    // Get the args
    //

    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_TARGET, &szTarget);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_TIME, &lTime);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_FORCE, &bForce);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_LOGOFF, &bOkToLogoff);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_BOOT, &bOkToBoot);
    bArgValid   = bArgValid && ProcessArg(&wargc, &wargv, IDS_SYNC, &bNextFgSync);
    bArgValid   = bArgValid && (wargc == 0);

    //
    // Get the target correctly
    //

    uTarget = 0;
    if (bArgValid ) {
        if (!szTarget) {
            uTarget |= REFRESH_MACHINE;
            uTarget |= REFRESH_USER;
        }
        else if ( CompareOptions(szTarget, IDS_MACHINE) )
            uTarget |= REFRESH_MACHINE;
        else if ( CompareOptions(szTarget, IDS_USER) ) 
            uTarget |= REFRESH_USER;
        else {
            bArgValid = FALSE;
        }
    }

    //
    // Get the options correctly
    //

    if (bArgValid) {
        if ( bForce )
            dwOption = RP_FORCE;
        else 
            dwOption = 0;
    }


    if (lTime == -1)
        dwTime = INFINITE;
    else
        dwTime = lTime;
        

    if (!bArgValid) {
        PrintUsage();
        goto Exit;
    }

    if (bOkToBoot) 
        bOkToLogoff = TRUE;


    if (bNextFgSync) {
        if (uTarget & REFRESH_MACHINE) {
            dwRet = ForceSyncFgPolicy( 0 );

            if (dwRet != ERROR_SUCCESS) {
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(dwRet, szErr));
                goto Exit;
            }
        }

        if (uTarget & REFRESH_USER) {
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }
            
            LPWSTR szSid = GetSidString( hToken );

            if (!szSid) {
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }

            dwRet = ForceSyncFgPolicy( szSid );

            if (dwRet != ERROR_SUCCESS) {
                LocalFree (szSid);
                PrintMsg(IDS_SET_MODE_FAILED, GetErrString(dwRet, szErr));
                goto Exit;
            }

            LocalFree (szSid);
            CloseHandle (hToken);
            hToken = 0;
        }

    }
    else {
        if (uTarget & REFRESH_MACHINE) {
            refMach.bMachine = TRUE;
            refMach.dwOption = dwOption;
            refMach.dwTimeOut = dwTime;


            if ((hThreads[dwThread] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RefreshPolicyAndWait, &refMach, 0, 0)) == NULL) {
                PrintMsg(IDS_REFRESH_POLICY_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }

            dwThread++;
        }


        if (uTarget & REFRESH_USER) {
            refUser.bMachine = FALSE;
            refUser.dwOption = dwOption;
            refUser.dwTimeOut = dwTime;


            if ((hThreads[dwThread] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RefreshPolicyAndWait, &refUser, 0, 0)) == NULL) {
                PrintMsg(IDS_REFRESH_POLICY_FAILED, GetErrString(GetLastError(), szErr));
                goto Exit;
            }

            dwThread++;
        }


        PrintMsg(IDS_REFRESH_LAUNCHED);


        dwRet = WaitForMultipleObjects(dwThread, hThreads, TRUE, INFINITE);

        if ((dwRet != WAIT_OBJECT_0) && (dwRet != (WAIT_OBJECT_0 + 1))) {
            // our threads didn't terminate properly..
            PrintMsg(IDS_REFRESH_POLICY_FAILED, GetErrString(GetLastError(), szErr));
            goto Exit;
        }


        if (uTarget & REFRESH_USER) {
            PrintRefreshError(&refUser);
            if (refUser.fState != NO_FAILURE)
                bError = TRUE;
        }

        if (uTarget & REFRESH_MACHINE) {
            PrintRefreshError(&refMach);
            if (refMach.fState != NO_FAILURE)
                bError = TRUE;
        }

        if (NO_FAILURE == refMach.fState)
        {
            PrintMsg(IDS_LOOK_EVENT_LOG);
        }

        if (bError) {
            goto Exit;
        }
    }


    PrintMsg(IDS_SPACE);

    if ((uTarget & REFRESH_USER) && (bNextFgSync || refUser.bFGNeeded)) {
        if ( bNextFgSync ) 
            PrintMsg(IDS_NEED_LOGOFF_SYNC);
        else 
            PrintMsg(IDS_NEED_LOGOFF);
        bNeedLogoff = TRUE;
    }
        
    if ((uTarget & REFRESH_MACHINE) && (bNextFgSync || refMach.bFGNeeded)) {
        if ( bNextFgSync ) 
            PrintMsg(IDS_NEED_REBOOT_SYNC);
        else
            PrintMsg(IDS_NEED_REBOOT);
        bNeedBoot = TRUE;
    }


    if ( !bNeedBoot && !bNeedLogoff) {
        goto Exit;
    }


    PrintMsg(IDS_SPACE);
    
    if (bNeedBoot && !bOkToBoot) {
        bOkToBoot = PromptUserForFG(TRUE);
    }

    
    if (bNeedBoot && bOkToBoot) {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }

        BYTE                 bytesTokenPrivNew[sizeof(DWORD)+sizeof(LUID_AND_ATTRIBUTES)];
        PTOKEN_PRIVILEGES    pTokenPrivNew = (PTOKEN_PRIVILEGES)bytesTokenPrivNew;
        BYTE                 bytesTokenPrivOld[sizeof(DWORD)+sizeof(LUID_AND_ATTRIBUTES)];
        PTOKEN_PRIVILEGES    pTokenPrivOld = (PTOKEN_PRIVILEGES)bytesTokenPrivOld;

        DWORD                dwSize=sizeof(DWORD)+sizeof(LUID_AND_ATTRIBUTES);
        DWORD                dwRetSize=0;


        pTokenPrivNew->PrivilegeCount = 1;
        pTokenPrivNew->Privileges->Attributes = SE_PRIVILEGE_ENABLED;
        if (!LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &(pTokenPrivNew->Privileges->Luid))) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }

        if (!AdjustTokenPrivileges(hToken, FALSE, pTokenPrivNew, dwSize, pTokenPrivOld, &dwRetSize)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }


        PrintMsg(IDS_NOTIFY_MACHINE_FG);            
        if (!ExitWindowsEx(EWX_REBOOT, 0)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
        }
        else {
            PrintMsg(IDS_REBOOTING);
        }


        if (!AdjustTokenPrivileges(hToken, FALSE, pTokenPrivOld, 0, NULL, 0)) {
            PrintMsg(IDS_COULDNT_REBOOT, GetErrString(GetLastError(), szErr));
            goto Exit;
        }

        // if we are rebooting no need to call logoff code
        goto Exit;
    }
    


    if (bNeedLogoff && !bOkToLogoff) {
        bOkToLogoff = PromptUserForFG(FALSE);
    }

    if (bNeedLogoff && bOkToLogoff) {
        PrintMsg(IDS_NOTIFY_USER_FG);
        if (!ExitWindowsEx(EWX_LOGOFF, 0)) {
            PrintMsg(IDS_COULDNT_LOGOFF, GetErrString(GetLastError(), szErr));                
        }
        else {
            PrintMsg(IDS_LOGGING_OFF);
        }
    }

Exit:
    if (hToken) 
        CloseHandle(hToken);

    for (;dwThread;dwThread--) 
        if (hThreads[dwThread-1]) {
            CloseHandle(hThreads[dwThread-1]);
        }

    if (wargv1)
        GlobalFree(wargv1);

    if (wargv)
        LocalFree(wargv);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\refgp\sid.c ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "refgp.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}

//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    HRESULT     hr;
    SID_IDENTIFIER_AUTHORITY Auth;

    ULONG ulNoChars = lstrlen (lpszSidStr) + 1;
    pSidStr = LocalAlloc(LPTR, ulNoChars*sizeof(WCHAR));;
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    hr = StringCchCopy (pSidStr, ulNoChars, lpszSidStr);
    ASSERT(SUCCEEDED(hr));

    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        LocalFree( pSidStr );
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = lstrlenW (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;
    HRESULT hr;

    len = lstrlen (szNum);
    pwszNumStr = LocalAlloc( LPTR, (len + 1) * sizeof(WCHAR));

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    hr = StringCchCopy (pwszNumStr, len+1, szNum);
    ASSERT(SUCCEEDED(hr));

    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        LocalFree( pwszNumStr );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\proquota\proquota.c ===
//*************************************************************
//  File name: PROQUOTA.C
//
//  Description:  Profile quota management
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <windows.h>
#include <wchar.h>
#include <aclapi.h>
#include <shellapi.h>
#include <commctrl.h>
#include <objbase.h>
#include <strsafe.h>
#include "proquota.h"
#include "debug.h"

#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")

#define MAX_MESSAGE_LENGTH  256

HINSTANCE hInst;
HWND      hwndMain;
HWND      g_hQuotaDlg = NULL;
BOOL      g_bHideSmallItems;
BOOL      g_bShowReg = FALSE;
HANDLE    g_hThread;
HANDLE    g_hExitEvent;
HANDLE    g_hQuotaDlgEvent;
DWORD     g_dwProfileSize = 0;
DWORD     g_dwProfileSizeTemp = 0;
DWORD     g_dwMaxProfileSize = 10240;  //KB
CRITICAL_SECTION g_cs;
HICON     hIconGood, hIconCaution, hIconStop;
BOOL      g_bQueryEndSession;
TCHAR     g_szExcludeList[2*MAX_PATH + 2]; // "User exclusion list;Policy exclusion list"
TCHAR*    g_lpQuotaMessage = NULL;
DWORD     g_cbQuotaMessage = 0;

TCHAR     szClassName[] = TEXT("proquota");
TCHAR     szEventName[] = TEXT("proquota instance event");
TCHAR     szSizeFormat[40];

BOOL      g_bWarnUser = FALSE;
DWORD     g_dwWarnUserTimeout = 15;  // minutes
BOOL      g_bWarningTimerRunning = FALSE;
BOOL      g_bWarningDisplayed = FALSE;


//
// Function prototypes
//

LRESULT CALLBACK ProQuotaWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK QuotaDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL SetSecurity (void);
BOOL ReadRegistry (void);
BOOL ReadExclusionList();
VOID QuotaThread(HWND hWnd);
BOOL RecurseDirectory (LPTSTR lpDir, UINT cchBuffer, LPTSTR lpTop, HWND hLV, LPTSTR lpExcludeList);
BOOL EnumerateProfile (HWND hLV);
BOOL CheckSemicolon (LPTSTR lpDir, UINT cchBuffer);
LPTSTR CheckSlash (LPTSTR lpDir, UINT cchBuffer, UINT* pcchRemaining);
LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList);
BOOL GetDisplayName(LPCTSTR lpDir, LPTSTR lpTop, LPTSTR lpDisplayName, DWORD cchDisplayName);

//*************************************************************
//
//  WinMain()
//
//  Purpose:    Entry point
//
//  Parameters: hInstance     -  Instance handle
//              hPrevInstance -  Previous Instance
//              lpCmdLine     -  Command line
//              nCmdShow      -  ShowWindow flag
//
//  Return:     int
//
//*************************************************************

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
    MSG msg;
    WNDCLASS  wc;
    HANDLE hEvent = NULL;
    int iRet = 0;


    //
    // Verbose output
    //

#if DBG
    InitDebugSupport();
    DebugMsg((DM_VERBOSE, TEXT("WinMain:  Entering...")));
#endif

    hInst = hInstance;


    //
    // Check if this app is already running
    //

    hEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, szEventName);

    if (hEvent) {
        DebugMsg((DM_VERBOSE, TEXT("WinMain:  Proquota already running.  Exiting...")));
        goto Exit;
    }

    hEvent = CreateEvent (NULL, TRUE, TRUE, szEventName);


    g_hQuotaDlgEvent = CreateEvent (NULL, FALSE, TRUE, NULL);

    if (!g_hQuotaDlgEvent) {
        DebugMsg((DM_VERBOSE, TEXT("WinMain:  Proquota Couldn't get prowquota dlg event, error %d..."), GetLastError()));
        goto Exit;
    }

    //
    // Get the quota settings
    //

    if (!ReadRegistry()) {
        DebugMsg((DM_VERBOSE, TEXT("WinMain:  ReadRegistry returned FALSE.  Exiting...")));
        goto Exit;
    }

    //
    // Munge the access mask on the process token so taskmgr
    // can't kill this app.
    //

    SetSecurity();

    //
    // Make sure proquota is the first one that is attempted to be shutdown
    //

    SetProcessShutdownParameters(0x3ff, 0);

    //
    // Initialize
    //

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&g_cs, 0x80000000)) {
            DebugMsg((DM_WARNING, TEXT("WinMain: InitializeCriticalSectionAndSpinCount failed with %d"), GetLastError()));
            goto Exit;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DebugMsg((DM_WARNING, TEXT("WinMain: InitializeCriticalSection failed")));
        goto Exit;
    }

    InitCommonControls();
    CoInitialize(NULL);

    LoadString (hInst, IDS_SIZEFMT, szSizeFormat, ARRAYSIZE(szSizeFormat));

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = ProQuotaWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szClassName;

    if (!RegisterClass(&wc)) {
        DebugMsg((DM_WARNING, TEXT("WinMain:  RegisterClass failed with %d"), GetLastError()));
        goto Exit;
    }

    //
    // Create a hidden top level window so we get
    // broadcasted messages.
    //

    hwndMain = CreateWindow(szClassName, NULL, WS_OVERLAPPED, 0, 0, 0, 0,
                            NULL, NULL, hInstance, NULL);

    if (!hwndMain) {
        DebugMsg((DM_WARNING, TEXT("WinMain:  CreateWindow failed with %d"), GetLastError()));
        goto Exit;
    }

    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    iRet = (int)(msg.wParam);

Exit:

    DebugMsg((DM_VERBOSE, TEXT("WinMain:  Leaving...")));

    if (hEvent) {
        CloseHandle (hEvent);
    }

    if (g_hQuotaDlgEvent) {
        CloseHandle(g_hQuotaDlgEvent);
    }

    if (g_lpQuotaMessage) {
        LocalFree(g_lpQuotaMessage);
        g_lpQuotaMessage = NULL;
    }

    return iRet;
}

//*************************************************************
//
//  ProQuotaWndProc()
//
//  Purpose:    Window procedure
//
//  Parameters: hWnd    -   Window handle
//              message -   Window message
//              wParam  -   WPARAM
//              lParam  -   LPARAM
//
//
//  Return:     LRESULT
//
//*************************************************************

LRESULT CALLBACK ProQuotaWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD  dwThreadId;

    switch (message) {
       case WM_CREATE:

          hIconGood = LoadIcon (hInst, MAKEINTRESOURCE(IDI_ICON));
          hIconCaution = LoadIcon (hInst, MAKEINTRESOURCE(IDI_CAUTION));
          hIconStop = LoadIcon (hInst, MAKEINTRESOURCE(IDI_STOP));

          g_hExitEvent = CreateEvent (NULL, FALSE, FALSE, NULL);

          if (!g_hExitEvent) {
            DebugMsg((DM_WARNING, TEXT("ProQuotaWndProc:  Failed to create exit event with error %d"), GetLastError()));
            return -1;
          }

          g_hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) QuotaThread,
                                   (LPVOID) hWnd, CREATE_SUSPENDED, &dwThreadId);

          if (!g_hThread) {
              DebugMsg((DM_WARNING, TEXT("ProQuotaWndProc:  Failed to create thread with error %d"), GetLastError()));
              CloseHandle (g_hExitEvent);
              return -1;
          }

          SetThreadPriority (g_hThread, THREAD_PRIORITY_IDLE);
          ResumeThread (g_hThread);
          break;

       case WM_USER:

          if (lParam == WM_LBUTTONDBLCLK) {
              PostMessage (hWnd, WM_QUOTADLG, 0, 0);
          }

#if DBG
          if (lParam == WM_RBUTTONUP) {
              DestroyWindow (hWnd);
          }
#endif
          break;

       case WM_QUERYENDSESSION:
          {
              BOOL bLogoff;

              //EnterCriticalSection (&g_cs);
              bLogoff = (g_dwProfileSize <= g_dwMaxProfileSize);
              //LeaveCriticalSection (&g_cs);

              //
              // If it is zero assume that it has not yet finished enumerating..
              //
          
              if (g_dwProfileSize == 0) {
                  bLogoff = FALSE;
                  DebugMsg((DM_VERBOSE, TEXT("ProQuotaWndProc: Recd QueryEnd Message before enumerating.")));
              }
            
              DebugMsg((DM_VERBOSE, TEXT("ProQuotaWndProc: Recd QueryEnd Message. Returning %s"), bLogoff?TEXT("TRUE"):TEXT("FALSE")));

              if (bLogoff) {
                  return TRUE;
              }

              PostMessage (hWnd, WM_QUOTADLG, 1, 0);
          }
          return FALSE;


       case WM_QUOTADLG:
          if (!g_hQuotaDlg) {

              if (wParam) {
                  g_bQueryEndSession = TRUE;
              } else {
                  g_bQueryEndSession = FALSE;
              }

              DialogBox (hInst, MAKEINTRESOURCE(IDD_QUOTA), hwndMain, QuotaDlgProc);
              g_hQuotaDlg = NULL;
          }
          break;

       case WM_WARNUSER:
          if (!g_bWarningDisplayed) {
              TCHAR szTitle[100];

              g_bWarningDisplayed = TRUE;

              LoadString (hInst, IDS_MSGTITLE, szTitle, ARRAYSIZE(szTitle));
              MessageBox(hWnd, g_lpQuotaMessage, szTitle, MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL);

              g_bWarningDisplayed = FALSE;
          }
          break;

       case WM_TIMER:
          if (g_dwWarnUserTimeout > 0) {
             PostMessage (hWnd, WM_WARNUSER, 0, 0);
          }
          break;

       case WM_EXITWINDOWS:
          ExitWindowsDialog(NULL);
          break;

       case WM_DESTROY:
          {
          NOTIFYICONDATA nid;

          nid.cbSize = sizeof(nid);
          nid.hWnd   = hWnd;
          nid.uID    = 1;

          Shell_NotifyIcon (NIM_DELETE, &nid);

          SetEvent (g_hExitEvent);

          WaitForSingleObject (g_hThread, INFINITE);

          CloseHandle (g_hExitEvent);
          CloseHandle (g_hThread);
          PostQuitMessage(0);
          }
          break;

       default:
          return (DefWindowProc(hWnd, message, wParam, lParam));
       }

    return FALSE;
}



//*************************************************************
//
//  QuotaThread()
//
//  Purpose:    Initializes the tray icon
//
//  Parameters: hWnd    -    main window handle
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

VOID QuotaThread (HWND hWnd)
{
    NOTIFYICONDATA nid;
    TCHAR  szProfile[MAX_PATH];
    TCHAR  szMessage[MAX_MESSAGE_LENGTH];
    HANDLE hFileChange = INVALID_HANDLE_VALUE;
    HANDLE hRegChange = NULL;
    HANDLE hWaitHandles[4];
    BOOL   bFirst = TRUE;
    HICON  hOk = NULL, hWarning = NULL, hBad = NULL;
    DWORD  dwDelta;
    HKEY   hKeySystem = NULL;
    LONG   lResult;
    DWORD  dwResult;
    HRESULT hr;


    DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  Entering...")));

    //
    // Load the status icons
    //

    hOk = LoadImage (hInst, MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON,
                     16, 16, LR_DEFAULTCOLOR);
    if (!hOk) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to load OK icon. Error %d"), GetLastError()));
        goto Exit;
    }

    hWarning =  LoadImage (hInst, MAKEINTRESOURCE(IDI_CAUTION), IMAGE_ICON,
                           16, 16, LR_DEFAULTCOLOR);
    if (!hWarning) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to load Warning icon. Error %d"), GetLastError()));
        goto Exit;
    }

    hBad = LoadImage (hInst, MAKEINTRESOURCE(IDI_STOP), IMAGE_ICON,
                       16, 16, LR_DEFAULTCOLOR);
    if (!hBad) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to load stop icon. Error %d"), GetLastError()));
        goto Exit;
    }


    //
    // Get the profile directory
    //

    szProfile[0] = TEXT('\0');
    GetEnvironmentVariable (TEXT("USERPROFILE"), szProfile, ARRAYSIZE(szProfile));

    if (szProfile[0] == TEXT('\0')) {
        ExitThread (0);
    }
    DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User's profile:  <%s>"), szProfile));


    //
    // Setup change notify
    //

    hFileChange = FindFirstChangeNotification (szProfile, TRUE,
                                     FILE_NOTIFY_CHANGE_FILE_NAME |
                                     FILE_NOTIFY_CHANGE_DIR_NAME  |
                                     FILE_NOTIFY_CHANGE_SIZE);

    if (hFileChange == INVALID_HANDLE_VALUE) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to setup file change notification.  %d"),
                 GetLastError()));
        goto Exit;
    }


    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                            0, KEY_READ, &hKeySystem);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to open registry key.  %d"), lResult));
        goto Exit;
    }


    hRegChange = CreateEvent (NULL, FALSE, FALSE, NULL);

    if (!hRegChange) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to setup reg event for change notification.  %d"),
                 GetLastError()));
        goto Exit;
    }

    lResult = RegNotifyChangeKeyValue(hKeySystem, FALSE, REG_NOTIFY_CHANGE_LAST_SET,
                                      hRegChange, TRUE);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("QuotaThread:  Failed to setup RegNotifyChangeKeyValue.  %d"),
                 lResult));
        goto Exit;
    }


    hWaitHandles[0] = g_hExitEvent;
    hWaitHandles[1] = hFileChange;
    hWaitHandles[2] = hRegChange;
    hWaitHandles[3] = g_hQuotaDlgEvent;

    while (TRUE) {

        //
        // Calculate the profile size
        //

        if (g_hQuotaDlg) {
            DebugMsg((DM_VERBOSE, TEXT("QuotaTHread: Enumerating profile and refreshing dialog")));
            if (!EnumerateProfile (GetDlgItem (g_hQuotaDlg, IDC_QUOTA_FILELIST))) {
                DebugMsg((DM_WARNING, TEXT("QuotaThread:  EnumerateProfile failed with Dlg Item.")));
                break;
            }
        }
        else {
            if (!EnumerateProfile (NULL)) {
                DebugMsg((DM_WARNING, TEXT("QuotaThread:  EnumerateProfile failed.")));
                break;
            }
        }

        
        //
        // Update the status icon
        //

        nid.cbSize = sizeof(nid);
        nid.hWnd   = hWnd;
        nid.uID    = 1;
        nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
        nid.uCallbackMessage = WM_USER;
        szMessage[0] = TEXT('\0');

        if (g_dwProfileSize > g_dwMaxProfileSize) {
            DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User has exceeded their profile quota.")));
            nid.hIcon = hBad;
            LoadString (hInst, IDS_SIZEBAD, szMessage, ARRAYSIZE(szMessage));
            dwDelta = g_dwProfileSize - g_dwMaxProfileSize;

            if (g_bWarnUser && !g_bWarningTimerRunning) {
                g_bWarningTimerRunning = TRUE;
                SetTimer (hwndMain, 1, g_dwWarnUserTimeout * 60000, NULL);
                PostMessage (hwndMain, WM_WARNUSER, 0, 0);
            }

        } else if ( (g_dwMaxProfileSize - g_dwProfileSize) < (g_dwProfileSize * .10)) {
            DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User is within 10% of their profile quota.")));
            nid.hIcon = hWarning;
            LoadString (hInst, IDS_SIZEWARN, szMessage, ARRAYSIZE(szMessage));
            dwDelta = g_dwMaxProfileSize - g_dwProfileSize;

            if (g_bWarnUser && g_bWarningTimerRunning) {
                KillTimer (hwndMain, 1);
                g_bWarningTimerRunning = FALSE;
            }

        } else {
            DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  User has space available in their profile quota.")));
            nid.hIcon = hOk;
            LoadString (hInst, IDS_SIZEOK, szMessage, ARRAYSIZE(szMessage));
            dwDelta = g_dwMaxProfileSize - g_dwProfileSize;

            if (g_bWarnUser && g_bWarningTimerRunning) {
                KillTimer (hwndMain, 1);
                g_bWarningTimerRunning = FALSE;
            }
        }

        hr = StringCchPrintf(nid.szTip, ARRAYSIZE(nid.szTip), szMessage, dwDelta);
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("QuotaThread: Insufficient buffer for message. Error 0x%x"), hr));
            continue;
        }

        if (bFirst) {
            if (Shell_NotifyIcon (NIM_ADD, &nid))  {
                bFirst = FALSE;
            }
        } else {
            Shell_NotifyIcon (NIM_MODIFY, &nid);
        }


        //
        // Notify the dialog if it's present
        //

        if (g_hQuotaDlg) {
            PostMessage (g_hQuotaDlg, WM_REFRESH, 0, 0);
        }


        //
        // Clean up and wait for the next change
        //

        FindNextChangeNotification (hFileChange);


        dwResult = WaitForMultipleObjects (4, hWaitHandles, FALSE, INFINITE);


        if (dwResult == WAIT_FAILED) {
            break;
        }

        switch (dwResult - WAIT_OBJECT_0) {

            case 0:
                goto Exit;
                break;

            case 2:

                EnterCriticalSection (&g_cs);

                if (!ReadRegistry()) {
                    PostMessage (hwndMain, WM_DESTROY, 0, 0);
                    goto Exit;
                }
                
                LeaveCriticalSection (&g_cs);

                RegNotifyChangeKeyValue(hKeySystem, FALSE,
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                        hRegChange, TRUE);
                // fall through

            case 1:
                Sleep (2000);
                DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  Running background enumeration.")));
                break;

            case 3:
                break;
        }

    }


Exit:

    if (hOk) {
        DestroyIcon(hOk);
    }

    if (hWarning) {
        DestroyIcon(hWarning);
    }

    if (hBad) {
        DestroyIcon(hBad);
    }

    if (hKeySystem) {
        RegCloseKey (hKeySystem);
    }

    if (hRegChange) {
        CloseHandle (hRegChange);
    }
    
    if (INVALID_HANDLE_VALUE != hFileChange) {
        FindCloseChangeNotification (hFileChange);
    }
    
    DebugMsg((DM_VERBOSE, TEXT("QuotaThread:  Leaving...")));
    ExitThread (0);

}

//*************************************************************
//
//  SetSecurity()
//
//  Purpose:    Removes TERMINATE_PROCESS access to this process
//              so taskman can't blow us away.
//
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SetSecurity (void)
{
    HANDLE hProcess;
    PACL  pDACL;
    PSECURITY_DESCRIPTOR pSD;
    WORD wIndex;
    ACE_HEADER * lpAceHeader;
    ACCESS_ALLOWED_ACE * lpAce;
    DWORD dwResult;

    hProcess = GetCurrentProcess();

    if (GetSecurityInfo (hProcess, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,
                         NULL, NULL, &pDACL, NULL, &pSD) != ERROR_SUCCESS) {
        return FALSE;
    }

    for (wIndex = 0; wIndex < pDACL->AceCount; wIndex++) {

        if (GetAce(pDACL, wIndex, &lpAceHeader)) {

            if (lpAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE) {
                lpAce = (ACCESS_ALLOWED_ACE *) lpAceHeader;

                lpAce->Mask &= ~(PROCESS_TERMINATE | WRITE_DAC | WRITE_OWNER);
            }
        }
    }

    dwResult = SetSecurityInfo (hProcess, SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,
                                NULL, NULL, pDACL, NULL);

    LocalFree (pSD);

    if (dwResult != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  ReadExclusionList()
//
//  Purpose:    Checks if the profile quota policy is set,
//              and if so gets the max profile size.
//
//  Parameters: void
//
//  Return:     TRUE if profile quota is enabled
//              FALSE if not
//
//*************************************************************

BOOL ReadExclusionList()
{
    TCHAR szExcludeList2[MAX_PATH+1];
    TCHAR szExcludeList1[MAX_PATH+1];
    HKEY  hKey;
    DWORD dwSize, dwType;
    HRESULT hr;

    //
    // Check for a list of directories to exclude both user preferences
    // and user policy
    //

    szExcludeList1[0] = TEXT('\0');
    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList1);
        if (RegQueryValueEx (hKey,
                             TEXT("ExcludeProfileDirs"),
                             NULL,
                             &dwType,
                             (LPBYTE) szExcludeList1,
                             &dwSize) != ERROR_SUCCESS) {

            // ignore user exclusion list
            szExcludeList1[0] = TEXT('\0');
        }

        RegCloseKey (hKey);
    }

    szExcludeList2[0] = TEXT('\0');
    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      SYSTEM_POLICIES_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList2);
        if (RegQueryValueEx (hKey,
                             TEXT("ExcludeProfileDirs"),
                             NULL,
                             &dwType,
                             (LPBYTE) szExcludeList2,
                             &dwSize) != ERROR_SUCCESS) {

            // ignore policy exclusion list
            szExcludeList2[0] = TEXT('\0');
        }

        RegCloseKey (hKey);
    }


    //
    // Merge the user preferences and policy together
    //

    g_szExcludeList[0] = TEXT('\0');

    if (szExcludeList1[0] != TEXT('\0')) {
        hr = StringCchCopy(g_szExcludeList, ARRAYSIZE(g_szExcludeList), szExcludeList1);
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("ReadExclusionList: Fail to copy user exclusion list. Error 0x%x"), hr));
            return FALSE;
        }
        
        if (!CheckSemicolon(g_szExcludeList, ARRAYSIZE(g_szExcludeList))) {
            return FALSE;
        }
    }

    if (szExcludeList2[0] != TEXT('\0')) {
        hr = StringCchCat(g_szExcludeList, ARRAYSIZE(g_szExcludeList), szExcludeList2);
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("ReadExclusionList: Fail to copy policy exclusion list. Error 0x%x"), hr));
            return FALSE;
        }
    }

    return TRUE;
}


//*************************************************************
//
//  ReadQuotaMsg()
//
//  Purpose:    Reads the msg that needs to be displayed.
//
//  Parameters: hKey    - Handle to the open policy 
//
//  Return:     TRUE if mesg could be read
//              FALSE otherwise
//
//*************************************************************
BOOL ReadQuotaMsg(HKEY hKey)
{
    DWORD dwType, dwSize, dwValue, dwErr;
    BOOL  bLoadDefault = FALSE;

    if (!g_lpQuotaMessage) {
        g_cbQuotaMessage = MAX_PATH * sizeof(TCHAR);
        g_lpQuotaMessage = LocalAlloc (LPTR, g_cbQuotaMessage);
        if (!g_lpQuotaMessage) {
            g_cbQuotaMessage = 0;
            DebugMsg((DM_WARNING, TEXT("ReadQuotaMsg:  Failed to allocate memory for msg with %d."), GetLastError()));
            return FALSE;
        }
    }
    
    //
    // Query the size for quota message
    //

    dwErr = RegQueryValueEx (hKey,  TEXT("ProfileQuotaMessage"), NULL,
                             &dwType, NULL, &dwSize);
    
    if (dwErr != ERROR_SUCCESS) {
        //
        // Load the default message otherwise
        //

        bLoadDefault = TRUE;
        goto Load_Default;
    }

    // Ensure proper size
    if (dwSize > g_cbQuotaMessage) {
        if (g_lpQuotaMessage) {
            LocalFree(g_lpQuotaMessage);
        }

        g_cbQuotaMessage = dwSize;
        g_lpQuotaMessage = LocalAlloc(LPTR, g_cbQuotaMessage);
        if (!g_lpQuotaMessage) {
            g_cbQuotaMessage = 0;
            DebugMsg((DM_WARNING, TEXT("ReadQuotaMsg:  Failed to allocate memory for msg with %d."), GetLastError()));
            return FALSE;
        }
    }
    
    dwSize = g_cbQuotaMessage;
    dwErr = RegQueryValueEx (hKey,  TEXT("ProfileQuotaMessage"), NULL,
                             &dwType, (LPBYTE) g_lpQuotaMessage, &dwSize);
    
    if (dwErr != ERROR_SUCCESS) {
        //
        // Load the default message otherwise
        //

        bLoadDefault = TRUE;
        goto Load_Default;
    }

    //
    // if there is any message expand the environment variables in it.
    //
    
    if (*g_lpQuotaMessage) {
        DWORD  cchSize;
        LPTSTR lpTemp;

        //
        // Get the size of expanded string buffer including NULL terminator
        //

        cchSize = ExpandEnvironmentStrings (g_lpQuotaMessage, NULL, 0);
        if (cchSize == 0) {
            //
            // Load the default message otherwise
            //

            DebugMsg((DM_WARNING, TEXT("ReadQuotaMsg: Failed to expand env var"), GetLastError()));
            bLoadDefault = TRUE;
            goto Load_Default;
        }

        lpTemp = LocalAlloc (LPTR, cchSize * sizeof(TCHAR));
        
        if (lpTemp) {
            cchSize = ExpandEnvironmentStrings (g_lpQuotaMessage, lpTemp, cchSize);
            
            if (cchSize == 0) {
                //
                // Load the default message otherwise
                //

                DebugMsg((DM_WARNING, TEXT("ReadQuotaMsg: Failed to expand env var"), GetLastError()));
                bLoadDefault = TRUE;
                goto Load_Default;
            }

            if (cchSize * sizeof(TCHAR) > g_cbQuotaMessage) {
                LocalFree(g_lpQuotaMessage);
                g_lpQuotaMessage = lpTemp;
                g_cbQuotaMessage = cchSize * sizeof(TCHAR);
            }
            else {
                if (FAILED(StringCchCopy(g_lpQuotaMessage, g_cbQuotaMessage/sizeof(TCHAR), lpTemp))) {
                    bLoadDefault = TRUE;
                }

                LocalFree(lpTemp);
            }
        }
        else {
            DebugMsg((DM_WARNING, TEXT("ReadQuotaMsg: Failed to allocate memory for tmp buffer with %d.Not expanding env var"), GetLastError()));
        }
    }

Load_Default:

    if (bLoadDefault) {
        //
        // Load the default message in case of error
        //

        LoadString (hInst, IDS_DEFAULTMSG, g_lpQuotaMessage, g_cbQuotaMessage/sizeof(TCHAR));
    }
    
    return TRUE;
}

//*************************************************************
//
//  ReadRegistry()
//
//  Purpose:    Checks if the profile quota policy is set,
//              and if so gets the max profile size.
//
//  Parameters: void
//
//  Return:     TRUE if profile quota is enabled
//              FALSE if not
//
//*************************************************************
BOOL ReadRegistry (void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwValue, dwErr;

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                            0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwValue);
        lResult = RegQueryValueEx (hKey, TEXT("EnableProfileQuota"), NULL,
                                   &dwType, (LPBYTE) &dwValue, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            if (dwValue) {

                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Profile quotas are enabled.")));

                dwSize = sizeof(g_dwMaxProfileSize);
                RegQueryValueEx (hKey, TEXT("MaxProfileSize"), NULL,
                                 &dwType, (LPBYTE) &g_dwMaxProfileSize, &dwSize);
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Max Profile Size:  %d"), g_dwMaxProfileSize));


                dwSize = sizeof(g_bShowReg);
                RegQueryValueEx (hKey, TEXT("IncludeRegInProQuota"), NULL,
                                 &dwType, (LPBYTE) &g_bShowReg, &dwSize);
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Show registry in file list:  %s"),
                         g_bShowReg ? TEXT("TRUE") : TEXT("FALSE")));


                dwSize = sizeof(g_bWarnUser);
                RegQueryValueEx (hKey, TEXT("WarnUser"), NULL,
                                 &dwType, (LPBYTE) &g_bWarnUser, &dwSize);
                DebugMsg((DM_VERBOSE, TEXT("ReadRegistry:  Warn user when quota exceeded:  %s"),
                         g_bWarnUser ? TEXT("TRUE") : TEXT("FALSE")));


                if (g_bWarnUser) {

                    dwSize = sizeof(g_dwWarnUserTimeout);
                 