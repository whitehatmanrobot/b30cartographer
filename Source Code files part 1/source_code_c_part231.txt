             iii. If a referance belongs in the partial order then it is a "strong referance" else
                        it is a weak referance.
         *** 2. Sufficient conditions to ensure no COM objects are leaked: ***
                 a. When Neuter() is invoked:
                     i. Calles Release on all its weak referances.
                    ii. Then, for each strong referance: 
                         1. invoke Neuter()
                         2. invoke Release()
                   iii. If it's derived from a CordbXXX class, call Neuter() on the base class.
                         1. Sense Neuter() is virtual, use the scope specifier Cordb[BaseClass]::Neuter().
             3. All members return error codes, except:
                 a. Members of IUknown, AddRef(), Release(), QueryInterfac()
                 b. Those documented to have functionality when the object is neutered.
                     i. Neuter() still works w/o error. If it is invoke a second time it will have already 
                        released all its strong and weak referances so it could just return.


        Alternate design ideas:

            DESIGN: Note that it's possible for object B to have two parents in the partial order
                    and it must be documented which one is responsible for calling Neuter() on B.
                     1. For example, CordbCode could reasonably be a sibling of CordbFunction and CordbNativeFrame.
                        Which one should call Release()? For now we have CordbFunction call Release() on CordbCode.

            DESIGN: It is not a necessary condition in that Neuter() invoke Release() on all
                    it's strong referances. Instead, it would be sufficent to ensure all object are released, that
                    each object call Release() on all its strong pointers in its destructor.
                     1. This might be done if its necessary for some member to return "tombstone" 
                        information after the object has been netuered() which involves the siblings (wrt poset)
                        of the object. However, no sibling could access a parent (wrt poset) because
                        Neuter called Release() on all its weak pointers.
                        
            DESIGN: Rename Neuter() to some name that more accurately reflect the semantics. 
                     1. The three operations are:
                         a. ReleaseWeakPointers()
                         b. NeuterStrongPointers()
                         c. ReleaseStrongPointers()
                             1. Assert that it's done after NeuterStrongPointers()
                     2. That would introduce a bunch of functions... but it would be clear.

            DESIGN: CordbBase could provide a function to register strong and weak referances. That way CordbBase 
                    could implement a general version of ReleaseWeak/ReleaseStrong/NeuterStrongPointers(). This
                    would provide a very error resistant framework for extending the object model plus it would
                    be very explicit about what is going on. 
                        One thing that might trip this is idea up is that if an object has two parents,
                        like the CordbCode might, then either both objects call Neuter or one is referance
                        is made weak.
                    
                     
         Our implementation:

            The graph fromed by the strong referances must remain acyclic.
            It's up to the developer (YOU!) to ensure that each Neuter
            function maintains that invariant. 
            
            Here is the current Partial Order on CordbXXX objects. (All these classes
            eventually chain to CordbBase.Neuter() for completeness.) 
            
             Cordb
                CordbProcess
                    CordbAppDomain
                        CordbBreakPoints
                        CordbAssembly
                        CordbModule
                            CordbClass
                            CordbFunction
                                CordbCode (Can we assert a thread will not referance 
                                            the same CordbCode as a CordbFunction?) 
                    CordbThread
                        CordbChains
                        CordbNativeFrame -> CordbFrame (Chain to baseClass)
                            CordbJITILFrame


            TODO: Some Neuter functions have not yet been implemented due to time restrictions.

            TODO: Some weak referances never have AddRef() called on them. If that's cool then
                  it should be stated in the documentation. Else it should be changed.
     */ 
     
    virtual void Neuter()
    {
        ;
    }

    //-----------------------------------------------------------
    // IUnknown support
    //----------------------------------------------------------


    ULONG STDMETHODCALLTYPE BaseAddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE BaseRelease() 
    {
        long        refCount = InterlockedDecrement((long *) &m_refCount);
        if (refCount == 0)
            delete this;

        return (refCount);
    }

protected:
    void NeuterAndClearHashtable(CordbHashTable * pCordbHashtable);
};

/* ------------------------------------------------------------------------- *
 * Hash table
 * ------------------------------------------------------------------------- */

struct CordbHashEntry
{
    FREEHASHENTRY entry;
    CordbBase *pBase;
};

class CordbHashTable : private CHashTableAndData<CNewData>
{
private:
    bool    m_initialized;
    SIZE_T  m_count;

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    {
        return ((ULONG)pc1) != ((CordbHashEntry*)pc2)->pBase->m_id;
    }

    USHORT HASH(ULONG id)
    {
        return (USHORT) (id ^ (id>>16));
    }

    BYTE *KEY(ULONG id)
    {
        return (BYTE *) id;
    }

public:

    CordbHashTable(USHORT size) 
    : CHashTableAndData<CNewData>(size), m_initialized(false), m_count(0)
    {
        
    }
    virtual ~CordbHashTable();

#ifndef RIGHT_SIDE_ONLY
#ifdef _DEBUG
private:
    BYTE *Add(
        USHORT      iHash)              // Hash value of entry to add.
    {
        _ASSERTE(g_dwInprocLockOwner == GetCurrentThreadId());
        return CHashTableAndData<CNewData>::Add(iHash);
    }

    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        USHORT      iIndex)             // Index of struct in m_pcEntries.
    {
        _ASSERTE(g_dwInprocLockOwner == GetCurrentThreadId());
        return CHashTableAndData<CNewData>::Delete(iHash, iIndex);
    }

    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        HASHENTRY   *psEntry)           // The struct to delete.
    {
        _ASSERTE(g_dwInprocLockOwner == GetCurrentThreadId());
        return CHashTableAndData<CNewData>::Delete(iHash, psEntry);
    }

    BYTE *Find(                         // Index of struct in m_pcEntries.
        USHORT      iHash,              // Hash value of the item.
        BYTE        *pcKey)             // The key to match.
    {
        _ASSERTE(g_dwInprocLockOwner == GetCurrentThreadId());
        return CHashTableAndData<CNewData>::Find(iHash, pcKey);
    }

    USHORT FindNext(                    // Index of struct in m_pcEntries.
        BYTE        *pcKey,             // The key to match.
        USHORT      iIndex)             // Index of previous match.
    {
        _ASSERTE(g_dwInprocLockOwner == GetCurrentThreadId());
        return CHashTableAndData<CNewData>::FindNext(pcKey, iIndex);
    }

    BYTE *FindFirstEntry(               // First entry found, or 0.
        HASHFIND    *psSrch)            // Search object.
    {
        _ASSERTE(g_dwInprocLockOwner == GetCurrentThreadId());
        return CHashTableAndData<CNewData>::FindFirstEntry(psSrch);
    }

    BYTE *FindNextEntry(                // The next entry, or0 for end of list.
        HASHFIND    *psSrch)            // Search object.
    {
        _ASSERTE(g_dwInprocLockOwner == GetCurrentThreadId());
        return CHashTableAndData<CNewData>::FindNextEntry(psSrch);
    }

public:

#endif // _DEBUG
#endif // !RIGHT_SIDE_ONLY


    HRESULT AddBase(CordbBase *pBase);
#ifndef RIGHT_SIDE_ONLY        
    typedef union
    {
        Assembly *pAssemblySpecial;
    } SpecialCasePointers;
    
    CordbBase *GetBase(ULONG id, 
                       BOOL fFab = TRUE, 
                       SpecialCasePointers *scp = NULL);

#else
    CordbBase *GetBase(ULONG id, BOOL fFab = TRUE);
#endif //RIGHT_SIDE_ONLY
    CordbBase *RemoveBase(ULONG id);

    ULONG32 GetCount()
    {
        return (m_count);
    } 

    CordbBase *FindFirst(HASHFIND *find);
    CordbBase *FindNext(HASHFIND *find);

public:
#ifndef RIGHT_SIDE_ONLY
    GUID    m_guid; //what type of hashtable? borrow enum IIDs...
    union
    {
        struct 
        {
            CordbProcess   *m_proc;
        } lsAppD;

        struct 
        {
            CordbProcess   *m_proc;
        } lsThread;

        struct
        {
            CordbAppDomain *m_appDomain;
        } lsAssem;

        struct
        {
            CordbProcess    *m_proc;
            CordbAppDomain  *m_appDomain;
        } lsMod;
        
    } m_creator;
#endif //RIGHT_SIDE_ONLY    
};

class CordbHashTableEnum : public CordbBase, 
public ICorDebugProcessEnum,
public ICorDebugBreakpointEnum,
public ICorDebugStepperEnum,
public ICorDebugThreadEnum,
public ICorDebugModuleEnum,
public ICorDebugAppDomainEnum,
public ICorDebugAssemblyEnum
{
public:
    CordbHashTableEnum(CordbHashTableEnum *cloneSrc);
    CordbHashTableEnum(CordbHashTable *table, 
                       const _GUID &id);

    ~CordbHashTableEnum();

    HRESULT Next(ULONG celt, CordbBase *bases[], ULONG *pceltFetched);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugEnum
    //-----------------------------------------------------------

    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset();
    COM_METHOD Clone(ICorDebugEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);

    //-----------------------------------------------------------
    // ICorDebugProcessEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugProcess *processes[],
                    ULONG *pceltFetched)
    {
        VALIDATE_POINTER_TO_OBJECT_ARRAY(processes, ICorDebugProcess *, 
            celt, true, true);
        VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

        return (Next(celt, (CordbBase **)processes, pceltFetched));
    }

    //-----------------------------------------------------------
    // ICorDebugBreakpointEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugBreakpoint *breakpoints[],
                    ULONG *pceltFetched)
    {
        VALIDATE_POINTER_TO_OBJECT_ARRAY(breakpoints, ICorDebugBreakpoint *, 
            celt, true, true);
        VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

        return (Next(celt, (CordbBase **)breakpoints, pceltFetched));
    }

    //-----------------------------------------------------------
    // ICorDebugStepperEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugStepper *steppers[],
                    ULONG *pceltFetched)
    {
        VALIDATE_POINTER_TO_OBJECT_ARRAY(steppers, ICorDebugStepper *, 
            celt, true, true);
        VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

        return (Next(celt, (CordbBase **)steppers, pceltFetched));
    }

    //-----------------------------------------------------------
    // ICorDebugThreadEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugThread *threads[],
                    ULONG *pceltFetched)
    {
        VALIDATE_POINTER_TO_OBJECT_ARRAY(threads, ICorDebugThread *, 
            celt, true, true);
        VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

        return (Next(celt, (CordbBase **)threads, pceltFetched));
    }

    //-----------------------------------------------------------
    // ICorDebugModuleEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugModule *modules[],
                    ULONG *pceltFetched)
    {
        VALIDATE_POINTER_TO_OBJECT_ARRAY(modules, ICorDebugModule *, 
            celt, true, true);
        VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

        return (Next(celt, (CordbBase **)modules, pceltFetched));
    }

    //-----------------------------------------------------------
    // ICorDebugAppDomainEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugAppDomain *appdomains[],
                    ULONG *pceltFetched)
    {
        VALIDATE_POINTER_TO_OBJECT_ARRAY(appdomains, ICorDebugAppDomain *, 
            celt, true, true);
        VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

        return (Next(celt, (CordbBase **)appdomains, pceltFetched));
    }
    //-----------------------------------------------------------
    // ICorDebugAssemblyEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugAssembly *assemblies[],
                    ULONG *pceltFetched)
    {
        VALIDATE_POINTER_TO_OBJECT_ARRAY(assemblies, ICorDebugAssembly *, 
            celt, true, true);
        VALIDATE_POINTER_TO_OBJECT(pceltFetched, ULONG *);

        return (Next(celt, (CordbBase **)assemblies, pceltFetched));
    }
private:
    CordbHashTable *m_table;
    bool            m_started;
    bool            m_done;
    HASHFIND        m_hashfind;
    REFIID          m_guid;
    ULONG           m_iCurElt;
    ULONG           m_count;
    BOOL            m_fCountInit;

public:
    BOOL            m_SkipDeletedAppDomains;

private:
    //These factor code between Next & Skip
    HRESULT PrepForEnum(CordbBase **pBase);

    // Note that the set of types advanced by Pre & by Post are disjoint, and
    // that the union of these two sets are all possible types enuerated by
    // the CordbHashTableEnum.
    HRESULT AdvancePreAssign(CordbBase **pBase);
    HRESULT AdvancePostAssign(CordbBase **pBase, 
                              CordbBase     **b,
                              CordbBase   **bEnd);

    // This factors some code that initializes the module enumerator.
    HRESULT SetupModuleEnumForSystemIteration(void);
    HRESULT GetNextSpecialModule(void);
    
public:
#ifndef RIGHT_SIDE_ONLY

    //We can get our modules from three places:
    // A special field so that during a module load we can get info about
    //      module (we set this in the EE prior to calling the callback)
    // Iterating through the system assemblies
    // Iterating though this appdomains' assemblies.
    enum MODULE_ENUMS
    {
        ME_SPECIAL,
        ME_SYSTEM,
        ME_APPDOMAIN,
    };

    union
    {
        struct 
        {
            AppDomain **pDomains;
            AppDomain **pCurrent;
            AppDomain **pMax;
            CordbProcess   *m_proc;
        } lsAppD;

        struct
        {
            Thread         *m_pThread;
        } lsThread;

        struct //copied into lsMod, below, as well
        {
            AppDomain::AssemblyIterator m_i;
            BOOL                        m_fSystem; // as opposed to
                                                   // non shared assembly;
                                                   // this'll be init'd
                                                   // to false by the memset
        } lsAssem;

        struct
        {
            AppDomain::AssemblyIterator m_i;
            Module                     *m_pMod; //The current module
            MODULE_ENUMS                m_meWhich; 
            ICorDebugThreadEnum        *m_enumThreads;
            CordbThread                *m_threadCur;
            CordbAppDomain             *m_appDomain;
        } lsMod;

    } m_enumerator;

#endif //RIGHT_SIDE_ONLY
};

/* ------------------------------------------------------------------------- *
 * Cordb class
 * ------------------------------------------------------------------------- */

class Cordb : public CordbBase, public ICorDebug
{
public:
    Cordb();
    virtual ~Cordb();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebug
    //-----------------------------------------------------------

    COM_METHOD Initialize();
    COM_METHOD Terminate();
    COM_METHOD SetManagedHandler(ICorDebugManagedCallback *pCallback);
    COM_METHOD SetUnmanagedHandler(ICorDebugUnmanagedCallback *pCallback);
    COM_METHOD CreateProcess(LPCWSTR lpApplicationName,
                             LPWSTR lpCommandLine,
                             LPSECURITY_ATTRIBUTES lpProcessAttributes,
                             LPSECURITY_ATTRIBUTES lpThreadAttributes,
                             BOOL bInheritHandles,
                             DWORD dwCreationFlags,
                             PVOID lpEnvironment,
                             LPCWSTR lpCurrentDirectory,
                             LPSTARTUPINFOW lpStartupInfo,
                             LPPROCESS_INFORMATION lpProcessInformation,
                             CorDebugCreateProcessFlags debuggingFlags,
                             ICorDebugProcess **ppProcess);
    COM_METHOD DebugActiveProcess(DWORD id, BOOL win32Attach, ICorDebugProcess **ppProcess);
    COM_METHOD EnumerateProcesses(ICorDebugProcessEnum **ppProcess);
    COM_METHOD GetProcess(DWORD dwProcessId, ICorDebugProcess **ppProcess);
    COM_METHOD CanLaunchOrAttach(DWORD dwProcessId, BOOL win32DebuggingEnabled);

    //-----------------------------------------------------------
    // CorDebug
    //-----------------------------------------------------------

    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        if (id != IID_IUnknown && id != IID_ICorDebug)
            return (E_NOINTERFACE);

        Cordb *db = new Cordb();

        if (db == NULL)
            return (E_OUTOFMEMORY);

        *object = (ICorDebug*)db;
        db->AddRef();

        return (S_OK);
    }

    //-----------------------------------------------------------
    // Methods not exposed via a COM interface.
    //-----------------------------------------------------------

    bool AllowAnotherProcess();
    HRESULT AddProcess(CordbProcess* process);
    void RemoveProcess(CordbProcess* process);
    void LockProcessList(void);
    void UnlockProcessList(void);

    HRESULT SendIPCEvent(CordbProcess* process,
                         DebuggerIPCEvent* event,
                         SIZE_T eventSize);
    void ProcessStateChanged(void);

    HRESULT WaitForIPCEventFromProcess(CordbProcess* process,
                                       CordbAppDomain *appDomain,
                                       DebuggerIPCEvent* event);

    // Gets the first event, used for in-proc stuff                                       
    HRESULT GetFirstContinuationEvent(CordbProcess *process, 
                                      DebuggerIPCEvent *event);
                                      
    HRESULT GetNextContinuationEvent(CordbProcess *process, 
                                     DebuggerIPCEvent *event);


    HRESULT GetCorRuntimeHost(ICorRuntimeHost **ppHost);
    HRESULT GetCorDBPrivHelper(ICorDBPrivHelper **ppHelper);
    
    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    ICorDebugManagedCallback    *m_managedCallback;
    ICorDebugUnmanagedCallback  *m_unmanagedCallback;
    CordbHashTable              m_processes;
    IMetaDataDispenser         *m_pMetaDispenser;

    CordbWin32EventThread*      m_win32EventThread;

    static bool                 m_runningOnNT;

    CordbRCEventThread*         m_rcEventThread;

    ICorRuntimeHost            *m_pCorHost;

    HANDLE                      m_crazyWin98WorkaroundEvent;
    
#ifndef RIGHT_SIDE_ONLY
    CordbProcess               *m_procThis;
#endif //RIGHT_SIDE_ONLY

private:
    BOOL                        m_initialized;
    CRITICAL_SECTION            m_processListMutex;
};



/* ------------------------------------------------------------------------- *
 * AppDomain class
 * ------------------------------------------------------------------------- */

class CordbAppDomain : public CordbBase, public ICorDebugAppDomain
{
public:
    CordbAppDomain(CordbProcess* pProcess, 
                    REMOTE_PTR pAppDomainToken, 
                    ULONG id,
                    WCHAR *szName);
    virtual ~CordbAppDomain();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugController
    //-----------------------------------------------------------

    COM_METHOD Stop(DWORD dwTimeout);
    COM_METHOD Deprecated_Continue(void);
    COM_METHOD Continue(BOOL fIsOutOfBand);
    COM_METHOD IsRunning(BOOL *pbRunning);
    COM_METHOD HasQueuedCallbacks(ICorDebugThread *pThread, BOOL *pbQueued);
    COM_METHOD EnumerateThreads(ICorDebugThreadEnum **ppThreads);
    COM_METHOD SetAllThreadsDebugState(CorDebugThreadState state,
                                       ICorDebugThread *pExceptThisThread);
    COM_METHOD Detach();
    COM_METHOD Terminate(unsigned int exitCode);

    COM_METHOD CanCommitChanges(
        ULONG cSnapshots, 
        ICorDebugEditAndContinueSnapshot *pSnapshots[], 
        ICorDebugErrorInfoEnum **pError);

    COM_METHOD CommitChanges(
        ULONG cSnapshots, 
        ICorDebugEditAndContinueSnapshot *pSnapshots[], 
        ICorDebugErrorInfoEnum **pError);


    //-----------------------------------------------------------
    // ICorDebugAppDomain
    //-----------------------------------------------------------
    /*      
     * GetProcess returns the process containing the app domain
     */

    COM_METHOD GetProcess(ICorDebugProcess **ppProcess);        

    /*        
     * EnumerateAssemblies enumerates all assemblies in the app domain
     */

    COM_METHOD EnumerateAssemblies(ICorDebugAssemblyEnum **ppAssemblies);

    COM_METHOD GetModuleFromMetaDataInterface(IUnknown *pIMetaData,
                                              ICorDebugModule **ppModule);
    /*
     * EnumerateBreakpoints returns an enum of all active breakpoints
     * in the app domain.  This includes all types of breakpoints :
     * function breakpoints, data breakpoints, etc.
     */

    COM_METHOD EnumerateBreakpoints(ICorDebugBreakpointEnum **ppBreakpoints);

    /*
     * EnumerateSteppers returns an enum of all active steppers in the app domain.
     */

    COM_METHOD EnumerateSteppers(ICorDebugStepperEnum **ppSteppers);
    /*
     * IsAttached returns whether or not the debugger is attached to the 
     * app domain.  The controller methods on the app domain cannot be used
     * until the debugger attaches to the app domain.
     */

    COM_METHOD IsAttached(BOOL *pbAttached);

    /*
     * GetName returns the name of the app domain. 
     * Note:   This method is not yet implemented.
     */

    COM_METHOD GetName(ULONG32 cchName, 
                      ULONG32 *pcchName, 
                      WCHAR szName[]); 

    /*
     * GetObject returns the runtime app domain object. 
     * Note:   This method is not yet implemented.
     */

    COM_METHOD GetObject(ICorDebugValue **ppObject);
    COM_METHOD Attach (void);
    COM_METHOD GetID (ULONG32 *pId);

    void Lock (void)
    { 
        LOCKCOUNTINCL("Lock in cordb.h");                               \

        EnterCriticalSection (&m_hCritSect);
    }
    void Unlock (void) 
    { 
        LeaveCriticalSection (&m_hCritSect);
        LOCKCOUNTDECL("Unlock in cordb.h");                             \
    
    }
    HRESULT ResolveClassByName(LPWSTR fullClassName,
                               CordbClass **ppClass);
    CordbModule *GetAnyModule(void);
    CordbModule *LookupModule(REMOTE_PTR debuggerModuleToken);
    void MarkForDeletion (void) { m_fMarkedForDeletion = TRUE;}
    BOOL IsMarkedForDeletion (void) { return m_fMarkedForDeletion;}


public:

    BOOL                m_fAttached;
    BOOL                m_fHasAtLeastOneThreadInsideIt; // So if we detach, we'll know
                                    // if we should eliminate the CordbAppDomain upon
                                    // thread_detach, or appdomain_exit.
    CordbProcess        *m_pProcess;
    WCHAR               *m_szAppDomainName;
    bool                m_nameIsValid;
    ULONG               m_AppDomainId;

    CordbHashTable      m_assemblies;
    CordbHashTable      m_modules;
    CordbHashTable      m_breakpoints;

private:
    bool                m_synchronizedAD; // to be used later
    CRITICAL_SECTION    m_hCritSect;
    BOOL                m_fMarkedForDeletion;


};


/* ------------------------------------------------------------------------- *
 * Assembly class
 * ------------------------------------------------------------------------- */

class CordbAssembly : public CordbBase, public ICorDebugAssembly
{
public:
    CordbAssembly(CordbAppDomain* pAppDomain, 
                    REMOTE_PTR debuggerAssemblyToken, 
                    const WCHAR *szName,
                    BOOL fIsSystemAssembly);
    virtual ~CordbAssembly();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    /*      
     * GetProcess returns the process containing the assembly
     */
    COM_METHOD GetProcess(ICorDebugProcess **ppProcess);        

    /*      
     * GetAppDomain returns the app domain containing the assembly.
     * Returns null if this is the system assembly
     */
    COM_METHOD GetAppDomain(ICorDebugAppDomain **ppAppDomain);      

    /*        
     * EnumerateModules enumerates all modules in the assembly
     */
    COM_METHOD EnumerateModules(ICorDebugModuleEnum **ppModules);

    /*
     * GetCodeBase returns the code base used to load the assembly
     */
    COM_METHOD GetCodeBase(ULONG32 cchName, 
                        ULONG32 *pcchName,
                        WCHAR szName[]); 

    /*
     * GetName returns the name of the assembly
     */
    COM_METHOD GetName(ULONG32 cchName, 
                      ULONG32 *pcchName,
                      WCHAR szName[]); 


    CordbAppDomain *GetAppDomain()
    {
        return m_pAppDomain;
    }

    BOOL IsSystemAssembly(void) { return m_fIsSystemAssembly;}

public:
    CordbAppDomain      *m_pAppDomain;
    WCHAR               *m_szAssemblyName;
    BOOL                m_fIsSystemAssembly;

};

/* ------------------------------------------------------------------------- *
 * MetaDataPointerCache class
   This class created on May 30th in response to bug 86954. Excerpts from that bug:
   
        Summary: for every module loaded into every AD, we send a ModuleLoad event to the 
        out-of-process debugging services. We do this even if the module is shared, creating an 
        illusion for the debugger that there are no shared modules. Everytime we receive a 
        ModuleLoad event on the out-of-process side, we copy the metadata for the module from 
        the debuggee into the debugger, and open a metadata scope on it. This is wasteful if
        the module is really shared.

        A word on the possible fix: I need to change the way we keep track of metadata on the Right Side, 
        moving the ownership of the metadata from the module to the process so that I can re-use the 
        same metadata copy for shared modules. I also need to figure out if we should do this for all 
        modules or just shared modules, and identify shared modules to the Right Side somehow.

    This class implements the possible fix discussed above.
        Shared modules are identified by having the same RemoteMetadataPointer as a previously loaded module.
        This class is only constructed in CordbProcess.
        Neuter() is only called in Cordbprocess.Neuter() 
            It's also neutered by it's own destructor but we're having memory leaks and I KNOW neuter gets
            called when the process dies. It doesn't hurt to call it twice.
        AddRefCachePointer() is only called in CordbModule.Reinit()
        ReleaseRefCachePointer() is called in CordbModule.Neuter() and elsewhere.

    The implementation:
        A link list is used to cache pRemoteMetadataPtr and the local copy at pLocalMetadataPtr and the 
        refCount for that remote pointer. Checking the cache takes time O(n) but that's ok because
        there shouldn't be too many shared modules.

    Bug 97774: The cache was corrupted. A remote pointer was found in the cache that didn't match the 
        metadata associated with the remote pointer. This was because the remote pointer in the cache
        was stale and should have been invalidated. Unfortunetly the invalidation event was processed
        after the cache lookup so the invalid local pointer was returned.
 * ------------------------------------------------------------------------- */
class MetadataPointerCache
{
private:
    typedef struct _MetadataCache{
        PVOID pRemoteMetadataPtr;
        DWORD dwProcessId;
        PBYTE pLocalMetadataPtr;
        DWORD dwRefCount;
        DWORD dwMetadataSize; // Added as a consistency check
        _MetadataCache * pNext;
    } MetadataCache;

    // The cache is implemented as a link list. Switch to hash if perf is bad. Considering what happened
    // before this class was instituted (unnecessary ReadProcessMemory to get metadata) this class should 
    // actually improve performance.
    MetadataCache * m_pHead;

    DWORD dwInsert(DWORD dwProcessId, PVOID pRemoteMetadataPtr, PBYTE pLocalMetadataPtr, DWORD dwMetadataSize);
    
    // Finds the MetadataCache entry associated with the pKey which is a remote or local metadata pointer
    // depending on bRemotePtr.
    // Returns true if the pointer is cached and false otherwise.
    // If the pointer is found - a cache hit
    //      The function returns true
    //      A pointer to the next pointer preceeding the matching node is returned in the referance parameter
    //          This allows the caller to remove the matching node from the link list
    // If the pointer is not found - a cache miss
    //      The function returns false
    //      *pppNext is NULL
    BOOL bFindMetadataCache(DWORD dwProcessId, PVOID pKey, MetadataCache *** pppNext, BOOL bRemotePtr);

    void vRemoveNode(MetadataCache **ppNext);


public:
    MetadataPointerCache();

    virtual ~MetadataPointerCache();

    void Neuter();

    BOOL IsEmpty();
    
    DWORD CopyRemoteMetadata(HANDLE hProcess, PVOID pRemoteMetadataPtr, DWORD dwMetadataSize, PBYTE* ppLocalMetadataPtr);
    
    // Returns an error code on error. Call release when the pointer to the local copy is no longer needed
    // by the CordbModule. The local copy will be deallocated when no CordbModules referances it.
    DWORD AddRefCachePointer(HANDLE hProcess, DWORD dwProcessId, PVOID pRemotePtr, DWORD dwMetadataSize, PBYTE * ppLocalMetadataPtr);

    void ReleaseCachePointer(DWORD dwProcessId, PBYTE pLocalMetadataPtr, PVOID pRemotePtr, DWORD dwMetadataSize);
};

/* ------------------------------------------------------------------------- *
 * Process class
 * ------------------------------------------------------------------------- */
typedef struct _snapshotInfo
{
	ULONG				 m_nSnapshotCounter; //m_id when we last synched
} EnCSnapshotInfo;

typedef CUnorderedArray<EnCSnapshotInfo, 11> UnorderedSnapshotInfoArray;

class CordbProcess : public CordbBase, public ICorDebugProcess
{
public:
    CordbProcess(Cordb* cordb, DWORD processID, HANDLE handle);
    virtual ~CordbProcess();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugController
    //-----------------------------------------------------------

    COM_METHOD Stop(DWORD dwTimeout);
    COM_METHOD Deprecated_Continue(void);
    COM_METHOD IsRunning(BOOL *pbRunning);
    COM_METHOD HasQueuedCallbacks(ICorDebugThread *pThread, BOOL *pbQueued);
    COM_METHOD EnumerateThreads(ICorDebugThreadEnum **ppThreads);
    COM_METHOD SetAllThreadsDebugState(CorDebugThreadState state,
                                       ICorDebugThread *pExceptThisThread);
    COM_METHOD Detach();
    COM_METHOD Terminate(unsigned int exitCode);

    COM_METHOD CanCommitChanges(
        ULONG cSnapshots, 
        ICorDebugEditAndContinueSnapshot *pSnapshots[], 
        ICorDebugErrorInfoEnum **pError);

    COM_METHOD CommitChanges(
        ULONG cSnapshots, 
        ICorDebugEditAndContinueSnapshot *pSnapshots[], 
        ICorDebugErrorInfoEnum **pError);

    COM_METHOD Continue(BOOL fIsOutOfBand);
    COM_METHOD ThreadForFiberCookie(DWORD fiberCookie,
                                    ICorDebugThread **ppThread);
    COM_METHOD GetHelperThreadID(DWORD *pThreadID);

    //-----------------------------------------------------------
    // ICorDebugProcess
    //-----------------------------------------------------------
    
    COM_METHOD GetID(DWORD *pdwProcessId);
    COM_METHOD GetHandle(HANDLE *phProcessHandle);
    COM_METHOD EnableSynchronization(BOOL bEnableSynchronization);
    COM_METHOD GetThread(DWORD dwThreadId, ICorDebugThread **ppThread);
    COM_METHOD EnumerateBreakpoints(ICorDebugBreakpointEnum **ppBreakpoints);
    COM_METHOD EnumerateSteppers(ICorDebugStepperEnum **ppSteppers);
    COM_METHOD EnumerateObjects(ICorDebugObjectEnum **ppObjects);
    COM_METHOD IsTransitionStub(CORDB_ADDRESS address, BOOL *pbTransitionStub);
    COM_METHOD EnumerateModules(ICorDebugModuleEnum **ppModules);
    COM_METHOD GetModuleFromMetaDataInterface(IUnknown *pIMetaData,
                                              ICorDebugModule **ppModule);
    COM_METHOD SetStopState(DWORD threadID, CorDebugThreadState state);
    COM_METHOD IsOSSuspended(DWORD threadID, BOOL *pbSuspended);
    COM_METHOD GetThreadContext(DWORD threadID, ULONG32 contextSize,
                                BYTE context[]);
    COM_METHOD SetThreadContext(DWORD threadID, ULONG32 contextSize,
                                BYTE context[]);
    COM_METHOD ReadMemory(CORDB_ADDRESS address, DWORD size, BYTE buffer[],
                          LPDWORD read);
    COM_METHOD WriteMemory(CORDB_ADDRESS address, DWORD size, BYTE buffer[],
                          LPDWORD written);

    COM_METHOD ClearCurrentException(DWORD threadID);

    /*
     * EnableLogMessages enables/disables sending of log messages to the 
     * debugger for logging.
     */
    COM_METHOD EnableLogMessages(BOOL fOnOff);

    /*
     * ModifyLogSwitch modifies the specified switch's severity level.
     */
    COM_METHOD ModifyLogSwitch(WCHAR *pLogSwitchName, LONG lLevel);

    COM_METHOD EnumerateAppDomains(ICorDebugAppDomainEnum **ppAppDomains);
    COM_METHOD GetObject(ICorDebugValue **ppObject);

    //-----------------------------------------------------------
    // Methods not exposed via a COM interface.
    //-----------------------------------------------------------

    HRESULT ContinueInternal(BOOL fIsOutOfBand, void *pAppDomainToken);
    HRESULT StopInternal(DWORD dwTimeout, void *pAppDomainToken);

    // CordbProcess wants to do global E&C, while AppDomain wants
    // to do E&C that applies only to that one appdomain - these
    // internal methods parameterize that.
    // @todo How does one force the compiler to inline these things?
    HRESULT CordbProcess::CommitChangesInternal(ULONG cSnapshots, 
                ICorDebugEditAndContinueSnapshot *pSnapshots[], 
                ICorDebugErrorInfoEnum **pError,
                UINT_PTR pAppDomainToken);
                
    HRESULT CordbProcess::CanCommitChangesInternal(ULONG cSnapshots, 
                ICorDebugEditAndContinueSnapshot *pSnapshots[], 
                ICorDebugErrorInfoEnum **pError,
                UINT_PTR pAppDomainToken);

    HRESULT Init(bool win32Attached);
    void CloseDuplicateHandle(HANDLE *pHandle);
    void CleanupHalfBakedLeftSide(void);
    void Terminating(BOOL fDetach);
    void HandleManagedCreateThread(DWORD dwThreadId, HANDLE hThread);
    CordbUnmanagedThread *HandleUnmanagedCreateThread(DWORD dwThreadId, HANDLE hThread, void *lpThreadLocalBase);
    HRESULT GetRuntimeOffsets(void);
    void QueueUnmanagedEvent(CordbUnmanagedThread *pUThread, DEBUG_EVENT *pEvent);
    void DequeueUnmanagedEvent(CordbUnmanagedThread *pUThread);
    void QueueOOBUnmanagedEvent(CordbUnmanagedThread *pUThread, DEBUG_EVENT *pEvent);
    void DequeueOOBUnmanagedEvent(CordbUnmanagedThread *pUThread);
    HRESULT SuspendUnmanagedThreads(DWORD notThisThread);
    HRESULT ResumeUnmanagedThreads(bool unmarkHijacks);
    void DispatchUnmanagedInBandEvent(void);
    void DispatchUnmanagedOOBEvent(void);
    HRESULT StartSyncFromWin32Stop(BOOL *asyncBreakSent);
    void SweepFCHThreads(void);
    bool ExceptionIsFlare(DWORD exceptionCode, void *exceptionAddress);
    bool IsSpecialStackOverflowCase(CordbUnmanagedThread *pUThread, DEBUG_EVENT *pEvent);
    
    void DispatchRCEvent(void);
    bool IgnoreRCEvent(DebuggerIPCEvent* event, CordbAppDomain **ppAppDomain);
    void MarkAllThreadsDirty(void);

    bool CheckIfLSExited();

    void Lock(void)
    {
        LOCKCOUNTINCL("Lock in cordb.h");                               \
        EnterCriticalSection(&m_processMutex);

#ifdef _DEBUG
        if (m_processMutexRecursionCount == 0)
            _ASSERTE(m_processMutexOwner == 0);
        
        m_processMutexOwner = GetCurrentThreadId();
        m_processMutexRecursionCount++;
        
#if 0
        LOG((LF_CORDB, LL_INFO10000,
             "CP::L: 0x%x locked m_processMutex\n", m_processMutexOwner));
#endif        
#endif    
    }

    void Unlock(void)
    {
#ifdef _DEBUG
#if 0
        LOG((LF_CORDB, LL_INFO10000,
             "CP::L: 0x%x unlocking m_processMutex\n", m_processMutexOwner));
#endif
        
        _ASSERTE(m_processMutexOwner == GetCurrentThreadId());
        
        if (--m_processMutexRecursionCount == 0)
            m_processMutexOwner = 0;
#endif    

        LeaveCriticalSection(&m_processMutex);
        LOCKCOUNTDECL("Unlock in cordb.h");                             \
    
    }

#ifdef _DEBUG    
    bool ThreadHoldsProcessLock(void)
    {
        return (GetCurrentThreadId() == m_processMutexOwner);
    }
#endif
    
    void LockSendMutex(void)
    {
        LOCKCOUNTINCL("LockSendMutex in cordb.h");                              \
        EnterCriticalSection(&m_sendMutex);
    }

    void UnlockSendMutex(void)
    {
        LeaveCriticalSection(&m_sendMutex);
        LOCKCOUNTDECL("UnLockSendMutex in cordb.h");                                \

    }

    void UnrecoverableError(HRESULT errorHR,
                            unsigned int errorCode,
                            const char *errorFile,
                            unsigned int errorLine);
    HRESULT CheckForUnrecoverableError(void);
    HRESULT VerifyControlBlock(void);
    
    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    HRESULT SendIPCEvent(DebuggerIPCEvent *event, SIZE_T eventSize)
    {
        return (m_cordb->SendIPCEvent(this, event, eventSize));
    }

    void InitIPCEvent(DebuggerIPCEvent *ipce, 
                      DebuggerIPCEventType type, 
                      bool twoWay,
                      void *appDomainToken,
                      bool async = false)
    {
        _ASSERTE(appDomainToken ||
                 type == DB_IPCE_ENABLE_LOG_MESSAGES ||
                 type == DB_IPCE_MODIFY_LOGSWITCH ||
                 type == DB_IPCE_ASYNC_BREAK ||
                 type == DB_IPCE_CONTINUE ||
                 type == DB_IPCE_GET_BUFFER ||
                 type == DB_IPCE_RELEASE_BUFFER ||
                 type == DB_IPCE_ATTACH_TO_APP_DOMAIN ||
                 type == DB_IPCE_IS_TRANSITION_STUB ||
                 type == DB_IPCE_ATTACHING ||
                 type == DB_IPCE_COMMIT ||
                 type == DB_IPCE_CONTROL_C_EVENT_RESULT ||
                 type == DB_IPCE_SET_REFERENCE ||
                 type == DB_IPCE_SET_DEBUG_STATE ||
                 type == DB_IPCE_SET_ALL_DEBUG_STATE);
        ipce->type = type;
        ipce->hr = S_OK;
        ipce->processId = 0;
        ipce->appDomainToken = appDomainToken;
        ipce->threadId = 0;
        ipce->replyRequired = twoWay;
        ipce->asyncSend = async;
        ipce->next = NULL;
    }

    void ClearContinuationEvents(void)
    {
        DebuggerIPCEvent *event = (DebuggerIPCEvent *)m_DCB->m_sendBuffer;

        while (event->next != NULL)
        {
            LOG((LF_CORDB,LL_INFO1000, "About to CCE 0x%x\n",event));

            DebuggerIPCEvent *pDel = event->next;
            event->next = pDel->next;
            delete pDel;
        }
    }

    HRESULT ResolveClassByName(LPWSTR fullClassName,
                               CordbClass **ppClass);

    CordbModule *GetAnyModule(void);

    CordbUnmanagedThread *GetUnmanagedThread(DWORD dwThreadId)
    {
        return (CordbUnmanagedThread*) m_unmanagedThreads.GetBase(dwThreadId);
    }

    /*
     * This will cleanup the patch table, releasing memory,etc.
     */
    void ClearPatchTable(void);

    /*
     * This will grab the patch table from the left side & go through
     * it to gather info needed for faster access.  If address,size,buffer
     * are passed in, while going through the table we'll undo patches
     * in buffer at the same time
     */    
    HRESULT RefreshPatchTable(CORDB_ADDRESS address = NULL, SIZE_T size = NULL, BYTE buffer[] = NULL);

    // Find if a patch exists at a given address.
    HRESULT FindPatchByAddress(CORDB_ADDRESS address, bool *patchFound, bool *patchIsUnmanaged);
    
    enum AB_MODE
    {
        AB_READ,
        AB_WRITE
    };

    /*
     * Once we've called RefreshPatchTable to get the patch table,
     * this routine will iterate through the patches & either apply
     * or unapply the patches to buffer. AB_READ => Replaces patches
     * in buffer with the original opcode, AB_WRTE => replace opcode
     * with breakpoint instruction, caller is responsible for
     * updating the patchtable back to the left side.
     *
     * @todo Perf Instead of a copy, undo the changes
     * Since the 'buffer' arg is an [in] param, we're not supposed to
     * change it.  If we do, we'll allocate & copy it to bufferCopy 
     * (we'll also set *pbUpdatePatchTable to true), otherwise we
     * don't manipuldate bufferCopy (so passing a NULL in for 
     * reading is fine).
     */
    HRESULT AdjustBuffer(CORDB_ADDRESS address,
                         SIZE_T size,
                         BYTE buffer[],
                         BYTE **bufferCopy,
                         AB_MODE mode,
                         BOOL *pbUpdatePatchTable = NULL);

    /*
     * AdjustBuffer, above, doesn't actually update the local patch table
     * if asked to do a write.  It stores the changes alongside the table,
     * and this will cause the changes to be written to the table (for
     * a range of left-side addresses
     */
    void CommitBufferAdjustments(CORDB_ADDRESS start,
                                 CORDB_ADDRESS end);

    /*
     * Clear the stored changes, or they'll sit there until we
     * accidentally commit them
     */
    void ClearBufferAdjustments(void);
    HRESULT Attach (ULONG AppDomainId);
    
    // If CAD is NULL, returns true if all appdomains (ie, the entire process)
    // is synchronized.  Otherwise, returns true if the specified appdomain is
    // synch'd.
    bool GetSynchronized(void);
    void SetSynchronized(bool fSynch);

    // Routines to read and write thread context records between the processes safely.
    HRESULT SafeReadThreadContext(void *pRemoteContext, CONTEXT *pCtx);
    HRESULT SafeWriteThreadContext(void *pRemoteContext, CONTEXT *pCtx);
    
private:
    /*
     * This is a helper function to both CanCommitChanges and CommitChanges,
     * with the flag checkOnly determining who is the caller.
     */
    HRESULT SendCommitRequest(ULONG cSnapshots,
                              ICorDebugEditAndContinueSnapshot *pSnapshots[],
                              ICorDebugErrorInfoEnum **pError,
                              BOOL checkOnly);

    /*
     * When SendCommitRequest has gotten back a reply, if there are errors, the
     * errors will refer to appDomains by debugger appdomain tokens, and modules
     * by the left side DebuggerModule pointers.  We'll translate these to
     * CordbAppDomain/CordbModules here
     */
    HRESULT TranslateLSToRSTokens(EnCErrorInfo*rgErrs, USHORT cErrs);
    
    /*
     * This is used to synchronize the snapshots to the left side.
     */
    HRESULT SynchSnapshots(ULONG cSnapshots,
                           ICorDebugEditAndContinueSnapshot *pSnapshots[]);

    /*
     * This is used to send the snapshots to the left side.
     */
    HRESULT SendSnapshots(ULONG cSnapshots,
                          ICorDebugEditAndContinueSnapshot *pSnapshots[]);

    /*
     * This will request a buffer of size cbBuffer to be allocated
     * on the left side.
     *
     * If successful, returns S_OK.  If unsuccessful, returns E_OUTOFMEMORY.
     */
    HRESULT GetRemoteBuffer(ULONG cbBuffer, void **ppBuffer);

    /*
     * This will release a previously allocated left side buffer.
     */
    HRESULT ReleaseRemoteBuffer(void **ppBuffer);

    HRESULT WriteStreamIntoProcess(IStream *pIStream,
                                   void *pBuffer,
                                   BYTE *pRemoteBuffer,
                                   ULONG cbOffset);

    void ProcessFirstLogMessage (DebuggerIPCEvent *event);
    void ProcessContinuedLogMessage (DebuggerIPCEvent *event);
    
    void CloseIPCHandles(void);
    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    HRESULT WriteStreamIntoFile(IStream *pIStream,
                                LPCWSTR name);
                                
    Cordb*                m_cordb;
    HANDLE                m_handle;

    bool                  m_attached;
    bool                  m_detached;
    bool                  m_uninitializedStop;
    bool                  m_createing;
    bool                  m_exiting;
    bool                  m_firstExceptionHandled;
    bool                  m_terminated;
    bool                  m_unrecoverableError;
    bool                  m_sendAttachIPCEvent;
    bool                  m_firstManagedEvent;
    bool                  m_specialDeferment;
    bool                  m_helperThreadDead;
    bool                  m_loaderBPReceived;
    
    DWORD                 m_stopCount;
    
    bool                  m_synchronized;
    bool                  m_syncCompleteReceived;
    bool                  m_oddSync;

    CordbHashTable        m_userThreads;
    CordbHashTable        m_unmanagedThreads;
    CordbHashTable        m_appDomains;
    
    // Since a stepper can begin in one appdomain, and complete in another,
    // we put the hashtable here, rather than on specific appdomains.
    CordbHashTable        m_steppers;

    //  Used to figure out if we have to refresh any reference objects
    //  on the left side.  Gets incremented each time a continue is called.
    UINT                  m_continueCounter; 
    //  Used to figure out if we should get a new version number for
    //  (possibly) EnC'd functions...
    SIZE_T                m_EnCCounter;

    
    DebuggerIPCControlBlock *m_DCB;
    DebuggerIPCRuntimeOffsets m_runtimeOffsets;
    HANDLE                m_leftSideEventAvailable;
    HANDLE                m_leftSideEventRead;
    HANDLE                m_rightSideEventAvailable;
    HANDLE                m_rightSideEventRead;
    HANDLE                m_leftSideUnmanagedWaitEvent;
    HANDLE                m_syncThreadIsLockFree;
    HANDLE                m_SetupSyncEvent;
    HANDLE                m_debuggerAttachedEvent;
   
    IPCReaderInterface    m_IPCReader;   
    bool                  m_initialized;

    DebuggerIPCEvent*     m_queuedEventList;
    DebuggerIPCEvent*     m_lastQueuedEvent;
    bool                  m_dispatchingEvent;

    bool                  m_stopRequested;
    HANDLE                m_stopWaitEvent;
    HANDLE                m_miscWaitEvent;
    CRITICAL_SECTION      m_processMutex;
#ifdef _DEBUG
    DWORD                 m_processMutexOwner;
    DWORD                 m_processMutexRecursionCount;
#endif    
    CRITICAL_SECTION      m_sendMutex;

    CordbUnmanagedEvent  *m_unmanagedEventQueue;
    CordbUnmanagedEvent  *m_lastQueuedUnmanagedEvent;
    CordbUnmanagedEvent  *m_lastIBStoppingEvent;
    CordbUnmanagedEvent  *m_outOfBandEventQueue;
    CordbUnmanagedEvent  *m_lastQueuedOOBEvent;
    bool                  m_dispatchingUnmanagedEvent;
    bool                  m_dispatchingOOBEvent;
    bool                  m_doRealContinueAfterOOBBlock;
    bool                  m_deferContinueDueToOwnershipWait;
    DWORD                 m_helperThreadId;

    enum 
    {
        PS_WIN32_STOPPED           = 0x0001,
        PS_HIJACKS_IN_PLACE        = 0x0002,
        PS_SOME_THREADS_SUSPENDED  = 0x0004,
        PS_WIN32_ATTACHED          = 0x0008,
        PS_SYNC_RECEIVED           = 0x0010,
        PS_WIN32_OUTOFBAND_STOPPED = 0x0020,
    };
    
    unsigned int          m_state;
    unsigned int          m_awaitingOwnershipAnswer;

    BYTE*                 m_pPatchTable; // If we haven't gotten the table,
                                         // then m_pPatchTable is NULL
    BYTE                 *m_rgData; // so we know where to write the
                                    // changes patchtable back to
    USHORT               *m_rgNextPatch;
    UINT                  m_cPatch;

    DWORD                *m_rgUncommitedOpcode;
    
    // CORDB_ADDRESS's are ULONG64's
    // @todo port : these constants will have to change when
    // typeof(CORDB_ADDRESS) does
#define MAX_ADDRESS     (0xFFFFFFFFFFFFFFFF)
#define MIN_ADDRESS     (0x0)
    CORDB_ADDRESS       m_minPatchAddr; //smallest patch in table
    CORDB_ADDRESS       m_maxPatchAddr;
    
    // @todo port : if slots of CHashTable change, so should these
#define DPT_TERMINATING_INDEX (0xFFFF)
    USHORT                  m_iFirstPatch;

private:
    // These are used to manage remote buffers and minimize allocations
    void                                  *m_pbRemoteBuf;
    SIZE_T                                 m_cbRemoteBuf;

	UnorderedSnapshotInfoArray			  *m_pSnapshotInfos;
};

/* ------------------------------------------------------------------------- *
 * Module class
 * ------------------------------------------------------------------------- */

class CordbModule : public CordbBase, public ICorDebugModule
{
public:
    // The cache needs to have a lifetime as long as the eldest CordbModule.
    // Any CordbXXX object, including CordbModule may, unfortunely, exsist longer than even
    // the Cordb object and/or the CordbProcess module which contained the 
    // CordbModule. 
    // 
    // If a CordbModule lives past the time when the right side becomes aware that
    // the  module is unloaded from the debugee then CordbModule *should* be neutered.
    // If it lives past the life time of the containing CordbProcess containing it, then
    // it will absolutlye be neutered because CordbProcess neuteres its object hierarchy
    // on ExitProcess. 
    //
    // So, if the MetadataPointerCache was a member of CordbProcess, as first considered,
    // then the lifetime of the cache would be shorter than the possible liftime of
    // a CordbModule. So if someone had a referance to a neutered module and tried to 
    // access the metadata cache in the CordbProcess an AV would occure. (This occured in
    // test case dbg_g008.exe "memory\i386\clrclient.exe" during the second case iff the
    // first case is run).
    //
    // Therefore I've decided to make the cache static ensuring it's around if someone sill
    // has a referance to a neutered CordbModule. 
    //
    static MetadataPointerCache  m_metadataPointerCache;

public:
    CordbModule(CordbProcess *process, CordbAssembly *pAssembly,
                REMOTE_PTR debuggerModuleToken, void* pMetadataStart, 
                ULONG nMetadataSize, REMOTE_PTR PEBaseAddress, 
                ULONG nPESize, BOOL fDynamic, BOOL fInMemory,
                const WCHAR *szName,
                CordbAppDomain *pAppDomain,
                BOOL fInproc = FALSE);

    virtual ~CordbModule();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
            return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugModule
    //-----------------------------------------------------------

    COM_METHOD GetProcess(ICorDebugProcess **ppProcess);
    COM_METHOD GetBaseAddress(CORDB_ADDRESS *pAddress);
    COM_METHOD GetAssembly(ICorDebugAssembly **ppAssembly);
    COM_METHOD GetName(ULONG32 cchName, ULONG32 *pcchName, WCHAR szName[]);
    COM_METHOD EnableJITDebugging(BOOL bTrackJITInfo, BOOL bAllowJitOpts);
    COM_METHOD EnableClassLoadCallbacks(BOOL bClassLoadCallbacks);
    COM_METHOD GetFunctionFromToken(mdMethodDef methodDef,
                                    ICorDebugFunction **ppFunction);
    COM_METHOD GetFunctionFromRVA(CORDB_ADDRESS rva, ICorDebugFunction **ppFunction);
    COM_METHOD GetClassFromToken(mdTypeDef typeDef,
                                 ICorDebugClass **ppClass);
    COM_METHOD CreateBreakpoint(ICorDebugModuleBreakpoint **ppBreakpoint);
    /*
     * Edit & Continue support.  GetEditAndContinueSnapshot produces a
     * snapshot of the running process.  This snapshot can then be fed
     * into the compiler to guarantee the same token values are
     * returned by the meta data during compile, to find the address
     * where new static data should go, etc.  These changes are
     * comitted using ICorDebugProcess.
     */
    COM_METHOD GetEditAndContinueSnapshot(
        ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);
    COM_METHOD GetMetaDataInterface(REFIID riid, IUnknown **ppObj);
    COM_METHOD GetToken(mdModule *pToken);
    COM_METHOD IsDynamic(BOOL *pDynamic);
    COM_METHOD GetGlobalVariableValue(mdFieldDef fieldDef,
                                   ICorDebugValue **ppValue);
    COM_METHOD GetSize(ULONG32 *pcBytes);
    COM_METHOD IsInMemory(BOOL *pInMemory);

    //-----------------------------------------------------------
    // Internal members
    //-----------------------------------------------------------

    HRESULT Init(void);
    HRESULT ReInit(bool fReopen);
    HRESULT ConvertToNewMetaDataInMemory(BYTE *pMD, DWORD cb);
    CordbFunction* LookupFunction(mdMethodDef methodToken);
    HRESULT CreateFunction(mdMethodDef token,
                           SIZE_T functionRVA,
                           CordbFunction** ppFunction);
    CordbClass* LookupClass(mdTypeDef classToken);
    HRESULT CreateClass(mdTypeDef classToken,
                        CordbClass** ppClass);
    HRESULT LookupClassByToken(mdTypeDef token, CordbClass **ppClass);
    HRESULT LookupClassByName(LPWSTR fullClassName,
                              CordbClass **ppClass);
    HRESULT ResolveTypeRef(mdTypeRef token, CordbClass **ppClass);
    HRESULT SaveMetaDataCopyToStream(IStream *pIStream);

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_process);
    }

    CordbAppDomain *GetAppDomain()
    {
        return m_pAppDomain;
    }

    CordbAssembly *GetCordbAssembly (void);

    WCHAR *GetModuleName(void)
    {
        return m_szModuleName;
    }

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    CordbProcess*    m_process;
    CordbAssembly*   m_pAssembly;
    CordbAppDomain*  m_pAppDomain;
    CordbHashTable   m_classes;
    CordbHashTable   m_functions;
    REMOTE_PTR       m_debuggerModuleToken;

    IMetaDataImport *m_pIMImport;

private:
    void*            m_pMetadataStart;
    DWORD            m_dwProcessId;
    ULONG            m_nMetadataSize;
    BYTE*            m_pMetadataCopy;
    REMOTE_PTR       m_PEBaseAddress;
    ULONG            m_nPESize;
    BOOL             m_fDynamic;
    BOOL             m_fInMemory;
    WCHAR*           m_szModuleName;
    CordbClass*      m_pClass;
    BOOL             m_fInproc;
};

struct CordbSyncBlockField
{
    FREEHASHENTRY   entry;
    DebuggerIPCE_FieldData data;
};

// DebuggerIPCE_FieldData.fldMetadataToken is the key
class CordbSyncBlockFieldTable : public CHashTableAndData<CNewData>
{
  private:

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    { return ((mdFieldDef)pc1) !=
          ((CordbSyncBlockField*)pc2)->data.fldMetadataToken; }

    USHORT HASH(mdFieldDef fldToken)
    { return (USHORT) ((DWORD) fldToken ^ ((DWORD)fldToken>>16)); }

    BYTE *KEY(mdFieldDef fldToken)
    { return (BYTE *) fldToken; }

  public:

    CordbSyncBlockFieldTable() : CHashTableAndData<CNewData>(11)
    { 
        NewInit(11, sizeof(CordbSyncBlockField), 11); 
    }

    void AddFieldInfo(DebuggerIPCE_FieldData *pInfo)
    { 
        _ASSERTE(pInfo != NULL);

        CordbSyncBlockField *pEntry = (CordbSyncBlockField *)Add(HASH(pInfo->fldMetadataToken));
        pEntry->data = *pInfo; // copy everything over
    }

    DebuggerIPCE_FieldData *GetFieldInfo(mdFieldDef fldToken)
    { 
        CordbSyncBlockField *entry = (CordbSyncBlockField*)Find(HASH(fldToken), KEY(fldToken));
        return (entry!=NULL?&(entry->data):NULL);
    }

    void RemoveFieldInfo(mdFieldDef fldToken)
    {
        CordbSyncBlockField *entry = (CordbSyncBlockField*)Find(HASH(fldToken), KEY(fldToken)); 
        _ASSERTE(entry != NULL);
        Delete(HASH(fldToken), (HASHENTRY*)entry);
   }
};



/* ------------------------------------------------------------------------- *
 * Class class
 * ------------------------------------------------------------------------- */

class CordbClass : public CordbBase, public ICorDebugClass
{
public:
    CordbClass(CordbModule* m, mdTypeDef token);
    virtual ~CordbClass();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugClass
    //-----------------------------------------------------------

    COM_METHOD GetStaticFieldValue(mdFieldDef fieldDef,
                                   ICorDebugFrame *pFrame,
                                   ICorDebugValue **ppValue);
    COM_METHOD GetModule(ICorDebugModule **pModule);
    COM_METHOD GetToken(mdTypeDef *pTypeDef);

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_module->GetProcess());
    }

    CordbModule *GetModule()
    {
        return m_module;
    }

    CordbAppDomain *GetAppDomain()
    {
        return m_module->GetAppDomain();
    }

    HRESULT GetFieldSig(mdFieldDef fldToken, 
                        DebuggerIPCE_FieldData *pFieldData);

    HRESULT GetSyncBlockField(mdFieldDef fldToken, 
                              DebuggerIPCE_FieldData **ppFieldData,
                              CordbObjectValue *object);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    // If you want to force the init to happen even if we think the class
    // is up to date, set fForceInit to TRUE
    HRESULT Init(BOOL fForceInit);
    HRESULT GetFieldInfo(mdFieldDef fldToken, DebuggerIPCE_FieldData **ppFieldData);
    HRESULT GetObjectSize(ULONG32 *pObjectSize);
    HRESULT IsValueClass(bool *pIsValueClass);
    HRESULT GetThisSignature(ULONG *pcbSigBlob, PCCOR_SIGNATURE *ppvSigBlob);
    static HRESULT PostProcessUnavailableHRESULT(HRESULT hr, 
                               IMetaDataImport *pImport,
                               mdFieldDef fieldDef);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    BOOL                    m_loadEventSent;
    bool                    m_hasBeenUnloaded;

private:
    CordbModule*            m_module;

    // Since GetProcess()->m_EnCCounter is init'd to 1, we
    // should init m_EnCCounterLastSyncClass to 0, so that the class will
    // start out uninitialized.
    SIZE_T                  m_EnCCounterLastSyncClass;
    UINT                    m_continueCounterLastSync;
    bool                    m_isValueClass;
    SIZE_T                  m_objectSize;
    unsigned int            m_instanceVarCount;
    unsigned int            m_staticVarCount;
    REMOTE_PTR              m_staticVarBase;

    // DON'T KEEP POINTERS TO ELEMENTS OF m_fields AROUND!!
    // We keep pointers into fldFullSig, but that's memory that's
    // elsewhere.
    // This may be deleted if the class gets EnC'd
    DebuggerIPCE_FieldData *m_fields;
    ULONG                   m_thisSigSize;
    BYTE                    m_thisSig[8]; // must be big enough to hold a
                                          // valid object signature.
                                          
    CordbSyncBlockFieldTable m_syncBlockFieldsStatic; // if we do an EnC after this
                                // class is loaded (in the debuggee), then the
                                // new fields will be hung off the sync block,
                                // thus available on a per-instance basis.
};


typedef CUnorderedArray<CordbCode*,11> UnorderedCodeArray;
//@todo port: different SIZE_T size/
const int DJI_VERSION_INVALID = 0;
const int DJI_VERSION_MOST_RECENTLY_JITTED = 1;
const int DJI_VERSION_MOST_RECENTLY_EnCED = 2;
HRESULT UnorderedCodeArrayAdd(UnorderedCodeArray *pThis, CordbCode *pCode);
CordbCode *UnorderedCodeArrayGet(UnorderedCodeArray *pThis, SIZE_T nVersion);

/* ------------------------------------------------------------------------- *
 * Function class
 * ------------------------------------------------------------------------- */
const BOOL bNativeCode = FALSE;
const BOOL bILCode = TRUE;

class CordbFunction : public CordbBase, public ICorDebugFunction
{
public:
    //-----------------------------------------------------------
    // Create from scope and member objects.
    //-----------------------------------------------------------
    CordbFunction(CordbModule *m, 
                  mdMethodDef token, 
                  SIZE_T functionRVA);
    virtual ~CordbFunction();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugFunction
    //-----------------------------------------------------------
    // Note that all public members should call UpdateToMostRecentEnCVersion
    // to ensure that they've got the most recently EnC'd version available
    // for their use.
    COM_METHOD GetModule(ICorDebugModule **pModule);
    COM_METHOD GetClass(ICorDebugClass **ppClass);
    COM_METHOD GetToken(mdMethodDef *pMemberDef);
    COM_METHOD GetILCode(ICorDebugCode **ppCode);
    COM_METHOD GetNativeCode(ICorDebugCode **ppCode);
    COM_METHOD CreateBreakpoint(ICorDebugFunctionBreakpoint **ppBreakpoint);
    COM_METHOD GetLocalVarSigToken(mdSignature *pmdSig);
    COM_METHOD GetCurrentVersionNumber(ULONG32 *pnCurrentVersion);

    //-----------------------------------------------------------
    // Internal members
    //-----------------------------------------------------------
    HRESULT CreateCode(BOOL isIL, REMOTE_PTR startAddress, SIZE_T size,
                       CordbCode** ppCode,
                       SIZE_T nVersion, void *CodeVersionToken,
                       REMOTE_PTR ilToNativeMapAddr,
                       SIZE_T ilToNativeMapSize);
    HRESULT Populate(SIZE_T nVersion);
    HRESULT ILVariableToNative(DWORD dwIndex,
                               SIZE_T ip,
                               ICorJitInfo::NativeVarInfo **ppNativeInfo);
    HRESULT LoadNativeInfo(void);
    HRESULT GetArgumentType(DWORD dwIndex, ULONG *pcbSigBlob,
                            PCCOR_SIGNATURE *ppvSigBlob);
    HRESULT GetLocalVariableType(DWORD dwIndex, ULONG *pcbSigBlob,
                                 PCCOR_SIGNATURE *ppvSigBlob);

    void SetLocalVarToken(mdSignature  localVarSigToken);
    
    HRESULT LoadLocalVarSig(void);
    HRESULT LoadSig(void);
    HRESULT UpdateToMostRecentEnCVersion(void);
    
    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_module->GetProcess());
    }

    CordbAppDomain *GetAppDomain()
    {
        return (m_module->GetAppDomain());
    }

    CordbModule *GetModule()
    {
        return m_module;
    }

    //-----------------------------------------------------------
    // Internal routines
    //-----------------------------------------------------------
    HRESULT GetCodeByVersion( BOOL fGetIfNotPresent, BOOL fIsIL, 
        SIZE_T nVer, CordbCode **ppCode );

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    CordbModule             *m_module;
    CordbClass              *m_class;
    UnorderedCodeArray       m_rgilCode;
    UnorderedCodeArray       m_rgnativeCode;
    mdMethodDef              m_token;
    SIZE_T                   m_functionRVA;

    // Update m_nativeInfo whenever we do a new EnC.
    BOOL                     m_nativeInfoValid;
    SIZE_T                   m_nVersionLastNativeInfo; // Version of the JITted code
        // that we have m_nativeInfo for.  So we call GetCodeByVersion (most recently
        // JITTED, or most recently EnC'd as the version number), and if
        // m_continue...Synch doesn't match the process's m_EnCCounter, then Populate,
        // which updates m_nVersionMostRecentEnC & m_continueCounterLastSynch.
        // LoadNativeInfo will do this, then make sure that m_nativeInfo is current.
    unsigned int             m_argumentCount;
    unsigned int             m_nativeInfoCount;
    ICorJitInfo::NativeVarInfo *m_nativeInfo;

    PCCOR_SIGNATURE          m_methodSig;
    ULONG                    m_methodSigSize;
    ULONG                    m_argCount;
    bool                     m_isStatic;
    PCCOR_SIGNATURE          m_localsSig;
    ULONG                    m_localsSigSize;
    unsigned int             m_localVarCount;
    mdSignature              m_localVarSigToken;
    UINT                     m_encCounterLastSynch; // A copy of the 
        // process's m_EnCCounter the last time we got some info.  So if the process
        // gets EnC'd, we'll know b/c this will be less than m_EnCCounter.
    SIZE_T                   m_nVersionMostRecentEnC; //updated when we call Populate,
        // this holds the number of the most recent version of the function that
        // the runtime has.

    
    bool                     m_isNativeImpl;
};

/* ------------------------------------------------------------------------- *
 * Code class
 * ------------------------------------------------------------------------- */

class CordbCode : public CordbBase, public ICorDebugCode
{
public:
    //-----------------------------------------------------------
    // Create from scope and member objects.
    //-----------------------------------------------------------
    CordbCode(CordbFunction *m, BOOL isIL, REMOTE_PTR startAddress,
              SIZE_T size, SIZE_T nVersion, void *CodeVersionToken,
              REMOTE_PTR ilToNativeMapAddr, SIZE_T ilToNativeMapSize);
    virtual ~CordbCode();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugCode
    //-----------------------------------------------------------

    COM_METHOD IsIL(BOOL *pbIL);
    COM_METHOD GetFunction(ICorDebugFunction **ppFunction);
    COM_METHOD GetAddress(CORDB_ADDRESS *pStart);
    COM_METHOD GetSize(ULONG32 *pcBytes);
    COM_METHOD CreateBreakpoint(ULONG32 offset, 
                                ICorDebugFunctionBreakpoint **ppBreakpoint);
    COM_METHOD GetCode(ULONG32 startOffset, ULONG32 endOffset,
                       ULONG32 cBufferAlloc,
                       BYTE buffer[],
                       ULONG32 *pcBufferSize);
    COM_METHOD GetVersionNumber( ULONG32 *nVersion);
    COM_METHOD GetILToNativeMapping(ULONG32 cMap,
                                    ULONG32 *pcMap,
                                    COR_DEBUG_IL_TO_NATIVE_MAP map[]);
    COM_METHOD GetEnCRemapSequencePoints(ULONG32 cMap,
                                         ULONG32 *pcMap,
                                         ULONG32 offsets[]);
    
    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_function->GetProcess());
    }

    CordbAppDomain *GetAppDomain()
    {
        return (m_function->GetAppDomain());
    }
    //-----------------------------------------------------------
    // Internal methods
    //-----------------------------------------------------------


    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    CordbFunction         *m_function;
    BOOL                   m_isIL;
    REMOTE_PTR             m_address;
    SIZE_T                 m_size;
    SIZE_T                 m_nVersion;
    BYTE                  *m_rgbCode; //will be NULL if we can't fit it into memory
    UINT                   m_continueCounterLastSync;
    void                  *m_CodeVersionToken;

    REMOTE_PTR             m_ilToNativeMapAddr;
    SIZE_T                 m_ilToNativeMapSize;
};


/* ------------------------------------------------------------------------- *
 * Thread classes
 * ------------------------------------------------------------------------- */

class CordbThread : public CordbBase, public ICorDebugThread
{
public:
    CordbThread(CordbProcess *process, DWORD id, HANDLE handle);
    virtual ~CordbThread();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugThread
    //-----------------------------------------------------------

    COM_METHOD GetProcess(ICorDebugProcess **ppProcess);
    COM_METHOD GetID(DWORD *pdwThreadId);
    COM_METHOD GetHandle(void** phThreadHandle);
    COM_METHOD GetAppDomain(ICorDebugAppDomain **ppAppDomain);
    COM_METHOD SetDebugState(CorDebugThreadState state);
    COM_METHOD GetDebugState(CorDebugThreadState *pState);
    COM_METHOD GetUserState(CorDebugUserState *pState);
    COM_METHOD GetCurrentException(ICorDebugValue **ppExceptionObject);
    COM_METHOD ClearCurrentException();
    COM_METHOD CreateStepper(ICorDebugStepper **ppStepper);
    COM_METHOD EnumerateChains(ICorDebugChainEnum **ppChains);
    COM_METHOD GetActiveChain(ICorDebugChain **ppChain);
    COM_METHOD GetActiveFrame(ICorDebugFrame **ppFrame);
    COM_METHOD GetRegisterSet(ICorDebugRegisterSet **ppRegisters);
    COM_METHOD CreateEval(ICorDebugEval **ppEval);
    COM_METHOD GetObject(ICorDebugValue **ppObject);

    //-----------------------------------------------------------
    // Internal members
    //-----------------------------------------------------------
    // Note that RefreshStack doesn't check to see if the process
    // is dirty in-proc, so don't put this in without an #ifdef
    // RIGHT_SIDE_ONLY, unless you can tolerate _always_ doing
    // a stack trace.
    HRESULT RefreshStack(void);
    void CleanupStack(void);

    void MarkStackFramesDirty(void)
    {
        m_framesFresh = false;
        m_floatStateValid = false;
        m_exception = false;
        m_contextFresh = false;
        m_pvLeftSideContext = NULL;
    }

    HRESULT LoadFloatState(void);

    HRESULT SetIP(  bool fCanSetIPOnly,
                    REMOTE_PTR debuggerModule, 
                    mdMethodDef mdMethodDef, 
                    void *versionToken, 
                    SIZE_T offset, 
                    bool fIsIL );

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_process);
    }

    CordbAppDomain *GetAppDomain()
    {
        return (m_pAppDomain);
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // Get Context
    //
    //      TODO: Since Thread will share the memory with RegisterSets, how
    //      do we know that the RegisterSets have relenquished all pointers
    //      to the m_pContext structure?
    //
    // Returns: NULL if the thread's CONTEXT structure couldn't be obtained
    //   A pointer to the CONTEXT otherwise.
    //
    //
    //////////////////////////////////////////////////////////////////////////
    HRESULT GetContext( CONTEXT **ppContext );
    HRESULT SetContext( CONTEXT *pContext );


    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    HANDLE                m_handle;
    //NULL if we haven't allocated memory for a Right side context
    CONTEXT              *m_pContext;

    //nonNULL if the L.S. is in an exception-handler
    void                 *m_pvLeftSideContext;

    bool                  m_contextFresh;
    CordbProcess         *m_process;
    CordbAppDomain       *m_pAppDomain;
    void*                 m_debuggerThreadToken;
    void*                 m_stackBase;
    void*                 m_stackLimit;

    CorDebugThreadState   m_debugState; // Note that this is for resume
                                        // purposes, NOT the current state of
                                        // the thread.
                                        
    CorDebugUserState     m_userState;  // This is the current state of the 
                                        // thread, at the time that the 
                                        // left side synchronized
    bool                  m_framesFresh;
    CordbNativeFrame    **m_stackFrames;
    unsigned int          m_stackFrameCount;
    CordbChain          **m_stackChains;
    unsigned int          m_stackChainCount, m_stackChainAlloc;

    bool                  m_floatStateValid;
    unsigned int          m_floatStackTop;
    double                m_floatValues[DebuggerIPCE_FloatCount];

    bool                  m_exception;
    bool                  m_continuable;
    void                 *m_thrown;

    // These are used for LogMessages
    int                   m_iLogMsgLevel;
    WCHAR                *m_pstrLogSwitch;
    WCHAR                *m_pstrLogMsg;
    int                   m_iLogMsgIndex;
    int                   m_iTotalCatLength;
    int                   m_iTotalMsgLength;
    bool                  m_fLogMsgContinued;
    void                 *m_firstExceptionHandler; //left-side pointer - fs:[0] on x86
#ifndef RIGHT_SIDE_ONLY
    // SuzCook says modules are loaded sequentially, so we don't need a 
    // collection for these.
    Module               *m_pModuleSpecial;

    // Assembly loads can be nested, so we need a stack here.
    union  {
        Assembly        **m_pAssemblySpecialStack;
        Assembly         *m_pAssemblySpecial;
    };
    USHORT                m_pAssemblySpecialAlloc;
    USHORT                m_pAssemblySpecialCount;
    DWORD                 m_dwSuspendVersion;
    BOOL                  m_fThreadInprocIsActive;
#endif //RIGHT_SIDE_ONLY

    bool                  m_detached;
};

/* ------------------------------------------------------------------------- *
 * Chain class
 * ------------------------------------------------------------------------- */

class CordbChain : public CordbBase, public ICorDebugChain
{
public:
    CordbChain(CordbThread* thread, 
               bool managed, CordbFrame **start, CordbFrame **end, UINT iChainInThread);

    virtual ~CordbChain();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugChain
    //-----------------------------------------------------------

    COM_METHOD GetThread(ICorDebugThread **ppThread);
    COM_METHOD GetReason(CorDebugChainReason *pReason);
    COM_METHOD GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd);
    COM_METHOD GetContext(ICorDebugContext **ppContext);
    COM_METHOD GetCaller(ICorDebugChain **ppChain);
    COM_METHOD GetCallee(ICorDebugChain **ppChain);
    COM_METHOD GetPrevious(ICorDebugChain **ppChain);
    COM_METHOD GetNext(ICorDebugChain **ppChain);
    COM_METHOD IsManaged(BOOL *pManaged);
    COM_METHOD EnumerateFrames(ICorDebugFrameEnum **ppFrames);
    COM_METHOD GetActiveFrame(ICorDebugFrame **ppFrame);
    COM_METHOD GetRegisterSet(ICorDebugRegisterSet **ppRegisters);

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_thread->GetProcess());
    }

    CordbAppDomain *GetAppDomain()
    {
        return (m_thread->GetAppDomain());
    }

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    CordbThread             *m_thread;
    UINT                     m_iThisChain;//in m_thread->m_stackChains
    CordbChain              *m_caller, *m_callee;
    bool                     m_managed;
    CordbFrame             **m_start, **m_end;
    CorDebugChainReason      m_reason;
    CORDB_ADDRESS            m_context;
    DebuggerREGDISPLAY       m_rd;
    bool                     m_quicklyUnwound;
    bool                     m_active;
};

/* ------------------------------------------------------------------------- *
 * Chain enumerator class
 * ------------------------------------------------------------------------- */

class CordbChainEnum : public CordbBase, public ICorDebugChainEnum
{
public:
    CordbChainEnum(CordbThread *thread);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugEnum
    //-----------------------------------------------------------

    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset(void);
    COM_METHOD Clone(ICorDebugEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);

    //-----------------------------------------------------------
    // ICorDebugChainEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugChain *chains[], ULONG *pceltFetched);

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_thread->GetProcess());
    }

    CordbAppDomain *GetAppDomain()
    {
        return (m_thread->GetAppDomain());
    }

private:
    CordbThread*    m_thread;
    unsigned long   m_currentChain;
};

class CordbContext : public CordbBase
{
public:

    CordbContext() : CordbBase(0, enumCordbContext) {}
    
    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugContext
    //-----------------------------------------------------------
private:

} ;


/* ------------------------------------------------------------------------- *
 * Frame class
 * ------------------------------------------------------------------------- */

class CordbFrame : public CordbBase, public ICorDebugFrame
{
public:
    CordbFrame(CordbChain *chain, void *id,
               CordbFunction *function, CordbCode *code,
               SIZE_T ip, UINT iFrameInChain, CordbAppDomain *currentAppDomain);

    virtual ~CordbFrame();
    virtual void Neuter();    

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugFrame
    //-----------------------------------------------------------

    COM_METHOD GetChain(ICorDebugChain **ppChain);
    COM_METHOD GetCode(ICorDebugCode **ppCode);
    COM_METHOD GetFunction(ICorDebugFunction **ppFunction);
    COM_METHOD GetFunctionToken(mdMethodDef *pToken);
    COM_METHOD GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd);
    COM_METHOD GetCaller(ICorDebugFrame **ppFrame);
    COM_METHOD GetCallee(ICorDebugFrame **ppFrame);
    COM_METHOD CreateStepper(ICorDebugStepper **ppStepper);

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_chain->GetProcess());
    }

    CordbAppDomain *GetFunctionAppDomain()
    {
        return (m_chain->GetAppDomain());
    }

    CordbAppDomain *GetCurrentAppDomain()
    {
        return m_currentAppDomain;
    }

    UINT_PTR GetID(void)
    {
        return m_id;
    }

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    SIZE_T                  m_ip;
    CordbThread            *m_thread;
    CordbFunction          *m_function;
    CordbCode              *m_code;
    CordbChain             *m_chain;
    bool                    m_active;
    UINT                    m_iThisFrame;
    CordbAppDomain         *m_currentAppDomain;
};


/* ------------------------------------------------------------------------- *
 * Frame enumerator class
 * ------------------------------------------------------------------------- */

class CordbFrameEnum : public CordbBase, public ICorDebugFrameEnum
{
public:
    CordbFrameEnum(CordbChain *chain);

    virtual ~CordbFrameEnum();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugEnum
    //-----------------------------------------------------------

    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset(void);
    COM_METHOD Clone(ICorDebugEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);

    //-----------------------------------------------------------
    // ICorDebugFrameEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugFrame *frames[], ULONG *pceltFetched);

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_chain->GetProcess());
    }

    CordbAppDomain *GetAppDomain()
    {
        return (m_chain->GetAppDomain());
    }

private:
    CordbChain*     m_chain;
    CordbFrame**    m_currentFrame;
};


/* ------------------------------------------------------------------------- *
 *  IL Frame class
 *
 *  NOTE: We don't actually use this class anymore - we assume we'll have
 *  a CordbNativeFrame, and if it has IL info, then it'll have a 
 *  CordbJITILFrame object hanging off of it.
 *
 *  We keep this code around on the off chance it'll be useful later.
 *
 * ------------------------------------------------------------------------- */

class CordbILFrame : public CordbFrame, public ICorDebugILFrame
{
public:
    CordbILFrame(CordbChain *chain, void *id,
                 CordbFunction *function, CordbCode* code,
                 SIZE_T ip, void* sp, const void **localMap,
                 void* argMap, void* frameToken, bool active,
                 CordbAppDomain *currentAppDomain);
    virtual ~CordbILFrame();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugFrame
    //-----------------------------------------------------------

    COM_METHOD GetChain(ICorDebugChain **ppChain)
    {
        return (CordbFrame::GetChain(ppChain));
    }
    COM_METHOD GetCode(ICorDebugCode **ppCode)
    {
        return (CordbFrame::GetCode(ppCode));
    }
    COM_METHOD GetFunction(ICorDebugFunction **ppFunction)
    {
        return (CordbFrame::GetFunction(ppFunction));
    }
    COM_METHOD GetFunctionToken(mdMethodDef *pToken)
    {
        return (CordbFrame::GetFunctionToken(pToken));
    }
    COM_METHOD GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd)
    {
        return (CordbFrame::GetStackRange(pStart, pEnd));
    }
    COM_METHOD GetCaller(ICorDebugFrame **ppFrame)
    {
        return (CordbFrame::GetCaller(ppFrame));
    }
    COM_METHOD GetCallee(ICorDebugFrame **ppFrame)
    {
        return (CordbFrame::GetCallee(ppFrame));
    }
    COM_METHOD CreateStepper(ICorDebugStepper **ppStepper)
    {
        return (CordbFrame::CreateStepper(ppStepper));
    }

    //-----------------------------------------------------------
    // ICorDebugILFrame
    //-----------------------------------------------------------

    COM_METHOD GetIP(ULONG32* pnOffset, CorDebugMappingResult *pMappingResult);
    COM_METHOD SetIP(ULONG32 nOffset);
    COM_METHOD EnumerateLocalVariables(ICorDebugValueEnum **ppValueEnum);
    COM_METHOD GetLocalVariable(DWORD dwIndex, ICorDebugValue **ppValue);
    COM_METHOD EnumerateArguments(ICorDebugValueEnum **ppValueEnum);
    COM_METHOD GetArgument(DWORD dwIndex, ICorDebugValue **ppValue);
    COM_METHOD GetStackDepth(ULONG32 *pDepth);
    COM_METHOD GetStackValue(DWORD dwIndex, ICorDebugValue **ppValue);
    COM_METHOD CanSetIP(ULONG32 nOffset);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT GetArgumentWithType(ULONG cbSigBlob,
                                PCCOR_SIGNATURE pvSigBlob,
                                DWORD dwIndex, 
                                ICorDebugValue **ppValue);
    HRESULT GetLocalVariableWithType(ULONG cbSigBlob,
                                     PCCOR_SIGNATURE pvSigBlob,
                                     DWORD dwIndex, 
                                     ICorDebugValue **ppValue);
    
    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    void             *m_sp;
    REMOTE_PTR        m_localMap;
    REMOTE_PTR        m_argMap;
    void             *m_frameToken;
};

class CordbValueEnum : public CordbBase, public ICorDebugValueEnum
{
public:
    enum ValueEnumMode {
        LOCAL_VARS,
        ARGS,
    } ;

    enum ValueEnumFrameSource {
        JIT_IL_FRAME,
        IL_FRAME,
    } ;
    
    CordbValueEnum(CordbFrame *frame, ValueEnumMode mode,
                   ValueEnumFrameSource frameSrc);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugEnum
    //-----------------------------------------------------------

    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset(void);
    COM_METHOD Clone(ICorDebugEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);

    //-----------------------------------------------------------
    // ICorDebugValueEnum
    //-----------------------------------------------------------

    COM_METHOD Next(ULONG celt, ICorDebugValue *values[], ULONG *pceltFetched);

private:
    CordbFrame*     m_frame;
    ValueEnumFrameSource m_frameSrc; //used to keep track of what
    //m_frame actually is - CordbILFrame or CordbJITILFrame
    ValueEnumMode   m_mode;
    UINT            m_iCurrent;
    UINT            m_iMax;
};



/* ------------------------------------------------------------------------- *
 * Native Frame class
 * ------------------------------------------------------------------------- */

class CordbNativeFrame : public CordbFrame, public ICorDebugNativeFrame
{
public:
    CordbNativeFrame(CordbChain *chain, void *id,
                     CordbFunction *function, CordbCode* code,
                     SIZE_T ip, DebuggerREGDISPLAY* rd, 
                     bool quicklyUnwound,
                     UINT iFrameInChain,
                     CordbAppDomain *currentAppDomain);
    virtual ~CordbNativeFrame();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugFrame
    //-----------------------------------------------------------

    COM_METHOD GetChain(ICorDebugChain **ppChain)
    {
        return (CordbFrame::GetChain(ppChain));
    }
    COM_METHOD GetCode(ICorDebugCode **ppCode)
    {
        return (CordbFrame::GetCode(ppCode));
    }
    COM_METHOD GetFunction(ICorDebugFunction **ppFunction)
    {
        return (CordbFrame::GetFunction(ppFunction));
    }
    COM_METHOD GetFunctionToken(mdMethodDef *pToken)
    {
        return (CordbFrame::GetFunctionToken(pToken));
    }
    COM_METHOD GetCaller(ICorDebugFrame **ppFrame)
    {
        return (CordbFrame::GetCaller(ppFrame));
    }
    COM_METHOD GetCallee(ICorDebugFrame **ppFrame)
    {
        return (CordbFrame::GetCallee(ppFrame));
    }
    COM_METHOD CreateStepper(ICorDebugStepper **ppStepper)
    {
        return (CordbFrame::CreateStepper(ppStepper));
    }

    COM_METHOD GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd);

    //-----------------------------------------------------------
    // ICorDebugNativeFrame
    //-----------------------------------------------------------

    COM_METHOD GetIP(ULONG32* pnOffset);
    COM_METHOD SetIP(ULONG32 nOffset);
    COM_METHOD GetRegisterSet(ICorDebugRegisterSet **ppRegisters);
    COM_METHOD GetLocalRegisterValue(CorDebugRegister reg, 
                                     ULONG cbSigBlob,
                                     PCCOR_SIGNATURE pvSigBlob,
                                     ICorDebugValue **ppValue);
    COM_METHOD GetLocalDoubleRegisterValue(CorDebugRegister highWordReg, 
                                           CorDebugRegister lowWordReg, 
                                           ULONG cbSigBlob,
                                           PCCOR_SIGNATURE pvSigBlob,
                                           ICorDebugValue **ppValue);
    COM_METHOD GetLocalMemoryValue(CORDB_ADDRESS address,
                                   ULONG cbSigBlob,
                                   PCCOR_SIGNATURE pvSigBlob,
                                   ICorDebugValue **ppValue);
    COM_METHOD GetLocalRegisterMemoryValue(CorDebugRegister highWordReg,
                                           CORDB_ADDRESS lowWordAddress, 
                                           ULONG cbSigBlob,
                                           PCCOR_SIGNATURE pvSigBlob,
                                           ICorDebugValue **ppValue);
    COM_METHOD GetLocalMemoryRegisterValue(CORDB_ADDRESS highWordAddress,
                                           CorDebugRegister lowWordRegister,
                                           ULONG cbSigBlob,
                                           PCCOR_SIGNATURE pvSigBlob,
                                           ICorDebugValue **ppValue);
    COM_METHOD CanSetIP(ULONG32 nOffset);

    //-----------------------------------------------------------
    // Non-COM members
    //-----------------------------------------------------------

    DWORD *GetAddressOfRegister(CorDebugRegister regNum);
    void  *GetLeftSideAddressOfRegister(CorDebugRegister regNum);
    HRESULT CordbNativeFrame::GetLocalFloatingPointValue(
                                                     DWORD index,
                                                     ULONG cbSigBlob,
                                                     PCCOR_SIGNATURE pvSigBlob,
                                                     ICorDebugValue **ppValue);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    DebuggerREGDISPLAY m_rd;
    bool               m_quicklyUnwound;
    CordbJITILFrame*   m_JITILFrame;
};


/* ------------------------------------------------------------------------- *
 * CordbRegisterSet class
 *
 * This can be obtained via GetRegisterSet from 
 *      CordbChain
 *      CordbNativeFrame
 *      CordbThread
 *
 * ------------------------------------------------------------------------- */

class CordbRegisterSet : public CordbBase, public ICorDebugRegisterSet
{
public:
    CordbRegisterSet( DebuggerREGDISPLAY *rd, CordbThread *thread, 
                      bool active, bool quickUnwind ) : CordbBase(0, enumCordbRegisterSet)
    {
        _ASSERTE( rd != NULL );
        _ASSERTE( thread != NULL );
        m_rd = rd;
        m_thread = thread;
        m_active = active;
        m_quickUnwind = quickUnwind;
    }

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }

    COM_METHOD QueryInterface(REFIID riid, void **ppInterface)
    {
        if (riid == IID_ICorDebugRegisterSet)
            *ppInterface = (ICorDebugRegisterSet*)this;
        else if (riid == IID_IUnknown)
            *ppInterface = (IUnknown*)(ICorDebugRegisterSet*)this;
        else
        {
            *ppInterface = NULL;
            return E_NOINTERFACE;
        }

        AddRef();
        return S_OK;
    }


    //-----------------------------------------------------------
    // ICorDebugRegisterSet
    // More extensive explanation are in Src/inc/CorDebug.idl
    //-----------------------------------------------------------
    COM_METHOD GetRegistersAvailable(ULONG64 *pAvailable);

    COM_METHOD GetRegisters(ULONG64 mask, 
                            ULONG32 regCount, 
                            CORDB_REGISTER regBuffer[]);
    COM_METHOD SetRegisters( ULONG64 mask, 
                             ULONG32 regCount, 
                             CORDB_REGISTER regBuffer[])
        {
        #ifndef RIGHT_SIDE_ONLY
            return CORDBG_E_INPROC_NOT_IMPL; 
        #else 
            VALIDATE_POINTER_TO_OBJECT_ARRAY(regBuffer, CORDB_REGISTER, 
                                           regCount, true, true);
    
            return E_NOTIMPL; 
        #endif //RIGHT_SIDE_ONLY    
        }

    COM_METHOD GetThreadContext(ULONG32 contextSize, BYTE context[]);
    COM_METHOD SetThreadContext(ULONG32 contextSize, BYTE context[]);

protected:
    DebuggerREGDISPLAY  *m_rd;
    CordbThread         *m_thread;
    bool                m_active;
    bool                m_quickUnwind;
} ;




/* ------------------------------------------------------------------------- *
 * JIT-IL Frame class
 * ------------------------------------------------------------------------- */

class CordbJITILFrame : public CordbBase, public ICorDebugILFrame
{
public:
    CordbJITILFrame(CordbNativeFrame *nativeFrame,
                    CordbCode* code,
                    UINT_PTR ip,
                    CorDebugMappingResult mapping,
                    bool fVarArgFnx,
                    void *rpSig,
                    ULONG cbSig,
                    void *rpFirstArg);
    virtual ~CordbJITILFrame();
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugFrame
    //-----------------------------------------------------------

    COM_METHOD GetChain(ICorDebugChain **ppChain);
    COM_METHOD GetCode(ICorDebugCode **ppCode);
    COM_METHOD GetFunction(ICorDebugFunction **ppFunction);
    COM_METHOD GetFunctionToken(mdMethodDef *pToken);
    COM_METHOD GetStackRange(CORDB_ADDRESS *pStart, CORDB_ADDRESS *pEnd);
    COM_METHOD CreateStepper(ICorDebugStepper **ppStepper);
    COM_METHOD GetCaller(ICorDebugFrame **ppFrame);
    COM_METHOD GetCallee(ICorDebugFrame **ppFrame);

    //-----------------------------------------------------------
    // ICorDebugILFrame
    //-----------------------------------------------------------

    COM_METHOD GetIP(ULONG32* pnOffset, CorDebugMappingResult *pMappingResult);
    COM_METHOD SetIP(ULONG32 nOffset);
    COM_METHOD EnumerateLocalVariables(ICorDebugValueEnum **ppValueEnum);
    COM_METHOD GetLocalVariable(DWORD dwIndex, ICorDebugValue **ppValue);
    COM_METHOD EnumerateArguments(ICorDebugValueEnum **ppValueEnum);
    COM_METHOD GetArgument(DWORD dwIndex, ICorDebugValue **ppValue);
    COM_METHOD GetStackDepth(ULONG32 *pDepth);
    COM_METHOD GetStackValue(DWORD dwIndex, ICorDebugValue **ppValue);
    COM_METHOD CanSetIP(ULONG32 nOffset);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT GetNativeVariable(ULONG cbSigBlob, PCCOR_SIGNATURE pvSigBlob,
                              ICorJitInfo::NativeVarInfo *pJITInfo,
                              ICorDebugValue **ppValue);

    CordbProcess *GetProcess()
    {
        return (m_nativeFrame->GetProcess());
    }

    CordbAppDomain *GetFunctionAppDomain()
    {
        return (m_nativeFrame->GetFunctionAppDomain());
    }

    CordbAppDomain *GetCurrentAppDomain()
    {
        return (m_nativeFrame->GetCurrentAppDomain());
    }

    HRESULT GetArgumentWithType(ULONG cbSigBlob, PCCOR_SIGNATURE pvSigBlob,
                                DWORD dwIndex, ICorDebugValue **ppValue);
    HRESULT GetLocalVariableWithType(ULONG cbSigBlob,
                                     PCCOR_SIGNATURE pvSigBlob, DWORD dwIndex, 
                                     ICorDebugValue **ppValue);

    // ILVariableToNative serves to let the frame intercept accesses
    // to var args variables.
    HRESULT ILVariableToNative(DWORD dwIndex,
                               SIZE_T ip,
                               ICorJitInfo::NativeVarInfo **ppNativeInfo);

    // Fills in our array of var args variables
    HRESULT FabricateNativeInfo(DWORD dwIndex,
                                ICorJitInfo::NativeVarInfo **ppNativeInfo);

    HRESULT GetArgumentType(DWORD dwIndex,
                            ULONG *pcbSigBlob,
                            PCCOR_SIGNATURE *ppvSigBlob);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    CordbNativeFrame* m_nativeFrame;
    CordbCode*        m_ilCode;
    UINT_PTR          m_ip;
    CorDebugMappingResult m_mapping;

    // var args stuff - if m_fVarArgFnx == true, it's a var args
    // fnx.  if m_sig != NULL, then we've got the data we need
    bool              m_fVarArgFnx;
    ULONG             m_argCount;
    PCCOR_SIGNATURE   m_sig;
    ULONG             m_cbSig;
    void *            m_rpFirstArg;
    ICorJitInfo::NativeVarInfo * m_rgNVI;
};

/* ------------------------------------------------------------------------- *
 * Breakpoint class
 * ------------------------------------------------------------------------- */

enum CordbBreakpointType
{
    CBT_FUNCTION,
    CBT_MODULE,
    CBT_VALUE
};

class CordbBreakpoint : public CordbBase, public ICorDebugBreakpoint
{
public:
    CordbBreakpoint(CordbBreakpointType bpType);
    virtual void Neuter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugBreakpoint
    //-----------------------------------------------------------

    COM_METHOD BaseIsActive(BOOL *pbActive);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------
    CordbBreakpointType GetBPType(void)
    {
        return m_type;
    }

    virtual void Disconnect() {}

    CordbAppDomain *GetAppDomain()
    {
        return m_pAppDomain;
    }
    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    bool                m_active;
    CordbAppDomain *m_pAppDomain;
    CordbBreakpointType m_type;
};

/* ------------------------------------------------------------------------- *
 * Function Breakpoint class
 * ------------------------------------------------------------------------- */

class CordbFunctionBreakpoint : public CordbBreakpoint,
                                public ICorDebugFunctionBreakpoint
{
public:
    CordbFunctionBreakpoint(CordbCode *code, SIZE_T offset);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugBreakpoint
    //-----------------------------------------------------------

    COM_METHOD GetFunction(ICorDebugFunction **ppFunction);
    COM_METHOD GetOffset(ULONG32 *pnOffset);
    COM_METHOD Activate(BOOL bActive);
    COM_METHOD IsActive(BOOL *pbActive)
    {
        VALIDATE_POINTER_TO_OBJECT(pbActive, BOOL *);
    
        return BaseIsActive(pbActive);
    }

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    void Disconnect();

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_code->GetProcess());
    }

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    CordbCode      *m_code;
    SIZE_T          m_offset;
};

/* ------------------------------------------------------------------------- *
 * Module Breakpoint class
 * ------------------------------------------------------------------------- */

class CordbModuleBreakpoint : public CordbBreakpoint,
                              public ICorDebugModuleBreakpoint
{
public:
    CordbModuleBreakpoint(CordbModule *pModule);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugModuleBreakpoint
    //-----------------------------------------------------------

    COM_METHOD GetModule(ICorDebugModule **ppModule);
    COM_METHOD Activate(BOOL bActive);
    COM_METHOD IsActive(BOOL *pbActive)
    {
        VALIDATE_POINTER_TO_OBJECT(pbActive, BOOL *);
    
        return BaseIsActive(pbActive);
    }

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    void Disconnect();

public:
    CordbModule       *m_module;
};

/* ------------------------------------------------------------------------- *
 * Value Breakpoint class
 * ------------------------------------------------------------------------- */

class CordbValueBreakpoint : public CordbBreakpoint,
                             public ICorDebugValueBreakpoint
{
public:
    CordbValueBreakpoint(CordbValue *pValue);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugModuleBreakpoint
    //-----------------------------------------------------------

    COM_METHOD GetValue(ICorDebugValue **ppValue);
    COM_METHOD Activate(BOOL bActive);
    COM_METHOD IsActive(BOOL *pbActive)
    {
        VALIDATE_POINTER_TO_OBJECT(pbActive, BOOL *);
    
        return BaseIsActive(pbActive);
    }

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    void Disconnect();

public:
    CordbValue       *m_value;
};

/* ------------------------------------------------------------------------- *
 * Stepper class
 * ------------------------------------------------------------------------- */

class CordbStepper : public CordbBase, public ICorDebugStepper
{
public:
    CordbStepper(CordbThread *thread, CordbFrame *frame = NULL);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugStepper
    //-----------------------------------------------------------

    COM_METHOD IsActive(BOOL *pbActive);
    COM_METHOD Deactivate();
    COM_METHOD SetInterceptMask(CorDebugIntercept mask);
    COM_METHOD SetUnmappedStopMask(CorDebugUnmappedStop mask);
    COM_METHOD Step(BOOL bStepIn);
    COM_METHOD StepRange(BOOL bStepIn, 
                         COR_DEBUG_STEP_RANGE ranges[], 
                         ULONG32 cRangeCount);
    COM_METHOD StepOut();
    COM_METHOD SetRangeIL(BOOL bIL);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    void Disconnect();

    //-----------------------------------------------------------
    // Convenience routines
    //-----------------------------------------------------------

    CordbProcess *GetProcess()
    {
        return (m_thread->GetProcess());
    }

    CordbAppDomain *GetAppDomain()
    {
        return (m_thread->GetAppDomain());
    }

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

    CordbThread     *m_thread;
    CordbFrame      *m_frame;
    REMOTE_PTR      m_stepperToken;
    bool            m_active;
    bool            m_rangeIL;
    CorDebugUnmappedStop m_rgfMappingStop;
    CorDebugIntercept m_rgfInterceptStop;
};

/* ------------------------------------------------------------------------- *
 * Value class
 * ------------------------------------------------------------------------- */

class CordbValue : public CordbBase
{
public:
    //-----------------------------------------------------------
    // Constructor/destructor
    //-----------------------------------------------------------
    CordbValue(CordbAppDomain *appdomain,
               CordbModule* module,
               ULONG cbSigBlob,
               PCCOR_SIGNATURE pvSigBlob,
               REMOTE_PTR remoteAddress,
               void *localAddress,
               RemoteAddress *remoteRegAddr,
               bool isLiteral)
    : CordbBase((ULONG)remoteAddress, enumCordbValue),
      m_cbSigBlob(cbSigBlob),
      m_pvSigBlob(pvSigBlob),
      m_appdomain(appdomain),
      m_module(module),
      m_size(0),
      m_localAddress(localAddress),
      m_sigCopied(false),
      m_isLiteral(isLiteral),
      m_pParent(NULL)
    {
        if (remoteRegAddr != NULL)
        {
            _ASSERTE(remoteAddress == NULL);
            m_remoteRegAddr = *remoteRegAddr;
        }
        else
            m_remoteRegAddr.kind = RAK_NONE;

        if (m_module)
        {
            m_process = m_module->GetProcess();
            m_process->AddRef();
        }
        else
            m_process = NULL;
    }

    virtual ~CordbValue()
    {
        if (m_process != NULL)
            m_process->Release();
        
        if (m_pvSigBlob != NULL)
            delete [] (BYTE*)m_pvSigBlob;

        if (m_pParent != NULL)
            m_pParent->Release();
    }
    
    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }

    //-----------------------------------------------------------
    // ICorDebugValue
    //-----------------------------------------------------------

    COM_METHOD GetType(CorElementType *pType)
    {
        VALIDATE_POINTER_TO_OBJECT(pType, CorElementType *);
    
        //Get rid of funky modifiers
        ULONG cb = _skipFunkyModifiersInSignature(m_pvSigBlob);
        
        *pType = (CorElementType) *(&m_pvSigBlob[cb]);
        return (S_OK);
    }

    COM_METHOD GetSize(ULONG32 *pSize)
    {
        VALIDATE_POINTER_TO_OBJECT(pSize, SIZE_T *);
    
        *pSize = m_size;
        return (S_OK);
    }

    COM_METHOD GetAddress(CORDB_ADDRESS *pAddress)
    {
        VALIDATE_POINTER_TO_OBJECT(pAddress, CORDB_ADDRESS *);
    
        *pAddress = m_id;
        return (S_OK);
    }

    COM_METHOD CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint);

    //-----------------------------------------------------------
    // Methods not exported through COM
    //-----------------------------------------------------------

    static HRESULT CreateValueByType(CordbAppDomain *appdomain,
                                     CordbModule *module,
                                     ULONG cbSigBlob,
                                     PCCOR_SIGNATURE pvSigBlob,
                                     CordbClass *optionalClass,
                                     REMOTE_PTR remoteAddress,
                                     void *localAddress,
                                     bool objectRefsInHandles,
                                     RemoteAddress *remoteRegAddr,
                                     IUnknown *pParent,
                                     ICorDebugValue** ppValue);

    HRESULT Init(void);

    HRESULT SetEnregisteredValue(void *pFrom);
    HRESULT SetContextRegister(CONTEXT *c,
                               CorDebugRegister reg,
                               DWORD newVal,
                               CordbNativeFrame *frame);

    virtual void GetRegisterInfo(DebuggerIPCE_FuncEvalArgData *pFEAD);

    virtual CordbAppDomain *GetAppDomain(void)
    {
        return m_appdomain;
    }

    void SetParent(IUnknown *pParent)
    {
        if (pParent != NULL)
        {
            m_pParent = pParent;
            pParent->AddRef();
        }
    }
    
    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    CordbProcess    *m_process;
    CordbAppDomain  *m_appdomain;
    CordbModule     *m_module;
    ULONG            m_cbSigBlob;
    PCCOR_SIGNATURE  m_pvSigBlob;
    bool             m_sigCopied;   // Since the signature shouldn't change,
                                    //  we only want to copy it once.
    ULONG32          m_size;
    void            *m_localAddress;
    RemoteAddress    m_remoteRegAddr; // register info on the Left Side.
    bool             m_isLiteral;     // true if the value is a RS fabrication.
    IUnknown        *m_pParent;
};


/* ------------------------------------------------------------------------- *
 * Generic Value class
 * ------------------------------------------------------------------------- */

class CordbGenericValue : public CordbValue, public ICorDebugGenericValue
{
public:
    CordbGenericValue(CordbAppDomain *appdomain,
                      CordbModule *module,
                      ULONG cbSigBlob,
                      PCCOR_SIGNATURE pvSigBlob,
                      REMOTE_PTR remoteAddress,
                      void *localAddress,
                      RemoteAddress *remoteRegAddr);

    CordbGenericValue(CordbAppDomain *appdomain,
                      CordbModule *module,
                      ULONG cbSigBlob,
                      PCCOR_SIGNATURE pvSigBlob,
                      DWORD highWord,
                      DWORD lowWord,
                      RemoteAddress *remoteRegAddr);
    CordbGenericValue(ULONG cbSigBlob,
                      PCCOR_SIGNATURE pvSigBlob);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugValue
    //-----------------------------------------------------------

    COM_METHOD GetType(CorElementType *pType)
    {
        return (CordbValue::GetType(pType));
    }
    COM_METHOD GetSize(ULONG32 *pSize)
    {
        return (CordbValue::GetSize(pSize));
    }
    COM_METHOD GetAddress(CORDB_ADDRESS *pAddress)
    {
        return (CordbValue::GetAddress(pAddress));
    }
    COM_METHOD CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint)
    {
        return (CordbValue::CreateBreakpoint(ppBreakpoint));
    }

    //-----------------------------------------------------------
    // ICorDebugGenericValue
    //-----------------------------------------------------------

    COM_METHOD GetValue(void *pTo);
    COM_METHOD SetValue(void *pFrom); 

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT Init(void);
    bool CopyLiteralData(BYTE *pBuffer);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

private:
    BYTE m_copyOfData[8]; // hold copies of up to 64-bit values.
};


/* ------------------------------------------------------------------------- *
 * Reference Value class
 * ------------------------------------------------------------------------- */

const BOOL               bCrvWeak = FALSE;
const BOOL               bCrvStrong = TRUE;

class CordbReferenceValue : public CordbValue, public ICorDebugReferenceValue
{
public:
    CordbReferenceValue(CordbAppDomain *appdomain,
                        CordbModule *module,
                        ULONG cbSigBlob,
                        PCCOR_SIGNATURE pvSigBlob,
                        REMOTE_PTR remoteAddress,
                        void *localAddress,
                        bool objectRefsInHandle,
                        RemoteAddress *remoteRegAddr);
    CordbReferenceValue(ULONG cbSigBlob,
                        PCCOR_SIGNATURE pvSigBlob);
    virtual ~CordbReferenceValue();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugValue
    //-----------------------------------------------------------

    COM_METHOD GetType(CorElementType *pType)
    {
        return (CordbValue::GetType(pType));
    }
    COM_METHOD GetSize(ULONG32 *pSize)
    {
        return (CordbValue::GetSize(pSize));
    }
    COM_METHOD GetAddress(CORDB_ADDRESS *pAddress)
    {
        return (CordbValue::GetAddress(pAddress));
    }
    COM_METHOD CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint)
    {
        return (CordbValue::CreateBreakpoint(ppBreakpoint));
    }

    //-----------------------------------------------------------
    // ICorDebugReferenceValue
    //-----------------------------------------------------------

    COM_METHOD IsNull(BOOL *pbNULL);
    COM_METHOD GetValue(CORDB_ADDRESS *pTo);
    COM_METHOD SetValue(CORDB_ADDRESS pFrom); 
    COM_METHOD Dereference(ICorDebugValue **ppValue);
    COM_METHOD DereferenceStrong(ICorDebugValue **ppValue);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT Init(bool fStrong);
    HRESULT DereferenceInternal( ICorDebugValue **ppValue, bool fStrong);
    bool CopyLiteralData(BYTE *pBuffer);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

public:
    bool                     m_objectRefInHandle;
    bool                     m_specialReference;
    DebuggerIPCE_ObjectData  m_info;
    CordbClass              *m_class;
    CordbObjectValue        *m_objectStrong;
    CordbObjectValue        *m_objectWeak;
    UINT                    m_continueCounterLastSync;
};

/* ------------------------------------------------------------------------- *
 * Object Value class
 *
 * Because of the oddness of string objects in the Runtime we have one
 * object that implements both ObjectValue and StringValue. There is a
 * definite string type, but its really just an object of the string
 * class. Furthermore, you can have a variable whose type is listed as
 * "class", but its an instance of the string class and therefore needs
 * to be treated like a string. Its my hope that they'll clean this up in
 * the Runtime one day and I can have a seperate StringValue class.
 *
 * -- Fri Aug 28 10:44:41 1998
 * ------------------------------------------------------------------------- */

class CordbObjectValue : public CordbValue, public ICorDebugObjectValue,
                         public ICorDebugGenericValue,
                         public ICorDebugStringValue
{
    friend HRESULT CordbClass::GetSyncBlockField(mdFieldDef fldToken, 
                                      DebuggerIPCE_FieldData **ppFieldData,
                                      CordbObjectValue *object);

public:
    CordbObjectValue(CordbAppDomain *appdomain,
                     CordbModule *module,
                     ULONG cbSigBlob,
                     PCCOR_SIGNATURE pvSigBlob,
                     DebuggerIPCE_ObjectData *pObjectData,
                     CordbClass *objectClass,
                     bool fStrong,
                     void *token);
    virtual ~CordbObjectValue();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugValue
    //-----------------------------------------------------------

    COM_METHOD GetType(CorElementType *pType);
    COM_METHOD GetSize(ULONG32 *pSize);
    COM_METHOD GetAddress(CORDB_ADDRESS *pAddress);
    COM_METHOD CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint);

    //-----------------------------------------------------------
    // ICorDebugHeapValue
    //-----------------------------------------------------------

    COM_METHOD IsValid(BOOL *pbValid);
    COM_METHOD CreateRelocBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint);
    
    //-----------------------------------------------------------
    // ICorDebugObjectValue
    //-----------------------------------------------------------

    COM_METHOD GetClass(ICorDebugClass **ppClass);
    COM_METHOD GetFieldValue(ICorDebugClass *pClass,
                             mdFieldDef fieldDef,
                             ICorDebugValue **ppValue);
    COM_METHOD GetVirtualMethod(mdMemberRef memberRef,
                                ICorDebugFunction **ppFunction);
    COM_METHOD GetContext(ICorDebugContext **ppContext);
    COM_METHOD IsValueClass(BOOL *pbIsValueClass);
    COM_METHOD GetManagedCopy(IUnknown **ppObject);
    COM_METHOD SetFromManagedCopy(IUnknown *pObject);

    //-----------------------------------------------------------
    // ICorDebugGenericValue
    //-----------------------------------------------------------

    COM_METHOD GetValue(void *pTo);
    COM_METHOD SetValue(void *pFrom); 

    //-----------------------------------------------------------
    // ICorDebugStringValue
    //-----------------------------------------------------------
    COM_METHOD GetLength(ULONG32 *pcchString);
    COM_METHOD GetString(ULONG32 cchString,
                         ULONG32 *ppcchStrin,
                         WCHAR szString[]);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT Init(void);

    // SyncObject will return true if the object is still valid,
    // and will return false if it isn't.
    bool SyncObject(void);

    void DiscardObject(void *token, bool fStrong);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

protected:
    DebuggerIPCE_ObjectData  m_info;
    BYTE                    *m_objectCopy;
    BYTE                    *m_objectLocalVars; // var base in _this_ process
                                                // points _into_ m_objectCopy
    BYTE                    *m_stringBuffer;    // points _into_ m_objectCopy
    CordbClass              *m_class;
    UINT                     m_mostRecentlySynched; //Used in IsValid to figure
                                // out if the process has been continued since
                                // the last time the object has been updated.
    bool                     m_fIsValid; // Sticky-bit: once it gets invalidated
                                // it can never be 're-validated'.
    bool                     m_fStrong; // True if we DereferenceStrong()'d a ref
                                // to get this object, false if we 
                                // Dereference()'d to get this object.
    void                    *m_objectToken;
    
    CordbSyncBlockFieldTable m_syncBlockFieldsInstance; 
};


/* ------------------------------------------------------------------------- *
 * Value Class Object Value class
 * ------------------------------------------------------------------------- */

class CordbVCObjectValue : public CordbValue, public ICorDebugObjectValue,
                           public ICorDebugGenericValue
{
public:
    CordbVCObjectValue(CordbAppDomain *appdomain,
                       CordbModule *module,
                       ULONG cbSigBlob,
                       PCCOR_SIGNATURE pvSigBlob,
                       REMOTE_PTR remoteAddress,
                       void *localAddress,
                       CordbClass *objectClass,
                       RemoteAddress *remoteRegAddr);
    virtual ~CordbVCObjectValue();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugValue
    //-----------------------------------------------------------

    COM_METHOD GetType(CorElementType *pType)
    {
        return (CordbValue::GetType(pType));
    }
    COM_METHOD GetSize(ULONG32 *pSize)
    {
        return (CordbValue::GetSize(pSize));
    }
    COM_METHOD GetAddress(CORDB_ADDRESS *pAddress)
    {
        return (CordbValue::GetAddress(pAddress));
    }
    COM_METHOD CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint)
    {
        return (CordbValue::CreateBreakpoint(ppBreakpoint));
    }

    //-----------------------------------------------------------
    // ICorDebugObjectValue
    //-----------------------------------------------------------

    COM_METHOD GetClass(ICorDebugClass **ppClass);
    COM_METHOD GetFieldValue(ICorDebugClass *pClass,
                             mdFieldDef fieldDef,
                             ICorDebugValue **ppValue);
    COM_METHOD GetVirtualMethod(mdMemberRef memberRef,
                                ICorDebugFunction **ppFunction);
    COM_METHOD GetContext(ICorDebugContext **ppContext);
    COM_METHOD IsValueClass(BOOL *pbIsValueClass);
    COM_METHOD GetManagedCopy(IUnknown **ppObject);
    COM_METHOD SetFromManagedCopy(IUnknown *pObject);

    //-----------------------------------------------------------
    // ICorDebugGenericValue
    //-----------------------------------------------------------

    COM_METHOD GetValue(void *pTo);
    COM_METHOD SetValue(void *pFrom); 

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT Init(void);
    HRESULT ResolveValueClass(void);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

private:
    BYTE       *m_objectCopy;
    CordbClass *m_class;
};


/* ------------------------------------------------------------------------- *
 * Box Value class
 * ------------------------------------------------------------------------- */

class CordbBoxValue : public CordbValue, public ICorDebugBoxValue,
                      public ICorDebugGenericValue
{
public:
    CordbBoxValue(CordbAppDomain *appdomain,
                  CordbModule *module,
                  ULONG cbSigBlob,
                  PCCOR_SIGNATURE pvSigBlob,
                  REMOTE_PTR remoteAddress,
                  SIZE_T objectSize,  
                  SIZE_T offsetToVars,
                  CordbClass *objectClass);
    virtual ~CordbBoxValue();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugValue
    //-----------------------------------------------------------

    COM_METHOD GetType(CorElementType *pType)
    {
        return (CordbValue::GetType(pType));
    }
    COM_METHOD GetSize(ULONG32 *pSize)
    {
        return (CordbValue::GetSize(pSize));
    }
    COM_METHOD GetAddress(CORDB_ADDRESS *pAddress)
    {
        return (CordbValue::GetAddress(pAddress));
    }
    COM_METHOD CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint)
    {
        return (CordbValue::CreateBreakpoint(ppBreakpoint));
    }

    //-----------------------------------------------------------
    // ICorDebugHeapValue
    //-----------------------------------------------------------

    COM_METHOD IsValid(BOOL *pbValid);
    COM_METHOD CreateRelocBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint);
    
    //-----------------------------------------------------------
    // ICorDebugGenericValue
    //-----------------------------------------------------------

    COM_METHOD GetValue(void *pTo);
    COM_METHOD SetValue(void *pFrom); 

    //-----------------------------------------------------------
    // ICorDebugBoxValue
    //-----------------------------------------------------------
    COM_METHOD GetObject(ICorDebugObjectValue **ppObject);

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT Init(void);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

private:
    SIZE_T      m_offsetToVars;
    CordbClass *m_class;
};

/* ------------------------------------------------------------------------- *
 * Array Value class
 * ------------------------------------------------------------------------- */

class CordbArrayValue : public CordbValue, public ICorDebugArrayValue,
                        public ICorDebugGenericValue
{
public:
    CordbArrayValue(CordbAppDomain *appdomain,
                    CordbModule *module,
                    ULONG cbSigBlob,
                    PCCOR_SIGNATURE pvSigBlob,
                    DebuggerIPCE_ObjectData *pObjectInfo,
                    CordbClass *elementClass);
    virtual ~CordbArrayValue();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugValue
    //-----------------------------------------------------------

    COM_METHOD GetType(CorElementType *pType)
    {
        return (CordbValue::GetType(pType));
    }
    COM_METHOD GetSize(ULONG32 *pSize)
    {
        return (CordbValue::GetSize(pSize));
    }
    COM_METHOD GetAddress(CORDB_ADDRESS *pAddress)
    {
        return (CordbValue::GetAddress(pAddress));
    }
    COM_METHOD CreateBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint)
    {
        return (CordbValue::CreateBreakpoint(ppBreakpoint));
    }

    //-----------------------------------------------------------
    // ICorDebugHeapValue
    //-----------------------------------------------------------

    COM_METHOD IsValid(BOOL *pbValid);
    COM_METHOD CreateRelocBreakpoint(ICorDebugValueBreakpoint **ppBreakpoint);
    
    //-----------------------------------------------------------
    // ICorDebugArrayValue
    //-----------------------------------------------------------

    COM_METHOD GetElementType(CorElementType *pType);
    COM_METHOD GetRank(ULONG32 *pnRank);
    COM_METHOD GetCount(ULONG32 *pnCount);
    COM_METHOD GetDimensions(ULONG32 cdim, ULONG32 dims[]);
    COM_METHOD HasBaseIndicies(BOOL *pbHasBaseIndicies);
    COM_METHOD GetBaseIndicies(ULONG32 cdim, ULONG32 indicies[]);
    COM_METHOD GetElement(ULONG32 cdim, ULONG32 indicies[],
                          ICorDebugValue **ppValue);
    COM_METHOD GetElementAtPosition(ULONG32 nIndex,
                                    ICorDebugValue **ppValue);

    //-----------------------------------------------------------
    // ICorDebugGenericValue
    //-----------------------------------------------------------

    COM_METHOD GetValue(void *pTo);
    COM_METHOD SetValue(void *pFrom); 

    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------

    HRESULT Init(void);
    HRESULT CreateElementValue(void *remoteElementPtr,
                               void *localElementPtr,
                               ICorDebugValue **ppValue);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

private:
    DebuggerIPCE_ObjectData  m_info;
    CordbClass              *m_class;
    BYTE                    *m_objectCopy;    
    DWORD                   *m_arrayLowerBase; // points _into_ m_objectCopy
    DWORD                   *m_arrayUpperBase; // points _into_ m_objectCopy
    unsigned int             m_idxLower; // index of Lower bound of data
    unsigned int             m_idxUpper; // index of Upper bound of data    
};

/* ------------------------------------------------------------------------- *
 * Snapshot class for EnC
 * ------------------------------------------------------------------------- */
#include "UtilCode.h"
typedef CUnorderedArray<UnorderedILMap, 17> ILMAP_UNORDERED_ARRAY;

class CordbEnCSnapshot : public CordbBase,
                         public ICorDebugEditAndContinueSnapshot
{
    friend class CordbProcess; //so that SendSnapshots can get at m_ILMaps
private:

    static UINT      m_sNextID;
    SIZE_T           m_roDataRVA;
    SIZE_T           m_rwDataRVA;

    IStream         *m_pIStream;
    ULONG            m_cbPEData;

    IStream         *m_pSymIStream;
    ULONG            m_cbSymData;

    CordbModule     *m_module;

    ILMAP_UNORDERED_ARRAY *m_ILMaps;

    COM_METHOD GetDataRVA(ULONG32 *pDataRVA, unsigned int eventType);

public:

    /*
     * Ctor
     */
    CordbEnCSnapshot(CordbModule *module);
    ~CordbEnCSnapshot();

    CordbModule *GetModule() const
    {
        return m_module;
    }

    IStream *GetStream() const
    {
        IStream *p = m_pIStream;
        if (p) p->AddRef();
        return (p);
    }

    ULONG GetImageSize() const
    {
        return (m_cbPEData);
    }

    IStream *GetSymStream() const
    {
        IStream *p = m_pSymIStream;
        if (p) p->AddRef();
        return (p);
    }

    ULONG GetSymSize() const
    {
        return (m_cbSymData);
    }

    HRESULT UpdateMetadata(void);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface); 

    //-----------------------------------------------------------
    // ICorDebugEditAndContinueSnapshot
    //-----------------------------------------------------------

    /*
     * CopyMetaData saves a copy of the executing metadata from the debuggee
     * for this snapshot to the output stream.  The stream implementation must
     * be supplied by the caller and will typically either save the copy to
     * memory or to disk.  Only the IStream::Write method will be called by
     * this method.  The MVID value returned is the unique metadata ID for
     * this copy of the metadata.  It may be used on subsequent edit and 
     * continue operations to determine if the client has the most recent
     * version already (performance win to cache).
     */
    COM_METHOD CopyMetaData(IStream *pIStream, GUID *pMvid);
    
    /*
     * GetMvid will return the currently active metadata ID for the executing
     * process.  This value can be used in conjunction with CopyMetaData to
     * cache the most recent copy of the metadata and avoid expensive copies.
     * So for example, if you call CopyMetaData once and save that copy,
     * then on the next E&C operation you can ask for the current MVID and see
     * if it is already in your cache.  If it is, use your version instead of
     * calling CopyMetaData again.
     */
    COM_METHOD GetMvid(GUID *pMvid);

    /*
     * GetRoDataRVA returns the base RVA that should be used when adding new
     * static read only data to an existing image.  The EE will guarantee that
     * any RVA values embedded in the code are valid when the delta PE is
     * applied with new data.  The new data will be added to a page that is
     * marked read only.
     */
    COM_METHOD GetRoDataRVA(ULONG32 *pRoDataRVA);

    /*
     * GetRwDataRVA returns the base RVA that should be used when adding new
     * static read/write data to an existing image.  The EE will guarantee that
     * any RVA values embedded in the code are valid when the delta PE is
     * applied with new data.  The ew data will be added to a page that is 
     * marked for both read and write access.
     */
    COM_METHOD GetRwDataRVA(ULONG32 *pRwDataRVA);


    /*
     * SetPEBytes gives the snapshot object a reference to the delta PE which was
     * based on the snapshot.  This reference will be AddRef'd and cached until
     * CanCommitChanges and/or CommitChanges are called, at which point the 
     * engine will read the delta PE and remote it into the debugee process where
     * the changes will be checked/applied.
     */
    COM_METHOD SetPEBytes(IStream *pIStream);

    /*
     * SetILMap is called once for every method being replace that has
     * active instances on a call stack on a thread in the target process.
     * It is up to the caller of this API to determine this case exists.
     * One should halt the target process before making this check and
     * calling this method.
     */
    COM_METHOD SetILMap(mdToken mdFunction, ULONG cMapSize, COR_IL_MAP map[]);    

    COM_METHOD SetPESymbolBytes(IStream *pIStream);
};

/* ------------------------------------------------------------------------- *
 * Eval class
 * ------------------------------------------------------------------------- */

class CordbEval : public CordbBase, public ICorDebugEval
{
public:
    CordbEval(CordbThread* pThread);
    virtual ~CordbEval();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorDebugEval
    //-----------------------------------------------------------

    COM_METHOD CallFunction(ICorDebugFunction *pFunction, 
                            ULONG32 nArgs,
                            ICorDebugValue *ppArgs[]);
    COM_METHOD NewObject(ICorDebugFunction *pConstructor,
                         ULONG32 nArgs,
                         ICorDebugValue *ppArgs[]);
    COM_METHOD NewObjectNoConstructor(ICorDebugClass *pClass);
    COM_METHOD NewString(LPCWSTR string);
    COM_METHOD NewArray(CorElementType elementType,
                        ICorDebugClass *pElementClass, 
                        ULONG32 rank,
                        ULONG32 dims[], 
                        ULONG32 lowBounds[]);
    COM_METHOD IsActive(BOOL *pbActive);
    COM_METHOD Abort(void);
    COM_METHOD GetResult(ICorDebugValue **ppResult);
    COM_METHOD GetThread(ICorDebugThread **ppThread);
    COM_METHOD CreateValue(CorElementType elementType,
                           ICorDebugClass *pElementClass,
                           ICorDebugValue **ppValue);
    
    //-----------------------------------------------------------
    // Non-COM methods
    //-----------------------------------------------------------
    HRESULT GatherArgInfo(ICorDebugValue *pValue,
                          DebuggerIPCE_FuncEvalArgData *argData);
    HRESULT SendCleanup(void);

    //-----------------------------------------------------------
    // Data members
    //-----------------------------------------------------------

private:
    CordbThread               *m_thread;
    CordbFunction             *m_function;
    CordbClass                *m_class;
    DebuggerIPCE_FuncEvalType  m_evalType;

    HRESULT SendFuncEval(DebuggerIPCEvent * event);

public:
    bool                       m_complete;
    bool                       m_successful;
    bool                       m_aborted;
    void                      *m_resultAddr;
    CorElementType             m_resultType;
    void                      *m_resultDebuggerModuleToken;
    void                      *m_resultAppDomainToken;
    void                      *m_debuggerEvalKey;
    bool                       m_evalDuringException;
};


/* ------------------------------------------------------------------------- *
 * Win32 Event Thread class
 * ------------------------------------------------------------------------- */
const unsigned int CW32ET_UNKNOWN_PROCESS_SLOT = 0xFFffFFff; // it's a managed process,
        //but we don't know which slot it's in - for Detach.

class CordbWin32EventThread
{
    friend class CordbProcess; //so that Detach can call ExitProcess
public:
    CordbWin32EventThread(Cordb* cordb);
    virtual ~CordbWin32EventThread();

    //
    // You create a new instance of this class, call Init() to set it up,
    // then call Start() start processing events. Stop() terminates the
    // thread and deleting the instance cleans all the handles and such
    // up.
    //
    HRESULT Init(void);
    HRESULT Start(void);
    HRESULT Stop(void);

    HRESULT SendCreateProcessEvent(LPCWSTR programName,
                                   LPWSTR  programArgs,
                                   LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                   LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                   BOOL bInheritHandles,
                                   DWORD dwCreationFlags,
                                   PVOID lpEnvironment,
                                   LPCWSTR lpCurrentDirectory,
                                   LPSTARTUPINFOW lpStartupInfo,
                                   LPPROCESS_INFORMATION lpProcessInformation,
                                   CorDebugCreateProcessFlags corDebugFlags);

    HRESULT SendDebugActiveProcessEvent(DWORD pid, 
                                        bool fWin32Attach, 
                                        CordbProcess *pProcess);
    HRESULT SendDetachProcessEvent(CordbProcess *pProcess);
    HRESULT SendUnmanagedContinue(CordbProcess *pProcess,
                                  bool internalContinue,
                                  bool outOfBandContinue);
    HRESULT UnmanagedContinue(CordbProcess *pProcess,
                              bool internalContinue,
                              bool outOfBandContinue);
    void DoDbgContinue(CordbProcess *pProcess,
                       CordbUnmanagedEvent *ue,
                       DWORD contType,
                       bool contProcess);
    void ForceDbgContinue(CordbProcess *pProcess,
                          CordbUnmanagedThread *ut,
                          DWORD contType,
                          bool contProcess);
    void HijackLastThread(CordbProcess *pProcess,
                          CordbUnmanagedThread *pThread);
    
    void LockSendToWin32EventThreadMutex(void)
    {
        LOCKCOUNTINCL("LockSendToWin32EventThreadMutex in cordb.h");
        LOG((LF_CORDB, LL_INFO10000, "W32ET::LockSendToWin32EventThreadMutex\n"));
        EnterCriticalSection(&m_sendToWin32EventThreadMutex);
    }

    void UnlockSendToWin32EventThreadMutex(void)
    {
        LeaveCriticalSection(&m_sendToWin32EventThreadMutex);
        LOG((LF_CORDB, LL_INFO10000, "W32ET::UnlockSendToWin32EventThreadMutex\n"));
        LOCKCOUNTDECL("unLockSendToWin32EventThreadMutex in cordb.h");
    }

    bool IsWin32EventThread(void)
    {
        return (m_threadId == GetCurrentThreadId());
    }

    void Win32EventLoop(void);

    void SweepFCHThreads(void);
    
private:
    void ThreadProc(void);
    static DWORD WINAPI ThreadProc(LPVOID parameter);

    void CreateProcess(void);

    //
    // EnsureCorDbgEnvVarSet makes sure that a user supplied
    // environment block contains the proper environment variable to
    // enable debugging on the Left Side.
    //
    template<class _T> bool EnsureCorDbgEnvVarSet(_T **ppEnv,
                                                  _T *varName,
                                                  bool isUnicode,
                                                  DWORD flag)
    {
        _ASSERTE(ppEnv != NULL);
        _ASSERTE(flag == 1 &&
                 "EnsureCorDbgEnvVarSet needs to be updated to set environment variables to values other than 1");

        _T *pEnv = (_T*) *ppEnv;

        // Nothing to do if there is no user supplied env block since
        // the initialization of Cordb set the env var in this
        // process's env block.
        if (pEnv == NULL)
            return false;

        // Find where the env var should be in the block
        _T *p = (_T*)pEnv;
        _T *lowEnd = NULL;
        _T *ourVar = NULL;
        SIZE_T varNameLen;

        if (isUnicode)
            varNameLen = wcslen((WCHAR*)varName);
        else
            varNameLen = strlen((CHAR*)varName);

        while (*p)
        {
            int res;

            if (isUnicode)
                res = _wcsnicmp((WCHAR*)p, (WCHAR*)varName, varNameLen);
            else
                res = _strnicmp((CHAR*)p, (CHAR*)varName, varNameLen);

            // It seems the environment block is only sorted on NT, so
            // we only look for our var in sorted position on NT.

            if (res == 0)
            {
                // Found it. lowEnd should point to the end of the
                // last var already. Remember where the good var is
                // and skip over it to find the next highest one.
                ourVar = p;
                while (*p++) ;
                break;
            }
            else if ((res < 0) || !Cordb::m_runningOnNT)
            {
                // Skip over this var since its smaller than ours
                while (*p++) ;

                // Remember the first char past the end
                lowEnd = p ;
            }
            else if (res > 0)
                // This var is too big. lowEnd still points to the end
                // of the last smaller var.
                break;
        }

        // Remember where the high part starts.
        _T *highStart = p;

        if (ourVar == NULL)
        {
            // At this point, we know that p is pointing to the first character before which
            // varname should be inserted.  If ourvar != NULL, then p points to the first
            // character of the next variable.  In the case that we're at the end of the
            // environment block, then p points to the second NULL that terminates the block,
            // but the logic of inserting/modifying the variable remains the same

            // We didn't find our var, so go ahead and rebuild the env
            // block with the low half, our var, then the high half.

            // Run up to the end to find the total length;
            while (*p || *(p+1)) p++;

            // Advance p to point to just after the last character of the block
            p += 2;

            // Since pEnv points to the first character of the environment block and
            // p points to the first non-block character, p-pEnv is the total size in
            // characters of the block.  Add the size of the variable plus 2 for the
            // value and null char
            SIZE_T totalLen = ((p - pEnv) + (varNameLen + 2));

            // Allocate a new buffer.
            _T *newEnv = new _T[totalLen];
            _T *p2 = newEnv;

            // Copy the low part in
            if (lowEnd != NULL)
            {
                memcpy(p2, pEnv, (lowEnd - pEnv) * sizeof(_T));
                p2 += lowEnd - pEnv;
            }

            // Copy in our env var and a null terminator (wcs/strcopy also copies in the null)
            if (isUnicode)
                wcscpy((WCHAR*)p2, (WCHAR*)varName);
            else
                strcpy((CHAR*)p2, (CHAR*)varName);

            // Advance p2
            p2 += varNameLen;

            // Assign a default value
            if (isUnicode)
                wcscpy((WCHAR*)p2, L"1");
            else
                strcpy((CHAR*)p2, "1");
        
            // Advance past the single-character default value and terminating NULL
            p2 += 2;

            // Copy in the high part. Note: the high part has both the
            // null terminator for the last string and the null
            // termination for the entire block on it. Thus, the +3
            // instead of +2. Also, because of this, the high part is
            // never empty.
            memcpy(p2, highStart, (p - highStart) * sizeof(_T));

            // Assert that we didn't go overboard here...
            _ASSERTE(((p2 + (p - highStart)) - newEnv) == totalLen);
                 
            *ppEnv = newEnv;
    
            return true;
        }
        else
        {
            // Found our var. So just make sure that the value
            // includes DBCF_GENERATE_DEBUG_CODE. Note: in order to
            // ensure that we'll never have to increase the size of
            // the environment block if our var is already in there,
            // we make sure that DBCF_GENERATE_DEBUG_CODE == 1 so that
            // we only have to toggle the low bit of the value.
            _ASSERTE(DBCF_GENERATE_DEBUG_CODE == 0x01);
            
            // Pointer to the last digit of the value
            _T *pValue = highStart - 2;

            // Set the low bit of the last digit and replace it.
            if ((*pValue >= L'0') && (*pValue <= L'9'))
            {
                unsigned int v = *pValue - L'0';
                v |= flag;
                
                _ASSERTE(v <= 9);
            
                *pValue = L'0' + v;
            }
            else
            {
                unsigned int v;
            
                if ((*pValue >= L'a') && (*pValue <= L'f'))
                    v = *pValue - L'a';
                else
                    v = *pValue - L'A';
            
                v |= flag;

                _ASSERTE(v <= 15);
            
                *pValue = L'a' + v;
            }

            return false;
        }
    }


    void AttachProcess(void);
    void HandleUnmanagedContinue(void);
    void ExitProcess(CordbProcess *process, unsigned int processSlot);
        
private:
    Cordb*               m_cordb;
    HANDLE               m_thread;
    DWORD                m_threadId;
    HANDLE               m_threadControlEvent;
    HANDLE               m_actionTakenEvent;
    BOOL                 m_run;
    unsigned int         m_win32AttachedCount;
    DWORD                m_waitTimeout;
    unsigned int         m_waitCount;
    HANDLE               m_waitSet[MAXIMUM_WAIT_OBJECTS];
    CordbProcess        *m_processSet[MAXIMUM_WAIT_OBJECTS];

    CRITICAL_SECTION     m_sendToWin32EventThreadMutex;
    
    unsigned int         m_action;
    HRESULT              m_actionResult;
    union
    {
        struct
        {
            LPCWSTR programName;
            LPWSTR  programArgs;
            LPSECURITY_ATTRIBUTES lpProcessAttributes;
            LPSECURITY_ATTRIBUTES lpThreadAttributes;
            BOOL bInheritHandles;
            DWORD dwCreationFlags;
            PVOID lpEnvironment;
            LPCWSTR lpCurrentDirectory;
            LPSTARTUPINFOW lpStartupInfo;
            LPPROCESS_INFORMATION lpProcessInformation;
            CorDebugCreateProcessFlags corDebugFlags;
        } createData;

        struct
        {
            DWORD           processId;
            bool            fWin32Attach;
            CordbProcess    *pProcess;
        } attachData;

        struct
        {
            CordbProcess    *pProcess;
        } detachData;

        struct
        {
            CordbProcess *process;
            bool          internalContinue;
            bool          outOfBandContinue;
        } continueData;
    }                    m_actionData;
};


/* ------------------------------------------------------------------------- *
 * Runtime Controller Event Thread class
 * ------------------------------------------------------------------------- */

class CordbRCEventThread
{
public:
    CordbRCEventThread(Cordb* cordb);
    virtual ~CordbRCEventThread();

    //
    // You create a new instance of this class, call Init() to set it up,
    // then call Start() start processing events. Stop() terminates the
    // thread and deleting the instance cleans all the handles and such
    // up.
    //
    HRESULT Init(void);
    HRESULT Start(void);
    HRESULT Stop(void);

    HRESULT SendIPCEvent(CordbProcess* process,
                         DebuggerIPCEvent* event,
                         SIZE_T eventSize);

    void ProcessStateChanged(void);
    void FlushQueuedEvents(CordbProcess* process);

    HRESULT WaitForIPCEventFromProcess(CordbProcess* process,
                                       CordbAppDomain *pAppDomain,
                                       DebuggerIPCEvent* event);
                                      
    HRESULT ReadRCEvent(CordbProcess* process,
                        DebuggerIPCEvent* event);
    void CopyRCEvent(BYTE *src, BYTE *dst);
private:
    void ThreadProc(void);
    static DWORD WINAPI ThreadProc(LPVOID parameter);
    HRESULT HandleFirstRCEvent(CordbProcess* process);
    void HandleRCEvent(CordbProcess* process,
                       DebuggerIPCEvent* event);

public:
    // Not an actual RPC, since it's all inproc, but it otherwise
    // behaves like our custom IPC stuff does.
    // Note that this sends stuff to the Virtual Right Side - the
    // inproc stuff
    // See also: Debugger::VrpcToVls
    HRESULT VrpcToVrs(CordbProcess *process,DebuggerIPCEvent* event)
#ifdef RIGHT_SIDE_ONLY
    { return S_OK; } // not used by the right side
#else
    ; // defined in EE\process.cpp
#endif
    
private:
    Cordb*               m_cordb;
    HANDLE               m_thread;
    BOOL                 m_run;
    HANDLE               m_threadControlEvent;
    BOOL                 m_processStateChanged;
};

/* ------------------------------------------------------------------------- *
 * Unmanaged Event struct
 * ------------------------------------------------------------------------- */

enum CordbUnmanagedEventState
{
    CUES_None                 = 0x00,
    CUES_ExceptionCleared     = 0x01,
    CUES_EventContinued       = 0x02,
    CUES_Dispatched           = 0x04,
    CUES_ExceptionUnclearable = 0x08
};

struct CordbUnmanagedEvent
{
public:
    BOOL IsExceptionCleared(void) { return m_state & CUES_ExceptionCleared; }
    BOOL IsEventContinued(void) { return m_state & CUES_EventContinued; }
    BOOL IsDispatched(void) { return m_state & CUES_Dispatched; }
    BOOL IsExceptionUnclearable(void) { return m_state & CUES_ExceptionUnclearable; }

    void SetState(CordbUnmanagedEventState state) { m_state = (CordbUnmanagedEventState)(m_state | state); }
    void ClearState(CordbUnmanagedEventState state) { m_state = (CordbUnmanagedEventState)(m_state & ~state); }

    CordbUnmanagedThread     *m_owner;
    CordbUnmanagedEventState  m_state;
    DEBUG_EVENT               m_currentDebugEvent;
    CordbUnmanagedEvent      *m_next;
};


/* ------------------------------------------------------------------------- *
 * Unmanaged Thread class
 * ------------------------------------------------------------------------- */

enum CordbUnmanagedThreadState
{
    CUTS_None                        = 0x0000,
    CUTS_Deleted                     = 0x0001,
    CUTS_FirstChanceHijacked         = 0x0002,
    CUTS_HideFirstChanceHijackState  = 0x0004,
    CUTS_GenericHijacked             = 0x0008,
    CUTS_SecondChanceHijacked        = 0x0010,
    CUTS_HijackedForSync             = 0x0020,
    CUTS_Suspended                   = 0x0040,
    CUTS_IsSpecialDebuggerThread     = 0x0080,
    CUTS_AwaitingOwnershipAnswer     = 0x0100,
    CUTS_HasIBEvent                  = 0x0200,
    CUTS_HasOOBEvent                 = 0x0400,
    CUTS_HasSpecialStackOverflowCase = 0x0800
};

class CordbUnmanagedThread : public CordbBase
{
public:
    CordbUnmanagedThread(CordbProcess *pProcess, DWORD dwThreadId, HANDLE hThread, void *lpThreadLocalBase);
    ~CordbUnmanagedThread();

    ULONG STDMETHODCALLTYPE AddRef() {return (BaseAddRef());}
    ULONG STDMETHODCALLTYPE Release() {return (BaseRelease());}

    COM_METHOD QueryInterface(REFIID riid, void **ppInterface)
    {
        // Not really used since we never expose this class. If we ever do expose this class via the ICorDebug API then
        // we should, of course, implement this.
        return E_NOINTERFACE;
    }

    CordbProcess *GetProcess()
    {
        return (m_process);
    }

    REMOTE_PTR GetEETlsValue(void);
    HRESULT LoadTLSArrayPtr(void);
    HRESULT SetEETlsValue(REMOTE_PTR EETlsValue);
    REMOTE_PTR GetEEThreadPtr(void);
    void GetEEThreadState(REMOTE_PTR EETlsValue, bool *threadStepping, bool *specialManagedException);
    bool GetEEThreadFrame(REMOTE_PTR EETlsValue);
    DWORD GetEEThreadDebuggerWord(REMOTE_PTR EETlsValue);
    HRESULT SetEEThreadDebuggerWord(REMOTE_PTR EETlsValue, DWORD word);
    bool GetEEThreadCantStop(REMOTE_PTR EETlsValue);
    bool GetEEThreadPGCDisabled(REMOTE_PTR EETlsValue);

    HRESULT SetupFirstChanceHijack(REMOTE_PTR EETlsValue);
    HRESULT FixupFromFirstChanceHijack(EXCEPTION_RECORD *pExceptionRecord, bool *pbExceptionBelongsToRuntime);
    HRESULT SetupGenericHijack(DWORD eventCode);
    HRESULT FixupFromGenericHijack(void);
    HRESULT SetupSecondChanceHijack(REMOTE_PTR EETlsValue);
    HRESULT FixupStackBasedChains(REMOTE_PTR EETlsValue);
    HRESULT DoMoreSecondChanceHijack(void);

    HRESULT FixupAfterOOBException(CordbUnmanagedEvent *ue);

    BOOL IsDeleted(void) { return m_state & CUTS_Deleted; }
    BOOL IsFirstChanceHijacked(void) { return m_state & CUTS_FirstChanceHijacked; }
    BOOL IsHideFirstChanceHijackState(void) { return m_state & CUTS_HideFirstChanceHijackState; }
    BOOL IsGenericHijacked(void) { return m_state & CUTS_GenericHijacked; }
    BOOL IsSecondChanceHijacked(void) { return m_state & CUTS_SecondChanceHijacked; }
    BOOL IsHijackedForSync(void) { return m_state & CUTS_HijackedForSync; }
    BOOL IsSuspended(void) { return m_state & CUTS_Suspended; }
    BOOL IsSpecialDebuggerThread(void) { return m_state & CUTS_IsSpecialDebuggerThread; }
    BOOL IsAwaitingOwnershipAnswer(void) { return m_state & CUTS_AwaitingOwnershipAnswer; }
    BOOL HasIBEvent(void) { return m_state & CUTS_HasIBEvent; }
    BOOL HasOOBEvent(void) { return m_state & CUTS_HasOOBEvent; }
    BOOL HasSpecialStackOverflowCase(void) { return m_state & CUTS_HasSpecialStackOverflowCase; }

    void SetState(CordbUnmanagedThreadState state) { m_state = (CordbUnmanagedThreadState)(m_state | state); }
    void ClearState(CordbUnmanagedThreadState state) { m_state = (CordbUnmanagedThreadState)(m_state & ~state); }

    CordbUnmanagedEvent *IBEvent(void)  { return &m_IBEvent; }
    CordbUnmanagedEvent *IBEvent2(void) { return &m_IBEvent2; }
    CordbUnmanagedEvent *OOBEvent(void) { return &m_OOBEvent; }

public:
    CordbProcess              *m_process;
    HANDLE                     m_handle;
    void                      *m_threadLocalBase;
    void                      *m_pTLSArray;

    CordbUnmanagedThreadState  m_state;
    
    CordbUnmanagedEvent        m_IBEvent;
    CordbUnmanagedEvent        m_IBEvent2;
    CordbUnmanagedEvent        m_OOBEvent;
    
    CONTEXT                    m_context;
    CONTEXT                   *m_pLeftSideContext;
    void                      *m_originalHandler;
};




//********************************************************************************
//**************** App Domain Publishing Service API *****************************
//********************************************************************************

class EnumElement
{
public:
    EnumElement() 
    {
        m_pData = NULL;
        m_pNext = NULL;
    }

    void SetData (void *pData) { m_pData = pData;}
    void *GetData (void) { return m_pData;}
    void SetNext (EnumElement *pNext) { m_pNext = pNext;}
    EnumElement *GetNext (void) { return m_pNext;}

private:
    void        *m_pData;
    EnumElement *m_pNext;
};


class CorpubPublish : public CordbBase, public ICorPublish
{
public:
    CorpubPublish();
    virtual ~CorpubPublish();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorPublish
    //-----------------------------------------------------------

    COM_METHOD EnumProcesses(
        COR_PUB_ENUMPROCESS Type,
        ICorPublishProcessEnum **ppIEnum);

    COM_METHOD GetProcess(
        unsigned pid, 
        ICorPublishProcess **ppProcess);
   
    
    COM_METHOD EnumProcessesInternal(COR_PUB_ENUMPROCESS Type,
                                    ICorPublishProcessEnum **ppIEnum,
                                    unsigned pid, 
                                    ICorPublishProcess **ppProcess,
                                    BOOL fOnlyOneProcess
                                    );

    //-----------------------------------------------------------
    // CreateObject
    //-----------------------------------------------------------
    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        *object = NULL;

        if (id != IID_IUnknown && id != IID_ICorPublish)
            return (E_NOINTERFACE);

        CorpubPublish *pCorPub = new CorpubPublish();

        if (pCorPub == NULL)
            return (E_OUTOFMEMORY);

        *object = (ICorPublish*)pCorPub;
        pCorPub->AddRef();

        return (S_OK);
    }

    CorpubProcess *GetFirstProcess (void) { return m_pProcess;}

private:
    CorpubProcess       *m_pProcess;    // pointer to the first process in the list
    EnumElement         *m_pHeadIPCReaderList;   
};

class CorpubProcess : public CordbBase, public ICorPublishProcess
{
public:
    CorpubProcess(DWORD dwProcessId, bool fManaged, HANDLE hProcess, 
        HANDLE hMutex, AppDomainEnumerationIPCBlock *pAD);
    virtual ~CorpubProcess();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorPublishProcess
    //-----------------------------------------------------------
    COM_METHOD IsManaged(BOOL *pbManaged);
    
    /*
     * Enumerate the list of known application domains in the target process.
     */
    COM_METHOD EnumAppDomains(ICorPublishAppDomainEnum **ppEnum);
    
    /*
     * Returns the OS ID for the process in question.
     */
    COM_METHOD GetProcessID(unsigned *pid);
    
    /*
     * Get the display name for a process.
     */
    COM_METHOD GetDisplayName(ULONG32 cchName, 
                                ULONG32 *pcchName,
                                WCHAR szName[]);

    CorpubProcess   *GetNextProcess (void) { return m_pNext;}
    void SetNext (CorpubProcess *pNext) { m_pNext = pNext;}

public:
    DWORD                           m_dwProcessId;

private:
    bool                            m_fIsManaged;
    HANDLE                          m_hProcess;
    HANDLE                          m_hMutex;
    AppDomainEnumerationIPCBlock    *m_AppDomainCB;
    CorpubProcess                   *m_pNext;   // pointer to the next process in the process list
    CorpubAppDomain                 *m_pAppDomain;
    WCHAR                           *m_szProcessName;

};

class CorpubAppDomain  : public CordbBase, public ICorPublishAppDomain
{
public:
    CorpubAppDomain (WCHAR *szAppDomainName, ULONG Id);
    virtual ~CorpubAppDomain();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface (REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorPublishAppDomain
    //-----------------------------------------------------------

    /*
     * Get the name and ID for an application domain.
     */
    COM_METHOD GetID (ULONG32 *pId);
    
    /*
     * Get the name for an application domain.
     */
    COM_METHOD GetName (ULONG32 cchName, 
                        ULONG32 *pcchName,
                        WCHAR szName[]);

    CorpubAppDomain *GetNextAppDomain (void) { return m_pNext;}
    void SetNext (CorpubAppDomain *pNext) { m_pNext = pNext;}

private:
    CorpubAppDomain *m_pNext;
    WCHAR           *m_szAppDomainName;
    ULONG           m_id;

};

class CorpubProcessEnum : public CordbBase, public ICorPublishProcessEnum
{
public:
    CorpubProcessEnum(CorpubProcess *pFirst);
    virtual ~CorpubProcessEnum(){}

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorPublishProcessEnum
    //-----------------------------------------------------------

    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset();
    COM_METHOD Clone(ICorPublishEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);
    COM_METHOD Next(ULONG celt,
                    ICorPublishProcess *objects[],
                    ULONG *pceltFetched);

private:
    CorpubProcess       *m_pFirst;
    CorpubProcess       *m_pCurrent;

};

class CorpubAppDomainEnum : public CordbBase, public ICorPublishAppDomainEnum
{
public:
    CorpubAppDomainEnum(CorpubAppDomain *pFirst);
    virtual ~CorpubAppDomainEnum(){}

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // ICorPublishAppDomainEnum
    //-----------------------------------------------------------
    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset();
    COM_METHOD Clone(ICorPublishEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);

    COM_METHOD Next(ULONG celt,
                    ICorPublishAppDomain *objects[],
                    ULONG *pceltFetched);

private:
    CorpubAppDomain     *m_pFirst;
    CorpubAppDomain     *m_pCurrent;

};

// Since the hash table of modules is per app domain (and
// threads is per prcoess) (for fast lookup from the appdomain/proces), 
// we need this wrapper
// here which allows us to iterate through an assembly's
// modules.  Is basically filters out modules/threads that aren't
// in the assembly/appdomain. This slow & awkward for assemblies, but fast
// for the common case - appdomain lookup.
class CordbEnumFilter : public CordbBase, 
                        public ICorDebugThreadEnum,
                        public ICorDebugModuleEnum
{
public:
    CordbEnumFilter();
    CordbEnumFilter::CordbEnumFilter(CordbEnumFilter*src);
    virtual ~CordbEnumFilter();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // Common methods
    //-----------------------------------------------------------
    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset();
    COM_METHOD Clone(ICorDebugEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);
    //-----------------------------------------------------------
    // ICorDebugModuleEnum
    //-----------------------------------------------------------
    COM_METHOD Next(ULONG celt,
                    ICorDebugModule *objects[],
                    ULONG *pceltFetched);

    //-----------------------------------------------------------
    // ICorDebugThreadEnum
    //-----------------------------------------------------------
    COM_METHOD Next(ULONG celt,
                    ICorDebugThread *objects[],
                    ULONG *pceltFetched);

    HRESULT Init (ICorDebugModuleEnum *pModEnum, CordbAssembly *pAssembly);
    HRESULT Init (ICorDebugThreadEnum *pThreadEnum, CordbAppDomain *pAppDomain);

private:

    EnumElement *m_pFirst;
    EnumElement *m_pCurrent;
    int         m_iCount;
};

class CordbEnCErrorInfo : public CordbBase,
                           public IErrorInfo,
                           public ICorDebugEditAndContinueErrorInfo
{
public:
    CordbEnCErrorInfo();
    virtual ~CordbEnCErrorInfo();

    HRESULT Init(CordbModule *pModule,
                 mdToken token,
                 HRESULT hr,
                 WCHAR *sz);

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // IErrorInfo
    //-----------------------------------------------------------
    COM_METHOD GetDescription(BSTR  *pBstrDescription); 
    COM_METHOD GetGUID(GUID  *pGUID);
    COM_METHOD GetHelpContext(DWORD  *pdwHelpContext);
    COM_METHOD GetHelpFile(BSTR  *pBstrHelpFile);
    COM_METHOD GetSource(BSTR  *pBstrSource);
    
    //-----------------------------------------------------------
    // ICorDebugEditAndContinueErrorInfo
    //-----------------------------------------------------------

    COM_METHOD GetModule(ICorDebugModule **ppModule);
    COM_METHOD GetToken(mdToken *pToken);
    COM_METHOD GetErrorCode(HRESULT *pHr);
    COM_METHOD GetString(ULONG32 cchString, 
                         ULONG32 *pcchString,
                         WCHAR szString[]); 
private:
    CordbModule *m_pModule;
    mdToken      m_token;
    HRESULT      m_hr;
    WCHAR       *m_szError;
} ;


typedef struct _UnorderedEnCErrorInfoArrayRefCount : public CordbBase
{
    UnorderedEnCErrorInfoArray *m_pErrors;
    CordbEnCErrorInfo          *m_pCordbEnCErrors;

    _UnorderedEnCErrorInfoArrayRefCount() : CordbBase(0)
    { 
        m_pErrors = NULL;
        m_pCordbEnCErrors = NULL;
    }   

    virtual ~_UnorderedEnCErrorInfoArrayRefCount()
    {
        if (m_pErrors != NULL)
        {
            delete m_pErrors;
            m_pErrors = NULL;
        }

        if (m_pCordbEnCErrors != NULL)
        {
            delete [] m_pCordbEnCErrors;
            m_pCordbEnCErrors = NULL;
        }
    }
    
    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }

    // We shouldn't be calling this
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface)
    {
        return E_NOTIMPL;
    }

} UnorderedEnCErrorInfoArrayRefCount;

class CordbEnCErrorInfoEnum : public CordbBase, 
                              public ICorDebugErrorInfoEnum
{
public:
    CordbEnCErrorInfoEnum();
    virtual ~CordbEnCErrorInfoEnum();

    //-----------------------------------------------------------
    // IUnknown
    //-----------------------------------------------------------

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (BaseAddRef());
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        return (BaseRelease());
    }
    COM_METHOD QueryInterface(REFIID riid, void **ppInterface);

    //-----------------------------------------------------------
    // Common methods
    //-----------------------------------------------------------
    COM_METHOD Skip(ULONG celt);
    COM_METHOD Reset();
    COM_METHOD Clone(ICorDebugEnum **ppEnum);
    COM_METHOD GetCount(ULONG *pcelt);
    
    //-----------------------------------------------------------
    // ICorDebugErrorInfoEnum
    //-----------------------------------------------------------
    COM_METHOD Next(ULONG celt,
                    ICorDebugEditAndContinueErrorInfo *objects[],
                    ULONG *pceltFetched);

    HRESULT Init(UnorderedEnCErrorInfoArrayRefCount *refCountedArray);

private:
    UnorderedEnCErrorInfoArrayRefCount *m_errors;
    USHORT                              m_iCur;
    USHORT                              m_iCount;
};


#endif /* CORDB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\debuggerutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"


//
//
// CHashTable
//
//

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
HRESULT CHashTable::NewInit(            // Return status.
    BYTE        *pcEntries,             // Array of structs we are managing.
    USHORT      iEntrySize)             // Size of the entries.
{
    _ASSERTE(iEntrySize >= sizeof(FREEHASHENTRY));

    // Allocate the bucket chain array and init it.
    if ((m_piBuckets = new USHORT [m_iBuckets]) == NULL)
        return E_OUTOFMEMORY;
    memset(m_piBuckets, 0xff, m_iBuckets * sizeof(USHORT));

    // Save the array of structs we are managing.
    m_pcEntries = pcEntries;
    m_iEntrySize = iEntrySize;
    return (S_OK);
}

//*****************************************************************************
// Add the struct at the specified index in m_pcEntries to the hash chains.
//*****************************************************************************
BYTE *CHashTable::Add(                  // New entry.
    USHORT      iHash,                  // Hash value of entry to add.
    USHORT      iIndex)                 // Index of struct in m_pcEntries.
{
    HASHENTRY   *psEntry;               // The struct we are adding.

    // Get a pointer to the entry we are adding.
    psEntry = EntryPtr(iIndex);

    // Compute the hash value for the entry.
    iHash %= m_iBuckets;

    _ASSERTE(m_piBuckets[iHash] != iIndex &&
        (m_piBuckets[iHash] == 0xffff || EntryPtr(m_piBuckets[iHash])->iPrev != iIndex));

    // Setup this entry.
    psEntry->iPrev = 0xffff;
    psEntry->iNext = m_piBuckets[iHash];

    // Link it into the hash chain.
    if (m_piBuckets[iHash] != 0xffff)
        EntryPtr(m_piBuckets[iHash])->iPrev = iIndex;
    m_piBuckets[iHash] = iIndex;
    return ((BYTE *) psEntry);
}

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
void CHashTable::Delete(
    USHORT      iHash,                  // Hash value of entry to delete.
    USHORT      iIndex)                 // Index of struct in m_pcEntries.
{
    HASHENTRY   *psEntry;               // Struct to delete.
    
    // Get a pointer to the entry we are deleting.
    psEntry = EntryPtr(iIndex);
    Delete(iHash, psEntry);
}

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
void CHashTable::Delete(
    USHORT      iHash,                  // Hash value of entry to delete.
    HASHENTRY   *psEntry)               // The struct to delete.
{
    // Compute the hash value for the entry.
    iHash %= m_iBuckets;

    _ASSERTE(psEntry->iPrev != psEntry->iNext || psEntry->iPrev == 0xffff);

    // Fix the predecessor.
    if (psEntry->iPrev == 0xffff)
        m_piBuckets[iHash] = psEntry->iNext;
    else
        EntryPtr(psEntry->iPrev)->iNext = psEntry->iNext;

    // Fix the successor.
    if (psEntry->iNext != 0xffff)
        EntryPtr(psEntry->iNext)->iPrev = psEntry->iPrev;
}

//*****************************************************************************
// The item at the specified index has been moved, update the previous and
// next item.
//*****************************************************************************
void CHashTable::Move(
    USHORT      iHash,                  // Hash value for the item.
    USHORT      iNew)                   // New location.
{
    HASHENTRY   *psEntry;               // The struct we are deleting.

    psEntry = EntryPtr(iNew);
    _ASSERTE(psEntry->iPrev != iNew && psEntry->iNext != iNew);

    if (psEntry->iPrev != 0xffff)
        EntryPtr(psEntry->iPrev)->iNext = iNew;
    else
        m_piBuckets[iHash % m_iBuckets] = iNew;
    if (psEntry->iNext != 0xffff)
        EntryPtr(psEntry->iNext)->iPrev = iNew;
}

//*****************************************************************************
// Search the hash table for an entry with the specified key value.
//*****************************************************************************
BYTE *CHashTable::Find(                 // Index of struct in m_pcEntries.
    USHORT      iHash,                  // Hash value of the item.
    BYTE        *pcKey)                 // The key to match.
{
    USHORT      iNext;                  // Used to traverse the chains.
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    // Start at the top of the chain.
    iNext = m_piBuckets[iHash % m_iBuckets];

    // Search until we hit the end.
    while (iNext != 0xffff)
    {
        // Compare the keys.
        psEntry = EntryPtr(iNext);
        if (!Cmp(pcKey, psEntry))
            return ((BYTE *) psEntry);

        // Advance to the next item in the chain.
        iNext = psEntry->iNext;
    }

    // We couldn't find it.
    return (0);
}

//*****************************************************************************
// Search the hash table for the next entry with the specified key value.
//*****************************************************************************
USHORT CHashTable::FindNext(            // Index of struct in m_pcEntries.
    BYTE        *pcKey,                 // The key to match.
    USHORT      iIndex)                 // Index of previous match.
{
    USHORT      iNext;                  // Used to traverse the chains.
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    // Start at the next entry in the chain.
    iNext = EntryPtr(iIndex)->iNext;

    // Search until we hit the end.
    while (iNext != 0xffff)
    {
        // Compare the keys.
        psEntry = EntryPtr(iNext);
        if (!Cmp(pcKey, psEntry))
            return (iNext);

        // Advance to the next item in the chain.
        iNext = psEntry->iNext;
    }

    // We couldn't find it.
    return (0xffff);
}

//*****************************************************************************
// Returns the next entry in the list.
//*****************************************************************************
BYTE *CHashTable::FindNextEntry(        // The next entry, or0 for end of list.
    HASHFIND    *psSrch)                // Search object.
{
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    for (;;)
    {
        // See if we already have one to use and if so, use it.
        if (psSrch->iNext != 0xffff)
        {
            psEntry = EntryPtr(psSrch->iNext);
            psSrch->iNext = psEntry->iNext;
            return ((BYTE *) psEntry);
        }

        // Advance to the next bucket.
        if (psSrch->iBucket < m_iBuckets)
            psSrch->iNext = m_piBuckets[psSrch->iBucket++];
        else
            break;
    }

    // There were no more entries to be found.
    return (0);
}


// Return true if UTF7/8 is supported, false if it isn't.
inline int UTF78Support()
{
    static int g_bUTF78Support = -1;

    if (g_bUTF78Support == -1)
    {
        // detect if utf-7/8 is supported
        char    testmb[] = "A";
        WCHAR   testwide[] = L"A";
        g_bUTF78Support = MultiByteToWideChar(CP_UTF8,0,testmb,-1,testwide,2);
    }

    return (g_bUTF78Support);
}

// From UTF.C
extern "C" {
    int UTFToUnicode(
        UINT CodePage,
        DWORD dwFlags,
        LPCSTR lpMultiByteStr,
        int cchMultiByte,
        LPWSTR lpWideCharStr,
        int cchWideChar);

    int UnicodeToUTF(
        UINT CodePage,
        DWORD dwFlags,
        LPCWSTR lpWideCharStr,
        int cchWideChar,
        LPSTR lpMultiByteStr,
        int cchMultiByte,
        LPCSTR lpDefaultChar,
        LPBOOL lpUsedDefaultChar);
};

//*****************************************************************************
// Convert an Ansi or UTF string to Unicode.
//
// On NT, or for code pages other than {UTF7|UTF8}, calls through to the
//  system implementation.  On Win95 (or 98), performing UTF translation,
//  calls to some code that was lifted from the NT translation functions.
//*****************************************************************************
int WszMultiByteToWideChar( 
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar)
{
    if (UTF78Support() || (CodePage < CP_UTF7) || (CodePage > CP_UTF8))
    {
        return (MultiByteToWideChar(CodePage, 
            dwFlags, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpWideCharStr, 
            cchWideChar));
    }
    else
    {
        return (UTFToUnicode(CodePage, 
            dwFlags, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpWideCharStr, 
            cchWideChar));
    }
}

//*****************************************************************************
// Convert a Unicode string to Ansi or UTF.
//
// On NT, or for code pages other than {UTF7|UTF8}, calls through to the
//  system implementation.  On Win95 (or 98), performing UTF translation,
//  calls to some code that was lifted from the NT translation functions.
//*****************************************************************************
int WszWideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar)
{
    if (UTF78Support() || (CodePage < CP_UTF7) || (CodePage > CP_UTF8))
    {
        return (WideCharToMultiByte(CodePage, 
            dwFlags, 
            lpWideCharStr, 
            cchWideChar, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpDefaultChar, 
            lpUsedDefaultChar));
    }
    else
    {
        return (UnicodeToUTF(CodePage, 
            dwFlags, 
            lpWideCharStr, 
            cchWideChar, 
            lpMultiByteStr, 
            cchMultiByte, 
            lpDefaultChar, 
            lpUsedDefaultChar));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\inc\dbgipcevents.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * DbgIPCEvents.h -- header file for private Debugger data shared by various
 *                   debugger components.
 * @doc
 * ------------------------------------------------------------------------- */

#ifndef _DbgIPCEvents_h_
#define _DbgIPCEvents_h_

#include <cor.h>
#include <cordebug.h>
#include <corjit.h> // for ICorJitInfo::VarLocType & VarLoc

// We want this available for DbgInterface.h - put it here.
typedef enum
{
    IPC_TARGET_INPROC,
    IPC_TARGET_OUTOFPROC,
    IPC_TARGET_COUNT,
} IpcTarget;

// Get version numbers for IPCHeader stamp
#include "__file__.ver"

//
// Names of the setup sync event and shared memory used for IPC between the Left Side and the Right Side. NOTE: these
// names must include a %d for the process id. The process id used is the process id of the debuggee.
//
#define CorDBIPCSetupSyncEventName L"CorDBIPCSetupSyncEvent_%d"
#define CorDBIPCLSEventAvailName   L"CorDBIPCLSEventAvailName_%d"
#define CorDBIPCLSEventReadName    L"CorDBIPCLSEventReadName_%d"

// Note: this one is only temporary. We would have rather added this event into the DCB or into the RuntimeOffsets, but
// we can't without that being a breaking change at this point (Fri Jul 13 15:17:20 2001). So we're using a named event
// for now, and next time we change the struct we'll put it back in.
#define CorDBDebuggerAttachedEvent L"CorDBDebuggerAttachedEvent_%d"

//
// This define controls whether we always pass first chance exceptions to the in-process first chance hijack filter
// during interop debugging or if we try to short-circuit and make the decision out-of-process as much as possible.
//
#define CorDB_Short_Circuit_First_Chance_Ownership 1

//
// Defines for current version numbers for the left and right sides
//
#define CorDB_LeftSideProtocolCurrent           1
#define CorDB_LeftSideProtocolMinSupported      1
#define CorDB_RightSideProtocolCurrent          1
#define CorDB_RightSideProtocolMinSupported     1

//
// DebuggerIPCRuntimeOffsets contains addresses and offsets of important global variables, functions, and fields in
// Runtime objects. This is populated during Left Side initialization and is read by the Right Side. This struct is
// mostly to facilitate unmanaged debugging support, but it may have some small uses for managed debugging.
//
struct DebuggerIPCRuntimeOffsets
{
    void   *m_firstChanceHijackFilterAddr;
    void   *m_genericHijackFuncAddr;
    void   *m_secondChanceHijackFuncAddr;
    void   *m_excepForRuntimeBPAddr;
    void   *m_excepForRuntimeHandoffStartBPAddr;
    void   *m_excepForRuntimeHandoffCompleteBPAddr;
    void   *m_excepNotForRuntimeBPAddr;
    void   *m_notifyRSOfSyncCompleteBPAddr;
    void   *m_notifySecondChanceReadyForData;
    SIZE_T  m_TLSIndex;                                 // The TLS index the CLR is using to hold Thread objects
    SIZE_T  m_EEThreadStateOffset;                      // Offset of m_state in a Thread
    SIZE_T  m_EEThreadStateNCOffset;                    // Offset of m_stateNC in a Thread
    SIZE_T  m_EEThreadPGCDisabledOffset;                // Offset of the bit for whether PGC is disabled or not in a Thread
    DWORD   m_EEThreadPGCDisabledValue;                 // Value at m_EEThreadPGCDisabledOffset that equals "PGC disabled".
    SIZE_T  m_EEThreadDebuggerWord2Offset;              // Offset of debugger word 2 in a Thread
    SIZE_T  m_EEThreadFrameOffset;                      // Offset of the Frame ptr in a Thread
    SIZE_T  m_EEThreadMaxNeededSize;                    // Max memory to read to get what we need out of a Thread object
    DWORD   m_EEThreadSteppingStateMask;                // Mask for Thread::TSNC_DebuggerIsStepping
    DWORD   m_EEMaxFrameValue;                          // The max Frame value
    SIZE_T  m_EEThreadDebuggerWord1Offset;              // Offset of debugger word 1 in a Thread
    SIZE_T  m_EEThreadCantStopOffset;                   // Offset of the can't stop count in a Thread
    SIZE_T  m_EEFrameNextOffset;                        // Offset of the next ptr in a Frame
    DWORD   m_EEBuiltInExceptionCode1;                  // Exception code that the EE can generate
    DWORD   m_EEBuiltInExceptionCode2;                  // Exception code that the EE can generate
    DWORD   m_EEIsManagedExceptionStateMask;            // Mask for Thread::TSNC_DebuggerIsManagedException
    void   *m_pPatches;                                 // Addr of patch table
    BOOL   *m_pPatchTableValid;                         // Addr of g_patchTableValid
    SIZE_T  m_offRgData;                                // Offset of m_pcEntries
    SIZE_T  m_offCData;                                 // Offset of count of m_pcEntries
    SIZE_T  m_cbPatch;                                  // Size per patch entry
    SIZE_T  m_offAddr;                                  // Offset within patch of target addr
    SIZE_T  m_offOpcode;                                // Offset within patch of target opcode
    SIZE_T  m_cbOpcode;                                 // Max size of opcode
    SIZE_T  m_offTraceType;                             // Offset of the trace.type within a patch
    DWORD   m_traceTypeUnmanaged;                       // TRACE_UNMANAGED
};

//
// The size of the send and receive IPC buffers.
//
#define CorDBIPC_BUFFER_SIZE 2018 // 2018 * 2 + 60 = 4096...

//
// DebuggerIPCControlBlock describes the layout of the shared memory shared between the Left Side and the Right
// Side. This includes error information, handles for the IPC channel, and space for the send/receive buffers.
//
struct DebuggerIPCControlBlock
{
    // Version data should be first in the control block to ensure that we can read it even if the control block
    // changes.
    SIZE_T                     m_DCBSize;
    ULONG                      m_verMajor;          // CLR build number for the Left Side.
    ULONG                      m_verMinor;          // CLR build number for the Left Side.
    bool                       m_checkedBuild;      // CLR build type for the Left Side.

    ULONG                      m_leftSideProtocolCurrent;       // Current protocol version for the Left Side.
    ULONG                      m_leftSideProtocolMinSupported;  // Minimum protocol the Left Side can support.

    ULONG                      m_rightSideProtocolCurrent;      // Current protocol version for the Right Side.
    ULONG                      m_rightSideProtocolMinSupported; // Minimum protocol the Right Side requires.

    HRESULT                    m_errorHR;
    unsigned int               m_errorCode;
    HANDLE                     m_rightSideEventAvailable;
    HANDLE                     m_rightSideEventRead;
    HANDLE                     m_leftSideEventAvailable;
    HANDLE                     m_leftSideEventRead;
    HANDLE                     m_rightSideProcessHandle;
    HANDLE                     m_leftSideUnmanagedWaitEvent;
    HANDLE                     m_syncThreadIsLockFree;
    bool                       m_rightSideIsWin32Debugger;
    DWORD                      m_helperThreadId;
    DWORD                      m_temporaryHelperThreadId;
    DebuggerIPCRuntimeOffsets *m_runtimeOffsets;
    void                      *m_helperThreadStartAddr;
    BYTE                       m_receiveBuffer[CorDBIPC_BUFFER_SIZE];
    BYTE                       m_sendBuffer[CorDBIPC_BUFFER_SIZE];

    bool                       m_specialThreadListDirty;
    DWORD                      m_specialThreadListLength;
    DWORD                     *m_specialThreadList;

    bool                       m_shutdownBegun;

    // NOTE The Init method works since there are no virtual functions - don't add any virtual functions without
    // changing this!
    void Init(HANDLE rsea, HANDLE rser, HANDLE lsea, HANDLE lser,
              HANDLE lsuwe, HANDLE stilf)
    {
        // NOTE this works since there are no virtual functions - don't add any without changing this!
        memset( this, 0, sizeof( DebuggerIPCControlBlock) );

        m_DCBSize = sizeof(DebuggerIPCControlBlock);
        
        // Setup version checking info.
        m_verMajor = COR_OFFICIAL_BUILD_NUMBER;
        m_verMinor = COR_PRIVATE_BUILD_NUMBER;

#ifdef _DEBUG
        m_checkedBuild = true;
#else
        m_checkedBuild = false;
#endif
    
        // Copy RSEA and RSER into the control block.
        m_rightSideEventAvailable = rsea;
        m_rightSideEventRead = rser;
        m_leftSideUnmanagedWaitEvent = lsuwe;
        m_syncThreadIsLockFree = stilf;

        // Mark the debugger special thread list as not dirty, empty and null.
        m_specialThreadListDirty = false;
        m_specialThreadListLength = 0;
        m_specialThreadList = NULL;

        m_shutdownBegun = false;
    }
};


#define INITIAL_APP_DOMAIN_INFO_LIST_SIZE	16

// Forward declaration
class AppDomain;

// AppDomainInfo contains information about an AppDomain
// All pointers are for the left side, and we do not own any of the memory
struct AppDomainInfo
{
	ULONG		m_id;	// unique identifier
	int			m_iNameLengthInBytes;
	LPCWSTR		m_szAppDomainName;
    AppDomain  *m_pAppDomain;

    // NOTE: These functions are just helpers and must not add a VTable
    // to this struct (since we need to read this out-of-proc)
    
    // Provide a clean definition of an empty entry
    inline bool IsEmpty() const 
    { 
        return m_szAppDomainName == NULL;
    }

    // Mark this entry as empty.
    inline void FreeEntry() 
    {
        m_szAppDomainName = NULL;
    }

    // Set the string name and length.    
    // If szName is null, it is adjusted to a global constant.
    // This also causes the entry to be considered valid
    inline void SetName(LPCWSTR szName)
    {
        if (szName != NULL)
            m_szAppDomainName = szName;
        else
            m_szAppDomainName = L"<NoName>";

        m_iNameLengthInBytes = (int) (wcslen(m_szAppDomainName) + 1) * sizeof(WCHAR);
    }
};


// AppDomain publishing server support:
// Information about all appdomains in the process will be maintained
// in the shared memory block for use by the debugger, etc.
// This structure defines the layout of the information that will 
// be maintained.
struct AppDomainEnumerationIPCBlock
{
	// lock for serialization while manipulating AppDomain list
	HANDLE				m_hMutex;  

	// Number of slots in AppDomainListElement array
	int					m_iTotalSlots;
	int					m_iNumOfUsedSlots;
	int					m_iLastFreedSlot;
	int					m_iSizeInBytes; // Size of AppDomainInfo in bytes
	int					m_iProcessNameLengthInBytes;
	WCHAR				*m_szProcessName;
	AppDomainInfo		*m_rgListOfAppDomains;
    BOOL                m_fLockInvalid;

    /*************************************************************************
     * Locks the list
     *************************************************************************/
    BOOL Lock()
    {
        DWORD dwRes = WaitForSingleObject(m_hMutex, INFINITE);
        _ASSERTE(dwRes == WAIT_OBJECT_0 &&
                 "ADEIPCB::Lock: failed to take debugger's AppDomain lock\r\n"
                 "If you can get this assert consistently, please file a bug with\r\n"
                 "a **very** detailed repro (dumps, logfiles for left & right sides, etc) \r\n"
                 "Else, YOU CAN SAFELY IGNORE THIS ASSERT"
        );

        // The only time this can happen is if we're in shutdown and a thread
        // that held this lock is killed.  If this happens, assume that this
        // IPC block is in a screwed up state and return FALSE to indicate
        // that people shouldn't do anything with the block anymore.
        if (dwRes == WAIT_ABANDONED)
            m_fLockInvalid = TRUE;

        if (m_fLockInvalid)
            Unlock();

        return (dwRes == WAIT_OBJECT_0 && !m_fLockInvalid);
    }

    /*************************************************************************
     * Unlocks the list
     *************************************************************************/
    void Unlock()
    {
        ReleaseMutex(m_hMutex);
    }

    /*************************************************************************
     * Gets a free AppDomainInfo entry, and will allocate room if there are
     * no free slots left.
     *************************************************************************/
    AppDomainInfo *GetFreeEntry()
    {
        // first check to see if there is space available. If not, then realloc.
        if (m_iNumOfUsedSlots == m_iTotalSlots)
        {
            // need to realloc
            AppDomainInfo *pTemp =
                (AppDomainInfo *) realloc(m_rgListOfAppDomains, m_iSizeInBytes*2);

            if (pTemp == NULL)
            {
                return (NULL);
            }

            // Initialize the increased portion of the realloced memory
            int iNewSlotSize = m_iTotalSlots * 2;

            for (int iIndex = m_iTotalSlots; iIndex < iNewSlotSize; iIndex++)
                pTemp[iIndex].FreeEntry();

            m_rgListOfAppDomains = pTemp;
            m_iTotalSlots = iNewSlotSize;
            m_iSizeInBytes *= 2;
        }

        // Walk the list looking for an empty slot. Start from the last
        // one which was freed.
        {
            int i = m_iLastFreedSlot;

            do 
            {
                // Pointer to the entry being examined
                AppDomainInfo *pADInfo = &(m_rgListOfAppDomains[i]);

                // is the slot available?
                if (pADInfo->IsEmpty())
                    return (pADInfo);

                i = (i + 1) % m_iTotalSlots;

            } while (i != m_iLastFreedSlot);
        }

        _ASSERTE(!"ADInfo::GetFreeEntry: should never get here.");
        return (NULL);
    }

    /*************************************************************************
     * Returns an AppDomainInfo slot to the free list.
     *************************************************************************/
    void FreeEntry(AppDomainInfo *pADInfo)
    {
        _ASSERTE(pADInfo >= m_rgListOfAppDomains &&
                 pADInfo < m_rgListOfAppDomains + m_iSizeInBytes);
        _ASSERTE(((size_t)pADInfo - (size_t)m_rgListOfAppDomains) %
            sizeof(AppDomainInfo) == 0);

        // Mark this slot as free
        pADInfo->FreeEntry();

#ifdef _DEBUG
        memset(pADInfo, 0, sizeof(AppDomainInfo));
#endif

        // decrement the used slot count
        m_iNumOfUsedSlots--;

        // Save the last freed slot.
        m_iLastFreedSlot = (int)((size_t)pADInfo - (size_t)m_rgListOfAppDomains) /
            sizeof(AppDomainInfo);
    }

    /*************************************************************************
     * Finds an AppDomainInfo entry corresponding to the AppDomain pointer.
     * Returns NULL if no such entry exists.
     *************************************************************************/
    AppDomainInfo *FindEntry(AppDomain *pAD)
    {
        // Walk the list looking for a matching entry
        for (int i = 0; i < m_iTotalSlots; i++)
        {
            AppDomainInfo *pADInfo = &(m_rgListOfAppDomains[i]);

            if (!pADInfo->IsEmpty() &&
                pADInfo->m_pAppDomain == pAD)
                return pADInfo;
        }

        return (NULL);
    }

    /*************************************************************************
     * Returns the first AppDomainInfo entry in the list.  Returns NULL if
     * no such entry exists.
     *************************************************************************/
    AppDomainInfo *FindFirst()
    {
        // Walk the list looking for a non-empty entry
        for (int i = 0; i < m_iTotalSlots; i++)
        {
            AppDomainInfo *pADInfo = &(m_rgListOfAppDomains[i]);

            if (!pADInfo->IsEmpty())
                return pADInfo;
        }

        return (NULL);
    }

    /*************************************************************************
     * Returns the next AppDomainInfo entry after pADInfo.  Returns NULL if
     * pADInfo was the last in the list.
     *************************************************************************/
    AppDomainInfo *FindNext(AppDomainInfo *pADInfo)
    {
        _ASSERTE(pADInfo >= m_rgListOfAppDomains &&
                 pADInfo < m_rgListOfAppDomains + m_iSizeInBytes);
        _ASSERTE(((size_t)pADInfo - (size_t)m_rgListOfAppDomains) %
            sizeof(AppDomainInfo) == 0);

        // Walk the list looking for the next non-empty entry
        for (int i = (int)((size_t)pADInfo - (size_t)m_rgListOfAppDomains)
                                                / sizeof(AppDomainInfo) + 1;
             i < m_iTotalSlots;
             i++)
        {
            AppDomainInfo *pADInfo = &(m_rgListOfAppDomains[i]);

            if (!pADInfo->IsEmpty())
                return pADInfo;
        }

        return (NULL);
    }

};


//
// Types of events that can be sent between the Runtime Controller and
// the Debugger Interface. Some of these events are one way only, while
// others go both ways. The grouping of the event numbers is an attempt
// to show this distinction and perhaps even allow generic operations
// based on the type of the event.
//
enum DebuggerIPCEventType
{
#define IPC_EVENT_TYPE0(type, val)  type = val,
#define IPC_EVENT_TYPE1(type, val)  type = val,
#define IPC_EVENT_TYPE2(type, val)  type = val,
#include "DbgIPCEventTypes.h"
#undef IPC_EVENT_TYPE2
#undef IPC_EVENT_TYPE1
#undef IPC_EVENT_TYPE0
};

#ifdef _DEBUG

struct IPCENames // We use a class/struct so that the function can remain in a shared header file
{
    static const char * GetName(DebuggerIPCEventType eventType)
    {
        static const struct
        {
            DebuggerIPCEventType    eventType;
            const char *            eventName;
        }
        DbgIPCEventTypeNames[] = 
        {
            #define IPC_EVENT_TYPE0(type, val)  { type, #type },
            #define IPC_EVENT_TYPE1(type, val)  { type, #type },
            #define IPC_EVENT_TYPE2(type, val)  { type, #type },
            #include "DbgIPCEventTypes.h"
            #undef IPC_EVENT_TYPE2
            #undef IPC_EVENT_TYPE1
            #undef IPC_EVENT_TYPE0
            { DB_IPCE_INVALID_EVENT, "DB_IPCE_Error" }
        };

        const nameCount = sizeof(DbgIPCEventTypeNames) / sizeof(DbgIPCEventTypeNames[0]);

        enum DbgIPCEventTypeNum
        {
        #define IPC_EVENT_TYPE0(type, val)  type##_Num,
        #define IPC_EVENT_TYPE1(type, val)  type##_Num,
        #define IPC_EVENT_TYPE2(type, val)  type##_Num,
        #include "DbgIPCEventTypes.h"
        #undef IPC_EVENT_TYPE2
        #undef IPC_EVENT_TYPE1
        #undef IPC_EVENT_TYPE0
        };

        unsigned int i, lim;
        
        if (eventType < DB_IPCE_DEBUGGER_FIRST)
        {
            i = DB_IPCE_RUNTIME_FIRST_Num + 1;
            lim = DB_IPCE_DEBUGGER_FIRST_Num;
        }
        else
        {
            i = DB_IPCE_DEBUGGER_FIRST_Num + 1;
            lim = nameCount;
        }

        for (/**/; i < lim; i++)
        {
            if (DbgIPCEventTypeNames[i].eventType == eventType)
                return DbgIPCEventTypeNames[i].eventName;
        }

        return DbgIPCEventTypeNames[nameCount - 1].eventName;
    }
};

#endif // _DEBUG

//
// NOTE: CPU-specific values below!
//
// DebuggerREGDISPLAY is very similar to the EE REGDISPLAY structure. It holds
// register values that can be saved over calls for each frame in a stack
// trace.
//
// DebuggerIPCE_FloatCount is the number of doubles in the processor's
// floating point stack.
//
// Note: We used to just pass the values of the registers for each frame to the Right Side, but I had to add in the
// address of each register, too, to support using enregistered variables on non-leaf frames as args to a func eval. Its
// very, very possible that we would rework the entire code base to just use the register's address instead of passing
// both, but its way, way too late in V1 to undertake that, so I'm just using these addresses to suppport our one func
// eval case. Clearly, this needs to be cleaned up post V1.
//
// -- Fri Feb 09 11:21:24 2001
//
#ifdef _X86_
struct DebuggerREGDISPLAY
{
    SIZE_T  Edi;
    void   *pEdi;
    SIZE_T  Esi;
    void   *pEsi;
    SIZE_T  Ebx;
    void   *pEbx;
    SIZE_T  Edx;
    void   *pEdx;
    SIZE_T  Ecx;
    void   *pEcx;
    SIZE_T  Eax;
    void   *pEax;
    SIZE_T  Ebp;
    void   *pEbp;
    SIZE_T  Esp;
    SIZE_T  PC;
};

#define DebuggerIPCE_FloatCount 8

#else
struct DebuggerREGDISPLAY
{
    DWORD PC;
};

#define DebuggerIPCE_FloatCount 1

#endif

// @struct DebuggerIPCE_FuncData | DebuggerIPCE_FunctionData holds data
// to describe a given function, its
// class, and a little bit about the code for the function. This is used
// in the stack trace result data to pass function information back that
// may be needed. Its also used when getting data about a specific function.
//
// @field void*|nativeStartAddressPtr|Ptr to CORDB_ADDRESS, which is 
//          the address of the real start address of the native code.  
//          This field will be NULL only if the method hasn't been JITted
//          yet (and thus no code is available).  Otherwise, it will be
//          the adress of a CORDB_ADDRESS in the remote memory.  This
//          CORDB_ADDRESS may be NULL, in which case the code is unavailable 
//          has been pitched (return CORDBG_E_CODE_NOT_AVAILABLE)
//
// @field SIZE_T|nativeSize|Size of the native code.  
//
// @field SIZE_T|nativeOffset|Offset from the beginning of the function,
//          in bytes.  This may be non-zero even when nativeStartAddressPtr
//          is NULL
// @field SIZE_T|nVersion|The version of the code that this instance of the
//          function is using.
// @field void *|CodeVersionToken|An opaque value to hand back to the left
//          side when refering to this.  It's actually a pointer in left side
//          memory to the DebuggerJitInfo struct.
struct DebuggerIPCE_FuncData
{
    mdMethodDef funcMetadataToken;
    SIZE_T      funcRVA;
    void*       funcDebuggerModuleToken;
	void*		funcDebuggerAssemblyToken;

    mdTypeDef   classMetadataToken;

    void*       ilStartAddress;
    SIZE_T      ilSize;
    SIZE_T      ilnVersion;
    
    void*       nativeStartAddressPtr; 
    SIZE_T      nativeSize;
    SIZE_T      nativeOffset;
    SIZE_T      nativenVersion;
    
    SIZE_T      nVersionMostRecentEnC;
    void	   *CodeVersionToken;

    mdSignature  localVarSigToken;

    bool        fVarArgs;
    void       *rpSig;
    SIZE_T      cbSig;
    void       *rpFirstArg;

    void*       ilToNativeMapAddr;
    SIZE_T      ilToNativeMapSize;
};


//
// DebuggerIPCE_STRData holds data for each stack frame or chain. This data is passed
// from the RC to the DI during a stack walk.
//
struct DebuggerIPCE_STRData
{
    void                   *fp;
    DebuggerREGDISPLAY      rd;
    bool                    quicklyUnwound;
    void                   *currentAppDomainToken;

    bool                    isChain;

    union
    {
        struct
        {   
            CorDebugChainReason chainReason;   
            bool                managed;
            void               *context;
        };
        struct
        {
            struct DebuggerIPCE_FuncData funcData;
            void                        *ILIP;
            CorDebugMappingResult        mapping;                
        };
    };
};

//
// DebuggerIPCE_FieldData holds data for each field within a class. This data
// is passed from the RC to the DI in response to a request for class info.
// This struct is also used by CordbClass to hold the list of fields for the
// class.
//
struct DebuggerIPCE_FieldData
{
    mdFieldDef      fldMetadataToken;
    CorElementType  fldType;          // If set to ELEMENT_TYPE_MAX, then EnC'd
                                      // field isn't available, yet.
    PCCOR_SIGNATURE fldFullSig;
    ULONG           fldFullSigSize;
    SIZE_T          fldOffset;
    void           *fldDebuggerToken;
    bool            fldIsTLS;
    bool            fldIsContextStatic;
    bool            fldIsRVA;
    bool            fldIsStatic;
    bool            fldIsPrimitive;   // Only true if this is a value type masquerading as a primitive.
};

//
// DebuggerIPCE_ObjectData holds the results of a
// GetAndSendObjectInfo, i.e., all the info about an object that the
// Right Side would need to access it. (This include array, string,
// and nstruct info.)
//
struct DebuggerIPCE_ObjectData
{
    void           *objRef;
    bool            objRefBad;
    SIZE_T          objSize;
    SIZE_T          objOffsetToVars;
    CorElementType  objectType;
    void           *objToken;

    // These will be the class of array elements, if any, for arrays.
    mdTypeDef       objClassMetadataToken;
    void           *objClassDebuggerModuleToken;
    
    union
    {
        struct
        {
            SIZE_T          length;
            SIZE_T          offsetToStringBase;
        } stringInfo;
                
        struct
        {
            SIZE_T          size;
            void           *ptr;
        } nstructInfo;
                
        struct
        {
            SIZE_T          offsetToArrayBase;
            SIZE_T          offsetToLowerBounds; // 0 if not present
            SIZE_T          offsetToUpperBounds; // 0 if not present
            DWORD           componentCount;
            DWORD           rank;
            SIZE_T          elementSize;
            CorElementType  elementType;
        } arrayInfo;
    };
};

//
// Remote enregistered info used by CordbValues and for passing
// variable homes between the left and right sides during a func eval.
//

enum RemoteAddressKind
{
    RAK_NONE = 0,
    RAK_REG,
    RAK_REGREG,
    RAK_REGMEM,
    RAK_MEMREG,
    RAK_FLOAT
};

struct RemoteAddress
{
    RemoteAddressKind    kind;
    void                *frame;

    CorDebugRegister     reg1;
    void                *reg1Addr;

    union
    {
        struct
        {
            CorDebugRegister  reg2;
            void             *reg2Addr;
        };
            
        CORDB_ADDRESS    addr;
        DWORD            floatIndex;
    };
};

//
// DebuggerIPCE_FuncEvalType specifies the type of a function
// evaluation that will occur.
//
enum DebuggerIPCE_FuncEvalType
{
    DB_IPCE_FET_NORMAL,
    DB_IPCE_FET_NEW_OBJECT,
    DB_IPCE_FET_NEW_OBJECT_NC,
    DB_IPCE_FET_NEW_STRING,
    DB_IPCE_FET_NEW_ARRAY,
    DB_IPCE_FET_RE_ABORT
};


enum NameChangeType
{
	APP_DOMAIN_NAME_CHANGE,
	THREAD_NAME_CHANGE
};

//
// DebuggerIPCE_FuncEvalArgData holds data for each argument to a
// function evaluation.
//
struct DebuggerIPCE_FuncEvalArgData
{
    RemoteAddress     argHome;  // enregistered variable home
    void             *argAddr;  // address if not enregistered
    CorElementType    argType;  // basic type of the argument
    bool              argRefsInHandles; // true if the ref could be a handle
    bool              argIsLiteral; // true if value is in argLiteralData
    union
    {
        BYTE          argLiteralData[8]; // copy of generic value data
        struct
        {
            mdTypeDef classMetadataToken;
            void     *classDebuggerModuleToken;
        } GetClassInfo;
    };
};

//
// DebuggerIPCE_FuncEvalInfo holds info necessary to setup a func eval
// operation.
//
struct DebuggerIPCE_FuncEvalInfo
{
    void                      *funcDebuggerThreadToken;
    DebuggerIPCE_FuncEvalType  funcEvalType;
    mdMethodDef                funcMetadataToken;
    mdTypeDef                  funcClassMetadataToken;
    void                      *funcDebuggerModuleToken;
    void                      *funcEvalKey;
    bool                       evalDuringException;

    // @todo: union these...
    SIZE_T                     argCount;
    
    SIZE_T                     stringSize;
    
    SIZE_T                     arrayRank;
    mdTypeDef                  arrayClassMetadataToken;
    void                      *arrayClassDebuggerModuleToken;
    CorElementType             arrayElementType;
    SIZE_T                     arrayDataLen;
};

//
// DebuggerIPCFirstChanceData holds info communicated from the LS to the RS when signaling that an exception does not
// belong to the runtime from a first chance hijack. This is used when Win32 debugging only.
//
struct DebuggerIPCFirstChanceData
{
    CONTEXT          *pLeftSideContext;
    void             *pOriginalHandler;
};

//
// DebuggerIPCSecondChanceData holds info communicated from the RS
// to the LS when setting up a second chance exception hijack. This is
// used when Win32 debugging only.
//
struct DebuggerIPCSecondChanceData
{
    CONTEXT          threadContext;
};

//
// Event structure that is passed between the Runtime Controller and the
// Debugger Interface. Some types of events are a fixed size and have
// entries in the main union, while others are variable length and have
// more specialized data structures that are attached to the end of this
// structure.
//
struct DebuggerIPCEvent
{
    DebuggerIPCEvent*       next;
    DebuggerIPCEventType    type;
    DWORD             processId;
    void*             appDomainToken;
    DWORD             threadId;
    HRESULT           hr;
    bool              replyRequired;
    bool              asyncSend;

    union
    {
        struct
        {
			BOOL fAttachToAllAppDomains;
			ULONG id;
		} DebuggerAttachData;

        struct
        {
			ULONG id;
			WCHAR rcName [1];
        } AppDomainData;

        struct
        {
            void* debuggerAssemblyToken;
			BOOL  fIsSystemAssembly;
			WCHAR rcName [1];
        } AssemblyData;

        struct
        {
            void*   debuggerThreadToken;
            HANDLE  threadHandle;
            void*   firstExceptionHandler; //points to the beginning of hte SEH chain
            void*   stackBase;
            void*   stackLimit;
        } ThreadAttachData;

	    struct
        {
            void* debuggerThreadToken;
        } StackTraceData;

        struct
        {
            unsigned int          totalFrameCount;
            unsigned int          totalChainCount;
            unsigned int          traceCount; // For this event only,
                                              // frames + chains
            CorDebugUserState     threadUserState;
            CONTEXT               *pContext;  // NULL if thread was stopped,
                                              // nonNULL if thread is in an exception
                                              // (in which case, it's the address 
                                              // of the memory to get the 
                                              // right CONTEXT from)
            DebuggerIPCE_STRData  traceData;
        } StackTraceResultData;

        struct
        {
            void* debuggerModuleToken;
			void* debuggerAssemblyToken;
            void* pMetadataStart;
            ULONG nMetadataSize;
            void* pPEBaseAddress;
            ULONG nPESize;
            BOOL  fIsDynamic;
            BOOL  fInMemory;
            WCHAR rcName[1];
        } LoadModuleData;

        struct
        {
            void* debuggerModuleToken;
			void* debuggerAssemblyToken;
        } UnloadModuleData;

        struct
        {
            void  *debuggerModuleToken;
			void  *debuggerAppDomainToken;
            BYTE  *pbSyms;
            DWORD  cbSyms;
            bool   needToFreeMemory;
        } UpdateModuleSymsData;

        struct
        {
            mdMethodDef funcMetadataToken;
            DWORD       funcRVA; // future...
            DWORD       implFlags; // future...
            void*       funcDebuggerModuleToken;
            SIZE_T      nVersion;
        } GetFunctionData;

        struct DebuggerIPCE_FuncData FunctionDataResult;

        struct
        {
            void        *breakpoint;
            void        *breakpointToken;
            mdMethodDef  funcMetadataToken;
            void        *funcDebuggerModuleToken;
            bool         isIL;
            SIZE_T       offset;
        } BreakpointData;

        struct
        {
            void        *breakpointToken;
        } BreakpointSetErrorData;

        struct 
        {
            void                *stepper;
            void                *stepperToken;
            void                *threadToken;
            void                *frameToken;
            bool                 stepIn;
            bool                rangeIL;
            unsigned int         totalRangeCount;
            CorDebugStepReason   reason;
            CorDebugUnmappedStop rgfMappingStop;
            CorDebugIntercept    rgfInterceptStop;
            unsigned int         rangeCount;
            COR_DEBUG_STEP_RANGE range; //note that this is an array
        } StepData;

        struct
        {
            void           *objectRefAddress;
            bool            objectRefInHandle;
            bool            objectRefIsValue;
            bool            makeStrongObjectHandle;
            CorElementType  objectType;
        } GetObjectInfo;

        struct DebuggerIPCE_ObjectData GetObjectInfoResult;

        struct
        {
            mdTypeDef  classMetadataToken;
            void      *classDebuggerModuleToken;
        } GetClassInfo;

        struct
        {
            bool                   isValueClass;
            SIZE_T                 objectSize;
            void                  *staticVarBase;
            unsigned int           instanceVarCount;
            unsigned int           staticVarCount;
            unsigned int           fieldCount; // for this event only
            DebuggerIPCE_FieldData fieldData;
        } GetClassInfoResult;

        struct 
        {
            mdMethodDef funcMetadataToken;
            void*       funcDebuggerModuleToken;
            bool        il;
            SIZE_T      start, end;
            BYTE        code;
            void*       CodeVersionToken;
        } GetCodeData;

        struct
        {
            ULONG      bufSize;
        } GetBuffer;

        struct 
        {
            void        *pBuffer;
            HRESULT     hr;
        } GetBufferResult;

        struct
        {
            void        *pBuffer;
        } ReleaseBuffer;

        struct
        {
            HRESULT     hr;
        } ReleaseBufferResult;

        struct
        {
            BOOL        checkOnly;
            void        *pData;
        } Commit;

        struct
        {
            HRESULT     hr;
            const BYTE *pErrorArr; 	// This is actually a remote pointer to an
            	// UnorderedEnCErrorInfoArray in the left side.
            	// Note that we'll have to read the pTable out of memory as well.
            ULONG32		cbErrorData;
        } CommitResult;

        struct
        {
            mdMethodDef funcMetadataToken;
            void*       funcDebuggerModuleToken;
        } GetJITInfo;

        struct
        {
            unsigned int            argumentCount;
            unsigned int            totalNativeInfos;
            SIZE_T                  nVersion; // of the function which has been jitted.
            unsigned int            nativeInfoCount; // for this event only
            ICorJitInfo::NativeVarInfo nativeInfo;
        } GetJITInfoResult;

        struct
        {
            void* debuggerThreadToken;
        } GetFloatState;

        struct
        {
            bool         floatStateValid;
            unsigned int floatStackTop;
            double       floatValues[DebuggerIPCE_FloatCount];
        } GetFloatStateResult;

        struct
        {
            mdTypeDef   classMetadataToken;
            void       *classDebuggerModuleToken;
            void       *classDebuggerAssemblyToken;
            BYTE       *pNewMetaData; // This is only valid if the class 
                // is on a dynamic module, and therefore the metadata needs to
                // be refreshed.
            DWORD       cbNewMetaData;
        } LoadClass;

        struct
        {
            mdTypeDef   classMetadataToken;
            void       *classDebuggerModuleToken;
            void       *classDebuggerAssemblyToken;
        } UnloadClass;

        struct
        {
            void* debuggerModuleToken;
            bool  flag;
        } SetClassLoad;

        struct
        {
            void        *exceptionHandle;
            bool        firstChance;
            bool        continuable;
        } Exception;

        struct
        {
            void*       debuggerThreadToken;
        } ClearException;

        struct 
        {
            void        *debuggerModuleToken;
        } GetDataRVA;

        struct 
        {
            SIZE_T      dataRVA;
            HRESULT     hr;
        } GetDataRVAResult;

        struct
        {
            void        *address;
        } IsTransitionStub;

        struct
        {
            bool        isStub;
        } IsTransitionStubResult;

        struct 
        {
            bool        fCanSetIPOnly;
            void        *debuggerThreadToken;
            void        *debuggerModule;
            mdMethodDef mdMethod;
            void        *versionToken;
            SIZE_T      offset;
            bool        fIsIL;
            void        *firstExceptionHandler;
        } SetIP; // this is also used for CanSetIP

        struct
        {
			bool fMoreToFollow;
			int iLevel;
			int iCategoryLength;
			int iMessageLength;
			WCHAR Dummy [1];
		} FirstLogMessage;

		struct 
		{
			bool fMoreToFollow;
			int iMessageLength;
			WCHAR Dummy [1];
		} ContinuedLogMessage;

		struct 
		{
			int iLevel;
			int iReason;
			WCHAR Dummy[1];
		} LogSwitchSettingMessage;

        struct
        {
            void                *debuggerThreadToken;
            CorDebugThreadState debugState; 
        } SetDebugState;

        struct
        {
            void                *debuggerExceptThreadToken;
            CorDebugThreadState debugState; 
        } SetAllDebugState;

        DebuggerIPCE_FuncEvalInfo FuncEval;
        
        struct
        {
            BYTE           *argDataArea;
            void           *debuggerEvalKey;
        } FuncEvalSetupComplete;

        struct
        {
            void           *funcEvalKey;
            bool            successful;
            bool            aborted;
            void           *resultAddr;
            CorElementType  resultType;
            void           *resultDebuggerModuleToken;
        } FuncEvalComplete;

        struct
        {
            void           *debuggerEvalKey;
        } FuncEvalAbort;
        
        struct
        {
            void           *debuggerEvalKey;
        } FuncEvalCleanup;
        
        struct 
        {
            void            *objectToken; 
            CorElementType  objectType;
        } ValidateObject;

        struct 
        {
            void            *objectToken; 
            bool             fStrong;
        } DiscardObject;
        
        struct
        {
            void           *objectRefAddress;
            bool            objectRefInHandle;
            void           *newReference;
        } SetReference;

		struct 
		{
			ULONG			id;			
		} GetAppDomainName;

		struct 
		{
			WCHAR rcName [1];
		} AppDomainNameResult;

		struct 
		{
			NameChangeType	eventType;
			void			*debuggerAppDomainToken;
			DWORD			debuggerThreadToken;
		} NameChange;

        struct
        {
			void			*debuggerObjectToken;
			void			*managedObject;
		} ObjectRef;

        struct
        {
            void            *debuggerModuleToken;
            BOOL             fTrackInfo;
            BOOL             fAllowJitOpts;
        } JitDebugInfo;

        struct
        {
            void            *fldDebuggerToken;
            void            *debuggerThreadToken;
        } GetSpecialStatic;

        struct
        {
            void            *fldAddress;
        } GetSpecialStaticResult;

        struct
        {
            BOOL            fAccurate;
            void            *debuggerModuleToken; //LS pointer to DebuggerModule
            // Carry along enough info to instantiate, if we have to.
            mdMethodDef     funcMetadataToken ;
            mdToken         localSigToken;
            ULONG           RVA;
        } EnCRemap;

        struct
        {
            void            *debuggerModuleToken;
            mdTypeDef        classMetadataToken;
            void            *pObject;
            CorElementType   objectType;
            SIZE_T           offsetToVars;
            mdFieldDef       fldToken;
            void            *staticVarBase;
        } GetSyncBlockField;

        struct 
        {
            // If it's static, then we don't have to refresh
            // it later since the object/int/etc will be right
            // there.
            BOOL                   fStatic; 
            DebuggerIPCE_FieldData fieldData;
        } GetSyncBlockFieldResult;

        struct
        {
            void      *oldData;
            void      *newData;
            mdTypeDef  classMetadataToken;
            void      *classDebuggerModuleToken;
        } SetValueClass;
    };
};


// 2*sizeof(WCHAR) for the two string terminating characters in the FirstLogMessage
#define LOG_MSG_PADDING			4

// *** WARNING *** WARNING *** WARNING ***
// FIRST_VALID_VERSION_NUMBER MUST be equal to 
// DebuggerJitInfo::DJI_VERSION_FIRST_VALID (in ee\debugger.h)

#define FIRST_VALID_VERSION_NUMBER  3
#define USER_VISIBLE_FIRST_VALID_VERSION_NUMBER 1

// The formula for the correct, user visible value is
// We should use the internal version _everywhere_ internally (left & right side),
// and convert this number to an external number only immediately before
// handing out to a client of our interface.
#define INTERNAL_TO_EXTERNAL_VERSION( x )  (x -  FIRST_VALID_VERSION_NUMBER + \
                         USER_VISIBLE_FIRST_VALID_VERSION_NUMBER)
// *** WARNING *** WARNING *** WARNING ***


// This is used to pass the IL maps over from the right side to the
// left, into the EnC left side buffer.
typedef struct 
{
    mdMethodDef mdMethod;
    ULONG       cMap;
    COR_IL_MAP  *pMap; // actually cMap entries.
} UnorderedILMap;

#endif /* _DbgIPCEvents_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\debuggerutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __DEBUGGERUTIL_H__
#define __DEBUGGERUTIL_H__

#include "stdlib.h"

static inline void * __cdecl operator new(size_t n) { return LocalAlloc(LMEM_FIXED, n); }
static inline void * __cdecl operator new[](size_t n) { return LocalAlloc(LMEM_FIXED, n); };
static inline void __cdecl operator delete(void *p) { LocalFree(p); }
static inline void __cdecl operator delete[](void *p) { LocalFree(p); }

/* ------------------------------------------------------------------------- *
 * Utility methods used by the debugger sample.
 * ------------------------------------------------------------------------- */

#define     CQUICKBYTES_BASE_SIZE           512
#define     CQUICKBYTES_INCREMENTAL_SIZE    128

//*****************************************************************************
//
// **** CQuickBytes
// This helper class is useful for cases where 90% of the time you allocate 512
// or less bytes for a data structure.  This class contains a 512 byte buffer.
// Alloc() will return a pointer to this buffer if your allocation is small
// enough, otherwise it asks the heap for a larger buffer which is freed for
// you.  No mutex locking is required for the small allocation case, making the
// code run faster, less heap fragmentation, etc...  Each instance will allocate
// 520 bytes, so use accordinly.
//
//*****************************************************************************
class CQuickBytes
{
public:
    CQuickBytes() :
        pbBuff(0),
        iSize(0),
        cbTotal(CQUICKBYTES_BASE_SIZE)
    { }

    ~CQuickBytes()
    {
        if (pbBuff)
            free(pbBuff);
    }

    void *Alloc(int iItems)
    {
        iSize = iItems;
        if (iItems <= CQUICKBYTES_BASE_SIZE)
            return (&rgData[0]);
        else
        {
            pbBuff = malloc(iItems);
            return (pbBuff);
        }
    }

    HRESULT ReSize(int iItems)
    {
        void *pbBuffNew;
        if (iItems <= cbTotal)
        {
            iSize = iItems;
            return NOERROR;
        }

        pbBuffNew = malloc(iItems + CQUICKBYTES_INCREMENTAL_SIZE);
        if (!pbBuffNew)
            return E_OUTOFMEMORY;
        if (pbBuff) 
        {
            memcpy(pbBuffNew, pbBuff, cbTotal);
            free(pbBuff);
        }
        else
        {
            _ASSERTE(cbTotal == CQUICKBYTES_BASE_SIZE);
            memcpy(pbBuffNew, rgData, cbTotal);
        }
        cbTotal = iItems + CQUICKBYTES_INCREMENTAL_SIZE;
        iSize = iItems;
        pbBuff = pbBuffNew;
        return NOERROR;
        
    }
    operator PVOID()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    void *Ptr()
    { return ((pbBuff) ? pbBuff : &rgData[0]); }

    int Size()
    { return (iSize); }

    void        *pbBuff;
    int         iSize;              // number of bytes used
    int         cbTotal;            // total bytes allocated in the buffer
    BYTE        rgData[512];
};

//*****************************************************************************
// This provides a wrapper around GetFileSize() that forces it to fail
// if the file is >4g and pdwHigh is NULL. Other than that, it acts like
// the genuine GetFileSize().
//
// It's not very sporting to fail just because the file exceeds 4gb,
// but it's better than risking a security hole where a bad guy could
// force a small buffer allocation and a large file read.
//*****************************************************************************
DWORD inline SafeGetFileSize(HANDLE hFile, DWORD *pdwHigh)
{
    if (pdwHigh != NULL)
    {
        return ::GetFileSize(hFile, pdwHigh);
    }
    else
    {
        DWORD hi;
        DWORD lo = ::GetFileSize(hFile, &hi);
        if (lo == 0xffffffff && GetLastError() != NO_ERROR)
        {
            return lo;
        }
        // api succeeded. is the file too large?
        if (hi != 0)
        {
            // there isn't really a good error to set here...
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0xffffffff;
        }

        if (lo == 0xffffffff)
        {
            // note that a success return of (hi=0,lo=0xffffffff) will be
            // treated as an error by the caller. Again, that's part of the
            // price of being a slacker and not handling the high dword.
            // We'll set a lasterror for him to pick up. (a bad error
            // code is better than a random one, I guess...)
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        return lo;
    }
}

//*****************************************************************************
// The information that the hash table implementation stores at the beginning
// of every record that can be but in the hash table.
//*****************************************************************************
struct HASHENTRY
{
    USHORT      iPrev;                  // Previous bucket in the chain.
    USHORT      iNext;                  // Next bucket in the chain.
};

struct FREEHASHENTRY : HASHENTRY
{
    USHORT      iFree;
};

//*****************************************************************************
// Used by the FindFirst/FindNextEntry functions.  These api's allow you to
// do a sequential scan of all entries.
//*****************************************************************************
struct HASHFIND
{
    USHORT      iBucket;            // The next bucket to look in.
    USHORT      iNext;
};


//*****************************************************************************
// This is a class that implements a chain and bucket hash table.  The table
// is actually supplied as an array of structures by the user of this class
// and this maintains the chains in a HASHENTRY structure that must be at the
// beginning of every structure placed in the hash table.  Immediately
// following the HASHENTRY must be the key used to hash the structure.
//*****************************************************************************
class CHashTable
{
protected:
    BYTE        *m_pcEntries;           // Pointer to the array of structs.
    USHORT      m_iEntrySize;           // Size of the structs.
    USHORT      m_iBuckets;             // # of chains we are hashing into.
    USHORT      *m_piBuckets;           // Ptr to the array of bucket chains.

    HASHENTRY *EntryPtr(USHORT iEntry)
    { return ((HASHENTRY *) (m_pcEntries + (iEntry * m_iEntrySize))); }

    USHORT     ItemIndex(HASHENTRY *p)
    {
        //
        // The following Index calculation is not safe on 64-bit platforms,
        // so we'll assert a range check in debug, which will catch SOME
        // offensive usages.  It also seems, to my eye, not to be safe on 
        // 32-bit platforms, but the 32-bit compilers don't seem to complain
        // about it.  Perhaps our warning levels are set too low? 
        //
        // [[@TODO: brianbec]]
        //
        
#       pragma warning(disable:4244)

        _ASSERTE( (( ( ((BYTE*)p) - m_pcEntries ) / m_iEntrySize ) & (~0xFFFF)) == 0 ) ;

        return (((BYTE *) p - m_pcEntries) / m_iEntrySize);

#       pragma warning(default:4244)
    }
    

public:
    CHashTable(
        USHORT      iBuckets) :         // # of chains we are hashing into.
        m_iBuckets(iBuckets),
        m_piBuckets(NULL),
        m_pcEntries(NULL)
    {
        _ASSERTE(iBuckets < 0xffff);
    }
    ~CHashTable()
    {
        if (m_piBuckets != NULL)
        {
            delete [] m_piBuckets;
            m_piBuckets = NULL;
        }
    }

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
    HRESULT NewInit(                    // Return status.
        BYTE        *pcEntries,         // Array of structs we are managing.
        USHORT      iEntrySize);        // Size of the entries.

//*****************************************************************************
// Return a boolean indicating whether or not this hash table has been inited.
//*****************************************************************************
    int IsInited()
    { return (m_piBuckets != NULL); }

//*****************************************************************************
// This can be called to change the pointer to the table that the hash table
// is managing.  You might call this if (for example) you realloc the size
// of the table and its pointer is different.
//*****************************************************************************
    void SetTable(
        BYTE        *pcEntries)         // Array of structs we are managing.
    {
        m_pcEntries = pcEntries;
    }

//*****************************************************************************
// Clear the hash table as if there were nothing in it.
//*****************************************************************************
    void Clear()
    {
        _ASSERTE(m_piBuckets != NULL);
        memset(m_piBuckets, 0xff, m_iBuckets * sizeof(USHORT));
    }

//*****************************************************************************
// Add the struct at the specified index in m_pcEntries to the hash chains.
//*****************************************************************************
    BYTE *Add(                          // New entry.
        USHORT      iHash,              // Hash value of entry to add.
        USHORT      iIndex);            // Index of struct in m_pcEntries.

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        USHORT      iIndex);            // Index of struct in m_pcEntries.

    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        HASHENTRY   *psEntry);          // The struct to delete.

//*****************************************************************************
// The item at the specified index has been moved, update the previous and
// next item.
//*****************************************************************************
    void Move(
        USHORT      iHash,              // Hash value for the item.
        USHORT      iNew);              // New location.

//*****************************************************************************
// Search the hash table for an entry with the specified key value.
//*****************************************************************************
    BYTE *Find(                         // Index of struct in m_pcEntries.
        USHORT      iHash,              // Hash value of the item.
        BYTE        *pcKey);            // The key to match.

//*****************************************************************************
// Search the hash table for the next entry with the specified key value.
//*****************************************************************************
    USHORT FindNext(                    // Index of struct in m_pcEntries.
        BYTE        *pcKey,             // The key to match.
        USHORT      iIndex);            // Index of previous match.

//*****************************************************************************
// Returns the first entry in the first hash bucket and inits the search
// struct.  Use the FindNextEntry function to continue walking the list.  The
// return order is not gauranteed.
//*****************************************************************************
    BYTE *FindFirstEntry(               // First entry found, or 0.
        HASHFIND    *psSrch)            // Search object.
    {
        if (m_piBuckets == 0)
            return (0);
        psSrch->iBucket = 1;
        psSrch->iNext = m_piBuckets[0];
        return (FindNextEntry(psSrch));
    }

//*****************************************************************************
// Returns the next entry in the list.
//*****************************************************************************
    BYTE *FindNextEntry(                // The next entry, or0 for end of list.
        HASHFIND    *psSrch);           // Search object.

protected:
    virtual inline BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2) = 0;
};


//*****************************************************************************
// Allocater classes for the CHashTableAndData class.  One is for VirtualAlloc
// and the other for malloc.
//*****************************************************************************
class CVMemData
{
public:
    static BYTE *Alloc(int iSize, int iMaxSize)
    {
        BYTE        *pPtr;

        _ASSERTE((iSize & 4095) == 0);
        _ASSERTE((iMaxSize & 4095) == 0);
        if ((pPtr = (BYTE *) VirtualAlloc(NULL, iMaxSize,
                                        MEM_RESERVE, PAGE_NOACCESS)) == NULL ||
            VirtualAlloc(pPtr, iSize, MEM_COMMIT, PAGE_READWRITE) == NULL)
        {
            VirtualFree(pPtr, 0, MEM_RELEASE);
            return (NULL);
        }
        return (pPtr);
    }
    static void Free(BYTE *pPtr, int iSize)
    {
        _ASSERTE((iSize & 4095) == 0);
        VirtualFree(pPtr, iSize, MEM_DECOMMIT);
        VirtualFree(pPtr, 0, MEM_RELEASE);
    }
    static BYTE *Grow(BYTE *pPtr, int iCurSize)
    {
        _ASSERTE((iCurSize & 4095) == 0);
        return ((BYTE *) VirtualAlloc(pPtr + iCurSize, GrowSize(), MEM_COMMIT, PAGE_READWRITE));
    }
    static int RoundSize(int iSize)
    {
        return ((iSize + 4095) & ~4095);
    }
    static int GrowSize()
    {
        return (4096);
    }
};

class CNewData
{
public:
    static BYTE *Alloc(int iSize, int iMaxSize)
    {
        return ((BYTE *) malloc(iSize));
    }
    static void Free(BYTE *pPtr, int iSize)
    {
        free(pPtr);
    }
    static BYTE *Grow(BYTE *&pPtr, int iCurSize)
    {
        void *p = realloc(pPtr, iCurSize + GrowSize());
        if (p == 0) return (0);
        return (pPtr = (BYTE *) p);
    }
    static int RoundSize(int iSize)
    {
        return (iSize);
    }
    static int GrowSize()
    {
        return (256);
    }
};


//*****************************************************************************
// This simple code handles a contiguous piece of memory.  Growth is done via
// realloc, so pointers can move.  This class just cleans up the amount of code
// required in every function that uses this type of data structure.
//*****************************************************************************
class CMemChunk
{
public:
    CMemChunk() : m_pbData(0), m_cbSize(0), m_cbNext(0) { }
    ~CMemChunk()
    {
        Clear();
    }

    BYTE *GetChunk(int cbSize)
    {
        BYTE *p;
        if (m_cbSize - m_cbNext < cbSize)
        {
            int cbNew = max(cbSize, 512);
            p = (BYTE *) realloc(m_pbData, m_cbSize + cbNew);
            if (!p) return (0);
            m_pbData = p;
            m_cbSize += cbNew;
        }
        p = m_pbData + m_cbNext;
        m_cbNext += cbSize;
        return (p);
    }

    // Can only delete the last unused chunk.  no free list.
    void DelChunk(BYTE *p, int cbSize)
    {
        _ASSERTE(p >= m_pbData && p < m_pbData + m_cbNext);
        if (p + cbSize  == m_pbData + m_cbNext)
            m_cbNext -= cbSize;
    }

    int Size()
    { return (m_cbSize); }

    int Offset()
    { return (m_cbNext); }

    BYTE *Ptr(int cbOffset = 0)
    {
        _ASSERTE(m_pbData && m_cbSize);
        _ASSERTE(cbOffset < m_cbSize);
        return (m_pbData + cbOffset);
    }

    void Clear()
    {
        if (m_pbData)
            free(m_pbData);
        m_pbData = 0;
        m_cbSize = m_cbNext = 0;
    }

private:
    BYTE        *m_pbData;              // Data pointer.
    int         m_cbSize;               // Size of current data.
    int         m_cbNext;               // Next place to write.
};


//*****************************************************************************
// This implements a hash table and the allocation and management of the
// records that are being hashed.
//*****************************************************************************
template <class M>
class CHashTableAndData : protected CHashTable
{
    USHORT      m_iFree;
    USHORT      m_iEntries;

public:
    CHashTableAndData(
        USHORT      iBuckets) :         // # of chains we are hashing into.
        CHashTable(iBuckets)
    {
        m_iFree = m_iEntries = 0;
    }
    ~CHashTableAndData()
    {
        if (m_pcEntries != NULL)
            M::Free(m_pcEntries, M::RoundSize(m_iEntries * m_iEntrySize));
    }

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
    HRESULT NewInit(                    // Return status.
        USHORT      iEntries,           // # of entries.
        USHORT      iEntrySize,         // Size of the entries.
        int         iMaxSize);          // Max size of data.

//*****************************************************************************
// Clear the hash table as if there were nothing in it.
//*****************************************************************************
    void Clear()
    {
        m_iFree = 0;

        if (m_iEntries > 0)
        {
            InitFreeChain(0, m_iEntries);
            CHashTable::Clear();
        }
    }

//*****************************************************************************
//*****************************************************************************
    BYTE *Add(
        USHORT      iHash)              // Hash value of entry to add.
    {
        FREEHASHENTRY *psEntry;

        // Make the table bigger if necessary.
        if (m_iFree == 0xffff && !Grow())
            return (NULL);

        // Add the first entry from the free list to the hash chain.
        psEntry = (FREEHASHENTRY *) CHashTable::Add(iHash, m_iFree);
        m_iFree = psEntry->iFree;
        return ((BYTE *) psEntry);
    }

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        USHORT      iIndex)             // Index of struct in m_pcEntries.
    {
        CHashTable::Delete(iHash, iIndex);
        ((FREEHASHENTRY *) EntryPtr(iIndex))->iFree = m_iFree;
        m_iFree = iIndex;
    }

    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        HASHENTRY   *psEntry)           // The struct to delete.
    {
        CHashTable::Delete(iHash, psEntry);
        ((FREEHASHENTRY *) psEntry)->iFree = m_iFree;
        m_iFree = ItemIndex(psEntry);
    }

private:
    void InitFreeChain(USHORT iStart,USHORT iEnd);
    int Grow();
};


//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
template<class M>
HRESULT CHashTableAndData<M>::NewInit(// Return status.
    USHORT      iEntries,               // # of entries.
    USHORT      iEntrySize,             // Size of the entries.
    int         iMaxSize)               // Max size of data.
{
    BYTE        *pcEntries;
    HRESULT     hr;

    // Allocate the memory for the entries.
    if ((pcEntries = M::Alloc(M::RoundSize(iEntries * iEntrySize),
                                M::RoundSize(iMaxSize))) == 0)
        return (E_OUTOFMEMORY);
    m_iEntries = iEntries;

    // Init the base table.
    if (FAILED(hr = CHashTable::NewInit(pcEntries, iEntrySize)))
        M::Free(pcEntries, M::RoundSize(iEntries * iEntrySize));
    else
    {
        // Init the free chain.
        m_iFree = 0;
        InitFreeChain(0, iEntries);
    }
    return (hr);
}

//*****************************************************************************
// Initialize a range of records such that they are linked together to be put
// on the free chain.
//*****************************************************************************
template<class M>
void CHashTableAndData<M>::InitFreeChain(
    USHORT      iStart,                 // Index to start initializing.
    USHORT      iEnd)                   // Index to stop initializing
{
    BYTE        *pcPtr;
    _ASSERTE(iEnd > iStart);

    pcPtr = m_pcEntries + iStart * m_iEntrySize;
    for (++iStart; iStart < iEnd; ++iStart)
    {
        ((FREEHASHENTRY *) pcPtr)->iFree = iStart;
        pcPtr += m_iEntrySize;
    }
    ((FREEHASHENTRY *) pcPtr)->iFree = 0xffff;
}

//*****************************************************************************
// Attempt to increase the amount of space available for the record heap.
//*****************************************************************************
template<class M>
int CHashTableAndData<M>::Grow()        // 1 if successful, 0 if not.
{
    int         iCurSize;               // Current size in bytes.
    int         iEntries;               // New # of entries.

    _ASSERTE(m_pcEntries != NULL);
    _ASSERTE(m_iFree == 0xffff);

    // Compute the current size and new # of entries.
    iCurSize = M::RoundSize(m_iEntries * m_iEntrySize);
    iEntries = (iCurSize + M::GrowSize()) / m_iEntrySize;

    // Make sure we stay below 0xffff.
    if (iEntries >= 0xffff) return (0);

    // Try to expand the array.
    if (M::Grow(m_pcEntries, iCurSize) == 0)
        return (0);

    // Init the newly allocated space.
    InitFreeChain(m_iEntries, iEntries);
    m_iFree = m_iEntries;
    m_iEntries = iEntries;
    return (1);
}

int WszMultiByteToWideChar(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar);

int WszWideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar);

#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(char); \
    CQuickBytes __CQuickBytes##ptrname; \
    __CQuickBytes##ptrname.Alloc(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__CQuickBytes##ptrname.Ptr(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__CQuickBytes##ptrname.Ptr()

#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname; \
    LPWSTR ptrname;	\
    __l##ptrname = MultiByteToWideChar(CP_ACP, 0, ansistr, -1, 0, 0); \
	ptrname = (LPWSTR) alloca(__l##ptrname*sizeof(WCHAR));	\
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, ptrname, __l##ptrname);

#define MAKE_UTF8PTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (long)((wcslen(widestr) + 1) * 2 * sizeof(char)); \
    LPSTR ptrname = (LPSTR)alloca(__l##ptrname); \
    WszWideCharToMultiByte(CP_UTF8, 0, widestr, -1, ptrname, __l##ptrname, NULL, NULL);

// NOTE: CP_ACP is not correct, but Win95 does not support CP_UTF8.  For this
//  particular application, CP_ACP is "close enough".
#define MAKE_WIDEPTR_FROMUTF8(ptrname, utf8str) \
    long __l##ptrname; \
    LPWSTR ptrname;	\
    __l##ptrname = WszMultiByteToWideChar(CP_UTF8, 0, utf8str, -1, 0, 0); \
	ptrname = (LPWSTR) alloca(__l##ptrname*sizeof(WCHAR));	\
    WszMultiByteToWideChar(CP_UTF8, 0, utf8str, -1, ptrname, __l##ptrname);

#define TESTANDRETURN(test, hrVal)              \
    _ASSERTE(test);                             \
    if (! (test))                               \
        return hrVal;

#define TESTANDRETURNPOINTER(pointer)           \
    TESTANDRETURN(pointer!=NULL, E_POINTER)

#define TESTANDRETURNMEMORY(pointer)            \
    TESTANDRETURN(pointer!=NULL, E_OUTOFMEMORY)

#define TESTANDRETURNHR(hr)                     \
    TESTANDRETURN(SUCCEEDED(hr), hr)

#define TESTANDRETURNARG(argtest)               \
    TESTANDRETURN(argtest, E_INVALIDARG)

#endif // __DEBUGGERUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\commands.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*------------------------------------------------------------------------- *
 * commands.cpp: com debugger shell functions
 * ------------------------------------------------------------------------- */

#include "stdafx.h"

#include "cordbpriv.h"
#include "corsvc.h"

#ifdef _INTERNAL_DEBUG_SUPPORT_
#include "InternalOnly.h"
#endif


/* ------------------------------------------------------------------------- *
 * RunDebuggerCommand is used to create and run a new CLR process.
 * ------------------------------------------------------------------------- */

class RunDebuggerCommand : public DebuggerCommand
{
private:
    WCHAR *m_lastRunArgs;

public:
    RunDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength), m_IFEOData(NULL)
    {
        if (g_pShell)
            m_lastRunArgs = g_pShell->m_lastRunArgs;
        else
            m_lastRunArgs = NULL;
    }

    virtual ~RunDebuggerCommand()
    {
    }

    char *m_IFEOData;
    HKEY  m_IFEOKey;
    DWORD m_IFEOKeyType;
    DWORD m_IFEOKeyLen;
    
    //
    // Yanking the Debugger value out of the registry will prevent
    // infinite launch recusion when we're not the win32 debugger of
    // the process.
    //
    void TurnOffIFEO(WCHAR *args)
    {
        // Extract the .exe name from the command.
        WCHAR *endOfExe = wcschr(args, L' ');

        if (endOfExe)
            *endOfExe = L'\0';

        WCHAR *exeNameStart = wcsrchr(args, L'\\');

        if (exeNameStart == NULL)
            exeNameStart = args;
        else
            exeNameStart++;

        MAKE_ANSIPTR_FROMWIDE(exeNameA, exeNameStart);
        
        // Is there an entry in the registry for this exe?
        char buffer[1024];

        sprintf(buffer, "Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s", exeNameA);

        if (!strchr(buffer, '.'))
            strcat(buffer, ".exe");
        
        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, buffer, 0, KEY_ALL_ACCESS,
                          &m_IFEOKey) == ERROR_SUCCESS)
        {
            // Get the length of the key data.
            if (RegQueryValueExA(m_IFEOKey, "Debugger", NULL,
                                 &m_IFEOKeyType, NULL,
                                 &m_IFEOKeyLen) == ERROR_SUCCESS)
            {
                // Make some room...
                m_IFEOData = new char[m_IFEOKeyLen + 1];

                if (m_IFEOData)
                {
                    // Grab the data....
                    if (RegQueryValueExA(m_IFEOKey, "Debugger", NULL,
                                         &m_IFEOKeyType,
                                         (BYTE*) m_IFEOData,
                                         &m_IFEOKeyLen) == ERROR_SUCCESS)
                    {
                        // We've got a copy of the value, so nuke it.
                        RegDeleteValueA(m_IFEOKey, "Debugger");
                    }
                }
            }

            // Leave m_IFEOKey open. TurnOnIFEO will close it.
        }

        // Put the args back.
        if (endOfExe)
            *endOfExe = L' ';
    }

    void TurnOnIFEO(void)
    {
        if (m_IFEOData != NULL)
        {
            // Put back the IFEO key now that the process is
            // launched. Note: we don't care if this part fails...
            RegSetValueExA(m_IFEOKey, "Debugger", NULL, m_IFEOKeyType,
                           (const BYTE*) m_IFEOData, m_IFEOKeyLen);

            delete [] m_IFEOData;

            RegCloseKey(m_IFEOKey);
        }
    }
    
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // If no arguments provided, use the previously provided arguments
        if ((*args == L'\0') && (m_lastRunArgs != NULL))
            args = m_lastRunArgs;

        // If there were no arguments and no previously existing arguments
        if (args == NULL || *args == L'\0')
        {
            shell->Error(L"Program name expected.\n");
            return;
        }

        // If the arguments are different than the last, save them as the last
        if (    m_lastRunArgs == NULL 
             || ( args != NULL
             && 0 != wcscmp(args, m_lastRunArgs) ) )
        {
            delete [] shell->m_lastRunArgs;
            m_lastRunArgs = NULL;

            shell->m_lastRunArgs = new WCHAR [wcslen(args) + 1];

            if (shell->m_lastRunArgs == NULL)
            {
                shell->ReportError(E_OUTOFMEMORY);
                return;
            }

            wcscpy (shell->m_lastRunArgs, args);

            m_lastRunArgs = shell->m_lastRunArgs;
        }

        // Kill the currently running process, if it exists
        shell->Kill();

        // Create and fill in the structure for creating a new CLR process
        STARTUPINFOW startupInfo = {0};
        startupInfo.cb = sizeof (STARTUPINFOW);
        PROCESS_INFORMATION processInfo = {0};

        // Startup in current directory.
        LPWSTR szCurrentDir = NULL;
        
        // Createprocess needs to modify the arguments, so make temp copy
        CQuickBytes argsBuf;
        WCHAR *argsCopy = (WCHAR*)argsBuf.Alloc(wcslen(args) * sizeof (WCHAR));

        if (argsCopy == NULL)
        {
            shell->Error(L"Couldn't get enough memory to copy args!\n");
            return;
        }

        wcscpy(argsCopy, args);

        CorDebugCreateProcessFlags cddf = DEBUG_NO_SPECIAL_OPTIONS;
        
        // Create the new CLR process
        ICorDebugProcess *proc;
        DWORD createFlags = 0;

        if (shell->m_rgfActiveModes & DSM_SEPARATE_CONSOLE)
            createFlags |= CREATE_NEW_CONSOLE;

        if (shell->m_rgfActiveModes & DSM_WIN32_DEBUGGER)
            createFlags |= DEBUG_ONLY_THIS_PROCESS;

        // Turn off any Image File Execution Option settings in the
        // registry for this app.
        TurnOffIFEO(argsCopy);
        
        HRESULT hr = cor->CreateProcess(NULL, argsCopy,
                                        NULL, NULL, TRUE, 
                                        createFlags,
                                        NULL, szCurrentDir, 
                                        &startupInfo, &processInfo,
                                        cddf, &proc);
        
        // Turn any Image File Execution Option settings in the
        // registry for this app back on.
        TurnOnIFEO();
        
        // Succeeded, so close process handle since the callback will
        // provide it
        if (SUCCEEDED(hr))
        {
            BOOL succ = CloseHandle(processInfo.hProcess);

            // Some sort of error has occured
            if (!succ)
            {
                WCHAR *p = wcschr(argsCopy, L' ');

                if (p != NULL)
                    *p = '\0';
                
                shell->Write(L"'%s'", argsCopy);
                shell->ReportError(HRESULT_FROM_WIN32(GetLastError()));
                return;
            }

            // We need to remember our target process now so we can
            // make use of it even before the managed CreateProcess
            // event arrives. This is mostly needed for Win32
            // debugging support.
            g_pShell->SetTargetProcess(proc);
            
            // We don't care to keep this reference to the new process.
            proc->Release();
            
            // Run the newly-created process
            shell->Run(true); // No continue for CreateProcess.
        }

        // Otherwise report the error
        else
        {
            WCHAR *p = wcschr(argsCopy, L' ');

            if (p != NULL)
                *p = '\0';
            
            shell->ReportError(hr);
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[<executable> [<args>]]\n");
        shell->Write(L"Kills the current process (if there is one) and\n");
        shell->Write(L"start a new one. If no executable argument is\n");
        shell->Write(L"passed, this command runs the program that was\n");
        shell->Write(L"previously executed with the run command. If the\n");
        shell->Write(L"executable argument is provided, the specified\n");
        shell->Write(L"program is run using the optionally supplied args.\n");
        shell->Write(L"If class load, module load, and thread start events\n");
        shell->Write(L"are being ignored (as they are by default), then the\n");
        shell->Write(L"program will stop on the first executable instruction\n");
        shell->Write(L"of the main thread.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Start a process for debugging";
    }
};

/* ------------------------------------------------------------------------- *
 * AttachDebuggerCommand is used to attach to an already-existing CLR
 * process.
 * ------------------------------------------------------------------------- */

class AttachDebuggerCommand : public DebuggerCommand
{
public:
    AttachDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
        {
        }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
        {
            int pid;

            if (shell->GetIntArg(args, pid))
            {
                // Kill the currently running process
                shell->Kill();

                BOOL win32Attach = FALSE;
                
                if (shell->m_rgfActiveModes & DSM_WIN32_DEBUGGER)
                    win32Attach = TRUE;
                
                // Attempt to attach to the provided process ID
                ICorDebugProcess *proc;

                HRESULT hr = cor->DebugActiveProcess(pid, win32Attach, &proc);

                if (SUCCEEDED(hr))
                {
                    // We don't care to keep this reference to the process.
                    g_pShell->SetTargetProcess(proc);
                    proc->Release();

                    shell->Run(true); // No initial Continue!
                }
                else if (hr == CORDBG_E_DEBUGGER_ALREADY_ATTACHED)
                    shell->Write(L"ERROR: A debugger is already attached to this process.\n");
                else
                    shell->ReportError(hr);
            }
            else
                Help(shell);
        }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
		shell->Write(L"<pid>\n");
        shell->Write(L"Attaches the debugger to a running process. The\n");
        shell->Write(L"program currently being debugged (if there is one)\n");
        shell->Write(L"is killed, and an attempt is made to attach to the\n");
        shell->Write(L"process specified by the pid argument. The pid can\n");
        shell->Write(L"be in decimal or hexadecimal.\n"); 
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Attach to a running process";
    }
};

/* ------------------------------------------------------------------------- *
 * This is an implementation of the ICORSvcDbgNotify class to be used by
 * the AttachDebuggerAtRTStartupCommand.
 * ------------------------------------------------------------------------- */
class CINotifyImpl : public ICORSvcDbgNotify
{
private:
    LONG m_cRef;

public:
    // ------------------------------------------------------------------------
    // Other
    CINotifyImpl() : m_cRef(1)
    {
    }

    // ------------------------------------------------------------------------
    // IUnknown

    STDMETHODIMP    QueryInterface (REFIID iid, void **ppv)
    {
        if (ppv == NULL)
            return E_INVALIDARG;

        if (iid == IID_IUnknown)
        {
            *ppv = (IUnknown *) this;
            AddRef();
            return S_OK;
        }

        if (iid == IID_ICORSvcDbgNotify)
        {
            *ppv = (ICORSvcDbgNotify *) this;
            AddRef();
            return S_OK;
        }

        *ppv = NULL;
        return E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            //delete this;
            return 0;
        }

        return 1;
    }

    // ------------------------------------------------------------------------
    // ICORSvcDbgNotify

    /*
     * NotifyRuntimeStartup will be called on the interface provided by a
     * call to RequestRuntimeStartupNotification.  The runtime will not
     * continue until the call to NotifyRuntimeStartup returns.
     */
    STDMETHODIMP NotifyRuntimeStartup(
        UINT_PTR procId)
    {
        return (E_NOTIMPL);
    }

    /*
     * NotifyServiceStopped lets those who have requested events know that the
     * service is being stopped, so they will not get their requested
     * notifications.  Calls on this method should not take long - if any great
     * amount of work must be done, spin up a new thread to do it and let this
     * one return.
     */
    STDMETHODIMP NotifyServiceStopped()
    {
        return (E_NOTIMPL);
    }
};


/* ------------------------------------------------------------------------- *
 * SyncAttachDebuggerAtRTStartupCommand will attach the debugger when the
 * runtime starts up within a specified process.  The process must already
 * exist, and must not have started the CLR.
 * ------------------------------------------------------------------------- */

class SyncAttachDebuggerAtRTStartupCommand :
    public DebuggerCommand, public CINotifyImpl
{
private:
    DebuggerShell  *m_pShell;
    HANDLE          m_hContinue;
    ICorDebug      *m_pCor;

public:
    SyncAttachDebuggerAtRTStartupCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength), CINotifyImpl(), m_pShell(NULL),
          m_hContinue(NULL)
        {
        }

    ~SyncAttachDebuggerAtRTStartupCommand()
    {
        if (m_hContinue != NULL)
            CloseHandle(m_hContinue);
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        int pid;
        
        if (shell->GetIntArg(args, pid))
        {
            m_pShell = shell;
            m_pCor = cor;

            // Kill the currently running process
            shell->Kill();

            // Get a reference to the debugger info interface for the CLR service
            HRESULT hr;
            MULTI_QI    mq;

            mq.pIID = &IID_ICORSvcDbgInfo;
            mq.pItf = NULL;
            mq.hr = S_OK;
            hr = CoCreateInstanceEx(CLSID_CORSvc, NULL, CLSCTX_LOCAL_SERVER, NULL, 1, &mq);

            if (SUCCEEDED(hr))
            {
                // Now we have an info interface
                ICORSvcDbgInfo *psvc = (ICORSvcDbgInfo *) mq.pItf;
                _ASSERTE(psvc);

                // Ask for notification when the runtime starts up
                hr = psvc->RequestRuntimeStartupNotification((UINT_PTR) pid, ((ICORSvcDbgNotify *) this));

                if (SUCCEEDED(hr))
                {
                    // Run will return when the event queue has been drained
                    shell->Run(true);
                }
                else
                {
                    shell->ReportError(hr);
                }
                
                // let go of the object
                if (psvc)
                    psvc->Release();
            }
        }
        else
            Help(shell);
    }

    /*
     * NotifyRuntimeStartup will be called on the interface provided by a
     * call to RequestRuntimeStartupNotification.  The runtime will not
     * continue until the call to NotifyRuntimeStartup returns.
     */
    STDMETHODIMP NotifyRuntimeStartup(
        UINT_PTR procId)
    {
        // Invoke the logic to debug an active process
        ICorDebugProcess *proc;
        HRESULT hr = m_pCor->DebugActiveProcess(procId, FALSE, &proc);

        // Upon success, we return from the DCOM call right away, since
        // the main runtime thread must be allowed to continue for the
        // attach to complete and the call to Run from Do above to return
        if (SUCCEEDED(hr))
        {
            // We don't care to keep this reference to the process.
            // We don't care to keep this reference to the process.
            g_pShell->SetTargetProcess(proc);
            proc->Release();
        }
        else if (hr == CORDBG_E_DEBUGGER_ALREADY_ATTACHED)
        {
            _ASSERTE(!"CORDBG: How on earth did someone attach ahead of a notification from the service?");
            g_pShell->Write(L"ERROR: A debugger is already attached to this process.\n");
        }
        else
            m_pShell->ReportError(hr);

        // A succeeded HR indicates that we are attaching and that the main
        // runtime thread should not continue until the attach is complete.  A
        // failed HR means that we are not going to attach and that the main
        // runtime thread can just continue.
        return (hr);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
        shell->Write(L"<pid>\n");
        shell->Write(L"Kills the current process and waits for the process\n");
        shell->Write(L"identified by the pid argument to start up the CLR,\n");
        shell->Write(L"at which point the debugger attaches and continues.\n");
        shell->Write(L"The target process can not have already started up\n"); 
        shell->Write(L"the CLR --- it must not have been loaded.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Attach to a process when the CLR is not loaded";
    }
};

/* ------------------------------------------------------------------------- *
 * KillDebuggerCommand is used to terminate the current debugee.
 * ------------------------------------------------------------------------- */

class KillDebuggerCommand : public DebuggerCommand
{
public:
    KillDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // Kill the current debugee
        shell->Kill();
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"\n");
        shell->Write(L"Kills the current process. The debugger remains\n");
        shell->Write(L"active to process further commands.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Kill the current process";
    }
};

/* ------------------------------------------------------------------------- *
 * QuitDebuggerCommand is used to quit the shell debugger
 * ------------------------------------------------------------------------- */

class QuitDebuggerCommand : public DebuggerCommand
{
public:
    QuitDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // Tell the shell that we are ready to quit
        shell->m_quit = true;

        // Terminate the current debugee
        shell->Kill();
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
	    ShellCommand::Help(shell);
    	shell->Write(L"\n");
        shell->Write(L"Kills the current process and exits the debugger.\n");
        shell->Write(L"The exit command is an alias for the quit command.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Kill the current process and exit the debugger";
    }
};

/* ------------------------------------------------------------------------- *
 * GoDebuggerCommand runs the debugee (it does not disable callbacks)
 * ------------------------------------------------------------------------- */

class GoDebuggerCommand : public DebuggerCommand
{
public:
    GoDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // A counter to indicate how many times the command is executed
        int count;

        // If no count is provided, assume a value of 1
        if (!shell->GetIntArg(args, count))
            count = 1;

        // Perform the command count times
        shell->m_stopLooping = false;
        while (count-- > 0 && !shell->m_stopLooping)
        {
            // If a debugee does not exist, quit command
            if (shell->m_currentProcess == NULL)
            {
                shell->Error(L"Process not running.\n");
                break;
            }
            
            // Otherwise, run the current debugee
            else
                shell->Run();
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {        
    	ShellCommand::Help(shell);
        shell->Write(L"[<count>]\n");
        shell->Write(L"Continues the program. If no argument is passed, the program is\n");
        shell->Write(L"continued once. If a count argument is provided, the program is\n");
        shell->Write(L"continued the specified number of times. This command is useful\n");
        shell->Write(L"for continuing a program when a load, exception, or breakpoint\n");
        shell->Write(L"event stops the debugger. The cont command is an alias of the go\n");
        shell->Write(L"command.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Continue the current process";
    }
};

/* ------------------------------------------------------------------------- *
 * SetIpDebuggerCommand is used to change the current IP
 * ------------------------------------------------------------------------- */

class SetIpDebuggerCommand : public DebuggerCommand
{
public:
    SetIpDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
        {
        }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
        {
            int lineNumber;
            long ILIP;
            HRESULT hr;

            // If no current process, terminate
            if (shell->m_currentProcess == NULL)
            {
                shell->Error(L"No active process.\n");
                return;
            }

            if (!shell->GetIntArg(args, lineNumber))
            {
                shell->Write( L"Need the offset argument\n");
                return;
            }

            ILIP = ValidateLineNumber( shell, lineNumber );

            if( ILIP == -1 )
            {
                shell->Write( L"Invalid line number\n");
                return;
            }
            
            SIZE_T offset = (SIZE_T)ILIP;
                
            hr = shell->m_currentFrame->CanSetIP( offset);
            if (hr != S_OK )
                hr = ConfirmSetIP(shell, hr);

            if (FAILED( hr ) )
            {
                return;
            }

            hr = shell->m_currentFrame->SetIP( offset);
            _ASSERTE(SUCCEEDED(hr));
            
            switch( hr )
            {
                case S_OK:
                    break;

                case CORDBG_S_BAD_START_SEQUENCE_POINT:
                    shell->Write(L"WARNING: should SetIP from a sequence point.\n");
                    break;
                    
                case CORDBG_S_BAD_END_SEQUENCE_POINT:
                    shell->Write(L"WARNING: should SetIP to another sequence point.\n");
                    break;

                default:
                    if (FAILED(hr))
                        shell->ReportError(hr);
                    break;
            }

            // This must be done on successful SetIPs, even when setting from
            // a bad sequence point.
            if (SUCCEEDED(hr))
            {
                if (hr != S_OK)
                {
                    shell->Write(L"WARNING: this operation may have "
                                 L"corrupted the stack.\n");
                }

                shell->Write(L"IP set successfully.\n");
                shell->SetDefaultFrame();
            }
    }
    
    long GetILIPFromSourceLine( DebuggerShell *shell, 
                                DebuggerSourceFile *file,
                                long lineNumber,
                                DebuggerFunction *fnx)
    {
        DebuggerModule *m = file->m_module;

        if (m->GetSymbolReader() == NULL)
            return -1;
        
        // GetMethodFromDocumentPosition to get an ISymUnmanagedMethod
        // from this doc.
        ISymUnmanagedMethod *pSymMethod;

        HRESULT hr = m->GetSymbolReader()->GetMethodFromDocumentPosition(
                                                        file->GetDocument(),
                                                        lineNumber,
                                                        0,
                                                        &pSymMethod);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return -1;
        }
        
        ULONG32 lineRangeCount = 0;

        // How many ranges?
        hr = pSymMethod->GetRanges(file->GetDocument(),
                                   lineNumber, 0,
                                   0, &lineRangeCount,
                                   NULL);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return -1;
        }

        long res = -1;
        
        // Make room for the ranges
        if (lineRangeCount > 0)
        {
            CQuickBytes rangeBuf;
            ULONG32 *rangeArray = (ULONG32 *) rangeBuf.Alloc(sizeof(ULONG32) * lineRangeCount);
            
            if (rangeArray == NULL)
            {
                shell->Error(L"Couldn't get enough memory to get lines!\n");
                return -1;
            }

            hr = pSymMethod->GetRanges(file->GetDocument(),
                                       lineNumber, 0,
                                       lineRangeCount,
                                       &lineRangeCount,
                                       rangeArray);

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);
                return -1;
            }
        
        
            DebuggerFunction *f = m->ResolveFunction(pSymMethod, NULL);
            if (fnx != f)
                return -1;

            res = rangeArray[0];
        }

        return res; //failure
    }

    
    long ValidateLineNumber( DebuggerShell *shell, long lineNumber )
    {
        HRESULT hr;
    
        //
        // First we jump through hoops (luckily, all cut-n-pasted) to
        // get a DebuggerModule...
        //
        
        // Get an ICorDebugCode pointer from the current frame
        ICorDebugCode *icode;
        hr = shell->m_currentFrame->GetCode(&icode);

        // Error check
        if (FAILED(hr))
        {
            shell->ReportError(hr);
            return -1;
        }

        // Get an ICorDebugFunction pointer from the code pointer
        ICorDebugFunction *ifunction;
        icode->GetFunction(&ifunction);

        // Error check
        if (FAILED(hr))
        {
            RELEASE(icode);
            shell->ReportError(hr);
            return -1;
        }

        // Resolve the ICorDebugFunction pointer to a DebuggerFunction ptr
        DebuggerFunction *function = DebuggerFunction::FromCorDebug(ifunction);   
        _ASSERTE( function );

        // Get the DebuggerSourceFile
        // @TODO: We try to get the source-file corresponding to offset 0,
        // but this may not always be correct/present.
        unsigned currentLineNumber;
        DebuggerSourceFile *sf;
        hr = function->FindLineFromIP(0, &sf, &currentLineNumber);
        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return -1;
        }
        else if (hr != S_OK)
        {
            g_pShell->Error(L"Could not find get source-file information\n");
            return -1;
        }

        if (sf->FindClosestLine(lineNumber, false) == lineNumber)
        {
            return GetILIPFromSourceLine( shell, sf, lineNumber, function);
        }

        return -1;
     }       

    HRESULT ConfirmSetIP( DebuggerShell *shell, HRESULT hr )
    {
        
    
        switch( hr )
        {
            case CORDBG_E_CODE_NOT_AVAILABLE:
                shell->Write( L"Can't set ip because the code isn't available.\n");
                hr = E_FAIL;
                break;
                
            case CORDBG_E_CANT_SET_IP_INTO_FINALLY:
                shell->Write( L"Can't set ip because set into a finally not allowed.\n");
                hr = E_FAIL;
                break;
                
            case CORDBG_E_CANT_SET_IP_INTO_CATCH:
                shell->Write( L"Can't set ip because set into a catch not allowed.\n");
                hr = E_FAIL;
                break;
 
            case CORDBG_S_BAD_START_SEQUENCE_POINT:
                shell->Write( L"SetIP can work, but is bad b/c you're not starting from a source line.\n");
                hr = S_OK;
                break;
            
            case CORDBG_S_BAD_END_SEQUENCE_POINT:
                shell->Write( L"SetIP can work, but is bad b/c you're going to a nonsource line.\n");
                hr = S_OK;
                break;
 
            case CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP:
                shell->Write( L"SetIP can work, but is bad b/c we don't have enough info to properly fix up the variables,etc.\n");
                hr = E_FAIL;
                break;

            case E_FAIL:
                shell->Write( L"SetIP said: E_FAIL (miscellaneous, fatal, error).\n");
                hr = E_FAIL;
                break;

            case CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY:
                shell->Write( L"Can't set ip to outside of a finally while unwinding.\n");
                hr = E_FAIL;
                break;

            case CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME:
                shell->Write( L"Can't setip on a nonleaf frame.\n");
                hr = E_FAIL;
                break;

            case CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER:
                shell->Write( L"Can't setip into or out of a filter.\n");
                hr = E_FAIL;
                break;
                
            case CORDBG_E_SET_IP_IMPOSSIBLE:
                shell->Write( L"SetIP said: I refuse: this is just plain impossible.\n");
                hr = E_FAIL;
                break;

            case CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION:
                shell->Write(L"ERROR: can't SetIP from an exception.\n");
                break;

            default:
                shell->Write( L"SetIP returned 0x%x.\n", hr);
                hr = E_FAIL;
                break;
        }
        
        if (FAILED( hr ) )
            return hr;

        shell->Write( L"Do you want to SetIp despite the risks inherent in this action (Y/N)?\n");
        WCHAR sz[20];
        shell->ReadLine( sz, 10);
        if( _wcsicmp( sz, L"n")==0 )
        {
            return E_FAIL;
        }
        
        return S_OK;
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<line number>\n");
        shell->Write(L"Sets the next statement to be executed to the\n");
        shell->Write(L"specified line number.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Set the next statement to a new line";
    }
};



/* ------------------------------------------------------------------------- *
 * StepDebuggerCommand steps into a function call
 * ------------------------------------------------------------------------- */

class StepDebuggerCommand : public DebuggerCommand
{
private:
    bool m_in;

public:
    StepDebuggerCommand(const WCHAR *name, bool in, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength), m_in(in)
    {
    }


    // @mfunc void | StepDebuggerCommand | Do | There are three options
    // for stepping: either we have no current frame (create a stepper off
    // of the thread, call StepRanges with ranges==NULL), there is a current
    // frame (create a stepper off the frame, call StepRanges w/ appropriate
    // ranges), or there is a current frame,but it's inside a {prolog,epilog,
    // etc} & we don't want to be - create a stepper
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        HRESULT hr = S_OK;
        ICorDebugStepper *pStepper;
        bool fSkipStepRanges; //in case we're stepping over the prolog

        COR_DEBUG_STEP_RANGE *ranges = NULL;
        SIZE_T rangeCount = 0;
        
        // A counter to indicate how many times the command is executed
        int count;

        // If no count is provided, assume a value of 1
        if (!shell->GetIntArg(args, count))
            count = 1;

            // Perform the command count times
        shell->m_stopLooping = false;
        while (count-- > 0 && !shell->m_stopLooping)
        {
            fSkipStepRanges = false; 
            
            shell->m_showSource = true;
        
            // If no current process, terminate
            if (shell->m_currentProcess == NULL)
            {
                shell->Error(L"Process not running.\n");
                return;
            }
            
            // If no current thread, terminate
            if (shell->m_currentThread == NULL)
            {
                shell->Error(L"Thread no longer exists.\n");
                return;
            }

            if (shell->m_currentFrame != NULL)
            {
                // Create a stepper based on the current frame
                HRESULT hr=shell->m_currentFrame->CreateStepper(&pStepper);
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                ULONG32 ip;
                CorDebugMappingResult mappingResult;
                hr = shell->m_currentFrame->GetIP(&ip, &mappingResult);

                // If we're in a prolog but don't want to be, step us to
                // the next (non-PROLOG) line of IL.
                // If we're in the prolog but want to be, then we should
                // single-step through the prolog.  Note that ComputeStopMask
                // will ensure that the (don't)skip flag is passed to the RC
                if (mappingResult & ~(MAPPING_EXACT|MAPPING_APPROXIMATE) )
                {
                    fSkipStepRanges = true;
                }
                else
                {
                    // Error check
                    if (FAILED(hr))
                    {
                        shell->ReportError(hr);
                        return;
                    }

                    // Get an ICorDebugCode pointer from the current frame
                    ICorDebugCode *icode;
                    hr = shell->m_currentFrame->GetCode(&icode);

                    // Error check
                    if (FAILED(hr))
                    {
                        shell->ReportError(hr);
                        return;
                    }

                    // Get an ICorDebugFunction pointer from the code pointer
                    ICorDebugFunction *ifunction;
                    icode->GetFunction(&ifunction);
                
                    // Error check
                    if (FAILED(hr))
                    {
                        RELEASE(icode);
                        shell->ReportError(hr);
                        return;
                    }

                    // Resolve the ICorDebugFunction pointer to a DebuggerFunction ptr
                    DebuggerFunction *function = 
                        DebuggerFunction::FromCorDebug(ifunction);

                    // Release iface pointers
                    RELEASE(icode);
                    RELEASE(ifunction);

                    // Get the ranges for the current IP
                    function->GetStepRangesFromIP(ip, &ranges, &rangeCount);
                                                    
                    if (rangeCount == 0)
                        shell->m_showSource = false;
                    else if (g_pShell->m_rgfActiveModes & DSM_ENHANCED_DIAGNOSTICS)
                    {
                        for (size_t i=0; i < rangeCount;i++)
                        {
                            shell->Write(L"Step range (IL): 0x%x to 0x%x\n", 
                                ranges[i].startOffset,
                                ranges[i].endOffset);
                        }
                    }

                }
            }

            // Create a stepper based on the current thread
            else
            {
                //note that this will fall into the step ranges case
                HRESULT hr = shell->m_currentThread->CreateStepper(&pStepper);
                if (FAILED(hr))
                {
                    shell->ReportError( hr );
                    return;
                }                

                fSkipStepRanges = true;
            }
            
                        
            hr = pStepper->SetUnmappedStopMask( shell->
                                                ComputeStopMask() );
            if (FAILED(hr))
            {
                shell->ReportError( hr );
                return;
            }

            hr = pStepper->SetInterceptMask( shell->
                                             ComputeInterceptMask());
            if (FAILED(hr))
            {
                shell->ReportError( hr );
                return;
            }
                    
            // Tell the shell about the new stepper
            shell->StepStart(shell->m_currentThread, pStepper);

            if (fSkipStepRanges)
            {
                hr = pStepper->Step( m_in );
                if (FAILED(hr))
                {
                    shell->ReportError( hr );
                    return;
                }
            }
            else
            {
                // Tell the stepper to step on the provided ranges
                HRESULT hr = pStepper->StepRange(m_in, ranges, rangeCount);
            
                // Error check
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                // Clean up
                delete [] ranges;
            }
            // Continue the process
            shell->Run();
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
        shell->Write(L"[<count>]\n");
        
    	if (m_in)
        {         	
            shell->Write(L"Steps the program to the next source line, stepping\n"); 
            shell->Write(L"into function calls. If no argument is passed, the\n"); 
            shell->Write(L"program is stepped to the next line. If a count\n"); 
            shell->Write(L"argument is provided, the specified number of lines\n");  
            shell->Write(L"will be stepped. The in and si commands are alias's\n");
            shell->Write(L"for the step command.\n");        
        }
        else
        {
            shell->Write(L"Steps the program to the next source line, stepping\n"); 
            shell->Write(L"over function calls. If no argument is passed, the\n"); 
            shell->Write(L"program is stepped to the next line. If a count\n"); 
            shell->Write(L"argument is provided, the specified number of lines\n");  
            shell->Write(L"will be stepped. The so command is an alias for\n");
            shell->Write(L"the next command.\n");        	   
        }
        
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        if (m_in)
            return L"Step into the next source line";
        else
            return L"Step over the next source line";
    }
};


class StepOutDebuggerCommand : public DebuggerCommand
{
public:
    StepOutDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        HRESULT hr;

        // A counter to indicate how many times the command is executed
        int count;

        // If no count is provided, assume a value of 1
        if (!shell->GetIntArg(args, count))
            count = 1;

        // Perform the command count times
        shell->m_stopLooping = false;
        while (count-- > 0 && !shell->m_stopLooping)
        {
            shell->m_showSource = true;

            // Error if no currently running process
            if (shell->m_currentProcess == NULL)
            {
                shell->Error(L"Process not running.\n");
                return;
            }
            
            // Error if no currently running thread
            if (shell->m_currentThread == NULL)
            {
                shell->Error(L"Thread no longer exists.\n");
                return;
            }

            ICorDebugStepper *pStepper;

            // Create a stepper based on the current frame
            if (shell->m_currentFrame != NULL)
                hr = shell->m_currentFrame->CreateStepper(&pStepper);

            // Create a stepper based on the current thread
            else
                hr = shell->m_currentThread->CreateStepper(&pStepper);

            // Error check
            if (FAILED(hr))
            {
                shell->ReportError(hr);
                return;
            }
            
            hr = pStepper->SetUnmappedStopMask( shell->ComputeStopMask() );
            if (FAILED(hr))
            {
                shell->Write( L"Unable to set unmapped stop mask");
                return;
            }                

            hr = pStepper->SetInterceptMask( shell->ComputeInterceptMask() );
            if (FAILED(hr))
            {
                shell->ReportError( hr );
                return;
            }
                
            
            // Tell the stepper to step out
            hr = pStepper->StepOut();

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);
                return;
            }

            // Indicate the current stepper to the shell
            shell->StepStart(shell->m_currentThread, pStepper);

            // Continue the process
            shell->Run();
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {		 
        ShellCommand::Help(shell);
        shell->Write(L"[<count>]\n");
        shell->Write(L"Steps the current program out of the current function.\n");
        shell->Write(L"If no argument is passed, a step out is performed once\n");
        shell->Write(L"for the current function. If a count argument is provided,\n");
        shell->Write(L"then a step out is performed the specified number of times.\n");        
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Step out of the current function";
    }
};

class StepSingleDebuggerCommand : public DebuggerCommand
{
private:
    bool m_in;

public:
    StepSingleDebuggerCommand(const WCHAR *name, bool in, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength), m_in(in)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        HRESULT hr;

        // A counter to indicate how many times the command is executed
        int count;

        shell->m_showSource = false;

        // If no count is provided, assume a value of 1
        if (!shell->GetIntArg(args, count))
            count = 1;

        // Perform the command count times
        shell->m_stopLooping = false;
        while (count-- > 0 && !shell->m_stopLooping)
        {
            // Error if no currently running process
            if (shell->m_currentProcess == NULL)
            {
                shell->Error(L"Process not running.\n");
                return;
            }
            
            // Error if no currently running thread
            if ((shell->m_currentThread == NULL) &&
                (shell->m_currentUnmanagedThread == NULL))
            {
                shell->Error(L"Thread no longer exists.\n");
                return;
            }

            ICorDebugChain *ichain = NULL;
            BOOL managed = FALSE;

            if (shell->m_currentThread != NULL)
            {
                HRESULT hr = shell->m_currentThread->GetActiveChain(&ichain);
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                hr = ichain->IsManaged(&managed);
                if (FAILED(hr))
                {
                    RELEASE(ichain);
                    shell->ReportError(hr);
                    return;
                }
            }

            if (managed || shell->m_currentUnmanagedThread == NULL)
            {
                if (ichain)
                    RELEASE(ichain);
                
                ICorDebugStepper *pStepper;

                // Create a stepper based on the current frame
                if (shell->m_currentFrame != NULL)
                    hr = shell->m_currentFrame->CreateStepper(&pStepper);
                else
                    hr = shell->m_currentThread->CreateStepper(&pStepper);
                                
                // Error check
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                hr = pStepper->SetUnmappedStopMask( shell->ComputeStopMask() );
                if (FAILED(hr))
                {
                    shell->Write( L"Unable to set unmapped stop mask");
                    return;
                }                
                hr = pStepper->SetInterceptMask(shell->ComputeInterceptMask());
                if (FAILED(hr))
                {
                    shell->ReportError( hr );
                    return;
                }
                
                
                // Tell the stepper what to do
                hr = pStepper->Step(m_in);
            
                // Error check
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                // Indicate the current stepper to the shell
                shell->StepStart(shell->m_currentThread, pStepper);

                // Continue the process
                shell->Run();
            }
            else
            {
                if (ichain == NULL)
                    shell->m_currentUnmanagedThread->m_unmanagedStackEnd = 0;
                else
                {
                    CORDB_ADDRESS start, end;
                    hr = ichain->GetStackRange(&start, &end);

                    RELEASE(ichain);
                    
                    if (FAILED(hr))
                    {
                        shell->ReportError(hr);
                        return;
                    }

                    shell->m_currentUnmanagedThread->m_unmanagedStackEnd = end;
                }

                ICorDebugRegisterSet *regSet = NULL;
                if (shell->m_currentThread != NULL)
                {
                    hr = shell->m_currentThread->GetRegisterSet(&regSet);
                    if (FAILED(hr))
                    {
                        shell->ReportError(hr);
                        return;
                    }
                }

                CONTEXT context;
                context.ContextFlags = CONTEXT_FULL;
                if (regSet != NULL)
                    hr = regSet->GetThreadContext(sizeof(context), (BYTE*)&context);
                else
                    hr = shell->m_currentProcess->GetThreadContext(
                                                   shell->m_currentUnmanagedThread->GetId(),
                                                   sizeof(context), (BYTE*)&context);
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

#ifdef _X86_
                context.EFlags |= 0x100;
#else // !_X86_
                _ASSERTE(!"@TODO Alpha - StepSingleDebuggerCommand::Do (Commands.cpp)");
#endif // _X86_

                if (regSet != NULL)
                {
                    hr = regSet->SetThreadContext(sizeof(context), (BYTE*)&context);
                    RELEASE(regSet);
                }
                else
                    hr = shell->m_currentProcess->SetThreadContext(
                                                   shell->m_currentUnmanagedThread->GetId(),
                                                   sizeof(context), (BYTE*)&context);

                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                shell->m_currentUnmanagedThread->m_stepping = TRUE;

                // Continue the process
                shell->Run();
            }
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
        ShellCommand::Help(shell);
    	shell->Write(L"[<count>]\n");
        
        if (m_in)
        {
            shell->Write(L"Steps the program one or more instructions, stepping\n"); 
            shell->Write(L"into function calls. If no argument is passed, only\n"); 
            shell->Write(L"one instruction is stepped into. If a count argument\n"); 
            shell->Write(L"argument is provided, the specified number of lines\n");  
            shell->Write(L"is provided, the specified number of steps is performed.\n");
        }
        else
        {
            shell->Write(L"Steps the program one or more instructions, skipping\n"); 
            shell->Write(L"over function calls. If no argument is passed, the\n"); 
            shell->Write(L"program is stepped one instruction. If a count argument\n"); 
            shell->Write(L"is provided, the program is stepped the specified number\n");  
            shell->Write(L"of instructions.\n"); 
        }
        
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        if (m_in)
            return L"Step into the next native or IL instruction";
        else
            return L"Step over the next native or IL instruction";
    }
};

class BreakpointDebuggerCommand : public DebuggerCommand
{
public:
    BreakpointDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    // Name is class::method
    BOOL    BindClassFunc ( WCHAR *name, 
                            const WCHAR *end, 
                            SIZE_T index, 
                            DWORD thread, 
                            DebuggerBreakpoint *breakpoint)
    {
        BOOL bAtleastOne = false;
        BOOL bFound = false;
        bool bUnused = false;
        HASHFIND find;

        // check if the user has specified a module name
        WCHAR *szModuleEnd = wcschr(name, L'!');
        WCHAR szModName [MAX_PATH] = L"";
        bool bModNameSpecified = false;
        char rcFile1[MAX_PATH];

        if (szModuleEnd != NULL)
        {
            if (szModuleEnd > name)
            {
                int iCount = szModuleEnd - name;

                wcsncpy (szModName, name, iCount);
                szModName [iCount] = L'\0';

                bModNameSpecified = true;

                // separate out the module file name 
                MAKE_ANSIPTR_FROMWIDE(name1A, szModName);
                _splitpath(name1A, NULL, NULL, rcFile1, NULL);
                char *pTemp = rcFile1;
                while (*pTemp != '\0')
                {   
                    *pTemp = tolower (*pTemp);
                    pTemp++;
                }
            }

            name = szModuleEnd+1;
        }

        // For each module, check if that class::method exists
        // and if it does, set a breakpoint on it
        for (DebuggerModule *m = (DebuggerModule *) 
             g_pShell->m_modules.FindFirst(&find);
            m != NULL;
            m = (DebuggerModule *) g_pShell->m_modules.FindNext(&find))
        {
            if (bModNameSpecified)
            {
                // the user has specified the module name.

                WCHAR *pszModName = m->GetName();
                if (pszModName == NULL)
                    pszModName = L"<UnknownName>";

                char        rcFile[MAX_PATH];

                MAKE_ANSIPTR_FROMWIDE(nameA, pszModName);
                _splitpath(nameA, NULL, NULL, rcFile, NULL);
                // convert the name to lowercase
                char *pTemp = rcFile;
                while (*pTemp != '\0')
                {   
                    *pTemp = tolower (*pTemp);
                    pTemp++;
                }
                
                if (strcmp (rcFile, rcFile1))
                    continue;
            }

            // Create a new breakpoint based on the provided information
            if (bFound)
            {
                breakpoint = new DebuggerBreakpoint(name,
                                        end - name, 
                                        index, thread);
                bUnused = true;
            }

            if (breakpoint != NULL)
            {
                if ((bFound = breakpoint->Bind(m, NULL))
                        == true)
                {
                    // Indicate that atleast one breakpoint was set
                    bAtleastOne = true;
                    bUnused = false;

                    g_pShell->OnBindBreakpoint(breakpoint, m);
                    breakpoint->Activate();
                    g_pShell->PrintBreakpoint(breakpoint);
                }
            }
            else
            {
                // out of memory
                g_pShell->ReportError(E_OUTOFMEMORY);
                break;
            }
        }

        if (bUnused == true)
            delete  breakpoint;

        return bAtleastOne;
    }

    // Name is filename:lineNumber
    BOOL    BindFilename (  WCHAR *name, 
                            const WCHAR *end, 
                            SIZE_T index, 
                            DWORD thread, 
                            DebuggerBreakpoint *breakpoint)
    {
        BOOL bAtleastOne = false;
        BOOL bFound = false;
        bool bUnused = false;
        HASHFIND find;
        HRESULT hr;

        // Convert the filename to lowercase letters
        WCHAR tmpName[MAX_PATH];
        wcscpy(tmpName, breakpoint->GetName());
        WCHAR *pstrName = tmpName;
        WCHAR *pstrTemp = pstrName;

        while (*pstrTemp)
        {
            *pstrTemp = towlower (*pstrTemp);
            pstrTemp++;
        }

        // First, try to match the string name as it is
        for (DebuggerModule *m = (DebuggerModule *) 
             g_pShell->m_modules.FindFirst(&find);
            m != NULL;
            m = (DebuggerModule *) g_pShell->m_modules.FindNext(&find))
        {
            ISymUnmanagedDocument *doc = NULL;

            // Create a new breakpoint based 
            // on the provided information
            if (bFound)
            {
                breakpoint = new DebuggerBreakpoint(name,
                                                    end - name, 
                                                    index, thread);
                bUnused = true;
            }

            if (breakpoint != NULL)
            {
                hr = m->MatchFullFileNameInModule (pstrName, &doc);

                bFound = false;

                if (SUCCEEDED (hr))
                {
                    if (doc != NULL)
                    {
                        // this means we found a source file 
                        // name in this module which exactly
                        // matches the user specified filename. 
                        // So set a breakpoint on this.
                        if (breakpoint->Bind(m, doc) == true)
                        {
                            // Indicate that atleast one breakpoint was set
                            bAtleastOne = true;
                            bFound = true;
                            bUnused = false;

                            g_pShell->OnBindBreakpoint(breakpoint, m);
                            breakpoint->Activate();
                            g_pShell->PrintBreakpoint(breakpoint);
                        }
                    }
                    else
                        continue;               
                }
            }
        }

        if (bAtleastOne == false)
        {
            // no file matching the user specified file was found.
            // Perform another search, this time using only the
            // stripped file name (minus the path) and see if that
            // has a match in some module

            // The way we'll proceed is:
            // 1. Find all matches for all modules.
            // 2. If there is only one match, set a breakpoint on it.
            // 3. Else more than one match found
            //    Ask the user to resolve the between the matched filenames and then 
            //    set breakpoints on the one he wants to.

            WCHAR   *rgpstrFileName [MAX_MODULES][MAX_FILE_MATCHES_PER_MODULE];
            ISymUnmanagedDocument *rgpDocs [MAX_MODULES][MAX_FILE_MATCHES_PER_MODULE];
            DebuggerModule *rgpDebugModule [MAX_MODULES];
            int iCount [MAX_MODULES]; // keeps track of number of filesnames in the module 
                                      // which matched the stripped filenanme
            int iCumulCount = 0;
            int iModIndex = 0;

            for (DebuggerModule *m = (DebuggerModule *) 
                 g_pShell->m_modules.FindFirst(&find);
                m != NULL;
                m = (DebuggerModule *) g_pShell->m_modules.FindNext(&find))
            {
                rgpDebugModule [iModIndex] = NULL;

                hr = m->MatchStrippedFNameInModule (pstrName,
                                                rgpstrFileName [iModIndex],
                                                rgpDocs [iModIndex],
                                                &iCount [iModIndex]
                                                );

                if (SUCCEEDED (hr) && iCount [iModIndex])
                {
                    iCumulCount += iCount [iModIndex];
                    rgpDebugModule [iModIndex] = m;
                }

                ++iModIndex;
                _ASSERTE (iModIndex < MAX_MODULES);
            }

            // Was a match found?
            if (iCumulCount)
            {
                int iInd;

                // if more than one match was found, then first filter 
                // out the duplicates. Duplicates may be present due to
                // multiple appdomains - if the same module is loaded in 
                // "n" appdomains, then there will be "n" modules as far
                // as cordbg is concerned.
                if (iCumulCount > 1)
                {
                    WCHAR **rgFName = new WCHAR *[iCumulCount];
                    int iTempNameIndex = 0;

                    if (rgFName != NULL)
                    {
                        for (iInd = 0; iInd < iModIndex; iInd++)
                        {
                            if (rgpDebugModule [iInd] != NULL)
                            {
                                int iTempCount = 0;
                                while (iTempCount < iCount [iInd])
                                {
                                    int j=0;
                                    boolean fMatchFound = false;
                                    while (j<iTempNameIndex)
                                    {
                                        if (!wcscmp(rgFName[j], 
                                                    rgpstrFileName [iInd][iTempCount]))
                                        {
                                            // this is a duplicate, so need to 
                                            // remove it from the list...
                                            for (int i=iTempCount; 
                                                i < (iCount [iInd]-1); 
                                                i++)
                                            {
                                                rgpstrFileName [iInd][i] = 
                                                        rgpstrFileName [iInd][i+1];
                
                                            }
                                            rgpstrFileName [iInd][i] = NULL;
                                            iCount [iInd]--;
                                            
                                            fMatchFound = true;

                                            break;

                                        }
                                        j++;
                                    }
                                    // if no match was found, then add this filename
                                    // to the list of unique filenames
                                    if (!fMatchFound)
                                    {   
                                        rgFName [iTempNameIndex++] =
                                                rgpstrFileName [iInd][iTempCount]; 
                                    }

                                    iTempCount++;
                                }
                            }
                        }

                        delete [] rgFName;
                        iCumulCount = iTempNameIndex;
                    }
                }

                // if there was only one match found,
                // then set a breakpoint on it
                if (iCumulCount == 1)
                {
                    for (iInd = 0; iInd<iModIndex; iInd++)
                        if (rgpDebugModule [iInd] != NULL)
                            break;

                    _ASSERT (iInd < iModIndex);
                    
                    if (breakpoint->Bind (rgpDebugModule [iInd],
                                    rgpDocs [iInd][0])  == true)
                    {
                        // Indicate that atleast one breakpoint
                        // was set
                        bAtleastOne = true;
                        bUnused = false;

                        // also update the breakpoint name from the 
                        // one that the user input to the one which 
                        // is stored in the module's meta data
                        breakpoint->UpdateName (rgpstrFileName [iInd][0]);

                        g_pShell->OnBindBreakpoint(breakpoint, m);
                        breakpoint->Activate();
                        g_pShell->PrintBreakpoint(breakpoint);

                    }
                }
                else
                {
                    // there were multiple matches. So get the user input
                    // on which ones he wants to set. 
                    // NOTE: User selection is 1-based, i.e., user enters "1"
                    // if he wants a breakpoint to be put on the first option shown
                    // to him.
                    int iUserSel = g_pShell->GetUserSelection (
                                                rgpDebugModule,
                                                rgpstrFileName,
                                                iCount,
                                                iModIndex,
                                                iCumulCount
                                                );

                    if (iUserSel == (iCumulCount+1))
                    {
                        // this means that the user wants a 
                        // breakpoint on all matched locations
                        for (iInd = 0; iInd < iModIndex; iInd++)
                        {
                            if (rgpDebugModule [iInd] != NULL)
                            {
                                for (int iTempCount = 0;
                                    iTempCount < iCount [iInd];
                                    iTempCount++)
                                {
                                    // Create a new breakpoint
                                    // based on the provided 
                                    // information
                                    if (bFound)
                                    {
                                        breakpoint = new DebuggerBreakpoint (
                                                            name, end - name, 
                                                                index, thread);

                                        bUnused = true;
                                    }

                                    if (breakpoint != NULL)
                                    {

                                        if ((bFound = breakpoint->Bind(
                                                rgpDebugModule [iInd],
                                                rgpDocs[iInd][iTempCount])
                                                ) == true)
                                        {
                                            // Indicate that atleast one
                                            // breakpoint was set
                                            bAtleastOne = true;
                                            if (bUnused == true)
                                                bUnused = false;
                                            breakpoint->UpdateName (
                                                    rgpstrFileName [iInd][iTempCount]);

                                            g_pShell->OnBindBreakpoint(breakpoint, m);
                                            breakpoint->Activate();
                                            g_pShell->PrintBreakpoint(breakpoint);

                                        }
                                    }
                                }
                            }
                        }

                    }
                    else
                    {
                        int iTempCumulCount = 0;

                        // locate the module which contains 
                        // the user specified breakpoint option
                        for (iInd = 0; iInd < iModIndex; iInd++)
                        {
                            if (rgpDebugModule [iInd] != NULL)
                            {
                                if ((iTempCumulCount + iCount [iInd])
                                        >= iUserSel)
                                {
                                    // found the module. Now 
                                    // calculate the file index
                                    // within this module.
                                    // Reuse iTempCumulCount
                                    iTempCumulCount = 
                                        iUserSel - iTempCumulCount - 1; // "-1" since it is 1 based

                                    if (breakpoint->Bind(
                                            rgpDebugModule [iInd],
                                            rgpDocs [iInd][iTempCumulCount]
                                            )
                                            == true)
                                    {
                                        // Indicate that atleast
                                        // one breakpoint was set
                                        bAtleastOne = true;
                                        if (bUnused == true)
                                            bUnused = false;

                                        breakpoint->UpdateName (
                                                rgpstrFileName [iInd][iTempCumulCount]);

                                        g_pShell->OnBindBreakpoint(breakpoint, m);
                                        breakpoint->Activate();
                                        g_pShell->PrintBreakpoint(breakpoint);
                                    }

                                    break;
                                }

                                iTempCumulCount += iCount [iInd];
                            }

                        }

                        _ASSERT (iInd < iModIndex);
                    }

                }
            }
                
        }

        if (bUnused)
            delete breakpoint;

        return bAtleastOne;
    }




    // Helper function to parse the arguments, the format being
    // [[<file>:]<line no>] [[<class>::]<function>[:offset]]
    //      [if <expression>] [thread <id>]
    // and the modifiers are 'if' and 'thread'
    bool GetModifiers(DebuggerShell *shell, 
                      const WCHAR *&args, DWORD &thread, WCHAR *&expression)
    {
        thread = NULL_THREAD_ID;
        expression = NULL;

        const WCHAR *word;

        while (shell->GetStringArg(args, word) == 0)
        {
            if (wcsncmp(word, L"if", 1) == 0)
            {
                if (!shell->GetStringArg(args, expression))
                    return (false);
            }
            else if (wcsncmp(word, L"thread", 6) == 0)
            {
                int ithread;
                if (!shell->GetIntArg(args, ithread))
                    return (false);
                thread = ithread;
            }
            else
                break;
        }
        return (true);
    }


    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        DWORD thread = NULL;
        WCHAR *expression;
        DebuggerBreakpoint *breakpoint = NULL;
        BOOL bAtleastOne = false;

        // Display all current breakpoints
        if (*args == 0)
        {
            // Iterate through all used IDs, and print out the info
            // for each one that maps to an breakpoint.
            for (DWORD i = 0; i <= shell->m_lastBreakpointID; i++)
            {
                breakpoint = shell->FindBreakpoint(i);
                if (breakpoint != NULL)
                    shell->PrintBreakpoint(breakpoint);
            }

            return;
        }

        // If a number is provided, break at that line number in the current
        // source file
        else if (iswdigit(*args))
        {
            // The line to create the breakpoint for.
            int lineNumber;

            // Check that there is an active frame
            if (shell->m_currentFrame == NULL)
            {
                shell->Error(L"No current source file to set breakpoint in.\n");
                return;
            }
            
            // Get the line number and any modifiers
            if (shell->GetIntArg(args, lineNumber)
                && GetModifiers(shell, args, thread, expression))
            {
                // Lookup the current source file. Assumes that if command is
                // just given a line number the current source file is implied.

                HRESULT hr;
                ICorDebugCode *icode;
                ICorDebugFunction *ifunction;
                ULONG32 ip;

                // Get the code from the current frame, and then get the function
                hr = shell->m_currentFrame->GetCode(&icode);
                
                // Error check
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }
                
                hr = icode->GetFunction(&ifunction);
                
                // Error check
                if (FAILED(hr))
                {
                    RELEASE(icode);
                    shell->ReportError(hr);
                    return;
                }

                DebuggerFunction *function 
                    = DebuggerFunction::FromCorDebug(ifunction);
                _ASSERTE(function);

                // Release the interfaces
                RELEASE(icode);
                RELEASE(ifunction);

                // Get the IP of the current frame
                CorDebugMappingResult mappingResult;
                shell->m_currentFrame->GetIP(&ip, &mappingResult);

                // Now get the source file and current line number
                DebuggerSourceFile *sf;
                unsigned int currentLineNumber;

                // Find the line number corresponding to the IP
                hr = function->FindLineFromIP(ip, &sf, &currentLineNumber);

                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    return;
                }

                // If there is no associated source file, or we explicitly don't
                // want to display source
                if (sf == NULL || !shell->m_showSource)
                {
                    _ASSERTE(function->m_name != NULL);

                    // Make sure the line provided is valid
                    if (function->ValidateInstruction(function->m_nativeCode != NULL, 
                                                      lineNumber))
                    {
                        breakpoint = new DebuggerBreakpoint(function,
                            lineNumber, thread);

                        //Out of memory
                        if (breakpoint == NULL)
                        {
                            shell->ReportError(E_OUTOFMEMORY);
                            return;
                        }
                    }
                    else
                        shell->Error(L"%d is not a valid instruction"
                                     L" offset in %s\n", 
                                     lineNumber, function->m_name);
                }

                // Set the breakpoint by line number within the current
                // functions source file.
                else
                {
                    // Can't set a bp on source line 0...
                    if (lineNumber == 0)
                    {
                        shell->Error(L"0 is not a valid source line "
                                     L"number.\n");
                        return;
                    }
                    
                    // Find the closest valid source line number
                    unsigned int newLineNumber = 
                        sf->FindClosestLine(lineNumber, true);

                    _ASSERTE(newLineNumber != 0);

                    // If the line number was invalid, print out the new line
                    if (newLineNumber != lineNumber)
                    {
                        shell->Error(L"No code at line %d, setting "
                                     L" breakpoint at line %d.\n", 
                                     lineNumber, newLineNumber);
                    }

                    // Create a breakpoint
                    breakpoint = new DebuggerBreakpoint(sf, newLineNumber, 
                                                        thread);

                    if (breakpoint == NULL)
                    {
                        shell->ReportError(E_OUTOFMEMORY);
                        return;
                    }
                }
            }
        }
        else if (*args == L'=')
        {
            // A equals sign indicates an absolute address to set an
            // unmanaged breakpoint at.
            args++;
            
            const WCHAR *name = args;
            int addr;
            
            shell->GetIntArg(args, addr);

            // Create a new breakpoint based on the provided information
            if ((breakpoint = new DebuggerBreakpoint(name,
                                                     wcslen(name), 
                                                     0,
                                                     NULL_THREAD_ID)) != NULL)
            {
                breakpoint->m_address = addr; // Remember the address...
                
                if (breakpoint->BindUnmanaged(g_pShell->m_currentProcess))
                    g_pShell->OnBindBreakpoint(breakpoint, NULL);
                
            }
        }
        
        // A fully-described breakpoint is provided, by file:linenumber or 
        // classname::function:offset
        else
        {
            WCHAR *name;

            // Get either the file name or the class/function name
            if (shell->GetStringArg(args, name)
                && GetModifiers(shell, args, thread, expression))
            {
                int index = 0;
                const WCHAR *end = args;

                for (WCHAR *p = name; p < end-1; p++)
                {
                    if (p[0] == L':' && iswdigit(p[1]))
                    {
                        end = p;
                        p++;
                        shell->GetIntArg(p, index);
                        break;
                    }
                }

                // Create a new breakpoint based on the provided information
                if ((breakpoint = new DebuggerBreakpoint(name, end - name, 
                                index, thread)) != NULL)
                {

                // Determine if it's a class::method or filename:linenumber

                    WCHAR *classEnd = wcschr(breakpoint->GetName(), L':');
                    if (classEnd != NULL && classEnd[1] == L':')
                    {
                        bAtleastOne = BindClassFunc (name, end, index, thread, breakpoint);
                    }
                    else
                    {
                        bAtleastOne = BindFilename (name, end, index, thread, breakpoint);
                    }

                    if (!bAtleastOne)
                    {
                        // this means that the user specified string didn't match any Class::method
                        // or any filename in any of the loaded modules. So do the following:
                        if (breakpoint->BindUnmanaged(g_pShell->m_currentProcess))
                            g_pShell->OnBindBreakpoint(breakpoint, NULL);
                    }
                }
                else
                {
                    // out of memory!!
                    g_pShell->ReportError(E_OUTOFMEMORY);
                }
            }

        }

        if (breakpoint == NULL)
            Help(shell);
        else
        {
            if (!bAtleastOne)
            {
                breakpoint->Activate();
                shell->PrintBreakpoint(breakpoint);
            }
        }
    }


    // Provide help specific to this command
    void Help(Shell *shell)
    {      
        ShellCommand::Help(shell);
        shell->Write(L"[[<file>:]<line number>] |\n"); 
        shell->Write(L"               [[<class>::]<function>[:offset]] |\n");
        shell->Write(L"               [=0x<address>]\n");
        shell->Write(L"Sets or displays breakpoints. If no arguments are passed, a list of\n");
        shell->Write(L"current breakpoints is displayed; otherwise, a breakpoint is set at\n");
        shell->Write(L"the specified location. A breakpoint can be set at a line number in\n");
        shell->Write(L"the current source file, a line number in a fully qualified source\n");
        shell->Write(L"file, or in a method qualified by a class and optional offset. All\n");
        shell->Write(L"breakpoints persist across runs in a session. The stop command is an\n"); 
        shell->Write(L"alias of the break command.\n");
        shell->Write(L"\n");
        shell->Write(L"Note: Setting a breakpoint at an address (for Win32 mode, managed and\n");
        shell->Write(L"unmanaged, debugging) is not officially supported in CorDbg. Breakpoints\n");
        shell->Write(L"will be displayed as \"unbound\" if the breakpoint location you specified\n");
        shell->Write(L"cannot be bound to code. When a breakpoint is unbound, it means that the\n");
        shell->Write(L"underlying code for the breakpoint location has not been loaded yet. This\n"); 
        shell->Write(L"can happen for a number of valid reasons, such as misspelling the file or\n"); 
        shell->Write(L"class name (they are case-sensitive).\n");
        shell->Write(L"\n");        
        shell->Write(L"Examples:\n");
        shell->Write(L"   b 42\n");
        shell->Write(L"   b foo.cpp:42\n");
        shell->Write(L"   b MyClass::MyFunc\n");
        shell->Write(L"   b =0x77e861d4 (Note: win32 mode only!)\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Set or display breakpoints";
    }
};

class RemoveBreakpointDebuggerCommand : public DebuggerCommand
{
public:
    RemoveBreakpointDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // If no argument, remove all breakpoints
        if (*args == NULL)
        {
            shell->Write(L"Removing all breakpoints.\n");
            shell->RemoveAllBreakpoints();
        }
        else
        {
            while (*args != NULL)
            {
                int id;

                // Get the breakpoint ID to remove
                if (shell->GetIntArg(args, id))
                {
                    // Find the breakpoint by ID
                    DebuggerBreakpoint *breakpoint = shell->FindBreakpoint(id);

                    // Indicate that the ID provided was invalid
                    if (breakpoint == NULL)
                        shell->Error(L"Invalid breakpoint %d.\n", id);

                    // Otherwise, deactivate the breakpoint and delete it
                    else
                    {
                        breakpoint->Deactivate();

                        if (breakpoint->m_skipThread != 0)
                            breakpoint->m_deleteLater = true;
                        else
                            delete breakpoint;
                    }
                }

                // If the user provided something other than a number
                else
                {
                    Help(shell);
                    break;
                }
            }
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
        ShellCommand::Help(shell);
    	shell->Write(L"[<breakpoint id>, ...]\n");
        shell->Write(L"Removes breakpoints. If no arguments are passed,\n");
        shell->Write(L"all current breakpoints are removed. If one or more\n");
        shell->Write(L"arguments are provided, the specified breakpoint(s)\n");
        shell->Write(L"are removed. Breakpoint identifiers can be obtained\n");
        shell->Write(L"using the break or stop command. The delete command\n");
        shell->Write(L"is an alias of the remove command.\n");        
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Remove one or more breakpoints";
    }
};

class ThreadsDebuggerCommand : public DebuggerCommand
{

public:
    ThreadsDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // If there is no process, there must be no threads!
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current process.\n");
            return;
        }

        // Display the active threads
        if (*args == 0)
        {
            HRESULT hr;
            ICorDebugThreadEnum *e;
            ICorDebugThread *ithread = NULL;

            // Enumerate the process' threads
            hr = shell->m_currentProcess->EnumerateThreads(&e);

            if (FAILED(hr))
            {
                shell->ReportError(hr);
                return;
            }

            ULONG count;  // indicates how many records were retrieved

            hr = e->GetCount(&count);
            if (FAILED(hr))
            {
                shell->ReportError(hr);
                return;
            }

            // Alert user if there's no threads. This may happen if we stop
            // in a debugger callback before any managed threads are created/
            // before any managed code is executed.
            if (count == 0)
            {
                shell->Write(L"There are no managed threads\n");
                return;
            }

            // Print out information for each thread
            for (hr = e->Next(1, &ithread, &count);
                 count == 1;
                 hr = e->Next(1, &ithread, &count))
            {
                // If the call to Next fails...
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    RELEASE(e);
                    return;
                }

                // Indicate the current thread
                if (ithread == shell->m_currentThread)
                    shell->Write(L"*");
                else
                    shell->Write(L" ");

            // Print thread info
                shell->PrintThreadState(ithread);

                // And release the iface pointer
                RELEASE(ithread);
            }

            if (FAILED(hr))
            {
                shell->ReportError(hr);
                return;
            }

            // Release the enumerator
            RELEASE(e);
        }

        // Otherwise, switch current thread
        else
        {
            HRESULT hr;
            int tid;

            if (shell->GetIntArg(args, tid))
            {
                ICorDebugThread *thread;

                // Get the thread by ID
                hr = shell->m_currentProcess->GetThread(tid, &thread);

                // No such thread
                if (FAILED(hr))
                    shell->Write(L"No such thread.\n");

                // Thread found, display info
                else
                {
                    shell->SetCurrentThread(shell->m_currentProcess, thread);
                    shell->SetDefaultFrame();
                    shell->PrintThreadState(thread);
                    thread->Release();
                }
            }
            else
                shell->Write(L"Invalid thread id.\n");
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[<tid>]\n");
        shell->Write(L"Displays a list of threads or sets the current thread.\n");
        shell->Write(L"If no argument is passed, the list of all threads that\n");
        shell->Write(L"are still alive and that have run managed code is displayed.\n");
        shell->Write(L"If a tid argument is provided, then the current thread\n");
        shell->Write(L"is set to the specified thread.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Set or display current threads";
    }
};

class WhereDebuggerCommand : public DebuggerCommand
{
private:
    int m_lastcount;
public:
    WhereDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength), m_lastcount(10)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        HRESULT hr = S_OK;
        ULONG count;
        int iNumFramesToShow;

        // If there is no process, cannot execute this command
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current process.\n");
            return;
        }

        if (!shell->GetIntArg(args, iNumFramesToShow))
            iNumFramesToShow = m_lastcount;
		else
		{
			if (iNumFramesToShow < 0)
				iNumFramesToShow = m_lastcount;
            else
                m_lastcount = iNumFramesToShow;
		}

        m_lastcount = iNumFramesToShow;

        // Get a pointer to the current thread
        ICorDebugThread *ithread = shell->m_currentThread;

        // If there is no current thread, cannot perform command
        if (ithread == NULL)
        {
            if (shell->m_currentUnmanagedThread != NULL)
            {
                HANDLE hProcess;
                hr = shell->m_currentProcess->GetHandle(&hProcess);

                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                shell->TraceUnmanagedThreadStack(
                                           hProcess,
                                           shell->m_currentUnmanagedThread,
                                           TRUE);
                return;
            }
            else
                shell->Write(L"Thread no longer exists.\n");

            return;
        }

        // Get the thread ID
        DWORD id;
        hr = ithread->GetID(&id);

        if (FAILED(hr))
        {
            shell->ReportError(hr);
            return;
        }

        CorDebugUserState us;
        hr = ithread->GetUserState(&us);

        if (FAILED(hr))
        {
            shell->ReportError(hr);
            return;
        }

        // Output thread ID, state
        shell->Write(L"Thread 0x%x Current State:%s\n", id,
                     shell->UserThreadStateToString(us));

        int i = 0;
        
        // Enumerate the chains
        int frameIndex = 0;
    
        ICorDebugChainEnum  *ce;
        ICorDebugChain      *ichain;
        hr = ithread->EnumerateChains(&ce);

        if (FAILED(hr))
        {
            shell->ReportError(hr);
            return;
        }

        // Get the first chain in the enumeration
        hr = ce->Next(1, &ichain, &count);
        
        if (FAILED(hr))
        {
            shell->ReportError(hr);
            RELEASE(ce);
            return;
        }

        while ((count == 1) && (iNumFramesToShow > 0))
        {
            shell->PrintChain(ichain, &frameIndex, &iNumFramesToShow);
            RELEASE(ichain);

            hr = ce->Next(1, &ichain, &count);

            if (FAILED(hr))
            {
                shell->ReportError(hr);
                RELEASE(ce);
                return;
            }
        }

        // Done with the chain enumerator
        RELEASE(ce);

        shell->Write(L"\n");
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
   		ShellCommand::Help(shell);
    	shell->Write(L"[<count>]\n");
        shell->Write(L"Displays a stack trace for the current thread. If a count argument is provided, the\n");
        shell->Write(L"specified number of stack frames are displayed. If no count is provided then 10 frames \n");
        shell->Write(L"are displayed or if a count was previously provided then it is used instead.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display a stack trace for the current thread";
    }
};

class ShowDebuggerCommand : public DebuggerCommand
{
private:
    // Keep track of the last argument
    int lastCount;

public:
    ShowDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength), lastCount(5)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // If there is no process, cannot execute this command
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current process.\n");
            return;
        }

        int count;

        // If no argument, use last count
        if (!shell->GetIntArg(args, count))
            count = lastCount;
        else
            lastCount = count;

        // Print the current source line, and count line above and below
        BOOL ret = shell->PrintCurrentSourceLine(count);

        // Report if unsuccessful
        if (!ret)
            shell->Write(L"No source code information available.\n");

        shell->m_showSource = true;
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[<count>]\n");
        shell->Write(L"Displays source code line(s). If no argument is\n");
        shell->Write(L"passed, the five source code lines before and after\n");
        shell->Write(L"the current source code line are displayed. If a count\n");
        shell->Write(L"argument is provided, the specified number of lines\n");
        shell->Write(L"before and after the current line is displayed. The\n");
        shell->Write(L"last count specified becomes the default for the\n");
        shell->Write(L"current session.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display source code lines";
    }
}; 


class PathDebuggerCommand : public DebuggerCommand
{
public:
    PathDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        WCHAR* newPath = NULL;
        HKEY key;

        shell->GetStringArg(args, newPath);

        int iLength = wcslen (newPath);

		while(iLength && newPath[iLength - 1] == L' ')
		{
			iLength --;
			newPath[iLength] = '\0';
		}

        if (iLength != 0)
        {
            // If there is no program executing, then set the 
            // global path in the registry
            if (shell->m_lastRunArgs == NULL)
            {
                // Set the new path, and save it in the registry
                if (shell->OpenDebuggerRegistry(&key))
                {
                    if (shell->WriteSourcesPath(key, newPath))
                    {
                        // Delete the previous path
                        delete [] shell->m_currentSourcesPath;

                        // Attempt to read what was just written
                        if (!(shell->ReadSourcesPath(key,
                                                     &(shell->m_currentSourcesPath))))
                        {
                            shell->Error(L"Path not set!\n");
                            shell->m_currentSourcesPath = NULL;
                            return;
                        }
                    }
                    else
                        shell->Error(L"Path not set!\n");

                    // Close the registry key
                    shell->CloseDebuggerRegistry(key);
                }
            }

            shell->UpdateCurrentPath (newPath);
        }

        // Display new path
        if (shell->m_currentSourcesPath)
            shell->Write(L"Path: %s\n", shell->m_currentSourcesPath);
        else
            shell->Write(L"Path: none\n");
    }
    // Provide help specific to this command
    void Help(Shell *shell)
    {
   		ShellCommand::Help(shell);
    	shell->Write(L"[<path>]\n");
        shell->Write(L"Displays the path used to search for source files (and symbols)\n");
        shell->Write(L"or sets the path. If no argument is passed, the\n");
        shell->Write(L"current source file path is displayed. If a path\n");
        shell->Write(L"argument is specified, it becomes the new path used\n");
        shell->Write(L"to search for source files (and symbols). This path is persisted\n");
        shell->Write(L"between sessions in the Windows registry.\n"); 
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Set or display the source file search path";
    }
};

class RefreshSourceDebuggerCommand : public DebuggerCommand
{
public:
    RefreshSourceDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // Get the file name to refresh
        WCHAR* fileName = NULL;
        shell->GetStringArg(args, fileName);

        // If a file name was provided
        if (wcslen(fileName) != 0)
        {
            // Look for the source file
            DebuggerSourceFile* sf = shell->LookupSourceFile(fileName);

            // If the source file is found, reload the text
            if (sf != NULL)
            {
                // Reload the text and print the current source line
                if (sf->ReloadText(shell->m_currentSourcesPath, false))
                    shell->PrintCurrentSourceLine(0);

                // Else if the file no longer exists, say so
                else
                    shell->Error(L"No source code information "
                                 L"available for file %s.\n", fileName);
            }

            // Indicate that the file is not found
            else
                shell->Error(L"File %s is not currently part of this program.\n",
                             fileName);
        }
        else
            Help(shell);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
   		ShellCommand::Help(shell);
    	shell->Write(L"[<source file>]\n");
        shell->Write(L"Reloads the source code for a given source file. The\n");
        shell->Write(L"source file to be reloaded must be part of the currently\n");
        shell->Write(L"executing program. After setting a source file path with\n");
        shell->Write(L"the path command, this command can be used to bring in\n");
        shell->Write(L"the new source code.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Reload a source file for display";
    }
};

class PrintDebuggerCommand : public DebuggerCommand
{
public:
    PrintDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // If there is no process, cannot execute this command
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current process.\n");
            return;
        }

        WCHAR wsz[40];
        ICorDebugThread *thread = shell->m_currentThread;

        ICorDebugILFrame *f = NULL;
        ICorDebugCode *icode = NULL;
        ICorDebugFunction *ifunction = NULL;
        ICorDebugValueEnum *pArgs = NULL;
        ICorDebugValueEnum *pLocals = NULL;
        
        if (thread == NULL)
        {
            shell->Write(L"Thread no longer exists.\n");
            return;
        }

        // Get the name of the variable to print.
        WCHAR* exp = NULL;
        shell->GetStringArg(args, exp);

        // If a name is provided, 
        if (args - exp > 0)
        {
            // Make a copy of the variable name to print
            CQuickBytes expBuf;
            WCHAR *expAlloc = (WCHAR *) expBuf.Alloc((args - exp + 1) *
                                                      sizeof (WCHAR));
            if (expAlloc == NULL)
            {
                shell->Error(L"Couldn't get enough memory to copy the expression!\n");
                return;
            }
            wcsncpy(expAlloc, exp, args - exp);
            expAlloc[args - exp] = L'\0';

            // Get the value for the name provided.
            ICorDebugValue *ivalue;
            ivalue = shell->EvaluateExpression(expAlloc,
                                               shell->m_currentFrame,
                                               true);

            // If the name provided is valid, print it!
            if (ivalue != NULL)
                shell->PrintVariable(expAlloc, ivalue, 0, TRUE);
            else
            {
                // Bummer... maybe its a global?
                bool fFound = shell->EvaluateAndPrintGlobals(expAlloc);

                if (!fFound)
                    shell->Write(L"Variable unavailable, or not valid\n");
            }
        }
        else
        {
            // Load up the info we need to search for locals.
            HRESULT hr;

            // Get the current frame
            f = shell->m_currentFrame;

            if (f == NULL)
            {
                if (shell->m_rawCurrentFrame == NULL)
                    shell->Error(L"No current managed IL frame.\n");
                else
                    shell->Error(L"The information needed to display "
                                 L"variables is not available.\n");
                goto LExit;
            }
            
            // Get the code for the current frame
            hr = f->GetCode(&icode);

            if (FAILED(hr))
            {
                shell->ReportError(hr);
                goto LExit;
            }

            // Then get the function
            hr = icode->GetFunction(&ifunction);

            if (FAILED(hr))
            {
                shell->ReportError(hr);
                goto LExit;
            }

            // Now get the IP for the start of the function
            ULONG32 ip;
            CorDebugMappingResult mappingResult;
            hr = f->GetIP(&ip, &mappingResult);

            if (FAILED(hr))
            {
                shell->ReportError(hr);
                goto LExit;
            }

            // Get the DebuggerFunction for the function iface
            DebuggerFunction *function;
            function = DebuggerFunction::FromCorDebug(ifunction);
            _ASSERTE(function);

            // Clean up
            RELEASE(icode);
            icode = NULL;
            RELEASE(ifunction);
            ifunction = NULL;

            hr = f->EnumerateArguments( &pArgs );
            if ( !SUCCEEDED( hr ) )
            {
                shell->Write( L"Unable to obtain method argument iterator!\n" );
                goto LExit;
            }
            
            unsigned int i;
            ULONG argCount;
            hr = pArgs->GetCount(&argCount);
            if( !SUCCEEDED( hr ) )
            {
                shell->Write(L"Unable to obtain a count of arguments\n");
                goto LExit;
            }

#ifdef _DEBUG
            bool fVarArgs;
            PCCOR_SIGNATURE sig;
            ULONG callConv;

            fVarArgs = false;
            sig = function->GetSignature();
            callConv = CorSigUncompressCallingConv(sig);

            if ( (callConv & IMAGE_CEE_CS_CALLCONV_MASK)&
                 IMAGE_CEE_CS_CALLCONV_VARARG)
                fVarArgs = true;

             ULONG cTemp;
             cTemp = function->GetArgumentCount();

             // Var Args functions have call-site-specific numbers of
             // arguments
            _ASSERTE( argCount == cTemp || fVarArgs);
#endif //_DEBUG

            // Print out each argument first
            LPWSTR nameWsz;
            for (i = 0; i < argCount; i++)
            {
                DebuggerVarInfo* arg = function->GetArgumentAt(i);

                //@TODO: Remove when DbgMeta becomes Unicode
                if (arg != NULL)
                {
                    MAKE_WIDEPTR_FROMUTF8(nameW, arg->name);
                    nameWsz = nameW;
                }
                else
                {
                    wsprintf( wsz, L"Arg%d", i );
                    nameWsz = wsz;
                }

                // Get the field value
                ICorDebugValue *ival;
                ULONG celtFetched = 0;
                hr = pArgs->Next(1, &ival,&celtFetched);

                // If successful, print the variable
                if (SUCCEEDED(hr) && celtFetched==1)
                {
                    shell->PrintVariable(nameWsz, ival, 0, FALSE);
                }

                // Otherwise, indicate that it is unavailable
                else
                    shell->Write(L"%s = <unavailable>", nameWsz);

                shell->Write(L"\n");
            }

            pArgs->Release();
            pArgs = NULL;
            
            // Get the active local vars
            DebuggerVariable *localVars;
            unsigned int localVarCount;

            localVarCount = 0;
            localVars = NULL;

            if( function->GetActiveLocalVars(ip, &localVars, &localVarCount) )
            {
                // Print all the locals in the current scope.
                for (i = 0; i < localVarCount; i++)
                {
                    // Get the argument info
                    DebuggerVariable *local = &(localVars[i]);

                    // Get the field value
                    ICorDebugValue* ival;
                    hr = f->GetLocalVariable(local->m_varNumber, &ival);

                    // If successful, print the variable
                    if (SUCCEEDED(hr) )
                        shell->PrintVariable(local->m_name, ival, 0, FALSE);
                
                    // Otherwise, indicate that it is unavailable
                    else
                        shell->Write(L"%s = <unavailable>", local->m_name);

                    shell->Write(L"\n");
                }
            
                // Cleanup
                delete [] localVars;

                // Indicate if no vars available.
                if ((function->IsStatic()) && (localVarCount == 0) &&
                    (function->GetArgumentCount() == 0))
                    shell->Write(L"No local variables in scope.\n");
            }
            else
            {
                // No vars in scope, so dump all
                // local variables, regardless of validity,etc.
                hr = f->EnumerateLocalVariables( &pLocals );
                if ( !SUCCEEDED( hr ) )
                {
                    shell->Write( L"Unable to enumerate local variables!\n" );
                    goto LExit;
                }

                _ASSERTE( pLocals != NULL );

                ULONG cAllLocalVars = 0;
                hr =pLocals->GetCount( &cAllLocalVars );
                if ( !SUCCEEDED( hr ) )
                {
                    shell->Write( L"Unable to obtain count of local variables!\n");
                    goto LExit;
                }
                
                ICorDebugValue* ival = NULL;
                ULONG celtFetched = 0;
                for ( ULONG i = 0; i < cAllLocalVars; i++)
                {
                    _ASSERTE( pLocals != NULL );
                    hr = pLocals->Next( 1, &ival, &celtFetched );
                    if ( FAILED( hr ) )
                    {
                        shell->Write( L"Var %d: Unavailable\n", i );
                    }
                    else
                    {
                        wsprintf( wsz, L"Var%d: ", i );
                        shell->PrintVariable( wsz, ival, 0, FALSE);
                        shell->Write( L"\n" );
                        //PrintVariable will Release ival for us
                    }
                }
                pLocals->Release();
                pLocals = NULL;
            }

LExit:
            // Print any current func eval result.
            ICorDebugValue *pResult;
            pResult = shell->EvaluateExpression(L"$result",
                                                shell->m_currentFrame,
                                                true);

            if (pResult != NULL)
            {
                shell->PrintVariable(L"$result", pResult, 0, FALSE);
                shell->Write( L"\n" );
            }

            // Print the current thread object
            pResult = shell->EvaluateExpression(L"$thread",
                                                shell->m_currentFrame,
                                                true);

            if (pResult != NULL)
            {
                shell->PrintVariable(L"$thread", pResult, 0, FALSE);
                shell->Write( L"\n" );
            }

            // Print any current exception for this thread.
            pResult = shell->EvaluateExpression(L"$exception",
                                                shell->m_currentFrame,
                                                true);

            if (pResult != NULL)
            {
                shell->PrintVariable(L"$exception", pResult, 0, FALSE);
                shell->Write( L"\n" );
            }
        }
        
        shell->Write(L"\n");

        if (icode != NULL )
            RELEASE( icode );

        if (ifunction != NULL )
            RELEASE( ifunction );

        if (pArgs != NULL )
            RELEASE( pArgs );
        
        if(pLocals != NULL)
            RELEASE(pLocals);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
   		ShellCommand::Help(shell);
    	shell->Write(L"[<variable>]\n");
        shell->Write(L"Displays one or more local variables along with\n");
        shell->Write(L"their values. If no argument is passed, all local\n");
        shell->Write(L"variables and their values are displayed. If a\n");
        shell->Write(L"variable argument is provided, the value of only\n");
        shell->Write(L"the specified local variable is displayed.\n");
        shell->Write(L"Examples:\n");
        shell->Write(L"  Variables within objects can be specified using\n");
        shell->Write(L"  dot notation, as follows:\n");
        shell->Write(L"     p obj.var1\n");
		shell->Write(L"     p obj1.obj2.var1\n");
        shell->Write(L"\n");
        shell->Write(L"  If a class extends another class, the print command\n");
        shell->Write(L"  will show both the specified class's fields and the\n");
        shell->Write(L"  super class's fields. For example, if class m1 has\n");
        shell->Write(L"  fields a, b, and c and class m2 extends m1 and has\n");
        shell->Write(L"  fields d, e, and f, then an instance foo of m2 will\n");
        shell->Write(L"  print as follows:\n");
		shell->Write(L"     foo = <addr> <m2>\n");
		shell->Write(L"       a = 1\n");
      	shell->Write(L"       b = 2\n");
      	shell->Write(L"       c = 3\n");
      	shell->Write(L"       m2::d = 4\n");
      	shell->Write(L"       m2::e = 5\n");
      	shell->Write(L"       m2::f = 6\n");
        shell->Write(L"\n");
        shell->Write(L"  Class static variables can be specified by prefixing\n");
        shell->Write(L"  the variable name with the class name, as follows:\n");
        shell->Write(L"     p MyClass::StaticVar1\n");
		shell->Write(L"     p System::Boolean::True\n");
        shell->Write(L"\n");
        shell->Write(L"  Array indices must be simple expressions. Thus, the\n");
        shell->Write(L"  following array indices are valid for use with the\n");
        shell->Write(L"  print command:\n");
		shell->Write(L"     p arr[1]\n");
		shell->Write(L"     p arr[i]\n");
		shell->Write(L"     p arr1[arr2[1]]\n");
		shell->Write(L"     p md[1][5][foo.a]\n");
        shell->Write(L"\n");
        shell->Write(L"  However, the following array indices cannot be used\n"); 
        shell->Write(L"  with the print command:\n");
        shell->Write(L"     p arr[i + 1]\n");
        shell->Write(L"     p arr[i + 2]\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Print variables (locals, args, statics, etc.)";
    }
};

class UpDebuggerCommand : public DebuggerCommand
{
public:
    UpDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // If there is no process, cannot execute this command
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current process.\n");
            return;
        }

        int count;

        if (!shell->GetIntArg(args, count))
            count = 1;
        else
        {
            if (count < 0)
                count = 1;
        }

        if (shell->m_currentThread == NULL)
        {
            shell->Write(L"Thread no longer exists.\n");
            return;
        }

        shell->m_stopLooping = false;
        while (count-- > 0 && !shell->m_stopLooping)
        {
            bool goUpAChain = false;
            
            if (shell->m_rawCurrentFrame != NULL)
            {
                ICorDebugFrame *iframe;
                HRESULT hr = shell->m_rawCurrentFrame->GetCaller(&iframe);

                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                if (iframe != NULL)
                {
                    shell->SetCurrentFrame(iframe);

                    RELEASE(iframe);
                }
                else
                    goUpAChain = true;
            }

            if ((shell->m_rawCurrentFrame == NULL) || goUpAChain)
            {
                if (shell->m_currentChain != NULL)
                {
                    ICorDebugChain *ichain;

                    HRESULT hr = shell->m_currentChain->GetCaller(&ichain);

                    if (FAILED(hr))
                    {
                        shell->ReportError(hr);
                        return;
                    }

                    if (ichain == NULL)
                    {
                        shell->Error(L"Cannot go up farther: "
                                     L"at top of call stack.\n");
                        break;
                    }

                    ICorDebugFrame *iframe;

                    hr = ichain->GetActiveFrame(&iframe);

                    if (FAILED(hr))
                    {
                        shell->ReportError(hr);
                        RELEASE(ichain);
                        return;
                    }

                    shell->SetCurrentChain(ichain);
                    shell->SetCurrentFrame(iframe);

                    RELEASE(ichain);
                    if (iframe != NULL)
                        RELEASE(iframe);

                }
                else
                    shell->Error(L"No stack trace for thread.");
            }
        }

        // Print where we ended up
        if (!shell->PrintCurrentSourceLine(0))
            shell->PrintThreadState(shell->m_currentThread);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
   		ShellCommand::Help(shell);
       	shell->Write(L"[<count>]\n");
        shell->Write(L"For inspection purposes, moves the stack frame pointer\n");
        shell->Write(L"up the stack toward frames that called the current stack\n");
        shell->Write(L"frame. If no argument is passed, the stack frame pointer\n"); 
        shell->Write(L"moves up one frame. If a count argument is provided, the\n"); 
        shell->Write(L"stack frame pointer moves up by the specified number of\n"); 
        shell->Write(L"frames. If source level information is available, the source\n"); 
        shell->Write(L"line for the frame is displayed.\n"); 
        shell->Write(L"\n"); 
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Navigate up from the current stack frame pointer";
    }
};

class DownDebuggerCommand : public DebuggerCommand
{
public:
    DownDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
      : DebuggerCommand(name, minMatchLength)
    {
        
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // If there is no process, cannot execute this command
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current process.\n");
            return;
        }

        int iCount;

        if (!shell->GetIntArg(args, iCount))
            iCount = 1;
        else
        {
            if (iCount < 0)
                iCount = 1;
        }

        if (shell->m_currentThread == NULL)
        {
            shell->Write(L"Thread no longer exists.\n");
            return;
        }

        shell->m_stopLooping = false;
        while (iCount-- > 0 && !shell->m_stopLooping)
        {
            bool goDownAChain = false;
            
            if (shell->m_rawCurrentFrame != NULL)
            {
                ICorDebugFrame *iframe;

                HRESULT hr = shell->m_rawCurrentFrame->GetCallee(&iframe);

                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }

                if (iframe != NULL)
                {
                    shell->SetCurrentFrame(iframe);

                    RELEASE(iframe);
                }
                else
                    goDownAChain = true;
            }

            if ((shell->m_rawCurrentFrame == NULL) || goDownAChain)
            {
                if (shell->m_currentChain != NULL)
                {
                    ICorDebugChain *ichain;

                    HRESULT hr = shell->m_currentChain->GetCallee(&ichain);

                    if (FAILED(hr))
                    {
                        shell->ReportError(hr);
                        return;
                    }

                    if (ichain == NULL)
                    {
                        shell->Error(L"Cannot go down farther: "
                                     L"at bottom of call stack.\n");
                        break;
                    }

                    ICorDebugFrame *iframe;

                    {
                        ICorDebugFrameEnum *fe;

                        HRESULT hr = ichain->EnumerateFrames(&fe);
                        if (FAILED(hr))
                        {
                            shell->ReportError(hr);
                            RELEASE(ichain);
                            return;
                        }

                        ULONG count;
                        hr = fe->GetCount(&count);
                        if (FAILED(hr))
                        {
                            shell->ReportError(hr);
                            RELEASE(ichain);
                            RELEASE(fe);
                            return;
                        }

                        if (count == 0)
                            iframe = NULL;
                        else
                        {
                            hr = fe->Skip(count-1);
                            if (FAILED(hr))
                            {
                                shell->ReportError(hr);
                                RELEASE(ichain);
                                RELEASE(fe);
                                return;
                            }

                            hr = fe->Next(1, &iframe, &count);
                            if (FAILED(hr) || count != 1)
                            {
                                shell->ReportError(hr);
                                RELEASE(ichain);
                                RELEASE(fe);
                                return;
                            }
                        }

                        RELEASE(fe);
                    }

                    shell->SetCurrentChain(ichain);
                    shell->SetCurrentFrame(iframe);

                    RELEASE(ichain);
                    if (iframe != NULL)
                        RELEASE(iframe);
                }
                else
                    shell->Error(L"No stack trace for thread.");
            }
        }

        // Print where we ended up
        if (!shell->PrintCurrentSourceLine(0))
            shell->PrintThreadState(shell->m_currentThread);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[<count>]\n");
        shell->Write(L"For inspection purposes, moves the stack frame pointer\n");
        shell->Write(L"down the stack toward frames called by the current frame.\n");
        shell->Write(L"If no argument is passed, the stack frame pointer moves\n");
        shell->Write(L"down one frame. If a count argument is provided, the stack\n");
        shell->Write(L"frame pointer moves down by the specified number of frames.\n");
        shell->Write(L"If source level information is available, the source line\n");
        shell->Write(L"for the frame is displayed. This command is used after the\n");
        shell->Write(L"up command has been used.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Navigate down from the current stack frame pointer";
    }
};

class SuspendDebuggerCommand : public DebuggerCommand
{
public:
    SuspendDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        int                 id;
        bool                fSuspendAll = false;
        ICorDebugThread    *ithread = NULL;
        
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current thread!\n");
            return;
        }
        
        if (*args == L'~')
        {
            fSuspendAll = true;
            args++;
        }
        
        if( shell->GetIntArg(args, id) )
        {
            if (FAILED(shell->m_currentProcess->GetThread(id, &ithread)))
            {
                shell->Write(L"No such thread 0x%x.\n", id);
                return;
            }
        }
        else
        {
            if (fSuspendAll == false)
            {
                shell->Write(L"If we're not suspending all threads, we "
                    L"need a thread id\n");
                return;
            }
            ithread = NULL;
        }

        if (fSuspendAll)
        {
            if(FAILED(shell->m_currentProcess->SetAllThreadsDebugState
                (THREAD_SUSPEND,ithread)))
            {
                if(ithread!=NULL)
                    RELEASE(ithread);
                shell->Write(L"Unable to suspend all threads.\n");
                return;
            }
            else
            {
                if(ithread!=NULL)
                    RELEASE(ithread);
                shell->Write(L"All threads except for 0x%x will "
                    L"be suspended.\n", id);
                return;
            }
        }
        else
        {
            if(FAILED(ithread->SetDebugState(THREAD_SUSPEND)))
            {
                RELEASE(ithread);
                shell->Write(L"Unable to suspend thread 0x%x.\n", id);
                return;
            }
            else
            {
                RELEASE(ithread);
                shell->Write(L"Will suspend thread 0x%x.\n", id);
                return;
            }
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[~][<tid>]\n");
        shell->Write(L"Suspends the thread specified by the tid argument\n");
        shell->Write(L"when the debugger continues. If the ~ syntax is used,\n");
        shell->Write(L"suspends all threads except the specified thread. If\n");
        shell->Write(L"no argument is passed, the command has no effect.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Suspend a thread";
    }
};

class ResumeDebuggerCommand : public DebuggerCommand
{
public:
    ResumeDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        int                 id;
        bool                fResumeAll = false;
        ICorDebugThread    *ithread = NULL;
        
        if (shell->m_currentProcess == NULL)
        {
            shell->Write(L"No current thread!\n");
            return;
        }
        
        if (*args == L'~')
        {
            fResumeAll = true;
            args++;
        }
        
        if( shell->GetIntArg(args, id) )
        {
            if (FAILED(shell->m_currentProcess->GetThread(id, &ithread)))
            {
                shell->Write(L"No such thread 0x%x.\n", id);
                return;
            }
        }
        else
        {
            if (fResumeAll == false)
            {
                shell->Write(L"If we're not resuming all threads, we "
                    L"need a thread id\n");
                return;
            }
            ithread = NULL;
        }

        if (fResumeAll)
        {
            if(FAILED(shell->m_currentProcess->SetAllThreadsDebugState
                (THREAD_RUN,ithread)))
            {
                if(ithread!=NULL)
                    RELEASE(ithread);
                shell->Write(L"Unable to resume all threads.\n");
                return;
            }
            else
            {
                if(ithread!=NULL)
                    RELEASE(ithread);
                shell->Write(L"All threads except for 0x%x will "
                    L"be resumed.\n", id);
                return;
            }
        }
        else
        {
            if(FAILED(ithread->SetDebugState(THREAD_RUN)))
            {
                RELEASE(ithread);
                shell->Write(L"Unable to resume thread 0x%x.\n", id);
                return;
            }
            else
            {
                RELEASE(ithread);
                shell->Write(L"Will resume thread 0x%x.\n", id);
                return;
            }
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[~][<tid>]\n");
        shell->Write(L"Resumes the thread specified by the tid argument\n");
        shell->Write(L"when the debugger continues. If the ~ syntax is\n");
        shell->Write(L"used, resumes all threads except the specified\n");
        shell->Write(L"thread. If no argument is passed, the command has\n");
        shell->Write(L"no effect.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Resume a thread";
    }
};



class CatchDebuggerCommand : public DebuggerCommand
{
public:
    CatchDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        WCHAR *what = NULL;

        if (!shell->GetStringArg(args, what))
        {
            Help(shell);
            return;
        }

        if (args > what)
        {
            // Figure out what event type to catch
            switch (*what)
            {
            case L'e':
                {
                    WCHAR *exType = NULL;

                    shell->GetStringArg(args, exType);

                    if (args > exType)
                        shell->HandleSpecificException(exType, true);
                    else
                        shell->m_catchException = true;
                }
                break;

            case L'u':
                if (wcsncmp(what, L"unhandled", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchUnhandled = true;
                break;

            case L'c':
                if (wcsncmp(what, L"class", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchClass = true;
                break;

            case L'm':
                if (wcsncmp(what, L"module", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchModule = true;
                break;

            case L't':
                if (wcsncmp(what, L"thread", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchThread = true;
                break;

            default:
                Help(shell);
            }
        }
        else
        {
            shell->Write(L"exception\t%s\n", shell->m_catchException ? L"on" : L"off");
            shell->Write(L"unhandled\t%s\n", shell->m_catchUnhandled ? L"on" : L"off");
            shell->Write(L"class\t\t%s\n", shell->m_catchClass ? L"on" : L"off");
            shell->Write(L"module\t\t%s\n", shell->m_catchModule ? L"on" : L"off");
            shell->Write(L"thread\t\t%s\n", shell->m_catchThread ? L"on" : L"off");
            shell->HandleSpecificException(NULL, true);
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[<event>]\n");
        shell->Write(L"Displays a list of event types or causes the specified event type\n");
        shell->Write(L"to stop the debugger. If no argument is passed, a list of event types\n");
        shell->Write(L"is displayed, where event types that stop the debugger are marked \"on,\"\n");
        shell->Write(L"and event types that are ignored are marked \"off.\" If an event argument\n");
        shell->Write(L"is provided, the debugger will stop when events of the specified type\n");
        shell->Write(L"occur. By default, the debugger only stops on unhandled exception events\n");
        shell->Write(L"(i.e., second chance exceptions). Stop events persist across runs in a\n");
        shell->Write(L"session. To cause the debugger to ignore a particular type of event, use\n");
        shell->Write(L"the ignore command.\n");
        shell->Write(L"\n");
        shell->Write(L"The event argument can be one of the following:\n");
        shell->Write(L"   e[xception]      All exceptions\n");
        shell->Write(L"   u[nhandled]      Unhandled exceptions\n");
		shell->Write(L"   c[lass]          Class load events\n");
        shell->Write(L"   m[odule]         Module load events\n");
        shell->Write(L"   t[hread]         Thread start events\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Stop on exception, thread, and/or load events";
    }
};

class IgnoreDebuggerCommand : public DebuggerCommand
{
public:
    IgnoreDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        WCHAR *what = NULL;
        shell->GetStringArg(args, what);
        if (args > what)
        {
            switch (*what)
            {
            case L'e':
                {
                    WCHAR *exType = NULL;

                    shell->GetStringArg(args, exType);

                    if (args > exType)
                        shell->HandleSpecificException(exType, false);
                    else
                        shell->m_catchException = false;
                }
                break;

            case L'u':
                if (wcsncmp(what, L"unhandled", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchUnhandled = false;
                break;

            case L'c':
                if (wcsncmp(what, L"class", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchClass = false;
                break;

            case L'm':
                if (wcsncmp(what, L"module", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchModule = false;
                break;

            case L't':
                if (wcsncmp(what, L"thread", wcslen(what)) != 0)
                    Help(shell);
                else
                    shell->m_catchThread = false;
                break;

            default:
                Help(shell);
            }
        }
        else
        {
            shell->Write(L"exception\t%s\n", shell->m_catchException ? L"on" : L"off");
            shell->Write(L"unhandled\t%s\n", shell->m_catchUnhandled ? L"on" : L"off");
            shell->Write(L"class\t\t%s\n", shell->m_catchClass ? L"on" : L"off");
            shell->Write(L"module\t\t%s\n", shell->m_catchModule ? L"on" : L"off");
            shell->Write(L"thread\t\t%s\n", shell->m_catchThread ? L"on" : L"off");
            shell->HandleSpecificException(NULL, true);
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
        shell->Write(L"[<event>]\n");
        shell->Write(L"Displays a list of event types or causes the specified event type to be\n");
        shell->Write(L"ignored by the debugger. If no argument is passed, a list of event types\n");
        shell->Write(L"is displayed, where event types that are ignored are marked \"off,\" and\n");
        shell->Write(L"event types that stop the debugger are marked \"on.\" If an event argument\n");
        shell->Write(L"is provided, the debugger will ignore events of the specified type. By\n");
        shell->Write(L"default, the debugger ignores all events except unhandled exception events\n");
        shell->Write(L"(i.e., second chance exceptions). Ignore events persist across runs in a\n");
        shell->Write(L"session. To cause the debugger to stop on a particular type of event, use\n");
        shell->Write(L"the catch command.\n");
        shell->Write(L"\n");
        shell->Write(L"The event argument can be one of the following:\n");
        shell->Write(L"   e[xception]      All exceptions\n");
        shell->Write(L"   u[nhandled]      Unhandled exceptions\n");
		shell->Write(L"   c[lass]          Class load events\n");
        shell->Write(L"   m[odule]         Module load events\n");
        shell->Write(L"   t[hread]         Thread start events\n");
        shell->Write(L"\n");

    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Ignore exception, thread, and/or load events";
    }
};

class SetDefaultDebuggerCommand : public DebuggerCommand
{
public:
    SetDefaultDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // Read the existing key first.
        WCHAR *realDbgCmd = NULL;
        HKEY key;
        DWORD disp;

        // Use create to be sure the key is there
        LONG result = RegCreateKeyExA(HKEY_LOCAL_MACHINE, REG_COMPLUS_KEY,
                                      NULL, NULL, REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS, NULL, &key, &disp);

        if (result == ERROR_SUCCESS)
        {
            DWORD type;
            DWORD len;

            result = RegQueryValueExA(key, REG_COMPLUS_DEBUGGER_KEY,
                                      NULL, &type, NULL, &len);

            if ((result == ERROR_SUCCESS) && ((type == REG_SZ) ||
                                              (type == REG_EXPAND_SZ)))
            {
                char *tmp = (char*) _alloca(len * sizeof (char));

                result = RegQueryValueExA(key,
                                          REG_COMPLUS_DEBUGGER_KEY,
                                          NULL, &type,
                                          (BYTE*) tmp,
                                          &len);

                if (result == ERROR_SUCCESS)
                {
                    MAKE_WIDEPTR_FROMANSI(tmpWStr, tmp);
                    realDbgCmd = new WCHAR[len];
                    wcscpy(realDbgCmd, tmpWStr);
                }
            }
        }
        else
        {
            shell->Error(L"Error reading registry: %d", result);
            return;
        }

        bool setIt = false;

        // If there is an existing command, show it and don't override
        // unless we're forced to.
        if (realDbgCmd != NULL)
        {
            shell->Write(L"Current managed JIT debugger command='%s'\n",
                         realDbgCmd);

            WCHAR *what = NULL;
            shell->GetStringArg(args, what);

            if ((args > what) && (*what == L'f'))
                setIt = true;

            delete realDbgCmd;
        }
        else
            setIt = true;

        // Set the new registry key.
        if (setIt)
        {
            MAKE_ANSIPTR_FROMWIDE(cmdA, shell->GetJITLaunchCommand());
            
            result = RegSetValueExA(key, REG_COMPLUS_DEBUGGER_KEY, NULL,
                                    REG_SZ,
                                    (const BYTE*) cmdA, strlen(cmdA) + 1);

            if (result != ERROR_SUCCESS)
                shell->Write(L"Error updating registry: %d\n", result);
            else
                shell->Write(L"Registry updated.\n");
        }

        RegCloseKey(key);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[force]\n");
        shell->Write(L"Sets the default managed JIT debugger to CorDbg. The\n");
        shell->Write(L"command does nothing if another debugger is already\n");
        shell->Write(L"registered. Use the force argument to overwrite the\n");
        shell->Write(L"registered managed JIT debugger.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Change the JIT debugger";
    }
};


// Infomation about all debugger shell modes.
struct DSMInfo g_DSMData[] = 
{
    {DSM_SHOW_APP_DOMAIN_ASSEMBLY_LOADS, L"AppDomainLoads",
     L"AppDomain and Assembly load events are displayed",
     L"AppDomain and Assembly load events are not displayed",
     L"Display appdomain and assembly load events",
     L"          "},

    {DSM_SHOW_CLASS_LOADS, L"ClassLoads",
     L"Class load events are displayed",
     L"Class load events are not displayed",
     L"Display class load events",
     L"              "},

    {DSM_DUMP_MEMORY_IN_BYTES, L"DumpMemoryInBytes",
     L"Memory is dumped in BYTES",
     L"Memory is dumped in DWORDS",
     L"Display memory contents as bytes or DWORDs",
     L"       "},

    {DSM_ENHANCED_DIAGNOSTICS, L"EnhancedDiag",
     L"Display extra diagnostic information",
     L"Suppress display of diagnostic information",
     L"Display enhanced diagnostic information",
     L"            "},

    {DSM_DISPLAY_REGISTERS_AS_HEX, L"HexDisplay",
     L"Numbers are displayed in hexadecimal",
     L"Numbers are displayed in decimal",
     L"Display numbers in hexadecimal or decimal",
     L"              "},

    {DSM_IL_NATIVE_PRINTING, L"ILNatPrint",
     L"Offsets will be both IL and native-relative",
     L"Offsets will be IL xor native-relative",
     L"Display offsets in IL or native-relative, or both",
     L"              "},

    {DSM_INTERCEPT_STOP_ALL, L"ISAll",
     L"All interceptors are stepped through",
     L"All interceptors are skipped",
     L"Step through all interceptors",
     L"                   "},

    {DSM_INTERCEPT_STOP_CLASS_INIT, L"ISClinit",
     L"Class initializers are stepped through",
     L"Class initializers are skipped",
     L"Step through class initializers",
     L"                "},

    {DSM_INTERCEPT_STOP_EXCEPTION_FILTER, L"ISExceptF",
     L"Exception filters are stepped through",
     L"Exception filters are skipped",
     L"Step through exception filters",
     L"               "},

    {DSM_INTERCEPT_STOP_INTERCEPTION, L"ISInt",
     L"User interceptors are stepped through",
     L"User interceptors are skipped",
     L"Step through user interceptors",
     L"                   "},

    {DSM_INTERCEPT_STOP_CONTEXT_POLICY, L"ISPolicy",
     L"Context policies are stepped through",
     L"Context policies are skipped",
     L"Step through context policies",
     L"                "},

    {DSM_INTERCEPT_STOP_SECURITY, L"ISSec",
     L"Security interceptors are stepped through",
     L"Security interceptors are skipped",
     L"Step through security interceptors",
     L"                   "},

    {DSM_ENABLE_JIT_OPTIMIZATIONS, L"JitOptimizations",
     L"JIT's will produce optimized code",
     L"JIT's will produce debuggable (non-optimized) code",
     L"JIT compilation generates debuggable code",
     L"        "},
        
    {DSM_LOGGING_MESSAGES, L"LoggingMessages",
     L"Managed log messages are displayed",
     L"Managed log messages are suppressed",
     L"Display managed code log messages",
     L"         "},

    {DSM_SHOW_MODULE_LOADS, L"ModuleLoads",
     L"Module load events are displayed",
     L"Module load events are not displayed",
     L"Display module load events",
     L"             "},

    {DSM_SEPARATE_CONSOLE, L"SeparateConsole",
     L"Debuggees get their own console",
     L"Debuggees share cordbg's console",
     L"Specify if debuggees get their own console",
     L"         "},

    {DSM_SHOW_ARGS_IN_STACK_TRACE, L"ShowArgs",
     L"Arguments will be shown in stack trace",
     L"Arguments will not be shown in stack trace",
     L"Display method arguments in stack trace",
     L"                "},

    {DSM_SHOW_MODULES_IN_STACK_TRACE, L"ShowModules",
     L"Module names will be included in stack trace",
     L"Module names will not be shown in stack trace",
     L"Display module names in the stack trace",
     L"             "},
     
    {DSM_SHOW_STATICS_ON_PRINT, L"ShowStaticsOnPrint",
     L"Static fields are included when displaying objects",
     L"Static fields are not included when displaying objects",
     L"Display static fields for objects",
     L"      "},

    {DSM_SHOW_SUPERCLASS_ON_PRINT, L"ShowSuperClassOnPrint",
     L"Super class names are included when displaying objects",
     L"Super class names are not included when displaying objects",
     L"Display contents of super class for objects",
     L"   "},

    {DSM_SHOW_UNMANAGED_TRACE, L"UnmanagedTrace",
     L"Unmanaged debug events are displayed",
     L"Unmanaged debug events are not displayed",
     L"Display unmanaged debug events",
     L"          "},

    {DSM_UNMAPPED_STOP_ALL, L"USAll",
     L"Unmapped stop locations are stepped through",
     L"Unmapped stop locations are skipped",
     L"Step through all unmapped stop locations",
     L"                   "},

    {DSM_UNMAPPED_STOP_EPILOG, L"USEpi",
     L"Epilogs are stepped through in disassembly",
     L"Epilogs are skipped, returning to calling method",
     L"Step through method epilogs",
     L"                   "},

    {DSM_UNMAPPED_STOP_PROLOG, L"USPro",
     L"Prologs are stepped through in disassembly",
     L"Prologs are skipped",
     L"Step through method prologs",
     L"                   "},

    {DSM_UNMAPPED_STOP_UNMANAGED, L"USUnmanaged",
     L"Unmanaged code is stepped through in disassembly",
     L"Unmanaged code is skipped",
     L"Step through unmanaged code",
     L"             "},

    {DSM_WIN32_DEBUGGER, L"Win32Debugger",
     L"CorDbg is the Win32 debugger for all processes.",
     L"CorDbg is not the Win32 debugger for all processes",
     L"Specify Win32 debugger (UNSUPPORTED: use at your own risk)",
     L"           "},

    {DSM_EMBEDDED_CLR, L"EmbeddedCLR",
     L"Embedded CLR applications are debugged",
     L"Desktop CLR applications are debugged",
     L"Select the desktop or embedded CLR debugging",
     L"             "},
};

class SetModeDebuggerCommand : public DebuggerCommand
{
public:
    SetModeDebuggerCommand(const WCHAR *name, int minMatchLength =0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void DisplayAllModes( DebuggerShell *shell  )
    {
        for (unsigned int i = 0; i < DSM_MAXIMUM_MODE; i++)
        {
            if (shell->m_rgfActiveModes & g_DSMData[i].modeFlag)
                shell->Write(L"  %s=1%s%s\n",
                             g_DSMData[i].name,
                             g_DSMData[i].descriptionPad,
                             g_DSMData[i].onDescription);
            else
                shell->Write(L"  %s=0%s%s\n",
                             g_DSMData[i].name,
                             g_DSMData[i].descriptionPad,
                             g_DSMData[i].offDescription);
        }
        
        shell->Write(L"\n\n");
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        WCHAR   *szMode;
        int     modeValue;

        _ASSERTE(DSM_MAXIMUM_MODE == (sizeof(g_DSMData) /
                                      sizeof(g_DSMData[0])));

        shell->GetStringArg(args, szMode);
        
        if (args != szMode)
        {
            int szModeLen = args - szMode;
            
            if (shell->GetIntArg(args, modeValue))
            {
                for (unsigned int i = 0; i < DSM_MAXIMUM_MODE; i++)
                {
                    if (_wcsnicmp(szMode, g_DSMData[i].name, szModeLen) == 0)
                    {
                        if (g_DSMData[i].modeFlag & DSM_CANT_CHANGE_AFTER_RUN &&
                            shell->m_targetProcess != NULL)
                        {
                            shell->Write(L"Not allowed to change this "
                                L"mode after the debuggee has started.\n");
                        }
                        else
                        {
                            if (modeValue)
                            {
                                shell->m_rgfActiveModes |= g_DSMData[i].modeFlag;
                                shell->Write(g_DSMData[i].onDescription);                            
                            }
                            else
                            {
                                shell->m_rgfActiveModes &= ~g_DSMData[i].modeFlag;
                                shell->Write(g_DSMData[i].offDescription);
                            }
                
                            shell->Write(L"\n\n\n");
                        
                            // Update the modes in the registry.
                            shell->WriteDebuggerModes();
                        }
                        break;
                    }
                }

                // If we made it to the end of the list, then we
                // didn't find the mode to change.
                if (!(i < DSM_MAXIMUM_MODE))
                    shell->Write(L"%s is not a valid mode.\n", szMode);
            }
            else
                DisplayAllModes(shell);
        }
        else
            DisplayAllModes(shell);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[<mode name> {0 | 1}]\n");
        shell->Write(L"Sets and displays debugger modes for various debugger\n");
        shell->Write(L"features. To set a value, specify the mode name and a 1\n"); 
        shell->Write(L"for on and 0 for off. If no argument is passed, a list\n");
        shell->Write(L"of current mode settings is displayed.\n");
        shell->Write(L"\n");
        shell->Write(L"The mode argument can be one of the following:\n");

        for (unsigned int i = 0; i < DSM_MAXIMUM_MODE; i++)
            shell->Write(L"  %s%s%s\n",
                         g_DSMData[i].name,
                         g_DSMData[i].descriptionPad,
                         g_DSMData[i].generalDescription);
                         
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display/modify various debugger modes";
    }
};

enum DispRegRegisters
{
    REGISTER_X86_EFL = REGISTER_X86_FPSTACK_7 +1,
    REGISTER_X86_CS,
    REGISTER_X86_DS,
    REGISTER_X86_ES,
    REGISTER_X86_FS,
    REGISTER_X86_GS,
    REGISTER_X86_SS,
    REGISTER_X86_EFLAGS_CY,
    REGISTER_X86_EFLAGS_PE,
    REGISTER_X86_EFLAGS_AC,
    REGISTER_X86_EFLAGS_ZR,
    REGISTER_X86_EFLAGS_PL,
    REGISTER_X86_EFLAGS_EI,
    REGISTER_X86_EFLAGS_UP,
    REGISTER_X86_EFLAGS_OV,
    INVALID_REGISTER
};

#define X86_EFLAGS_CY   SETBITULONG64(0)    //Carry Set
#define X86_EFLAGS_PE   SETBITULONG64(2)    //Parity Even?
#define X86_EFLAGS_AC   SETBITULONG64(4)    //Aux. Carry
#define X86_EFLAGS_ZR   SETBITULONG64(6)    //Zero Set
#define X86_EFLAGS_PL   SETBITULONG64(7)    //Sign positive
#define X86_EFLAGS_EI   SETBITULONG64(9)    //Enabled Interrupt
#define X86_EFLAGS_UP   SETBITULONG64(10)   //Direction increment
#define X86_EFLAGS_OV   SETBITULONG64(11)   //Overflow Set

static int g_numRegNames = REGISTER_X86_EFLAGS_OV+1;
static WCHAR g_RegNames[REGISTER_X86_EFLAGS_OV+1][4] = { L"EIP", L"ESP", 
                                    L"EBP", L"EAX", L"ECX", 
                                    L"EDX", L"EBX", L"ESI", L"EDI", L"ST0",
                                    L"ST1", L"ST2", L"ST3", L"ST4", L"ST5",
                                    L"ST6", L"ST7", L"EFL", L"CS", L"DS",
                                    L"ES", L"FS", L"GS", L"SS", L"CY", L"PE",
                                    L"AC", L"ZR", L"PL", L"EI", L"UP", L"OV"};

class RegistersDebuggerCommand : public DebuggerCommand
{
public:
    RegistersDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(Shell *shell, const WCHAR *args) 
    {
        DebuggerShell *dsh = static_cast<DebuggerShell *>(shell);

        Do(dsh, dsh->m_cor, args);
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
#ifdef _X86_
        HRESULT hr = S_OK;
        bool    fPrintAll; // set to true if we want to print all regs
                           // false means print only the 1 requested

        WCHAR *szReg = NULL;

        shell->GetStringArg(args, szReg);
        
        // GetStringArg will point szReg to args (and not change) args if
        // there is no StringArg. Therefore, we print everything iff there
        // is no StringArg
        fPrintAll = (args == szReg);

        // If there is no current thread, cannot perform command.
        if ((shell->m_currentThread == NULL) &&
            (shell->m_currentUnmanagedThread == NULL))
        {
            shell->Write(L"Thread no longer exists.\n");
            return;
        }

        // We need to fill in a context with the thread/frame's
        // current registers.
        ICorDebugRegisterSet *iRs = NULL;
        CONTEXT context;
        context.ContextFlags = CONTEXT_FULL;

        DebuggerUnmanagedThread *ut = shell->m_currentUnmanagedThread;

        if ((shell->m_rawCurrentFrame == NULL) && (ut != NULL))
        {
            // No frame, just use unmanaged context.
            HANDLE hThread = ut->GetHandle();
            
            hr = shell->m_targetProcess->GetThreadContext(ut->GetId(),
                                                          sizeof(CONTEXT),
                                                          (BYTE*)&context);

            if (!SUCCEEDED(hr))
            {
                shell->Write(L"Failed to get context 0x%x\n", hr);
                return;
            }
        }
        else if (shell->m_rawCurrentFrame != NULL)
        {
            // If we have a frame, use that.
            ICorDebugNativeFrame *inativeFrame;

            hr = shell->m_rawCurrentFrame->QueryInterface(
                                               IID_ICorDebugNativeFrame,
                                               (void **)&inativeFrame);

            if (FAILED(hr))
            {
                g_pShell->Write(L"The current frame isn't a native frame!\n" );
                return;
            }

            hr = inativeFrame->GetRegisterSet(&iRs);

            inativeFrame->Release();
            
            if (FAILED(hr))
            {
                shell->Write(L"Unable to GetRegisterSet from the current, "
                             L"native frame\n" );
                return;
            }
        }
        else if (shell->m_currentChain != NULL)
        {
            hr = shell->m_currentChain->GetRegisterSet(&iRs);

            if (FAILED(hr))
            {
                shell->Write(L"Unable to GetRegisterSet from the current "
                             L"chain");
                return;
            }
        }
        else if (shell->m_currentThread != NULL)
        {
            hr = shell->m_currentThread->GetRegisterSet(&iRs);
            
            if (FAILED(hr))
            {
                shell->Write(L"Unable to GetRegisterSet from the current "
                             L"thread");
                return;
            }
        }
        else
        {
            shell->Write(L"Unable to get registers for current thread.\n");
            return;
        }

        // If we ended up with a register set, then convert it to a context.
        if (iRs != NULL)
        {
            hr = iRs->GetThreadContext(sizeof(CONTEXT), (BYTE*)&context);
            iRs->Release();
            iRs = NULL;

            if (!SUCCEEDED(hr))
            {
                shell->Write(L"Unable to GetThreadContext!\n");
                return;
            }
        }

        // Convert the float save area to doubles for printing.
#define FLOAT_COUNT 8
        double floatValues[FLOAT_COUNT];
        
        // On X86, we do this by saving our current FPU state, loading
        // the other thread's FPU state into our own, saving out each
        // value off the FPU stack, and then restoring our FPU state.
        FLOATING_SAVE_AREA floatarea = context.FloatSave;

        // Suck the TOP out of the FPU status word. Note, our version
        // of the stack runs from 0->7, not 7->0...
        unsigned int floatStackTop =
            7 - ((floatarea.StatusWord & 0x3800) >> 11);

        FLOATING_SAVE_AREA currentFPUState;

        __asm fnsave currentFPUState // save the current FPU state.

        floatarea.StatusWord &= 0xFF00; // remove any error codes.
        floatarea.ControlWord |= 0x3F; // mask all exceptions.

        __asm
        {
            fninit
            frstor floatarea          ;; reload the threads FPU state.
        }

        unsigned int i;
        
        for (i = 0; i <= floatStackTop; i++)
        {
            double td;
            __asm fstp td // copy out the double
            floatValues[i] = td;
        }

        __asm
        {
            fninit
            frstor currentFPUState    ;; restore our saved FPU state.
        }

        int nRegsWritten = 1;

        // Write out all the registers, unless we were given a
        // specific register to print out.
        if (fPrintAll)
        {
            // Print the thread ID
            DWORD id;

            if (shell->m_currentThread)
            {
                hr = shell->m_currentThread->GetID(&id);
            
                if (FAILED(hr))
                {
                    shell->ReportError(hr);
                    return;
                }
            }
            else
                id = ut->GetId();
            
            // Output thread ID
            shell->Write(L"Thread 0x%x:\n", id);

            for (int i = REGISTER_X86_EIP; i < REGISTER_X86_EFLAGS_OV; i++)
            {
                WriteReg(i, &context, floatValues, shell);

                if (((nRegsWritten++ % 5) == 0) ||
                    (i == REGISTER_X86_FPSTACK_7) ||
                    (i == REGISTER_X86_EDI))
                {
                    nRegsWritten = 1;
                    shell->Write(L"\n");
                }
                else
                    shell->Write(L" ");
            }
        }
        else
        {
            if (!WriteReg(LookupRegisterIndexByName(szReg),
                          &context,
                          floatValues,
                          shell))
                shell->Write(L"Register %s unknown or unprintable\n", szReg);
        }

        shell->Write(L"\n");

        WCHAR sz[20];
        int nBase;
        
        if (shell->m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
            nBase = 16;
        else
            nBase = 10;

        if (fPrintAll && (context.ContextFlags & CONTEXT_DEBUG_REGISTERS))
        {
            shell->Write(L"Dr0 = %08s ",  _itow(context.Dr0, sz, nBase));
            shell->Write(L"Dr1 = %08s ",  _itow(context.Dr1, sz, nBase));
            shell->Write(L"Dr2 = %08s\n", _itow(context.Dr2, sz, nBase));
            shell->Write(L"Dr3 = %08s ",  _itow(context.Dr3, sz, nBase));
            shell->Write(L"Dr6 = %08s ",  _itow(context.Dr6, sz, nBase));
            shell->Write(L"Dr7 = %08s\n", _itow(context.Dr7, sz, nBase));
        }

        if (fPrintAll && (context.ContextFlags & CONTEXT_FLOATING_POINT))
        {
            shell->Write(L"ControlWord = %08s ", 
                         _itow(context.FloatSave.ControlWord, sz, nBase));
            shell->Write(L"StatusWord = %08s ", 
                         _itow(context.FloatSave.StatusWord, sz, nBase));
            shell->Write(L"TagWord = %08s\n",
                         _itow(context.FloatSave.TagWord, sz, nBase));
            shell->Write(L"ErrorOffset = %08s ",
                         _itow(context.FloatSave.ErrorOffset, sz, nBase));
            shell->Write(L"ErrorSelector = %08s ", 
                         _itow(context.FloatSave.ErrorSelector, sz, nBase));
            shell->Write(L"DataOffset = %08s\n",
                         _itow(context.FloatSave.DataOffset, sz, nBase));
            shell->Write(L"DataSelector = %08s ", 
                         _itow(context.FloatSave.DataSelector, sz, nBase));
            shell->Write(L"Cr0NpxState = %08s\n", 
                         _itow(context.FloatSave.Cr0NpxState, sz, nBase));
        }

#else // !_X86_
        _ASSERTE(!"@TODO Alpha - RegistersDebugger2Command::Do (Commands.cpp)");
#endif // _X86_
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"\n");
        shell->Write(L"Displays the contents of the registers for\n");
        shell->Write(L"the current thread.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display CPU registers for current thread";
    }

    int LookupRegisterIndexByName(WCHAR *wszReg)
    {
        for (int i = 0; i < g_numRegNames;i++)
        {
            if (!_wcsicmp(wszReg, g_RegNames[i]))
            {
                return i;
            }
        }

        return INVALID_REGISTER;
    }

#undef WRITE_SPECIAL_BIT_REGISTER
#undef WRITE_SPECIAL_REGISTER

#define REGS_PER_LINE 4
#define WRITE_SPECIAL_REGISTER(shell, pContext, segmentflag, Name, fieldName, nBase, sz) \
            if ((pContext)->ContextFlags & (segmentflag))            \
                (shell)->Write( L#Name L" = %04s",                   \
                _itow((pContext)->##fieldName, sz, (nBase)));        \
            else                                                     \
                shell->Write(L#Name L"=<?>");                        

#define WRITE_SPECIAL_BIT_REGISTER( shell, pContext, segmentFlag, fName, Name ) \
                if ( (pContext)->ContextFlags & (segmentFlag))           \
                {                                                       \
                    if ( (pContext)->EFlags & (X86_EFLAGS_##fName) )     \
                        shell->Write( L#Name L" = 1"  );             \
                    else                                                \
                        shell->Write( L#Name L" = 0"  );             \
                }                                                       \
                else                                                    \
                {                                                       \
                    shell->Write( L#Name L"=<?>" );                     \
                }                                                       \


    bool WriteReg(UINT iReg,
                  CONTEXT *pContext,
                  double *floatValues,
                  DebuggerShell *shell)
    {
#ifdef _X86_
        WCHAR wszTemp[30];
        int nBase; //base 16 or base 10?

        _ASSERTE( pContext != NULL );
        _ASSERTE(sizeof (double) == sizeof (CORDB_REGISTER));

        if ( shell->m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
            nBase = 16;
        else
            nBase = 10;

#define WRITE_REG(_shell, _val, _name, _tmp, _base) \
        (_shell)->Write(L"%s = %08s", (_name), _ui64tow((_val), (_tmp), (_base)));
                        
        switch( iReg )
        {
        case REGISTER_X86_EAX:
            WRITE_REG(shell, pContext->Eax, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_EBX:
            WRITE_REG(shell, pContext->Ebx, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_ECX:
            WRITE_REG(shell, pContext->Ecx, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_EDX:
            WRITE_REG(shell, pContext->Edx, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_ESI:
            WRITE_REG(shell, pContext->Esi, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_EDI:
            WRITE_REG(shell, pContext->Edi, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_EIP:
            WRITE_REG(shell, pContext->Eip, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_ESP:
            WRITE_REG(shell, pContext->Esp, g_RegNames[iReg], wszTemp, nBase);
            break;
        case REGISTER_X86_EBP:
            WRITE_REG(shell, pContext->Ebp, g_RegNames[iReg], wszTemp, nBase);
            break;

        case REGISTER_X86_FPSTACK_0:
        case REGISTER_X86_FPSTACK_1:
        case REGISTER_X86_FPSTACK_2:
        case REGISTER_X86_FPSTACK_3:
        case REGISTER_X86_FPSTACK_4:
        case REGISTER_X86_FPSTACK_5:
        case REGISTER_X86_FPSTACK_6:
        case REGISTER_X86_FPSTACK_7:
            {
                shell->Write(L"%s = %.16g", g_RegNames[iReg],
                             floatValues[iReg - REGISTER_X86_FPSTACK_0]);
                break;
            }

        case REGISTER_X86_EFL:
            {
                WRITE_SPECIAL_REGISTER( shell, pContext, CONTEXT_SEGMENTS, EFL, EFlags, nBase, wszTemp )
                break;
            }
        case REGISTER_X86_CS:
            {
                WRITE_SPECIAL_REGISTER( shell, pContext, CONTEXT_SEGMENTS, CS, SegCs, nBase, wszTemp )
                break;
            }
        case REGISTER_X86_DS:
            {
                WRITE_SPECIAL_REGISTER( shell, pContext, CONTEXT_SEGMENTS, DS, SegDs, nBase, wszTemp )
                break;
            }
        case REGISTER_X86_ES:
            {
                WRITE_SPECIAL_REGISTER( shell, pContext, CONTEXT_SEGMENTS, ES, SegEs, nBase, wszTemp )
                break;
            }
        case REGISTER_X86_SS:
            {
                WRITE_SPECIAL_REGISTER( shell, pContext, CONTEXT_CONTROL, SS, SegSs, nBase, wszTemp )
                break;
            }
        case REGISTER_X86_FS:
            {
                WRITE_SPECIAL_REGISTER( shell, pContext, CONTEXT_SEGMENTS, FS, SegFs, nBase, wszTemp )
                break;
            }
        case REGISTER_X86_GS:
            {
                WRITE_SPECIAL_REGISTER( shell, pContext, CONTEXT_SEGMENTS, GS, SegGs, nBase, wszTemp )
                break;
            }
        case REGISTER_X86_EFLAGS_CY:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, CY, CY )
                break;
            }
        case REGISTER_X86_EFLAGS_PE:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, PE, PE )
                break;
            }
        case REGISTER_X86_EFLAGS_AC:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, AC, AC )
                break;
            }
        case REGISTER_X86_EFLAGS_ZR:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, ZR, ZR )
                break;
            }
        case REGISTER_X86_EFLAGS_PL:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, PL, PL)
                break;
            }
        case REGISTER_X86_EFLAGS_EI:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, EI, EI )
                break;
            }
        case REGISTER_X86_EFLAGS_UP:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, UP, UP )
                break;
            }
        case REGISTER_X86_EFLAGS_OV:
            {
                WRITE_SPECIAL_BIT_REGISTER( shell, pContext,  CONTEXT_CONTROL, OV, OV )
                break;
            }
        default:
            {
                return false;
            }
        }
#else // !_X86_
        _ASSERTE(!"@TODO Alpha - WriteReg (Commands.cpp)");
#endif // _X86_
        return true;
    }
}; //RegistersDebuggerCommand 

#define ON_ERROR_EXIT() if(hr != S_OK) { shell->ReportError(hr); goto done; }
#define ON_ERROR_BREAK() if(hr != S_OK) { shell->ReportError(hr); break; }
#define EXIT_WITH_MESSAGE(msg) { shell->Error(msg); goto done; }
class WTDebuggerCommand : public DebuggerCommand
{
    int GetNestingLevel(DebuggerShell * shell)
    {
        HRESULT hr;
        int level = 0;
        SIZE_T count;

        ICorDebugChainEnum * ce;
        ICorDebugChain * chain;

        if (shell->m_currentThread != NULL)
        {
            hr = shell->m_currentThread->EnumerateChains(&ce);
            
            if (hr == S_OK)
            {

                while (ce->Next(1, &chain, &count) == S_OK && count == 1)
                {
                    BOOL isManaged;
                    ICorDebugFrameEnum * fe;
                    ICorDebugFrame * frame;

                    if (chain->IsManaged(&isManaged) == S_OK && isManaged)
                    {
                        if (chain->EnumerateFrames(&fe) == S_OK)
                        {
                            while (fe->Next(1, &frame, &count) == S_OK && count == 1)
                            {
                                level++;
                                RELEASE(frame);
                            }
                            RELEASE(fe);
                        }
                    }
                    RELEASE(chain);
                }
                RELEASE(ce);
            }
        }

        return level;
    }

    void FormatFunctionName(WCHAR * buffer, ICorDebugFunction * function)
    {
        DebuggerFunction * func;

        func = DebuggerFunction::FromCorDebug(function);
        if(func) 
        {
            wsprintf(buffer, L"%s::%s", func->GetClassName(), func->GetName());
        } else {
            lstrcpy(buffer, L"(nowhere::nomethod)");
        }
    }

    void OutputReportLine(DebuggerShell *shell, int startingLevel, int count, WCHAR * funcname)
    {
        int level = GetNestingLevel(shell);
        int i = 0;
        WCHAR levels[256];

        while(level-- > startingLevel)
        {
            levels[i++] = L' ';
        }
        levels[i] = L'\0';
        shell->Write(L"%8d\t%s%s\n", count, levels, funcname);
    }

public:
    WTDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        HRESULT hr;

        ICorDebugCode * corDebugCode    = NULL;
        ICorDebugFunction * ourFunc     = NULL;
        ICorDebugFunction * lruFunc     = NULL;
        BYTE * code                     = NULL;
        int count                       = 0;
        int funcCount                   = 0;
        int ourNestingLevel             = 0;
        WCHAR funcName[MAX_CLASSNAME_LENGTH];
        ULONG32 codeSize;
        bool needToSkipCompilerStubs;
        
        // Error if no currently running process
        if (shell->m_currentProcess == NULL)
            EXIT_WITH_MESSAGE(L"Process not running.\n");
        
        // Error if no currently running thread
        if (shell->m_currentThread == NULL)
            EXIT_WITH_MESSAGE(L"Thread no longer exists.\n");

        // See if we have good current frame pointer
        if (shell->m_currentFrame == NULL) 
            EXIT_WITH_MESSAGE(L"There is no current frame.\n");

        // Don't show any tracing activity
        shell->m_silentTracing = true;

        // Retrieve code for the current function
        hr = shell->m_rawCurrentFrame->GetCode(&corDebugCode);
        ON_ERROR_EXIT();

        // Retrieve code size
        hr = corDebugCode->GetSize(&codeSize);
        if (hr != S_OK || codeSize == 0) 
            EXIT_WITH_MESSAGE(L"Failure to retrieve function code size.\n");

        // Prepare buffer for code bytes
        code = new BYTE[codeSize];
        if (code == NULL) 
            EXIT_WITH_MESSAGE(L"Failure to allocate code array.\n");

        // Grab the code bytes
        hr = corDebugCode->GetCode(0, codeSize, codeSize, code, &codeSize);
        ON_ERROR_EXIT();

        // Remember in what function we started 
        hr = shell->m_rawCurrentFrame->GetFunction(&ourFunc);
        ON_ERROR_EXIT();

        lruFunc = ourFunc;
        lruFunc->AddRef();
        FormatFunctionName(funcName, lruFunc);
        ourNestingLevel = GetNestingLevel(shell);

        // Turn off compiler stub skipping.
        needToSkipCompilerStubs = shell->m_needToSkipCompilerStubs;
        shell->m_needToSkipCompilerStubs = false;
        
        // Trace to return instruction in current frame. Do this so long as the process is alive.
        shell->m_stopLooping = false;
        while (shell->m_targetProcess != NULL && !shell->m_stopLooping)
        {
            ICorDebugStepper * pStepper;
            ICorDebugFunction * currentFunc;

            // Count in the instruction we are going to execute
            count++;

            // Retrieve function
            if (shell->m_rawCurrentFrame)
            {
                hr = shell->m_rawCurrentFrame->GetFunction(&currentFunc);
                ON_ERROR_BREAK();

                // are we now in different function?
                if(currentFunc != lruFunc)
                {
                    WCHAR newFuncName[MAX_CLASSNAME_LENGTH];

                    FormatFunctionName(newFuncName, currentFunc);

                    // If this is new function, print stats and remember new function
                    if (lstrcmp(newFuncName, funcName) != 0) 
                    {
                        OutputReportLine(shell, ourNestingLevel, funcCount, funcName);
                        lstrcpy(funcName, newFuncName);
                       
                        lruFunc->Release();
                        lruFunc = currentFunc;
                        lruFunc->AddRef();
                        funcCount = 0;
                    }

                }

                // At least one instruction in this function
                funcCount++;

                // We won't deref this pointer anymore, just look at its value
                currentFunc->Release();

                // See if we are at the top level
                if (currentFunc == ourFunc)
                {
                    ULONG32 currentIP;
                    ICorDebugNativeFrame * nativeFrame;

                    // Obtain IP assuming jitted code
                    hr = shell->m_rawCurrentFrame->QueryInterface(
                      IID_ICorDebugNativeFrame,(void **)&nativeFrame);
                    ON_ERROR_BREAK();

                    hr = nativeFrame->GetIP(&currentIP);
                    nativeFrame->Release();
                    ON_ERROR_BREAK();

                    // Prevent accesses past the code array boundary
                    if(currentIP >= codeSize)
                    {
                        shell->Error(L"Stepped outside of function.\n");
                        break;
                    }

                    // Get the code byte
                    BYTE opcode = code[currentIP];

                    // Detect RET instruction
                    if (opcode == 0xC3 || opcode == 0xC2 || 
                        opcode == 0xCA || opcode == 0xCB )
                    {
                        //
                        // Only stop if we are at our nesting level
                        //
                        if (ourNestingLevel == GetNestingLevel(shell))
                            break;
                    }
                }
            }

            // Create a stepper based on the current frame or thread
            if (shell->m_currentFrame != NULL)
                hr = shell->m_currentFrame->CreateStepper(&pStepper);
            else
                hr = shell->m_currentThread->CreateStepper(&pStepper);
            ON_ERROR_BREAK();

            // Make sure the stepper stops everywhere. Without this,
            // we 1) don't get an accurate count and 2) can't stop
            // when we get to the end of the method because we step
            // over the epilog automagically.
            CorDebugUnmappedStop unmappedStop;
            if (g_pShell->m_rgfActiveModes & DSM_WIN32_DEBUGGER)
            {
                unmappedStop = STOP_ALL;
            }
            else
            {
                unmappedStop = (CorDebugUnmappedStop)
                    (STOP_PROLOG|
                     STOP_EPILOG|
                     STOP_NO_MAPPING_INFO|
                     STOP_OTHER_UNMAPPED);
            }
            hr = pStepper->SetUnmappedStopMask(unmappedStop);
            ON_ERROR_BREAK();
            
            hr = pStepper->SetInterceptMask(INTERCEPT_ALL);
            ON_ERROR_BREAK();
            
            // Tell the stepper what to do
            hr = pStepper->Step(TRUE);
            ON_ERROR_BREAK();

            // Indicate the current stepper to the shell
            shell->StepStart(shell->m_currentThread, pStepper);

            // Continue the process
            shell->Run();
        }

        // Turn stub skipping back on if necessary.
        shell->m_needToSkipCompilerStubs = needToSkipCompilerStubs;
        
        // Report result
        OutputReportLine(shell, ourNestingLevel, funcCount, funcName);
        shell->Write(L"\n%8d instructions total\n", count);

done:
        shell->m_silentTracing = false;

        if (corDebugCode)
            RELEASE(corDebugCode);

        if (ourFunc)
            RELEASE(ourFunc);

        if (lruFunc)
            RELEASE(lruFunc);

        if (code)
            delete [] code;
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"\n");
        shell->Write(L"The command, starting from the current instruction, steps\n");
        shell->Write(L"the application by native instructions displaying the call\n");
        shell->Write(L"tree as it goes. The number of native instructions executed\n");
        shell->Write(L"in each function is printed with the call trace. Tracing\n");
        shell->Write(L"stops when the return instruction is reached for the function\n");
        shell->Write(L"that the command was originally executed in. At the end of the\n");
        shell->Write(L"trace, the total number of instructions executed is displayed.\n");
        shell->Write(L"The command mimics the wt command found in NTSD and can be\n");
        shell->Write(L"used for basic performance analysis. Only managed code is\n");
        shell->Write(L"counted now.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Track native instruction count and display call tree";
    }

};
#undef ON_ERROR_EXIT
#undef ON_ERROR_BREAK
#undef EXIT_WITH_MESSAGE


#define DEFAULT_DUMP_BLOCK_SIZE 128

class DumpDebuggerCommand : public DebuggerCommand
{
public:
    DumpDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        int WORD_SIZE = 4;
        int iMaxOnOneLine = 4;

        if ( shell->m_currentProcess == NULL )
        {
            shell->Error( L"Process not running!\n" );
            return ;
        }

        int		cwch = 80;

        CQuickBytes argsBuf;
        WCHAR *wszArgsCopy = (WCHAR *) argsBuf.Alloc(sizeof(WCHAR) * 80);
        if (wszArgsCopy == NULL)
        {
            shell->Error(L"Couldn't get enough memory to copy args!\n");
            return;
        }
		if ( (int)wcslen( args ) >= cwch )
		{
			shell->Write( L"Mode: input string too long!\n" );
			return;
		}
		wcscpy( wszArgsCopy, args );

        WCHAR *szAddrTemp = NULL;
        WCHAR szAddr [20];
        WCHAR *szByteCount = NULL;

        CORDB_ADDRESS addr = NULL;
        SIZE_T  cb = 0;


        szAddr [0] = L'\0';
        shell->GetStringArg( wszArgsCopy, szAddrTemp);
        if ( wszArgsCopy == szAddrTemp )
        {
            shell->Write( L"\n Memory address argument is required\n" );
            return;
        }

        // check to see if this is a valid number
        // if the first digit is '0', then this is an octal or hex number

		for (int i=0; i<(int)wcslen(szAddrTemp); i++)
		{
			if ((szAddrTemp[i] != L' ') &&
				(szAddrTemp[i] != L',') && (szAddrTemp[i] != L';'))
				szAddr [i] = szAddrTemp [i];
			else
				break;
		}

        szAddr [i] = L'\0';

        if (szAddr [0] == L'0')
        {
            if (szAddr [1] == L'x' || szAddr [1] == L'X')
            {
                // it's a hex number
                int iIndex = 2;
                WCHAR ch;
                while ((ch = szAddr [iIndex++]) != L'\0')
                {   
                    if ((ch >= L'0' && ch <= '9')
                        || (ch >= 'a' && ch <= 'f')
                        || (ch >= 'A' && ch <= 'F'))
                    {
                        continue;
                    }
                    goto AddrError;
                }
            }
            else
            {
                // it's an octal number
                int iIndex = 1;
                WCHAR ch;
                while ((ch = szAddr [iIndex++]) != L'\0')
                {   
                    if (ch >= L'0' && ch <= '7')
                    {
                        continue;
                    }
                    goto AddrError;
                }
            }
        }
        else
        {
            // this is a decimal number. Verify.
            int iIndex = 1;
            WCHAR ch;
            while ((ch = szAddr [iIndex++]) != L'\0')
            {   
                if (ch >= L'0' && ch <= '9')
                {
                    continue;
                }
                goto AddrError;
            }
        }

        WCHAR *pCh;
        addr = (CORDB_ADDRESS)wcstoul( szAddr, &pCh, 0 );

        if ( wszArgsCopy[0] != NULL )
        {
            *(wszArgsCopy++) = NULL;
        }

        shell->GetStringArg( wszArgsCopy, szByteCount);
        if ( wszArgsCopy == szByteCount )
        {
            cb = DEFAULT_DUMP_BLOCK_SIZE;
        }
        else
        {
            cb = wcstoul( szByteCount, &pCh, 0 );
        }

AddrError:      
        if ( addr == 0 )
        {
            shell->Write( L"\n Address misformatted or invalid!\n");
            return;
        }
        if ( cb == 0 )
        {
            shell->Write( L"\n Byte count misformatted or invalid!\n");
            return;
        }

        // Get the display mode (Byte, dword)
        if (g_pShell->m_rgfActiveModes & DSM_DUMP_MEMORY_IN_BYTES)
        {
            WORD_SIZE = 1;
            iMaxOnOneLine = 16;
        }

        if (cb % WORD_SIZE)
        {
            cb += WORD_SIZE - (cb % WORD_SIZE);
        }

        _ASSERTE( shell->m_currentProcess != NULL );
        BYTE *pbMemory = new BYTE [ cb ];
        if ( pbMemory == NULL )
        {
            shell->Write( L"\n Unable to allocate the %d bytes needed!", cb );
            return;
        }
        memset( pbMemory, '?', cb );

        SIZE_T read = 10;
        HRESULT hr = shell->m_currentProcess->ReadMemory( addr, cb,
                                                          pbMemory, &read );
        if ( !SUCCEEDED( hr ) )
        {
            shell->Write( L"\n Couldn't read the asked-for memory" );
            goto LExit;
        }

        if (cb != read )
        {
            shell->Write( L"Only able to read %d of the %d requested bytes!\n", read, cb );
        }

        shell->DumpMemory(pbMemory, addr, cb, WORD_SIZE, iMaxOnOneLine, TRUE);
        
LExit:
        shell->Write( L"\n" );
        delete [] pbMemory;
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<address> [<count>]\n");
        shell->Write(L"Dump a block of memory with the output in hexadecimal or\n");
        shell->Write(L"decimal depending on which mode (see the mode command) the\n"); 
        shell->Write(L"debugger is in. The address argument is the address of the\n"); 
        shell->Write(L"block of memory. The count argument is the number of bytes\n"); 
        shell->Write(L"to dump. If either argument begins with the prefix 0x, the\n");
        shell->Write(L"argument is assumed to be in hexadecimal format. Otherwise,\n");
        shell->Write(L"the argument is assumed to be in decimal format.\n");
        shell->Write(L"\n");
        shell->Write(L"Examples:\n");
        shell->Write(L"  du 0x311003fa 16\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Dump the contents of memory";
    }
};
    

class WriteMemoryDebuggerCommand : public DebuggerCommand
{
public:
    WriteMemoryDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if ( shell->m_currentProcess == NULL )
        {
            shell->Error( L"Process not running!\n" );
            return ;
        }

        WCHAR *szAddr = NULL;
        WCHAR *szRange = NULL;
        WCHAR *szValue = NULL;

        CORDB_ADDRESS addr = NULL;
        UINT    cValue = 0;
        BYTE    *rgbValue = NULL;

        HRESULT hr = S_OK;
        int iFirstRepeated = -1; //-1 => no values yet repeated
        UINT iValue =0;

        SIZE_T written = 10;
        
        //get target address
        shell->GetStringArg( args, szAddr);
        if ( args == szAddr )
        {
            shell->Write( L"\n Memory address argument is required\n" );
            return;
        }

        WCHAR *pCh;
        addr = (CORDB_ADDRESS)wcstoul( szAddr, &pCh, 0 );

        if ( addr == NULL )
        {
            shell->Write( L"\n Address misformatted or invalid!\n");
            return;
        }

        //get count of values
        shell->GetStringArg( args, szRange);
        if ( args == szRange )
        {
            shell->Write( L"\n Count of Values argument is required\n" );
            return;
        }
        cValue = (UINT)wcstoul( szRange, &pCh, 0 );

        if ( cValue == 0 )
        {
            shell->Write( L"\n Byte value misformatted or invalid!\n");
            return;
        }
        
        //get byte-pattern
        rgbValue = (BYTE *)malloc( sizeof(BYTE) * cValue );
        if ( rgbValue == NULL )
        {
            shell->Write( L"\nCan't allocate enough memory for writing space!\n" );
            return;
        }
    
        shell->GetStringArg( args, szValue);
        if ( args == szValue )
        { 
            shell->Write( L"\nNeed at least one byte for pattern!\n" );
            goto LExit;
        }
        args = szValue;
        iFirstRepeated = -1;
        for ( iValue = 0; iValue< cValue;iValue++)
        {
            shell->GetStringArg( args, szValue);
            if ( args == szValue )
            {   //ran out of arguments
                //this is slow, but how many characters can
                //people type?
                if ( iFirstRepeated == -1 )
                {
                    iFirstRepeated = 0;
                }
                rgbValue[iValue] = rgbValue[iFirstRepeated++];
            }
            else
                rgbValue[iValue] = (BYTE)wcstoul( szValue, &pCh, 0 );
        }

        hr = shell->m_currentProcess->WriteMemory( addr, cValue,
                                                   rgbValue, &written );
        if ( !SUCCEEDED( hr ) )
        {
            shell->Write( L"\n Couldn't write the target memory\n" );
            goto LExit;
        }

        if (cValue != written )
        {
            shell->Write( L"Only able to write %d of the %d requested bytes!\n", written, cValue );
        }
        
        _ASSERTE( g_pShell != NULL );
        g_pShell->m_invalidCache = true;

        shell->Write( L"\nMemory written!\n" );
LExit:
        free( rgbValue );
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<address> <count> <byte>, ...\n");
        shell->Write(L"Writes the specified bytes to the target process. The\n");
        shell->Write(L"address argument specifies the location to which the\n");
        shell->Write(L"bytes should be written. The count argument specifies\n");
        shell->Write(L"the number of bytes to be written. The byte arguments\n");
        shell->Write(L"specify what is to be written to the process. If the\n");
        shell->Write(L"number of bytes in the list is less than the count\n");
        shell->Write(L"argument, the byte list will be wrapped and copied\n");
        shell->Write(L"again. If the number of bytes in the list is more than\n");
        shell->Write(L"the count argument, the extra bytes will be ignored.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Write memory to target process";
    }
};


class AssociateSourceFileCommand: public DebuggerCommand
{
public:
    AssociateSourceFileCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        // Get the file name to associate
        WCHAR* fileName = NULL;
        WCHAR* cmdName = NULL;
        int     iCount;

        // the first character in args should be "b" or "s" and the next char
        // should be a blank
        if (wcslen(args))
        {
            if (((args [0] == L'b') || (args [0] == L's')) && (args [1]==L' '))
            {
                if (args [0] == L'b')
                {
                    args += 2;

                    // breakpoint
                    if (!shell->GetIntArg(args, iCount))
                    {
                        Help(shell);
                        return;
                    }

                    shell->GetStringArg (args, fileName);

                    if (wcslen(fileName) != 0)
                    {
                        DebuggerBreakpoint *breakpoint = shell->FindBreakpoint(iCount);

                        if (breakpoint != NULL)
                        {
                            breakpoint->ChangeSourceFile (fileName);
                        }                   
                        else
                            shell->Error (L"Breakpoint with this id does not exist.\n");
                    }
                    else
                    {
                        Help(shell);
                    }
                }
                else    // stack frame
                {
                    args += 2;

                    // get file name
                    shell->GetStringArg (args, fileName);

                    if (wcslen(fileName) != 0)
                    {
                        shell->ChangeCurrStackFile (fileName);
                    }
                    else
                    {
                        Help(shell);
                    }
                }
            }
            else
                Help(shell);
        }
        else
            Help(shell);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<s | b <breakpoint id>> <file name>\n");
        shell->Write(L"Associates the given file name with the specified breakpoint\n");
        shell->Write(L"(option b) or the current stack frame (option s).\n");
	    shell->Write(L"\n");
        shell->Write(L"Examples:\n");                   
        shell->Write(L"   as s d:\\program\\src\\foo.cpp\n");
        shell->Write(L"   as b 1 d:\\program\\src\\foo.cpp\n");
		shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Associate a source file with a breakpoint or stack frame";
    }
};


// Given a frame, get the appdomain for it.
// We AddRef it, so caller must release it.
// If this fails, *ppAppDomain is NULL;
static HRESULT GetAppDomainForFrame(ICorDebugFrame * pFrame, ICorDebugAppDomain ** ppAppDomain)
{
    _ASSERTE(pFrame != NULL);
    _ASSERTE(ppAppDomain != NULL);    
    *ppAppDomain = NULL;

    HRESULT hr = S_OK;
    ICorDebugFunction * pFunction = NULL;
    ICorDebugModule   * pModule   = NULL;
    ICorDebugAssembly * pAssembly = NULL;
    
    hr = pFrame->GetFunction(&pFunction);
        
    if (pFunction != NULL)
    {
        hr = pFunction->GetModule(&pModule);
        pFunction->Release();

        if (pModule != NULL)
        {
            hr = pModule->GetAssembly(&pAssembly);
            pModule->Release();

            if (pAssembly != NULL)
            {
                hr = pAssembly->GetAppDomain(ppAppDomain);
                pAssembly->Release();
                
            } // assembly
        } // module
    } // function

    _ASSERTE(SUCCEEDED(hr) || (*ppAppDomain == NULL));
    
    return hr;    
}

static HRESULT GetArgsForFuncEval(DebuggerShell *shell, ICorDebugEval *pEval,
                                  const WCHAR *args, ICorDebugValue **argArray, unsigned int *argCount)
{
    HRESULT hr = S_OK;
    *argCount = 0;
        
    while (*args)
    {
        if (*argCount >= 256)
        {
            shell->Error(L"Too many arguments to function.\n");
            return E_FAIL;
        }
            
        WCHAR *argName;
        shell->GetStringArg(args, argName);

        if (*args)
            *((WCHAR*)args++) = L'\0';

        argArray[*argCount] = shell->EvaluateExpression(argName, shell->m_currentFrame, true);

        // If that didn't work, then see if its a literal value.  @todo: this is only gonna do I4's and NULL for
        // now...
        if (argArray[*argCount] == NULL)
        {
            unsigned int genVal4;
            unsigned __int64 genVal8;
            void *pNewVal;
            bool isNullRef = false;

            if ((argName[0] == L'n') || (argName[0] == L'N'))
            {
                // Create a null reference.
                isNullRef = true;
                    
                hr = pEval->CreateValue(ELEMENT_TYPE_CLASS, NULL, &(argArray[*argCount]));
            }
            else
            {
                if (!shell->GetInt64Arg(argName, genVal8))
                {
                    shell->Error(L"Argument '%s' could not be evaluated\n", argName);
                    return E_FAIL;
                }

                // Make sure it will fit in an I4.
                if (genVal8 <= 0xFFFFFFFF)
                {
                    genVal4 = (unsigned int)genVal8;
                    pNewVal = &genVal4;
                }
                else
                {
                    shell->Error(L"The value 0x%08x is too large.\n", genVal8);
                    return E_FAIL;
                }

                // Create a literal.
                hr = pEval->CreateValue(ELEMENT_TYPE_I4, NULL, &(argArray[*argCount]));
            }
                
            if (FAILED(hr))
            {
                shell->Error(L"CreateValue failed.\n");
                shell->ReportError(hr);
                return hr;
            }

            if (!isNullRef)
            {
                ICorDebugGenericValue *pGenValue;
                
                hr = argArray[*argCount]->QueryInterface(IID_ICorDebugGenericValue, (void**)&pGenValue);
                _ASSERTE(SUCCEEDED(hr));
                
                // Set the literal value.
                hr = pGenValue->SetValue(pNewVal);

                pGenValue->Release();
                
                if (FAILED(hr))
                {
                    shell->Error(L"SetValue failed.\n");
                    shell->ReportError(hr);
                    return hr;
                }
            }
        }

        (*argCount)++;
    }

    return S_OK;
}

class FuncEvalDebuggerCommand : public DebuggerCommand
{
public:
    FuncEvalDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }

        if (shell->m_currentThread == NULL)
        {
            shell->Error(L"No current thread.\n");
            return;
        }

        // Grab the method name.
        WCHAR *methodName = NULL;

        shell->GetStringArg(args, methodName);

        if (wcslen(methodName) == 0)
        {
            shell->Error(L"Function name is required.\n");
            return;
        }

        // Null terminate the method name.
        if (*args)
            *((WCHAR*)args++) = L'\0';

        // Create the eval object.
        ICorDebugAppDomain * pAppDomain = NULL;
        ICorDebugEval *pEval = NULL;
        
        HRESULT hr = shell->m_currentThread->CreateEval(&pEval);

        if (FAILED(hr))
        {
            shell->Error(L"CreateEval failed.\n");
            shell->ReportError(hr);
            goto ErrExit;
        }

         // Grab each argument.
        unsigned int argCount;
        ICorDebugValue *argArray[256];

        if (FAILED(GetArgsForFuncEval(shell, pEval, args, argArray, &argCount)))
            goto ErrExit;

        // Get the appdomain for the frame. May be null, that's ok.
        if (FAILED(GetAppDomainForFrame(shell->m_rawCurrentFrame, &pAppDomain)))
        {
            shell->Error(L"Can only do func-eval in a frame with an appdomain.\n");
            goto ErrExit;
        }

        // Find the function by name.
        ICorDebugFunction *pFunc;
        
        hr = shell->ResolveFullyQualifiedMethodName(methodName, &pFunc, pAppDomain);

        if (FAILED(hr))
        {
            shell->Error(L"Could not find function: %s\n", methodName);

            if (hr != E_INVALIDARG)
                shell->ReportError(hr);

            goto ErrExit;
        }

        // Call the function. No args for now.
        hr = pEval->CallFunction(pFunc, argCount, argArray);

        pFunc->Release();
        
        if (FAILED(hr))
        {
            shell->Error(L"CallFunction failed.\n");
            shell->ReportError(hr);

            pEval->Release();
            
            goto ErrExit;
        }

        shell->m_pCurrentEval = pEval;
        
        // Let the process run. We'll let the callback cleanup the
        // func eval on this thread.
        shell->Run();

    ErrExit:
        if (pAppDomain != NULL)
            pAppDomain->Release();
            
        if (FAILED(hr) && pEval)
            pEval->Release();
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"[<class>::]<function> [<arg0> <arg1> ...]\n");
        shell->Write(L"Evaluates the specified function on the current thread.\n");
        shell->Write(L"The new object will be stored in $result and can be used\n");
        shell->Write(L"for subsequent evaluations. Note, for a member function,\n");
        shell->Write(L"the first argument should be an object of the class (or\n");
        shell->Write(L"derived class) to which the member function belongs.\n");
        shell->Write(L"\n");
        shell->Write(L"Examples:\n");        
        shell->Write(L"  f FooSpace.Foo::Bar         (static method case)\n");
        shell->Write(L"  f Bar::Car bar i $result    (instance method case)\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Function evaluation";
    }
};

class NewStringDebuggerCommand : public DebuggerCommand
{
public:
    NewStringDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }

        if (shell->m_currentThread == NULL)
        {
            shell->Error(L"No current thread.\n");
            return;
        }

        // Create the eval.
        ICorDebugEval *pEval = NULL;
        
        HRESULT hr = shell->m_currentThread->CreateEval(&pEval);

        if (FAILED(hr))
        {
            shell->Error(L"CreateEval failed.\n");
            shell->ReportError(hr);
            return;
        }

        // Create the string
        hr = pEval->NewString(args);

        if (FAILED(hr))
        {
            shell->Error(L"CreateString failed.\n");
            shell->ReportError(hr);

            pEval->Release();
            
            return;
        }

        // Let the process run. We'll let the callback cleanup the
        // func eval on this thread.
        shell->Run();
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<class>\n");
        shell->Write(L"Creates a new string using the current thread.\n");
        shell->Write(L"The new string will be stored in $result and can\n");
        shell->Write(L"be used for subsequent evaluations.\n");  
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Create a new string via function evaluation";
    }
};

class NewObjectDebuggerCommand : public DebuggerCommand
{
public:
    NewObjectDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }

        if (shell->m_currentThread == NULL)
        {
            shell->Error(L"No current thread.\n");
            return;
        }

        // Grab the method name.
        WCHAR *methodName = NULL;

        shell->GetStringArg(args, methodName);

        if (wcslen(methodName) == 0)
        {
            shell->Error(L"Class name is required.\n");
            return;
        }

        // Null terminate the method name.
        if (*args)
            *((WCHAR*)args++) = L'\0';
        
        ICorDebugEval *pEval = NULL;
        
        HRESULT hr = shell->m_currentThread->CreateEval(&pEval);

        if (FAILED(hr))
        {
            shell->Error(L"CreateEval failed.\n");
            shell->ReportError(hr);
            return;
        }

        // Grab each argument.
        unsigned int argCount = 0;
        ICorDebugValue *argArray[256];
        
        if (FAILED(GetArgsForFuncEval(shell, pEval, args, argArray, &argCount)))
            return;

        DebuggerModule *pDM = NULL;
        mdTypeDef TD;
        hr = shell->ResolveClassName(methodName,
                                     &pDM,
                                     &TD);
        if( FAILED(hr))
        {
            shell->Error(L"Could not resolve class: %s\n", methodName);
            return;
        }

        LPWSTR wzTypeDef = NULL;
        ULONG chTypeDef;
        DWORD dwTypeDefFlags;
        mdToken tkExtends;

        IMetaDataImport *pIMI = pDM->GetMetaData();
        
        hr = pIMI->GetTypeDefProps (TD, wzTypeDef,0, &chTypeDef, 
            &dwTypeDefFlags, &tkExtends);

        if (IsTdAbstract(dwTypeDefFlags))
        {
            shell->Write(L"Can't instantiate abstract class!\n");
            return;
        }

        // Get the appdomain for the frame. May be null, that's ok.        
        ICorDebugAppDomain * pAppDomain = NULL;
        if (FAILED(GetAppDomainForFrame(shell->m_rawCurrentFrame, &pAppDomain)))
        {
            _ASSERTE(pAppDomain == NULL);
            shell->Write(L"Can't get appdomain for frame.\n");
            return;
        }
                               

        // Find the constructor by name.
        WCHAR consName[MAX_CLASSNAME_LENGTH];
        swprintf(consName, L"%s::%s",
                 methodName,
                 COR_CTOR_METHOD_NAME_W);

        ICorDebugFunction *pFunc = NULL;
        
        hr = shell->ResolveFullyQualifiedMethodName(consName, &pFunc, pAppDomain);

        if (pAppDomain)
            pAppDomain->Release();

        if (FAILED(hr))
        {
            shell->Error(L"Could not find constructor for class: %s\n", methodName);

            if (hr != E_INVALIDARG)
                shell->ReportError(hr);

            return;
        }

        // Call the function.
        hr = pEval->NewObject(pFunc, argCount, argArray);

        pFunc->Release();
        
        if (FAILED(hr))
        {
            shell->Error(L"NewObject failed.\n");
            shell->ReportError(hr);

            pEval->Release();
            
            return;
        }

        // Let the process run. We'll let the callback cleanup the
        // func eval on this thread.
        shell->Run();
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<class>\n");
        shell->Write(L"Creates a new object and runs the default constructor\n");
        shell->Write(L"using the current thread. The new object will be stored\n");
        shell->Write(L"in $result and can be used for subsequent evaluations.\n");
        shell->Write(L"\n"); 
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Create a new object via function evaluation";
    }
};

class NewObjectNCDebuggerCommand : public DebuggerCommand
{
public:
    NewObjectNCDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }

        if (shell->m_currentThread == NULL)
        {
            shell->Error(L"No current thread.\n");
            return;
        }

        // Grab the class name.
        WCHAR *methodName = NULL;

        shell->GetStringArg(args, methodName);

        if (wcslen(methodName) == 0)
        {
            shell->Error(L"Class name is required.\n");
            return;
        }

        // Null terminate the method name.
        if (*args)
            *((WCHAR*)args++) = L'\0';
        
        ICorDebugEval *pEval = NULL;
        
        HRESULT hr =
            shell->m_currentThread->CreateEval(&pEval);

        if (FAILED(hr))
        {
            shell->Error(L"CreateEval failed.\n");
            shell->ReportError(hr);
            return;
        }

        // Find the class by name.
        DebuggerModule *pDM;
        mdTypeDef td;
        
        hr = shell->ResolveClassName(methodName, &pDM, &td);

        if (FAILED(hr))
        {
            shell->Error(L"Could not find class: %s\n", methodName);

            if (hr != E_INVALIDARG)
                shell->ReportError(hr);

            return;
        }
        
        ICorDebugClass *pClass = NULL;
        hr = pDM->GetICorDebugModule()->GetClassFromToken(td, &pClass);

        if (FAILED(hr))
        {
            shell->Error(L"Could not find class: %s\n", methodName);

            if (hr != E_INVALIDARG)
                shell->ReportError(hr);

            return;
        }
        
        // Call the function. No args for now.
        hr = pEval->NewObjectNoConstructor(pClass);

        pClass->Release();
        
        if (FAILED(hr))
        {
            shell->Error(L"NewObjectNoConstructor failed.\n");
            shell->ReportError(hr);

            pEval->Release();
            
            return;
        }

        // Let the process run. We'll let the callback cleanup the
        // func eval on this thread.
        shell->Run();
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<class>\n");
        shell->Write(L"Creates a new object using the current thread. The\n");
        shell->Write(L"new object will be stored in $result and can be used\n");
        shell->Write(L"for subsequent evaluations.\n"); 
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Create a new object via function evaluation, no constructor";
    }
};

class SetValueDebuggerCommand : public DebuggerCommand
{
public:
    SetValueDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        ICorDebugValue *ivalue = NULL;
        ICorDebugGenericValue *pGenValue = NULL;
        ICorDebugReferenceValue *pRefValue = NULL;
        HRESULT hr = S_OK;

        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            goto Exit;
        }

        if (shell->m_currentThread == NULL)
        {
            shell->Error(L"No current thread.\n");
            goto Exit;
        }

        // Get the name of the variable to print.
        WCHAR* varName;
        shell->GetStringArg(args, varName);

        if ((args - varName) == 0)
        {
            shell->Error(L"A variable name is required.\n");
            goto Exit;
        }
        
        WCHAR *varNameEnd;
        varNameEnd = (WCHAR*) args;
            
        // Get the value to set the variable to.
        WCHAR *valString;
        shell->GetStringArg(args, valString);

        if ((args - valString) == 0)
        {
            shell->Error(L"A value is required.\n");
            goto Exit;
        }

        *varNameEnd = L'\0';

        // Get the value for the name provided
        ivalue = shell->EvaluateExpression(varName, shell->m_currentFrame);

        // If the name provided is valid, print it!
        if (ivalue == NULL)
        {
            shell->Error(L"Variable unavailable, or not valid\n");
            goto Exit;
        }

        // Grab the element type of this value...
        CorElementType type;
        hr = ivalue->GetType(&type);

        if (FAILED(hr))
        {
            shell->Error(L"Problem accessing type info of the variable.\n");
            shell->ReportError(hr);
            goto Exit;
        }

        // Update the variable with the new value. We get the value
        // converted to whatever we need it to be then we call
        // SetValue with that. There are a lot of possibilities for
        // what the proper form of the value could be...
        void *pNewVal;
        
        // If this is a byref, then deref through it...
        if (type == ELEMENT_TYPE_BYREF)
        {
            hr = ivalue->QueryInterface(IID_ICorDebugReferenceValue,
                                        (void**)&pRefValue);

            _ASSERTE(SUCCEEDED(hr));

            ICorDebugValue *newval = NULL;
            hr = pRefValue->Dereference(&newval);
            _ASSERTE(SUCCEEDED(hr));

            RELEASE(ivalue);
            ivalue = newval;
            
            RELEASE(pRefValue);
            pRefValue = NULL;
        }
        
        // Get the specific kind of value we have, generic or reference.
        hr = ivalue->QueryInterface(IID_ICorDebugGenericValue,
                                    (void**)&pGenValue);

        if (FAILED(hr))
        {
            hr = ivalue->QueryInterface(IID_ICorDebugReferenceValue,
                                        (void**)&pRefValue);

            _ASSERTE(SUCCEEDED(hr));
        }

        unsigned char    genVal1;
        unsigned short   genVal2;
        unsigned int     genVal4;
        unsigned __int64 genVal8;
        float            genValR4;
        double           genValR8;
        CORDB_ADDRESS    refVal;

        // Only need to pre-init these two, since all others are
        // copied from these.
        genVal8 = 0;
        genValR8 = 0;

        // Could the value be another variable? (A little eaiser to
        // check than looking for a literal.)
        ICorDebugValue *pAnotherVarValue;
        pAnotherVarValue = shell->EvaluateExpression(valString,
                                                     shell->m_currentFrame,
                                                     true);

        if (pAnotherVarValue != NULL)
        {
            // Ah, it is another variable. Lets grab the value. Is it
            // a generic value or a reference value?
            ICorDebugGenericValue *pAnotherGenValue;
            hr = pAnotherVarValue->QueryInterface(IID_ICorDebugGenericValue,
                                                  (void**)&pAnotherGenValue);
            if (SUCCEEDED(hr))
            {
                RELEASE(pAnotherVarValue);

                // How big is this thing?
                ULONG32 valSize;
                hr = pAnotherGenValue->GetSize(&valSize);

                if (SUCCEEDED(hr))
                {
                    CQuickBytes valBuf;
                    pNewVal = valBuf.Alloc(valSize);
                    if (pNewVal == NULL)
                    {
                        shell->Error(L"Couldn't get enough memory to grab value!\n");
                        goto Exit;
                    }

                    hr = pAnotherGenValue->GetValue(pNewVal);
                }

                RELEASE(pAnotherGenValue);
            }
            else
            {
                ICorDebugReferenceValue *pAnotherRefValue;
                hr = pAnotherVarValue->QueryInterface(
                                            IID_ICorDebugReferenceValue,
                                            (void**)&pAnotherRefValue);
                RELEASE(pAnotherVarValue);

                // If its not a generic value, it had better be a
                // reference value.
                _ASSERTE(SUCCEEDED(hr));

                // Grab the value.
                hr = pAnotherRefValue->GetValue(&refVal);
                RELEASE(pAnotherRefValue);
            }

            if (FAILED(hr))
            {
                shell->Error(L"Error accessing new variable.\n");
                shell->ReportError(hr);
                goto Exit;
            }
        }
        else
        {
            // Must be some type of literal...
            switch (type)
            {
            case ELEMENT_TYPE_BOOLEAN:
                _ASSERTE(pGenValue != NULL);

                if ((valString[0] == L't') || (valString[0] == L'T'))
                {
                    genVal1 = 1;
                    pNewVal = &genVal1;
                }
                else if ((valString[0] == L'f') || (valString[0] == L'F'))
                {
                    genVal1 = 0;
                    pNewVal = &genVal1;
                }
                else
                {
                    shell->Error(L"The value should be 'true' or 'false'\n");
                    goto Exit;
                }

                break;
                
            case ELEMENT_TYPE_I1:
            case ELEMENT_TYPE_U1:
                _ASSERTE(pGenValue != NULL);

                if (!shell->GetInt64Arg(valString, genVal8))
                {
                    shell->Error(L"The value must be a number.\n");
                    goto Exit;
                }

                if (genVal8 <= 0xFF)
                {
                    genVal1 = (unsigned char)genVal8;
                    pNewVal = &genVal1;
                }
                else
                {
                    shell->Error(L"The value 0x%08x is too large.\n",
                                 genVal8);
                    goto Exit;
                }

                break;

            case ELEMENT_TYPE_CHAR:
                _ASSERTE(pGenValue != NULL);

                if ((valString[0] == L'\'') && (valString[1] != L'\0'))
                {
                    genVal2 = valString[1];
                    pNewVal = &genVal2;
                }
                else
                {
                    shell->Error(L"The value is not a character literal.\n");
                    goto Exit;
                }

                break;
                
            case ELEMENT_TYPE_I2:
            case ELEMENT_TYPE_U2:
                _ASSERTE(pGenValue != NULL);

                if (!shell->GetInt64Arg(valString, genVal8))
                {
                    shell->Error(L"The value must be a number.\n");
                    goto Exit;
                }

                if (genVal8 <= 0xFFFF)
                {
                    genVal2 = (unsigned short)genVal8;
                    pNewVal = &genVal2;
                }
                else
                {
                    shell->Error(L"The value 0x%08x is too large.\n",
                                 genVal8);
                    goto Exit;
                }

                break;

            case ELEMENT_TYPE_I4:
            case ELEMENT_TYPE_U4:
            case ELEMENT_TYPE_I:
                _ASSERTE(pGenValue != NULL);

                if (!shell->GetInt64Arg(valString, genVal8))
                {
                    shell->Error(L"The value must be a number.\n");
                    goto Exit;
                }

                if (genVal8 <= 0xFFFFFFFF)
                {
                    genVal4 = (unsigned int)genVal8;
                    pNewVal = &genVal4;
                }
                else
                {
                    shell->Error(L"The value 0x%08x is too large.\n",
                                 genVal8);
                    goto Exit;
                }

                break;

            case ELEMENT_TYPE_I8:
            case ELEMENT_TYPE_U8:
                _ASSERTE(pGenValue != NULL);

                if (!shell->GetInt64Arg(valString, genVal8))
                {
                    shell->Error(L"The value must be a number.\n");
                    goto Exit;
                }
                
                pNewVal = &genVal8;

                break;

            case ELEMENT_TYPE_R4:
                _ASSERTE(pGenValue != NULL);

                if (!iswdigit(valString[0]))
                {
                    shell->Error(L"The value must be a number.\n");
                    goto Exit;
                }

                genValR8 = wcstod(valString, NULL);
                genValR4 = (float) genValR8;
                pNewVal = &genValR4;

                break;
                
            case ELEMENT_TYPE_R8:
                _ASSERTE(pGenValue != NULL);

                if (!iswdigit(valString[0]))
                {
                    shell->Error(L"The value must be a number.\n");
                    goto Exit;
                }

                genValR8 = wcstod(valString, NULL);
                pNewVal = &genValR8;

                break;

            case ELEMENT_TYPE_CLASS:
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_SZARRAY:
            case ELEMENT_TYPE_ARRAY:
                _ASSERTE(pRefValue != NULL);

                if (!shell->GetInt64Arg(valString, genVal8))
                {
                    shell->Error(L"The value must be a number.\n");
                    goto Exit;
                }

                refVal = (CORDB_ADDRESS)genVal8;

                break;

            default:
                shell->Error(L"Can't set value of variable with type 0x%x\n",
                             type);
                goto Exit;
            }
        }
        
        // Update which every type of value we found.
        if (pGenValue != NULL)
            hr = pGenValue->SetValue(pNewVal);
        else
        {
            _ASSERTE(pRefValue != NULL);
            hr = pRefValue->SetValue(refVal);
        }

        if (SUCCEEDED(hr))
        {
            RELEASE(ivalue);
            
            // Re-get the value for the name provided. This ensures that we've got the true result of the SetValue.
            ivalue = shell->EvaluateExpression(varName, shell->m_currentFrame);

            // If the name provided is valid, print it!
            _ASSERTE(ivalue != NULL);

            // Note: PrintVariable releases ivalue.
            shell->PrintVariable(varName, ivalue, 0, TRUE);
            shell->Write(L"\n");

            ivalue = NULL;
        }
        else
        {
            shell->Error(L"Update failed.\n");
            shell->ReportError(hr);
        }

    Exit:
        if (ivalue)
            RELEASE(ivalue);

        if (pGenValue)
            RELEASE(pGenValue);

        if (pRefValue)
            RELEASE(pRefValue);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {		 
    	ShellCommand::Help(shell);
        shell->Write(L"<variable> <value>\n");
        shell->Write(L"Sets the value of the specified variable to the\n");
        shell->Write(L"specified value. The value can be a literal or\n");
        shell->Write(L"another variable.\n");
		shell->Write(L"\n");
        shell->Write(L"Examples:\n");
        shell->Write(L"   set int1 0x2a\n");
        shell->Write(L"   set float1 3.1415\n");
        shell->Write(L"   set char1 'a'\n");
        shell->Write(L"   set bool1 true\n");
        shell->Write(L"   set obj1 0x12345678\n");
        shell->Write(L"   set obj1 obj2\n");
        shell->Write(L"   set obj1.m_foo[obj1.m_bar] obj3.m_foo[2]\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Modify the value of a variable (locals, statics, etc.)";
    }
};


class ProcessesEnumDebuggerCommand: public DebuggerCommand
{
public:
    ProcessesEnumDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        BOOL fPidSpecified = TRUE;
        int ulPid;
        if (!shell->GetIntArg(args, ulPid))
            fPidSpecified = FALSE;      
        
        ICorPublish *pPublish;

        HRESULT hr = ::CoCreateInstance (CLSID_CorpubPublish, 
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_ICorPublish,
                                        (LPVOID *)&pPublish);

        if (SUCCEEDED (hr))
        {
            ICorPublishProcessEnum *pProcessEnum = NULL;
            ICorPublishProcess  *pProcess [1];
            BOOL fAtleastOne = FALSE;

            if (fPidSpecified == FALSE)
            {
                hr = pPublish->EnumProcesses (COR_PUB_MANAGEDONLY,
                                                &pProcessEnum);
            }
            else
            {
                hr = pPublish->GetProcess (ulPid,
                                           pProcess);                   
            }

            if (SUCCEEDED (hr))
            {
                ULONG ulElemsFetched;

                if (fPidSpecified == FALSE)
                {
                    pProcessEnum->Next (1, pProcess, &ulElemsFetched);
                }
                else
                {
                    ulElemsFetched = 1;
                }

                while (ulElemsFetched != 0)
                {
                    UINT    pid;
                    WCHAR   szName [64];
                    ULONG32 ulNameLength;
                    BOOL    fIsManaged;

                    pProcess [0]->GetProcessID (&pid);
                    pProcess [0]->GetDisplayName (64, &ulNameLength, szName);
                    pProcess [0]->IsManaged (&fIsManaged);

                    if ((fPidSpecified == FALSE) || (pid == ulPid))
                    {

                        shell->Write (L"\nPID=0x%x (%d)  Name=%s\n", pid, pid, szName);

                        fAtleastOne = TRUE;


                        ICorPublishAppDomainEnum *pAppDomainEnum;

                        hr = pProcess [0]->EnumAppDomains (&pAppDomainEnum);

                        if (SUCCEEDED (hr))
                        {
                            ICorPublishAppDomain    *pAppDomain [1];
                            ULONG ulAppDomainsFetched;

                            pAppDomainEnum->Next (1, pAppDomain, &ulAppDomainsFetched);

                            while (ulAppDomainsFetched != 0)
                            {
                                ULONG32 uId;
                                WCHAR   szName [64];
                                ULONG32 ulNameLength;

                                pAppDomain [0]->GetID (&uId);
                                pAppDomain [0]->GetName (64, &ulNameLength, szName);

                                shell->Write (L"\tID=%d  AppDomainName=%s\n", uId, szName);

                                pAppDomain [0]->Release();

                                pAppDomainEnum->Next (1, pAppDomain, &ulAppDomainsFetched);
                            }
                        }
                    }

                    pProcess [0]->Release();

                    if (fPidSpecified == FALSE)
                    {
                        pProcessEnum->Next (1, pProcess, &ulElemsFetched);
                    }
                    else
                    {
                        ulElemsFetched--;
                    }
                }

                if (!fAtleastOne)
                {
                    if (fPidSpecified)
                        shell->Error (L"No managed process with given ProcessId found\n");
                    else
                        shell->Error (L"No managed process found\n");
                }

            }
            if (pProcessEnum != NULL)
                pProcessEnum->Release();
        }           
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
	    ShellCommand::Help(shell);
        shell->Write(L"\n");
        shell->Write(L"Enumerates all managed processes and application\n");
        shell->Write(L"domains in each process.\n"); 
        shell->Write(L"\n");
    }


    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display all managed processes running on the system";
    }
};

#define MAX_APP_DOMAINS     64

enum ADC_PRINT
{
    ADC_PRINT_APP_DOMAINS = 0, 
    ADC_PRINT_ASSEMBLIES,
    ADC_PRINT_MODULES,
    ADC_PRINT_ALL,
};

class AppDomainChooser
{
    ICorDebugAppDomain *m_pAD [MAX_APP_DOMAINS];
    BOOL m_fAttachStatus [MAX_APP_DOMAINS];
    ULONG m_ulAppDomainCount;

public:
    AppDomainChooser()
        : m_ulAppDomainCount(0)
    {
        memset(m_pAD, 0, sizeof(ICorDebugAppDomain*)*MAX_APP_DOMAINS);
        memset(m_fAttachStatus, 0, sizeof(BOOL)*MAX_APP_DOMAINS);
    }

    virtual ~AppDomainChooser()
    {
        for (ULONG i = 0; i < m_ulAppDomainCount; i++)
        {
            if (m_pAD[i] != NULL)
                m_pAD[i]->Release();
        }
    }

#define MAX_NAME_LENGTH (600)
    void PrintAppDomains(ICorDebugAppDomainEnum *pADEnum,
                         ICorDebugAppDomain *pAppDomainCur,
                         ADC_PRINT iPrintVal,
                         DebuggerShell *shell)
    {
		WCHAR   szName [MAX_NAME_LENGTH];
		UINT    ulNameLength;
        ULONG32   id;
        HRESULT hr = S_OK;
        ULONG   ulCount;
            
        hr = pADEnum->Next (MAX_APP_DOMAINS, &m_pAD [0], &m_ulAppDomainCount);

        for (ULONG iADIndex=0; iADIndex < m_ulAppDomainCount; iADIndex++)
        {
        	WCHAR	*pszAttachString;
        	WCHAR   *pszActiveString;
        	bool    fUuidToString = false;
        	
        	m_pAD [iADIndex]->GetName (MAX_NAME_LENGTH, &ulNameLength, (WCHAR *)szName);
        	m_pAD [iADIndex]->IsAttached (&m_fAttachStatus [iADIndex]);
            m_pAD [iADIndex]->GetID(&id);

            if (m_fAttachStatus [iADIndex] == TRUE)
                pszAttachString = L" Attached ";
            else
                pszAttachString = L" Not Attached ";

            if (pAppDomainCur != NULL && pAppDomainCur == m_pAD [iADIndex])
                pszActiveString = L"*";
            else
                pszActiveString = L" ";

            shell->Write (L"\n%d) %s AppDomainName = <%s>\n\tDebugStatus"
                L": <Debugger%s>\n\tID: %d\n", iADIndex+1, 
                pszActiveString, szName, pszAttachString, id);
            
            if (iPrintVal >= ADC_PRINT_ASSEMBLIES)
            {
                ICorDebugAssemblyEnum *pAssemblyEnum = NULL;
                hr = m_pAD [iADIndex]->EnumerateAssemblies (&pAssemblyEnum);

                if (SUCCEEDED (hr))
                {
                    ICorDebugAssembly *pAssembly [1];

        			hr = pAssemblyEnum->Next (1, pAssembly, &ulCount);
        			while (ulCount > 0)
        			{
        				pAssembly [0]->GetName (MAX_NAME_LENGTH, &ulNameLength, (WCHAR *)szName);
        				shell->Write (L"\tAssembly Name : %s\n", szName);

                        if (iPrintVal >= ADC_PRINT_MODULES)
                        {

                            ICorDebugModuleEnum *pModuleEnum = NULL;
                            hr = pAssembly [0]->EnumerateModules (&pModuleEnum);

                            if (SUCCEEDED (hr))
                            {
                                ICorDebugModule *pModule [1];

                                hr = pModuleEnum->Next (1, pModule, &ulCount);

        						while (ulCount > 0)
        						{
        							pModule [0]->GetName (MAX_NAME_LENGTH, &ulNameLength, (WCHAR *)szName);
        							shell->Write (L"\t\tModule Name : %s\n", szName);
                                    pModule [0]->Release();
                                    hr = pModuleEnum->Next (1, pModule, &ulCount);
                                }

                                pModuleEnum->Release();
                            }
                            else
                            {
                                shell->Error (L"ICorDebugAssembly::EnumerateModules() failed!! \n");
                                shell->ReportError (hr);
                            }
                        }

                        pAssembly [0]->Release();
                        hr = pAssemblyEnum->Next (1, &pAssembly [0], &ulCount);         
                    }
                    pAssemblyEnum->Release();
                }
                else
                {
                    shell->Error (L"ICorDebugAppDomain::EnumerateAssemblies() failed!! \n");
                    shell->ReportError (hr);
                }
            }
        }
    }

#define ADC_CHOICE_ERROR (-1)
    ICorDebugAppDomain *GetConsoleChoice(int *piR, DebuggerShell *shell)
    {
        WCHAR strTemp [10+1];
        int iResult;
        if (shell->ReadLine (strTemp, 10))
        {
            WCHAR *p = strTemp;
            if (shell->GetIntArg (p, iResult))
            {
                iResult--; // Since the input is count, and this is index
                if (iResult < 0 || iResult >= (int)m_ulAppDomainCount)
                {
                    shell->Error (L"\nInvalid selection.\n");
                    (*piR) = ADC_CHOICE_ERROR;
                    return NULL;
                }

               (*piR) = iResult; 
                return m_pAD[iResult];
            }
            else
            {
                shell->Error (L"\nInvalid (non numeric) selection.\n");
                
                (*piR) = ADC_CHOICE_ERROR;
                return NULL;
            }
        }
        return NULL;
    }

    BOOL GetAttachStatus(int iResult)
    {
        return m_fAttachStatus[iResult];
    }
};

enum EADDC_CHOICE
{
    EADDC_NONE = 0,
    EADDC_ATTACH,
    EADDC_DETACH,
    EADDC_ASYNC_BREAK,
};

class EnumAppDomainsDebuggerCommand: public DebuggerCommand
{
public:
    EnumAppDomainsDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        HRESULT hr = S_OK;
        EADDC_CHOICE choice = EADDC_NONE;
        
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }

        int iPrintVal;
        if (!shell->GetIntArg(args, iPrintVal))
        {
            WCHAR *szAttachDetach;
            if (!shell->GetStringArg(args, szAttachDetach))
            {
                shell->Write( L"First arg is neither number nor string!\n");
                return;
            }

            iPrintVal = ADC_PRINT_APP_DOMAINS;
            
            if (szAttachDetach[0] == 'a' ||
                szAttachDetach[0] == 'A')
            {
                choice = EADDC_ATTACH;
            }
            else if (szAttachDetach[0] == 'd' ||
                     szAttachDetach[0] == 'D')
            {
                choice = EADDC_DETACH;   
            }
            else if (szAttachDetach[0] == 's' ||
                     szAttachDetach[0] == 'S')
            {
                choice = EADDC_ASYNC_BREAK;   
            }
            else
            {
                iPrintVal = ADC_PRINT_ALL;
            }
        }
        else
        {
            if (iPrintVal > ADC_PRINT_ALL ||
                iPrintVal < ADC_PRINT_APP_DOMAINS)
            {
                shell->Write( L"Command is not recognized.\n");
                return;
            }
        }
        
        ICorDebugAppDomain *pAppDomainCur = NULL;
        if (shell->m_currentThread != NULL)
        {
            hr = shell->m_currentThread->GetAppDomain(&pAppDomainCur);
            if (FAILED(hr))
                pAppDomainCur = NULL;
            else
            {   
                BOOL fAttached;

                if (FAILED(pAppDomainCur->IsAttached(&fAttached)))
                    pAppDomainCur = NULL;

                if (!fAttached)
                    pAppDomainCur = NULL;
            }
        }

        ICorDebugAppDomainEnum *pADEnum = NULL;
        hr = shell->m_currentProcess->EnumerateAppDomains (&pADEnum);
        AppDomainChooser adc;

        ICorDebugAppDomain *pADChosen = NULL;
        
        if (SUCCEEDED (hr))
        {
            adc.PrintAppDomains(pADEnum, pAppDomainCur, (ADC_PRINT)iPrintVal, shell);
            
            pADEnum->Release();

            if (choice != EADDC_NONE)
            {
                WCHAR *szAction;
                switch(choice)
                {
                    case EADDC_ATTACH:
                        szAction = L"attach to";
                        break;
                    case EADDC_DETACH:
                        szAction = L"detach from";
                        break;
                    case EADDC_ASYNC_BREAK:
                        szAction = L"break into";
                        break;
                }
                
                // prompt the user to select one of the app domains to act upon:
                shell->Write (L"\nPlease select the app domain to %s by "
                    L"number.\n", szAction);

                int iResult;
                pADChosen = adc.GetConsoleChoice(&iResult, shell);
                if (NULL == pADChosen)
                    return;
                    
                switch(choice)
                {
                    case EADDC_ATTACH:
                        if (adc.GetAttachStatus(iResult) == FALSE)
                        {
                            pADChosen->Attach();
                        }
                        else
                        {
                            shell->Write (L"Already attached to specified "
                                L"app domain.\n");
                        }
                        break;
                        
                    case EADDC_DETACH:
                        if (adc.GetAttachStatus(iResult) == TRUE)
                        {
                            pADChosen->Detach();
                        }
                        else
                        {
                            shell->Write (L"Already detached from specified "
                                L"app domain.\n");
                        }
                        break;
                        
                    case EADDC_ASYNC_BREAK:
                        hr = shell->AsyncStop(pADChosen);
                        break;
                }
            }
        }
        else
        {
            shell->Error (L"ICorDebugProcess::EnumerateAppDomains() failed!! \n");
            shell->ReportError (hr);
        }

        if (pAppDomainCur != NULL)
            pAppDomainCur->Release();
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {     
    	ShellCommand::Help(shell);
    	shell->Write(L"[<option>]\n");
        shell->Write(L"Enumerates all appdomains, assemblies, and modules in\n");
        shell->Write(L"the current process. After detaching/attaching, you must\n");
        shell->Write(L"use \"go\" in order to resume execution.\n");
        shell->Write(L"\n");
        shell->Write(L"The option argument can be one of the following:\n");
        shell->Write(L"  attach    <Lists the appdomains in the process and prompts\n");
        shell->Write(L"             the user to select the appdomain to attach to.>\n");
        shell->Write(L"  detach    <Lists the appdomains in the process and prompts\n");
        shell->Write(L"             the user to select the appdomain to detach from.>\n");
        shell->Write(L"  0         <Lists only the appdomains in the process.>\n");
        shell->Write(L"  1         <Lists the appdomains and assemblies in the current\n");
        shell->Write(L"             process.>\n");
        shell->Write(L"If the option argument is omitted, the command lists all the\n");
        shell->Write(L"appdomains, assemblies, and modules in the current process.\n");        
        shell->Write(L"\n");
    }


    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display appdomains/assemblies/modules in the current process";
    }
};



class ListDebuggerCommand: public DebuggerCommand
{
public:
    ListDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }


        // Get the type to list.
        WCHAR* varName;
        shell->GetStringArg(args, varName);

        if ((args - varName) == 0)
        {
            shell->Error(L"Incorrect/no arguments specified.\n");
            Help (shell);
            return;
        }

        if ((varName [0] == L'm' || varName [0] == L'M')
            &&
            (varName [1] == L'o' || varName [1] == L'O'))
        {
            g_pShell->ListAllModules (LIST_MODULES);
        }
        else if ((varName [0] == L'c' || varName [0] == L'C')
                 &&
                 (varName [1] == L'l' || varName [1] == L'L'))
        {
            g_pShell->ListAllModules (LIST_CLASSES);
        }
        else if ((varName[0] == L'f' || varName [0] == L'F')
                 &&
                 (varName [1] == L'u' || varName [1] == L'U'))
        {
            g_pShell->ListAllModules (LIST_FUNCTIONS);
        }

        else
            Help (shell);       
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<option>\n");
        shell->Write(L"Displays a list of loaded modules, classes, or\n");
        shell->Write(L"global functions.\n");
        shell->Write(L"\n");
        shell->Write(L"The option argument can be one of the following:\n");
        shell->Write(L"  mod    <List the loaded modules in the process.>\n");
		shell->Write(L"  cl     <List the loaded classes in the process.>\n");
		shell->Write(L"  fu     <List global functions for modules in process.>\n");      
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display loaded modules, classes, or global functions";
    }
};


/* ------------------------------------------------------------------------- *
 * ReadCommandFromFile is used to read commands from a file and execute. 
 * ------------------------------------------------------------------------- */

class ReadCommandFromFile : public DebuggerCommand
{
private:
    FILE *savOld;
    FILE *newFile;

public:
    ReadCommandFromFile(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        WCHAR* fileName;

        shell->GetStringArg(args, fileName);
        
        if (fileName != args)
        {
            MAKE_ANSIPTR_FROMWIDE (fnameA, fileName);
            _ASSERTE (fnameA != NULL);

            newFile = fopen(fnameA, "r");

            if (newFile != NULL)
            {
                savOld = g_pShell->GetM_in();
                g_pShell->PutM_in(newFile);

                while (!feof(newFile))
                    shell->ReadCommand();

                g_pShell->PutM_in(savOld);
                fclose(newFile);
            }
            else
                shell->Write(L"Unable to open input file.\n");
        }
        else
            Help(shell);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
        shell->Write(L"<filename>\n");
        shell->Write(L"Reads commands from the given file and executes them.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Read and execute commands from a file";
    }
};

/* ------------------------------------------------------------------------- *
 * SaveCommandsToFile is used to save commands to a file and execute. 
 * ------------------------------------------------------------------------- */

class SaveCommandsToFile : public DebuggerCommand
{
private:
    FILE *savFile;

public:
    SaveCommandsToFile(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
        savFile = NULL;
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {

        if (savFile == NULL)
        {
            WCHAR* fileName;

            shell->GetStringArg(args, fileName);
            
            if (fileName != args)
            {
                MAKE_ANSIPTR_FROMWIDE (fnameA, fileName);
                _ASSERTE (fnameA != NULL);
                
                savFile = fopen(fnameA, "w");

                if (savFile != NULL)
                {
                    shell->Write(L"Outputing commands to file %S\n",
                                 fnameA);
                    
                    while (!shell->m_quit && (savFile != NULL))
                    {
                        shell->ReadCommand();

                        // Write the command into the file.
                        if (savFile != NULL)
                            shell->PutCommand(savFile);
                    }

                    shell->Write(L"No longer outputing commands to file %S\n",
                                 fnameA);
                }
                else
                    shell->Write(L"Unable to open output file.\n");
            }
            else
                Help(shell);
        }
        else
        {
            if (savFile != NULL)
            {
                fclose(savFile);
                savFile = NULL;
            }
            else
                Help(shell);
        }
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"<filename>\n");
        shell->Write(L"Given a filename, all commands executed will be written\n");
        shell->Write(L"to the file. If no filename is specified, the command\n"); 
        shell->Write(L"stops writing commands to the file.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Write commands to a file";
    }
};


class XtendedSymbolsInfoDebuggerCommand : public DebuggerCommand
{
public:
    XtendedSymbolsInfoDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }


        // Get the modulename and string to look for.
        WCHAR* varName;
        shell->GetStringArg(args, varName);

        if ((args - varName) == 0)
        {
            shell->Error(L"Incorrect/no arguments specified.\n");
            Help (shell);
            return;
        }

        shell->MatchAndPrintSymbols (varName, TRUE);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
        shell->Write(L"<modulename>!<string_to_look_for>\n");
        shell->Write(L"Displays symbols matching the pattern in the given\n");
        shell->Write(L"module. Note '*' can be used to mean \"match anything\".\n");
        shell->Write(L"Any characters after '*' will be ignored.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Display symbols matching a given pattern";
    }
};

class DetachDebuggerCommand : public DebuggerCommand
{
public:
    DetachDebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : DebuggerCommand(name, minMatchLength)
    {
    }

    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
    {
        if (shell->m_currentProcess == NULL)
        {
            shell->Error(L"Process not running.\n");
            return;
        }

        HRESULT hr = shell->m_currentProcess->Detach();
        _ASSERTE(!FAILED(hr));

        shell->SetTargetProcess(NULL);
        shell->SetCurrentThread(NULL, NULL, NULL);
    }

    // Provide help specific to this command
    void Help(Shell *shell)
    {
    	ShellCommand::Help(shell);
    	shell->Write(L"\n");
        shell->Write(L"Detaches the debugger from the current process.\n");
        shell->Write(L"\n");
    }

    const WCHAR *ShortHelp(Shell *shell)
    {
        return L"Detach from the current process";
    }
};

void DebuggerShell::AddCommands()
{
    AddCommand(new AssociateSourceFileCommand(L"associatesource", 2));
    AddCommand(new AttachDebuggerCommand(L"attach", 1));
    AddCommand(new BreakpointDebuggerCommand(L"break", 1));
    AddCommand(new BreakpointDebuggerCommand(L"stop"));
    AddCommand(new CatchDebuggerCommand(L"catch", 2));
    AddCommand(new DetachDebuggerCommand(L"detach", 2));
    AddCommand(new DownDebuggerCommand(L"down", 1));
    AddCommand(new DumpDebuggerCommand(L"dump", 2));
    AddCommand(new EnumAppDomainsDebuggerCommand(L"appdomainenum", 2));
    AddCommand(new FuncEvalDebuggerCommand(L"funceval", 1));
    AddCommand(new GoDebuggerCommand(L"go", 1));
    AddCommand(new GoDebuggerCommand(L"cont", 4));    
    AddCommand(new HelpShellCommand(L"help", 1));
    AddCommand(new HelpShellCommand(L"?", 1));
    AddCommand(new IgnoreDebuggerCommand(L"ignore", 2));
    AddCommand(new KillDebuggerCommand(L"kill", 1));
    AddCommand(new ListDebuggerCommand(L"list", 1));
    AddCommand(new NewObjectDebuggerCommand(L"newobj", 4));
    AddCommand(new NewObjectNCDebuggerCommand(L"newobjnc", 8));
    AddCommand(new NewStringDebuggerCommand(L"newstr", 4));
    AddCommand(new PathDebuggerCommand(L"path", 2));
    AddCommand(new PrintDebuggerCommand(L"print", 1)); 
    AddCommand(new ProcessesEnumDebuggerCommand(L"processenum", 3));
    AddCommand(new QuitDebuggerCommand(L"quit", 1));
    AddCommand(new QuitDebuggerCommand(L"exit", 2));
    AddCommand(new ReadCommandFromFile(L"<", 1));
    AddCommand(new RefreshSourceDebuggerCommand(L"refreshsource", 3));
    AddCommand(new RegistersDebuggerCommand(L"registers", 3));
    AddCommand(new RemoveBreakpointDebuggerCommand(L"remove", 3));
    AddCommand(new RemoveBreakpointDebuggerCommand(L"delete", 3));
    AddCommand(new ResumeDebuggerCommand(L"resume",2));
    AddCommand(new RunDebuggerCommand(L"run", 1));
    AddCommand(new SaveCommandsToFile(L">", 1));  
    AddCommand(new SetDefaultDebuggerCommand(L"regdefault", 4));
    AddCommand(new SetIpDebuggerCommand(L"setip", 5));
    AddCommand(new SetModeDebuggerCommand(L"mode", 1));        
    AddCommand(new SetValueDebuggerCommand(L"set", 3));  
    AddCommand(new ShowDebuggerCommand(L"show", 2));
    AddCommand(new StepDebuggerCommand(L"step", true, 1));
    AddCommand(new StepDebuggerCommand(L"in", true, 1));
    AddCommand(new StepDebuggerCommand(L"si", true));
    AddCommand(new StepDebuggerCommand(L"next", false, 1));
    AddCommand(new StepDebuggerCommand(L"so", false));
    AddCommand(new StepOutDebuggerCommand(L"out", 1));
    AddCommand(new StepSingleDebuggerCommand(L"ssingle", true, 2));
    AddCommand(new StepSingleDebuggerCommand(L"nsingle", false, 2));
    AddCommand(new SuspendDebuggerCommand(L"suspend", 2));    
    AddCommand(new ThreadsDebuggerCommand(L"threads", 1));
    AddCommand(new UpDebuggerCommand(L"up", 1));
    AddCommand(new WhereDebuggerCommand(L"where", 1));
    AddCommand(new WriteMemoryDebuggerCommand( L"writememory", 2)); 
    AddCommand(new WTDebuggerCommand(L"wt", 2));
    AddCommand(new XtendedSymbolsInfoDebuggerCommand(L"x", 1));
    
#ifdef _INTERNAL_DEBUG_SUPPORT_    
    AddCommand(new ConnectDebuggerCommand(L"connect", 4));    
    AddCommand(new ClearUnmanagedExceptionCommand(L"uclear", 2));
    AddCommand(new DisassembleDebuggerCommand(L"disassemble", 3));
    AddCommand(new UnmanagedThreadsDebuggerCommand(L"uthreads", 2));
    AddCommand(new UnmanagedWhereDebuggerCommand(L"uwhere", 2));

#ifdef _DEBUG
    // this is only valid in debug mode becuase relies on debug-only
    // support in metadata and Iceefilegen
    AddCommand(new CompileForEditAndContinueCommand(L"zcompileForEnC", 2));

    // These are here so that we don't ship these commands in the
    // retail version of cordbg.exe
    AddCommand(new EditAndContinueDebuggerCommand(L"zEnC", 2));
    AddCommand(new EditAndContinueDebuggerCommand(L"zenc", 2));
    AddCommand(new SyncAttachDebuggerAtRTStartupCommand(L"syncattach", 2));
#endif
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\disassem.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * disassem.cpp
 * ------------------------------------------------------------------------- */

#include "stdafx.h"

#include "dshell.h"
#include "__file__.ver"

/* ------------------------------------------------------------------------- *
 * Opcode tables
 * ------------------------------------------------------------------------- */
#define OLD_OPCODE_FORMAT 0		// Fix remove after 8/1/99

#include "openum.h"

#define DECLARE_DATA 1

#undef OPDEF
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) L##s,
WCHAR *opcodeName[] =
{
#include "opcode.def"
};

#undef OPDEF
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) args,

OPCODE_FORMAT operandDescription[] =
{
#include "opcode.def"
};

enum OPCODE_CONTROL_TYPE
{
    OPCODE_CONTROL_NEXT,
    OPCODE_CONTROL_BRANCH,
    OPCODE_CONTROL_COND_BRANCH,
    OPCODE_CONTROL_CALL,
    OPCODE_CONTROL_RETURN,
    OPCODE_CONTROL_BREAK,
    OPCODE_CONTROL_THROW,
    OPCODE_CONTROL_META,
    OPCODE_CONTROL_PHI
};

#undef OPDEF
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl)      OPCODE_CONTROL_ ## ctrl,

static OPCODE_CONTROL_TYPE controlTypes[] =
{
#include "opcode.def"
};

//
// table of opcode argument sizes
//

static BYTE argSizes[] =
{
    #define InlineNone_size           0
    #define ShortInlineVar_size       1
    #define InlineVar_size            2
    #define ShortInlineI_size         1
    #define InlineI_size              4
    #define InlineI8_size             8
    #define ShortInlineR_size         4
    #define InlineR_size              8
    #define ShortInlineBrTarget_size  1
    #define InlineBrTarget_size       4
    #define InlineMethod_size         4
    #define InlineField_size          4
    #define InlineType_size     	  4
    #define InlineString_size   	  4
    #define InlineSig_size            4
    #define InlineRVA_size            4
    #define InlineTok_size            4
    #define InlineSwitch_size         -1
    #define InlinePhi_size            -2 
	#define InlineVarTok_size		  0		  // remove

    #undef OPDEF
    #define OPDEF(name,string,pop,push,oprType,opcType,l,s1,s2,ctrl) oprType ## _size ,
    #include "opcode.def"

    #undef InlineNone_size
    #undef ShortInlineVar_size
    #undef InlineVar_size
    #undef ShortInlineI_size
    #undef InlineI_size
    #undef InlineI8_size
    #undef ShortInlineR_size
    #undef InlineR_size
    #undef ShortInlineBrTarget_size
    #undef InlineBrTarget_size
    #undef InlineMethod_size
    #undef InlineField_size
    #undef InlineType_size
    #undef InlineString_size
    #undef InlineSig_size
    #undef InlineRVA_size
    #undef InlineTok_size
    #undef InlineSwitch_size
    #undef InlinePhi_size
};

/* ------------------------------------------------------------------------- *
 * Useful macros
 * ------------------------------------------------------------------------- */

#define READ_STREAM_VALUE(p, t) (*((t*&)(p))++)
#define POP_STACK_VALUE(p, t)   (p += sizeof(t), *(t*)(p-sizeof(t)))

/* ------------------------------------------------------------------------- *
 * Disassembly routines
 * ------------------------------------------------------------------------- */

//
// ReadNextOpcode reads the next opcode from the stream and the current
// opcode maps.
// ip           -> instruction pointer to get opcode from. 
//  result      <- decoded opcode which should be executed.
//              <- pointer past opcode, to opcode's argument
//
const BYTE *ReadNextOpcode(const BYTE *ip,  DWORD *result)
{
    const BYTE *nextIP = ip;
    DWORD opcode = *nextIP++;

    switch (opcode)
    {
    case CEE_PREFIX1:
        opcode = OPCODE(*nextIP++ + 256);
        break;

    default:
        // !!! error on macro?
        break;
    }

    *result = opcode;
    return (nextIP);
}

//
// SkipIP skips past the opcode argument & returns the address of the
// next instruction in the instruction stream.  Note that this is
// not necessarily the next instruction which will be executed.
//
// ip   -> address of argument for the opcode specified in
//          the instruction stream.  Note that this is not an
//          instruction boundary, it is past the opcode.
//      <- returns a pointer to the  next instruction in the
//          stream.
//

const BYTE *SkipIP(const BYTE *ip, DWORD opcode)
{
    if (opcode == CEE_SWITCH)
    {
        unsigned int numcases = READ_STREAM_VALUE(ip, int);

        return (ip + (numcases*4));
    }
    else
        return (ip + argSizes[opcode]);
}

void DisassembleToken(IMetaDataImport *i,
                      DWORD token, WCHAR *buffer)
{
    HRESULT hr;

    switch (TypeFromToken(token))
    {
    default:
        swprintf(buffer, L"<unknown token type %08x>", TypeFromToken(token));
        break;

    case mdtTypeDef:
        {
            ULONG cLen;
            WCHAR szName[50];

            hr = i->GetTypeDefProps(token, szName, 49, &cLen, NULL, NULL);

            if (FAILED(hr))
                wcscpy(szName, L"<unknown type def>");

            swprintf(buffer, L"%s", szName);
        }
        break;

    case mdtTypeRef:
        {
            ULONG cLen;
            WCHAR szName[50];

            hr = i->GetTypeRefProps(token, NULL, szName, 49, &cLen);

            if (FAILED(hr))
                wcscpy(szName, L"<unknown type ref>");

            swprintf(buffer, L"%s", szName);
        }
        break;

    case mdtFieldDef:
        {
            ULONG cLen;
            WCHAR szFieldName[50];
            WCHAR szClassName[50];
            mdTypeDef mdClass;

            hr = i->GetFieldProps(token, &mdClass, szFieldName, 49, &cLen, 
                                  NULL, NULL, NULL, NULL, NULL, NULL);

            if (FAILED(hr))
                wcscpy(szFieldName, L"<unknown field def>");

            hr = i->GetTypeDefProps(mdClass, szClassName, 49, &cLen,
                                    NULL, NULL);

            if (FAILED(hr))
                wcscpy(szClassName, L"<unknown type def>");

            swprintf(buffer, L"%s::%s", szClassName, szFieldName);
        }
        break;

    case mdtMethodDef:
        {
            ULONG cLen;
            WCHAR szFieldName[50];
            WCHAR szClassName[50];
            mdTypeDef mdClass;

            hr = i->GetMethodProps(token, &mdClass, szFieldName, 49, &cLen, 
                                   NULL, NULL, NULL, NULL, NULL);

            if (FAILED(hr))
                wcscpy(szFieldName, L"<unknown method def>");

            hr = i->GetTypeDefProps(mdClass, szClassName, 49, &cLen,
                                    NULL, NULL);

            if (FAILED(hr))
                wcscpy(szClassName, L"<unknown type def>");

            swprintf(buffer, L"%s::%s", szClassName, szFieldName);
        }
        break;

    case mdtMemberRef:
        {
            mdTypeRef cr = mdTypeRefNil;
            LPWSTR pMemberName;
            WCHAR memberName[50];
            ULONG memberNameLen;

            hr = i->GetMemberRefProps(token, &cr, memberName, 49,
                                      &memberNameLen, NULL, NULL);

            if (FAILED(hr))
            {
                pMemberName = L"<unknown member ref>";
            }
            else
                pMemberName = memberName;

            ULONG cLen;
            WCHAR szName[50];

            if(TypeFromToken(cr) == mdtTypeRef)
            {
                if (FAILED(i->GetTypeRefProps(cr, NULL, szName, 50, &cLen)))
                {
                    wcscpy(szName, L"<unknown type ref>");
                }
            }
            else if(TypeFromToken(cr) == mdtTypeDef)
            {
                if (FAILED(i->GetTypeDefProps(cr, szName, 49, &cLen,
                                              NULL, NULL)))
                {
                    wcscpy(szName, L"<unknown type def>");
                }
            }
            swprintf(buffer, L"%s::%s ", szName, pMemberName);
            buffer += wcslen(buffer);
        }
        break;
    }
}

void DisassembleArgument(BYTE *ip, DWORD address, int type, WCHAR *buffer)
{
    /* 
     * !!! this code isn't processor portable.  
     */

    switch (type)
    {
    case InlineNone:
        *buffer = L'\0';
        break;

    case ShortInlineI:
        swprintf(buffer, L"%d", *(char *)ip);
        break;

    case ShortInlineVar:
        swprintf(buffer, L"%u", *(unsigned char *)ip);
        break;

    case InlineVar:
        swprintf(buffer, L"%u", *(unsigned short *)ip);
        break;

    case InlineI:
        swprintf(buffer, L"%d", *(int *)ip);
        break;

    case InlineI8:
        swprintf(buffer, L"%I64d", *(__int64 *)ip);
        break;

    case ShortInlineR:
        swprintf(buffer, L"%g", *(float *)ip);
        break;

    case InlineR:
        swprintf(buffer, L"%g", *(double *)ip);
        break;

    case ShortInlineBrTarget:
        swprintf(buffer, L"[%.4x]", address + 1 + *(char *)ip);
        break;

    case InlineBrTarget:
        swprintf(buffer, L"[%.4x]", address + 4 + *(int*)ip);
        break;

    case InlineSwitch:
        {
            DWORD caseCount = *(unsigned int*)ip;
            ip += 4;

            address += caseCount*4 + 4;

            DWORD index = 0;
            while (index < caseCount)
            {
                int offset = *(int *)ip;
                buffer += wcslen(buffer);
                swprintf(buffer, L"%d:[%.4x] ", index, address + offset);
                index++;
                ip += 4;
            }
        }
        break;

    case InlinePhi:
        {
            DWORD caseCount = *(unsigned char*)ip;
            ip += 1;

            DWORD index = 0;
            while (index < caseCount)
            {
                buffer += wcslen(buffer);
                swprintf(buffer, L"%d:[%.4x] ", index, *((unsigned short*) ip));
                index++;
                ip += 2;
            }
        }
        break;

    case InlineTok:
    case InlineMethod:
    case InlineField:
    case InlineType:
    case InlineSig:
        swprintf(buffer, L"%d", *(unsigned int *)ip);
        break;

    case InlineString:
        swprintf(buffer, L"%08x", *(unsigned int *)ip);
        break;

    default:
        swprintf(buffer, L"<unknown type %d>", type);
    }
}

/*static*/ SIZE_T DebuggerFunction::WalkInstruction(BOOL native,
                                                    SIZE_T offset,
                                                    BYTE *codeStart,
                                                    BYTE *codeEnd)
{
    BYTE *code = codeStart + offset;

    if (!native)
    {
        DWORD opcode;
        code = (BYTE *) ReadNextOpcode(code, &opcode);
        code = (BYTE *) SkipIP(code, opcode);

        return (code - codeStart);
    }
    else
    {
        if (!g_pShell->InitDisassembler())
            return (0xffff);

        size_t cb = ((DIS *)(g_pShell->m_pDIS))->CbDisassemble(0, 
        										   			   (const void*) code,
                                                               (codeEnd - codeStart) - offset);

        // If the disassemble fails
        if (cb == 0)
            return (0xffff);

        return (offset + cb);
    }
}

/*static*/ SIZE_T DebuggerFunction::Disassemble(BOOL native,
                                                SIZE_T offset,
                                                BYTE *codeStart,
                                                BYTE *codeEnd,
                                                WCHAR *buffer,
                                                BOOL noAddress,
                                                DebuggerModule *module,
                                                BYTE *ilCode)
{
    SIZE_T ret;

    if (!native)
    {
        //
        // Write the address
        //
        swprintf(buffer, L"[IL:%.4x] ", offset);
        buffer += wcslen(buffer);

        //
        // Read next opcode
        //
        BYTE *ip = codeStart + offset;
        DWORD opcode;
        BYTE *prevIP = ip;
        ip = (BYTE *) ReadNextOpcode(ip, &opcode);

        //
        // Get the end of the instruction
        //
        BYTE *nextIP = (BYTE *) SkipIP(ip, opcode);

        BYTE *bytes = prevIP;

        //
        // Dump the raw value of the stream
        //
        while (bytes < ip)
        {
            swprintf(buffer, L"%.2x", *bytes++);
            buffer += wcslen(buffer);
        }
        *buffer++ = ':';
        while (bytes < nextIP)
        {
            swprintf(buffer, L"%.2x", *bytes++);
            buffer += wcslen(buffer);
        }

        while (bytes++ - prevIP < 8)
        {
            *buffer++ = L' ';
            *buffer++ = L' ';
        }

        //
        // Print the opcode
        //
        swprintf(buffer, L"%s\t", opcodeName[opcode]);
        buffer += wcslen(buffer);

        int tokenType = operandDescription[opcode];

        if (tokenType == InlineSwitch)
        {
            *buffer++ = L'\n';

            DWORD caseCount = *(unsigned int*)ip;
            ip += 4;

            DWORD endOffset = (ip + (caseCount*4)) - ilCode;

            DWORD index = 0;
            while (index < caseCount)
            {
                int offset = *(int *)ip;
                swprintf(buffer, L"\t\t\t%.5d:[%.4x]\n", index,
                        *((unsigned short*) ip));
                buffer += wcslen(buffer);
                index++;
                ip += 4;
            }
        }
        else if (tokenType == InlinePhi)
        {
            *buffer++ = L'\n';

            DWORD caseCount = *(unsigned char*)ip;
            ip += 1;

            DWORD index = 0;
            while (index < caseCount)
            {
                swprintf(buffer, L"\t\t\t%.5d: [%.4x]\n", index, *((unsigned short*) ip));
                buffer += wcslen(buffer);
                index++;
                ip += 2;
            }
        }
        else if (tokenType == InlineTok || tokenType == InlineType || 
			     tokenType == InlineField ||  tokenType == InlineMethod)
        {
            DisassembleToken(module->GetMetaData(), *(DWORD *)ip, buffer);
            buffer += wcslen(buffer);
        }
        else
        {
            DisassembleArgument(ip, ip - ilCode, tokenType, buffer);
            buffer += wcslen(buffer);
        }

        ret = nextIP - ilCode;
    }
    else
    {
        BYTE *ip = codeStart + offset;

        // Write the address
        if (!noAddress)
        {
            swprintf(buffer, L"[%.4x] ", offset);
            buffer += wcslen(buffer);
        }

        if (!g_pShell->InitDisassembler())
            return (0xffff);

        size_t cb = ((DIS *)(g_pShell->m_pDIS))->CbDisassemble(0,
                                                               (const void*) ip, 
                                                               (DWORD) codeEnd - offset);

        if (cb == 0)
            return (0xffff);

        if (cb != 0)
        {
            char db[256];
            
#ifndef _ALPHA_ // msdis not currently supported on Alpha
            size_t len = ((DIS *)(g_pShell->m_pDIS))->CchFormatInstr(db, 256);
#else // _ALPHA_
            size_t len = 0;
#endif // !_ALPHA_
            
            _ASSERTE(len < 256);

            if (len == 0)
                return (0xffff);

            swprintf(buffer, L"%S", db);
            buffer += wcslen(buffer);

            ret = offset + cb;
        }
        else
        {
            swprintf(buffer, L"<invalid instruction>");
            buffer += wcslen(buffer);
            ret = offset+1;
        }
    }

    *buffer++ = L'\n';
    *buffer = L'\0';

    return (ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\inc\dbgipceventtypes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Events that go both ways
IPC_EVENT_TYPE0(DB_IPCE_INVALID_EVENT                ,0x0000)
IPC_EVENT_TYPE0(DB_IPCE_TYPE_MASK                    ,0x0FFF)

// Events that travel from the RC to the DI (Left to Right)
IPC_EVENT_TYPE1(DB_IPCE_RUNTIME_FIRST                ,0x0100)
IPC_EVENT_TYPE1(DB_IPCE_BREAKPOINT                   ,0x0100)
IPC_EVENT_TYPE1(DB_IPCE_SYNC_COMPLETE                ,0x0102)
IPC_EVENT_TYPE1(DB_IPCE_THREAD_ATTACH                ,0x0103)
IPC_EVENT_TYPE1(DB_IPCE_THREAD_DETACH                ,0x0104)
IPC_EVENT_TYPE1(DB_IPCE_LOAD_MODULE                  ,0x0105)
IPC_EVENT_TYPE1(DB_IPCE_UNLOAD_MODULE                ,0x0106)
IPC_EVENT_TYPE1(DB_IPCE_LOAD_CLASS                   ,0x0107)
IPC_EVENT_TYPE1(DB_IPCE_UNLOAD_CLASS                 ,0x0108)
IPC_EVENT_TYPE1(DB_IPCE_EXCEPTION                    ,0x0109)
IPC_EVENT_TYPE1(DB_IPCE_UNHANDLED_EXCEPTION          ,0x010A)
IPC_EVENT_TYPE1(DB_IPCE_STACK_TRACE_RESULT           ,0x010B)
IPC_EVENT_TYPE1(DB_IPCE_FUNCTION_DATA_RESULT         ,0x010C)
IPC_EVENT_TYPE1(DB_IPCE_BREAKPOINT_ADD_RESULT        ,0x010D)
IPC_EVENT_TYPE1(DB_IPCE_STEP_RESULT                  ,0x010E)
IPC_EVENT_TYPE1(DB_IPCE_STEP_COMPLETE                ,0x010F)
IPC_EVENT_TYPE1(DB_IPCE_BREAKPOINT_REMOVE_RESULT     ,0x0111)
IPC_EVENT_TYPE1(DB_IPCE_GET_OBJECT_INFO_RESULT       ,0x0112)
IPC_EVENT_TYPE1(DB_IPCE_GET_CLASS_INFO_RESULT        ,0x0113)
IPC_EVENT_TYPE1(DB_IPCE_GET_CODE_RESULT              ,0x0114)
IPC_EVENT_TYPE1(DB_IPCE_GET_BUFFER_RESULT            ,0x0115)
IPC_EVENT_TYPE1(DB_IPCE_RELEASE_BUFFER_RESULT        ,0x0116)
IPC_EVENT_TYPE1(DB_IPCE_COMMIT_RESULT                ,0x0117)
IPC_EVENT_TYPE1(DB_IPCE_GET_JIT_INFO_RESULT          ,0x0119)
IPC_EVENT_TYPE1(DB_IPCE_GET_FLOAT_STATE_RESULT       ,0x011A)
IPC_EVENT_TYPE1(DB_IPCE_GET_EXCEPTION_RESULT         ,0x011B)
IPC_EVENT_TYPE1(DB_IPCE_USER_BREAKPOINT              ,0x011C)
IPC_EVENT_TYPE1(DB_IPCE_FIRST_LOG_MESSAGE            ,0x011D)
IPC_EVENT_TYPE1(DB_IPCE_CONTINUED_LOG_MESSAGE        ,0x011E)
IPC_EVENT_TYPE1(DB_IPCE_LOGSWITCH_SET_MESSAGE        ,0x011F)
IPC_EVENT_TYPE1(DB_IPCE_CREATE_APP_DOMAIN            ,0x0120)
IPC_EVENT_TYPE1(DB_IPCE_EXIT_APP_DOMAIN              ,0x0121)
IPC_EVENT_TYPE1(DB_IPCE_LOAD_ASSEMBLY                ,0x0122)
IPC_EVENT_TYPE1(DB_IPCE_UNLOAD_ASSEMBLY              ,0x0123)
IPC_EVENT_TYPE1(DB_IPCE_SET_DEBUG_STATE_RESULT       ,0x0124)
IPC_EVENT_TYPE1(DB_IPCE_FUNC_EVAL_SETUP_RESULT       ,0x0125)
IPC_EVENT_TYPE1(DB_IPCE_FUNC_EVAL_COMPLETE           ,0x0126)
IPC_EVENT_TYPE1(DB_IPCE_SET_REFERENCE_RESULT         ,0x0127)
IPC_EVENT_TYPE1(DB_IPCE_APP_DOMAIN_NAME_RESULT       ,0x0128)
IPC_EVENT_TYPE1(DB_IPCE_FUNC_EVAL_ABORT_RESULT       ,0x0129)
IPC_EVENT_TYPE1(DB_IPCE_NAME_CHANGE				     ,0x012a)
IPC_EVENT_TYPE1(DB_IPCE_THREAD_OBJECT_RESULT         ,0x012b)
IPC_EVENT_TYPE1(DB_IPCE_UPDATE_MODULE_SYMS           ,0x012c)
IPC_EVENT_TYPE1(DB_IPCE_GET_SPECIAL_STATIC_RESULT    ,0x012d)
IPC_EVENT_TYPE1(DB_IPCE_CHANGE_JIT_INFO_RESULT       ,0x012e)
IPC_EVENT_TYPE1(DB_IPCE_CONTROL_C_EVENT              ,0x012f)
IPC_EVENT_TYPE1(DB_IPCE_FUNC_EVAL_CLEANUP_RESULT     ,0x0130)
IPC_EVENT_TYPE1(DB_IPCE_ENC_REMAP                    ,0x0131)
IPC_EVENT_TYPE1(DB_IPCE_GET_SYNC_BLOCK_FIELD_RESULT  ,0x0132)
IPC_EVENT_TYPE1(DB_IPCE_SET_VALUE_CLASS_RESULT		 ,0x0133)
IPC_EVENT_TYPE1(DB_IPCE_BREAKPOINT_SET_ERROR         ,0x0134)

// Events that travel from the DI to the RC (Right to Left)
IPC_EVENT_TYPE2(DB_IPCE_DEBUGGER_FIRST               ,0x0200)
IPC_EVENT_TYPE2(DB_IPCE_ASYNC_BREAK                  ,0x0200)
IPC_EVENT_TYPE2(DB_IPCE_CONTINUE                     ,0x0201)
IPC_EVENT_TYPE2(DB_IPCE_LIST_THREADS                 ,0x0202)
IPC_EVENT_TYPE2(DB_IPCE_STACK_TRACE                  ,0x0203)
IPC_EVENT_TYPE2(DB_IPCE_SET_DEBUG_STATE              ,0x0204)
IPC_EVENT_TYPE2(DB_IPCE_SET_IP                       ,0x0205)
IPC_EVENT_TYPE2(DB_IPCE_SUSPEND_THREAD               ,0x0206)
IPC_EVENT_TYPE2(DB_IPCE_RESUME_THREAD                ,0x0207)
IPC_EVENT_TYPE2(DB_IPCE_GET_FUNCTION_DATA            ,0x0208)
IPC_EVENT_TYPE2(DB_IPCE_BREAKPOINT_ADD               ,0x0209)
IPC_EVENT_TYPE2(DB_IPCE_BREAKPOINT_REMOVE            ,0x020A)
IPC_EVENT_TYPE2(DB_IPCE_STEP_CANCEL                  ,0x020B)
IPC_EVENT_TYPE2(DB_IPCE_STEP                         ,0x020C)
IPC_EVENT_TYPE2(DB_IPCE_STEP_OUT                     ,0x020D)
IPC_EVENT_TYPE2(DB_IPCE_GET_OBJECT_INFO              ,0x020E)
IPC_EVENT_TYPE2(DB_IPCE_GET_CLASS_INFO               ,0x020F)
IPC_EVENT_TYPE2(DB_IPCE_GET_CODE                     ,0x0210)
IPC_EVENT_TYPE2(DB_IPCE_GET_BUFFER                   ,0x0211)
IPC_EVENT_TYPE2(DB_IPCE_RELEASE_BUFFER               ,0x0212)
IPC_EVENT_TYPE2(DB_IPCE_COMMIT                       ,0x0213)
IPC_EVENT_TYPE2(DB_IPCE_CHANGE_JIT_DEBUG_INFO        ,0x0214)
IPC_EVENT_TYPE2(DB_IPCE_GET_JIT_INFO                 ,0x0215)
IPC_EVENT_TYPE2(DB_IPCE_GET_FLOAT_STATE              ,0x0216)
IPC_EVENT_TYPE2(DB_IPCE_SET_CLASS_LOAD_FLAG          ,0x0217)
IPC_EVENT_TYPE2(DB_IPCE_GET_EXCEPTION                ,0x0218)
IPC_EVENT_TYPE2(DB_IPCE_CONTINUE_EXCEPTION           ,0x0219)
IPC_EVENT_TYPE2(DB_IPCE_ATTACHING                    ,0x021A)
IPC_EVENT_TYPE2(DB_IPCE_GET_RO_DATA_RVA              ,0x021E)
IPC_EVENT_TYPE2(DB_IPCE_GET_RW_DATA_RVA              ,0x021F)
IPC_EVENT_TYPE2(DB_IPCE_GET_DATA_RVA_RESULT          ,0x0220)
IPC_EVENT_TYPE2(DB_IPCE_IS_TRANSITION_STUB           ,0x0221)
IPC_EVENT_TYPE2(DB_IPCE_IS_TRANSITION_STUB_RESULT    ,0x0222)
IPC_EVENT_TYPE2(DB_IPCE_MODIFY_LOGSWITCH             ,0x0223)
IPC_EVENT_TYPE2(DB_IPCE_ENABLE_LOG_MESSAGES          ,0x0224)
IPC_EVENT_TYPE2(DB_IPCE_FUNC_EVAL                    ,0x0225)
IPC_EVENT_TYPE2(DB_IPCE_VALIDATE_OBJECT              ,0x0226)
IPC_EVENT_TYPE2(DB_IPCE_DISCARD_OBJECT               ,0x0227)
IPC_EVENT_TYPE2(DB_IPCE_SET_REFERENCE                ,0x0228)
IPC_EVENT_TYPE2(DB_IPCE_ATTACH_TO_APP_DOMAIN         ,0x0229)
IPC_EVENT_TYPE2(DB_IPCE_DETACH_FROM_APP_DOMAIN       ,0x022a)
IPC_EVENT_TYPE2(DB_IPCE_GET_APP_DOMAIN_NAME          ,0x022b)
IPC_EVENT_TYPE2(DB_IPCE_FUNC_EVAL_ABORT              ,0x022c)
IPC_EVENT_TYPE2(DB_IPCE_GET_THREAD_OBJECT            ,0x022d)
IPC_EVENT_TYPE2(DB_IPCE_GET_SPECIAL_STATIC           ,0x022e)
IPC_EVENT_TYPE2(DB_IPCE_DETACH_FROM_PROCESS          ,0x022f)
IPC_EVENT_TYPE2(DB_IPCE_CONTROL_C_EVENT_RESULT       ,0x0230)
IPC_EVENT_TYPE2(DB_IPCE_FUNC_EVAL_CLEANUP            ,0x0231)
IPC_EVENT_TYPE2(DB_IPCE_SET_ALL_DEBUG_STATE          ,0x0232)
IPC_EVENT_TYPE2(DB_IPCE_GET_SYNC_BLOCK_FIELD         ,0x0233)
IPC_EVENT_TYPE2(DB_IPCE_SET_VALUE_CLASS				 ,0x0234)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\dshell.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * debug\comshell.h: com debugger shell class
 * ------------------------------------------------------------------------- */

#ifndef __DSHELL_H__
#define __DSHELL_H__

#include <stdio.h>

#define ADDRESS IMAGHLP_ADDRESS
#include <imagehlp.h>
#undef ADDRESS

#undef CreateProcess

#include "cor.h"
#include "shell.h"
#include "corpub.h"
#include "corsym.h"
#include "cordebug.h"
#include "corerror.h"


#ifdef _INTERNAL_DEBUG_SUPPORT_
#include <msdis.h>

#ifdef _X86_
#include <disx86.h>
#endif
#else
#include <strstream>		   // For std::ostream
#endif

#include <imagehlp.h>

#define PTR_TO_CORDB_ADDRESS(_ptr) (CORDB_ADDRESS)(ULONG)(_ptr)
            
#define REG_COMPLUS_KEY          "Software\\Microsoft\\.NETFramework\\"
#define REG_COMPLUS_DEBUGGER_KEY "DbgManagedDebugger"

// Names of registry keys used to hold the source files path.
#define REG_DEBUGGER_KEY  REG_COMPLUS_KEY "Samples\\CorDbg"
#define REG_SOURCES_KEY  "CorDbgSourceFilePath"
#define REG_MODE_KEY     "CorDbgModes"

#define MAX_MODULES					    512
#define MAX_FILE_MATCHES_PER_MODULE		4
#define MAX_EXT							20
#define MAX_PATH_ELEMS					64
#define MAX_CACHE_ELEMS					256

#define MAX_SYMBOL_NAME_LENGTH			256

enum
{
    NULL_THREAD_ID = -1,
    NULL_PROCESS_ID = -1
};

enum ListType
{
	LIST_MODULES = 0,
	LIST_CLASSES,
	LIST_FUNCTIONS
};

#define SETBITULONG64( x ) ( (ULONG64)1 << (x) )

// Define max source file buckets for source file cache present for each module
#define MAX_SF_BUCKETS      9

// Modes used in the shell to control various global settings.
enum DebuggerShellModes
{
    DSM_DISPLAY_REGISTERS_AS_HEX        = 0x00000001,
    DSM_WIN32_DEBUGGER                  = 0x00000002,
    DSM_SEPARATE_CONSOLE                = 0x00000004,
    DSM_ENABLE_JIT_OPTIMIZATIONS        = 0x00000008,
    DSM_SHOW_CLASS_LOADS                = 0x00000020,
    DSM_SHOW_MODULE_LOADS               = 0x00000040,
    DSM_SHOW_UNMANAGED_TRACE            = 0x00000080,
    DSM_IL_NATIVE_PRINTING              = 0x00000100,
    DSM_SHOW_ARGS_IN_STACK_TRACE        = 0x00000200,
    DSM_UNMAPPED_STOP_PROLOG            = 0x00000400,
    DSM_UNMAPPED_STOP_EPILOG            = 0x00000800,
    DSM_UNMAPPED_STOP_UNMANAGED         = 0x00001000,
    DSM_UNMAPPED_STOP_ALL               = 0x00002000,
    DSM_INTERCEPT_STOP_CLASS_INIT       = 0x00004000,
    DSM_INTERCEPT_STOP_EXCEPTION_FILTER = 0x00008000,
    DSM_INTERCEPT_STOP_SECURITY         = 0x00010000,    
    DSM_INTERCEPT_STOP_CONTEXT_POLICY   = 0x00020000,
    DSM_INTERCEPT_STOP_INTERCEPTION     = 0x00040000,
    DSM_INTERCEPT_STOP_ALL              = 0x00080000,  
    DSM_SHOW_APP_DOMAIN_ASSEMBLY_LOADS  = 0x00100000,
    DSM_ENHANCED_DIAGNOSTICS            = 0x00200000,
    DSM_SHOW_MODULES_IN_STACK_TRACE     = 0x00400000,
    DSM_LOGGING_MESSAGES                = 0x01000000,
    DSM_DUMP_MEMORY_IN_BYTES            = 0x02000000,
    DSM_SHOW_SUPERCLASS_ON_PRINT        = 0x04000000,
    DSM_SHOW_STATICS_ON_PRINT           = 0x08000000,
    DSM_EMBEDDED_CLR                    = 0x10000000,

    DSM_MAXIMUM_MODE             = 27, // count of all modes, not a mask.
    DSM_INVALID_MODE             = 0x00000000,
    DSM_DEFAULT_MODES            = DSM_DISPLAY_REGISTERS_AS_HEX |
                                   DSM_SHOW_ARGS_IN_STACK_TRACE |
                                   DSM_SHOW_MODULES_IN_STACK_TRACE,
    // Some modes aren't allowed to change after the debuggee has started
    // running b/c we depend on them to reflect the state of the debuggee.
    DSM_CANT_CHANGE_AFTER_RUN    = DSM_WIN32_DEBUGGER
};

// A helper function which will return the generic interface for
// either the appdomain or process.
ICorDebugController *GetControllerInterface(ICorDebugAppDomain *pAppDomain);

// Structure used to define information about debugger shell modes.
struct DSMInfo
{
    DebuggerShellModes  modeFlag;
    WCHAR              *name;
    WCHAR              *onDescription;
    WCHAR              *offDescription;
    WCHAR              *generalDescription;
    WCHAR              *descriptionPad;
};


/* ------------------------------------------------------------------------- *
 * Forward declarations
 * ------------------------------------------------------------------------- */

class DebuggerBreakpoint;
class DebuggerCodeBreakpoint;
class DebuggerSourceCodeBreakpoint;
class DebuggerModule;
class DebuggerUnmanagedThread;
class DebuggerManagedThread;
class DebuggerSourceFile;
class DebuggerFunction;
class DebuggerFilePathCache;
class ModuleSourceFile;

/* ------------------------------------------------------------------------- *
 * Debugger FilePathCache
 * This class keeps track of the fully qualified filename for each module
 * for files which were opened as a result of hitting a breakpoint, stack 
 * trace, etc. This will be persisted for later runs of the debugger.
 * ------------------------------------------------------------------------- */
class DebuggerFilePathCache
{
private:
	CHAR			*m_rstrPath [MAX_PATH_ELEMS];
	int				m_iPathCount;
	CHAR			*m_rpstrModName [MAX_CACHE_ELEMS];
	ISymUnmanagedDocument	*m_rDocs [MAX_CACHE_ELEMS];
	CHAR			*m_rpstrFullPath [MAX_CACHE_ELEMS];
	int				m_iCacheCount;

	WCHAR			m_szExeName [MAX_PATH];

public:
	// Constructor
	DebuggerFilePathCache()
	{
		for (int i=0; i<MAX_PATH_ELEMS; i++)
			m_rstrPath [i] = NULL;
		m_iPathCount = 0;

		m_iCacheCount = 0;

		m_szExeName [0] = L'\0';
	}

	// Destructor
	~DebuggerFilePathCache()
	{
		for (int i=0; i<m_iPathCount; i++)
			delete [] m_rstrPath [i];

		for (i=0; i<m_iCacheCount; i++)
		{
			delete [] m_rpstrModName [i];
			delete [] m_rpstrFullPath [i];
		}
	}

	HRESULT Init (void);
	HRESULT	InitPathArray (WCHAR *pstrName);
	int  GetPathElemCount (void) { return m_iPathCount;}
	CHAR *GetPathElem (int iIndex) { return m_rstrPath [iIndex];}
	int	 GetFileFromCache (DebuggerModule *pModule, ISymUnmanagedDocument *doc,
                           CHAR **ppstrFName);	
	BOOL UpdateFileCache (DebuggerModule *pModule, ISymUnmanagedDocument *doc,
                          CHAR *pFullPath);
};

class ModuleSearchElement
{
private:
	char *pszName;
	ModuleSearchElement *pNext;

public:
	ModuleSearchElement() 
	{
		pszName = NULL;
		pNext = NULL;
	}

	~ModuleSearchElement()
	{
		delete [] pszName;
	}

	void SetName (char *szModName)
	{
		pszName = new char [strlen(szModName) + 1];

		if (pszName)
		{
			strcpy (pszName, szModName);
		}
	}

	char *GetName (void) { return pszName;}

	void SetNext (ModuleSearchElement *pEle) { pNext = pEle;}
	ModuleSearchElement *GetNext (void) { return pNext;}
};

class ModuleSearchList
{
private:
	ModuleSearchElement *pHead;
public:
	ModuleSearchList()
	{
		pHead = NULL;
	}

	~ModuleSearchList()
	{
		ModuleSearchElement *pTemp;
		while (pHead)
		{
			pTemp = pHead;
			pHead = pHead->GetNext();
			delete pTemp;
		}		
	}

	BOOL ModuleAlreadySearched (char *szModName)
	{
		ModuleSearchElement *pTemp = pHead;
		while (pTemp)
		{
			char *pszName = pTemp->GetName();
			if (pszName)
				if (!strcmp (pszName, szModName))
					return TRUE;
			pTemp = pTemp->GetNext();
		}

		return FALSE;
	}
	void AddModuleToAlreadySearchedList (char *szModName)
	{
		ModuleSearchElement *pTemp = new ModuleSearchElement;
		if (pTemp)
		{
			pTemp->SetName (szModName);
			pTemp->SetNext (pHead);
			pHead = pTemp;
		}		
	}	
};
/*
#define TRACK_CORDBG_INSTANCES
typedef enum {
    eCrodbgMaxDerived, 
    eCordbgMaxThis = 1024,
    eCordbgUnknown
} enumCordbgClass;

class InstanceTracker
{
private:
#ifdef TRACK_CORDBG_INSTANCES
    static LONG m_saDwInstance[eCrodbgMaxDerived]; // instance x this
    static LONG m_saDwAlive[eCrodbgMaxDerived];
    static PVOID m_sdThis[eCrodbgMaxDerived][eCordbgMaxThis];
#endif
    
public: 
    InstanceTracker()
    {
    }
        
    static void OnCreation(eCordbgUnknown eType, PVOID pThis)
    {
#ifdef TRACK_CORDBG_INSTANCES
        DWROD dwInstance = InterlockedIncrement(&InstanceTracker::m_saDwInstance[eType]);
        InterlockedIncrement(&InstanceTracker::m_saDwAlive[eType]);
        if (dwInstance < eCordbgMaxThis)
        {
            m_sdThis[eType][dwInstance] = pThis;
        }
#endif
    }
    
    static void OnDeletion(eCordbgUnknown eType, PVOID pThis)
    {
#ifdef TRACK_CORDBG_INSTANCES
        DWORD dwInstance;
        for (dwInstance = 0; dwInstance <= InstanceTracker::m_saDwInstance[eType]; dwInstance++)
        {
            if (pThis == m_sdThis[eType][dwInstance])
            {
                break;
            }
        }
        _ASSERT(dwInstance < InstanceTracker::m_saDwInstance[eType] && pThis == m_sdThis[eType][dwInstance]);
        InterlockedDecrement(&InstanceTracker::m_saDwAlive[eType]);
        m_sdThis[eType][dwInstance] = NULL;
#endif
    }
};*/

/* ------------------------------------------------------------------------- *
 * Base class
 * ------------------------------------------------------------------------- */

class DebuggerBase
{
public:
    DebuggerBase(ULONG token) : m_token(token)
    {
        
    }
    virtual ~DebuggerBase()
    {
        
    }

    ULONG GetToken()
    {
        return(m_token);
    }

protected:
    ULONG   m_token;
};

/* ------------------------------------------------------------------------- *
 * HashTable class
 * ------------------------------------------------------------------------- */

struct DebuggerHashEntry
{
    FREEHASHENTRY entry;
    DebuggerBase* pBase;
};

class DebuggerHashTable : private CHashTableAndData<CNewData>
{
private:
    bool    m_initialized;

    BOOL Cmp(const BYTE* pc1, const HASHENTRY* pc2)
    {
        return((ULONG)pc1) != ((DebuggerHashEntry*)pc2)->pBase->GetToken();
    }

    USHORT HASH(ULONG token)
    {
        return(USHORT) (token ^ (token>>16));
    }

    BYTE* KEY(ULONG token)
    {
        return(BYTE* ) token;
    }

public:

    DebuggerHashTable(USHORT size) 
    : CHashTableAndData<CNewData>(size), m_initialized(false)
    {
        
    }
    ~DebuggerHashTable();

    HRESULT AddBase(DebuggerBase* pBase);
    DebuggerBase* GetBase(ULONG token);
    BOOL RemoveBase(ULONG token);
    void RemoveAll();

    DebuggerBase* FindFirst(HASHFIND* find);
    DebuggerBase* FindNext(HASHFIND* find);
};

/* ------------------------------------------------------------------------- *
 * Debugger Stepper Table class
 * ------------------------------------------------------------------------- *

	@class StepperHashTable | It's possible for there to be multiple,
	outstanding,uncompleted steppers within the debuggee, and any of them 
	can complete after a given 'continue'. Thus, instead of a 'last stepper'
	field off of the thread object, we really need a table of active steppers
	off the thread object, which is what a StepperHashTable is.  
	@comm Currently unused, will fix a known bug in cordbg
*/
struct StepperHashEntry
{
    FREEHASHENTRY 		entry;
    ICorDebugStepper* 	pStepper;
};

class StepperHashTable : private CHashTableAndData<CNewData>
{
private:
    bool    m_initialized;

    BOOL Cmp(const BYTE* pc1, const HASHENTRY* pc2)
    {
        return((ICorDebugStepper*)pc1) != ((StepperHashEntry*)pc2)->pStepper;
    }

    USHORT HASH(ICorDebugStepper *pStepper)
    {
        return(USHORT) ((UINT)pStepper ^ ((UINT)pStepper >>16));
    }

    BYTE* KEY(ICorDebugStepper *pStepper)
    {
        return(BYTE* ) pStepper;
    }

public:

    StepperHashTable(USHORT size) 
    : CHashTableAndData<CNewData>(size), m_initialized(false)
    {
    }
    ~StepperHashTable();

	HRESULT Initialize(void);

    HRESULT AddStepper(ICorDebugStepper *pStepper);
		//Also does an AddRef, of course
    
    bool IsStepperPresent(ICorDebugStepper *pStepper);
    
    BOOL RemoveStepper(ICorDebugStepper *pStepper);
    
    void ReleaseAll(); //will go through & release all the steppers
    	//in the table, twice, then delete them.  This should deallocate
    	//them both from the table & from cordbg

    ICorDebugStepper *FindFirst(HASHFIND* find);
    ICorDebugStepper *FindNext(HASHFIND* find);
};


class DebuggerManagedThread : public DebuggerBase
{
public:

    DebuggerManagedThread(DWORD dwThreadId,ICorDebugThread *icdThread) :
        m_thread(icdThread), DebuggerBase(dwThreadId),
        m_lastFuncEval(NULL), m_steppingForStartup(false)
    {
        fSuperfluousFirstStepCompleteMessageSuppressed = false;
    
        //@todo port: if DWORD or ULONG size changes, create a field
        //for dwThreadId
        _ASSERTE( sizeof(dwThreadId) == sizeof(m_token));

        if (m_thread != NULL )
            m_thread->AddRef();


        m_pendingSteppers = new StepperHashTable(7);
    }

    virtual ~DebuggerManagedThread()
    {
        _ASSERTE( m_thread != NULL );
        m_thread->Release();
        m_thread = NULL;

        if (m_pendingSteppers != NULL )
        {
            m_pendingSteppers->ReleaseAll();
        }

        if (m_lastFuncEval)
        {
            m_lastFuncEval->Release();
            m_lastFuncEval = NULL;
        }
    }
    
    StepperHashTable*	   m_pendingSteppers;
    ICorDebugThread*       m_thread;
    bool                   fSuperfluousFirstStepCompleteMessageSuppressed;
    ICorDebugEval*         m_lastFuncEval;
    bool                   m_steppingForStartup;
};

/* ------------------------------------------------------------------------- *
 * DebuggerShell class
 * ------------------------------------------------------------------------- */

struct ExceptionHandlingInfo
{
    WCHAR                  *m_exceptionType;
    bool                    m_catch;
    ExceptionHandlingInfo  *m_next;
};


class DebuggerShell : public Shell
{
public:
    DebuggerShell(FILE* in, FILE* out);
    virtual ~DebuggerShell();

    HRESULT Init();

    CorDebugUnmappedStop ComputeStopMask( void );
    CorDebugIntercept    ComputeInterceptMask( void );
    
    
    bool ReadLine(WCHAR* buffer, int maxCount);

    // Write will return an HRESULT if it can't work.  For E_OUTOFMEMORY, and
    // the special case of a large string, you could then try WriteBigString.
    virtual HRESULT Write(const WCHAR* buffer, ...);

    // WriteBigString will loop over the character array, calling Write on
    // subportions of it.  It may still fail, though.
    virtual HRESULT WriteBigString(WCHAR *s, ULONG32 count);
    virtual void Error(const WCHAR* buffer, ...);

    // Do a command once for every thread in the process
    virtual void DoCommandForAllThreads(const WCHAR *string);

    // Right now, this will return E_OUTOFMEMORY if it can't get enough space
    HRESULT CommonWrite(FILE *out, const WCHAR *buffer, va_list args);

    void AddCommands();

    void Kill();
    virtual void Run(bool fNoInitialContinue = false);
    void Stop(ICorDebugController *controller, 
              ICorDebugThread* thread,
              DebuggerUnmanagedThread *unmanagedThread = NULL);
    HRESULT AsyncStop(ICorDebugController *controller, 
                      DWORD dwTimeout = 500);
    void Continue(ICorDebugController* process, 
                  ICorDebugThread* thread,
				  DebuggerUnmanagedThread *unmanagedThread = NULL,
                  BOOL fIsOutOfBand = FALSE);
    void Interrupt();
    void SetTargetProcess(ICorDebugProcess* process);
    void SetCurrentThread(ICorDebugProcess* process, ICorDebugThread* thread,
						  DebuggerUnmanagedThread *unmanagedThread = NULL);
    void SetCurrentChain(ICorDebugChain* chain);
    void SetCurrentFrame(ICorDebugFrame* frame);
    void SetDefaultFrame();

    HRESULT PrintThreadState(ICorDebugThread* thread);
	HRESULT PrintChain(ICorDebugChain *chain, int *frameIndex = NULL,
											int *iNumFramesToShow = NULL);
	HRESULT PrintFrame(ICorDebugFrame *frame);

    ICorDebugValue* EvaluateExpression(const WCHAR* exp, ICorDebugILFrame* context, bool silently = false);
    ICorDebugValue* EvaluateName(const WCHAR* name, ICorDebugILFrame* context,
                                 bool* unavailable);
    void PrintVariable(const WCHAR* name, ICorDebugValue* value,
                       unsigned int indent, BOOL expandObjects);
    void PrintArrayVar(ICorDebugArrayValue *iarray,
                       const WCHAR* name,
                       unsigned int indent, BOOL expandObjects);
    void PrintStringVar(ICorDebugStringValue *istring,
                        const WCHAR* name,
                        unsigned int indent, BOOL expandObjects);
    void PrintObjectVar(ICorDebugObjectValue *iobject,
                        const WCHAR* name,
                        unsigned int indent, BOOL expandObjects);
    bool EvaluateAndPrintGlobals(const WCHAR *exp);
    void PrintGlobalVariable (mdFieldDef md, 
                              WCHAR  *wszName,
                              DebuggerModule *dm);
    void DumpMemory(BYTE *pbMemory, 
                    CORDB_ADDRESS ApparantStartAddr,
                    ULONG32 cbMemory, 
                    ULONG32 WORD_SIZE, 
                    ULONG32 iMaxOnOneLine, 
                    BOOL showAddr);
    
    HRESULT ResolveClassName(WCHAR *className,
                             DebuggerModule **pDM, mdTypeDef *pTD);
    HRESULT FindTypeDefByName(DebuggerModule *m,
                              WCHAR *className,
                              mdTypeDef *pTD);
    HRESULT ResolveTypeRef(DebuggerModule *currentDM, mdTypeRef tr,
                           DebuggerModule **pDM, mdTypeDef *pTD);
    HRESULT ResolveQualifiedFieldName(DebuggerModule *currentDM,
                                      mdTypeDef currentTD,
                                      WCHAR *fieldName,
                                      DebuggerModule **pDM,
                                      mdTypeDef *pTD,
                                      ICorDebugClass **pIClass,
                                      mdFieldDef *pFD,
                                      bool *pbIsStatic);
    HRESULT ResolveFullyQualifiedMethodName(WCHAR *methodName,
                                            ICorDebugFunction **ppFunc,
                                            ICorDebugAppDomain * pAppDomainHint = NULL);
    HRESULT GetArrayIndicies(WCHAR **pp, ICorDebugILFrame *context,
                             ULONG32 rank, ULONG32 *indicies);
    HRESULT StripReferences(ICorDebugValue **ppValue, bool printAsYouGo);
    BOOL PrintCurrentSourceLine(unsigned int around);
	virtual void ActivateSourceView(DebuggerSourceFile *psf, unsigned int lineNumber);
    BOOL PrintCurrentInstruction(unsigned int around,
                                 int          offset,
                                 DWORD        startAddr);
    BOOL PrintCurrentUnmanagedInstruction(unsigned int around,
                                          int          offset,
                                          DWORD        startAddr);
    void PrintIndent(unsigned int level);
    void PrintVarName(const WCHAR* name);
    void PrintBreakpoint(DebuggerBreakpoint* breakpoint);

    void PrintThreadPrefix(ICorDebugThread* pThread, bool forcePrint = false); 
    HRESULT  StepStart(ICorDebugThread *pThread,
                   ICorDebugStepper* pStepper);
    void StepNotify(ICorDebugThread* pThread, 
                    ICorDebugStepper* pStepper);

    DebuggerBreakpoint* FindBreakpoint(SIZE_T id);
    void RemoveAllBreakpoints();
	virtual void OnActivateBreakpoint(DebuggerBreakpoint *pb);
	virtual void OnDeactivateBreakpoint(DebuggerBreakpoint *pb);
	virtual void OnUnBindBreakpoint(DebuggerBreakpoint *pb, DebuggerModule *pm);
	virtual void OnBindBreakpoint(DebuggerBreakpoint *pb, DebuggerModule *pm);

    BOOL OpenDebuggerRegistry(HKEY* key);
    void CloseDebuggerRegistry(HKEY key);
    BOOL ReadSourcesPath(HKEY key, WCHAR** currentPath);
    BOOL WriteSourcesPath(HKEY key, WCHAR* newPath);
	BOOL AppendSourcesPath(const WCHAR *newpath);
    BOOL ReadDebuggerModes(HKEY key);
    BOOL WriteDebuggerModes(void);

    DebuggerModule* ResolveModule(ICorDebugModule *pIModule);
    DebuggerSourceFile* LookupSourceFile(const WCHAR* name);
    mdTypeDef LookupClass(const WCHAR* name);

	virtual HRESULT ResolveSourceFile(DebuggerSourceFile *pf, char *szPath, 
									  char*pszFullyQualName, 
									  int iMaxLen, bool bChangeOfFile);
	virtual ICorDebugManagedCallback *GetDebuggerCallback();
	virtual ICorDebugUnmanagedCallback *GetDebuggerUnmanagedCallback();

    BOOL InitDisassembler(void);

    bool SkipCompilerStubs(ICorDebugAppDomain *pAppDomain,
                           ICorDebugThread *pThread);

	BOOL SkipProlog(ICorDebugAppDomain *pAD,
                    ICorDebugThread *thread,
                    bool gotFirstThread);
	

    virtual WCHAR *GetJITLaunchCommand(void)
    {
        return L"cordbg.exe !a 0x%x";
    }

    void LoadUnmanagedSymbols(HANDLE hProcess, HANDLE hFile, DWORD imageBase);
    void HandleUnmanagedThreadCreate(DWORD dwThreadId, HANDLE hThread);
    void TraceUnmanagedThreadStack(HANDLE hProcess,
                                   DebuggerUnmanagedThread *ut,
                                   bool lie);
    void TraceAllUnmanagedThreadStacks(void);
	void PrintUnmanagedStackFrame(HANDLE hProcess, CORDB_ADDRESS ip);
    
    void TraceUnmanagedStack(HANDLE hProcess, HANDLE hThread,
							 CORDB_ADDRESS ip, CORDB_ADDRESS bp, 
							 CORDB_ADDRESS sp, CORDB_ADDRESS bpEnd);

    bool HandleUnmanagedEvent(void);

	// !!! Move to process object
    HRESULT AddManagedThread( ICorDebugThread *icdThread,
                              DWORD dwThreadId )
    {
        DebuggerManagedThread *pdt = new DebuggerManagedThread( dwThreadId,
                                                                icdThread);
        if (pdt == NULL)
            return E_OUTOFMEMORY;

		if (FAILED(pdt->m_pendingSteppers->Initialize()))
			return E_OUTOFMEMORY;
        
        return m_managedThreads.AddBase( (DebuggerBase *)pdt );
    } 

    DebuggerManagedThread *GetManagedDebuggerThread(
                                     ICorDebugThread *icdThread )
    {
        DWORD dwThreadId = 0;
        HRESULT hr = icdThread->GetID(&dwThreadId);
        _ASSERTE( !FAILED(hr));

        return (DebuggerManagedThread *)m_managedThreads.GetBase( dwThreadId );
    }
    
    BOOL RemoveManagedThread( DWORD dwThreadId )
    {
        return m_managedThreads.RemoveBase( dwThreadId );
    }


	int GetUserSelection(DebuggerModule *rgpDebugModule[],
							WCHAR *rgpstrFileName[][MAX_FILE_MATCHES_PER_MODULE],	
							int rgiCount[],
							int iModuleCount,
							int iCumulCount
							  );

	BOOL ChangeCurrStackFile (WCHAR *fileName);
	BOOL DebuggerShell::UpdateCurrentPath (WCHAR *args);
	void ListAllModules (ListType lt);
	void ListAllGlobals (DebuggerModule *m);

    const WCHAR *UserThreadStateToString(CorDebugUserState us);

    bool MatchAndPrintSymbols (WCHAR *pszArg, BOOL fSymbol, bool fSilently = false);

    FILE *GetM_in(void) { return m_in; };
    void  PutM_in(FILE *f) { m_in = f; };
    HRESULT NotifyModulesOfEnc(ICorDebugModule *pModule, IStream *pSymStream);
    
    void ClearDebuggeeState(void); //when we Restart, for example, we'll want to
                                   //reset some flags.

    HRESULT HandleSpecificException(WCHAR *exType, bool shouldCatch);
    bool ShouldHandleSpecificException(ICorDebugValue *pException);
    
private:
    FILE*                  m_in;
    FILE*                  m_out;

public:
    ICorDebug*             m_cor;

    ICorDebugProcess*      m_targetProcess;
    bool                   m_targetProcessHandledFirstException;
    
    ICorDebugProcess*      m_currentProcess;
    ICorDebugThread*       m_currentThread;
    ICorDebugChain*        m_currentChain;
    ICorDebugILFrame*      m_currentFrame;
    ICorDebugFrame*        m_rawCurrentFrame;

    DebuggerUnmanagedThread* m_currentUnmanagedThread;

    DWORD                  m_lastThread;
    ICorDebugStepper*      m_lastStepper;
    
    bool                   m_showSource;
    bool                   m_silentTracing;

    WCHAR*                 m_currentSourcesPath;

    HANDLE                 m_stopEvent;
	HANDLE                 m_hProcessCreated;
    bool                   m_stop;
    bool                   m_quit;

    bool                   m_gotFirstThread;

    DebuggerBreakpoint*    m_breakpoints;
    SIZE_T                 m_lastBreakpointID;

    DebuggerHashTable      m_modules;

	// !!! Move to process object
    DebuggerHashTable      m_unmanagedThreads;
    DebuggerHashTable      m_managedThreads;
    
    void*                  m_pDIS;

    WCHAR*                 m_lastRunArgs;

    bool                   m_catchException;
    bool                   m_catchUnhandled;
    bool                   m_catchClass;
    bool                   m_catchModule;
    bool                   m_catchThread;

    bool                   m_needToSkipCompilerStubs;
	DWORD				   m_rgfActiveModes;
    bool                   m_invalidCache; //if true, we've affected the left 
                            //  side & anything that has cached information
                            //  should refresh

	DebuggerFilePathCache  m_FPCache;

    DEBUG_EVENT            m_lastUnmanagedEvent;
    bool                   m_handleUnmanagedEvent;

    bool                   m_unmanagedDebuggingEnabled;

    ULONG                  m_cEditAndContinues;

    ICorDebugEval          *m_pCurrentEval;

    // This indicates whether or not a ctrl-break will do anything
    bool                   m_enableCtrlBreak;
    // This indicates whether or not a looping command should stop (like s 1000)
    bool                   m_stopLooping;

    ExceptionHandlingInfo *m_exceptionHandlingList;
};

/* ------------------------------------------------------------------------- *
 * Breakpoint class
 * ------------------------------------------------------------------------- */

class DebuggerBreakpoint
{
public:
    DebuggerBreakpoint(const WCHAR* name, SIZE_T nameLength, SIZE_T index, DWORD threadID);
    DebuggerBreakpoint(DebuggerFunction* f, SIZE_T offset, DWORD threadID);
    DebuggerBreakpoint(DebuggerSourceFile* file, SIZE_T lineNumber, DWORD threadID);

    ~DebuggerBreakpoint();

	// Create/remove a breakpoint.
    bool Bind(DebuggerModule* m_module, ISymUnmanagedDocument *doc);
    bool BindUnmanaged(ICorDebugProcess *m_process,
                       DWORD moduleBase = 0);
    void Unbind();

	// Enable/disable an active breakpoint.
    void Activate();
    void Deactivate();

	// Leave bp active; tear down or reset CLR bp object.
	void Detach();
	// Detaches the break point from the specified module
	void DetachFromModule(DebuggerModule * pModule);
	void Attach();

    bool Match(ICorDebugBreakpoint* ibreakpoint);
    bool MatchUnmanaged(CORDB_ADDRESS address);

	SIZE_T GetId (void) {return m_id;}
	SIZE_T GetIndex (void) { return m_index;}
	WCHAR *GetName (void) { return m_name;}
	void UpdateName (WCHAR *pstrName);

	void ChangeSourceFile (WCHAR *filename);

    DebuggerBreakpoint*          m_next;
    SIZE_T                       m_id;

    WCHAR*                       m_name;
    // May be NULL if no module name was specified.
    WCHAR*                       m_moduleName; 
    SIZE_T                       m_index;
    DWORD                        m_threadID;

    bool                         m_active;

	bool                         m_managed;

	ISymUnmanagedDocument                *m_doc;

	ICorDebugProcess	*m_process;
	CORDB_ADDRESS		 m_address;
	BYTE				 m_patchedValue;
	DWORD				 m_skipThread;
	CORDB_ADDRESS        m_unmanagedModuleBase;
    bool                 m_deleteLater;

public:
    struct BreakpointModuleNode
    {
        DebuggerModule *m_pModule;
        BreakpointModuleNode *m_pNext;
    };

    // Will be a list of modules for which this breakpoint is
    // associated.  This is necessary because the same module
    // may be loaded into separate AppDomains, but the breakpoint
    // should still be valid for all instances of the module.
    BreakpointModuleNode *m_pModuleList;

	// This will return true if this breakpoint is associated
	// with the pModule argument
    bool IsBoundToModule(DebuggerModule *pModule);

	// This will add the provided module to the list of bound
	// modules
    bool AddBoundModule(DebuggerModule *pModule);

	// This will remove the specified module from the list of
	// bound modules
    bool RemoveBoundModule(DebuggerModule *pModule);

private:
    void CommonCtor(void);
    void Init(DebuggerModule* module, bool bProceed, WCHAR *szModuleName);

	void ApplyUnmanagedPatch();
	void UnapplyUnmanagedPatch();
};


//
// DebuggerVarInfo
//
// Holds basic information about local variables, method arguments,
// and class static and instance variables.
//
struct DebuggerVarInfo
{
    LPCSTR                 name;
    PCCOR_SIGNATURE        sig;
    unsigned long          varNumber;  // placement info for IL code

    DebuggerVarInfo() : name(NULL), sig(NULL), varNumber(0)
                         {}
};


/* ------------------------------------------------------------------------- *
 * Class class
 * ------------------------------------------------------------------------- */

class DebuggerClass : public DebuggerBase
{
public:
	DebuggerClass (ICorDebugClass *pClass);
	~DebuggerClass ();

	void SetName (WCHAR *pszName, WCHAR *pszNamespace);
	WCHAR *GetName (void);
	WCHAR *GetNamespace (void);
	
private:
	WCHAR	*m_szName;
	WCHAR	*m_szNamespace;
};


/* ------------------------------------------------------------------------- *
 * Module class
 * ------------------------------------------------------------------------- */

class DebuggerModule : public DebuggerBase
{
public:
    DebuggerModule(ICorDebugModule* module);
    ~DebuggerModule();

    HRESULT Init(WCHAR *pSearchPath);
    
    DebuggerSourceFile* LookupSourceFile(const WCHAR* name);
    DebuggerSourceFile* ResolveSourceFile(ISymUnmanagedDocument *doc);

    DebuggerFunction* ResolveFunction(mdMethodDef mb,
                                      ICorDebugFunction* iFunction);
    DebuggerFunction* ResolveFunction(ISymUnmanagedMethod *method,
                                      ICorDebugFunction* iFunction);

    static DebuggerModule* FromCorDebug(ICorDebugModule* module);

    IMetaDataImport *GetMetaData(void)
    {
        return m_pIMetaDataImport;
    }

    ISymUnmanagedReader *GetSymbolReader(void)
    {
        return m_pISymUnmanagedReader;
    }

    ICorDebugModule *GetICorDebugModule(void)
    {
        return (ICorDebugModule*)m_token;
    }

    HRESULT LoadSourceFileNames (void);
    void DeleteModuleSourceFiles(void);

	HRESULT	MatchStrippedFNameInModule	(
					WCHAR *pstrFileName,									
					WCHAR **ppstrMatchedNames, 
					ISymUnmanagedDocument **ppDocs, 
					int *piCount);
	HRESULT	MatchFullFileNameInModule (WCHAR *pstrFileName, 
                                           ISymUnmanagedDocument **ppDocs);

    ISymUnmanagedDocument *FindDuplicateDocumentByURL(ISymUnmanagedDocument *pDoc);
    ISymUnmanagedDocument *SearchForDocByString(WCHAR *szUrl);

	BOOL PrintMatchingSymbols (WCHAR *szSearchString, char *szModName);
    BOOL PrintGlobalVariables (WCHAR *szSearchString, 
                               char *szModName,
                               DebuggerModule *dm);

	void	SetName (WCHAR *pszName);
	WCHAR*	GetName (void) { return m_szName;}

    HRESULT UpdateSymbols(IStream *pSymbolStream);
	
public:
    IMetaDataImport        *m_pIMetaDataImport;

    ISymUnmanagedReader    *m_pISymUnmanagedReader;

    DebuggerHashTable       m_sourceFiles;
    DebuggerHashTable       m_functions;
    DebuggerHashTable       m_functionsByIF;
	DebuggerHashTable		m_loadedClasses;

    DebuggerCodeBreakpoint* m_breakpoints;

private:
	ModuleSourceFile		*m_pModSourceFile [MAX_SF_BUCKETS];
	bool					m_fSFNamesLoaded;
	WCHAR                   *m_szName;
#ifdef _INTERNAL_DEBUG_SUPPORT_
    ULONG                   m_EnCLastUpdated;
#endif
};

class DebuggerCodeBreakpoint
{
public:
    DebuggerCodeBreakpoint(int breakpointID, 
                           DebuggerModule* module,
                           DebuggerFunction* function, SIZE_T offset, BOOL il,
                           DWORD threadID);
    DebuggerCodeBreakpoint(int breakpointID, 
                           DebuggerModule* module,
                           DebuggerSourceCodeBreakpoint* parent,
                           DebuggerFunction* function, SIZE_T offset, BOOL il,
                           DWORD threadID);

    virtual ~DebuggerCodeBreakpoint();

    virtual bool Activate();
    virtual void Deactivate();

    virtual bool Match(ICorDebugBreakpoint* ibreakpoint);

	virtual void Print();

public:
    DebuggerCodeBreakpoint      *m_next;
    int                         m_id;
    DebuggerModule              *m_module;
    DebuggerFunction            *m_function;
    SIZE_T                      m_offset;
    BOOL                        m_il;
    DWORD                       m_threadID;

    ICorDebugFunctionBreakpoint* m_ibreakpoint;

    DebuggerSourceCodeBreakpoint* m_parent;
};

class DebuggerSourceCodeBreakpoint : public DebuggerCodeBreakpoint
{
public:
    DebuggerSourceCodeBreakpoint(int breakpointID, 
                                 DebuggerSourceFile* file, SIZE_T lineNumber,
                                 DWORD threadID);
    ~DebuggerSourceCodeBreakpoint();

    bool Activate();
    void Deactivate();
    bool Match(ICorDebugBreakpoint *ibreakpoint);
	void Print();

public:
    DebuggerSourceFile*     m_file;
    SIZE_T                  m_lineNumber;

    DebuggerCodeBreakpoint* m_breakpoints;
    bool                    m_initSucceeded;
};

/* ------------------------------------------------------------------------- *
 * SourceFile class
 * ------------------------------------------------------------------------- */

class DebuggerSourceFile : public DebuggerBase
{
public:
    //-----------------------------------------------------------
    // Create a DebuggerSourceFile from a scope and a SourceFile
    // token.
    //-----------------------------------------------------------
    DebuggerSourceFile(DebuggerModule* m, ISymUnmanagedDocument *doc);
    ~DebuggerSourceFile();

    //-----------------------------------------------------------
    // Given a line find the closest line which has code
    //-----------------------------------------------------------
    unsigned int FindClosestLine(unsigned int line, bool silently);

    const WCHAR* GetName(void)
    {
        return(m_name);
    }
	const WCHAR* GetPath(void)
	{
		return(m_path);
	}
	DebuggerModule* GetModule()
    {
        return(m_module);
    }

    //-----------------------------------------------------------
    // Methods to load the text of a source file and provide
    // access to it a line at a time.
    //-----------------------------------------------------------
    BOOL LoadText(const WCHAR* path, bool bChangeOfName);
    BOOL ReloadText(const WCHAR* path, bool bChangeOfName);
    unsigned int TotalLines(void)
    {
        return(m_totalLines);
    }
    const WCHAR* GetLineText(unsigned int lineNumber)
    {
        _ASSERTE((lineNumber > 0) && (lineNumber <= m_totalLines));
        return(m_lineStarts[lineNumber - 1]);
    }

	ISymUnmanagedDocument	*GetDocument (void) {return (ISymUnmanagedDocument*)m_token;}

public:
    ISymUnmanagedDocument *m_doc;
    DebuggerModule*        m_module;
    WCHAR*                 m_name;
	WCHAR*                 m_path;

    unsigned int           m_totalLines;
    WCHAR**                m_lineStarts;
    WCHAR*                 m_source;
    BOOL                   m_sourceTextLoaded;
    BOOL                   m_allBlocksLoaded;
    BOOL                   m_sourceNotFound;
};

/* ------------------------------------------------------------------------- *
 * DebuggerVariable struct
 * ------------------------------------------------------------------------- */

// Holds basic info about local variables and method arguments within
// the debugger. This is really only the name and variable number. No
// signature is required.
struct DebuggerVariable
{
    WCHAR        *m_name;
    ULONG32       m_varNumber;

    DebuggerVariable() : m_name(NULL), m_varNumber(0) {}

    ~DebuggerVariable()
    {
        if (m_name)
            delete [] m_name;
    }
};

/* ------------------------------------------------------------------------- *
 * Function class
 * ------------------------------------------------------------------------- */

class DebuggerFunction : public DebuggerBase
{
public:
    //-----------------------------------------------------------
    // Create from scope and member tokens.
    //-----------------------------------------------------------
    DebuggerFunction(DebuggerModule* m, mdMethodDef md,
                     ICorDebugFunction* iFunction);
    ~DebuggerFunction();

    HRESULT Init(void);

    HRESULT FindLineFromIP(UINT_PTR ip,
                           DebuggerSourceFile** sourceFile,
                           unsigned int* line);

    void GetStepRangesFromIP(UINT_PTR ip, 
                             COR_DEBUG_STEP_RANGE** range,
                             SIZE_T* rangeCount);

    //-----------------------------------------------------------
    // These allow you to get the count of method argument and
    // get access to the info for each individual argument.
    // Ownership of the DebugVarInfo returned from GetArgumentAt
    // is retained by the DebugFunction.
    //-----------------------------------------------------------
    unsigned int GetArgumentCount(void)
    {
        return(m_argCount);
    }
    DebuggerVarInfo* GetArgumentAt(unsigned int index)
    {
        if (m_arguments)
            if (index < m_argCount)
                return(&m_arguments[index]);

        return NULL;
    }

    PCCOR_SIGNATURE GetReturnType()
    {
        return(m_returnType);
    }

    //-----------------------------------------------------------
    // This returns an array of pointers to DebugVarInfo blocks,
    // each representing a local variable that in in scope given
    // a certian IP. The variables are ordered in the list are in
    // increasingly larger lexical scopes, i.e., variables in the
    // smallest scope are first, then variables in the enclosing
    // scope, and so on. So, to find a certian variable "i",
    // search the list of "i" and take the first one you find.
    // If there are other "i"s, then they are shadowed by the
    // first one.
    // You must free the array returned in vars with delete [].
    // RETURNS: true if we succeeded, or at least found some debugging info
    //          false if we couldn't find any debugging info
    //-----------------------------------------------------------
    bool GetActiveLocalVars(UINT_PTR IP,
                            DebuggerVariable** vars, unsigned int* count);

    //-----------------------------------------------------------
    // Misc methods to get basic method information.
    //-----------------------------------------------------------
    WCHAR* GetName(void)
    {
        return(m_name);
    }
    PCCOR_SIGNATURE GetSignature(void)
    {
        return(m_signature);
    }
    WCHAR* GetNamespaceName(void)
    {
        return(m_namespaceName);
    }
    WCHAR* GetClassName(void)
    {
        return(m_className);
    }
    DebuggerModule* GetModule(void)
    {
        return(m_module);
    }
    BOOL IsStatic(void)
    {
        return(m_isStatic);
    }


    static DebuggerFunction* FromCorDebug(ICorDebugFunction* function);

    //-----------------------------------------------------------
    // EE interaction methods
    //-----------------------------------------------------------
    HRESULT LoadCode(BOOL native);

#ifdef _INTERNAL_DEBUG_SUPPORT_
    static SIZE_T WalkInstruction(BOOL native,
                                  SIZE_T offset,
                                  BYTE *codeStart,
                                  BYTE *codeEnd);
    static SIZE_T Disassemble(BOOL native,
                              SIZE_T offset,
                              BYTE *codeStart,
                              BYTE *codeEnd,
                              WCHAR* buffer,
                              BOOL noAddress,
                              DebuggerModule *module,
                              BYTE *ilcode);
#endif
    
    BOOL ValidateInstruction(BOOL native, SIZE_T offset);
    HRESULT CacheSequencePoints(void);

public:
    DebuggerModule*           m_module;
    mdTypeDef                 m_class;
    ICorDebugFunction*        m_ifunction;
    BOOL                      m_isStatic;
    BOOL                      m_allBlocksLoaded;
    BOOL                      m_allScopesLoaded;
    WCHAR*                    m_name;
    PCCOR_SIGNATURE           m_signature;
	WCHAR*					  m_namespaceName;
    WCHAR*                    m_className;
    BOOL                      m_VCHack;
                              
    DebuggerVarInfo*          m_arguments;
    unsigned int              m_argCount;
    PCCOR_SIGNATURE           m_returnType;    

    void CountActiveLocalVars(ISymUnmanagedScope* head,
                              unsigned int line,
                              unsigned int* varCount);
    void FillActiveLocalVars(ISymUnmanagedScope* head,
                             unsigned int line,
                             unsigned int varCount,
                             unsigned int* currentVar,
                             DebuggerVariable* varPtrs);

    ISymUnmanagedMethod    *m_symMethod;
    ULONG32                *m_SPOffsets;
    ISymUnmanagedDocument **m_SPDocuments;
    ULONG32                *m_SPLines;
    ULONG32                 m_SPCount;

    BYTE*                   m_ilCode;
    ULONG32                 m_ilCodeSize;
    BYTE*                   m_nativeCode;
    ULONG32                 m_nativeCodeSize;
    ULONG                   m_nEditAndContinueLastSynched;
};

/* ------------------------------------------------------------------------- *
 * DebuggerCallback
 * ------------------------------------------------------------------------- */

#define COM_METHOD HRESULT STDMETHODCALLTYPE

class DebuggerCallback : public ICorDebugManagedCallback
{
public:    
    DebuggerCallback() : m_refCount(0)
    {
    }

    // 
    // IUnknown
    //

    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long refCount = InterlockedDecrement(&m_refCount);
        if (refCount == 0)
            delete this;

        return (refCount);
    }

    COM_METHOD QueryInterface(REFIID riid, void **ppInterface)
    {
        if (riid == IID_IUnknown)
            *ppInterface = (IUnknown *) this;
        else if (riid == IID_ICorDebugManagedCallback)
            *ppInterface = (ICorDebugManagedCallback *) this;
        else
            return (E_NOINTERFACE);

        this->AddRef();
        return (S_OK);
    }

    // 
    // ICorDebugManagedCallback
    //

    COM_METHOD CreateProcess(ICorDebugProcess *pProcess);
    COM_METHOD ExitProcess(ICorDebugProcess *pProcess);
    COM_METHOD DebuggerError(ICorDebugProcess *pProcess,
                             HRESULT errorHR,
                             DWORD errorCode);

	COM_METHOD CreateAppDomain(ICorDebugProcess *pProcess,
							ICorDebugAppDomain *pAppDomain); 

	COM_METHOD ExitAppDomain(ICorDebugProcess *pProcess,
						  ICorDebugAppDomain *pAppDomain); 

	COM_METHOD LoadAssembly(ICorDebugAppDomain *pAppDomain,
						 ICorDebugAssembly *pAssembly);

	COM_METHOD UnloadAssembly(ICorDebugAppDomain *pAppDomain,
						   ICorDebugAssembly *pAssembly);

	COM_METHOD Breakpoint( ICorDebugAppDomain *pAppDomain,
					    ICorDebugThread *pThread, 
					    ICorDebugBreakpoint *pBreakpoint);

	COM_METHOD StepComplete( ICorDebugAppDomain *pAppDomain,
						  ICorDebugThread *pThread,
						  ICorDebugStepper *pStepper,
						  CorDebugStepReason reason);

	COM_METHOD Break( ICorDebugAppDomain *pAppDomain,
				   ICorDebugThread *thread);

	COM_METHOD Exception( ICorDebugAppDomain *pAppDomain,
					   ICorDebugThread *pThread,
					   BOOL unhandled);

	COM_METHOD EvalComplete( ICorDebugAppDomain *pAppDomain,
                               ICorDebugThread *pThread,
                               ICorDebugEval *pEval);

	COM_METHOD EvalException( ICorDebugAppDomain *pAppDomain,
                                ICorDebugThread *pThread,
                                ICorDebugEval *pEval);

	COM_METHOD CreateThread( ICorDebugAppDomain *pAppDomain,
						  ICorDebugThread *thread);

	COM_METHOD ExitThread( ICorDebugAppDomain *pAppDomain,
					    ICorDebugThread *thread);

	COM_METHOD LoadModule( ICorDebugAppDomain *pAppDomain,
					    ICorDebugModule *pModule);

	COM_METHOD UnloadModule( ICorDebugAppDomain *pAppDomain,
						  ICorDebugModule *pModule);

	COM_METHOD LoadClass( ICorDebugAppDomain *pAppDomain,
					   ICorDebugClass *c);

	COM_METHOD UnloadClass( ICorDebugAppDomain *pAppDomain,
						 ICorDebugClass *c);

	COM_METHOD LogMessage(ICorDebugAppDomain *pAppDomain,
                      ICorDebugThread *pThread,
					  LONG lLevel,
					  WCHAR *pLogSwitchName,
					  WCHAR *pMessage);

	COM_METHOD LogSwitch(ICorDebugAppDomain *pAppDomain,
                      ICorDebugThread *pThread,
					  LONG lLevel,
					  ULONG ulReason,
					  WCHAR *pLogSwitchName,
					  WCHAR *pParentName);

    COM_METHOD ControlCTrap(ICorDebugProcess *pProcess);
    
	COM_METHOD NameChange(ICorDebugAppDomain *pAppDomain, 
                          ICorDebugThread *pThread);

    COM_METHOD UpdateModuleSymbols(ICorDebugAppDomain *pAppDomain,
                                   ICorDebugModule *pModule,
                                   IStream *pSymbolStream);
                                   
    COM_METHOD EditAndContinueRemap(ICorDebugAppDomain *pAppDomain,
                                    ICorDebugThread *pThread, 
                                    ICorDebugFunction *pFunction,
                                    BOOL fAccurate);
    COM_METHOD BreakpointSetError(ICorDebugAppDomain *pAppDomain,
                                  ICorDebugThread *pThread,
                                  ICorDebugBreakpoint *pBreakpoint,
                                  DWORD dwError);
    
protected:
    long        m_refCount;
};


/* ------------------------------------------------------------------------- *
 * DebuggerUnmanagedCallback
 * ------------------------------------------------------------------------- */

class DebuggerUnmanagedCallback : public ICorDebugUnmanagedCallback
{
public:    
    DebuggerUnmanagedCallback() : m_refCount(0)
    {
    }

    // IUnknown
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long refCount = InterlockedDecrement(&m_refCount);
        if (refCount == 0)
            delete this;

        return (refCount);
    }

    COM_METHOD QueryInterface(REFIID riid, void **ppInterface)
    {
        if (riid == IID_IUnknown)
            *ppInterface = (IUnknown*)(ICorDebugUnmanagedCallback*)this;
        else if (riid == IID_ICorDebugUnmanagedCallback)
            *ppInterface = (ICorDebugUnmanagedCallback*) this;
        else
            return (E_NOINTERFACE);

        this->AddRef();
        return (S_OK);
    }

    COM_METHOD DebugEvent(LPDEBUG_EVENT pDebugEvent,
                          BOOL fIsOutOfband);

protected:
    long        m_refCount;
};

/* ------------------------------------------------------------------------- *
 * Unmanaged Thread class
 * ------------------------------------------------------------------------- */

class DebuggerUnmanagedThread : public DebuggerBase
{
public:
    DebuggerUnmanagedThread(DWORD dwThreadId, HANDLE hThread)
	  : DebuggerBase(dwThreadId), m_hThread(hThread), 
		m_stepping(FALSE), m_unmanagedStackEnd(NULL) {}

    HANDLE GetHandle(void) { return m_hThread; }
    DWORD GetId(void) { return m_token; }

	BOOL		    m_stepping;
	CORDB_ADDRESS	m_unmanagedStackEnd;

private:
    HANDLE			m_hThread;
};

/* ------------------------------------------------------------------------- *
 * Debugger ShellCommand classes
 * ------------------------------------------------------------------------- */

class DebuggerCommand : public ShellCommand
{
public:
    DebuggerCommand(const WCHAR *name, int minMatchLength = 0)
        : ShellCommand(name, minMatchLength)
    {
    }

    void Do(Shell *shell, const WCHAR *args) 
    {
        DebuggerShell *dsh = static_cast<DebuggerShell *>(shell);

        Do(dsh, dsh->m_cor, args);
    }

    virtual void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args) = 0;
};


/* ------------------------------------------------------------------------- *
 * class ModuleSourceFile
 * ------------------------------------------------------------------------- */

class ModuleSourceFile
{
private:
	ISymUnmanagedDocument	*m_SFDoc;	            // Symbol reader document
	WCHAR 			*m_pstrFullFileName;	// File name along with path (as returned by the metadata API)
	WCHAR			*m_pstrStrippedFileName;// The barebone file name (eg. foo.cpp)
	ModuleSourceFile *m_pNext;

public:
	ModuleSourceFile()
	{
		m_SFDoc = NULL;
		m_pstrFullFileName = NULL;
		m_pstrStrippedFileName = NULL;
		m_pNext = NULL;
	}

	~ModuleSourceFile()
	{
		delete [] m_pstrFullFileName;
		delete [] m_pstrStrippedFileName;

        if (m_SFDoc)
        {
            m_SFDoc->Release();
            m_SFDoc = NULL;
        }
	}

	ISymUnmanagedDocument	*GetDocument (void) {return m_SFDoc;}

	// This sets the full file name as well as the stripped file name
	BOOL	SetFullFileName (ISymUnmanagedDocument *doc, LPCSTR pstrFullFileName);
	WCHAR	*GetFullFileName (void) { return m_pstrFullFileName;}
	WCHAR	*GetStrippedFileName (void) { return m_pstrStrippedFileName;}

	void	SetNext (ModuleSourceFile *pNext) { m_pNext = pNext;}
	ModuleSourceFile *GetNext (void) { return m_pNext;}

};

/* ------------------------------------------------------------------------- *
 * Global variables
 * ------------------------------------------------------------------------- */

extern DebuggerShell        *g_pShell;

#endif __DSHELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\internalonly.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: InternalOnly.cpp
//
// Internal only helper code that should never go outside of Microsoft.
//
//*****************************************************************************
#include "stdafx.h"
#include "cordbpriv.h"
#include "InternalOnly.h"


ULONG g_EditAndContinueCounter = 0;


//@TODO: JENH - remove this when appropriate

EditAndContinueDebuggerCommand::EditAndContinueDebuggerCommand(const WCHAR *name, int minMatchLength)
    : DebuggerCommand(name, minMatchLength)
{
    
}

HRESULT StreamFromFile(DebuggerShell *shell,
                       WCHAR *fname,
                       IStream **ppIStream)
{
    HRESULT hr = S_OK;
    
    HANDLE hFile = CreateFileW(fname, GENERIC_READ, FILE_SHARE_READ,
                               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        shell->Write(L"EditAndContinue::CreateFile failed %d (Couldn't open file %s)\n",
                     GetLastError(), fname);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    DWORD cbFile = SafeGetFileSize(hFile, NULL);

	if (cbFile == 0xffffffff)
    {
        shell->Write(L"EditAndContinue,GetFileSize failed %d\n",
                     GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }
    else if (cbFile == 0)
    {
        *ppIStream = NULL;
        return S_FALSE;
    }

	HANDLE hFileMapping = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
    
    if (!hFileMapping)
    {
        shell->Write(L"EditAndContinue,CreateFileMapping failed %d\n",
                     GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

	LPVOID pFileView = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);

	if (!pFileView)
    {
        shell->Write(L"EditAndContinue,MapViewOfFile failed %d\n",
                     GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = CInMemoryStream::CreateStreamOnMemory(pFileView, cbFile, ppIStream);

	if (FAILED(hr))
    {
        shell->Write(L"CreateStreamOnMemory failed 0x%08x\n", hr);
        return hr;
    }

    return S_OK;
}

#define SET_MAP_ENTRY(map, i, oldO, newO, fAcc) \
    map[i].oldOffset = oldO;                   \
    map[i].newOffset = newO;                   \
    map[i].fAccurate = fAcc

// This exists for testing purposes only.
// Hard-code that map you want & recompile.
void EditAndContinueDebuggerCommand::SetILMaps(ICorDebugEditAndContinueSnapshot *pISnapshot,
                                               DebuggerShell *shell)
{
    return;
    
    // Rest should be re-tooled as you need it.
    mdToken mdFunction = (mdToken)0x06000002;
    ULONG cMapSize = 4;
    COR_IL_MAP map[4];
    
    SET_MAP_ENTRY(map, 0, 0, 0, TRUE);     // line 6
    SET_MAP_ENTRY(map, 1, 1, 0xb, TRUE);      // 7
    SET_MAP_ENTRY(map, 2, 6, 0x10, FALSE);     // 8
    SET_MAP_ENTRY(map, 3, 7, 0x11, TRUE);      // 9
    
    HRESULT hr = pISnapshot->SetILMap(mdFunction,
                          cMapSize,
                          map);
    if (FAILED(hr))
    {
        shell->Write(L"SetILMap failed 0x%08x for method 0x%x\n", hr, mdFunction);
    }
}



void EditAndContinueDebuggerCommand::Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
{
    if (shell->m_currentProcess == NULL)
    {
        shell->Error(L"Process not running.\n");
    }

    WCHAR *fname = NULL;
    WCHAR *symfname = NULL;

    shell->GetStringArg(args, fname);
    if (args == fname)
    {
        Help(shell);
        return;
    }

    WCHAR *fnameEnd = (WCHAR*) args;
    shell->GetStringArg(args, symfname);
    if (args == symfname)
    {
        // We'll take the .exe name, and chop off the .exe (if there
        // is one), and tack ".pdb" onto the end, so the user doesn't
        // have to 
        symfname = (WCHAR *)_alloca( sizeof(WCHAR)*(wcslen(fname)+4));
        wcscpy(symfname, fname);
        WCHAR *nameWithoutDotExe = wcsrchr(symfname, L'.');
        if (!nameWithoutDotExe)
        {
            Help(shell);
            return;
        }

        if (wcscmp(nameWithoutDotExe, L".exe") != 0)
        {
            Help(shell);
            return;
        }

        wcscpy(nameWithoutDotExe, L".pdb");
        
        shell->Write( L"Attempting to use %s for symbols (type \"? zE\" for help)\n", symfname);
    }

    *fnameEnd = L'\0';

    // update the module containing the current function
    ICorDebugCode *icode = NULL;
    ICorDebugFunction *ifunction = NULL;
    ICorDebugModule *imodule = NULL;
    ICorDebugEditAndContinueSnapshot *isnapshot = NULL;
    IStream *pStream = NULL;

    if (shell->m_currentFrame==NULL)
    {
        shell->Write(L"EditAndContinue:Failed b/c there's no current frame!\n");
        return;
    }

    HRESULT hr = shell->m_currentFrame->GetCode(&icode);
    _ASSERTE(SUCCEEDED(hr));
    hr = icode->GetFunction(&ifunction);
    _ASSERTE(SUCCEEDED(hr));
    icode->Release();
    hr = ifunction->GetModule(&imodule);
    _ASSERTE(SUCCEEDED(hr));
    ifunction->Release();
    hr = imodule->GetEditAndContinueSnapshot(&isnapshot);
    _ASSERTE(SUCCEEDED(hr));

    // Snagg the PE file and set it in the snapshot.
    hr = StreamFromFile(shell, fname, &pStream);

    if (FAILED(hr))
        return;

    hr = isnapshot->SetPEBytes(pStream);

    if (FAILED(hr))
    {
        shell->Write(L"EditAndContinue,SetPEBytes failed\n");
        return;
    }

    pStream->Release();
    pStream = NULL;

    SetILMaps(isnapshot, shell);

    // Snagg the symbol file and set it in the snapshot.
    if (symfname)
    {
        hr = StreamFromFile(shell, symfname, &pStream);

        if (FAILED(hr))
            return;

        if (hr == S_OK)
        {
            hr = isnapshot->SetPESymbolBytes(pStream);

            if (FAILED(hr))
            {
                shell->Write(L"EditAndContinue,SetSymbolBytes failed\n");
                return;
            }
        }
    }

    ICorDebugErrorInfoEnum *pErrors = NULL;
    hr = shell->m_currentProcess->CanCommitChanges(1, &isnapshot, &pErrors);

    if (FAILED(hr))
    {
		ULONG celtFetched = 1;
        
        shell->Write(L"EditAndContinue,CanCommitChanges with hr:0x%x\n\n", hr);
        
        while(celtFetched == 1 && pErrors != NULL)
        {
            HRESULT hrGetError = S_OK;
        
            ICorDebugEditAndContinueErrorInfo *pEnCErrorInfo = NULL;
            hrGetError = pErrors->Next(1,
                                       &pEnCErrorInfo,
                                       &celtFetched);
            if (FAILED(hrGetError))
                goto CouldntGetError;

            if (celtFetched == 1)
            {
                mdToken tok;
                HRESULT hrEnC;
                WCHAR szErr[60];
                ULONG32 cchSzErr;
                ICorDebugModule *pModule = NULL;
                WCHAR szMod[100];
                ULONG32 cchSzMod;
                
                hrGetError = pEnCErrorInfo->GetToken(&tok);
                if (FAILED(hrGetError))
                    goto CouldntGetError;
                    
                hrGetError = pEnCErrorInfo->GetErrorCode(&hrEnC);
                if (FAILED(hrGetError))
                    goto CouldntGetError;
                    
                hrGetError = pEnCErrorInfo->GetString(60, &cchSzErr,szErr);
                if (FAILED(hrGetError))
                    goto CouldntGetError;
                    
                hrGetError = pEnCErrorInfo->GetModule(&pModule);
                if (FAILED(hrGetError))
                    goto CouldntGetError;

                hrGetError = pModule->GetName(100, &cchSzMod, szMod);
                if (FAILED(hrGetError))
                    goto CouldntGetError;

                shell->Write(L"Error:0x%x, About token:0x%x\n\tModule: %s\n\t%s\n",
                        hrEnC, tok, szMod,szErr);

                if (pEnCErrorInfo != NULL)
                    pEnCErrorInfo->Release();
            }
            
CouldntGetError:
            if (FAILED(hrGetError))
            {
                shell->Write(L"Unable to get error info: ");
                shell->ReportError(hrGetError);
            }

            if(pEnCErrorInfo != NULL)
            {
                pEnCErrorInfo->Release();
                pEnCErrorInfo = NULL;
            }
        }

        if (pErrors != NULL)
            pErrors->Release();


        return;
    }

    hr = shell->m_currentProcess->CommitChanges(1, &isnapshot, NULL);

    if (FAILED(hr))
    {
        shell->Write(L"EditAndContinue,CommitChanges with hr:0x%x\n", hr);
        return;
    }

    isnapshot->Release();

    if (! SUCCEEDED(hr))
        shell->Write(L"EditAndContinue failed with hresult %s\n", hr);

    shell->m_cEditAndContinues++;
    g_EditAndContinueCounter = shell->m_cEditAndContinues;
    
    hr = shell->NotifyModulesOfEnc(imodule, pStream);
    imodule->Release();

    if (pStream)
        pStream->Release();

    if (! SUCCEEDED(hr))
        shell->Write(L"Actual EnC went fine, but afterwards, NotifyModulesOfEnc failed with hresult %s\n",
                     hr);
}

// Provide help specific to this command
void EditAndContinueDebuggerCommand::Help(Shell *shell)
{
	ShellCommand::Help(shell);
	shell->Write(L"<delta PE> <delta PDB>\n");
    shell->Write(L"Updates the module for the currently running function.\n");
	shell->Write(L"The specified delta PE must have been created with the\n");
	shell->Write(L"zCompileForEnC command.\n");
    shell->Write(L"\n");
}


const WCHAR *EditAndContinueDebuggerCommand::ShortHelp(Shell *shell)
{
    return L"Perform an edit and continue";
}

//@TODO: JENH - remove this when appropriate
CompileForEditAndContinueCommand::CompileForEditAndContinueCommand(const WCHAR *name, int minMatchLength)
    : DebuggerCommand(name, minMatchLength)
{
    
}

void CompileForEditAndContinueCommand::Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
{
    if (shell->m_currentProcess == NULL)
    {
        shell->Error(L"Process not running.\n");
    }

    WCHAR *command = NULL;

    shell->GetStringArg(args, command);
    if (args == command)
    {
        Help(shell);
        return;
    }
    else
    {
		HRESULT hr = S_OK;
        // update the module containing the current function
        ICorDebugCode *icode = NULL;
        ICorDebugFunction *ifunction = NULL;
        ICorDebugModule *imodule = NULL;
		ICorDebugEditAndContinueSnapshot *isnapshot = NULL;
		IStream *pStream = NULL;

        if (shell->m_currentFrame == NULL)
        {
            shell->Write(L"CompileForEditAndContinue: Failed for lack of a current frame!\n");
            return; 
        }

        hr = shell->m_currentFrame->GetCode(&icode);
		_ASSERTE(SUCCEEDED(hr));
        hr = icode->GetFunction(&ifunction);
		_ASSERTE(SUCCEEDED(hr));
        icode->Release();
		hr = ifunction->GetModule(&imodule);
		_ASSERTE(SUCCEEDED(hr));
        ifunction->Release();

		// find module name
		WCHAR szModuleName[256];
		ULONG32 cchName;
		hr = imodule->GetName(sizeof(szModuleName), &cchName, szModuleName);
		_ASSERTE(cchName < sizeof(szModuleName));
		BOOL success = SetEnvironmentVariableW(L"COMP_ENCPE", szModuleName);
		if (! success) 
		{
			shell->Write(L"CompileForEditAndContinue,set COMP_ENCPE failed\n");
			return;
		}

		hr = imodule->GetEditAndContinueSnapshot(&isnapshot);
		_ASSERTE(SUCCEEDED(hr));
        imodule->Release();

		// get rdatarva
        ULONG32 dataRVA;
        hr = isnapshot->GetRwDataRVA(&dataRVA);
		if (FAILED(hr)) 
		{
			shell->Write(L"CompileForEditAndContinue, GetRwDataRVA failed\n");
			return;
		}

        hr = isnapshot->GetRoDataRVA(&dataRVA);
		if (FAILED(hr)) 
		{
			shell->Write(L"CompileForEditAndContinue, GetRwDataRVA failed\n");
			return;
		}
        isnapshot->Release();

		if (GetEnvironmentVariableW(L"COMP_ENCNORVA", 0, 0) == 0) 
		{
			WCHAR buf[10];
			WCHAR *rvaBuf = _ultow(dataRVA, buf, 16);
			if (! rvaBuf) 
			{
				shell->Write(L"CompileForEditAndContinue, ultoa failed\n");
				return;
			}

			success = SetEnvironmentVariableW(L"COMP_ENCRVA", rvaBuf);
			if (! success) 
			{
				shell->Write(L"CompileForEditAndContinue, set COMP_ENCRVA failed\n");
				return;
			}
			shell->Write(L"CompileForEditAndContinue, rva is %x\n", dataRVA);
		}

		// issue the compile command
		_wsystem(command);

		SetEnvironmentVariableA("COMP_ENCPE", "");
		SetEnvironmentVariableA("COMP_ENCRVA", "");
    }
}

// Provide help specific to this command
void CompileForEditAndContinueCommand::Help(Shell *shell)
{
	ShellCommand::Help(shell);
    shell->Write(L"<compilation command>\n");
    shell->Write(L"This will create a delta PE based on the module\n");
    shell->Write(L"currently being debugged. Note, that to add new\n");
    shell->Write(L"constant string data, you must use a compiler\n");
    shell->Write(L"that uses the ICeeFileGen interface.\n");
    shell->Write(L"\n");
}

const WCHAR *CompileForEditAndContinueCommand::ShortHelp(Shell *shell)
{
    return L"Compile source for an edit and continue";
}


//@Todo: this code only lives in the EE build system, need it for testing
//  EnC code.  We'll throw it out before we ship.


//
// CInMemoryStream
//

ULONG STDMETHODCALLTYPE CInMemoryStream::Release()
{
    ULONG       cRef = InterlockedDecrement((long *) &m_cRef);
    if (cRef == 0)
        delete this;
    return (cRef);
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::QueryInterface(REFIID riid, PVOID *ppOut)
{
    *ppOut = this;
    AddRef();
    return (S_OK);
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::Read(
                               void        *pv,
                               ULONG       cb,
                               ULONG       *pcbRead)
{
    ULONG       cbRead = min(cb, m_cbSize - m_cbCurrent);

    if (cbRead == 0)
        return (S_FALSE);
    memcpy(pv, (void *) ((long) m_pMem + m_cbCurrent), cbRead);
    if (pcbRead)
        *pcbRead = cbRead;
    m_cbCurrent += cbRead;
    return (S_OK);
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::Write(
                                const void  *pv,
                                ULONG       cb,
                                ULONG       *pcbWritten)
{
    if (m_cbCurrent + cb > m_cbSize)
        return (OutOfMemory());
    memcpy((BYTE *) m_pMem + m_cbCurrent, pv, cb);
    m_cbCurrent += cb;
    if (pcbWritten) *pcbWritten = cb;
    return (S_OK);
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::Seek(LARGE_INTEGER dlibMove,
                               DWORD       dwOrigin,
                               ULARGE_INTEGER *plibNewPosition)
{
    _ASSERTE(dwOrigin == STREAM_SEEK_SET);
    _ASSERTE(dlibMove.QuadPart <= ULONG_MAX);
    m_cbCurrent = (ULONG) dlibMove.QuadPart;
    //HACK HACK HACK
    //This allows dynamic IL to pass an assert in TiggerStorage::WriteSignature.
	if (plibNewPosition!=NULL)
        plibNewPosition->QuadPart = m_cbCurrent;

    _ASSERTE(m_cbCurrent < m_cbSize);
    return (S_OK);
}

HRESULT STDMETHODCALLTYPE CInMemoryStream::CopyTo(
                                 IStream     *pstm,
                                 ULARGE_INTEGER cb,
                                 ULARGE_INTEGER *pcbRead,
                                 ULARGE_INTEGER *pcbWritten)
{
    HRESULT     hr;
    // We don't handle pcbRead or pcbWritten.
    _ASSERTE(pcbRead == 0);
    _ASSERTE(pcbWritten == 0);

    _ASSERTE(cb.QuadPart <= ULONG_MAX);
    ULONG       cbTotal = min(static_cast<ULONG>(cb.QuadPart), m_cbSize - m_cbCurrent);
    ULONG       cbRead=min(1024, cbTotal);
    CQuickBytes rBuf;
    void        *pBuf = rBuf.Alloc(cbRead);
    if (pBuf == 0)
        return (PostError(OutOfMemory()));

    while (cbTotal)
        {
            if (cbRead > cbTotal)
                cbRead = cbTotal;
            if (FAILED(hr=Read(pBuf, cbRead, 0)))
                return (hr);
            if (FAILED(hr=pstm->Write(pBuf, cbRead, 0)))
                return (hr);
            cbTotal -= cbRead;
        }

    // Adjust seek pointer to the end.
    m_cbCurrent = m_cbSize;

    return (S_OK);
}

HRESULT CInMemoryStream::CreateStreamOnMemory(           // Return code.
                                    void        *pMem,                  // Memory to create stream on.
                                    ULONG       cbSize,                 // Size of data.
                                    IStream     **ppIStream)            // Return stream object here.
{
    CInMemoryStream *pIStream;          // New stream object.
    if ((pIStream = new CInMemoryStream) == 0)
        return (PostError(OutOfMemory()));
    pIStream->InitNew(pMem, cbSize);
    *ppIStream = pIStream;
    return (S_OK);
}


DisassembleDebuggerCommand::DisassembleDebuggerCommand(const WCHAR *name,
                                                       int minMatchLength)
	: DebuggerCommand(name, minMatchLength)
{
}

void DisassembleDebuggerCommand::Do(DebuggerShell *shell,
                                    ICorDebug *cor,
                                    const WCHAR *args)
{
    // If there is no process, cannot execute this command
    if (shell->m_currentProcess == NULL)
    {
        shell->Write(L"No current process.\n");
        return;
    }

    static int lastCount = 5;
    int count;
    int offset = 0;
    int startAddr = 0;
    
    while ((*args == L' ') && (*args != L'\0'))
        args++;

    if (*args == L'-')
    {
        args++;

        shell->GetIntArg(args, offset);
        offset *= -1;
    }
    else if (*args == L'+')
    {
        args++;

        shell->GetIntArg(args, offset);
    }
    else if ((*args == L'0') && ((*(args + 1) == L'x') ||
                                 (*(args + 1) == L'X')))
    {
        shell->GetIntArg(args, startAddr);
    }

    // Get the number of lines to print on top and bottom of current IP
    if (!shell->GetIntArg(args, count))
        count = lastCount;
    else
        lastCount = count;

    // Don't do anything if there isn't a current thread.
    if ((shell->m_currentThread == NULL) &&
        (shell->m_currentUnmanagedThread == NULL))
    {
        shell->Write(L"Thread no longer exists.\n");
        return;
    }

    // Only show the version info if EnC is enabled.
    if ((shell->m_rgfActiveModes & DSM_ENHANCED_DIAGNOSTICS) &&
        (shell->m_rawCurrentFrame != NULL))
    {
        ICorDebugCode *icode;
        HRESULT hr = shell->m_rawCurrentFrame->GetCode(&icode);

        if (FAILED(hr))
        {
            shell->Write(L"Code information unavailable\n");
        }
        else
        {
            CORDB_ADDRESS codeAddr;
            ULONG32 codeSize;

            hr = icode->GetAddress(&codeAddr);

            if (SUCCEEDED(hr))
                hr = icode->GetSize(&codeSize);

            if (SUCCEEDED(hr))
            {
                shell->Write(L"Code at 0x%08x", codeAddr);
                shell->Write(L" size %d\n", codeSize);
            }
            else
                shell->Write(L"Code address and size not available\n");
            
            ULONG32 nVer;
            hr = icode->GetVersionNumber(&nVer);
            RELEASE(icode);
            
            if (SUCCEEDED(hr))
                shell->Write(L"Version %d\n", nVer);
            else
                shell->Write(L"Code version not available\n");
        }

        ICorDebugFunction *ifnx = NULL;
        hr = shell->m_rawCurrentFrame->GetFunction(&ifnx);
        
        if (FAILED(hr))
        {
            shell->Write(L"Last EnC'd Version Number Unavailable\n");
        }
        else
        {
            ULONG32 nVer;
            hr = ifnx->GetCurrentVersionNumber(&nVer);
            RELEASE(ifnx);

            if (SUCCEEDED(hr)) {
                shell->Write(L"Last EnC'd Version: %d\n", nVer);
            }
        }
    }

    // Print out the disassembly around the current IP.
    shell->PrintCurrentInstruction(count,
                                   offset,
                                   startAddr);

    // Indicate that we are in disassembly display mode
    shell->m_showSource = false;
}

// Provide help specific to this command
void DisassembleDebuggerCommand::Help(Shell *shell)
{
	ShellCommand::Help(shell);
	shell->Write(L"[0x<address>] [{+|-}<delta>] [<line count>]\n");
    shell->Write(L"Displays native or IL disassembled instructions for the current instruction\n");
    shell->Write(L"pointer (ip) or a given address, if specified. The default number of\n");
    shell->Write(L"instructions displayed is five (5). If a line count argument is provided,\n");
    shell->Write(L"the specified number of extra instructions will be shown before and after\n");
    shell->Write(L"the current ip or address. The last line count used becomes the default\n");
    shell->Write(L"for the current session. If a delta is specified then the number specified\n");
    shell->Write(L"will be added to the current ip or given address to begin disassembling.\n");
    shell->Write(L"\n");
    shell->Write(L"Examples:\n");
    shell->Write(L"   dis 20\n");
    shell->Write(L"   dis 0x31102500 +5 20\n");
    shell->Write(L"\n");
}

const WCHAR *DisassembleDebuggerCommand::ShortHelp(Shell *shell)
{
    return L"Display native or IL disassembled instructions";
}

/* ------------------------------------------------------------------------- *
 * ConnectDebuggerCommand is used to connect to an embedded                  *
 * (starlite) CLR device.                                                    *
 * ------------------------------------------------------------------------- */

ConnectDebuggerCommand::ConnectDebuggerCommand(const WCHAR *name,
                                               int minMatchLength)
        : DebuggerCommand(name, minMatchLength)
{
}

void ConnectDebuggerCommand::Do(DebuggerShell *shell,
                                ICorDebug *cor,
                                const WCHAR *args)
{
    WCHAR *lpParameters = NULL;

    if (!(shell->m_rgfActiveModes & DSM_EMBEDDED_CLR))
    {
        shell->Write(L"ERROR: connect only works for Embedded CLR\n");
        return;
    }

    if (!shell->GetStringArg(args, lpParameters))
    {
        Help(shell);
        return;
    }
    WCHAR lpCurrentDir[_MAX_PATH];

    // Get the current directory for the load module path mapping
    GetCurrentDirectory(_MAX_PATH, lpCurrentDir);

    // Attempt to connect
    ICorDebugProcess *proc;

    HRESULT hr = cor->CreateProcess(
      L"\\?\\1",                        // lpApplicationName - special string
      lpParameters,                     // lpCommandLine
      NULL,                             // lpProcesssAttributes
      NULL,                             // lpThreadAttributes
      FALSE,                            // bInheritHandles
      0,                                // dwCreationFlags
      NULL,                             // lpEnvironment
      lpCurrentDir,                     // lpCurrentDirectory
      NULL,                             // lpStartupInfo
      NULL,                             // lpProcessInformation
      DEBUG_NO_SPECIAL_OPTIONS,         // debuggingFlags
      &proc);                           // ppProcess

    if (SUCCEEDED(hr))
    {
        // We don't care to keep this reference to the process.
        g_pShell->SetTargetProcess(proc);
        proc->Release();

        shell->Run(true); // No initial Continue!
    }
    else
    {
        shell->ReportError(hr);
    }
}

// Provide help specific to this command
void ConnectDebuggerCommand::Help(Shell *shell)
{
    ShellCommand::Help(shell);
    shell->Write(L"<machine_name> <port>\n");
    shell->Write(L"Connects to a remote embedded CLR device.\n");
    shell->Write(L"<machine_name> is the remote machine name\n");
    shell->Write(L"<port> is the remote machine port number\n");
    shell->Write(L"\n");
}

const WCHAR *ConnectDebuggerCommand::ShortHelp(Shell *shell)
{
    return L"Connect to a remote device";
}

ClearUnmanagedExceptionCommand::ClearUnmanagedExceptionCommand(const WCHAR *name, int minMatchLength)
    : DebuggerCommand(name, minMatchLength)
{
}

void ClearUnmanagedExceptionCommand::Do(DebuggerShell *shell,
                                        ICorDebug *cor,
                                        const WCHAR *args)
{
    if (shell->m_currentProcess == NULL)
    {
        shell->Error(L"Process not running.\n");
        return;
    }
    
    // We're given the thread id as the only param
    int dwThreadId;
    if (!shell->GetIntArg(args, dwThreadId))
    {
        Help(shell);
        return;
    }

    // Find the unmanaged thread
    DebuggerUnmanagedThread *ut =
        (DebuggerUnmanagedThread*) shell->m_unmanagedThreads.GetBase(dwThreadId);

    if (ut == NULL)
    {
        shell->Write(L"Thread 0x%x (%d) does not exist.\n",
                     dwThreadId, dwThreadId);
        return;
    }
    
    HRESULT hr =
        shell->m_currentProcess->ClearCurrentException(dwThreadId);

    if (!SUCCEEDED(hr))
        shell->ReportError(hr);
}

	// Provide help specific to this command
void ClearUnmanagedExceptionCommand::Help(Shell *shell)
{
	ShellCommand::Help(shell);
    shell->Write(L"<tid>\n");
    shell->Write(L"Clear the current unmanaged exception for the given tid\n");
    shell->Write(L"\n");
}

const WCHAR *ClearUnmanagedExceptionCommand::ShortHelp(Shell *shell)
{
    return L"Clear the current unmanaged exception (Win32 mode only)";
}

// Unmanaged commands

/* ------------------------------------------------------------------------- *
 * UnmanagedThreadsDebuggerCommand is used to create and run a new COM+ process.
 * ------------------------------------------------------------------------- */
UnmanagedThreadsDebuggerCommand::UnmanagedThreadsDebuggerCommand(
                                                    const WCHAR *name,
                                                    int minMatchLength)
	: DebuggerCommand(name, minMatchLength)
{
}

void UnmanagedThreadsDebuggerCommand::Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args)
{
    // If there is no process, there must be no threads!
    if (shell->m_currentProcess == NULL)
    {
        shell->Write(L"No current process.\n");
        return;
    }

    // Display the active threads
    if (*args == 0)
    {
        shell->TraceAllUnmanagedThreadStacks();
    }
    // Otherwise, switch current thread
    else
    {
        HRESULT hr;
        int tid;

        if (shell->GetIntArg(args, tid))
        {
            DebuggerUnmanagedThread *ut = (DebuggerUnmanagedThread*) 
                shell->m_unmanagedThreads.GetBase(tid);

            if (ut == NULL)
                shell->Write(L"No such thread.\n");
            else
            {
                shell->SetCurrentThread(shell->m_currentProcess, NULL, ut);
                shell->SetDefaultFrame();

                HANDLE hProcess;
                hr = shell->m_currentProcess->GetHandle(&hProcess);

                if (FAILED(hr))
                    shell->ReportError(hr);
                else
                    shell->TraceUnmanagedThreadStack(hProcess, 
                                                     ut, TRUE);
            }
        }
        else
            shell->Write(L"Invalid thread id.\n");
    }
}

// Provide help specific to this command
void UnmanagedThreadsDebuggerCommand::Help(Shell *shell)
{
    ShellCommand::Help(shell);
    shell->Write(L"[<tid>]\n");
    shell->Write(L"Sets or displays unmanaged threads. If no argument\n");
    shell->Write(L"is given, the command displays all unmanaged threads.\n");
    shell->Write(L"Otherwise, the current unmanaged thread is set to tid.\n");
    shell->Write(L"\n");
}

const WCHAR *UnmanagedThreadsDebuggerCommand::ShortHelp(Shell *shell)
{
    return L"Set or display unmanaged threads (Win32 mode only)";
}

/* ------------------------------------------------------------------------- *
 * UnmanagedWhereDebuggerCommand is used to create and run a new COM+ process.
 * ------------------------------------------------------------------------- */

UnmanagedWhereDebuggerCommand::UnmanagedWhereDebuggerCommand(
                                                  const WCHAR *name,
                                                  int minMatchLength)
	: DebuggerCommand(name, minMatchLength)
{
}

void UnmanagedWhereDebuggerCommand::Do(DebuggerShell *shell,
                                       ICorDebug *cor,
                                       const WCHAR *args)
{
    HRESULT hr = S_OK;  
    int iNumFramesToShow;

    if (!shell->GetIntArg(args, iNumFramesToShow))
        iNumFramesToShow = 1000;
    else
    {
        if (iNumFramesToShow < 0)
            iNumFramesToShow = 1000;
    }

    DebuggerUnmanagedThread *ut = shell->m_currentUnmanagedThread;

    if (ut == NULL)
    {
        shell->Write(L"Thread no longer exists.\n");
        return;
    }

    HANDLE hProcess;
    hr = shell->m_currentProcess->GetHandle(&hProcess);

    if (FAILED(hr))
    {
        shell->ReportError(hr);
        return;
    }

    shell->TraceUnmanagedThreadStack(hProcess, ut, TRUE);
}

// Provide help specific to this command
void UnmanagedWhereDebuggerCommand::Help(Shell *shell)
{
	ShellCommand::Help(shell);
	shell->Write(L"\n");
    shell->Write(L"Displays the unmanaged stack trace for the current thread.\n");
    shell->Write(L"\n");
}

const WCHAR *UnmanagedWhereDebuggerCommand::ShortHelp(Shell *shell)
{
    return L"Display an unmanaged stack trace (Win32 mode only)";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\shell.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * debug\shell.cpp: generic shell routines
 * ------------------------------------------------------------------------- */
#include "stdafx.h"

#include <Winbase.h>

#include "shell.h"

/* ------------------------------------------------------------------------- *
 * ShellCommand routines
 * ------------------------------------------------------------------------- */

ShellCommand::ShellCommand(const WCHAR *n, int min)
{
	int length = wcslen(n);
    _ASSERTE(min <= length);
    
    m_pName = n; 
    m_bHasShortcut = (BOOL)((min > 0) && (min < length));
	m_minMatchLength = ((m_bHasShortcut == TRUE) ? min : length);
    
    // figure out the shortcut name
    if (m_bHasShortcut == TRUE)
    {  
    	wcsncpy(m_pShortcutName, m_pName, m_minMatchLength);
      	m_pShortcutName[m_minMatchLength] = L'\0';
            
       	wcscat(m_pShortcutName, L"[");
        wcscat(m_pShortcutName, m_pName + m_minMatchLength);
        wcscat(m_pShortcutName, L"]");
   	}
    else
    	wcscpy(m_pShortcutName, n);	          
}

void ShellCommand::Help(Shell *shell)
{		
    shell->Write(L"Usage: %s ", m_pShortcutName);
}


/* ------------------------------------------------------------------------- *
 * ShellCommandTable routines
 * ------------------------------------------------------------------------- */

struct ShellCommandEntry
{
    HASHENTRY entry;

    ShellCommand *command;
};

class ShellCommandTable : CHashTableAndData<CNewData>
{
private:
    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    {
        return((WCHAR)pc1) != ((ShellCommandEntry*)pc2)->command->GetName()[0];
    };

    USHORT HASH(const WCHAR *name) 
    {
        // Try and keep them alphabetic
        if(name[0] < L'a')
            return(name[0] - L'a');
        else
            return(name[0] - L'A');
    };

    BYTE *KEY(const WCHAR *name) 
    {
        return ((BYTE *) name[0]);
    };

    bool Match(const WCHAR *string, size_t length, const WCHAR *match, size_t minMatchLength)
    {
        return(length >= minMatchLength && wcsncmp(string, match, length) == 0);
    }

    ShellCommandEntry *Find(const WCHAR *name)
    {
        return((ShellCommandEntry *) CHashTableAndData<CNewData>::Find(HASH(name), KEY(name)));
    }
    
    ShellCommandEntry *FindNext(ShellCommandEntry *cmdEntry)
    {
        USHORT index =
            CHashTableAndData<CNewData>::FindNext(KEY(cmdEntry->command->GetName()),
                                                  ItemIndex(&cmdEntry->entry));
        
        if(index == 0xffff)
            return(NULL);
        else
            return((ShellCommandEntry *) EntryPtr(index));
    }

public:

    ShellCommandTable() : CHashTableAndData<CNewData>(50) 
    {
        NewInit(50, sizeof(ShellCommandEntry), 500);
    }

    bool AddCommand(ShellCommand *newCommand)
    {
        //
        // Check for duplicate entry
        //
        for(ShellCommandEntry *entry = Find(newCommand->GetName());
           entry != NULL;
           entry = FindNext(entry))
        {
            ShellCommand *command = entry->command;

            // If we find a match, the command may not be entered
            if(Match(newCommand->GetName(), newCommand->GetMinMatchLength(),
                     command->GetName(), command->GetMinMatchLength()))
                return(false);
        }

        //
        // Add the new entry and fill out the data structure
        //
        ShellCommandEntry *newEntry = (ShellCommandEntry*) Add(HASH(newCommand->GetName()));
        _ASSERTE(newEntry != NULL);
        newEntry->command = newCommand;

        return(true);
    }

    ShellCommand *GetCommand(const WCHAR *string, size_t length)
    {
        for(ShellCommandEntry *entry = Find(string);
           entry != NULL;
           entry = FindNext(entry))
        {
            ShellCommand *command = entry->command;

            if(Match(string, length, command->GetName(), command->GetMinMatchLength()))
                return(command);
        }

        return(NULL);
    }

    ShellCommand *GetFirstCommand(HASHFIND *info)
    {
        ShellCommandEntry *entry = (ShellCommandEntry *) FindFirstEntry(info);
        
        if(entry == NULL)
            return(NULL);
        else
            return(entry->command);
    }

    ShellCommand *GetNextCommand(HASHFIND *info)
    {
        ShellCommandEntry *entry = (ShellCommandEntry *) FindNextEntry(info);

        if(entry == NULL)
            return(NULL);
        else
            return(entry->command);
    }
};

/* ------------------------------------------------------------------------- *
 * Shell routines
 * ------------------------------------------------------------------------- */

Shell::Shell()
{
    m_pPrompt = L"(shell)";
    m_pCommands = new ShellCommandTable();
    _ASSERTE(m_pCommands != NULL);
    m_lastCommand[0] = L'\0';
}

Shell::~Shell()
{
    HASHFIND info;

    for(ShellCommand *command = m_pCommands->GetFirstCommand(&info);
       command != NULL;
       command = m_pCommands->GetNextCommand(&info))
    {
        delete command;
    }

    delete m_pCommands;
}

void Shell::AddCommand(ShellCommand *command)
{
    m_pCommands->AddCommand(command); 
}

void Shell::PutCommand(FILE *f)
{
	fwprintf(f, m_buffer);
	fwprintf(f, L"\n");
}

ShellCommand *Shell::GetCommand(const WCHAR *string, size_t length)
{
    return(m_pCommands->GetCommand(string, length));
} 

void Shell::ReadCommand()
{
    Write(L"%s ", m_pPrompt);

    // !!! would be nice to handle some control characters - 
    // we'll see what we get for free from stdio

    m_buffer[0] = L'\0';

    // @todo: ReadLine can fail if you hit ctrl-break while it in. It
    // retuns a failure, but we don't really want to quit at that
    // point. I'm leaving the old code for now just in case we find
    // the need to switch back.
#if 0
    if(!ReadLine(m_buffer, BUFFER_SIZE))
        wcscpy(m_buffer, L"quit");

    DoCommand(m_buffer);
#else
    if(ReadLine(m_buffer, BUFFER_SIZE))
        DoCommand(m_buffer);
#endif    
}

void Shell::DoCommand(const WCHAR *string)
{
    const WCHAR     *args;
    const WCHAR     *commandName;
    ShellCommand    *command;

    if (*string == L'\0')
        string = m_lastCommand;
    else
        wcscpy(m_lastCommand, string);

    // If the command is prefixed with a '*', then execute it once for every thread in the process.
    if ((string != NULL) && (string[0] == L'*'))
    {
        WCHAR *newString = (WCHAR*)string;
        
        // Skip all '*'s.
        while ((newString != NULL) && (newString[0] == L'*'))
            newString++;

        if (wcslen(newString) == 0)
        {
            Error(L"No command following *. \n");
            return;
        }

        // Do the command over all threads
        return DoCommandForAllThreads(newString);
    }
    
    args = string;

    if (GetStringArg(args, commandName))
    {
        command = m_pCommands->GetCommand(commandName, args - commandName);

        if (command == NULL)
        {
            if (wcslen(string) != 0)
                Error(L"Unknown command \"%.*s\"\n", args - commandName, commandName);
        }
        else
        {
            while (*args && iswspace(*args))
                args++;

            command->Do(this, args);
        }
    }
}

#define MAX_SHELL_COMMANDS		256

void Shell::Help()
{
    HASHFIND        info;
	ShellCommand *pCommand [MAX_SHELL_COMMANDS];
	int iNumCommands = 0;

    Write(L"\nThe following commands are available:\n\n");

	pCommand [iNumCommands] = m_pCommands->GetFirstCommand(&info);
    
	while ((pCommand [iNumCommands] != NULL) && 
			(iNumCommands < MAX_SHELL_COMMANDS))
	{
		iNumCommands++;
		pCommand [iNumCommands] = m_pCommands->GetNextCommand(&info);
	}

	// The commands that are returned are already sorted, it's just that 
	// they don't start from "a". So, find the first entry starting with 
	// "a" (there will be atleast one due to the "attach" command) and start
	// printing from there. Then wrap around.

	int iStartIndex = 0;
	bool fFound = false;

	while ((fFound == false) && (iStartIndex < iNumCommands))
	{
		WCHAR *strName = (WCHAR *)pCommand [iStartIndex] ->GetName();
		if ((strName[0] == L'a') || (strName[0] == L'A'))
			fFound = true;
		else
			iStartIndex++;
	}

	// assert that there's always one command starting with "a".
	_ASSERTE (iStartIndex < iNumCommands);

	// now print the commands starting from this one.
	int iEndMarker = iStartIndex;

	do
	{
        _ASSERTE( iNumCommands != 0 );
    	ShellCommand *command = pCommand [iStartIndex % iNumCommands];
		iStartIndex++;
        
      	Write(L"%-20s%s\n", command->GetShortcutName(), command->ShortHelp(this));
                    
    } while ((iStartIndex % iNumCommands) != iEndMarker);
}

void Shell::ReportError(long hr)
{
    WCHAR* wszBuffer = NULL;

    switch (hr)
    {
        case CORDBG_E_FUNCTION_NOT_IL:
            wszBuffer = L"The function has no managed body\n";
            break;

        case CORDBG_E_UNRECOVERABLE_ERROR:
            wszBuffer = L"Unrecoverable internal error\n";
            break;

        case CORDBG_E_PROCESS_TERMINATED:
            wszBuffer = L"The debuggee has terminated\n";
            break;
        
        case CORDBG_E_PROCESS_NOT_SYNCHRONIZED:
            wszBuffer = L"Unable to process while debuggee is running\n";
            break;
        
        case CORDBG_E_CLASS_NOT_LOADED:
            wszBuffer = L"A class has not been loaded yet by the debuggee\n";
            break;
        
        case CORDBG_E_IL_VAR_NOT_AVAILABLE:
            wszBuffer = L"The variable is not available\n";
            break;
        
        case CORDBG_E_BAD_REFERENCE_VALUE:
            wszBuffer = L"The reference is invalid\n";
            break;
        
        case CORDBG_E_FIELD_NOT_AVAILABLE:
            wszBuffer = L"The field is not available.\n";
            break;
        
        case CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL:
            wszBuffer = L"The field is not available because it is a constant optimized away by the runtime.\n";
            break;
        
        case CORDBG_E_NON_NATIVE_FRAME:
            wszBuffer = L"The frame type is incorrect\n";
            break;
        
        case CORDBG_E_NONCONTINUABLE_EXCEPTION:
            wszBuffer = L"The exception cannot be continued from\n";
            break;
        
        case CORDBG_E_CODE_NOT_AVAILABLE:
            wszBuffer = L"The code is not available at this time\n";
            break;
        
        case CORDBG_S_BAD_START_SEQUENCE_POINT:
            wszBuffer = L"The operation cannot be started at the current IP\n";
            break;
        
        case CORDBG_S_BAD_END_SEQUENCE_POINT:
            wszBuffer = L"The destination IP is not valid\n";
            break;
        
        case CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP:
            wszBuffer = L"Insufficient information to perform Set IP\n";
            break;
        
        case CORDBG_E_CANT_SET_IP_INTO_FINALLY:
            wszBuffer = L"Cannot Set IP into a finally clause\n";
            break;
        
        case CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY:
            wszBuffer = L"Cannot Set IP out of a finally clause\n";
            break;
        
        case CORDBG_E_CANT_SET_IP_INTO_CATCH:
            wszBuffer = L"Cannot Set IP into a catch clause\n";
            break;
        
        case CORDBG_E_SET_IP_IMPOSSIBLE:
            wszBuffer = L"Unable to Set IP\n";
            break;
        
        case CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME:
            wszBuffer = L"Can't Set IP on a non-leaf frame\n";
            break;
        
        case CORDBG_E_FUNC_EVAL_BAD_START_POINT:
            wszBuffer = L"Cannot perform a func eval at the current IP\n";
            break;
        
        case CORDBG_E_INVALID_OBJECT:
            wszBuffer = L"The object value is no longer valid\n";
            break;
        
        case CORDBG_E_FUNC_EVAL_NOT_COMPLETE:
            wszBuffer = L"The func eval is still being processed\n";
            break;
        
        case CORDBG_S_FUNC_EVAL_HAS_NO_RESULT:
            wszBuffer = L"The func eval has no result\n";
            break;
        
        case CORDBG_S_VALUE_POINTS_TO_VOID:
            wszBuffer = L"Can't dereference a void pointer\n";
            break;
        
        case CORDBG_E_INPROC_NOT_IMPL:
            wszBuffer = L"The API is not usable in-process\n";
            break;
        
        case CORDBG_S_FUNC_EVAL_ABORTED:
            wszBuffer = L"The func eval was aborted\n";
            break;
        
        case CORDBG_E_STATIC_VAR_NOT_AVAILABLE:
            wszBuffer = L"The static variable is not available (not yet "
                        L"initialized)\n";
            break;
        
        case CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS:
            wszBuffer = L"The value class object cannot be copied\n";
            break;
        
        case CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER:
            wszBuffer = L"Cannot Set IP into or out of a filter\n";
            break;
        
        case CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE:
            wszBuffer = L"Cannot change JIT setting for pre-jitted module\n";
            break;
        
        case CORDBG_E_BAD_THREAD_STATE:
            wszBuffer = L"The thread's state is invalid\n";
            break;

        case CORDBG_E_DEBUGGING_NOT_POSSIBLE:
            wszBuffer = L"Debugging is not possible due to a runtime configuration issue\n";
            break;

        case CORDBG_E_KERNEL_DEBUGGER_ENABLED:
            wszBuffer = L"Debugging is not possible because there is a kernel debugger enabled on your system\n";
            break;
        
        case CORDBG_E_KERNEL_DEBUGGER_PRESENT:
            wszBuffer = L"Debugging is not possible because there is a kernel debugger present on your system\n";
            break;

        case CORDBG_E_INCOMPATIBLE_PROTOCOL:
            wszBuffer = L"The process cannot be debugged because the debugger's\ninternal debugging protocol is incompatible with the protocol supported\nby the process.\n";
            break;
            
        default:
        {
            wszBuffer = NULL;
        }
    }
    
    PCHAR szBuffer = NULL;

    if (!wszBuffer)
    {

        // Get the string error from the HR
        DWORD res = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM 
                                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                                    | FORMAT_MESSAGE_IGNORE_INSERTS, 
                                    NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                                    (LPSTR) &szBuffer, 0, NULL);

        if (!res)
        {
            _ASSERTE(FAILED(HRESULT_FROM_WIN32(GetLastError())));

            szBuffer = "Non-Winbase Error\n";
        }
    }
    else
    {
        MAKE_ANSIPTR_FROMWIDE(tempBuffer, wszBuffer);

        szBuffer = tempBuffer;
    }

    CHAR sz[1024];

    sprintf(sz, "Error: hr=0x%08x, %s", hr, szBuffer);

    MAKE_WIDEPTR_FROMANSI(wsz, sz);
    
    Error(wsz);

    if (!wszBuffer && szBuffer)
    {
        LocalFree(szBuffer);
    }
}

void Shell::SystemError()
{
    ReportError(GetLastError());
}

size_t Shell::GetArgArray(WCHAR *argString, const WCHAR **argArray, size_t argMax)
{
    const WCHAR **pArg = argArray, **pArgEnd = pArg, **pArgMax = pArg + argMax;

    while(pArgEnd < pArgMax)
    {
        // 
        // Skip leading white space
        //
        while(*argString && iswspace(*argString))
            argString++;

        if(*argString == 0)
            break;

        *pArgEnd++ = argString;

        //
        // Add some kind of quoting at some point
        //

        while(*argString && !iswspace(*argString))
            argString++;

        *argString++ = 0;
    }

    return(pArgEnd - argArray);
}

bool Shell::GetStringArg(const WCHAR *&string, const WCHAR *&result)
{
    while(*string && iswspace(*string))
        string++;

    result = string;

    while(*string && !iswspace(*string))
        string++;

    return(true);
}

bool Shell::GetIntArg(const WCHAR *&string, int &result)
{
    while(*string && iswspace(*string))
        string++;

    result = 0;

    if(string[0] == L'0' && towlower(string[1]) == L'x')
    {
        string += 2;

        while(iswxdigit(*string))
        {
            result <<= 4;
            if(iswdigit(*string))
                result += *string - L'0';
            else
                result += 10 + towlower(*string) - L'a';

            string++;
        }

        return(true);
    }
    else if(iswdigit(*string))
    {
        while(iswdigit(*string))
        {
            result *= 10;
            result += *string++ - L'0';
        }

        return(true);
    }
    else
        return(false);
}

bool Shell::GetInt64Arg(const WCHAR *&string, unsigned __int64 &result)
{
    while(*string && iswspace(*string))
        string++;

    result = 0;

    if(string[0] == L'0' && towlower(string[1]) == L'x')
    {
        string += 2;

        while(iswxdigit(*string))
        {
            result <<= 4;
            if(iswdigit(*string))
                result += *string - L'0';
            else
                result += 10 + towlower(*string) - L'a';

            string++;
        }

        return(true);
    }
    else if(iswdigit(*string))
    {
        while(iswdigit(*string))
        {
            result *= 10;
            result += *string++ - L'0';
        }

        return(true);
    }
    else
        return(false);
}

/* ------------------------------------------------------------------------- *
 * HelpShellCommand routines
 * ------------------------------------------------------------------------- */

void HelpShellCommand::Do(Shell *shell, const WCHAR *args)
{
    if (*args == 0)
        Help(shell);

    const WCHAR *commandName;

    while ((shell->GetStringArg(args, commandName)) &&
           *commandName != 0)
    {
        ShellCommand *command = shell->GetCommand(commandName,
                                                  args - commandName);

        if (command == NULL)
            shell->Error(L"Unknown command \"%.*s\"\n",
                         args - commandName, commandName);
        else
            command->Help(shell);

        shell->Write(L"\n");
    }
}

void HelpShellCommand::Help(Shell *shell)
{
	ShellCommand::Help(shell);
	shell->Write(L"[<command> ...]\n");
    shell->Write(L"Displays debugger command descriptions. If no arguments\n");
    shell->Write(L"are passed, a list of debugger commands is displayed. If\n");
    shell->Write(L"one or more command arguments is provided, descriptions\n");
    shell->Write(L"are displayed for the specified commands. The ? command\n");
    shell->Write(L"is an alias for the help command.\n");
    
    shell->Help();
    shell->Write(L"\n");    
}

const WCHAR *HelpShellCommand::ShortHelp(Shell *shell)
{
    return L"Display debugger command descriptions";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\dshell.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * debug\comshell.cpp: com debugger shell functions
 * ------------------------------------------------------------------------- */

#include "stdafx.h"

#include "dshell.h"

#ifdef _INTERNAL_DEBUG_SUPPORT_
#include "__file__.ver"
#endif

// Poor-man's import of System.Object. Can't import mscorlib.tlb since
// it hasn't been built yet.
static const GUID IID_Object = {0x65074F7F, 0x63C0, 0x304E, { 0xAF, 0x0A, 0xD5, 0x17, 0x41, 0xCB, 0x4A, 0x8D}};
struct _Object : IDispatch
{
    virtual HRESULT __stdcall get_ToString(BSTR *pBstr) = 0;        
    virtual HRESULT __stdcall Equals() = 0;
    virtual HRESULT __stdcall GetHashCode() = 0;
    virtual HRESULT __stdcall GetType() = 0;
};


/* ------------------------------------------------------------------------- *
 * Def for a signature formatter, stolen from the internals of the Runtime
 * ------------------------------------------------------------------------- */
class SigFormat
{
public:
    SigFormat(IMetaDataImport *importer, PCCOR_SIGNATURE sigBlob, ULONG sigBlobSize, WCHAR *methodName);
    ~SigFormat();

    HRESULT FormatSig();
    WCHAR *GetString();
    ULONG AddType(PCCOR_SIGNATURE sigBlob);

protected:
    WCHAR*           _fmtSig;
    int              _size;
    int              _pos;
    PCCOR_SIGNATURE  _sigBlob;
    ULONG            _sigBlobSize;
    WCHAR           *_memberName;
    IMetaDataImport *_importer;

    int AddSpace();
    int AddString(WCHAR *s);
};

/* ------------------------------------------------------------------------- *
 * Globals
 * ------------------------------------------------------------------------- */

DebuggerShell        *g_pShell = NULL;

#if DOSPEW
#define SPEW(s) s
#else
#define SPEW(s)
#endif

WCHAR *FindSep(                         // Pointer to separator or null.
    const WCHAR *szPath)                // The path to look in.
{
    WCHAR *ptr = wcsrchr(szPath, L'.');
    if (ptr && ptr - 1 >= szPath && *(ptr - 1) == L'.')
        --ptr;
    return ptr;
}

ICorDebugController *GetControllerInterface(ICorDebugAppDomain *pAppDomain)
{
    ICorDebugProcess *pProcess = NULL;
    ICorDebugController *pController = NULL;
    HRESULT hr = S_OK;

    hr = pAppDomain->GetProcess(&pProcess);
    if (FAILED(hr))
        return pController;

    hr = pProcess->QueryInterface(IID_ICorDebugController,
                                  (void**)&pController);

    RELEASE(pProcess);

    _ASSERTE(pController != NULL); 
    return pController;
}

HRESULT DebuggerCallback::CreateProcess(ICorDebugProcess *pProcess)
{
    g_pShell->m_enableCtrlBreak = false;
    DWORD pid = 0;
    
    SPEW(fprintf(stderr, "[%d] DC::CreateProcess.\n", GetCurrentThreadId()));

    pProcess->GetID(&pid);
    g_pShell->Write(L"Process %d/0x%x created.\n", pid, pid);
    g_pShell->SetTargetProcess(pProcess);

    SPEW(fprintf(stderr, "[%d] DC::CP: creating process.\n", GetCurrentThreadId()));
    SPEW(fprintf(stderr, "[%d] DC::CP: returning.\n", GetCurrentThreadId()));

    // Also initialize the source file search path 
    g_pShell->m_FPCache.Init ();

    g_pShell->m_gotFirstThread = false;

    g_pShell->Continue(pProcess, NULL);

    return (S_OK);
}

HRESULT DebuggerCallback::ExitProcess(ICorDebugProcess *pProcess)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::ExitProcess.\n", GetCurrentThreadId()));

    g_pShell->Write(L"Process exited.\n");

    if (g_pShell->m_targetProcess == pProcess)
        g_pShell->SetTargetProcess(NULL);

    g_pShell->Stop(NULL, NULL);

    SPEW(fprintf(stderr, "[%d] DC::EP: returning.\n", GetCurrentThreadId()));
    return (S_OK);
}


//  @mfunc BOOL|DebuggerShell|SkipProlog|Determines if
//  the debuggee is current inside of either a prolog or
//  interceptor (eg, class initializer), and if we don't
//  want to be, then it steps us over or out of (respectively)
//  the code region.
//  @rdesc returns TRUE if we are in a prolog||interceptor,
//      and we've stepped over XOR out of that region.
//      Otherwise, returns FALSE
BOOL DebuggerShell::SkipProlog(ICorDebugAppDomain *pAD,
                               ICorDebugThread *thread,
                               bool gotFirstThread)
{
    ICorDebugFrame *pFrame = NULL;
    ICorDebugILFrame *pilFrame = NULL;
    ULONG32 ilOff = 0;
    CorDebugMappingResult mapping;
    bool fStepOver = false;

    ICorDebugChain *chain = NULL;
    CorDebugChainReason reason;
    bool fStepOutOf = false;
        
    ICorDebugStepper *pStepper = NULL;
    // If we're in the prolog or interceptor,
    // but the user doesn't want to see it, create
    // a stepper to step over the prolog
    if (! (m_rgfActiveModes & DSM_UNMAPPED_STOP_PROLOG
         ||m_rgfActiveModes & DSM_UNMAPPED_STOP_ALL) )
    {
        SPEW(fprintf(stderr, "DC::CreateThread: We're not interested in prologs\n"));

        if (FAILED(thread->GetActiveFrame( &pFrame ) ) ||
            (pFrame == NULL) ||
            FAILED(pFrame->QueryInterface(IID_ICorDebugILFrame,
                                          (void**)&pilFrame)) ||
            FAILED(pilFrame->GetIP( &ilOff, &mapping )) )
        {
            Write(L"Unable to  determine existence of prolog, if any\n");
            mapping = (CorDebugMappingResult)~MAPPING_PROLOG;
        }

        if (mapping & MAPPING_PROLOG)
        {
            fStepOver = true;
        }
    }

    // Are we in an interceptor?
    if (FAILED(thread->GetActiveChain( &chain ) ) )
    {
        Write( L"Unable to obtain active chain!\n" );
        goto LExit;
    }
    
    if ( FAILED( chain->GetReason( &reason)) )
    {
        Write( L"Unable to query current chain!\n" );
        RELEASE( chain );
        chain = NULL;
        goto LExit;
    }
    RELEASE( chain );
    chain = NULL;

    // If there's any interesting reason & we've said stop on everything, then
    // don't step out
    // Otherwise, as long as at least one reason has 
    // been flagged by the user as uninteresting, and we happen to be in such
    // an uninteresting frame, then we should step out.
    if (
        !( (reason &(CHAIN_CLASS_INIT|CHAIN_SECURITY|
                    CHAIN_EXCEPTION_FILTER|CHAIN_CONTEXT_POLICY
                    |CHAIN_INTERCEPTION))&&
            (m_rgfActiveModes & DSM_INTERCEPT_STOP_ALL))
        &&
        (((reason & CHAIN_CLASS_INIT) && 
            !(m_rgfActiveModes & DSM_INTERCEPT_STOP_CLASS_INIT))
        ||((reason & CHAIN_SECURITY) && 
            !(m_rgfActiveModes & DSM_INTERCEPT_STOP_SECURITY)) 
        ||((reason & CHAIN_EXCEPTION_FILTER) && 
            !(m_rgfActiveModes & DSM_INTERCEPT_STOP_EXCEPTION_FILTER))
        ||((reason & CHAIN_CONTEXT_POLICY) && 
            !(m_rgfActiveModes & DSM_INTERCEPT_STOP_CONTEXT_POLICY)) 
        ||((reason & CHAIN_INTERCEPTION) && 
            !(m_rgfActiveModes & DSM_INTERCEPT_STOP_INTERCEPTION)))
       )
    {
        fStepOutOf = true;
    }
    
    if ( fStepOutOf || fStepOver )
    {
        if ( FAILED(thread->CreateStepper( &pStepper )) ||
             FAILED(pStepper->SetUnmappedStopMask(ComputeStopMask())) ||
             FAILED(pStepper->SetInterceptMask(ComputeInterceptMask())))
        {
            Write( L"Unable to step around special code!\n");
            g_pShell->Stop(pAD, thread);
            goto LExit;
        }

        if ( fStepOutOf )
        {
            if (FAILED(pStepper->StepOut()) )
            {
                Write( L"Unable to step out of interceptor\n" );
                g_pShell->Stop(pAD, thread);
                goto LExit;
            }
        }
        else if ( fStepOver && FAILED(pStepper->Step(false)))
        {
            Write( L"Unable to step over prolog,epilog,etc\n" );
            g_pShell->Stop(pAD, thread);
            goto LExit;
        }
        
        StepStart(thread, pStepper);

        // Remember that we're stepping because we want to stop on a
        // thread create. But don't do this for the first thread,
        // otherwise we'll never stop for it!
        if (gotFirstThread)
        {
            DWORD dwThreadId;
            HRESULT hr = thread->GetID(&dwThreadId);
            _ASSERTE(!FAILED(hr));
        
            DebuggerManagedThread *dmt = (DebuggerManagedThread*)
                m_managedThreads.GetBase(dwThreadId);
            _ASSERTE(dmt != NULL);
        
            dmt->m_steppingForStartup = true;
        }
        
        m_showSource = true;

        ICorDebugController *pController = GetControllerInterface(pAD);
        Continue(pController, thread);
         
        if (pController!=NULL)
            RELEASE(pController);
    }
LExit:
    if (pFrame != NULL )
    {
        RELEASE( pFrame );
        pFrame = NULL;
    }

    if (pilFrame != NULL )
    {
        RELEASE( pilFrame );
        pilFrame = NULL;
    }

    if ( chain != NULL)
    {
        RELEASE( chain );
        chain = NULL;
    }
    
    return (fStepOver || fStepOutOf)?(TRUE):(FALSE);
}

enum printType
{
    PT_CREATED,
    PT_EXITED,
    PT_IN,
    PT_NONE
};

static void _printAppDomain(ICorDebugAppDomain *pAppDomain,
                            printType pt)
{
    ULONG32 id;

    HRESULT hr = pAppDomain->GetID(&id);
    _ASSERTE(SUCCEEDED(hr));
    
    WCHAR buff[256];
    ULONG32 s;
    WCHAR *defaultName = L"<Unknown appdomain>";
    WCHAR *name = defaultName;

    hr = pAppDomain->GetName(256, &s, buff);

    if (SUCCEEDED(hr))
        name = buff;

    if (pt == PT_IN)
        g_pShell->Write(L"\tin appdomain #%d, %s\n", id, name);
    else if (pt == PT_CREATED)
        g_pShell->Write(L"Appdomain #%d, %s -- Created\n", id, name);
    else if (pt == PT_EXITED)
        g_pShell->Write(L"Appdomain #%d, %s -- Exited\n", id, name);
    else
        g_pShell->Write(L"Appdomain #%d, %s\n", id, name);
}

static void _printAssembly(ICorDebugAssembly *pAssembly,
                           printType pt)
{
    WCHAR buff[256];
    ULONG32 s;
    WCHAR *defaultName = L"<Unknown assembly>";
    WCHAR *name = defaultName;

    HRESULT hr = pAssembly->GetName(256, &s, buff);

    if (SUCCEEDED(hr))
        name = buff;

    if (pt == PT_IN)
        g_pShell->Write(L"\tin assembly 0x%08x, %s\n", pAssembly, name);
    else if (pt == PT_CREATED)
        g_pShell->Write(L"Assembly 0x%08x, %s -- Loaded\n", pAssembly, name);
    else if (pt == PT_EXITED)
        g_pShell->Write(L"Assembly 0x%08x, %s -- Unloaded\n", pAssembly, name);
    else
        g_pShell->Write(L"Assembly 0x%08x, %s\n", pAssembly, name);
}

static void _printModule(ICorDebugModule *pModule, printType pt)
{
    WCHAR buff[256];
    ULONG32 s;
    WCHAR *defaultName = L"<Unknown module>";
    WCHAR *name = defaultName;

    HRESULT hr = pModule->GetName(256, &s, buff);

    if (SUCCEEDED(hr))
        name = buff;

    BOOL isDynamic = FALSE;
    BOOL isInMemory = FALSE;

    hr = pModule->IsDynamic(&isDynamic);
    _ASSERTE(SUCCEEDED(hr));

    hr = pModule->IsInMemory(&isInMemory);
    _ASSERTE(SUCCEEDED(hr));

    WCHAR *mt;

    if (isDynamic)
        mt = L"Dynamic Module";
    else if (isInMemory)
        mt = L"In-memory Module";
    else
        mt = L"Module";
    
    if (pt == PT_IN)
        g_pShell->Write(L"\tin %s 0x%08x, %s\n", mt, pModule, name);
    else if (pt == PT_CREATED)
        g_pShell->Write(L"%s 0x%08x, %s -- Loaded\n", mt, pModule, name);
    else if (pt == PT_EXITED)
        g_pShell->Write(L"%s 0x%08x, %s -- Unloaded\n", mt, pModule, name);
    else
    {
        ICorDebugAppDomain *pAD;
        ICorDebugAssembly *pAS;

        hr = pModule->GetAssembly(&pAS);
        _ASSERTE(SUCCEEDED(hr));

        hr = pAS->GetAppDomain(&pAD);
        _ASSERTE(SUCCEEDED(hr));

        ULONG32 adId;
        hr = pAD->GetID(&adId);
        _ASSERTE(SUCCEEDED(hr));
        
        g_pShell->Write(L"%s 0x%08x, %s -- AD #%d", mt, pModule, name, adId);

        DebuggerModule *m = DebuggerModule::FromCorDebug(pModule);
        _ASSERTE(m != NULL);
        
        if (m->GetSymbolReader() == NULL)
            g_pShell->Write(L" -- Symbols not loaded\n");
        else
            g_pShell->Write(L"\n");
    }
}

/*
 * CreateAppDomain is called when an app domain is created.
 */
HRESULT DebuggerCallback::CreateAppDomain(ICorDebugProcess *pProcess,
                                          ICorDebugAppDomain *pAppDomain)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::CreateAppDomain.\n", GetCurrentThreadId()));

    if (g_pShell->m_rgfActiveModes & DSM_SHOW_APP_DOMAIN_ASSEMBLY_LOADS)
        _printAppDomain(pAppDomain, PT_CREATED);

    // Attach to this app domain
    pAppDomain->Attach();
    g_pShell->Continue(pProcess, NULL);

    return S_OK;
}

/*
 * ExitAppDomain is called when an app domain exits.
 */
HRESULT DebuggerCallback::ExitAppDomain(ICorDebugProcess *pProcess,
                                        ICorDebugAppDomain *pAppDomain)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::ExitAppDomain.\n", GetCurrentThreadId()));

    if (g_pShell->m_rgfActiveModes & DSM_SHOW_APP_DOMAIN_ASSEMBLY_LOADS)
    {
        _printAppDomain(pAppDomain, PT_EXITED);
    }

    ICorDebugController *pController = GetControllerInterface(pAppDomain);

    g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    return S_OK;
}


/*
 * LoadAssembly is called when a CLR module is successfully
 * loaded. 
 */
HRESULT DebuggerCallback::LoadAssembly(ICorDebugAppDomain *pAppDomain,
                                       ICorDebugAssembly *pAssembly)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::LoadAssembly.\n", GetCurrentThreadId()));

    if (g_pShell->m_rgfActiveModes & DSM_SHOW_APP_DOMAIN_ASSEMBLY_LOADS)
    {
        _printAssembly(pAssembly, PT_CREATED);
        _printAppDomain(pAppDomain, PT_IN);
    }

    ICorDebugController *pController = GetControllerInterface(pAppDomain);

    g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    return S_OK;
}

/*
 * UnloadAssembly is called when a CLR module (DLL) is unloaded. The module 
 * should not be used after this point.
 */
HRESULT DebuggerCallback::UnloadAssembly(ICorDebugAppDomain *pAppDomain,
                                         ICorDebugAssembly *pAssembly)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::UnloadAssembly.\n", GetCurrentThreadId()));

    if (g_pShell->m_rgfActiveModes & DSM_SHOW_APP_DOMAIN_ASSEMBLY_LOADS)
    {
        _printAssembly(pAssembly, PT_EXITED);
    }

    ICorDebugController *pController = GetControllerInterface(pAppDomain);

    g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    return S_OK;
}


HRESULT DebuggerCallback::Breakpoint(ICorDebugAppDomain *pAppDomain,
                                     ICorDebugThread *pThread, 
                                     ICorDebugBreakpoint *pBreakpoint)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::Breakpoint.\n", GetCurrentThreadId()));

    ICorDebugProcess *pProcess;
    pAppDomain->GetProcess(&pProcess);

    DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

    while (bp && !bp->Match(pBreakpoint))
        bp = bp->m_next;

    if (bp)
    {
        g_pShell->PrintThreadPrefix(pThread);
        g_pShell->Write(L"break at ");
        g_pShell->PrintBreakpoint(bp);
    }
    else
    {
        g_pShell->Write(L"Unknown breakpoint hit.  Continuing may produce unexpected results.\n");
    }

    g_pShell->Stop(pProcess, pThread);

    return S_OK;
}

const WCHAR *StepTypeToString(CorDebugStepReason reason )
{
    switch (reason)
    {
        case STEP_NORMAL:
            return L"STEP_NORMAL";
            break;
        case STEP_RETURN:
            return L"STEP_RETURN";
            break;
        case STEP_CALL:
            return L"STEP_CALL";
            break;
        case STEP_EXCEPTION_FILTER:
            return L"STEP_EXCEPTION_FILTER";
            break;
        case STEP_EXCEPTION_HANDLER:
            return L"STEP_EXCEPTION_HANDLER";
            break;
        case STEP_INTERCEPT:
            return L"STEP_INTERCEPT";
            break;
        case STEP_EXIT:
            return L"STEP_EXIT";
            break;
        default:
            _ASSERTE( !"StepTypeToString given unknown step type!" );
            return NULL;
            break;
    }
}

HRESULT DebuggerCallback::StepComplete(ICorDebugAppDomain *pAppDomain,
                                       ICorDebugThread *pThread,
                                       ICorDebugStepper *pStepper,
                                       CorDebugStepReason reason)
{
    SPEW(fprintf(stderr, "[%d] DC::StepComplete with reason %d.\n",
                 GetCurrentThreadId(), reason));

    if (g_pShell->m_rgfActiveModes & DSM_ENHANCED_DIAGNOSTICS)
    {
        g_pShell->Write( L"Step complete:");
        g_pShell->Write( StepTypeToString(reason) );
        g_pShell->Write( L"\n" );
    }


    g_pShell->StepNotify(pThread, pStepper);

    RELEASE(pStepper);

    // We only want to skip compiler stubs until we hit non-stub
    // code
    if (!g_pShell->m_needToSkipCompilerStubs ||
        g_pShell->SkipCompilerStubs(pAppDomain, pThread))
    {
        g_pShell->m_needToSkipCompilerStubs = false;

        DWORD dwThreadId;
        HRESULT hr = pThread->GetID(&dwThreadId);
        _ASSERTE(!FAILED(hr));
        
        DebuggerManagedThread *dmt = (DebuggerManagedThread*)
            g_pShell->m_managedThreads.GetBase(dwThreadId);
        _ASSERTE(dmt != NULL);

        ICorDebugController *pController = GetControllerInterface(pAppDomain);

        // If we're were just stepping to get over a new thread's
        // prolog, but we no longer want to catch thread starts, then
        // don't stop...
        if (!(dmt->m_steppingForStartup && !g_pShell->m_catchThread))
            g_pShell->Stop(pController, pThread);
        else
            g_pShell->Continue(pController, pThread);
        
        if (pController != NULL)
            RELEASE(pController);
    }
    // else SkipCompilerStubs Continue()'d for us

    return S_OK;
}

HRESULT DebuggerCallback::Break(ICorDebugAppDomain *pAppDomain,
                                ICorDebugThread *pThread)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::Break.\n", GetCurrentThreadId()));

    g_pShell->PrintThreadPrefix(pThread);
    g_pShell->Write(L"user break\n");

    ICorDebugProcess *pProcess;
    pAppDomain->GetProcess(&pProcess);

    g_pShell->Stop(pProcess, pThread);

    return S_OK;
}

HRESULT DebuggerCallback::Exception(ICorDebugAppDomain *pAppDomain,
                                    ICorDebugThread *pThread,
                                    BOOL unhandled)
{
    g_pShell->m_enableCtrlBreak = false;
   ICorDebugController *pController = GetControllerInterface(pAppDomain);

    SPEW(fprintf(stderr, "[%d] DC::Exception.\n", GetCurrentThreadId()));

    if (!unhandled)
    {
        g_pShell->PrintThreadPrefix(pThread);
        g_pShell->Write(L"First chance exception generated: ");

        ICorDebugValue *ex;
        HRESULT hr = pThread->GetCurrentException(&ex);
        bool stop = g_pShell->m_catchException;

        if (SUCCEEDED(hr))
        {
            // If we have a valid current exception object, then stop based on its type.
            stop = g_pShell->ShouldHandleSpecificException(ex);
            
            // If we're stopping, dump the whole thing. Otherwise, just dump the class.
            if (stop)
                g_pShell->PrintVariable(NULL, ex, 0, TRUE);
            else
                g_pShell->PrintVariable(NULL, ex, 0, FALSE);
        }
        else
        {
            g_pShell->Write(L"Unexpected error occured: ");
            g_pShell->ReportError(hr);
        }

        g_pShell->Write(L"\n");

        if (stop)
            g_pShell->Stop(pController, pThread);
        else
            g_pShell->Continue(pController, pThread);
    }
    else if (unhandled && g_pShell->m_catchUnhandled)
    {
        g_pShell->PrintThreadPrefix(pThread);
        g_pShell->Write(L"Unhandled exception generated: ");

        ICorDebugValue *ex;
        HRESULT hr = pThread->GetCurrentException(&ex);
        if (SUCCEEDED(hr))
            g_pShell->PrintVariable(NULL, ex, 0, TRUE);
        else
        {
            g_pShell->Write(L"Unexpected error occured: ");
            g_pShell->ReportError(hr);
        }

        g_pShell->Write(L"\n");

        g_pShell->Stop(pController, pThread);
    }
    else
    {
        g_pShell->Continue(pController, pThread);
    }

    if (pController != NULL)
        RELEASE(pController);

    return S_OK;
}


HRESULT DebuggerCallback::EvalComplete(ICorDebugAppDomain *pAppDomain,
                                       ICorDebugThread *pThread,
                                       ICorDebugEval *pEval)
{
    g_pShell->m_enableCtrlBreak = false;
    ICorDebugProcess *pProcess;
    pAppDomain->GetProcess(&pProcess);

    g_pShell->PrintThreadPrefix(pThread);

    // Remember the most recently completed func eval for this thread.
    DebuggerManagedThread *dmt = g_pShell->GetManagedDebuggerThread(pThread);
    _ASSERTE(dmt != NULL);

    if (dmt->m_lastFuncEval)
        RELEASE(dmt->m_lastFuncEval);

    dmt->m_lastFuncEval = pEval;

    // Print any current func eval result.
    ICorDebugValue *pResult;
    HRESULT hr = pEval->GetResult(&pResult);

    if (hr == S_OK)
    {
        g_pShell->Write(L"Function evaluation complete.\n");
        g_pShell->PrintVariable(L"$result", pResult, 0, TRUE);
    }
    else if (hr == CORDBG_S_FUNC_EVAL_ABORTED)
        g_pShell->Write(L"Function evaluation aborted.\n");
    else if (hr == CORDBG_S_FUNC_EVAL_HAS_NO_RESULT)
        g_pShell->Write(L"Function evaluation complete, no result.\n");
    else
        g_pShell->ReportError(hr);

    g_pShell->m_pCurrentEval = NULL;
    
    g_pShell->Stop(pProcess, pThread);

    return S_OK;
}

HRESULT DebuggerCallback::EvalException(ICorDebugAppDomain *pAppDomain,
                                        ICorDebugThread *pThread,
                                        ICorDebugEval *pEval)
{
    g_pShell->m_enableCtrlBreak = false;
    ICorDebugProcess *pProcess;
    pAppDomain->GetProcess(&pProcess);

    g_pShell->PrintThreadPrefix(pThread);
    g_pShell->Write(L"Function evaluation completed with an exception.\n");

    // Remember the most recently completed func eval for this thread.
    DebuggerManagedThread *dmt = g_pShell->GetManagedDebuggerThread(pThread);
    _ASSERTE(dmt != NULL);

    if (dmt->m_lastFuncEval)
        RELEASE(dmt->m_lastFuncEval);

    dmt->m_lastFuncEval = pEval;

    // Print any current func eval result.
    ICorDebugValue *pResult;
    HRESULT hr = pEval->GetResult(&pResult);

    if (hr == S_OK)
        g_pShell->PrintVariable(L"$result", pResult, 0, TRUE);
    
    g_pShell->m_pCurrentEval = NULL;
    
    g_pShell->Stop(pProcess, pThread);

    return S_OK;
}


HRESULT DebuggerCallback::CreateThread(ICorDebugAppDomain *pAppDomain,
                                       ICorDebugThread *thread)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::CreateThread.\n", GetCurrentThreadId()));

    DWORD threadID;
    HRESULT hr = thread->GetID(&threadID);
    if (FAILED(hr))
    {
        g_pShell->Write(L"Unexpected error in CreateThread callback:");
        g_pShell->ReportError(hr);
        goto LExit;
    }

    g_pShell->PrintThreadPrefix(thread, true);
    g_pShell->Write(L"Thread created.\n");

    SPEW(fprintf(stderr, "[%d] DC::CT: Thread id is %d\n",
                 GetCurrentThreadId(), threadID));

    hr = g_pShell->AddManagedThread( thread, threadID );
    if (FAILED(hr))
        goto LExit;

    SPEW(g_pShell->Write( L"interc? m_rgfActiveModes:0x%x\n",g_pShell->m_rgfActiveModes));
    
    if ((!g_pShell->m_gotFirstThread) || (g_pShell->m_catchThread))
    {
        // Try to skip compiler stubs. 
        // SkipCompilerStubs returns TRUE if we're NOT in a stub
        if (g_pShell->SkipCompilerStubs(pAppDomain, thread))
        {
            // If we do want to skip the prolog (or an interceptor),
            // then we don't want to skip a stub, and we're finished, so go
            // to the clean-up code immediately
            if (g_pShell->SkipProlog(pAppDomain,
                                     thread,
                                     g_pShell->m_gotFirstThread))
                goto LExit;

            // If we don't need to skip a
            // compiler stub on entry to the first thread, or an
            // interceptor, etc, then we never
            // will, so set the flag appropriately.
            g_pShell->m_needToSkipCompilerStubs = false;
            

            // Recheck why we're here... we may have spent a long time
            // in SkipProlog.
            if ((!g_pShell->m_gotFirstThread) || (g_pShell->m_catchThread))
            {
                ICorDebugController *pController =
                    GetControllerInterface(pAppDomain);

                g_pShell->Stop(pController, thread);

                if (pController != NULL)
                    RELEASE(pController);
            }
        }
    }
    else
    {
        ICorDebugController *controller = NULL;
        controller = GetControllerInterface(pAppDomain);

        g_pShell->Continue(controller, thread);
        
        if (controller != NULL)
            RELEASE(controller);
    }
    
LExit:
    g_pShell->m_gotFirstThread = true;

    return hr;
}


HRESULT DebuggerCallback::ExitThread(ICorDebugAppDomain *pAppDomain,
                                     ICorDebugThread *thread)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::ExitThread.\n", GetCurrentThreadId()));

    g_pShell->PrintThreadPrefix(thread, true);
    g_pShell->Write(L"Thread exited.\n");

    ICorDebugController *pController = GetControllerInterface(pAppDomain);
    g_pShell->Continue(pController, thread);

    if (pController != NULL)
        RELEASE(pController);

    SPEW(fprintf(stderr, "[%d] DC::ET: returning.\n", GetCurrentThreadId()));

    DWORD dwThreadId =0;
    HRESULT hr = thread->GetID( &dwThreadId );
    if (FAILED(hr) )
        return hr;

    DebuggerManagedThread *dmt = g_pShell->GetManagedDebuggerThread(thread);
    if (dmt != NULL)
    {
        g_pShell->RemoveManagedThread( dwThreadId );
    }

    return S_OK;
}

HRESULT DebuggerCallback::LoadModule( ICorDebugAppDomain *pAppDomain,
                                      ICorDebugModule *pModule)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::LoadModule.\n", GetCurrentThreadId()));

    HRESULT hr;

    DebuggerModule *m = new DebuggerModule(pModule);

    if (m == NULL)
    {
        g_pShell->ReportError(E_OUTOFMEMORY);
        return (E_OUTOFMEMORY);
    }

    hr = m->Init(g_pShell->m_currentSourcesPath);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return hr;
    }

    hr = g_pShell->m_modules.AddBase(m);
    _ASSERTE(SUCCEEDED(hr));

    WCHAR moduleName[256];
    ULONG32 s;
    
    moduleName[0] = L'\0';
    hr = pModule->GetName(256, &s, moduleName);
    m->SetName (moduleName);

    DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

    while (bp != NULL)
    {
        // If (the user specified a module for this bp, and this is the module OR
        //     the user HASN't specified a module for this bp), and
        // the module has a type/method that matches the bp's, then bind
        // the breakpoint here.
        if ((bp->m_moduleName == NULL ||
            _wcsicmp(bp->m_moduleName, moduleName) == 0) &&
            bp->Bind(m, NULL))
        {            
            g_pShell->OnBindBreakpoint(bp, m);
        }        

        bp = bp->m_next;
    }

    if ((g_pShell->m_rgfActiveModes & DSM_SHOW_MODULE_LOADS) ||
        (g_pShell->m_catchModule))
    {
        _printModule(pModule, PT_CREATED);

        ICorDebugAssembly *pAssembly;
        hr = pModule->GetAssembly(&pAssembly);
        _ASSERTE(SUCCEEDED(hr));
        
        _printAssembly(pAssembly, PT_IN);
        _printAppDomain(pAppDomain, PT_IN);
    }

    hr = pModule->EnableClassLoadCallbacks(TRUE);

    if (FAILED(hr))
        g_pShell->Write(L"Failed to enable class load callbacks for %s\n",
                        moduleName);

    if (g_pShell->m_rgfActiveModes & DSM_ENABLE_JIT_OPTIMIZATIONS)
    {
        hr = pModule->EnableJITDebugging(TRUE, TRUE);

        if (FAILED(hr))
            g_pShell->Write(L"Failed to enable JIT Optimizations for %s\n",
                            moduleName);
    }
    
    ICorDebugController *pController = GetControllerInterface(pAppDomain);
    
    if (g_pShell->m_catchModule)
        g_pShell->Stop(pController, NULL);
    else
        g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    SPEW(fprintf(stderr, "[%d] DC::LM: continued.\n", GetCurrentThreadId()));

    return S_OK;
}


HRESULT DebuggerCallback::UnloadModule( ICorDebugAppDomain *pAppDomain,
                      ICorDebugModule *pModule)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::UnloadModule.\n", GetCurrentThreadId()));

    DebuggerModule *m = DebuggerModule::FromCorDebug(pModule);
    _ASSERTE(m != NULL);

    DebuggerBreakpoint *bp = g_pShell->m_breakpoints;
    while (bp != NULL)
    {
        // Detach the breakpoint, which means it is an active bp
        // but doesn't have a CLR object behind it.
        if (bp->m_managed && bp->IsBoundToModule(m))
                bp->DetachFromModule(m);
        bp = bp->m_next;
    }

    g_pShell->m_modules.RemoveBase((ULONG)pModule);

    if ((g_pShell->m_rgfActiveModes & DSM_SHOW_MODULE_LOADS) || 
        (g_pShell->m_catchModule))
    {
        _printModule(pModule, PT_EXITED);

        ICorDebugAssembly *pAssembly;
        HRESULT hr = pModule->GetAssembly(&pAssembly);
        _ASSERTE(SUCCEEDED(hr));
        
        _printAssembly(pAssembly, PT_IN);
        _printAppDomain(pAppDomain, PT_IN);
    }
    
    ICorDebugController *pController = GetControllerInterface(pAppDomain);
    
    if (g_pShell->m_catchModule)
        g_pShell->Stop(pController, NULL);
    else
        g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    SPEW(fprintf(stderr, "[%d] DC::UM: continued.\n", GetCurrentThreadId()));

    return S_OK;
}


HRESULT DebuggerCallback::LoadClass( ICorDebugAppDomain *pAppDomain,
                   ICorDebugClass *c)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::LoadClass.\n", GetCurrentThreadId()));

    DebuggerModule *dm = NULL;
    DebuggerClass *cl = new DebuggerClass(c);

    if (cl == NULL)
    {
        g_pShell->ReportError(E_OUTOFMEMORY);
        return (E_OUTOFMEMORY);
    }

    HRESULT hr = S_OK;

    mdTypeDef td;
    hr = c->GetToken(&td);

    if (SUCCEEDED(hr))
    {
        ICorDebugModule *imodule;
        hr = c->GetModule(&imodule);

        if (SUCCEEDED(hr))
        {
            dm = DebuggerModule::FromCorDebug(imodule);
            _ASSERTE(dm != NULL);

            hr = dm->m_loadedClasses.AddBase(cl);
            _ASSERTE(SUCCEEDED(hr));
            
            WCHAR className[MAX_CLASSNAME_LENGTH];
            ULONG classNameSize = 0;

            hr = dm->GetMetaData()->GetTypeDefProps(td,
                                                    className, MAX_CLASSNAME_LENGTH,
                                                    &classNameSize,
                                                    NULL, NULL);

            if (SUCCEEDED(hr))
            {
                WCHAR *namespacename;
                WCHAR *name;

                namespacename = className;
                name = wcsrchr(className, L'.');
                if (name)
                    *name++ = 0;
                else
                {
                    namespacename = L"";
                    name = className;
                }

                cl->SetName (name, namespacename);

                if ((g_pShell->m_rgfActiveModes & DSM_SHOW_CLASS_LOADS) ||
                    g_pShell->m_catchClass)
                {
                    if (namespacename != NULL && *namespacename != NULL)
                        g_pShell->Write(L"Loaded class: %s.%s\n", namespacename, name);
                    else
                        g_pShell->Write(L"Loaded class: %s\n", name);       
                }
            }
            else
                g_pShell->ReportError(hr);

            RELEASE(imodule);
        }
        else
            g_pShell->ReportError(hr);
    }
    else
        g_pShell->ReportError(hr);

    _ASSERTE( dm );

    // If this module is dynamic, then bind all breakpoints, as
    // they may have been bound to this class.
    ICorDebugModule *pMod = dm->GetICorDebugModule();
    _ASSERTE( pMod != NULL );

    BOOL fDynamic = false;
    hr = pMod->IsDynamic(&fDynamic);
    if (FAILED(hr))
    {
        g_pShell->Write( L"Unable to determine if loaded module is dynamic");
        g_pShell->Write( L"- not attempting\n to bind any breakpoints");
    }
    else
    {
        if (fDynamic)
        {
            DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

            while (bp != NULL)
            {
                if (bp->Bind(dm, NULL))
                    g_pShell->OnBindBreakpoint(bp, dm);

                bp = bp->m_next;
            }
        }
    }

    ICorDebugController *pController = GetControllerInterface(pAppDomain);
    
    if (g_pShell->m_catchClass)
        g_pShell->Stop(pController, NULL);
    else
        g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    SPEW(fprintf(stderr, "[%d] DC::LC: continued.\n", GetCurrentThreadId()));

    return S_OK;
}


HRESULT DebuggerCallback::UnloadClass( ICorDebugAppDomain *pAppDomain,
                     ICorDebugClass *c)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::UnloadClass.\n", GetCurrentThreadId()));

    HRESULT hr = S_OK;
    mdTypeDef td;
    hr = c->GetToken(&td);

    if (SUCCEEDED(hr))
    {
        ICorDebugModule *imodule;
        hr = c->GetModule(&imodule);

        if (SUCCEEDED(hr))
        {
            DebuggerModule *dm = DebuggerModule::FromCorDebug(imodule);
            _ASSERTE(dm != NULL);

            if ((g_pShell->m_rgfActiveModes & DSM_SHOW_CLASS_LOADS) ||
                g_pShell->m_catchClass)
            {


                WCHAR className[MAX_CLASSNAME_LENGTH];
                ULONG classNameSize = 0;
            
                hr = dm->GetMetaData()->GetTypeDefProps(td,
                                                        className, MAX_CLASSNAME_LENGTH,
                                                        &classNameSize,
                                                        NULL, NULL);

                if (SUCCEEDED(hr))
                    g_pShell->Write(L"Unloaded class: %s\n", className);
                else
                    g_pShell->ReportError(hr);
            }

            hr = dm->m_loadedClasses.RemoveBase((ULONG)c);
            _ASSERTE(SUCCEEDED(hr));

            RELEASE(imodule);
        }
        else
            g_pShell->ReportError(hr);
    }
    else
        g_pShell->ReportError(hr);

    ICorDebugController *pController = GetControllerInterface(pAppDomain);
    
    if (g_pShell->m_catchClass)
        g_pShell->Stop(pController, NULL);
    else
        g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    SPEW(fprintf(stderr, "[%d] DC::LC: continued.\n", GetCurrentThreadId()));

    return S_OK;
}



HRESULT DebuggerCallback::DebuggerError(ICorDebugProcess *pProcess,
                                        HRESULT errorHR,
                                        DWORD errorCode)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::DebuggerError 0x%p (%d).\n",
                 GetCurrentThreadId(), errorHR, errorCode));

    g_pShell->Write(L"The debugger has encountered a fatal error.\n");
    g_pShell->ReportError(errorHR);

    return (S_OK);
}


HRESULT DebuggerCallback::LogMessage(ICorDebugAppDomain *pAppDomain,
                  ICorDebugThread *pThread,
                  LONG lLevel,
                  WCHAR *pLogSwitchName,
                  WCHAR *pMessage)
{
    g_pShell->m_enableCtrlBreak = false;
    DWORD dwThreadId = 0;

    pThread->GetID(&dwThreadId);

    if(g_pShell->m_rgfActiveModes & DSM_LOGGING_MESSAGES)
    {
        g_pShell->Write (L"LOG_MESSAGE: TID=0x%x Category:Severity=%s:%d Message=\n%s\n",
            dwThreadId, pLogSwitchName, lLevel, pMessage);
    }
    else
    {
        // If we don't want to get messages, then tell the other side to stop
        // sending them....
        ICorDebugProcess *process = NULL;
        HRESULT hr = S_OK;
        hr = pAppDomain->GetProcess(&process);
        if (!FAILED(hr))
        {
            process->EnableLogMessages(FALSE);
            RELEASE(process);
        }
    }
    ICorDebugController *pController = GetControllerInterface(pAppDomain);
    g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    return S_OK;
}


HRESULT DebuggerCallback::LogSwitch(ICorDebugAppDomain *pAppDomain,
                  ICorDebugThread *pThread,
                  LONG lLevel,
                  ULONG ulReason,
                  WCHAR *pLogSwitchName,
                  WCHAR *pParentName)
{
    g_pShell->m_enableCtrlBreak = false;
    ICorDebugController *pController = GetControllerInterface(pAppDomain);
    g_pShell->Continue(pController, NULL);

    if (pController != NULL)
        RELEASE(pController);

    return S_OK;
}

HRESULT DebuggerCallback::ControlCTrap(ICorDebugProcess *pProcess)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::ControlC.\n", GetCurrentThreadId()));

    g_pShell->Write(L"ControlC Trap\n");

    g_pShell->Stop(pProcess, NULL);

    return S_OK;
}

HRESULT DebuggerCallback::NameChange(ICorDebugAppDomain *pAppDomain, 
                                     ICorDebugThread *pThread)
{
    g_pShell->m_enableCtrlBreak = false;
    ICorDebugProcess *pProcess = NULL;

    if (pAppDomain)
        pAppDomain->GetProcess(&pProcess);
    else
    {
        _ASSERTE (pThread != NULL);
        pThread->GetProcess(&pProcess);
    }

    g_pShell->Continue(pProcess, NULL);

    RELEASE(pProcess);
    return S_OK;
}


HRESULT DebuggerCallback::UpdateModuleSymbols(ICorDebugAppDomain *pAppDomain,
                                              ICorDebugModule *pModule,
                                              IStream *pSymbolStream)
{
    g_pShell->m_enableCtrlBreak = false;
    ICorDebugProcess *pProcess;
    pAppDomain->GetProcess(&pProcess);

    HRESULT hr;

    DebuggerModule *m = DebuggerModule::FromCorDebug(pModule);
    _ASSERTE(m != NULL);

    hr = m->UpdateSymbols(pSymbolStream);

    if (SUCCEEDED(hr))
        g_pShell->Write(L"Updated symbols: ");
    else
        g_pShell->Write(L"Update of symbols failed with 0x%08x: \n", hr);
    
    _printModule(m->GetICorDebugModule(), PT_NONE);
    
    g_pShell->Continue(pProcess, NULL);

    return S_OK;
}

HRESULT DebuggerCallback::EditAndContinueRemap(ICorDebugAppDomain *pAppDomain,
                                               ICorDebugThread *pThread, 
                                               ICorDebugFunction *pFunction,
                                               BOOL fAccurate)
{
    HRESULT hr = S_OK;

    // If we were given a function, then tell the user about the remap.
    if (pFunction != NULL)
    {
        mdMethodDef methodDef;
        hr = pFunction->GetToken(&methodDef);

        g_pShell->Write(L"EnC Remapped method 0x%x, fAccurate:0x%x\n", 
                        methodDef, fAccurate);

    }
    else
        g_pShell->Write(L"EnC remap, but no method specified.\n");

    if (fAccurate)
        g_pShell->Continue(pAppDomain, NULL);
    else
        g_pShell->Stop(pAppDomain, pThread);
    
    return S_OK;
}

HRESULT DebuggerCallback::BreakpointSetError(ICorDebugAppDomain *pAppDomain,
                                             ICorDebugThread *pThread, 
                                             ICorDebugBreakpoint *pBreakpoint,
                                             DWORD dwError)
{
    g_pShell->m_enableCtrlBreak = false;
    SPEW(fprintf(stderr, "[%d] DC::BreakpointSetError.\n", GetCurrentThreadId()));

    ICorDebugProcess *pProcess;
    pAppDomain->GetProcess(&pProcess);

    DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

    while (bp && !bp->Match(pBreakpoint))
        bp = bp->m_next;

    if (bp)
    {
        g_pShell->Write(L"Error binding this breakpoint (it will not be hit): ");
        g_pShell->PrintBreakpoint(bp);
    }
    else
    {
        g_pShell->Write(L"Unknown breakpoint had a binding error.\n");
    }

    g_pShell->Continue(pAppDomain, NULL);

    return S_OK;
}



HRESULT DebuggerUnmanagedCallback::DebugEvent(LPDEBUG_EVENT event,
                                              BOOL fIsOutOfBand)
{
    SPEW(fprintf(stderr, "[%d] DUC::DebugEvent.\n", GetCurrentThreadId()));

    // Find the process this event is for.
    ICorDebugProcess *pProcess;
    HRESULT hr = g_pShell->m_cor->GetProcess(event->dwProcessId, &pProcess);

    if (FAILED(hr) || pProcess == NULL)
    {
        g_pShell->ReportError(hr);
        return hr;
    }

    // Snagg the handle for this process.
    HPROCESS hProcess;
    hr = pProcess->GetHandle(&hProcess);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        RELEASE(pProcess);
        return hr;
    }

    // Find the thread this event is for.
    ICorDebugThread *pThread;
    hr = pProcess->GetThread(event->dwThreadId, &pThread);

    if (FAILED(hr))
        pThread = NULL;

    //
    // Find the unmanaged thread this event is for.
    //

    DebuggerUnmanagedThread *ut = (DebuggerUnmanagedThread*) 
      g_pShell->m_unmanagedThreads.GetBase(event->dwThreadId);
            
    // We need to skip the first exception we get and simply clear it
    // since its the entrypoint excetpion.

    bool stopNow = false;

    switch (event->dwDebugEventCode)
    {
    case CREATE_PROCESS_DEBUG_EVENT:
        {
            g_pShell->m_unmanagedDebuggingEnabled = true;
            
            g_pShell->Write(L"Create Process, Thread=0x%x\n",
                            event->dwThreadId);

            g_pShell->HandleUnmanagedThreadCreate(
                                       event->dwThreadId,
                                       event->u.CreateProcessInfo.hThread);
            
            BOOL succ = SymInitialize(hProcess, NULL, FALSE);

            if (succ)
            {
                g_pShell->LoadUnmanagedSymbols(
                                     hProcess,
                                     event->u.CreateProcessInfo.hFile,
                              (DWORD)event->u.CreateProcessInfo.lpBaseOfImage);
            }
            else
                g_pShell->Write(L"Error initializing symbol loader.\n");
        }

        break;

    case EXIT_PROCESS_DEBUG_EVENT:
        {
            g_pShell->Write(L"Exit Process, Thread=0x%x\n",
                            event->dwThreadId);

            DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

            while (bp != NULL)
            {
                if (!bp->m_managed && bp->m_process == pProcess)
                {
                    // Set the process to 0 to prevent the call to
                    // UnapplyUnmanagedPatch, which will fail because
                    // most of the process memory is unmapped now.
                    bp->m_process = 0;
                    
                    bp->Detach();
                }

                bp = bp->m_next;
            }

            g_pShell->m_unmanagedThreads.RemoveBase(event->dwThreadId);
            SymCleanup(hProcess);

            g_pShell->m_unmanagedDebuggingEnabled = false;
        }
    
        break;

    case CREATE_THREAD_DEBUG_EVENT:
        g_pShell->Write(L"Create Thread, Id=0x%x\n", event->dwThreadId);

        g_pShell->HandleUnmanagedThreadCreate(event->dwThreadId,
                                              event->u.CreateThread.hThread);
        break;

    case EXIT_THREAD_DEBUG_EVENT:
        g_pShell->Write(L"Exit Thread, Id=0x%x\n", event->dwThreadId);

        // Copy the whole event...
        g_pShell->m_lastUnmanagedEvent = *event;
        g_pShell->m_handleUnmanagedEvent = true;
        stopNow = true;
        break;

    case EXCEPTION_DEBUG_EVENT:
        if (g_pShell->m_rgfActiveModes & DSM_SHOW_UNMANAGED_TRACE)
            g_pShell->Write(L"Exception, Thread=0x%x, Code=0x%08x, "
                            L"Addr=0x%08x, Chance=%d, OOB=%d\n",
                            event->dwThreadId,
                            event->u.Exception.ExceptionRecord.ExceptionCode,
                            event->u.Exception.ExceptionRecord.ExceptionAddress,
                            event->u.Exception.dwFirstChance,
                            fIsOutOfBand);

        if (event->u.Exception.ExceptionRecord.ExceptionCode == STATUS_SINGLE_STEP)
        {
            bool clear = false;
            
            // Reenable any breakpoints we were skipping over in this
            // thread. (We turn on tracing to get over unmanaged
            // breakpoints, so this might be the only reason we were
            // stepping.)
            DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

            while (bp != NULL)
            {
                DebuggerBreakpoint *nbp = bp->m_next;
                
                if (!bp->m_managed 
                    && bp->m_process == pProcess
                    && bp->m_skipThread == event->dwThreadId)
                {
                    clear = true;
                    bp->m_skipThread = 0;

                    if (bp->m_deleteLater)
                        delete bp;
                    else
                        bp->Attach();
                }

                bp = nbp;
            }
            
            // Handle any unmanaged single stepping that we were doing
            if (ut != NULL && ut->m_stepping)
            {
                clear = true;
                
                // In order to properly handle a single step, we need
                // to see if we're on a transition stub now. To do
                // that, we have to communicate with the inprocess
                // portion of the debugging services, and we can't do
                // that from inside of the unmanaged callback. So we
                // copy the event to the DebuggerShell and go ahead
                // and tell the shell to stop. The shell will pickup
                // the event and finish processing it.

                // Copy the whole event...
                g_pShell->m_lastUnmanagedEvent = *event;
                g_pShell->m_handleUnmanagedEvent = true;
                stopNow = true;
            }

            // Clear single step exceptions if we're the reason we
            // were stepping the thread.
            //
            // Note: don't clear the exception if this is an out-of-band
            // exception, since this is automatically done for us by the CLR.
            if (clear && !fIsOutOfBand)
            {
                hr = pProcess->ClearCurrentException(event->dwThreadId);
                if (FAILED(hr))
                    g_pShell->ReportError(hr);
            }
        }
        else if (event->u.Exception.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT)
        {
            bool clear = false;
            
            DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

            while (bp != NULL)
            {
                if (!bp->m_managed && bp->MatchUnmanaged(PTR_TO_CORDB_ADDRESS(event->u.Exception.ExceptionRecord.ExceptionAddress)))
                {
                    g_pShell->Write(L"[thread 0x%x] unmanaged break at ", event->dwThreadId);
                    g_pShell->PrintBreakpoint(bp);

                    g_pShell->m_showSource = false;

                    clear = true;

                    bp->Detach();
                    bp->m_skipThread = event->dwThreadId;
                }

                bp = bp->m_next;
            }

            if (clear)
            {
                // Note: don't clear the exception if this is an out-of-band
                // exception, since this is automatically done for us by the CLR.
                // We also don't backup Eip or turn on the trace flag,
                // since the CLR does this too.
                if (!fIsOutOfBand)
                {
                    //
                    // Stop here
                    //

                    stopNow = true;

                    //
                    // Enable single stepping on this thread so 
                    // we can restore the breakpoint later
                    //

                    CONTEXT context;
                    context.ContextFlags = CONTEXT_FULL;
                    hr = pProcess->GetThreadContext(event->dwThreadId,
                                                    sizeof(context), (BYTE*)&context);
                    if (FAILED(hr))
                        g_pShell->ReportError(hr);

#ifdef _X86_
                    // Enable single step
                    context.EFlags |= 0x100;

                    // Backup Eip to point to the instruction we need to execute. Continuing from a breakpoint exception
                    // continues execution at the instruction after the breakpoint, but we need to continue where the
                    // breakpoint was.
                    context.Eip -= 1;
                
#else // !_X86_
                    _ASSERTE(!"@TODO Alpha - DebugEvent (dShell.cpp)");
#endif // _X86_

                    hr = pProcess->SetThreadContext(event->dwThreadId,
                                                    sizeof(context), (BYTE*)&context);
                    if (FAILED(hr))
                        g_pShell->ReportError(hr);

                    //
                    // Clear the exception
                    //

                    hr = pProcess->ClearCurrentException(event->dwThreadId);
                    if (FAILED(hr))
                        g_pShell->ReportError(hr);
                }
            }
            else
            {
                if (!fIsOutOfBand)
                {
                    // User breakpoint in unmanaged code...
                    stopNow = true;
                
                    if (pThread)
                    {
                        g_pShell->PrintThreadPrefix(pThread);
                        g_pShell->Write(L"Unmanaged user breakpoint reached.\n");
                    }
                    else
                        g_pShell->Write(L"Unmanaged user breakpoint reached on "
                                        L"thread id 0x%x (%d)\n",
                                        event->dwThreadId,
                                        event->dwThreadId);

                    hr = pProcess->ClearCurrentException(event->dwThreadId);
                    if (FAILED(hr))
                        g_pShell->ReportError(hr);
                }
            }
        }
        else
        {
            stopNow = true;

            g_pShell->Write(L"Exception, Thread=0x%x, Code=0x%08x, "
                            L"Addr=0x%08x, Chance=%d\n",
                            event->dwThreadId,
                            event->u.Exception.ExceptionRecord.ExceptionCode,
                            event->u.Exception.ExceptionRecord.ExceptionAddress,
                            event->u.Exception.dwFirstChance);

            CONTEXT context;
            context.ContextFlags = CONTEXT_FULL;
            hr = pProcess->GetThreadContext(event->dwThreadId, sizeof(context), (BYTE*)&context);

            if (FAILED(hr))
                g_pShell->ReportError(hr);

#ifdef _X86_
            // Disable single step
            if (context.EFlags & 0x100)
            {
                if (g_pShell->m_rgfActiveModes & DSM_SHOW_UNMANAGED_TRACE)
                    g_pShell->Write(L"Removing the trace flag due to exception, EFlags=0x%08x\n", context.EFlags);

                context.EFlags &= ~0x100;
#else // !_X86_
                _ASSERTE(!"@TODO Alpha - DebugEvent (dShell.cpp)");
#endif // _X86_

                hr = pProcess->SetThreadContext(event->dwThreadId, sizeof(context), (BYTE*)&context);

                if (FAILED(hr))
                    g_pShell->ReportError(hr);
            }
        }

        break;

    case LOAD_DLL_DEBUG_EVENT:
        g_pShell->LoadUnmanagedSymbols(hProcess,
                                       event->u.LoadDll.hFile,
                                       (DWORD)event->u.LoadDll.lpBaseOfDll);

        {
            DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

            while (bp != NULL)
            {
                bp->BindUnmanaged(pProcess,
                                  (DWORD)event->u.LoadDll.lpBaseOfDll);
                bp = bp->m_next;
            }
        }

        break;

    case UNLOAD_DLL_DEBUG_EVENT:
        {
            g_pShell->Write(L"Unload DLL, base=0x%08x\n",
                            event->u.UnloadDll.lpBaseOfDll);

            DebuggerBreakpoint *bp = g_pShell->m_breakpoints;
            while (bp != NULL)
            {
                // Detatch the breakpoint, which means it is an active bp
                // but doesn't have a CLR object behind it.
                if (!bp->m_managed &&
                    (bp->m_unmanagedModuleBase ==
                     PTR_TO_CORDB_ADDRESS(event->u.UnloadDll.lpBaseOfDll)))
                    bp->Detach();

                bp = bp->m_next;
            }

            SymUnloadModule(hProcess, (DWORD)event->u.UnloadDll.lpBaseOfDll);
        }
        break;

    case OUTPUT_DEBUG_STRING_EVENT:
        if (g_pShell->m_rgfActiveModes & DSM_SHOW_UNMANAGED_TRACE)
            g_pShell->Write(L"Output Debug String, Thread=0x%x\n",
                            event->dwThreadId);

        // Read the string.
        if (event->u.DebugString.nDebugStringLength > 0)
        {
            BYTE *stringBuf =
                new BYTE[event->u.DebugString.nDebugStringLength + sizeof(WCHAR)];

            if (stringBuf)
            {
                SIZE_T read = 0;
                hr = pProcess->ReadMemory(
                 PTR_TO_CORDB_ADDRESS(event->u.DebugString.lpDebugStringData),
                                      event->u.DebugString.nDebugStringLength,
                                      stringBuf, &read );

                if ((read > 0) &&
                    (read <= event->u.DebugString.nDebugStringLength))
                {
                    if (event->u.DebugString.fUnicode)
                    {
                        ((WCHAR*)stringBuf)[read / 2] = L'\0';
                    
                        g_pShell->Write(L"Thread 0x%x: %s",
                                        event->dwThreadId, stringBuf);
                    }
                    else
                    {
                        stringBuf[read] = '\0';
                    
                        g_pShell->Write(L"Thread 0x%x: %S",
                                        event->dwThreadId, stringBuf);
                    }
                }
                else
                    g_pShell->Write(L"Unable to read memory for "
                                    L"OutputDebugString on thread 0x%x: "
                                    L"addr=0x%08x, len=%d, read=%d, "
                                    L"hr=0x%08x\n",
                                    event->dwThreadId,
                                    event->u.DebugString.lpDebugStringData,
                                    event->u.DebugString.nDebugStringLength,
                                    read,
                                    hr);
            
                delete [] stringBuf;
            }
        }
        
        // Must clear output debug strings for some reason.
        hr = pProcess->ClearCurrentException(event->dwThreadId);
        _ASSERTE(SUCCEEDED(hr));
        break;

    case RIP_EVENT:
        g_pShell->Write(L"RIP, Thread=0x%x\n", event->dwThreadId);
        break;

    default:
        if (g_pShell->m_rgfActiveModes & DSM_SHOW_UNMANAGED_TRACE)
            g_pShell->Write(L"Unknown event %d, Thread=0x%x\n",
                            event->dwDebugEventCode,
                            event->dwThreadId);
        break;
    }

    ICorDebugController *pController = NULL;
    
    hr = pProcess->QueryInterface(IID_ICorDebugController,
                                  (void**)&pController);
    if (FAILED(hr))
        goto LError;

    if (stopNow && fIsOutOfBand)
    {
        stopNow = false;

        if (g_pShell->m_rgfActiveModes & DSM_SHOW_UNMANAGED_TRACE)
            g_pShell->Write(L"Auto-continue because event is out-of-band.\n");
    }
    
    if (stopNow)
    {
        _ASSERTE(fIsOutOfBand == FALSE);
        g_pShell->Stop(pController, pThread, ut);
    }
    else
        g_pShell->Continue(pController, pThread, ut, fIsOutOfBand);

LError:
    RELEASE(pProcess);
    
    if (pController != NULL)
        RELEASE(pController);

    if (pThread != NULL)
        RELEASE(pThread);
    
    return (S_OK);
}

bool DebuggerShell::HandleUnmanagedEvent(void)
{
    // Mark that we've handled the unmanaged event.
    g_pShell->m_handleUnmanagedEvent = false;
    
    DEBUG_EVENT *event = &m_lastUnmanagedEvent;
    
    // Find the process this event is for.
    ICorDebugProcess *pProcess;
    HRESULT hr = m_cor->GetProcess(event->dwProcessId, &pProcess);

    if (FAILED(hr))
    {
        ReportError(hr);
        return false;
    }

    // Find the thread this event is for, if any.
    ICorDebugThread *pThread;
    hr = pProcess->GetThread(event->dwThreadId, &pThread);

    if (FAILED(hr))
        pThread = NULL;

    // Find the unmanaged thread this event is for.
    DebuggerUnmanagedThread *ut = (DebuggerUnmanagedThread*) 
        m_unmanagedThreads.GetBase(event->dwThreadId);

    // Finish up stepping work...
    if (event->dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
    {
        if (event->u.Exception.ExceptionRecord.ExceptionCode ==
            STATUS_SINGLE_STEP)
        {
            _ASSERTE(ut != NULL);
            _ASSERTE(ut->m_stepping);
            
            ut->m_stepping = FALSE;

            // See if we're still in unmanaged code.
            BOOL managed = FALSE;

            CONTEXT context;
            context.ContextFlags = CONTEXT_FULL;
            hr = pProcess->GetThreadContext(ut->GetId(), 
                                            sizeof(context), (BYTE*)&context);
            if (FAILED(hr))
            {
                Write(L"Cannot get thread context.\n");
                ReportError(hr);
                return false;
            }

#ifdef _X86_
#if 0
            if (ut->m_unmanagedStackEnd != NULL
                && context.Esp > ut->m_unmanagedStackEnd)
            {
                // If we've stepped out of the unmanaged stack range,
                // we're returning to managed code.
                managed = TRUE;
            }
            else
#endif
            {
                // If this is a managed stub, we're calling managed
                // code.
                BOOL stub;
                hr = pProcess->IsTransitionStub(context.Eip, &stub);

                if (FAILED(hr))
                {
                    Write(L"Cannot tell if it's a stub\n");
                    ReportError(hr);
                    return false;
                }
                else if (stub)
                {
                    managed = TRUE;
                }
            }
#else // !_X86_
            _ASSERTE(!"@TODO Alpha - HandleUnmanagedEvent (dShell.cpp)");
#endif // _X86_
                
            if (managed)
            {
                // Create a managed stepper & let it go.
                ICorDebugStepper *pStepper;

                _ASSERTE(pThread != NULL);
                hr = pThread->CreateStepper(&pStepper);
                if (FAILED(hr))
                {
                    ReportError(hr);
                    return false;
                }

                hr = pStepper->Step(TRUE);
                if (FAILED(hr))
                {
                    RELEASE(pStepper);
                    ReportError(hr);
                    return false;
                }

                StepStart(pThread, pStepper);
                m_showSource = true;

                // Return that we should continue the process without
                // notifying the user.
                return true;
            }
            else
            {
                // Stop here.
                StepNotify(pThread, NULL);
                return false;
            }
        }
    }
    else if (event->dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT)
    {
        m_currentUnmanagedThread = NULL;
        g_pShell->m_unmanagedThreads.RemoveBase(event->dwThreadId);
        m_stop = false;
        return true;
    }
    
    return false;
}

/* ------------------------------------------------------------------------- *
 * DebuggerShell methods
 * ------------------------------------------------------------------------- */

DebuggerShell::DebuggerShell(FILE *i, FILE *o) : 
    m_in(i),
    m_out(o),
    m_cor(NULL),
    m_modules(11), 
    m_unmanagedThreads(11),
    m_managedThreads(17),
    m_lastStepper(NULL),
    m_targetProcess(NULL),
    m_targetProcessHandledFirstException(false),
    m_currentProcess(NULL),
    m_currentThread(NULL),
    m_currentChain(NULL),
    m_rawCurrentFrame(NULL),
    m_currentUnmanagedThread(NULL),
    m_lastThread(0),
    m_currentFrame(NULL),
    m_showSource(true),
    m_silentTracing(false),
    m_quit(false),
    m_breakpoints(NULL),
    m_lastBreakpointID(0),
    m_pDIS(NULL),
    m_currentSourcesPath(NULL),
    m_stopEvent(NULL),
    m_hProcessCreated(NULL),
    m_stop(false),
    m_lastRunArgs(NULL),
    m_catchException(false),
    m_catchUnhandled(true),
    m_catchClass(false),
    m_catchModule(false),
    m_catchThread(false),
    m_needToSkipCompilerStubs(true),
    m_invalidCache(false),
    m_rgfActiveModes(DSM_DEFAULT_MODES),
    m_handleUnmanagedEvent(false),
    m_unmanagedDebuggingEnabled(false),
    m_cEditAndContinues(0),
    m_pCurrentEval(NULL),
    m_enableCtrlBreak(false),
    m_exceptionHandlingList(NULL)
{
    
}

CorDebugUnmappedStop DebuggerShell::ComputeStopMask(void )
{
    unsigned int us = (unsigned int)STOP_NONE;

    if (m_rgfActiveModes & DSM_UNMAPPED_STOP_PROLOG )
        us |= (unsigned int)STOP_PROLOG;

    if (m_rgfActiveModes & DSM_UNMAPPED_STOP_EPILOG )
        us |= (unsigned int)STOP_EPILOG;

    if (m_rgfActiveModes & DSM_UNMAPPED_STOP_UNMANAGED )
    {
        if (m_rgfActiveModes & DSM_WIN32_DEBUGGER)
            us |= (unsigned int)STOP_UNMANAGED;
        else
            Write(L"You can only step into unmanaged code if you're "
                  L"Win32 attached.\n");
    }
    
    if (m_rgfActiveModes & DSM_UNMAPPED_STOP_ALL )
    {
        us |= (unsigned int)STOP_ALL;
        if (!(m_rgfActiveModes & DSM_WIN32_DEBUGGER))
            us &= ~STOP_UNMANAGED;
    }

    return (CorDebugUnmappedStop)us;
}

CorDebugIntercept DebuggerShell::ComputeInterceptMask( void )
{
    unsigned int is = (unsigned int)INTERCEPT_NONE;

    if (m_rgfActiveModes & DSM_INTERCEPT_STOP_CLASS_INIT )
        is |= (unsigned int)INTERCEPT_CLASS_INIT;

    if (m_rgfActiveModes & DSM_INTERCEPT_STOP_EXCEPTION_FILTER )         
        is |= (unsigned int)INTERCEPT_EXCEPTION_FILTER;
    
    if (m_rgfActiveModes & DSM_INTERCEPT_STOP_SECURITY)
        is |= (unsigned int)INTERCEPT_SECURITY;
            
    if (m_rgfActiveModes & DSM_INTERCEPT_STOP_CONTEXT_POLICY)
        is |= (unsigned int)INTERCEPT_CONTEXT_POLICY;
            
    if (m_rgfActiveModes & DSM_INTERCEPT_STOP_INTERCEPTION )
        is |= (unsigned int)INTERCEPT_INTERCEPTION;
            
    if (m_rgfActiveModes & DSM_INTERCEPT_STOP_ALL)
        is |= (unsigned int)INTERCEPT_ALL;

    return (CorDebugIntercept)is;
}



//
// InvokeDebuggerOnBreak is a console control handler which 
// breaks into the debugger when a break signal is received.
//

static BOOL WINAPI InvokeDebuggerOnBreak(DWORD dwCtrlType)
{
    if ((dwCtrlType == CTRL_BREAK_EVENT) || ((dwCtrlType == CTRL_C_EVENT) &&
                                             !(g_pShell->m_rgfActiveModes & DSM_WIN32_DEBUGGER)))
    {
        if (dwCtrlType == CTRL_BREAK_EVENT)
            g_pShell->Write(L"<Ctrl-Break>\n");
        else
            g_pShell->Write(L"<Ctrl-C>\n");

        g_pShell->m_stopLooping = true;
        
        if ((g_pShell->m_targetProcess != NULL) && (g_pShell->m_enableCtrlBreak == true))
        {
            g_pShell->m_enableCtrlBreak = false;
            
            if (g_pShell->m_pCurrentEval == NULL)
            {
                g_pShell->Write(L"\n\nBreaking current process.\n");
                g_pShell->Interrupt();
            }
            else
            {
                g_pShell->Write(L"\n\nAborting func eval...\n");
                HRESULT hr = g_pShell->m_pCurrentEval->Abort();

                if (FAILED(hr))
                {
                    g_pShell->Write(L"Abort failed\n");
                    g_pShell->ReportError(hr);
                }
            }
        }
        else if (g_pShell->m_targetProcess == NULL)
            g_pShell->Write(L"No process to break.\n");
        else
            g_pShell->Write(L"Async break not allowed at this time.\n");

        return (TRUE);
    }
    else if ((dwCtrlType == CTRL_C_EVENT) && (g_pShell->m_rgfActiveModes & DSM_WIN32_DEBUGGER))
    {
        g_pShell->Write(L"<Ctrl-C>\n");
        
        g_pShell->Write(L"\n\nTracing all unmanaged stacks.\n");
        g_pShell->TraceAllUnmanagedThreadStacks();

        return (TRUE);
    }
    
    return (FALSE);
}


DebuggerShell::~DebuggerShell()
{
    SetTargetProcess(NULL);
    SetCurrentThread(NULL, NULL);
    SetCurrentChain(NULL);

    SetConsoleCtrlHandler(InvokeDebuggerOnBreak, FALSE);

    if (m_cor)
    {
        m_cor->Terminate();
        RELEASE(m_cor);
    }

    if (m_currentSourcesPath)
        delete [] m_currentSourcesPath;

    if (m_stopEvent)
        CloseHandle(m_stopEvent);

    if (m_hProcessCreated)
        CloseHandle(m_hProcessCreated);

#ifdef _INTERNAL_DEBUG_SUPPORT_
    if (m_pDIS != NULL)
        delete ((DIS *)m_pDIS);
#endif

    while (m_breakpoints)
        delete m_breakpoints;

    if (g_pShell == this)
        g_pShell = NULL;

    delete [] m_lastRunArgs;

    //clear out any managed threads that were left lieing around
    HASHFIND find;
    DebuggerManagedThread *dmt =NULL;
    for (dmt = (DebuggerManagedThread*)m_managedThreads.FindFirst(&find);
         dmt != NULL;
         dmt = (DebuggerManagedThread*)m_managedThreads.FindNext(&find))
    {
        RemoveManagedThread(dmt->GetToken() );
    }

    // Cleanup any list of specific exception types to handle
    while (m_exceptionHandlingList != NULL)
    {
        ExceptionHandlingInfo *h = m_exceptionHandlingList;
        
        delete [] h->m_exceptionType;

        m_exceptionHandlingList = h->m_next;
        delete h;
    }
    
    CoUninitialize();
}

HRESULT DebuggerShell::Init()
{
    HRESULT hr;

    // Use new so that the string is deletable.
    m_currentSourcesPath = new WCHAR[2];
    wcscpy(m_currentSourcesPath, L".");

    // Load the current path to any source files and the last set of
    // debugger modes from the registry.
    HKEY key;

    if (OpenDebuggerRegistry(&key))
    {
        WCHAR *newPath;
        
        if (ReadSourcesPath(key, &newPath))
        {
            delete [] m_currentSourcesPath;
            m_currentSourcesPath = newPath;
        }

        ReadDebuggerModes(key);
        
        CloseDebuggerRegistry(key);
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    if (FAILED(hr))
    {
        return hr;
    }

    if (m_rgfActiveModes & DSM_EMBEDDED_CLR)
    {
        hr = CoCreateInstance(CLSID_EmbeddedCLRCorDebug, NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ICorDebug,
                              (void **)&m_cor);

        if (FAILED(hr))
        {
            Write(L"Unable to create an IEmbeddedCLRCorDebug object.\n");
            Write(L"(The most probable cause is that icordbg.dll is"
                  L" not properly registered.)\n\n");
            return (hr);
        }
    }
    else
    {
        hr = CoCreateInstance(CLSID_CorDebug, NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_ICorDebug,
                              (void **)&m_cor);

        if (FAILED(hr))
        {
            Write(L"Unable to create an ICorDebug object.\n");
            Write(L"(The most probable cause is that mscordbi.dll is"
                  L" not properly registered.)\n\n");

            return (hr);
        }
    }

    hr = m_cor->Initialize();

    if (FAILED(hr))
    {
        Write(L"Unable to initialize an ICorDebug object.\n");

        RELEASE(m_cor);
        m_cor = NULL;

        return (hr);
    }

    ICorDebugManagedCallback *imc = GetDebuggerCallback();

    if (imc != NULL)
    {
        imc->AddRef();

        hr = m_cor->SetManagedHandler(imc);
        RELEASE(imc);

        if (FAILED(hr))
            return (hr);
    }
    else
        return (E_OUTOFMEMORY);

    ICorDebugUnmanagedCallback *iumc = GetDebuggerUnmanagedCallback();

    if (iumc != NULL)
    {
        iumc->AddRef();

        hr = m_cor->SetUnmanagedHandler(iumc);
        RELEASE(iumc);
    }
    else
        return (E_OUTOFMEMORY);
    
    AddCommands();
    m_pPrompt = L"(cordbg)";

    // Verify that debugging is possible on this system.
    hr = m_cor->CanLaunchOrAttach(0, (m_rgfActiveModes & DSM_WIN32_DEBUGGER) ? TRUE : FALSE);

    if (FAILED(hr))
    {
        if (hr == CORDBG_E_KERNEL_DEBUGGER_ENABLED)
        {
            Write(L"\nWARNING: there is a kernel debugger enabled on your system. Managed-only\n");
            Write(L"         debugging will cause your system to trap to the kernel debugger!\n\n");
        }
        else if (hr == CORDBG_E_KERNEL_DEBUGGER_PRESENT)
        {
            Write(L"\nWARNING: there is a kernel debugger present on your system. Managed-only\n");
            Write(L"         debugging will cause your system to trap to the kernel debugger!\n\n");
        }
        else
            return hr;
    }

    m_stopEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
    _ASSERTE(m_stopEvent != NULL);
 
    m_hProcessCreated = CreateEventA(NULL, FALSE, FALSE, NULL);
    _ASSERTE(m_hProcessCreated != NULL);

    g_pShell = this;

    SetConsoleCtrlHandler(InvokeDebuggerOnBreak, TRUE);

    // Set the error mode so we never show a dialog box if removable media is not in a drive. This prevents annoying
    // error messages while searching for PDB's for PE's that were compiled to a specific drive, and that drive happens
    // to be removable media on the current system.
    SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    return (S_OK);
}


static const WCHAR *MappingType( CorDebugMappingResult mr )
{
    switch( mr )
    {
        case MAPPING_PROLOG:
            return L"prolog";
            break;
        case MAPPING_EPILOG:
            return L"epilog";
            break;
        case MAPPING_NO_INFO:
            return L"no mapping info region";
            break;
        case MAPPING_UNMAPPED_ADDRESS:
            return L"unmapped region";
            break;
        case MAPPING_EXACT:
            return L"exactly mapped";
            break;
        case MAPPING_APPROXIMATE:
            return L"approximately mapped";
            break;
        default:
            return L"Unknown mapping";
            break;
    }
}

void DebuggerShell::Run(bool fNoInitialContinue)
{
    m_stop = false;

    HRESULT hr  = S_OK;
    
    SetCurrentThread(m_targetProcess, NULL);
    m_enableCtrlBreak = true;

    while (TRUE)
    {
        ResetEvent(m_stopEvent);

        SPEW(fprintf(stderr, "[%d] DS::R: Continuing process...\n", 
                     GetCurrentThreadId()));

        // Don't continue the first time of fNoInitialContinue is set
        // to true.
        if ((m_targetProcess != NULL) && !fNoInitialContinue)
        {
            ICorDebugProcess *p = m_targetProcess;
            
            p->AddRef();
            p->Continue(FALSE);
            RELEASE(p);
        }

        fNoInitialContinue = false;

        SPEW(fprintf(stderr, "[%d] DS::R: Waiting for a callback...\n", 
                     GetCurrentThreadId()));

        WaitForSingleObject(m_stopEvent, INFINITE);

        SPEW(fprintf(stderr, "[%d] DS::R: Done waiting.\n", GetCurrentThreadId()));

        // If the target process has received an unmanaged event that
        // must be handled outside of the unmanaged callback, then
        // handle it now. If HandleUnmanagedEvent() returns true then
        // that means that the unmanaged event was handled in such a
        // way that the process should be continued and the user not
        // given control, so we simply continue to the top of the
        // loop.
        if (m_targetProcess && m_handleUnmanagedEvent)
            if (HandleUnmanagedEvent())
                continue;

        BOOL queued;
        if (m_targetProcess == NULL
            || FAILED(m_targetProcess->HasQueuedCallbacks(NULL, &queued))
            || (!queued && m_stop))
        {
            SPEW(fprintf(stderr, "[%d] DS::R: I'm stopping now (%squeued and %sstop)...\n", 
                         GetCurrentThreadId(),
                         queued ? "" : "not ", m_stop ? "" : "not "));
            break;
        }

        SPEW(fprintf(stderr, "[%d] DS::R: I'm gonna do it again (%squeued and %sstop)...\n",
                     GetCurrentThreadId(),
                     queued ? "" : "not ", m_stop ? "" : "not "));
    }

    if ((m_currentThread != NULL) || (m_currentUnmanagedThread != NULL))
    {
        SetDefaultFrame();

        if (!m_silentTracing) 
        {
            ULONG32 IP;
            CorDebugMappingResult map;

            if ( m_currentFrame != NULL &&
                 SUCCEEDED( m_currentFrame->GetIP( &IP, &map ) ) )
            {
 
                if (map & ~(MAPPING_APPROXIMATE | MAPPING_EXACT) )
                {
                    if ((map != MAPPING_EPILOG) || (m_rgfActiveModes & DSM_UNMAPPED_STOP_EPILOG))
                    {
                        g_pShell->Write( L"Source not available when in the %s"
                                         L" of a function(offset 0x%x)\n",
                                         MappingType(map),IP);
                        g_pShell->m_showSource = false;
                    }
                }

            }

            if (m_currentThread != NULL)
            {
                PrintThreadPrefix(m_currentThread);
                Write( L"\n" );
            }

            if (! (m_showSource 
                   ? PrintCurrentSourceLine(0) 
                   : PrintCurrentInstruction(0, 0, 0)))
                PrintThreadState(m_currentThread);
        }
    }

    //this only has an effect when m_targetProcess == NULL
    // (ie, the target process has exited)
    m_lastStepper = NULL;
}

void DebuggerShell::Kill()
{
    if (m_targetProcess != NULL)
    {
        HANDLE h;

        HRESULT hr = m_targetProcess->GetHandle(&h);

        Write(L"Terminating current process...\n");

        {
            HASHFIND find;
            DebuggerManagedThread *dmt =NULL;
            for (dmt = (DebuggerManagedThread*)m_managedThreads.FindFirst(&find);
                 dmt != NULL;
                 dmt = (DebuggerManagedThread*)m_managedThreads.FindNext(&find))
            {
                RemoveManagedThread(dmt->GetToken() );
            }
        }
        
        m_stop = false;
        ResetEvent(m_stopEvent);

        // If this succeeds, our ExitProcess() callback may be invoked immediately.
        // (even before we return from Terminate() here)
        // That will in turn call SetTargetProcess(NULL) thus invalidating our
        // CordbProcess object.
        hr = m_targetProcess->Terminate(0);

        // If it fails, then we terminate manually...
        if (FAILED(hr) && (m_rgfActiveModes & DSM_WIN32_DEBUGGER))
        {
            m_targetProcess->AddRef();
            
            ::TerminateProcess(h, 0);

            ICorDebugController *pController = NULL;
            hr = m_targetProcess->QueryInterface(IID_ICorDebugController,
                                                 (void**)&pController);
            _ASSERTE(SUCCEEDED(hr));
            
            Continue(pController, NULL, NULL, FALSE);

            RELEASE(pController);

            RELEASE(m_targetProcess);
        }

        SetCurrentThread(NULL, NULL);

        // Don't call Run. There is no need to Continue from calling
        // ICorDebugProcess::Terminate, and ExitProcess will be called
        // automatically. Instead, we simply wait for ExitProcess to
        // get called before going back to the command prompt.
        WaitForSingleObject(m_stopEvent, INFINITE);

        // At this point, m_targetProcess should be finished.
    }

    ClearDebuggeeState();
}

// AsyncStop gets called by the main thread (the one that handles the
// command prompt) to stop an <appdomain> asynchronously.
HRESULT DebuggerShell::AsyncStop(ICorDebugController *controller, 
                                 DWORD dwTimeout)
{
    return controller->Stop(dwTimeout);
}

// Stop gets used by callbacks to tell the main loop (the one that
// called Run()) that we want to stop running now. c.f. AsyncStop
void DebuggerShell::Stop(ICorDebugController *controller, 
                         ICorDebugThread *thread,
                         DebuggerUnmanagedThread *unmanagedThread)
{
    //
    // Don't stop for any process other than the target.
    //
    ICorDebugProcess *process = NULL;
    HRESULT hr = S_OK;
    
    if (controller != NULL)
        hr = controller->QueryInterface(IID_ICorDebugProcess, 
                                        (void **)&process);

    if (hr==E_NOINTERFACE )
    {
        ICorDebugAppDomain *appDomain = NULL;
        
        _ASSERTE(process == NULL);

        hr = controller->QueryInterface(IID_ICorDebugAppDomain,
                                        (void **)&appDomain);
        _ASSERTE(!FAILED(hr)); 
        
        hr = appDomain->GetProcess(&process);
        
        _ASSERTE(!FAILED(hr)); 
        _ASSERTE(NULL != process); 

        RELEASE(appDomain);
    }
    if (FAILED(hr))
        g_pShell->ReportError(hr);
    
    if (!FAILED(hr) &&
        process != m_targetProcess && 
        process != NULL)
    {
        HRESULT hr = controller->Continue(FALSE);
        if (FAILED(hr))
            g_pShell->ReportError(hr);
    }
    else
    {
        m_stop = true;
        SetCurrentThread(process, thread, unmanagedThread);
        SetEvent(m_stopEvent);
    }

    if (NULL !=process)
        RELEASE(process);
}

void DebuggerShell::Continue(ICorDebugController *controller,
                             ICorDebugThread *thread,
                             DebuggerUnmanagedThread *unmanagedThread,
                             BOOL fIsOutOfBand)
{
    HRESULT hr = S_OK;
    
    if (!m_stop || fIsOutOfBand)
    {
        m_enableCtrlBreak = true;
        hr = controller->Continue(fIsOutOfBand);

        if (FAILED(hr) && !m_stop)
            g_pShell->ReportError(hr);
    }
    else
    {
        //
        // Just go ahead and continue from any events on other processes.
        //
        ICorDebugProcess *process = NULL;
        HRESULT hr = S_OK;
        hr = controller->QueryInterface(IID_ICorDebugProcess, 
                                         (void **)&process);

        if (hr==E_NOINTERFACE ||
            process == NULL)
        {
            ICorDebugAppDomain *appDomain = NULL;
            hr = controller->QueryInterface(IID_ICorDebugAppDomain,
                                            (void **)&appDomain);
            _ASSERTE(!FAILED(hr)); 
            
            hr = appDomain->GetProcess(&process);
            _ASSERTE(!FAILED(hr)); 
            _ASSERTE(NULL != process); 

            RELEASE(appDomain);
        }

        if (!FAILED(hr) && 
            process != m_targetProcess && 
            process != NULL)
        {
            m_enableCtrlBreak = true;
            HRESULT hr = controller->Continue(FALSE);

            if (FAILED(hr))
                g_pShell->ReportError(hr);
        }
        else
        {
            SetEvent(m_stopEvent);
        }
        
        RELEASE(process);
    }
}

void DebuggerShell::Interrupt()
{
    _ASSERTE(m_targetProcess);
    HRESULT hr = m_targetProcess->Stop(INFINITE);

    if (FAILED(hr))
    {
        Write(L"\nError stopping process:  ", hr);
        ReportError(hr);
    }
    else
        Stop(m_targetProcess, NULL);
}

void DebuggerShell::SetTargetProcess(ICorDebugProcess *pProcess)
{
    if (pProcess != m_targetProcess)
    {
        if (m_targetProcess != NULL)
            RELEASE(m_targetProcess);

        m_targetProcess = pProcess;

        if (pProcess != NULL)
            pProcess->AddRef();

        //
        // If we're done with a process, remove all of the modules.
        // This will clean up if we miss some unload module events.
        //

        if (m_targetProcess == NULL)
        {
            g_pShell->m_modules.RemoveAll();
            m_targetProcessHandledFirstException = false;
        }
    }
}

void DebuggerShell::SetCurrentThread(ICorDebugProcess *pProcess, 
                                     ICorDebugThread *pThread,
                                     DebuggerUnmanagedThread *pUnmanagedThread)
{
    if (pThread != NULL && pUnmanagedThread == NULL)
    {
        //
        // Lookup the corresponding unmanaged thread
        // 

        DWORD threadID;
        HRESULT hr;
    
        hr = pThread->GetID(&threadID);
        if (SUCCEEDED(hr))
        {
            pUnmanagedThread = 
              (DebuggerUnmanagedThread*) m_unmanagedThreads.GetBase(threadID);
        }
    }
    else if (pUnmanagedThread != NULL && pThread == NULL)
    {
        //
        // Lookup the corresponding managed thread
        //

        HRESULT hr;

        hr = pProcess->GetThread(pUnmanagedThread->GetId(), &pThread);
        if (pThread != NULL)
            RELEASE(pThread);
    }

    if (pProcess != m_currentProcess)
    {
        if (m_currentProcess != NULL)
            RELEASE(m_currentProcess);

        m_currentProcess = pProcess;

        if (pProcess != NULL)
            pProcess->AddRef();
    }

    if (pThread != m_currentThread)
    {
        if (m_currentThread != NULL)
            RELEASE(m_currentThread);

        m_currentThread = pThread;

        if (pThread != NULL)
            pThread->AddRef();
    }

    m_currentUnmanagedThread = pUnmanagedThread;

    SetCurrentChain(NULL);
    SetCurrentFrame(NULL);
}

void DebuggerShell::SetCurrentChain(ICorDebugChain *chain)
{
    if (chain != m_currentChain)
    {
        if (m_currentChain != NULL)
            RELEASE(m_currentChain);

        m_currentChain = chain;

        if (chain != NULL)
            chain->AddRef();
    }
}

void DebuggerShell::SetCurrentFrame(ICorDebugFrame *frame)
{
    if (frame != m_rawCurrentFrame)
    {
        if (m_rawCurrentFrame != NULL)
            RELEASE(m_rawCurrentFrame);

        if (m_currentFrame != NULL)
            RELEASE(m_currentFrame);

        m_rawCurrentFrame = frame;

        if (frame != NULL)
        {
            frame->AddRef();

            if (FAILED(frame->QueryInterface(IID_ICorDebugILFrame, 
                                             (void **) &m_currentFrame)))
                m_currentFrame = NULL;
        }
        else
            m_currentFrame = NULL;
    }
}

void DebuggerShell::SetDefaultFrame()
{
    if (m_currentThread != NULL)
    {
        ICorDebugChain *ichain;
        HRESULT hr = m_currentThread->GetActiveChain(&ichain);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return;
        }

        SetCurrentChain(ichain);

        if (ichain != NULL)
        {
            RELEASE(ichain);

            ICorDebugFrame *iframe;

            hr = m_currentThread->GetActiveFrame(&iframe);

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);
                return;
            }

            SetCurrentFrame(iframe);
            
            if (iframe != NULL)
                RELEASE(iframe);
        }
        else
            SetCurrentFrame(NULL);
    }
}

static const WCHAR WcharFromDebugState(CorDebugThreadState debugState)
{
    WCHAR sz;

    switch( debugState )
    {
        case THREAD_RUN:
            sz = L'R';
            break;
        case THREAD_SUSPEND:
            sz = L'S';
            break;
        default:
            _ASSERTE( !"WcharFromDebugState given an invalid value" );
            sz = L'?';
            break;
    }

    return sz;
}

HRESULT DebuggerShell::PrintThreadState(ICorDebugThread *thread)
{
    DWORD threadID;
    HRESULT hr;

    if (thread == NULL)
        return S_OK;
    
    hr = thread->GetID(&threadID);

    if (FAILED(hr))
        return hr;

    Write(L"Thread 0x%x", threadID);

    CorDebugThreadState ds;
    if( !FAILED(thread->GetDebugState(&ds)))
    {
        Write(L" %c ", WcharFromDebugState(ds));
    }
    else
    {
        Write(L" - ");
    }
    
    ICorDebugILFrame* ilframe = NULL;
    ICorDebugNativeFrame* nativeframe = NULL;

    if (thread == m_currentThread)
    {
        ilframe = m_currentFrame;
        if (ilframe != NULL)
            ilframe->AddRef();
        if (m_rawCurrentFrame != NULL )
            m_rawCurrentFrame->QueryInterface( IID_ICorDebugNativeFrame,
                                (void **)&nativeframe);
    }
    else
    {
        ICorDebugFrame *iframe;
        hr = thread->GetActiveFrame(&iframe);
        if (FAILED(hr))
        {
            if (hr == CORDBG_E_BAD_THREAD_STATE)
                Write(L" no stack, thread is exiting.\n");
            else
                ReportError(hr);
            
            return hr;
        }

        if (iframe != NULL)
        {
            hr = iframe->QueryInterface(IID_ICorDebugILFrame, 
                                        (void **) &ilframe);
            if (FAILED(hr))
                ilframe = NULL;
            
            hr = iframe->QueryInterface( IID_ICorDebugNativeFrame,
                                    (void **)&nativeframe);
            RELEASE(iframe);
            if (FAILED(hr))
                nativeframe = NULL;
        }
    }

    if ( nativeframe != NULL)
    {
        DWORD id;
        HRESULT hr = thread->GetID(&id);

        if (SUCCEEDED(hr))
        {
            ICorDebugCode *icode;
            if (ilframe != NULL )
                hr = ilframe->GetCode(&icode);
            else
                hr = nativeframe->GetCode( &icode );

            if (SUCCEEDED(hr))
            {
                ICorDebugFunction *ifunction;
                hr = icode->GetFunction(&ifunction);

                if (SUCCEEDED(hr))
                {
                    DebuggerFunction *function;
                    function = DebuggerFunction::FromCorDebug(ifunction);
                    _ASSERTE(function != NULL);
            
                    ULONG32 ip = 0;
                    ULONG32 nativeIp = 0;
                    bool fILIP = false;
                    if (nativeframe != NULL )
                    {
                        hr = nativeframe->GetIP(&nativeIp);
                    }
                    if (ilframe != NULL && !FAILED( hr ) )
                    {
                        CorDebugMappingResult mappingResult;
                        if (!FAILED( ilframe->GetIP(&ip, &mappingResult) ) )
                            fILIP = true;
                    }

                    if (SUCCEEDED(hr))
                    {
                        DebuggerSourceFile *sf = NULL;
                        unsigned int lineNumber = 0;

                        if (fILIP)
                            hr = function->FindLineFromIP(ip, &sf,
                                                          &lineNumber);

                        if (SUCCEEDED(hr))
                        {
                            Write(L" at %s::%s", function->m_className, function->m_name);
                    
                            Write(L" +%.4x", nativeIp);
                            if (fILIP
                                && m_rgfActiveModes & DSM_IL_NATIVE_PRINTING)
                                Write( L"[native] +%.4x[IL]", ip );

                            if (sf != NULL)
                                Write(L" in %s:%d", sf->GetName(), lineNumber);
                        }
                        else
                            g_pShell->ReportError(hr);
                    }
                    else
                        g_pShell->ReportError(hr);

                    RELEASE(ifunction);
                }
                else
                    g_pShell->ReportError(hr);

                RELEASE(icode);
            }
            else
                g_pShell->ReportError(hr);
        }
        else
            g_pShell->ReportError(hr);

        if (ilframe)
            RELEASE(ilframe);
    }
    else
    {
        //
        // See if we at least have a current chain
        //

        ICorDebugChain *ichain = NULL;

        if (thread == m_currentThread)
        {
            ichain = m_currentChain;
            if (ichain != NULL)
                ichain->AddRef();
        }
        else
        {
            hr = thread->GetActiveChain(&ichain);

            if (FAILED(hr))
                return hr;
        }

        if (ichain != NULL)
        {
            BOOL isManaged;
            HRESULT hr = ichain->IsManaged(&isManaged);

            if (FAILED(hr))
                return hr;

            if (isManaged)
            {
                // 
                // Just print the chain - it has no frames so will
                // be one line
                //

                PrintChain(ichain);
            }
            else
            {
                //
                // Print the top line of the stack trace
                //

                ICorDebugRegisterSet *pRegisters;

                hr = ichain->GetRegisterSet(&pRegisters);
                if (FAILED(hr))
                    return hr;

                CORDB_REGISTER ip;

                hr = pRegisters->GetRegisters(1<<REGISTER_INSTRUCTION_POINTER,
                                              1, &ip);
                RELEASE(pRegisters);
                if (FAILED(hr))
                    return hr;

                ICorDebugProcess *iprocess;
                hr = thread->GetProcess(&iprocess);
                if (FAILED(hr))
                    return hr;

                HANDLE hProcess;
                hr = iprocess->GetHandle(&hProcess);
                RELEASE(iprocess);
                if (FAILED(hr))
                    return hr;

                PrintUnmanagedStackFrame(hProcess, ip);
            }
        
            RELEASE(ichain);
        }
        else
            Write(L" <no information available>");
    }
    
    if (NULL != nativeframe)
        RELEASE( nativeframe);
    Write(L"\n");

    return S_OK;
}

HRESULT DebuggerShell::PrintChain(ICorDebugChain *chain, 
                                  int *frameIndex,
                                  int *iNumFramesToShow)
{
    ULONG count;
    BOOL isManaged;
    int frameCount = 0;
    int iNumFrames = 1000;

    if (frameIndex != NULL)
        frameCount = *frameIndex;

    if (iNumFramesToShow != NULL)
        iNumFrames = *iNumFramesToShow;

    // Determined whether or not the chain is managed
    HRESULT hr = chain->IsManaged(&isManaged);

    if (FAILED(hr))
        return hr;

    // Chain is managed, so information can be displayed
    if (isManaged)
    {
        // Enumerate every frame in the chain
        ICorDebugFrameEnum *fe;
        hr = chain->EnumerateFrames(&fe);

        if (FAILED(hr))
            return hr;

        // Get the first frame in the enumeration
        ICorDebugFrame *iframe;
        hr = fe->Next(1, &iframe, &count);

        if (FAILED(hr))
            return hr;

        // Display properties for each frame
        while ( (count == 1) && (iNumFrames-- > 0))
        {
            // Indicate the top frame
            if (chain == m_currentChain && iframe == m_rawCurrentFrame)
                Write(L"%d)* ", frameCount++);
            else
                Write(L"%d)  ", frameCount++);

            PrintFrame(iframe);
            RELEASE(iframe);

            // Get the next frame. We don't stop if printing a frame
            // fails for some reason.
            hr = fe->Next(1, &iframe, &count);

            if (FAILED(hr))
            {
                RELEASE(fe);
                return hr;
            }
        }

        // Done with current frame
        RELEASE(fe);
    }
    else
    {
        CORDB_ADDRESS stackStart, stackEnd;

        ICorDebugThread *ithread;
        hr = chain->GetThread(&ithread);
        if (FAILED(hr))
            return hr;
                
        hr = chain->GetStackRange(&stackStart, &stackEnd);
        if (FAILED(hr))
            return hr;

        ICorDebugRegisterSet *pRegisters;

        hr = chain->GetRegisterSet(&pRegisters);
        if (FAILED(hr))
            return hr;

        CORDB_REGISTER registers[3];

        hr = pRegisters->GetRegisters((1<<REGISTER_INSTRUCTION_POINTER)
                                      | (1<<REGISTER_STACK_POINTER)
                                      | (1<<REGISTER_FRAME_POINTER),
                                      3, registers);
        
        if (FAILED(hr))
            return hr;

        RELEASE(pRegisters);

        HANDLE hThread;
        hr = ithread->GetHandle(&hThread);
        if (FAILED(hr))
            return hr;

        ICorDebugProcess *iprocess;
        hr = ithread->GetProcess(&iprocess);
        RELEASE(ithread);
        if (FAILED(hr))
            return hr;

        HANDLE hProcess;
        hr = iprocess->GetHandle(&hProcess);
        RELEASE(iprocess);
        if (FAILED(hr))
            return hr;

        if (chain == m_currentChain )
            Write(L"* ");

        TraceUnmanagedStack(hProcess, hThread, 
                            registers[REGISTER_INSTRUCTION_POINTER],
                            registers[REGISTER_FRAME_POINTER],
                            registers[REGISTER_STACK_POINTER],
                            stackEnd);
    }

    CorDebugChainReason reason;

    // Get & print chain's reason
    hr = chain->GetReason(&reason);

    if (FAILED(hr))
        return hr;

    LPWSTR reasonString = NULL;

    switch (reason)
    {
    case CHAIN_PROCESS_START:
    case CHAIN_THREAD_START:
        break;

    case CHAIN_ENTER_MANAGED:
        reasonString = L"Managed transition";
        break;

    case CHAIN_ENTER_UNMANAGED:
        reasonString = L"Unmanaged transition";
        break;

    case CHAIN_CLASS_INIT:
        reasonString = L"Class initialization";
        break;

    case CHAIN_DEBUGGER_EVAL:
        reasonString = L"Debugger evaluation";
        break;

    case CHAIN_EXCEPTION_FILTER:
        reasonString = L"Exception filter";
        break;

    case CHAIN_SECURITY:
        reasonString = L"Security";
        break;

    case CHAIN_CONTEXT_POLICY:
        reasonString = L"Context policy";
        break;

    case CHAIN_CONTEXT_SWITCH:
        reasonString = L"Context switch";
        break;

    case CHAIN_INTERCEPTION:
        reasonString = L"Interception";
        break;

    case CHAIN_FUNC_EVAL:
        reasonString = L"Function Evaluation";
        break;

    default:
        reasonString = NULL;
    }

    if (reasonString != NULL)
        Write(L"--- %s ---\n", reasonString);

    if (frameIndex != NULL)
        *frameIndex = frameCount;

    if (iNumFramesToShow != NULL)
        *iNumFramesToShow = iNumFrames;

    return S_OK;
}

HRESULT DebuggerShell::PrintFrame(ICorDebugFrame *frame)
{
    ICorDebugILFrame       *ilframe = NULL;
    ICorDebugCode          *icode = NULL;
    ICorDebugFunction      *ifunction = NULL;
    ICorDebugNativeFrame   *icdNativeFrame = NULL;

    DebuggerFunction       *function = NULL;
    unsigned int            j;
    DebuggerSourceFile     *sf = NULL;
    unsigned int            lineNumber = 0;
    bool                    fILIP = false;
    ULONG32                 nativeIp = 0;
    WCHAR                   wsz[40];

    // Get the native frame for the current frame
    HRESULT hr = frame->QueryInterface(IID_ICorDebugNativeFrame,
                                       (void **)&icdNativeFrame);
    
    if (FAILED(hr))
    {
	icdNativeFrame = NULL;
    }

    // Get the IL frame for the current frame
    hr = frame->QueryInterface(IID_ICorDebugILFrame, 
                               (void **) &ilframe);
    
    if (FAILED(hr))
        ilframe = NULL;

    // Get the code for the frame
    if (ilframe != NULL )
    {
        hr = ilframe->GetCode(&icode);
    }
    else if (icdNativeFrame != NULL )
    {
        hr = icdNativeFrame->GetCode(&icode);
    }
    else
    {
        hr = E_FAIL;
    }

    if (FAILED(hr))
    {
        Write(L"[Unable to obtain any code information]");
        goto LExit;
    }

    // Get the function for the code
    hr = icode->GetFunction(&ifunction);
    
    if (FAILED(hr))
    {
        Write(L"[Unable to obtain any function information]");
        goto LExit;
    }

    // Get the DebuggerFunction for the function iface
    function = DebuggerFunction::FromCorDebug(ifunction);
    _ASSERTE(function);
    
    // Get the IP for the current frame
    ULONG32 ip;
    
    if (ilframe != NULL)
    {
        CorDebugMappingResult mappingResult;
        
        hr = ilframe->GetIP(&ip, &mappingResult);

        // Find the source line for the IP
        hr = function->FindLineFromIP(ip, &sf, &lineNumber);

        if (FAILED(hr))
            ip = 0;
        else
            fILIP = true;
    }
    
    // If the module names are desired, then include the name in front of
    // the class info ntsd-style.
    if (m_rgfActiveModes & DSM_SHOW_MODULES_IN_STACK_TRACE)
    {
        WCHAR       *szModule;
        WCHAR       rcModule[_MAX_PATH];

        DebuggerModule *module = function->GetModule();
        szModule = module->GetName();
        _wsplitpath(szModule, NULL, NULL, rcModule, NULL);
        Write(L"%s!", rcModule);
    }
    
    // Write out the class and method for the current IP
    Write(L"%s%s::%s", 
          function->GetNamespaceName(),
          function->GetClassName(), 
          function->GetName());

    // Print out the funtion's source file, line and start addr
    if (icdNativeFrame == NULL)
    {
        if (fILIP == true)
            Write( L" +%.4x[IL]", ip);
    }
    else
    {
        if (!FAILED(icdNativeFrame->GetIP(&nativeIp)))
            Write(L" +%.4x", nativeIp);

        if ((m_rgfActiveModes & DSM_IL_NATIVE_PRINTING) && fILIP == true)
            Write( L"[native] +%.4x[IL]", ip);
    }

    if (lineNumber > 0)
    {
        if (sf->GetPath())
            Write(L" in %s:%d", sf->GetPath(), lineNumber);
        else if (sf->GetName())
            Write(L" in %s:%d", sf->GetName(), lineNumber);
        else
            Write(L" in %s:%d", L"<UnknownFilename>", lineNumber);
    }
    else
        Write(L" [no source information available]");

    // if currently associated source file does not have 
    // lineNumber number of lines, warn the user
    if (lineNumber > 0)
    {
        if (sf != NULL)
        {
            if (sf->GetPath() && (sf->TotalLines() < lineNumber))
                Write(L"\tWARNING: The currently associated source file has only %d lines."
                        , sf->TotalLines());
        }
    }

    if (m_rgfActiveModes & DSM_SHOW_ARGS_IN_STACK_TRACE)
    {
        // Now print out the arguments for the method
        ICorDebugILFrame *ilf = NULL;

        hr = frame->QueryInterface(IID_ICorDebugILFrame, (void **)&ilf);

        if (FAILED(hr))
            goto LExit;

        ICorDebugValueEnum *pArgs = NULL;

        hr = ilf->EnumerateArguments(&pArgs);

        if (!SUCCEEDED(hr))
            goto LExit;
        
        RELEASE(ilf);
        ilf = NULL;

        ULONG argCount;

        hr = pArgs->GetCount(&argCount);

        if (!SUCCEEDED(hr))
            goto LExit;
        
#ifdef _DEBUG
        bool fVarArgs = false;
        PCCOR_SIGNATURE sig = function->GetSignature();
        ULONG callConv = CorSigUncompressCallingConv(sig);

        if ((callConv & IMAGE_CEE_CS_CALLCONV_MASK) &
            IMAGE_CEE_CS_CALLCONV_VARARG)
            fVarArgs = true;
#endif //_DEBUG

        ULONG cTemp = function->GetArgumentCount();

        // Var Args functions have call-site-specific numbers of
        // arguments
        _ASSERTE( argCount == cTemp || fVarArgs);

        ICorDebugValue *ival;
        ULONG celtFetched = 0;

        // Print out each argument first
        // Avoid printing "this" in arg list for static methods
        if (function->IsStatic())
        {
            j = 0;
        }
        else
        {
            j = 1;

            hr = pArgs->Next(1, &ival,&celtFetched);
        }

        LPWSTR nameWsz;
        for (; j < argCount; j++)
        {
            DebuggerVarInfo* arg = function->GetArgumentAt(j);

            Write(L"\n\t\t");
            if (arg != NULL)
            {
                MAKE_WIDEPTR_FROMUTF8(nameW, arg->name);
                nameWsz = nameW;
            }
            else
            {
                wsprintf( wsz, L"Arg%d", j );
                nameWsz = wsz;
            }

            // Get the field value
            hr = pArgs->Next(1, &ival,&celtFetched);

            // If successful, print the variable
            if (SUCCEEDED(hr) && celtFetched==1)
            {
                //@TODO: Remove when DbgMeta becomes Unicode

                PrintVariable(nameWsz, ival, 0, FALSE);
            }

            // Otherwise, indicate that it is unavailable
            else
                Write(L"%s = <unavailable>", nameWsz);
        }

        RELEASE(pArgs);
        pArgs = NULL;
    }

 LExit:
    Write(L"\n");

    // Clean up
    if (icdNativeFrame != NULL )
        RELEASE( icdNativeFrame);

    if (icode != NULL )
        RELEASE(icode);

    if (ilframe != NULL )
        RELEASE(ilframe);

    if (ifunction != NULL )
        RELEASE(ifunction);

    return hr;
}

DebuggerBreakpoint *DebuggerShell::FindBreakpoint(SIZE_T id)
{
    DebuggerBreakpoint *b = m_breakpoints;

    while (b != NULL)
    {
        if (b->m_id == id)
            return (b);

        b = b->m_next;
    }

    return (NULL);
}


void DebuggerShell::RemoveAllBreakpoints()
{
    while (m_breakpoints != NULL)
    {
        delete m_breakpoints;
    }
}

void DebuggerShell::OnActivateBreakpoint(DebuggerBreakpoint *pb)
{
}

void DebuggerShell::OnDeactivateBreakpoint(DebuggerBreakpoint *pb)
{
}

void DebuggerShell::OnBindBreakpoint(DebuggerBreakpoint *pb, DebuggerModule *pm)
{
    Write(L"Breakpoint #%d has bound to %s.\n", pb->GetId(),
          pm ? pm->GetName() : L"<unknown>");
}

void DebuggerShell::OnUnBindBreakpoint(DebuggerBreakpoint *pb, DebuggerModule *pm)
{
    Write(L"Breakpoint #%d has unbound from %s.\n", pb->GetId(),
          pm ? pm->GetName() : L"<unknown>");
}

bool DebuggerShell::ReadLine(WCHAR *buffer, int maxCount)
{
    CQuickBytes mbBuf;
    CHAR *szBufMB  = (CHAR *)mbBuf.Alloc(maxCount * sizeof(CHAR));

    // MultiByteToWideChar fails to terminate the string with 2 null characters
    // Instead it only uses one. That's why we need to zero the memory out.
    _ASSERTE(buffer && maxCount);
    memset(buffer, 0, maxCount * sizeof(WCHAR));
    memset(szBufMB, 0, maxCount * sizeof(CHAR));

    if (!fgets(szBufMB, maxCount, m_in))
    {
        if (m_in == stdin)
        {
            // Must have piped commands in
            m_quit = true;
        }

        return false;
    }

    // Try the write
    MultiByteToWideChar(GetConsoleCP(), 0, szBufMB, strlen(szBufMB), buffer, maxCount);

    WCHAR *ptr = wcschr(buffer, L'\n');

    if (ptr)
    {
        // Get rid of the newline character it it's there
		*ptr = L'\0';
    }
    else if (fgets(szBufMB, maxCount, m_in))
    {
        Write(L"The input string was too long.\n");

        while(!strchr(szBufMB, L'\n') && fgets(szBufMB, maxCount, m_in))
        {
            ;
        }

        *buffer = L'\0';

        return false;
    }

    if (m_in != stdin)
    {
        Write(L"%s\n", buffer);
    }

    return true;
}

#define INIT_WRITE_BUF_SIZE 4096
HRESULT DebuggerShell::CommonWrite(FILE *out, const WCHAR *buffer, va_list args)
{
    BOOL fNeedToDeleteDB = FALSE;
    // We need to tack a "+1" tacked onto all our allocates so that we can
    // whack a NULL character onto it, but NOT include it in our doublebyte (Wide) count
    // so that we don't actually store any data in it.
    SIZE_T curBufSizeDB = INIT_WRITE_BUF_SIZE;
    CQuickBytes dbBuf;
    WCHAR *szBufDB = (WCHAR *)dbBuf.Alloc( (curBufSizeDB+1) * sizeof(WCHAR));
    int cchWrittenDB = -1;
    if (szBufDB != NULL)
        cchWrittenDB = _vsnwprintf(szBufDB, INIT_WRITE_BUF_SIZE, buffer, args);
    
    if (cchWrittenDB == -1)
    {
        szBufDB = NULL;

        while (cchWrittenDB == -1)
        {
            delete [] szBufDB;
            szBufDB = new WCHAR[(curBufSizeDB+1) * 4];

            // Out of memory, nothing we can do
            if (!szBufDB)
                return E_OUTOFMEMORY;

            curBufSizeDB *= 4;
            fNeedToDeleteDB = TRUE;

            cchWrittenDB = _vsnwprintf(szBufDB, curBufSizeDB, buffer, args);
        }
    }

    // Double check that we're null-terminated.  Note that this uses the extra
    // space we tacked onto the end
    szBufDB[curBufSizeDB] = L'\0';

    // Allocate buffer
    BOOL fNeedToDeleteMB = FALSE;
    SIZE_T curBufSizeMB = INIT_WRITE_BUF_SIZE+1; // +1 from above percolates through
    CQuickBytes mbBuf;
    CHAR *szBufMB  = (CHAR *)mbBuf.Alloc(curBufSizeMB * sizeof(CHAR));

    // Try the write
    int cchWrittenMB = 0;
    if(szBufMB != NULL)
        cchWrittenMB = WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufDB, -1, szBufMB, curBufSizeMB, NULL, NULL);

    if (cchWrittenMB == 0)
    {
        // Figure out size required
        int cchReqMB = WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufDB, -1, NULL, 0, NULL, NULL);
        _ASSERTE(cchReqMB > 0);

        // I don't think the +1 is necessary, but I'm doing it to make sure (WideCharToMultiByte is a bit
        // shady in whether or not it writes the null after the end of the buffer)
        szBufMB = new CHAR[cchReqMB+1];

        // Out of memory, nothing we can do
        if (!szBufDB)
        {
            if (fNeedToDeleteDB)
                delete [] szBufDB;

            return E_OUTOFMEMORY;
        }

        curBufSizeMB = cchReqMB;
        fNeedToDeleteMB = TRUE;

        // Try the write
        cchWrittenMB = WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufDB, -1, szBufMB, curBufSizeMB, NULL, NULL);
        _ASSERTE(cchWrittenMB > 0);
    }

    // Finally, write it
    fputs(szBufMB, out);

    // Clean up
    if (fNeedToDeleteDB)
        delete [] szBufDB;

    if (fNeedToDeleteMB)
        delete [] szBufMB;

    return S_OK;
}

HRESULT DebuggerShell::Write(const WCHAR *buffer, ...)
{
    HRESULT hr;
    va_list     args;

    va_start(args, buffer);

    hr = CommonWrite(m_out, buffer, args);

    va_end(args);

    return hr;
}

HRESULT DebuggerShell::WriteBigString(WCHAR *s, ULONG32 count)
{
    // The idea is that we'll print subparts iteratively,
    // rather than trying to do everything all at once.
    ULONG32 chunksize = 4096;
    ULONG32 iEndOfChunk = 0;
    WCHAR temp;
    HRESULT hr = S_OK;

    // Loop if there's something left & nothing's gone wrong
    while(iEndOfChunk < count && hr == S_OK)
    {
        if (iEndOfChunk + chunksize > count)
            chunksize = count - iEndOfChunk;

        iEndOfChunk += chunksize;
        temp = s[iEndOfChunk];
        s[iEndOfChunk] = '\0';
        hr = Write(L"%s", &(s[iEndOfChunk-chunksize]));
        s[iEndOfChunk] = temp;
    }

    return hr;
}

// Output to the user
void DebuggerShell::Error(const WCHAR *buffer, ...)
{
    va_list     args;

    va_start(args, buffer);

    CommonWrite(m_out, buffer, args);

    va_end(args);
}

//
// Print a little whitespace on the current line for indenting.
//

void DebuggerShell::PrintIndent(unsigned int level)
{
    unsigned int i;

    for (i = 0; i < level; i++)
        Write(L"  ");
}

//
// Write the name of a variable out, but only if it is valid.
//
void DebuggerShell::PrintVarName(const WCHAR* name)
{
    if (name != NULL)
        Write(L"%s=", name);
}

//
// Get all the indicies for an array.
//
HRESULT DebuggerShell::GetArrayIndicies(WCHAR **pp,
                                        ICorDebugILFrame *context,
                                        ULONG32 rank, ULONG32 *indicies)
{
    HRESULT hr = S_OK;
    WCHAR *p = *pp;

    for (unsigned int i = 0; i < rank; i++)
    {
        if (*p != L'[')
        {
            Error(L"Missing open bracked on array index.\n");
            hr = E_FAIL;
            goto exit;
        }

        p++;
        
        // Check for close bracket
        const WCHAR *indexStart = p;
        int nestLevel = 1;

        while (*p)
        {
            _ASSERTE(nestLevel != 0);

            if (*p == L'[')
                nestLevel++;

            if (*p == L']')
                nestLevel--;

            if (nestLevel == 0)
                break;

            p++;
        }

        if (nestLevel != 0)
        {
            Error(L"Missing close bracket on array index.\n");
            hr = E_FAIL;
            goto exit;
        }

        const WCHAR *indexEnd = p;
        p++;

        // Get index
        int index;
        bool indexFound = false;

        if (!GetIntArg(indexStart, index))
        {
            WCHAR tmpStr[256];

            _ASSERTE( indexEnd >= indexStart );
            wcsncpy(tmpStr, indexStart, 255);
            tmpStr[255] = L'\0';

            ICorDebugValue *iIndexValue = EvaluateExpression(tmpStr, context);

            if (iIndexValue != NULL)
            {
                ICorDebugGenericValue *igeneric;
                hr = iIndexValue->QueryInterface(IID_ICorDebugGenericValue,
                                                 (void **) &igeneric);

                if (SUCCEEDED(hr))
                {
                    CorElementType indexType;
                    hr = igeneric->GetType(&indexType);

                    if (SUCCEEDED(hr))
                    {
                        if ((indexType == ELEMENT_TYPE_I1)  ||
                            (indexType == ELEMENT_TYPE_U1)  ||
                            (indexType == ELEMENT_TYPE_I2)  ||
                            (indexType == ELEMENT_TYPE_U2)  ||
                            (indexType == ELEMENT_TYPE_I4)  ||
                            (indexType == ELEMENT_TYPE_U4))
                        {
                            hr = igeneric->GetValue(&index);

                            if (SUCCEEDED(hr))
                                indexFound = true;
                            else
                                ReportError(hr);
                        }
                    }
                    else
                        ReportError(hr);

                    RELEASE(igeneric);
                }
                else
                    ReportError(hr);

                RELEASE(iIndexValue);
            }
        }
        else
            indexFound = true;

        if (!indexFound)
        {
            Error(L"Invalid array index. Must use a number or "
                  L"a variable of type: I1, UI1, I2, UI2, I4, UI4.\n");
            hr = E_FAIL;
            goto exit;
        }

        indicies[i] = index;
    }

exit:    
    *pp = p;
    return hr;
}

bool DebuggerShell::EvaluateAndPrintGlobals(const WCHAR *exp)
{
    return this->MatchAndPrintSymbols((WCHAR *)exp, FALSE, true );
}

ICorDebugValue *DebuggerShell::EvaluateExpression(const WCHAR *exp,
                                                  ICorDebugILFrame *context,
                                                  bool silently)
{
    HRESULT hr;
    const WCHAR *p = exp;

    // Skip white space
    while (*p && iswspace(*p))
        p++;

    // First component of expression must be a name (variable or class static)
    const WCHAR *name = p;

    while (*p && !iswspace(*p) && *p != L'[' && *p != L'.')
        p++;

    if (p == name)
    {
        Error(L"Syntax error, name missing in %s\n", exp);
        return (NULL);
    }

    WCHAR *nameAlloc = new WCHAR[p - name + 1];
    if (!nameAlloc)
    {
        return NULL;
    }
    
    wcsncpy(nameAlloc, name, p - name);
    nameAlloc[p-name] = L'\0';

    bool unavailable;
    ICorDebugValue *value = EvaluateName(nameAlloc, context, &unavailable);

    if (unavailable)
    {
        Error(L"Variable %s is in scope but unavailable.\n", nameAlloc);
        delete [] nameAlloc;
        return (NULL);
    }

    DebuggerModule *m = NULL;
    mdTypeDef td = mdTypeDefNil;
    
    if (value == NULL)
    {
        ICorDebugClass *iclass;
        mdFieldDef fd;
        bool isStatic;

        // See if we've got a static field name here...
        hr = ResolveQualifiedFieldName(NULL, mdTypeDefNil, nameAlloc,
                                       &m, &td, &iclass, &fd, &isStatic);

        if (FAILED(hr))
        {
            if (!silently)
                Error(L"%s is not an argument, local, or class static.\n",
                      nameAlloc);
            
            delete [] nameAlloc;
            return (NULL);
        }

        if (isStatic)
        {
            if (!context)
            {
                if (!silently)
                    Error(L"Must have a context to display %s.\n",
                        nameAlloc);
                
                delete [] nameAlloc;
                return (NULL);
            }

            // We need an ICorDebugFrame to pass in here...
            ICorDebugFrame *pFrame;
            hr = context->QueryInterface(IID_ICorDebugFrame, (void**)&pFrame);
            _ASSERTE(SUCCEEDED(hr));
            
            // Grab the value of the static field off of the class.
            hr = iclass->GetStaticFieldValue(fd, pFrame, &value);
            
            RELEASE(pFrame);

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);

                RELEASE(iclass);
                delete [] nameAlloc;
                return (NULL);
            }
        }
        else
        {
            if (!silently)
                Error(L"%s is not a static field.\n", nameAlloc);
            
            delete [] nameAlloc;
            return (NULL);
        }
    }
    
    delete [] nameAlloc;

    //
    // Now look for suffixes to the name
    //
    _ASSERTE(value != NULL);
    
    while (TRUE)
    {
        // Skip white space 
        while (*p != L'\0' && iswspace(*p))
            p++;

        if (*p == L'\0')
            return (value);

        switch (*p)
        {
        case L'.':
            {
                p++;

                // Strip off any reference values.
                hr = StripReferences(&value, false);

                if (FAILED(hr) || value == NULL)
                {
                    Error(L"Cannot get field of non-object value.\n");

                    if (value)
                        RELEASE(value);

                    return NULL;
                }
                    
                // If we have a boxed object then unbox the little
                // fella...
                ICorDebugBoxValue *boxVal;
            
                if (SUCCEEDED(value->QueryInterface(IID_ICorDebugBoxValue,
                                                    (void **) &boxVal)))
                {
                    ICorDebugObjectValue *objVal;
                    hr = boxVal->GetObject(&objVal);
                
                    if (FAILED(hr))
                    {
                        ReportError(hr);
                        RELEASE(boxVal);
                        RELEASE(value);
                        return NULL;
                    }

                    RELEASE(boxVal);
                    RELEASE(value);

                    // Replace the current value with the unboxed object.
                    value = objVal;
                }
                    
                // Now we should have an object, or we're done.
                ICorDebugObjectValue *object;

                if (FAILED(value->QueryInterface(IID_ICorDebugObjectValue,
                                                 (void **)&object)))
                {
                    Error(L"Cannot get field of non-object value.\n");
                    RELEASE(value);
                    return NULL;
                }

                RELEASE(value);

                // Get class & module
                ICorDebugClass *iclass;
                hr = object->GetClass(&iclass);

                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    RELEASE(object);
                    return (NULL);
                }

                ICorDebugModule *imodule;
                hr = iclass->GetModule(&imodule);

                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    RELEASE(object);
                    RELEASE(iclass);
                    return (NULL);
                }

                m = DebuggerModule::FromCorDebug(imodule);
                _ASSERTE(m != NULL);

                hr = iclass->GetToken(&td);

                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    RELEASE(object);
                    RELEASE(iclass);
                    return (NULL);
                }

                RELEASE(iclass);
                RELEASE(imodule);

                //
                // Get field name
                //

                const WCHAR *field = p;

                while (*p && !iswspace(*p) && *p != '[' && *p != '.')
                    p++;

                if (p == field)
                {
                    Error(L"Syntax error, field name missing in %s\n", exp);
                    return (NULL);
                }

                CQuickBytes fieldBuf;
                WCHAR *fieldAlloc = (WCHAR *) fieldBuf.Alloc((p - field + 1) * sizeof(WCHAR));
                if (fieldAlloc == NULL)
                {
                    Error(L"Couldn't get enough memory to get the field's name!\n");
                    return (NULL);
                }
                wcsncpy(fieldAlloc, field, p - field);
                fieldAlloc[p-field] = L'\0';

                // Lookup field
                mdFieldDef fd = mdFieldDefNil;
                bool isStatic;
                
                hr = ResolveQualifiedFieldName(m, td, fieldAlloc,
                                               &m, &td, &iclass, &fd,
                                               &isStatic);

                if (FAILED(hr))
                {
                    Error(L"Field %s not found.\n", fieldAlloc);

                    RELEASE(object);
                    return (NULL);
                }

                _ASSERTE(object != NULL);

                if (!isStatic)
                    object->GetFieldValue(iclass, fd, &value);
                else
                {
                    // We'll let the user look at static fields as if
                    // they belong to objects.
                    iclass->GetStaticFieldValue(fd, NULL, &value);
                }

                RELEASE(iclass);
                RELEASE(object);

                break;
            }

        case L'[':
            {
                if (!context)
                {
                    Error(L"Must have a context to display array.\n");
                    return (NULL);
                }

                if (value == NULL)
                {
                    Error(L"Cannot index a class.\n");
                    return (NULL);
                }

                // Strip off any reference values.
                hr = StripReferences(&value, false);

                if (FAILED(hr) || value == NULL)
                {
                    Error(L"Cannot index non-array value.\n");

                    if (value)
                        RELEASE(value);

                    return NULL;
                }
                    
                // Get Array interface
                ICorDebugArrayValue *array;
                hr = value->QueryInterface(IID_ICorDebugArrayValue,
                                           (void**)&array);

                RELEASE(value);
                
                if (FAILED(hr))
                {
                    Error(L"Cannot index non-array value.\n");
                    return (NULL);
                }

                _ASSERTE(array != NULL);

                // Get the rank
                ULONG32 rank;
                hr = array->GetRank(&rank);

                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    RELEASE(array);
                    return NULL;
                }

                ULONG32 *indicies = (ULONG32*) _alloca(rank * sizeof(ULONG32));

                hr = GetArrayIndicies((WCHAR**)&p, context, rank, indicies);

                if (FAILED(hr))
                {
                    Error(L"Error getting array indicies.\n");
                    RELEASE(array);
                    return NULL;
                }

                // Get element.
                hr = array->GetElement(rank, indicies, &value);

                RELEASE(array);
                
                if (FAILED(hr))
                {
                    if (hr == E_INVALIDARG)
                        Error(L"Array index out of range.\n");
                    else
                    {
                        Error(L"Error getting array element: ");
                        ReportError(hr);
                    }
                    
                    return (NULL);
                }

                break;
            }
        default:
            Error(L"syntax error, unrecognized character \'%c\'.\n", *p);
            if (value != NULL)
                RELEASE(value);
            return (NULL);
        }
    }
}


HRESULT CheckForGeneratedName( bool fVar,
    ICorDebugILFrame *context, WCHAR *name,ICorDebugValue **ppiRet )
{
    WCHAR *wszVarType;

    if (fVar == true)
        wszVarType = L"var";
    else
        wszVarType = L"arg";
    
    if (_wcsnicmp( name, wszVarType, wcslen(wszVarType))==0)
    {
        //extract numeric & go looking for it.
        WCHAR *wszVal = (WCHAR*)(name + wcslen(wszVarType));
        WCHAR *wszStop = NULL;
        if (wcslen(wszVal)==0 )
            return E_FAIL;
        
        long number = wcstoul(wszVal, &wszStop, 10);
        if (fVar == true)
            return context->GetLocalVariable(number, ppiRet);
        else
            return context->GetArgument(number, ppiRet);
    }

    return E_FAIL;
}

ICorDebugValue *DebuggerShell::EvaluateName(const WCHAR *name,
                                            ICorDebugILFrame *context,
                                            bool *unavailable)
{
    HRESULT hr;
    ICorDebugValue* piRet = NULL;
    unsigned int i;
    unsigned int argCount;

    *unavailable = false;

    // At times, it may be reasonable to have no current managed frame
    // but still want to attempt to display some pseudo-variables. So
    // if we don't have a context, skip most of the work.
    if (context == NULL)
        goto NoContext;
    
    ICorDebugCode *icode;
    hr = context->GetCode(&icode);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return (NULL);
    }

    ICorDebugFunction *ifunction;
    hr = icode->GetFunction(&ifunction);

    RELEASE(icode);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return (NULL);
    }

    DebuggerFunction *function;
    function = DebuggerFunction::FromCorDebug(ifunction);
    _ASSERTE(function != NULL);

    RELEASE(ifunction);

    //
    // Look for local variable.
    //

    ULONG32 ip;
    CorDebugMappingResult mappingResult;
    context->GetIP(&ip, &mappingResult);

    DebuggerVariable *localVars;
    localVars = NULL;
    unsigned int localVarCount;

    function->GetActiveLocalVars(ip, &localVars, &localVarCount);
    _ASSERTE((localVarCount == 0 && localVars == NULL) ||
             (localVarCount > 0 && localVars != NULL));

    for (i = 0; i < localVarCount; i++)
    {
        DebuggerVariable* pVar = &(localVars[i]);
        _ASSERTE(pVar && pVar->m_name);

        if (wcscmp(name, pVar->m_name) == 0)
        {
            hr = context->GetLocalVariable(pVar->m_varNumber, &piRet);

            if (FAILED(hr))
            {
                *unavailable = true;
                delete [] localVars;
                return (NULL);
            }
            else
            {
                delete [] localVars;
                return (piRet);
            }
        }
    }

    delete [] localVars;

    //
    // Look for an argument
    //
    for (i = 0, argCount = function->GetArgumentCount(); i < argCount; i++)
    {
        DebuggerVarInfo* arg = function->GetArgumentAt(i);

        if (arg != NULL && arg->name != NULL)
        {
            //@TODO: Remove when DbgMeta becomes unicode
            MAKE_WIDEPTR_FROMUTF8(wArgName, arg->name);

            if (wcscmp(name, wArgName) == 0)
            {
                hr = context->GetArgument(arg->varNumber, &piRet);

                if (FAILED(hr))
                {
                    *unavailable = true;
                    return (NULL);
                }
                else
                    return (piRet);
            }
        }
    }

    // at this point we haven't found anything, so assume that
    // the user simply wants to see the nth arg or var.
    // NOTE that this looks the same as what's printed out when
    // we don't have any debugging metadata for the variables
    if ( !FAILED(CheckForGeneratedName( true, context, (WCHAR*)name, &piRet)))
    {
        return piRet;
    }
    
    if ( !FAILED(CheckForGeneratedName( false, context, (WCHAR*)name, &piRet)))
    {
        return piRet;
    }

NoContext:
    // Do they want to see the result of the last func eval?
    if (!_wcsicmp(name, L"$result"))
    {
        if (m_currentThread != NULL)
        {
            // Grab our managed thread object.
            DebuggerManagedThread *dmt =
                GetManagedDebuggerThread(m_currentThread);
            _ASSERTE(dmt != NULL);

            // Is there an eval to get a result from?
            if (dmt->m_lastFuncEval)
            {
                hr = dmt->m_lastFuncEval->GetResult(&piRet);

                if (SUCCEEDED(hr))
                    return piRet;
            }
        }
    }

    // Do they want to see the thread object?
    if (!_wcsicmp(name, L"$thread"))
    {
        if (m_currentThread != NULL)
        {
            // Grab our managed thread object.
            hr = m_currentThread->GetObject (&piRet);

            if (SUCCEEDED(hr))
            {
                return piRet;
            }
        }
    }

    // Do they want to see the last exception on this thread?
    if (!_wcsicmp(name, L"$exception"))
    {
        if (m_currentThread != NULL)
        {
            hr = m_currentThread->GetCurrentException(&piRet);

            if (SUCCEEDED(hr))
                return piRet;
        }
    }
    
    return (NULL);
}

//
// Strip all references off of the given value. This simply
// dereferences through references until it hits a non-reference
// value.
//
HRESULT DebuggerShell::StripReferences(ICorDebugValue **ppValue,
                                       bool printAsYouGo)
{
    HRESULT hr = S_OK;
    
    while (TRUE)
    {
        ICorDebugReferenceValue *reference;
        hr = (*ppValue)->QueryInterface(IID_ICorDebugReferenceValue, 
                                        (void **) &reference);

        if (FAILED(hr))
        {
            hr = S_OK;
            break;
        }

        // Check for NULL
        BOOL isNull;
        hr = reference->IsNull(&isNull);

        if (FAILED(hr))
        {
            RELEASE(reference);
            RELEASE((*ppValue));
            *ppValue = NULL;
            break;
        }

        if (isNull)
        {
            if (printAsYouGo)
                Write(L"<null>");
            
            RELEASE(reference);
            RELEASE((*ppValue));
            *ppValue = NULL;
            break;
        }

        CORDB_ADDRESS realObjectPtr;
        hr = reference->GetValue(&realObjectPtr);

        if (FAILED(hr))
        {
            RELEASE(reference);
            RELEASE((*ppValue));
            *ppValue = NULL;
            break;
        }

        // Dereference the thing...
        ICorDebugValue *newValue;
        hr = reference->Dereference(&newValue);
            
        if (hr != S_OK)
        {
            if (printAsYouGo)
                if (hr == CORDBG_E_BAD_REFERENCE_VALUE)
                    Write(L"<invalid reference: 0x%p>", realObjectPtr);
                else if (hr == CORDBG_E_CLASS_NOT_LOADED)
                    Write(L"(0x%p) Note: CLR error -- referenced class "
                          L"not loaded.", realObjectPtr);
                else if (hr == CORDBG_S_VALUE_POINTS_TO_VOID)
                    Write(L"0x%p", realObjectPtr);

            RELEASE(reference);;
            RELEASE((*ppValue));
            *ppValue = NULL;
            break;
        }

        if (printAsYouGo)
            Write(L"(0x%08x) ", realObjectPtr);
        
        RELEASE(reference);

        RELEASE((*ppValue));
        *ppValue = newValue;
    }

    return hr;
}


#define GET_VALUE_DATA(pData, size, icdvalue)                   \
    _ASSERTE(icdvalue);                                         \
    ICorDebugGenericValue *__gv##icdvalue;                      \
    HRESULT __hr##icdvalue = icdvalue->QueryInterface(          \
                               IID_ICorDebugGenericValue,       \
                               (void**) &__gv##icdvalue);       \
    if (FAILED(__hr##icdvalue))                                 \
    {                                                           \
        g_pShell->ReportError(__hr##icdvalue);                  \
        goto exit;                                              \
    }                                                           \
    ULONG32 size;                                               \
    __hr##icdvalue = __gv##icdvalue->GetSize(&size);            \
    if (FAILED(__hr##icdvalue))                                 \
    {                                                           \
        g_pShell->ReportError(__hr##icdvalue);                  \
        RELEASE(__gv##icdvalue);                                \
        goto exit;                                              \
    }                                                           \
    void* pData = (void*) _alloca(size);                        \
    __hr##icdvalue = __gv##icdvalue->GetValue(pData);           \
    if (FAILED(__hr##icdvalue))                                 \
    {                                                           \
        g_pShell->ReportError(__hr##icdvalue);                  \
        RELEASE(__gv##icdvalue);                                \
        goto exit;                                              \
    }                                                           \
    RELEASE(__gv##icdvalue);

//
// Print a variable. There are a lot of options here to handle lots of
// different kinds of variables. If subfieldName is set, then it is a
// field within an object to be printed. The indent is used to keep
// indenting proper for recursive calls, and expandObjects allows you
// to specify wether or not you want the fields of an object printed.
//
void DebuggerShell::PrintVariable(const WCHAR *name,
                                  ICorDebugValue *ivalue,
                                  unsigned int indent,
                                  BOOL expandObjects)
{
    HRESULT hr;

    // Print the variable's name first.
    PrintVarName(name);

    // Strip off any reference values before the real value
    // automatically.  Note: this will release the original
    // ICorDebugValue if it is actually dereferenced for us.
    hr = StripReferences(&ivalue, true);

    if (FAILED(hr) && !((hr == CORDBG_E_BAD_REFERENCE_VALUE) ||
                        (hr == CORDBG_E_CLASS_NOT_LOADED) ||
                        (hr == CORDBG_S_VALUE_POINTS_TO_VOID)))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    if ((ivalue == NULL) || (hr != S_OK))
        return;
    
    // Grab the element type.
    CorElementType type;
    hr = ivalue->GetType(&type);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    // Basic types are all printed pretty much the same. See the macro
    // GET_VALUE_DATA for some of the details.
    switch (type)
    {
    case ELEMENT_TYPE_BOOLEAN:
        {
            GET_VALUE_DATA(b, bSize, ivalue);
            _ASSERTE(bSize == sizeof(BYTE));
            Write(L"%s", (*((BYTE*)b) == FALSE) ? L"false" : L"true");
            break;
        }

    case ELEMENT_TYPE_CHAR:
        {
            GET_VALUE_DATA(ch, chSize, ivalue);
            _ASSERTE(chSize == sizeof(WCHAR));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%.2x", *((WCHAR*) ch));
            else
                Write(L"'%c'", *((WCHAR*) ch));
            break;
        }

    case ELEMENT_TYPE_I1:
        {
            GET_VALUE_DATA(i1, i1Size, ivalue);
            _ASSERTE(i1Size == sizeof(BYTE));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%.2x", *((BYTE*) i1) );
            else
                Write(L"'%d'", *((BYTE*) i1) );
            break;

        }

    case ELEMENT_TYPE_U1:
        {
            //@todo: this is supiciously similar to I1, above
            GET_VALUE_DATA(ui1, ui1Size, ivalue);
            _ASSERTE(ui1Size == sizeof(BYTE));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%.2x",  *((BYTE*) ui1));
            else
                Write(L"'%d",  *((BYTE*) ui1));
            break;
        }

    case ELEMENT_TYPE_I2:
        {
            GET_VALUE_DATA(i2, i2Size, ivalue);
            _ASSERTE(i2Size == sizeof(short));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%.4x", *((short*) i2) );
            else
                Write(L"%d", *((short*) i2));
            break;
        }

    case ELEMENT_TYPE_U2:
        {
            GET_VALUE_DATA(ui2, ui2Size, ivalue);
            _ASSERTE(ui2Size == sizeof(unsigned short));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%.4x", *((unsigned short*) ui2) );
            else
                Write(L"%d", *((unsigned short*) ui2));
            break;
        }

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_I:
        {
            GET_VALUE_DATA(i4, i4Size, ivalue);
            _ASSERTE(i4Size == sizeof(int));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%.8x", *((int*) i4) );
            else
                Write(L"%d", *((int*) i4));
            break;
        }

    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_U:
        {
            GET_VALUE_DATA(ui4, ui4Size, ivalue);
            _ASSERTE(ui4Size == sizeof(unsigned int));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%.8x", *((unsigned int*) ui4) );
            else
                Write(L"%d", *((unsigned int*) ui4));
            break;
        }

    case ELEMENT_TYPE_I8:
        {
            GET_VALUE_DATA(i8, i8Size, ivalue);
            _ASSERTE(i8Size == sizeof(__int64));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%I64x", *((__int64*) i8) );
            else
                Write(L"%I64d", *((__int64*) i8));
            break;
        }

    case ELEMENT_TYPE_U8:
        {
            GET_VALUE_DATA(ui8, ui8Size, ivalue);
            _ASSERTE(ui8Size == sizeof(unsigned __int64));
            if ( m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
                Write( L"0x%I64x", *((unsigned __int64*) ui8) );
            else            
                Write(L"%I64d", *((unsigned __int64*) ui8) );
            break;
        }

    case ELEMENT_TYPE_R4:
        {
            GET_VALUE_DATA(f4, f4Size, ivalue);
            _ASSERTE(f4Size == sizeof(float));
            Write(L"%.16g", *((float*) f4));
            break;
        }

    case ELEMENT_TYPE_R8:
        {
            GET_VALUE_DATA(f8, f8Size, ivalue);
            _ASSERTE(f8Size == sizeof(double));
            Write(L"%.16g", *((double*) f8));
            break;
        }

    //
    // @todo: replace MDARRAY with ARRAY when the time comes.
    //
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_SZARRAY:
    case ELEMENT_TYPE_ARRAY:
    case ELEMENT_TYPE_VALUETYPE:
        {
            // If we have a boxed object then unbox the little fella...
            ICorDebugBoxValue *boxVal;
            
            if (SUCCEEDED(ivalue->QueryInterface(IID_ICorDebugBoxValue,
                                                 (void **) &boxVal)))
            {
                ICorDebugObjectValue *objVal;
                hr = boxVal->GetObject(&objVal);
                
                if (FAILED(hr))
                {
                    ReportError(hr);
                    RELEASE(boxVal);
                    break;
                }

                RELEASE(boxVal);
                RELEASE(ivalue);

                // Replace the current value with the unboxed object.
                ivalue = objVal;

                Write(L"(boxed) ");
            }

            // Is this object a string object?
            ICorDebugStringValue *istring;
            hr = ivalue->QueryInterface(IID_ICorDebugStringValue, 
                                        (void**) &istring);

            // If it is a string, print it out.
            if (SUCCEEDED(hr))
            {
                PrintStringVar(istring, name, indent, expandObjects);
                break;
            }

            // Might be an array...
            ICorDebugArrayValue *iarray;
            hr = ivalue->QueryInterface(IID_ICorDebugArrayValue, 
                                        (void **) &iarray);

            if (SUCCEEDED(hr))
            {
                PrintArrayVar(iarray, name, indent, expandObjects);
                break;
            }
            
            // It had better be an object by this point...
            ICorDebugObjectValue *iobject;
            hr = ivalue->QueryInterface(IID_ICorDebugObjectValue, 
                                        (void **) &iobject);

            if (SUCCEEDED(hr))
            {
                PrintObjectVar(iobject, name, indent, expandObjects);
                break;
            }

            // Looks like we've got a bad object here...
            ReportError(hr);
            break;
        }

    case ELEMENT_TYPE_BYREF: // should never have a BYREF here.
    case ELEMENT_TYPE_PTR: // should never have a PTR here.
    case ELEMENT_TYPE_TYPEDBYREF: // should never have a REFANY here.
    default:
        Write(L"[unknown variable type 0x%x]", type);
    }

exit:    
    RELEASE(ivalue);
}

void DebuggerShell::PrintArrayVar(ICorDebugArrayValue *iarray,
                                  const WCHAR* name,
                                  unsigned int indent,
                                  BOOL expandObjects)
{
    HRESULT hr;
    ULONG32 *dims;
    ULONG32 *bases = NULL;
    unsigned int i;
    
    // Get the rank
    ULONG32 rank;
    hr = iarray->GetRank(&rank);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    // Get the element count
    ULONG32 elementCount;
    hr = iarray->GetCount(&elementCount);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    // Get the dimensions
    dims = (ULONG32*)_alloca(rank * sizeof(ULONG32));
    hr = iarray->GetDimensions(rank, dims);
    
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    Write(L"array with dims=");

    for (i = 0; i < rank; i++)
        Write(L"[%d]", dims[i]);
    
    // Does it have base indicies?
    BOOL hasBaseIndicies;
    hr = iarray->HasBaseIndicies(&hasBaseIndicies);
    
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    if (hasBaseIndicies)
    {
        bases = (ULONG32*)_alloca(rank * sizeof(ULONG32));
        hr = iarray->GetBaseIndicies(rank, bases);
        
        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            goto exit;
        }

        Write(L", bases=");

        for (i = 0; i < rank; i++)
            Write(L"[%d]", bases[i]);
    }
    
    // Get the element type of the array
    CorElementType arrayType;
    hr = iarray->GetElementType(&arrayType);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    // If desired, print out the contents of the array, if not void.
    if (arrayType != ELEMENT_TYPE_VOID && expandObjects && rank == 1)
    {
        // Get and print each element of the array
        for (SIZE_T i = 0; i < elementCount; i++)
        {
            Write(L"\n");
            PrintIndent(indent + 1);

            if (bases != NULL)
                Write(L"%s[%d] = ", name, i + bases[0]);
            else
                Write(L"%s[%d] = ", name, i);

            ICorDebugValue *ielement;
            hr = iarray->GetElementAtPosition(i, &ielement);

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);
                goto exit;
            }

            PrintVariable(NULL, ielement, indent + 1, FALSE);
        }
    }

exit:
    RELEASE(iarray);
}

void DebuggerShell::PrintStringVar(ICorDebugStringValue *istring,
                                   const WCHAR* name,
                                   unsigned int indent,
                                   BOOL expandObjects)
{
    CQuickBytes sBuf;
    WCHAR *s = NULL;

    _ASSERTE(istring != NULL);

    // Get the string
    ULONG32 count;
    HRESULT hr = istring->GetLength(&count);
                    
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto LExit;
   }

    s = (WCHAR*) sBuf.Alloc((count + 1) * sizeof(WCHAR));

    if (s == NULL)
    {
        g_pShell->Error(L"Couldn't allocate enough space for string!\n");
        goto LExit;
    }
    
    if (count > 0)
    {   
        hr = istring->GetString(count, &count, s);
                
        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            goto LExit;
        }
    }

    // Null terminate it
    s[count] = L'\0';

    // This will convert all embedded NULL's into spaces
    {
        WCHAR *pStart = &s[0];
        WCHAR *pEnd = &s[count];

        while (pStart != pEnd)
        {
            if (*pStart == L'\0')
            {
                *pStart = L' ';
            }

            pStart++;
        }
    }

    Write(L"\"");

    if (FAILED(Write(L"%s",s)))
        WriteBigString(s, count);
        
    Write(L"\"");

LExit:
    RELEASE(istring);

    return;
}


void DebuggerShell::PrintObjectVar(ICorDebugObjectValue *iobject,
                                   const WCHAR* name,
                                   unsigned int indent,
                                   BOOL expandObjects)
{
    HRESULT hr = S_OK;
    
    _ASSERTE(iobject != NULL);

    DebuggerModule *dm;

    // Snagg the object's class.
    ICorDebugClass *iclass = NULL;
    hr = iobject->GetClass(&iclass);
    
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    // Get the class's token
    mdTypeDef tdClass;
    _ASSERTE(iclass != NULL);
    hr = iclass->GetToken(&tdClass);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        RELEASE(iclass);
        goto exit;
    }

    // Get the module from this class
    ICorDebugModule *imodule;
    iclass->GetModule(&imodule);
    RELEASE(iclass);
    iclass = NULL;
    
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    dm = DebuggerModule::FromCorDebug(imodule);
    _ASSERTE(dm != NULL);
    RELEASE(imodule);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    // Get the class name
    WCHAR       className[MAX_CLASSNAME_LENGTH];
    ULONG       classNameSize;
    mdToken     parentTD;

    hr = dm->GetMetaData()->GetTypeDefProps(tdClass,
                                            className, MAX_CLASSNAME_LENGTH,
                                            &classNameSize, 
                                            NULL, &parentTD);
    
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        goto exit;
    }

    Write(L"<%s>", className);

    // Print all the members of this object.
    if (expandObjects)
    {
        BOOL isValueClass = FALSE;

        hr = iobject->IsValueClass(&isValueClass);
        _ASSERTE(SUCCEEDED(hr));

        BOOL anyMembers = FALSE;
        BOOL isSuperClass = FALSE;

        do
        {
            if (isSuperClass)
            {
                hr = dm->GetMetaData()->GetTypeDefProps(tdClass,
                                            className, MAX_CLASSNAME_LENGTH,
                                            &classNameSize, 
                                            NULL, &parentTD);

                if (FAILED(hr))
                    break;
            }
    
            // Snagg the ICorDebugClass we're working with now...
            hr = dm->GetICorDebugModule()->GetClassFromToken(tdClass, &iclass);

            if (FAILED(hr))
                break;
            
            HCORENUM fieldEnum = NULL;

            while (TRUE)
            {
                // Get the fields one at a time
                mdFieldDef field[1];
                ULONG numFields = 0;

                hr = dm->GetMetaData()->EnumFields(&fieldEnum,
                                                   tdClass, field, 1,
                                                   &numFields);

                // No fields left
                if (SUCCEEDED(hr) && (numFields == 0))
                    break;
                // Error
                else if (FAILED(hr))
                    break;

                // Get the field properties
                WCHAR name[MAX_CLASSNAME_LENGTH];
                ULONG nameLen = 0;
                DWORD attr = 0;
                            
                hr = dm->GetMetaData()->GetFieldProps(field[0],
                                                      NULL,
                                                      name,
                                                      MAX_CLASSNAME_LENGTH,
                                                      &nameLen,
                                                      &attr,
                                                      NULL, NULL,
                                                      NULL, NULL, NULL);

                if (FAILED(hr))
                    break;

                // If it's not a static field
                if (((attr & fdStatic) == 0) ||
                    (m_rgfActiveModes & DSM_SHOW_STATICS_ON_PRINT))
                {
                    Write(L"\n");
                    PrintIndent(indent + 1);

                    if (isSuperClass &&
                        (m_rgfActiveModes & DSM_SHOW_SUPERCLASS_ON_PRINT))
                    {
                        // Print superclass field qualifiers in the
                        // syntax required to print them (i.e., use ::
                        // for the seperator in the namespace.
                        WCHAR *pc = className;

                        while (*pc != L'\0')
                        {
                            if (*pc == L'.')
                                Write(L"::");
                            else
                                Write(L"%c", *pc);

                            pc++;
                        }

                        Write(L"::");
                    }

                    ICorDebugValue *fieldValue;

                    if (attr & fdStatic)
                    {
                        Write(L"<static> ");
                    
                        // We'll let the user look at static fields as if
                        // they belong to objects.
                        hr = iclass->GetStaticFieldValue(field[0], NULL,
                                                         &fieldValue);
                    }
                    else
                        hr = iobject->GetFieldValue(iclass, field[0],
                                                    &fieldValue);

                    if (FAILED(hr))
                    {
                        if (hr == CORDBG_E_FIELD_NOT_AVAILABLE ||
                            hr == CORDBG_E_ENC_HANGING_FIELD)
                            Write(L"%s -- field not available", name);
                        else if (hr == CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL)
                            Write(L"%s -- field is an optimized literal", name);
                        else
                            Write(L"%s -- error getting field: hr=0x%08x",
                                  name, hr);
                    }
                    else
                    {
                        PrintVariable(name, fieldValue, indent + 1, FALSE);
                        anyMembers = TRUE;
                    }
                }
            }

            RELEASE(iclass);

            // Release the field enumerator
            if (fieldEnum != NULL)
                dm->GetMetaData()->CloseEnum(fieldEnum);

            // Check for failure from within the loop...
            if (FAILED(hr))
            {
                ReportError(hr);
                goto exit;
            }

            // Repeat with the super class.
            isSuperClass = TRUE;
            tdClass = parentTD;

            if ((TypeFromToken(tdClass) == mdtTypeRef) &&
                (tdClass != mdTypeRefNil))
            {
                hr = ResolveTypeRef(dm, tdClass, &dm, &tdClass);

                if (FAILED(hr))
                {
                    ReportError(hr);
                    goto exit;
                }
            }

        } while ((tdClass != mdTypeDefNil) && (tdClass != mdTypeRefNil));

        // If this object has no members, lets go ahead and see if it has a size. If it does, then we'll just dump the
        // raw memory.
        if (!anyMembers && isValueClass)
        {
            ULONG32 objSize = 0;
        
            hr = iobject->GetSize(&objSize);

            if (SUCCEEDED(hr) && (objSize > 0))
            {
                BYTE *objContents = new BYTE[objSize];

                if (objContents != NULL)
                {
                    ICorDebugGenericValue *pgv = NULL;

                    hr = iobject->QueryInterface(IID_ICorDebugGenericValue, (void**)&pgv);

                    if (SUCCEEDED(hr))
                    {
                        hr = pgv->GetValue(objContents);

                        if (SUCCEEDED(hr))
                        {
                            Write(L"\nObject has no defined fields, but has a defined size of %d bytes.\n", objSize);
                            Write(L"Raw memory dump of object follows:\n");
                            DumpMemory(objContents, PTR_TO_CORDB_ADDRESS(objContents), objSize, 4, 4, FALSE);
                        }

                        pgv->Release();
                    }
                
                    delete [] objContents;
                }
            }
        }

        // If we're expanding and this is a value class, run
        // Object::ToString on it just for fun.
        if (isValueClass)
        {
            IUnknown *pObject = NULL;
            
            hr = iobject->GetManagedCopy(&pObject);

            if (SUCCEEDED(hr))
            {
                _Object *pIObject = NULL;
                
                hr = pObject->QueryInterface(IID_Object,
                                             (void**)&pIObject);

                if (SUCCEEDED(hr))
                {
                    BSTR bstr;

                    hr = pIObject->get_ToString(&bstr);

                    if (SUCCEEDED(hr))
                    {
                        PrintIndent(indent + 1);
                        Write(L"\nObject::ToString(%s) = %s", name, bstr);
                    }
                    else
                        Write(L"\nObject::ToString failed: 0x%08x", hr);

                    RELEASE(pIObject);
                }

                RELEASE(pObject);
            }
        }
    }

exit:
    RELEASE(iobject);
}

//
// Given a class name, find the DebuggerModule that it is in and its
// mdTypeDef token.
//
HRESULT DebuggerShell::ResolveClassName(WCHAR *className,
                                        DebuggerModule **pDM,
                                        mdTypeDef *pTD)
{
    HRESULT hr = S_OK;

    // Find the class, by name and namespace, in any module we've loaded.
    HASHFIND find;
    DebuggerModule *m;
    
    for (m = (DebuggerModule*) g_pShell->m_modules.FindFirst(&find);
         m != NULL;
         m = (DebuggerModule*) g_pShell->m_modules.FindNext(&find))
    {
        mdTypeDef td;
        hr = FindTypeDefByName(m, className, &td);
        
        if (SUCCEEDED(hr))
        {
            *pDM = m;
            *pTD = td;
            goto exit;
        }
    }

    hr = E_INVALIDARG;

exit:
    return hr;
}

//
// This will find a typedef in a module, even if its nested, so long
// as the name is specified correctly.
//
HRESULT DebuggerShell::FindTypeDefByName(DebuggerModule *m,
                                         WCHAR *className,
                                         mdTypeDef *pTD)
{
    HRESULT hr = S_OK;

    hr = m->GetMetaData()->FindTypeDefByName(className, mdTokenNil, pTD);

    if (!SUCCEEDED(hr))
    {
        WCHAR *cpy = new WCHAR[wcslen(className) + 1];
        wcscpy(cpy, className);

        WCHAR *ns;
        WCHAR *cl;
        
        cl = wcsrchr(cpy, L'.');

        if ((cl == NULL) || (cl == cpy))
        {
            ns = NULL;
            cl = cpy;
        }
        else
        {
            ns = cpy;
            *cl = L'\0';
            cl++;
        }

        if (ns != NULL)
        {
            mdTypeDef en;
            hr = FindTypeDefByName(m, cpy, &en);

            if (SUCCEEDED(hr))
                hr = m->GetMetaData()->FindTypeDefByName(cl, en, pTD);
        }

        delete cpy;
    }

    return hr;
}

//
// Given a DebuggerModule and a mdTypeRef token, resolve it to
// whatever DebuggerModule and mdTypeDef token the ref is refering to.
//
HRESULT DebuggerShell::ResolveTypeRef(DebuggerModule *currentDM,
                                      mdTypeRef tr,
                                      DebuggerModule **pDM,
                                      mdTypeDef *pTD)
{
    _ASSERTE(TypeFromToken(tr) == mdtTypeRef);

    // Get the name of the type ref.
    WCHAR className[MAX_CLASSNAME_LENGTH];
    HRESULT hr = currentDM->GetMetaData()->GetTypeRefProps(tr,
                                                           NULL,
                                                           className,
                                                           MAX_CLASSNAME_LENGTH,
                                                           NULL);
    if (FAILED(hr))
        return hr;

    return ResolveClassName(className, pDM, pTD);
}

//
// Split a name in the form "ns::ns::ns::class::field" into
// "ns.ns.ns.class" and "field". The output params need to be delete
// []'d by the caller.
//
HRESULT _splitColonQualifiedFieldName(WCHAR *pWholeName,
                                      WCHAR **ppClassName,
                                      WCHAR **ppFieldName)
{
    HRESULT hr = S_OK;
    
    // We're gonna be kinda gross about some of the allocations here,
    // basically over allocating for both the classname and the
    // fieldname.
    int len = wcslen(pWholeName);

    WCHAR *fn = NULL;
    WCHAR *cn = NULL;

    fn = new WCHAR[len+1];

    if (fn == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }
    
    cn = new WCHAR[len+1];

    if (cn == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }

    // Find the field name.
    WCHAR *lastColon;
    lastColon = wcsrchr(pWholeName, L':');

    if (lastColon)
    {
        // The field name is whatever is after the last colon.
        wcscpy(fn, lastColon + 1);

        // The class name is everything up to the last set of colons.
        WCHAR *tmp = pWholeName;
        WCHAR *newCn = cn;

        _ASSERTE(lastColon - 1 >= pWholeName);
        
        while (tmp < (lastColon - 1))
        {
            // We convert "::" to "."
            if (*tmp == L':')
            {
                *newCn++ = L'.';
                tmp++;

                if (*tmp != L':')
                {
                    // Badly formed name.
                    *ppClassName = NULL;
                    *ppFieldName = NULL;
                    hr = E_FAIL;
                    goto ErrExit;
                }
                else
                    tmp++;
            }
            else
                *newCn++ = *tmp++;
        }

        // Null terminate the class name.
        *newCn++ = L'\0';

        // Make sure we didn't go over our buffer.
        _ASSERTE((newCn - cn) < len);
    }
    else
    {
        // No separator for the field name, so the whole thing is the
        // field name.
        wcscpy(fn, pWholeName);
        wcscpy(cn, L"\0");
    }

    // All went well, so pass out the results.
    *ppClassName = cn;
    *ppFieldName = fn;

ErrExit:
    if ((hr != S_OK) && fn)
        delete [] fn;

    if ((hr != S_OK) && cn)
        delete [] cn;

    return hr;
}
                                   

HRESULT DebuggerShell::ResolveQualifiedFieldName(DebuggerModule *currentDM,
                                                 mdTypeDef currentTD,
                                                 WCHAR *fieldName,
                                                 DebuggerModule **pDM,
                                                 mdTypeDef *pTD,
                                                 ICorDebugClass **pIClass,
                                                 mdFieldDef *pFD,
                                                 bool *pbIsStatic)
{
    HRESULT hr = S_OK;

    // Separate the class name from the field name.
    WCHAR *fn = NULL;
    WCHAR *cn = NULL;

    hr = _splitColonQualifiedFieldName(fieldName, &cn, &fn);

    if (hr != S_OK)
        goto exit;

    _ASSERTE(fn && cn);
    
    // If there is no class name, then we must have current scoping info.
    if ((cn[0] == L'\0') &&
        ((currentDM == NULL) || (currentTD == mdTypeDefNil)))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // If we've got a specific class name to look for, go get it now.
    if (cn[0] != L'\0')
    {
        hr = ResolveClassName(cn, pDM, pTD);

        if (FAILED(hr))
            goto exit;
    }
    else
    {
        // No specific class name, so we're just using the existing
        // module and class.
        *pDM = currentDM;
        *pTD = currentTD;
    }

retry:
    // Now get the field off of this class.
    hr = (*pDM)->GetMetaData()->FindField(*pTD, fn, NULL, 0, pFD);

    if (FAILED(hr))
    {
        // Perhaps its a field on a super class?
        mdToken parentTD;
        hr = (*pDM)->GetMetaData()->GetTypeDefProps(*pTD,
                                                    NULL, 0, NULL,
                                                    NULL, 
                                                    &parentTD);

        if (SUCCEEDED(hr))
        {
            if ((TypeFromToken(parentTD) == mdtTypeRef) &&
                (parentTD != mdTypeRefNil))
            {
                hr = ResolveTypeRef(*pDM, parentTD, pDM, pTD);

                if (SUCCEEDED(hr))
                    goto retry;
            }
            else if ((TypeFromToken(parentTD) == mdtTypeDef) &&
                     (parentTD != mdTypeDefNil))
            {
                *pTD = parentTD;
                goto retry;
            }
        }

        hr = E_FAIL;
        goto exit;
    }

    if (TypeFromToken(*pFD) != mdtFieldDef)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Finally, figure out if its static or not.
    DWORD attr;
    hr = (*pDM)->GetMetaData()->GetFieldProps(*pFD, NULL, NULL, 0, NULL, &attr,
                                              NULL, NULL, NULL, NULL, NULL);

    if (FAILED(hr))
        return hr;

    if (attr & fdStatic)
        *pbIsStatic = true;
    else
        *pbIsStatic = false;
    
    // Get the ICorDebugClass to go with the class we're working with.
    hr = (*pDM)->GetICorDebugModule()->GetClassFromToken(*pTD, pIClass);

exit:
    if (fn)
        delete [] fn;

    if (cn)
        delete [] cn;

    return hr;
}


// Resolve a string method name to an ICorDebugFunction
// If pAppDomainHint is non-null, will pull a function from that AD.
HRESULT DebuggerShell::ResolveFullyQualifiedMethodName(
    WCHAR *methodName, 
    ICorDebugFunction **ppFunc, // out
    ICorDebugAppDomain * pAppDomainHint // = NULL
)
{
    HRESULT hr = S_OK;
    *ppFunc = NULL;
    
    // Split apart the name into namespace, class name, and method name if necessary.
    WCHAR *className = NULL;
    WCHAR *methName = NULL;

    // Does it have a classname?
    WCHAR *classEnd = wcschr(methodName, L':');

    if ((classEnd != NULL) && (classEnd[1] == L':'))
    {
        // Name is class::method
        methName = classEnd + 2;
        *classEnd = L'\0';
        className = methodName;
    }
    else
        methName = methodName;

    // Whip over the modules looking for either our class or the method (since the method could be global.)
    HASHFIND find;
    DebuggerModule *m;
    
    for (m = (DebuggerModule*) m_modules.FindFirst(&find); m != NULL; m = (DebuggerModule*) m_modules.FindNext(&find))
    {
        // If we need a specific AD, make sure this matches
        if (pAppDomainHint != NULL)
        {
            // Get the ICorDebugAppDomain that this module lives in.
            ICorDebugAssembly * pAssembly = NULL;
            ICorDebugAppDomain * pAppDomain = NULL;
            ICorDebugModule * pModule = NULL;

            pModule = m->GetICorDebugModule(); // doesn't addref
            if (pModule != NULL)
            {
                pModule->GetAssembly(&pAssembly);
                // don't release module here because our getter didn't addref.
                
                if (pAssembly != NULL)
                {                            
                    pAssembly->GetAppDomain(&pAppDomain);
                    pAssembly->Release();

                    const bool fMatch = (pAppDomain == pAppDomainHint);
                    
                    if (pAppDomain != NULL)
                    {       
                        pAppDomain->Release();
                        
                        // If the module doesn't match the appdomain we're looking for, don't match it.
                        if (!fMatch)
                            continue;                
                    }
                } // assembly
            } // module
        } // end check AppDomain match
        
    
        // Look for the type first, if we have one.
        mdTypeDef td = mdTypeDefNil;

        // @todo:  Make this work right for Nested classes.
        if (className != NULL)
            hr = FindTypeDefByName(m, className, &td);

        // Whether we found the type or not, look for a method within the type. If we didn't find the type, then td ==
        // mdTypeDefNil and we'll search the global namespace in this module.
        HCORENUM e = NULL;
        mdMethodDef md = mdMethodDefNil;
        ULONG count;

        // Create an enum of all the methods with this name.
        hr = m->GetMetaData()->EnumMethodsWithName(&e, td, methName, NULL, 0, &count);

        if (FAILED(hr))
            continue;

        // Figure out how many methods match.
        hr = m->GetMetaData()->CountEnum(e, &count);
        
        if (FAILED(hr) || (count == 0))
            continue;

        // Put the enum back at the start.
        hr = m->GetMetaData()->ResetEnum(e, 0);

        if (count == 1)
        {
            // If there is only one, go ahead and use it.
            hr = m->GetMetaData()->EnumMethodsWithName(&e, td, methName, &md, 1, &count);
            _ASSERTE(count == 1);
        }
        else
        {
            // If there are many, get the user to pick just one.
            mdMethodDef *mdArray = new mdMethodDef[count];

            if (mdArray == NULL)
            {
                g_pShell->ReportError(E_OUTOFMEMORY);
                continue;
            }

            // Snagg all of the methods.
            hr = m->GetMetaData()->EnumMethodsWithName(&e, td, methName, mdArray, count, &count);

            if (SUCCEEDED(hr))
            {
                g_pShell->Write(L"There are %d possible matches for the method %s. Pick one:\n", count, methName);
                g_pShell->Write(L"0) none, abort the operation.\n");
                
                for (unsigned int i = 0; i < count; i++)
                {
                    PCCOR_SIGNATURE sigBlob = NULL;
                    ULONG       sigBlobSize = 0;
                    DWORD       methodAttr = 0;

                    hr = m->GetMetaData()->GetMethodProps(mdArray[i], NULL, NULL, 0, NULL,
                                                          &methodAttr, &sigBlob, &sigBlobSize, NULL, NULL);

                    _ASSERTE(SUCCEEDED(hr));

                    SigFormat *sf = new SigFormat(m->GetMetaData(), sigBlob, sigBlobSize, methName);

                    if (sf != NULL)
                        hr = sf->FormatSig();
                    else
                        hr = E_OUTOFMEMORY;
                    
                    g_pShell->Write(L"%d) [%08x] %s\n", i + 1, mdArray[i], SUCCEEDED(hr) ? sf->GetString() : methName);

                    if (sf != NULL)
                        delete sf;
                }

                g_pShell->Write(L"\nPlease make a selection (0-%d): ", count);
                
                WCHAR response[256];
                int ires = 0;

                hr = E_FAIL;
                
                if (ReadLine(response, 256))
                {
                    WCHAR *p = response;
                    
                    if (GetIntArg(p, ires))
                    {
                        if ((ires > 0) && (ires <= (int)count))
                        {
                            md = mdArray[ires - 1];
                            hr = S_OK;
                        }
                    }
                }
            }
            
            delete [] mdArray;
        }
        
        if (SUCCEEDED(hr))
        {
            DebuggerFunction *func = m->ResolveFunction(md, NULL);

            if (func != NULL)
            {
                *ppFunc = func->m_ifunction;
                (*ppFunc)->AddRef();
                break;
            }
        }
    }

    if (m == NULL)
        hr = E_INVALIDARG;
    
    // Leave the input string like we found it.
    if (classEnd)
        *classEnd = L':';
    
    return hr;
}

void DebuggerShell::PrintBreakpoint(DebuggerBreakpoint *breakpoint)
{
    bool bPrinted = false;

    DebuggerSourceFile *pSource = NULL;
    if (breakpoint->m_managed)
    {
        if ((breakpoint->m_doc != NULL) && (breakpoint->m_pModuleList != NULL))
        {
            if ((pSource = breakpoint->m_pModuleList->m_pModule->
                    ResolveSourceFile (breakpoint->m_doc)) != NULL)
            {
                if (pSource->GetPath() != NULL)
                {
                    g_pShell->Write(L"#%d\t%s:%d\t", breakpoint->m_id, 
                            pSource->GetPath(), breakpoint->m_index);

                    bPrinted = true;

                }
            }
        }
    }

    if (bPrinted == false)
    {
        DebuggerModule *m = NULL;
        WCHAR *pszModName = NULL;

        if (breakpoint->m_pModuleList != NULL)
        {
            m = breakpoint->m_pModuleList->m_pModule;
            _ASSERTE (m != NULL);

            if (m != NULL)
                pszModName = m->GetName();
        }
        else if (breakpoint->m_moduleName != NULL)
        {
            pszModName = breakpoint->m_moduleName;
        }

        if (pszModName == NULL)
            pszModName = L"<UnknownModule>";

        g_pShell->Write(L"#%d\t%s!%s:%d\t", breakpoint->m_id, 
                        pszModName, breakpoint->m_name, 
                        breakpoint->m_index);
    }

    if (breakpoint->m_threadID != NULL_THREAD_ID)
        g_pShell->Write(L"thread 0x%x ", breakpoint->m_threadID);

    if (!breakpoint->m_active)
        g_pShell->Write(L"[disabled]");

    if (breakpoint->m_managed)
    {
        if (breakpoint->m_pModuleList == NULL)
            g_pShell->Write(L"[unbound] ");
        else
        {
            DebuggerCodeBreakpoint *bp = breakpoint->m_pModuleList->m_pModule->m_breakpoints;

            while (bp != NULL)
            {
                if (bp->m_id == breakpoint->m_id)
                {
                    bp->Print();
                    break;
                }
                bp = bp->m_next;
            }
        }
    }
    else
    {
        if (breakpoint->m_process == NULL)
            g_pShell->Write(L"[unbound] ");
    }

    g_pShell->Write(L"\n");
    if (bPrinted == true)
    {
        // Also, check if the number of lines in the source 
        // file are >= line number we want to display
        if (pSource->TotalLines() < breakpoint->m_index)
        {
            // Warn user
            g_pShell->Write(L"WARNING: Cannot display source line %d.", breakpoint->m_index);
            g_pShell->Write(L" Currently associated source file %s has only %d lines.\n",
                            pSource->GetPath(), pSource->TotalLines());

        }
    }
}

void DebuggerShell::PrintThreadPrefix(ICorDebugThread *pThread, bool forcePrint)
{
    DWORD               threadID;

    if (pThread)
    {
        HRESULT hr = pThread->GetID(&threadID);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return;
        }

        if (threadID != m_lastThread || forcePrint)
        {
            Write(L"[thread 0x%x] ", threadID);
            m_lastThread = threadID;
        }
    }
    else
    {
        Write(L"[No Managed Thread] ");
    }
}

HRESULT DebuggerShell::StepStart(ICorDebugThread *pThread,
                                 ICorDebugStepper *pStepper)
{
    DWORD dwThreadId = 0;

    if( pThread != NULL )
    {
        //figure out which thread to stick the stepper to in case
        //we don't complete the step (ie, the program exits first)
        HRESULT hr = pThread->GetID( &dwThreadId);
        _ASSERTE( !FAILED( hr ) );

        DebuggerManagedThread  *dmt = (DebuggerManagedThread  *)
            m_managedThreads.GetBase( dwThreadId );
        _ASSERTE(dmt != NULL);

        //add this to the list of steppers-in-progress
        if (pStepper)
            dmt->m_pendingSteppers->AddStepper( pStepper );
    }
    
    m_lastStepper = pStepper;
    return S_OK;
}

//called by DebuggerCallback::StepComplete
void DebuggerShell::StepNotify(ICorDebugThread *thread, 
                               ICorDebugStepper *pStepper)
{
    g_pShell->m_enableCtrlBreak = false;
    if (pStepper != m_lastStepper)
    {   // mulithreaded debugging: the step just completed is in
        // a different thread than the one that we were last in,
        // so print something so the user will know what's going on.

        // It looks weird to have a thread be created and then immediately 
        // complete a step, so we first check to make sure that the thread
        // hasn't just been created.
        DWORD dwThreadId;
        HRESULT hr = thread->GetID( &dwThreadId);
        
        _ASSERTE( !FAILED( hr ) );

        DebuggerManagedThread  *dmt = (DebuggerManagedThread  *)
            m_managedThreads.GetBase( dwThreadId );
        _ASSERTE(dmt != NULL);

        if (!dmt->fSuperfluousFirstStepCompleteMessageSuppressed)
        {
           dmt->fSuperfluousFirstStepCompleteMessageSuppressed = true;
        }
        else
        {
            PrintThreadPrefix(thread);
            Write(L" step complete\n");
        }
    }

    m_lastStepper = NULL;

    //we've completed the step, so elim. the pending step field
    if (pStepper)
    {
        DebuggerManagedThread *dmt = GetManagedDebuggerThread( thread );
        _ASSERTE( dmt != NULL );
        _ASSERTE( dmt->m_pendingSteppers->IsStepperPresent(pStepper) );
        dmt->m_pendingSteppers->RemoveStepper(pStepper);
    }
}

//
// Print the current source line. The parameter around specifies how many
// lines around the current line you want printed, too. If around is 0,
// only the current line is printed.
//
BOOL DebuggerShell::PrintCurrentSourceLine(unsigned int around)
{
    HRESULT hr;
    BOOL ret = FALSE;

    if ((m_currentThread == NULL) && (m_currentUnmanagedThread != NULL))
        return PrintCurrentUnmanagedInstruction(around, 0, 0);
    
    // Don't do anything if there isn't a current thread.
    if ((m_currentThread == NULL) || (m_rawCurrentFrame == NULL))
        return (ret);

    // Just print native instruction if we dont have an IL frame
    if (m_currentFrame == NULL)
    {
        _ASSERTE(m_rawCurrentFrame);
        return (PrintCurrentInstruction(around, 0, 0));
    }

    ICorDebugCode *icode;
    hr = m_currentFrame->GetCode(&icode);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return (FALSE);
    }

    ICorDebugFunction *ifunction;
    icode->GetFunction(&ifunction);

    RELEASE(icode);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return (FALSE);
    }

    DebuggerFunction *function = DebuggerFunction::FromCorDebug(ifunction);
    _ASSERTE(function != NULL);

    RELEASE(ifunction);

    ULONG32 ip;
    CorDebugMappingResult mappingResult;
    hr = m_currentFrame->GetIP(&ip, &mappingResult);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return (FALSE);
    }

    DebuggerSourceFile* sf;
    unsigned int lineNumber;
    hr = function->FindLineFromIP(ip, &sf, &lineNumber);

    if (hr == S_OK)
        ret = sf->LoadText(m_currentSourcesPath, false);

    if (ret && (sf->TotalLines() > 0))
    {
        if (g_pShell->m_rgfActiveModes & DSM_ENHANCED_DIAGNOSTICS)
        {
            _ASSERTE(sf != NULL);
            Write(L"File:%s\n",sf->GetName());
        }
    
        unsigned int start, stop;

        if (lineNumber > around)
            start = lineNumber - around;
        else
            start = 1;

        if ((lineNumber + around) <= sf->TotalLines())
            stop = lineNumber + around;
        else
            stop = sf->TotalLines();

        while (start <= stop)
        {
            if ((start == lineNumber) && (around != 0))
                Write(L"%03d:*%s\n", start, sf->GetLineText(start));
            else
                Write(L"%03d: %s\n", start, sf->GetLineText(start));

            start++;

            ret = TRUE;
        }

        ActivateSourceView(sf, lineNumber);
    }

    if (!ret)
        return (PrintCurrentInstruction(around, 0, 0));
    else
        return (TRUE);
}

void DebuggerShell::ActivateSourceView(DebuggerSourceFile *psf, unsigned int lineNumber)
{
}


//
// InitDisassembler -- initialize a disassembler object for this method,
// if one is needed. We setup a DIS object for native methods. I don't
// know how hefty one of these are, or what the cost of creating one really
// is. Right now, I'm assuming that its cheaper to have one around only
// when needed rather than having one around for every method until the
// debugging session is done.
//
BOOL DebuggerShell::InitDisassembler(void)
{
#ifdef _INTERNAL_DEBUG_SUPPORT_
    if (m_pDIS == NULL)
    {
        //
        // We're delay loading the MSDIS DLL, and since this is the first
        // place where we'll every try to access it, we need to make sure
        // the load succeeds.
        //
        __try
        {
#ifdef _X86_
            m_pDIS = (DIS *)DIS::PdisNew(DIS::distX86);
#else
            m_pDIS = NULL;
#endif        
        }
        __except((GetExceptionCode() & 0x00ff) == ERROR_MOD_NOT_FOUND ?
                 EXCEPTION_EXECUTE_HANDLER :
                 EXCEPTION_CONTINUE_SEARCH)
        {
            m_pDIS = NULL;
        }
    }

#else

  	Write(L"Sorry, native disassembly is not supported.\n\n");  
#endif // _INTERNAL_DEBUG_SUPPORT_


    return (m_pDIS != NULL);
}


//
// Disassemble unmanaged code. This is different from disassembling
// managed code. For managed code, we know where the function starts
// and ends, and we get the code from a different place. For unmanaged
// code, we only know our current IP, and we have to guess at the
// start and end of the function.
//
BOOL DebuggerShell::PrintCurrentUnmanagedInstruction(
                                            unsigned int around,
                                            int          offset,
                                            DWORD        startAddr)
{
#ifdef _INTERNAL_DEBUG_SUPPORT_
    HRESULT hr;

    // Print out the disassembly around the current IP for unmanaged code.
    DebuggerUnmanagedThread *ut = m_currentUnmanagedThread;

    CONTEXT c;
    c.ContextFlags = CONTEXT_FULL;

    // If we have an unmanaged thread, and we have no current managed
    // frame info, then go ahead and use the context from the
    // unmanaged thread.
    if ((ut != NULL) && (m_rawCurrentFrame == NULL))
    {
        HANDLE hThread = ut->GetHandle();

        hr = m_targetProcess->GetThreadContext(ut->GetId(),
                                               sizeof(CONTEXT),
                                               (BYTE*)&c);

        if (!SUCCEEDED(hr))
        {
            Write(L"Failed to get context 0x%x\n", hr);
            return FALSE;
        }
    }
    else if (m_currentThread != NULL)
    {
        // If we have a current managed thread, use its context.
        ICorDebugRegisterSet *regSet = NULL;

        hr = m_currentThread->GetRegisterSet(&regSet);

        if (FAILED(hr))
        {
            ReportError(hr);
            return FALSE;
        }

        hr = regSet->GetThreadContext(sizeof(c), (BYTE*)&c);
    }
    else
    {
        Write(L"Thread no longer exists.");
        return FALSE;
    }

    if (startAddr == 0)
        startAddr = c.Eip;

    startAddr += offset;
    
    // Read two pages: the page at Eip and the page after. The one at
    // the start address had better succeed, but the other one may
    // fail, so we read one at a time.
#ifdef _X86_
#define PAGE_SIZE 4096
#else
#error "Platform NYI"
#endif
    
    BYTE pages[PAGE_SIZE * 2];
    memset(pages, 0xcc, sizeof(pages)); // fill with int 3's
    
    bool after = false;

    BYTE *readAddr = (BYTE*)(startAddr & ~(PAGE_SIZE - 1));

    DWORD read;

    // Read the current page
    hr = m_targetProcess->ReadMemory(PTR_TO_CORDB_ADDRESS(readAddr),
                                     PAGE_SIZE,
                                     pages,
                                     &read);

    if (read > PAGE_SIZE) // Win2k can be weird... 
        read = 0;

    if (!SUCCEEDED(hr) || (read == 0))
    {
        Write(L"Failed to read memory from address 0x%08x\n",
              readAddr);
        return FALSE;
    }

    // Go for the page after
    hr = m_targetProcess->ReadMemory(PTR_TO_CORDB_ADDRESS(readAddr + PAGE_SIZE),
                                     PAGE_SIZE,
                                     pages + PAGE_SIZE,
                                     &read);

    if (SUCCEEDED(hr))
        after = true;

    // Remove any unmanaged patches we may have placed in the code.
    DebuggerBreakpoint *b = m_breakpoints;

    while (b != NULL)
    {
        if ((b->m_managed == false) &&
            ((byte*)(b->m_address) >= readAddr) &&
            (b->m_address <  PTR_TO_CORDB_ADDRESS(readAddr + PAGE_SIZE * 2)))
        {
            SIZE_T delta = (SIZE_T)(b->m_address) - (SIZE_T)readAddr;

            pages[delta] = b->m_patchedValue;
        }

        b = b->m_next;
    }
    
    // Now, lets disassemble some code...
    BYTE *codeStart;
    BYTE *codeEnd;

    codeStart = pages;

    if (after)
        codeEnd = pages + (PAGE_SIZE * 2) - 1;
    else
        codeEnd = pages + PAGE_SIZE - 1;
    
    WCHAR s[1024];
    SIZE_T curOffset = (BYTE*)startAddr - readAddr;
    
    do
    {
        SIZE_T oldOffset = curOffset;
        
        curOffset = DebuggerFunction::Disassemble(TRUE,
                                                  curOffset,
                                                  codeStart,
                                                  codeEnd,
                                                  s,
                                                  TRUE,
                                                  NULL,
                                                  NULL);

        // If we failed to disassemble, then we're done.
        if ((curOffset == 0xffff) || (curOffset == oldOffset))
            break;

        if ((readAddr + oldOffset) == (BYTE*)c.Eip)
            Write(L"*[%08x] %s", readAddr + oldOffset, s);
        else
            Write(L" [%08x] %s", readAddr + oldOffset, s);
    }
    while (around-- && (curOffset < (PAGE_SIZE * 2)));
    
#else
	Write(L"Debug information may not be available.\n");
  	Write(L"Sorry, native disassembly is not supported.\n\n");  
#endif // _INTERNAL_DEBUG_SUPPORT_


    return TRUE;
}


//
// Print the current native instruction. The parameter around
// specifies how many lines around the current line you want printed,
// too. If around is 0, only the current line is printed.
//
BOOL DebuggerShell::PrintCurrentInstruction(unsigned int around,
                                            int          offset,
                                            DWORD        startAddr)
{
#ifdef _INTERNAL_DEBUG_SUPPORT_
    HRESULT hr;

    // Don't do anything if there isn't a current thread.
    if ((m_currentThread == NULL) && (m_currentUnmanagedThread == NULL))
        return (FALSE);

    // We do something very different for unmanaged code...
    if ((m_rawCurrentFrame == NULL) || (startAddr != 0))
        return PrintCurrentUnmanagedInstruction(around,
                                                offset,
                                                startAddr);
    
    ICorDebugCode *icode;
    hr = m_rawCurrentFrame->GetCode(&icode);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return (FALSE);
    }

    BOOL isIL;
    hr = icode->IsIL(&isIL);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        RELEASE(icode);
        return (FALSE);
    }

    ICorDebugFunction *ifunction;
    hr = icode->GetFunction(&ifunction);

    RELEASE(icode);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return (FALSE);
    }

    DebuggerFunction *function = DebuggerFunction::FromCorDebug(ifunction);
    _ASSERTE(function != NULL);

    RELEASE(ifunction);

    ULONG32 ip;
    CorDebugMappingResult mappingResult;

    if (isIL)
    {
        hr = m_currentFrame->GetIP(&ip, &mappingResult);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return (FALSE);
        }
    }
    else
    {
        ICorDebugNativeFrame *inativeFrame;
        hr = m_rawCurrentFrame->QueryInterface(IID_ICorDebugNativeFrame,
                                               (void **)&inativeFrame);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return (FALSE);
        }

        hr = inativeFrame->GetIP(&ip);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return (FALSE);
        }

        RELEASE(inativeFrame);
    }


    WCHAR buffer[1024];

    if (!isIL)
    {
        if (InitDisassembler() != TRUE)
        {
            Write(L"Unable to provide disassembly.\n");
            return (FALSE);
        }
    }

    if (FAILED(function->LoadCode(!isIL)))
    {
        Write(L"Unable to provide disassembly.\n");
        return (FALSE);
    }

    BYTE *codeStart;
    BYTE *codeEnd;

    if (isIL)
    {
        codeStart = function->m_ilCode;
        codeEnd = function->m_ilCode + function->m_ilCodeSize;
    }
    else
    {
        codeStart = function->m_nativeCode;
        codeEnd = function->m_nativeCode + function->m_nativeCodeSize;
    }
    
    if (around == 0)
    {
        DebuggerFunction::Disassemble(!isIL,
                                      ip,
                                      codeStart,
                                      codeEnd,
                                      buffer,
                                      FALSE,
                                      function->m_module,
                                      function->m_ilCode);

        Write(buffer);
    }
    else
    {
        // What a pain - we have to trace from the beginning of the method
        // to find the right instruction boundary.
        size_t currentAddress = ip;
        size_t address = 0;

        size_t endAddress = isIL ? function->m_ilCodeSize :
                                   function->m_nativeCodeSize; 

        unsigned int instructionCount = 0;
        while (address < currentAddress)
        {
            size_t oldAddress = address;

            address = function->WalkInstruction(!isIL,
                                                address,
                                                codeStart,
                                                codeEnd);

            if (address == 0xffff)
                break;

            // If the WalkInstruction didn't advance the address, then
            // break. This means that we failed to disassemble the
            // instruction.  get to next line
            if (address == oldAddress)
                break;

            instructionCount++;
        }

        // Now, walk forward again to get to the starting point.
        address = 0;

        while (around < instructionCount)
        {
            address = function->WalkInstruction(!isIL,
                                                address,
                                                codeStart,
                                                codeEnd);
            instructionCount--;
        }

        unsigned int i;

        for (i = 0; i < instructionCount; i++)
        {
            Write(L" ");
            address = DebuggerFunction::Disassemble(!isIL,
                                                    address,
                                                    codeStart,
                                                    codeEnd,
                                                    buffer,
                                                    FALSE,
                                                    function->m_module,
                                                    function->m_ilCode);
            Write(buffer);
        }

        Write(L"*");
        address = DebuggerFunction::Disassemble(!isIL,
                                                address,
                                                codeStart,
                                                codeEnd,
                                                buffer,
                                                FALSE,
                                                function->m_module,
                                                function->m_ilCode);
        Write(buffer);

        for (i = 0; i < around && address < endAddress; i++)
        {
            Write(L" ");
            address = DebuggerFunction::Disassemble(!isIL,
                                                    address,
                                                    codeStart,
                                                    codeEnd,
                                                    buffer,
                                                    FALSE,
                                                    function->m_module,
                                                    function->m_ilCode);
            Write(buffer);
        }
    }
    
#else
    Write(L"Debug information may not be available.\n");
    Write(L"Sorry, native disassembly is not supported.\n\n");  
#endif // _INTERNAL_DEBUG_SUPPORT_


    return TRUE;
}


//
// Open the registry key for persistent debugger settings.
// Returns FALSE if it fails.
//
BOOL DebuggerShell::OpenDebuggerRegistry(HKEY* key)
{
    DWORD disp;
    LONG result = RegCreateKeyExA(HKEY_CURRENT_USER, REG_DEBUGGER_KEY,
                                  NULL, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL, key, &disp);

    if (result == ERROR_SUCCESS)
        return (TRUE);

    Error(L"Error %d opening registry key for source file "
          L"path.\n", result);

    return (FALSE);
}

//
// Close the registry key for debugger settings.
//
void DebuggerShell::CloseDebuggerRegistry(HKEY key)
{
    RegFlushKey(key);
    RegCloseKey(key);
}

//
// The current source file path is returned in currentPath. Free with
// delete currentPath;
// Returns FALSE if it fails.
//
BOOL DebuggerShell::ReadSourcesPath(HKEY key, WCHAR **currentPath)
{
    DWORD len = 0;
    DWORD type;

    // Get the length of the key data
    LONG result = RegQueryValueExA(key, REG_SOURCES_KEY, NULL,
                                   &type, NULL, &len);

    if (result == ERROR_SUCCESS)
    {
        // Get the key data
        char *currentPathA = (char *) _alloca(len * sizeof(char));

        result = RegQueryValueExA(key, REG_SOURCES_KEY, NULL,
                                    &type, (BYTE*) currentPathA, &len);

        // If successful, convert from ANSI to Unicode
        if (result == ERROR_SUCCESS)
        {
            MAKE_WIDEPTR_FROMANSI(tmpWStr, currentPathA);
            *currentPath = new WCHAR[len];

            if (!currentPath)
            {
                return false;
            }
            
            wcscpy(*currentPath, tmpWStr);

            return (TRUE);
        }

        // Otherwise indicate failure
        else
            return (FALSE);
    }

    return (FALSE);
}

//
// Write a new source file path to the registry. If successful, return
// TRUE.
//
BOOL DebuggerShell::WriteSourcesPath(HKEY key, WCHAR *newPath)
{
    // Convert the string to ANSI
    MAKE_ANSIPTR_FROMWIDE(newPathA, newPath);

    LONG result = RegSetValueExA(key, REG_SOURCES_KEY, NULL,
                                 REG_EXPAND_SZ, (const BYTE*) newPathA,
                                 strlen(newPathA) + 1);

    if (result == ERROR_SUCCESS)
        return (TRUE);

    Write(L"Error %d writing new path to registry.\n", result);

    return (FALSE);
}

BOOL DebuggerShell::AppendSourcesPath(const WCHAR *newpath)
{
    WCHAR       *szPath;
    int         ilen;
    ilen = wcslen(m_currentSourcesPath) + wcslen(newpath) + 4;
    szPath = new WCHAR[ilen];
    if (!szPath)
        return (FALSE);

    wcscpy(szPath, m_currentSourcesPath);
    wcscat(szPath, L";");
    wcscat(szPath, newpath);
    m_currentSourcesPath = szPath;
    return (TRUE);
}


// Called when we failed to find a source file on the default path.  You
// may prompt for path information.
HRESULT DebuggerShell::ResolveSourceFile(
    DebuggerSourceFile *pf,
    CHAR *pszPath, 
    CHAR *pszFullyQualName,
    int iMaxLen,
    bool bChangeOfName)
{
	HRESULT hr = S_FALSE;
	CHAR	*pstrFileName = NULL;
	int fileNameLength;

    if (pf->m_name == NULL)
        return S_FALSE;

    MAKE_ANSIPTR_FROMWIDE(nameA, pf->m_name);
    _ASSERTE(pszPath != NULL && nameA != NULL);

    
    // First off, check the SourceFile cache to see if there's an
    // entry matching the module and document
    ISymUnmanagedDocument *doc = NULL;
    GUID g = {0};
    if ((pf->m_module->GetSymbolReader() != NULL) &&
        SUCCEEDED(pf->m_module->GetSymbolReader()->GetDocument(pf->m_name,
                                                                g, g, g,
                                                                &doc)))
    {
        if (bChangeOfName == false)
        {
            m_FPCache.GetFileFromCache (pf->m_module, doc, &pstrFileName);
            if (pstrFileName != NULL)
            {
                strcpy (pszFullyQualName, pstrFileName);
                delete [] pstrFileName;

                RELEASE(doc);
                doc = NULL;
                
                return S_OK;
            }
        }
        else
        {
            // We have already determined (in one of the calling func) that this file exists.
            // But we need to get the fully qualified path and also update the cache.
            // Note: These buffers must be large enough for the strcat below.
            CHAR        rcDrive [_MAX_PATH]; 
            CHAR        rcFile[_MAX_FNAME + _MAX_EXT];
            CHAR        rcPath[_MAX_PATH];
            CHAR        rcExt [_MAX_EXT];
            _splitpath(pszPath, rcDrive, rcPath, rcFile, rcExt);

            strcat (rcDrive, rcPath); 
            strcat (rcFile, rcExt); 

            fileNameLength = SearchPathA(rcDrive, 
                                            rcFile, 
                                            NULL,
                                            iMaxLen,
                                            pszFullyQualName,
                                            NULL);

            if ((fileNameLength > 0) && (fileNameLength < iMaxLen))
            {
                m_FPCache.UpdateFileCache (pf->m_module, doc,
                                           pszFullyQualName);
                RELEASE(doc);
                doc = NULL;

                return S_OK;
            }
        }
    }

    // Now, try to locate the file as is:
    fileNameLength = SearchPathA(NULL, nameA, NULL, iMaxLen,
                                       pszFullyQualName, NULL);

    if (fileNameLength == 0)
    {
        // file name was not located. So, try all the paths

        // extract the filename and extension from the file name
        CHAR        rcFile[_MAX_FNAME];
        CHAR        rcExt [_MAX_EXT];
        _splitpath(nameA, NULL, NULL, rcFile, rcExt);

        strcat (rcFile, rcExt); 

        // get the number of elements in the search path
        int iNumElems = m_FPCache.GetPathElemCount();

        // if could be that the search path was earlier null and 

        char rcFullPathArray [MAX_PATH_ELEMS][MAX_PATH]; // to hold full paths for all elems
        if (iNumElems > 0)
        {
            int iCount = 0;

            // Initialize the array elements 
            for (int j=0; j<iNumElems; j++)
            {
                rcFullPathArray [j][0] = '\0';
            }
            
            int iIndex = 0;

            // for each element in the search path, see if the file exists
            while (iIndex < iNumElems)
            {
                char *pszPathElem = m_FPCache.GetPathElem (iIndex);

                // first, try and use the unsplit name. If that doesn't return a match,
                // use the stripped name

                fileNameLength = SearchPathA(pszPathElem, 
                                                nameA, 
                                                NULL,
                                                iMaxLen,
                                                rcFullPathArray [iCount],
                                                NULL);
                if (fileNameLength == 0)
                {
                    fileNameLength = SearchPathA(pszPathElem, 
                                                    rcFile, 
                                                    NULL,
                                                    iMaxLen,
                                                    rcFullPathArray [iCount],
                                                    NULL);
                }


                if ((fileNameLength > 0) && (fileNameLength < iMaxLen))
                {
                    iCount++;
                }
                    
                iIndex++;
            }

            if (iCount > 0)
            {
                // atleast one file was located

                // convert all names to lowercase
                for (int i=0; i<iCount; i++)
                {
                    iIndex = 0;
                    while (rcFullPathArray [i][iIndex] != '\0')
                    {
                        rcFullPathArray [i][iIndex] = tolower (
                                                    rcFullPathArray[i][iIndex]);
                        iIndex++;
                    }
                }

                
                // remove any duplicate entries
                int iLowerBound = 1;
                for (int iCounter1=1;   iCounter1 < iCount; iCounter1++)
                {
                    bool fDuplicate = false;
                    for (int iCounter2=0; iCounter2 < iLowerBound;
                                                        iCounter2++)
                    {
                        if ((strcmp (rcFullPathArray [iCounter2], 
                                    rcFullPathArray [iCounter1]) == 0))
                        {
                            // found a duplicate entry. So break.
                            fDuplicate = true;
                            break;
                        }
                    }

                    if (fDuplicate == false)                    
                    {
                        // if we've found atleast one duplicate uptil now,
                        // then copy this entry into the entry pointed to
                        // by iLowerbound. Otherwise no need to do so (since
                        // it would be a copy to self).
                        if (iLowerBound != iCounter1)
                            strcpy (rcFullPathArray [iLowerBound],
                                    rcFullPathArray [iCounter1]);

                        iLowerBound++;
                    }
                }

                // new count equals the number of elements in the array (minus
                // the duplicates)
                iCount = iLowerBound;


                if (iCount == 1)
                {
                    // exactly one file was located. So this is the one!!
                    strcpy (pszFullyQualName, rcFullPathArray [0]);

                    // add this to the SourceFile cache
                    if (doc != NULL)
                    {
                        m_FPCache.UpdateFileCache (pf->m_module, doc,
                                                   pszFullyQualName);
                        RELEASE(doc);
                        doc = NULL;
                    }

                    hr = S_OK;
                }
                else
                {
                    // ask user to select which file he wants to open
                    while (true)
                    {
                        int iTempCount = 1;

                        // Print all the file names found
                        while (iTempCount <= iCount)
                        {
                            Write (L"\n%d)\t%S", iTempCount, rcFullPathArray [iTempCount - 1]);
                            iTempCount++;
                        }

                        bool bDone = false;

                        WCHAR strTemp [10+1];
                        int iResult;
                        while (true)
                        {
                            Write (L"\nPlease select one of the above options (enter the number): ");
                            if (ReadLine (strTemp, 10))
                            {
                                WCHAR *p = strTemp;
                                if (GetIntArg (p, iResult))
                                {
                                        if (iResult > 0 && iResult <= iCount)
                                        {
                                        strcpy (pszFullyQualName, rcFullPathArray [iResult-1]);
                                    
                                        // add this to the SourceFile cache
                                        if (doc != NULL)
                                        {
                                            m_FPCache.UpdateFileCache (
                                                                pf->m_module,
                                                                doc, 
                                                                pszFullyQualName
                                                                );
                                            RELEASE(doc);
                                            doc = NULL;
                                        }

                                        return (S_OK);
                                    }
                                }
                            }

                        }

                    }
                }
            }
        }
    }
    else
    {
        // Should never exceed the maximum path length
        _ASSERTE( 0 < fileNameLength && fileNameLength <= MAX_PATH);

        hr = S_OK;
    }

    if (doc != NULL)
        RELEASE(doc);

    return hr;
}


// Read the last set of debugger modes from the registry.
BOOL DebuggerShell::ReadDebuggerModes(HKEY key)
{
    DWORD len = sizeof(m_rgfActiveModes);
    DWORD type;

    // Get the mode word
    LONG result = RegQueryValueExA(key, REG_MODE_KEY, NULL,
                                   &type, (BYTE*) &m_rgfActiveModes, &len);

    if (result == ERROR_SUCCESS)
        return (TRUE);
    else
    {
        if (result != ERROR_FILE_NOT_FOUND)
            Write(L"Error %d reading debugger modes from the registry.\n",
                  result);
        
        return (FALSE);
    }
}

// Write the current set of debugger modes to the registry.
BOOL DebuggerShell::WriteDebuggerModes(void)
{
    HKEY key;

    if (OpenDebuggerRegistry(&key))
    {
        LONG result = RegSetValueExA(key, REG_MODE_KEY, NULL,
                                     REG_DWORD,
                                     (const BYTE*) &m_rgfActiveModes,
                                     sizeof(m_rgfActiveModes));

        CloseDebuggerRegistry(key);
        
        if (result == ERROR_SUCCESS)
            return (TRUE);
        else
        {
            Write(L"Error %d writing debugger modes to the registry.\n",
                  result);
            return (FALSE);
        }
    }

    return (FALSE);
}

ICorDebugManagedCallback *DebuggerShell::GetDebuggerCallback()
{
    return (new DebuggerCallback());
}


ICorDebugUnmanagedCallback *DebuggerShell::GetDebuggerUnmanagedCallback()
{
    return (new DebuggerUnmanagedCallback());
}


DebuggerModule *DebuggerShell::ResolveModule(ICorDebugModule *m)
{
    DebuggerModule *module = (DebuggerModule *)m_modules.GetBase((ULONG)m);

    return (module);
}

HRESULT DebuggerShell::NotifyModulesOfEnc(ICorDebugModule *pModule,
                                          IStream *pSymStream)
{
    DebuggerModule *m = DebuggerModule::FromCorDebug(pModule);
    _ASSERTE(m != NULL);

    if (m->m_pISymUnmanagedReader != NULL)
    {

        HRESULT hr = m->m_pISymUnmanagedReader->UpdateSymbolStore(NULL,
                                                                  pSymStream);

        if (FAILED(hr))
            Write(L"Error updating symbols for module: 0x%08x\n", hr);
    }
    
    return S_OK;
}

void DebuggerShell::ClearDebuggeeState(void)
{
    m_needToSkipCompilerStubs = true;
}

DebuggerSourceFile *DebuggerShell::LookupSourceFile(const WCHAR* name)
{
    HASHFIND find;

    for (DebuggerModule *module = (DebuggerModule *) m_modules.FindFirst(&find);
        module != NULL;
        module = (DebuggerModule *) m_modules.FindNext(&find))
    {
        DebuggerSourceFile *file = module->LookupSourceFile(name);
        if (file != NULL)
            return (file);
    }

    return (NULL);
}

//
// SkipCompilerStubs returns TRUE if the given thread is outside of a
// compiler compiler-generated stub. If inside a compiler stub, it
// creates a stepper on the thread and continues the process.
//
// This is really only a temporary thing in order to get VB apps past
// the compiler generated stubs and down to the real user entry
// point. In the future, we will be able to determine the proper
// entrypoint for an app and set a brekapoint there rather than going
// through all of this to step through compiler generated stubs.
//
bool DebuggerShell::SkipCompilerStubs(ICorDebugAppDomain *pAppDomain,
                                      ICorDebugThread *pThread)
{
    bool ret = true;

    ICorDebugChainEnum *ce;
    ICorDebugChain *ichain;
    ICorDebugFrameEnum *fe;
    ICorDebugFrame *iframe;
    ICorDebugFunction *ifunction;
    DebuggerFunction *function;
    ICorDebugStepper *pStepper;
    
    HRESULT hr = pThread->EnumerateChains(&ce);

    if (FAILED(hr))
        goto exit;

    DWORD got;
    hr = ce->Next(1, &ichain, &got);

    RELEASE(ce);
    
    if (FAILED(hr))
        goto exit;

    if (got == 1)
    {
        hr = ichain->EnumerateFrames(&fe);

        RELEASE(ichain);

        if (FAILED(hr))
            goto exit;

        hr = fe->Next(1, &iframe, &got);

        RELEASE(fe);
        
        if (FAILED(hr))
            goto exit;

        if (got == 1)
        {
            hr = iframe->GetFunction(&ifunction);

            RELEASE(iframe);
            
            if (FAILED(hr))
                goto exit;

            // Get the DebuggerFunction for the function interface
            function = DebuggerFunction::FromCorDebug(ifunction);
            _ASSERTE(function);

            RELEASE(ifunction);

            WCHAR *funcName = function->GetName();

            // These are stub names for the only compiler we know
            // generates such stubs at this point: VB. If your
            // compiler also generates stubs that you don't want the
            // user to see, add the names in here.
            if (!wcscmp(funcName, L"_main") ||
                !wcscmp(funcName, L"mainCRTStartup") ||
                !wcscmp(funcName, L"_mainMSIL") ||
                !wcscmp(funcName, L"_vbHidden_Constructor") ||
                !wcscmp(funcName, L"_vbHidden_Destructor") ||
                !wcscmp(funcName, L"_vbGenerated_MemberConstructor") ||
                !wcscmp(funcName, L"_vbGenerated_StaticConstructor"))
            {
                hr = pThread->CreateStepper(&pStepper);

                if (FAILED(hr))
                    goto exit;

                hr = pStepper->SetUnmappedStopMask( g_pShell->ComputeStopMask() );
                
                if (FAILED(hr))
                    goto exit;

                hr = pStepper->SetInterceptMask( g_pShell->ComputeInterceptMask() );
                
                if (FAILED(hr))
                    goto exit;
                    
                hr = pStepper->Step(TRUE);

                if (FAILED(hr))
                {
                    RELEASE(pStepper);
                    goto exit;
                }
                m_showSource = true;
                StepStart(pThread, pStepper);
                
                ICorDebugController *dc = GetControllerInterface(pAppDomain);
                Continue(dc, pThread);
                
                if (dc != NULL)
                    RELEASE(dc);
                    
                ret = false;
            }
        }
    }

exit:
    if (FAILED(hr))
        ReportError(hr);
    
    return ret;
}

void DebuggerShell::LoadUnmanagedSymbols(HANDLE hProcess,
                                         HANDLE hFile,
                                         DWORD imageBase)
{
    BOOL succ = SymLoadModule(hProcess, hFile, NULL, NULL, imageBase, 0);

    if (succ)
    {
        IMAGEHLP_MODULE mi;
        mi.SizeOfStruct = sizeof(mi);
                
        succ = SymGetModuleInfo(hProcess, imageBase, &mi);

        if (succ)
        {
            char *imageName = NULL;

            if (mi.LoadedImageName[0] != '\0')
                imageName = mi.LoadedImageName;
            else if (mi.ImageName[0] != '\0')
                imageName = mi.ImageName;
            else if (mi.ModuleName[0] != '\0')
                imageName = mi.ModuleName;

            if ((imageName == NULL) || (imageName[0] == '\0'))
                imageName = "<Unknown module>";
            
            g_pShell->Write(L"Loaded symbols for %S, base=0x%08x\n",
                            imageName, mi.BaseOfImage);
        }
        else
            g_pShell->Write(L"Error loading symbols.\n");
    }
    else
        g_pShell->Write(L"Error loading symbols.\n");
}

void DebuggerShell::HandleUnmanagedThreadCreate(DWORD dwThreadId,
                                                HANDLE hThread)
{
    DebuggerUnmanagedThread *ut = new DebuggerUnmanagedThread(dwThreadId,
                                                              hThread);
    _ASSERTE(ut);
    
    HRESULT hr = g_pShell->m_unmanagedThreads.AddBase(ut);
    _ASSERTE(SUCCEEDED(hr));
}

void DebuggerShell::TraceUnmanagedThreadStack(HANDLE hProcess,
                                              DebuggerUnmanagedThread *ut,
                                              bool lie)
{
    HANDLE hThread = ut->GetHandle();

    STACKFRAME f = {0};
    BOOL succ;
    CONTEXT c;
    c.ContextFlags = CONTEXT_FULL;

    if ((m_currentProcess) && lie)
    {
        HRESULT hr = m_targetProcess->GetThreadContext(ut->GetId(),
                                                        sizeof(CONTEXT),
                                                        (BYTE*)&c);

        if (!SUCCEEDED(hr))
        {
            Write(L"Failed to get context 0x%x. No trace for thread 0x%x\n", hr, ut->GetId());
            return;
        }

        Write(L"Filtered ");
    }
    else
    {
        succ = GetThreadContext(hThread, &c);

        if (!succ)
        {
            Write(L"Failed to get context %d. No trace for thread 0x%x\n", GetLastError(), ut->GetId());
            return;
        }

        Write(L"True ");
    }

    Write(L"stack trace for thread 0x%x:\n", ut->GetId());

    if (!lie)
    {
        DWORD cnt = SuspendThread(hThread);
        Write(L"Suspend count is %d\n", cnt);
        cnt = ResumeThread(hThread);
    }

#ifdef _X86_
    TraceUnmanagedStack(hProcess, hThread, c.Eip, c.Ebp, c.Esp, (DWORD)-1);
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - TraceUnmanagedThreadStack (dShell.cpp)");
#endif // _X86_
}

void DebuggerShell::TraceUnmanagedStack(HANDLE hProcess, HANDLE hThread,
                                        CORDB_ADDRESS ipStart, 
                                        CORDB_ADDRESS bpStart, 
                                        CORDB_ADDRESS spStart,
                                        CORDB_ADDRESS bpEnd)
{
    if (m_unmanagedDebuggingEnabled)
    {
        STACKFRAME f = {0};

        f.AddrPC.Offset = (SIZE_T)ipStart;
        f.AddrPC.Mode = AddrModeFlat;
        f.AddrReturn.Mode = AddrModeFlat;
        f.AddrFrame.Offset = (SIZE_T)bpStart;
        f.AddrFrame.Mode = AddrModeFlat;
        f.AddrStack.Offset = (SIZE_T)spStart;
        f.AddrStack.Mode = AddrModeFlat;

        int i = 0;
        
        do
        {
            if (!StackWalk(IMAGE_FILE_MACHINE_I386,
                             hProcess,
                             hThread,
                             &f,
                             NULL,
                             NULL,
                             SymFunctionTableAccess,
                             SymGetModuleBase,
                             NULL))
                break;

            if (f.AddrPC.Offset == 0)
                continue;

            PrintUnmanagedStackFrame(hProcess, f.AddrPC.Offset);
            Write(L"\n");
        }
        while ((f.AddrFrame.Offset <= bpEnd) && (i++ < 200));
    }
    else
    {
    // If we're not a win32 debugger, then we can't provide an unmanaged stack
    // trace because we're not getting the events to let us know what modules
    // are loaded.
        Write(L"\t0x%p:  <unknown>\n", (DWORD)ipStart);
    }
}

void DebuggerShell::PrintUnmanagedStackFrame(HANDLE hProcess, CORDB_ADDRESS ip)
{
    DWORD disp;
    IMAGEHLP_SYMBOL *sym = (IMAGEHLP_SYMBOL*) _alloca(sizeof(sym) +
                                                      MAX_CLASSNAME_LENGTH);
    sym->SizeOfStruct = sizeof(sym) + MAX_CLASSNAME_LENGTH;
    sym->MaxNameLength = MAX_CLASSNAME_LENGTH;
    
	BOOL succ;
	succ = SymGetSymFromAddr(hProcess, (SIZE_T)ip, &disp, sym);

    if (!succ)
        Write(L"\t0x%p:  <unknown>", (DWORD)ip, sym->Name);
    else
        Write(L"\t0x%p:  %S + %d", (DWORD)ip, sym->Name, disp);
}

void DebuggerShell::TraceAllUnmanagedThreadStacks(void)
{
    if (m_targetProcess == NULL)
    {
        Error(L"Process not running.\n");
        return;
    }
        
    // Snagg the handle for this process.
    HPROCESS hProcess;
    HRESULT hr = m_targetProcess->GetHandle(&hProcess);

    if (FAILED(hr))
    {
        ReportError(hr);
        return;
    }

    HASHFIND find;
    DebuggerUnmanagedThread *ut;
    
    for (ut = (DebuggerUnmanagedThread*) m_unmanagedThreads.FindFirst(&find);
         ut != NULL;
         ut = (DebuggerUnmanagedThread*) m_unmanagedThreads.FindNext(&find))
    {
        Write(L"\n\n");
        TraceUnmanagedThreadStack(hProcess, ut, false);
    }
}


int DebuggerShell::GetUserSelection  (DebuggerModule *rgpDebugModule[],
                        WCHAR *rgpstrFileName[][MAX_FILE_MATCHES_PER_MODULE],   
                        int rgiCount[],
                        int iModuleCount,
                        int iCumulCount
                        )
{
    int iOptionCounter = 1; // User gets the breakpoint options starting from 1
    WCHAR rgwcModuleName [MAX_PATH+1];
    ULONG32 NameLength;

    for (int i=0; i<iModuleCount; i++)
    {
        if (rgpDebugModule [i] != NULL)
        {
            // Initialize module name to null
            rgwcModuleName [0] = L'\0';

            // Now get the module name
            rgpDebugModule [i]->GetICorDebugModule()->GetName(MAX_PATH, &NameLength, rgwcModuleName);

            for (int j=0; j < rgiCount[i]; j++)
            {
                Write (L"%d]\t%s!%s\n",  iOptionCounter, rgwcModuleName, rgpstrFileName [i][j]);
                iOptionCounter++;
            }
        }
    }

    Write (L"%d\tAll of the above\n", iOptionCounter); 
    Write (L"\nPlease select one of the above :");

    bool bDone = false;

    WCHAR strTemp [10+1];
    int iResult;
    while (true)
    {
        if (ReadLine (strTemp, 10))
        {
            WCHAR *p = strTemp;
            if (GetIntArg (p, iResult))
                if ((iResult > 0) && (iResult <= iOptionCounter))
                    return iResult;

        }

    }

}


BOOL    DebuggerShell::ChangeCurrStackFile (WCHAR *fileName)
{
    // first, check to see if the file even exists. Otherwise error out.
    MAKE_ANSIPTR_FROMWIDE (fnameA, fileName);
    _ASSERTE (fnameA != NULL);

    FILE *stream = fopen (fnameA, "r");
    DebuggerSourceFile *pSource = NULL;
    HRESULT hr;
    BOOL ret = FALSE;


    if (stream != NULL)
    {
        fclose (stream);

        //
        // Don't do anything if there isn't a current thread.
        //
        if ((m_currentThread == NULL) || (m_currentFrame == NULL))
            return (ret);

        ICorDebugCode *icode;
        hr = m_currentFrame->GetCode(&icode);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return (FALSE);
        }

        ICorDebugFunction *ifunction;
        icode->GetFunction(&ifunction);

        RELEASE(icode);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return (FALSE);
        }

        DebuggerFunction *function = DebuggerFunction::FromCorDebug(ifunction);
        _ASSERTE(function != NULL);

        RELEASE(ifunction);

        ULONG32 ip;
        CorDebugMappingResult mappingResult;
        hr = m_currentFrame->GetIP(&ip, &mappingResult);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return (FALSE);
        }

        DebuggerSourceFile* sf;
        unsigned int lineNumber;
        hr = function->FindLineFromIP(ip, &sf, &lineNumber);

        if (hr == S_OK)
            ret = sf->ReloadText(fileName, true);   
    }
    else
    {
        g_pShell->Write(L"Could not locate/open given file.\n");
    }

    return ret;
}


BOOL DebuggerShell::UpdateCurrentPath (WCHAR *newPath)
{
    int iLength = wcslen (newPath);

    if (iLength != 0)
    {
        // Delete the previous path
        delete [] m_currentSourcesPath;

        // Write the new path into m_currentSourcesPath
        if ((m_currentSourcesPath = new WCHAR [iLength+1]) == NULL)
        {
            Error(L"Path not set!\n");
            m_currentSourcesPath = NULL;
            return false;
        }

        wcscpy (m_currentSourcesPath, newPath);

        // Now, store this in the DebuggerFilePathCache
        HRESULT hr = m_FPCache.InitPathArray (m_currentSourcesPath);

        _ASSERTE (hr == S_OK);
    }

    return (true);
}


// BOOL fSymbol true if we want to print symbols, false if we
//          want to print the values of global variables
bool DebuggerShell::MatchAndPrintSymbols (WCHAR *pszArg, 
                                          BOOL fSymbol, 
                                          bool fSilently)
{
    // separate the module name from the string to search for
    WCHAR szModName [MAX_PATH];
    WCHAR szSymName [MAX_SYMBOL_NAME_LENGTH];
    BOOL fAtleastOne = FALSE;
    ModuleSearchList MSL;

    // separate the module and searchstring
    int iIndex = 0;
    int iLength = wcslen (pszArg);
    szModName [0] = L'\0';
    szSymName [0] = L'\0';

    while (iIndex < iLength)
    {
        if (pszArg [iIndex] == '!')
        {
            if (iIndex > 0)
            {
                wcsncpy (szModName, pszArg, iIndex);
                szModName [iIndex] = L'\0';
            }
        
            wcscpy (szSymName, &pszArg [iIndex+1]);
            break;
        }

        iIndex++;
    }

    if (iIndex == iLength)
        wcscpy (szSymName, pszArg);

    // if no module is specified, then need to walk through all modules...
    if (wcslen (szModName) == 0)
    {
        HASHFIND find;
        DebuggerModule *m;

        for (m = (DebuggerModule*) g_pShell->m_modules.FindFirst(&find);
             m != NULL;
             m = (DebuggerModule*) g_pShell->m_modules.FindNext(&find))
        {
            WCHAR *pszModName = m->GetName();
            if (pszModName == NULL)
                pszModName = L"<UnknownName>";

            char        rcFile[MAX_PATH];
            char        rcExt[_MAX_EXT];

            MAKE_ANSIPTR_FROMWIDE(nameA, pszModName);
            _splitpath(nameA, NULL, NULL, rcFile, rcExt);
            strcat(rcFile, rcExt);

            // There could be multiple instances of DebuggerModule object 
            // for the same base module. Therefore, check to see if this module 
            // has already been searched
            if (!MSL.ModuleAlreadySearched (rcFile))
            {
                // add this module to the list of modules already searched
                MSL.AddModuleToAlreadySearchedList (rcFile);

                // get the MetaData
                IMetaDataImport *pMD = m->GetMetaData();
                if (pMD != NULL)
                {
                    if (fSymbol)
                    {
                        if (m->PrintMatchingSymbols (szSymName, rcFile) == TRUE)
                            fAtleastOne = TRUE;
                    }
                    else
                    {
                        if (m->PrintGlobalVariables(szSymName, rcFile, m) == TRUE)
                            fAtleastOne = TRUE;
                    }
                }
                else
                {
                    if (!fSilently)
                        Write (L"**ERROR** No MetaData available for module : %S\n", rcFile);
                }
            }
        }
    }
    else
    {
        // see if the given file name matches
        char        rcFile1[MAX_PATH];
        char        rcExt1[_MAX_EXT];

        MAKE_ANSIPTR_FROMWIDE(name1A, szModName);
        _splitpath(name1A, NULL, NULL, rcFile1, rcExt1);
        strcat(rcFile1, rcExt1);
        char *pTemp = rcFile1;
        while (*pTemp != '\0')
        {   
            *pTemp = tolower (*pTemp);
            pTemp++;
        }

        // walk the list of modules looking for the one which 
        // matches the given module name
        HASHFIND find;
        DebuggerModule *m;
        for (m = (DebuggerModule*) g_pShell->m_modules.FindFirst(&find);
             m != NULL;
             m = (DebuggerModule*) g_pShell->m_modules.FindNext(&find))
        {
            WCHAR *pszModName = m->GetName();
            if (pszModName == NULL)
                pszModName = L"<UnknownName>";

            char        rcFileNoExt[_MAX_FNAME];
            char        rcFileExt[_MAX_EXT];
            char        rcExt[_MAX_EXT];

            MAKE_ANSIPTR_FROMWIDE(nameA, pszModName);
            _splitpath(nameA, NULL, NULL, rcFileNoExt, rcExt);

            // need to do some funky stuff depending on if the user supplied a name with
            // extension, as he may be supplying a name with extension but that extension
            // not being the 'real' one: eg, for symbols in Dot.Net.dll he may be supplying
            // Dot.Net and therefore we cant just blindly say he's searching for Dot.Net, we'll
            // have to check against for Dot.Net.*

            bool bExtension;
            if (strlen (rcExt1))
            {
                bExtension=true;
                strcpy(rcFileExt, rcFileNoExt);
                strcat(rcFileExt, rcExt);

                // convert the name with extension to lowercase
                pTemp = rcFileExt;
                while (*pTemp != '\0')
                {   
                    *pTemp = tolower (*pTemp);
                    pTemp++;
                }
            }
            else
            {
                bExtension=false;
            }            

            // convert the name to lowercase
            pTemp = rcFileNoExt;
            while (*pTemp != '\0')
            {   
                *pTemp = tolower (*pTemp);
                pTemp++;
            }
            
            bool bMatch=false;
            char* pszMatch=0;
            if (bExtension)
            {
                // Check against name with extension
                if (!strcmp(rcFileExt, rcFile1))
                {
                    pszMatch=rcFileExt;
                    bMatch=true;
                }                
            }

            
            // Check against name without extension
            if (!bMatch && !strcmp(rcFileNoExt, rcFile1))
            {
                pszMatch=rcFileNoExt;
                bMatch=true;
            }                
            

            if (bMatch)
            {
                // this is the one!!

                // get the MetaData
                IMetaDataImport *pMD = m->GetMetaData();
                if (pMD != NULL)
                {
                    if (fSymbol)
                    {
                        if (m->PrintMatchingSymbols (szSymName, pszMatch) == TRUE)
                            fAtleastOne = TRUE;
                    }
                    else
                    {
                        if (m->PrintGlobalVariables(szSymName, pszMatch, m) == TRUE)
                            fAtleastOne = TRUE;
                    }
                }
                else
                {
                    if (!fSilently)
                        Write (L"**ERROR** No MetaData available for module : %S\n", rcFile1);
                }
                break;
            }
        }
    }

    if (fAtleastOne == FALSE)
    {
        if (wcslen (szModName) == 0)
        {
            if (!fSilently)
                Write (L"No matching symbols found in any of the loaded modules.\n");
        }
        else
        {
            if (!fSilently)
                Write (L"No matching symbols found in module: %s .\n", szModName);
        }
        
        return false;
    }

    return true;
}

const WCHAR *DebuggerShell::UserThreadStateToString(CorDebugUserState us)
{
    WCHAR *wsz;

    switch (us)
    {
        case USER_STOP_REQUESTED:
            wsz = L"Stop Requested";
            break;
        case USER_SUSPEND_REQUESTED:
            wsz = L"Suspend Requested";
            break;
        case USER_BACKGROUND:
            wsz = L"Background";
            break;
        case USER_UNSTARTED:
            wsz = L"Unstarted";
            break;
        case USER_STOPPED:
            wsz = L"Stopped";
            break;
        case USER_WAIT_SLEEP_JOIN:
            wsz = L"Wait/Sleep/Join";
            break;
        case USER_SUSPENDED:
            wsz = L"Suspended";
            break;
        default:
            wsz = L"Normal";
            break;
    }

    return wsz;
}

void UndecorateName(MDUTF8CSTR name, MDUTF8STR u_name)
{
    int i, j;
    int len;

    len = strlen(name);
    j = 0;
    for (i = 1; i < len; i++)
    {
        if (j > MAX_CLASSNAME_LENGTH-1) break;
        if (name[i] != '@') u_name[j++] = name[i];
        else break;
    }

    u_name[j] = '\0';
}

void DebuggerShell::ListAllGlobals (DebuggerModule *m)
{
    IMetaDataImport *pIMetaDI;
    HCORENUM phEnum = 0;
    mdMethodDef rTokens[100];
    ULONG i;
    ULONG count;
    HRESULT hr;
    MDUTF8CSTR name;
    MDUTF8STR  u_name;
    bool anythingPrinted = false;
 
    pIMetaDI = m->GetMetaData();

    u_name = new char[MAX_CLASSNAME_LENGTH];

    do 
    {
        hr = pIMetaDI->EnumMethods(&phEnum, NULL, &rTokens[0], 100, &count);

        if (!SUCCEEDED(hr))
        {
            ReportError(hr);
            goto ErrExit;
        }

        for (i = 0; i < count; i++)
        {
            hr = pIMetaDI->GetNameFromToken(rTokens[i], &name);

            if (name == NULL)
                continue;

            Write(L"\t");
            
            if (name[0] == '?')
            {
                UndecorateName(name, u_name);
                        
                Write(L"%S (%S)\n", u_name, name);
            }
            else
                Write(L"%S\n", name);

            anythingPrinted = true;
        }
    }
    while (count > 0); 

ErrExit:    
    delete u_name;

    if (!anythingPrinted)
        Write(L"No global functions in this module.\n");
}

void DebuggerShell::ListAllModules(ListType lt)
{
    HASHFIND find;
    DebuggerModule *m;
    
    for (m = (DebuggerModule*) g_pShell->m_modules.FindFirst(&find);
         m != NULL;
         m = (DebuggerModule*) g_pShell->m_modules.FindNext(&find))
    {
        _printModule(m->GetICorDebugModule(), PT_NONE);

        if (lt == LIST_CLASSES)
        {
            HASHFIND classfind;
            DebuggerClass *cl;
    
            for (cl = (DebuggerClass*) m->m_loadedClasses.FindFirst(&classfind);
                 cl != NULL;
                 cl = (DebuggerClass*) m->m_loadedClasses.FindNext(&classfind))
            {
                WCHAR *pszClassName = cl->GetName();
                WCHAR *pszNamespace = cl->GetNamespace();

                if (pszClassName == NULL)
                    pszClassName = L"<UnknownClassName>";

                Write (L"\t");
                if (pszNamespace != NULL)
                    Write (L"%s.", pszNamespace);
                Write (L"%s\n", pszClassName);
            }
        }

        // List all the global functions here.
        if (lt == LIST_FUNCTIONS)
        {
            ListAllGlobals(m);  
        }
    }
}



/* ------------------------------------------------------------------------- *
 * DebuggerBreakpoint
 * ------------------------------------------------------------------------- */

void DebuggerBreakpoint::CommonCtor()
{
    // Real ctors fill in m_threadID & m_index so DON'T overwrite those
    // values here.
    m_next = NULL;
    m_id = 0;
    m_name = NULL;
    m_moduleName = NULL;
    m_active = false;
    m_managed = false;
    m_doc = NULL;
    m_process = NULL;
    m_address= 0;
    m_patchedValue = 0;
    m_skipThread = 0;
    m_unmanagedModuleBase = 0;
    m_pModuleList = NULL;
    m_deleteLater = false;
}

DebuggerBreakpoint::DebuggerBreakpoint(const WCHAR *name, SIZE_T nameLength, 
                                       SIZE_T index, DWORD threadID)
    : m_threadID(threadID), m_index(index)
{
    WCHAR *moduleName = NULL;
    CommonCtor();
    
    // Make a copy of the name
    if (nameLength > 0)
    {
        // check to see if the name contains the "!" character. 
        // Anything before the "!" is a module name and will not
        // be stored in the breakpoint name
        WCHAR *szModuleEnd = wcschr(name, L'!');
        if (szModuleEnd != NULL)
        {
            // We'll store it in the m_moduleName field, instead
            SIZE_T modNameLen = szModuleEnd - name;
            moduleName = (WCHAR *)_alloca( sizeof(WCHAR) *(modNameLen+1));
            wcsncpy(moduleName, name, modNameLen);
            moduleName[modNameLen] = '\0';
        
            // Adjust the length, since we've trimmed something off the from the start
            nameLength -= (szModuleEnd+1-name);
            name = szModuleEnd+1;
        }

        m_name = new WCHAR[nameLength+1];
        _ASSERTE(m_name != NULL);

        wcsncpy(m_name, name, nameLength);
        m_name[nameLength] = L'\0';
    }

    Init(NULL, false, moduleName);
}

DebuggerBreakpoint::DebuggerBreakpoint(DebuggerFunction *f, 
                                       SIZE_T offset, DWORD threadID)
    : m_threadID(threadID), m_index(offset)
{
    CommonCtor();
    
    SIZE_T len = wcslen(f->m_name) + 1;

    if (f->m_className != NULL)
        len += wcslen(f->m_className) + 2;

    m_name = new WCHAR[len];

    if (f->m_className != 0)
    {
        wcscpy(m_name, f->m_className);
        wcscat(m_name, L"::");
        wcscat(m_name, f->m_name);
    }
    else
        wcscpy(m_name, f->m_name);

    Init(f->m_module, true, f->m_module->GetName());
}


DebuggerBreakpoint::DebuggerBreakpoint(DebuggerSourceFile *file, 
                                       SIZE_T lineNumber, DWORD threadID)
    : m_threadID(threadID), m_index(lineNumber)
{
    CommonCtor();
    
    // Copy the filename
    m_name = new WCHAR[wcslen(file->m_name) + 1];
    wcscpy(m_name, file->m_name);

    // Init the breakpoint
    Init(file->m_module, true, file->m_module->GetName());
}


DebuggerBreakpoint::~DebuggerBreakpoint()
{
    if (m_active)
        Deactivate();

    if (m_name != NULL)
        delete [] m_name;

    // Remove itself from the shell's list of breakpoints
    DebuggerBreakpoint **bp = &g_pShell->m_breakpoints;
    while (*bp != this)
        bp = &(*bp)->m_next;

    while (m_pModuleList)
        RemoveBoundModule(m_pModuleList->m_pModule);

    *bp = m_next;
}

void DebuggerBreakpoint::Init(DebuggerModule *module, 
                              bool bProceed,
                              WCHAR *szModuleName)
{
    bool        bFound = false;
    m_id = ++g_pShell->m_lastBreakpointID;

    m_next = g_pShell->m_breakpoints;
    g_pShell->m_breakpoints = this;

    // If the user gave us a module name, we should keep track of it.
    if (szModuleName)
    {
        // The ICorDebugModule's name will include a full path
        // if the user didn't specify a full path, then
        // we'll prepend the current working directory onto it.

        SIZE_T len = wcslen(szModuleName);
        SIZE_T lenPath = 0;
        WCHAR cwd[MAX_PATH];

        // Are we missing any path info?
        WCHAR *szModuleEnd = wcschr(szModuleName, L'\\');
        if (szModuleEnd == NULL)
        {
            // Then get the cwd
            CHAR cdBuffer[MAX_PATH];
            CHAR * cd;
            cd = _getcwd(cdBuffer, MAX_PATH);

            _ASSERTE(cd != NULL); // This shouldn't fail

            memset(cwd, 0, MAX_PATH * sizeof(WCHAR)); // MBTWC fails to null terminate strings correctly
            MultiByteToWideChar(GetConsoleCP(), 0, cdBuffer, strlen(cdBuffer), cwd, MAX_PATH);
            cwd[MAX_PATH - 1] = '\0';
                
            if (cwd != NULL)
            {
                // getcwd won't end with a '\' - we'll need to
                // add that in between the path & the module name.
                lenPath = wcslen(cwd) + 1;        
            }
        }

        // Space for path, module name, and terminating NULL.
        m_moduleName = new WCHAR[len+lenPath+1];

        // If we need to prepend the cwd, put it in now
        if (lenPath)
        {
            wcscpy(m_moduleName, cwd);
            m_moduleName[lenPath-1] = '\\'; // put the dir separator in/
        }

        // Put the module name at the end
        wcscpy(&(m_moduleName[lenPath]), szModuleName);
    }

    if (bProceed == false)
        return;

    if (module != NULL && !IsBoundToModule(module))
    {
        bFound = Bind(module, NULL);

        if (!bFound)
            bFound = BindUnmanaged(g_pShell->m_currentProcess);
    }

    if (bFound)
        g_pShell->OnBindBreakpoint(this, module);

}

bool DebuggerBreakpoint::BindUnmanaged(ICorDebugProcess *process,
                                       DWORD moduleBase)
{
    if (m_name == NULL)
        return FALSE;

    if (m_process != NULL || process == NULL)
        return FALSE;

    HANDLE hProcess;
    HRESULT hr = process->GetHandle(&hProcess);

    if (FAILED(hr))
    {
        return false;
    }
            
    // If this is an unmanaged breakpoint for an absolute address,
    // then m_address already holds the address. If its 0, then we try
    // to lookup by name.
    if (m_address == 0)
    {
        IMAGEHLP_SYMBOL *sym = (IMAGEHLP_SYMBOL*) _alloca(sizeof(sym) +
                                                          MAX_CLASSNAME_LENGTH);
        sym->SizeOfStruct = sizeof(sym) + MAX_CLASSNAME_LENGTH;
        sym->MaxNameLength = MAX_CLASSNAME_LENGTH;
    
        MAKE_ANSIPTR_FROMWIDE(symbolName, m_name);

        BOOL succ;
        succ = SymGetSymFromName(hProcess, symbolName, sym);

        if (!succ)
            return false;

        m_address = sym->Address + m_index;
    }
    
    // Find the base of the module that this symbol is in.
    if (moduleBase == 0)
    {
        moduleBase = SymGetModuleBase(hProcess, (SIZE_T)m_address);

        if (moduleBase == 0)
        {
            g_pShell->ReportError(HRESULT_FROM_WIN32(GetLastError()));
            return false;
        }
    }
    
    m_managed = false;
    m_process = process;
    m_unmanagedModuleBase = moduleBase;

    if (m_active)
        ApplyUnmanagedPatch();

    return true;
}

bool DebuggerBreakpoint::Bind(DebuggerModule *module, ISymUnmanagedDocument *doc)
{
    if (m_name == NULL)
        return (false);

    // Make sure we are not double-binding
    _ASSERTE(!IsBoundToModule(module));

#if 0    
    if (m_module != NULL)
        return (false);
#endif    

    //
    // First, see if our name is a function name
    //

    bool success = false;
    HRESULT hr = S_OK;

    WCHAR *classEnd = wcschr(m_name, L':');
    if (classEnd != NULL && classEnd[1] == L':')
    {
        //
        // Name is class::method.
        //

        WCHAR *method = classEnd + 2;

        *classEnd = 0;
        mdTypeDef td = mdTypeDefNil;

        // Only try to lookup the class if we have a name for one.
        if (classEnd != m_name)
            hr = g_pShell->FindTypeDefByName(module, m_name, &td);

        // Its okay if we have a nil typedef since that simply
        // indicates a global function.
        if (SUCCEEDED(hr))
        {
            HCORENUM e = NULL;
            mdMethodDef md;
            ULONG count;

            while (TRUE)
            {
                hr = module->GetMetaData()->EnumMethodsWithName(&e, td, method,
                                                                &md, 1,
                                                                &count);
                if (FAILED(hr) || count == 0)
                    break;

                DebuggerFunction *function = module->ResolveFunction(md, NULL);

                if (function == NULL)
                    continue;

                //
                // Assume offset is IL only for functions which have 
                // no native code.
                // 
                // !!! This will be wrong if we're rebinding a breakpoint, 
                // and we don't have native code because the jit hasn't 
                // occurred yet.
                //

                bool il;

                ICorDebugCode *icode = NULL;
                hr = function->m_ifunction->GetNativeCode(&icode);

                if (FAILED(hr) && (hr != CORDBG_E_CODE_NOT_AVAILABLE))
                {
                    g_pShell->ReportError(hr);
                    continue;
                }
                
                if ((SUCCEEDED(hr) || hr == CORDBG_E_CODE_NOT_AVAILABLE) && icode != NULL)
                {
                    RELEASE(icode);
                    il = FALSE;
                }
                else
                    il = TRUE;

                if (SUCCEEDED(function->LoadCode(!il)))
                {
                    //
                    // Our instruction validation fails if we can't load the
                    // code at this point.  For now, just let it slide.
                    // 

                    if (!function->ValidateInstruction(!il, m_index))
                        continue;
                }

                DebuggerCodeBreakpoint *bp = 
                    new DebuggerCodeBreakpoint(m_id, module, 
                                               function, m_index, il,
                                               NULL_THREAD_ID);

                if (bp == NULL)
                {
                    g_pShell->ReportError(E_OUTOFMEMORY);
                    continue;
                }

                if (m_active)
                    bp->Activate();

                success = true;
            }
        }

        *classEnd = L':';
    }

    if (!success)
    {
        if ((doc == NULL) && (module->GetSymbolReader() != NULL))
        {
            // Get the source file token by name
            GUID g = {0};
            HRESULT hr = module->GetSymbolReader()->GetDocument(m_name,
                                                                g, g, g,
                                                                &doc);

            // If the source file wasn't found, see if we can find it using
            // the short name, since the meta data stores only relative paths.
            if (hr != S_OK)
            {
                char        rcFile[_MAX_FNAME];
                char        rcExt[_MAX_EXT];

                MAKE_ANSIPTR_FROMWIDE(nameA, m_name);
                _splitpath(nameA, NULL, NULL, rcFile, rcExt);
                strcat(rcFile, rcExt);
                

                MAKE_WIDEPTR_FROMANSI(nameW, rcFile);
                hr = module->GetSymbolReader()->GetDocument(nameW,
                                                            g, g, g,
                                                            &doc);
            }
        }


        if ((hr == S_OK) && (doc != NULL))
        {
            DebuggerSourceFile *file = module->ResolveSourceFile(doc);
            _ASSERTE(file != NULL);

            //
            // !!! May want to try to adjust line number rather than just
            // having the binding fail.
            //

            if (file->FindClosestLine(m_index, false) == m_index)
            {
                DebuggerSourceCodeBreakpoint *bp = 
                    new DebuggerSourceCodeBreakpoint(m_id, file, m_index, 
                                                     NULL_THREAD_ID);

                if (bp == NULL)
                {
                    g_pShell->ReportError(E_OUTOFMEMORY);
                    return (false);
                } else if (bp->m_initSucceeded == false)
                    return false;
                
                if (m_active)
                    bp->Activate();

                m_doc = doc;

                success = true;
            }
        }
    }

    if (success)
    {
        m_managed = true;

        if (!IsBoundToModule(module))
            AddBoundModule(module);
    }

    return (success);
}

void DebuggerBreakpoint::Unbind()
{
    if (m_managed)
    {
        while (m_pModuleList != NULL)
        {
            DebuggerCodeBreakpoint *bp = m_pModuleList->m_pModule->m_breakpoints;

            while (bp != NULL)
            {
                g_pShell->OnUnBindBreakpoint(this, m_pModuleList->m_pModule);
                DebuggerCodeBreakpoint *bpNext = bp->m_next;
                delete bp;
                bp = bpNext;
            }

            // Remove the module from the list
            RemoveBoundModule(m_pModuleList->m_pModule);
        }
    }
    else
    {
        if (m_process != 0)
            UnapplyUnmanagedPatch();

        m_process = NULL;
    }
}

void DebuggerBreakpoint::Activate()
{
    if (m_active)
        return;

    if (m_managed)
    {
        BreakpointModuleNode *pCurNode = m_pModuleList;
        
        while (pCurNode != NULL)
        {
            DebuggerCodeBreakpoint *bp = pCurNode->m_pModule->m_breakpoints;

            while (bp != NULL)
            {
                if (bp->m_id == m_id)
                {
                    bp->Activate();
                    g_pShell->OnActivateBreakpoint(this);
                }
                bp = bp->m_next;
            }
            
            pCurNode = pCurNode->m_pNext;
        }
    }
    else
        if (m_process)
            ApplyUnmanagedPatch();

    m_active = true;
}

void DebuggerBreakpoint::Deactivate()
{
    if (!m_active)
        return;

    if (m_managed)
    {
        BreakpointModuleNode *pCurNode = m_pModuleList;

        while (pCurNode != NULL)
        {
            DebuggerCodeBreakpoint *bp = pCurNode->m_pModule->m_breakpoints;

            while (bp != NULL)
            {
                if (bp->m_id == m_id)
                {
                    bp->Deactivate();
                    g_pShell->OnDeactivateBreakpoint(this);
                }
                bp = bp->m_next;
            }

            pCurNode = pCurNode->m_pNext;
        }
    }
    else
    {
        if (m_process != 0)
            UnapplyUnmanagedPatch();
    }

    m_active = false;
}

void DebuggerBreakpoint::Detach()
{
    if (m_managed)
    {
        BreakpointModuleNode *pCurNode = m_pModuleList;

        while (pCurNode != NULL)
        {
            DebuggerCodeBreakpoint *bp = pCurNode->m_pModule->m_breakpoints;

            while (bp != NULL)
            {
                if (bp->m_id == m_id)
                {
                    bp->Deactivate();
                }
                bp = bp->m_next;
            }

            pCurNode = pCurNode->m_pNext;
        }
    }
    else
    {
        if (m_process != 0)
            UnapplyUnmanagedPatch();
    }
}

void DebuggerBreakpoint::DetachFromModule(DebuggerModule * pModule)
{
	_ASSERTE(pModule != NULL);
	if (m_managed)
    {
	    DebuggerCodeBreakpoint *bp = pModule->m_breakpoints;

        while (bp != NULL)
        {
	        if (bp->m_id == m_id)
            {
		        bp->Deactivate();
            }
            bp = bp->m_next;
        }
    }
    else
    {
        if (m_process != 0)
            UnapplyUnmanagedPatch();
    }
}

void DebuggerBreakpoint::Attach()
{
    if (m_managed)
    {
        BreakpointModuleNode *pCurNode = m_pModuleList;

        while (pCurNode != NULL)
        {
            DebuggerCodeBreakpoint *bp = pCurNode->m_pModule->m_breakpoints;

            while (bp != NULL)
            {
                if (bp->m_id == m_id)
                {
                    bp->Activate();
                }
                bp = bp->m_next;
            }

            pCurNode = pCurNode->m_pNext;
        }
    }
    else
    {
        if (m_process != 0)
            ApplyUnmanagedPatch();
    }
}

bool DebuggerBreakpoint::Match(ICorDebugBreakpoint *ibreakpoint)
{
    if (m_managed)
    {
        BreakpointModuleNode *pCurNode = m_pModuleList;

        while (pCurNode != NULL)
        {
            DebuggerCodeBreakpoint *bp = pCurNode->m_pModule->m_breakpoints;

            while (bp != NULL)
            {
                if (bp->m_id == m_id && bp->Match(ibreakpoint))
                    return (true);
                bp = bp->m_next;
            }

            pCurNode = pCurNode->m_pNext;
        }
    }

    return false;
}

bool DebuggerBreakpoint::MatchUnmanaged(CORDB_ADDRESS address)
{
    return !m_managed && m_process != NULL && m_address == address;
}

void DebuggerBreakpoint::ApplyUnmanagedPatch()
{
    SIZE_T read = 0;

    if (m_address == NULL)
    {
        g_pShell->Write( L"Unable to set unmanaged breakpoint at 0x00000000\n" );
        return;
    }

    HRESULT hr = m_process->ReadMemory(m_address, 1, &m_patchedValue, &read);
    if (FAILED(hr) )
    {
        g_pShell->ReportError(hr);
        return;
    }

    if (read != 1 )
    {
        g_pShell->Write( L"Unable to read memory\n" );
        return;
    }

    BYTE patchByte = 0xCC;
    
    hr = m_process->WriteMemory(m_address, 1, &patchByte, &read);
    
    if (FAILED(hr) )
        g_pShell->ReportError(hr);

    if (read != 1 )
    {
        g_pShell->Write( L"Unable to write memory\n" );
        return;
    }
}

void DebuggerBreakpoint::UnapplyUnmanagedPatch()
{
    SIZE_T written;

    if (m_address == NULL)
        return;

    HRESULT hr = m_process->WriteMemory(m_address,
                                        1,
                                        &m_patchedValue,
                                        &written);

    if (FAILED(hr))
        g_pShell->ReportError(hr);

    if (written != 1)
        g_pShell->Write( L"Unable to write memory!\n" );
}


void DebuggerBreakpoint::ChangeSourceFile (WCHAR *filename)
{
    // first, check to see if the file even exists. Otherwise error out.
    MAKE_ANSIPTR_FROMWIDE (fnameA, filename);
    _ASSERTE (fnameA != NULL);

    FILE *stream = fopen (fnameA, "r");
    DebuggerSourceFile *pSource = NULL;

    if (stream != NULL)
    {
        fclose (stream);

        if (m_managed)
        {
            BreakpointModuleNode *pCurNode = m_pModuleList;

            while (pCurNode != NULL)
            {
                if ((m_doc == NULL) &&
                    (pCurNode->m_pModule->GetSymbolReader() != NULL))
                {
                    // Get the source file token by name
                    GUID g = {0};
                    ISymUnmanagedDocument *doc = NULL;
                    HRESULT hr = pCurNode->m_pModule->GetSymbolReader()->GetDocument(filename,
                                                                        g, g, g,
                                                                        &doc);

                    // If the source file wasn't found, see if we can find it using
                    // the short name, since the meta data stores only relative paths.
                    if (hr == CLDB_E_RECORD_NOTFOUND)
                    {
                        char        rcFile[_MAX_FNAME];
                        char        rcExt[_MAX_EXT];

                        MAKE_ANSIPTR_FROMWIDE(nameA, filename);
                        _splitpath(nameA, NULL, NULL, rcFile, rcExt);
                        strcat(rcFile, rcExt);

                        MAKE_WIDEPTR_FROMANSI(nameW, rcFile);
                        hr = pCurNode->m_pModule->GetSymbolReader()->GetDocument(nameW,
                                                                    g, g, g,
                                                                    &doc);

                    }

                    m_doc = doc;
                }

                if (m_doc != NULL)
                {
                    if ((pSource = pCurNode->m_pModule->ResolveSourceFile (m_doc)) != NULL)
                    {
                        pSource->ReloadText (filename, true);
                    }
                }
                else
                {
                    g_pShell->Write(L"Could not associate the given source file.\n");
                    g_pShell->Write(L"Please check that the file name (and path) was entered correctly.\n");
                    g_pShell->Write(L"This problem could also arise if files were compiled without the debug flag.\n");

                }

                pCurNode = pCurNode->m_pNext;
            }
        }
    }
    else
    {
        g_pShell->Write(L"Could not locate/open given file.\n");
    }
}



void DebuggerBreakpoint::UpdateName (WCHAR *pstrName)
{
    // save the old name just in case we run out of memory
    // while allocating memory for the new name
    WCHAR *pTemp = m_name;
    int iLength = wcslen (pstrName);

    if ((m_name = new WCHAR [iLength+1]) != NULL)
    {
        wcscpy (m_name, pstrName);
        delete [] pTemp;
    }
    else
        m_name = pTemp;

}

// This will return true if this breakpoint is associated
// with the pModule argument
bool DebuggerBreakpoint::IsBoundToModule(DebuggerModule *pModule)
{
    for (BreakpointModuleNode *pCur = m_pModuleList; pCur != NULL; pCur = pCur->m_pNext)
    {
        if (pCur->m_pModule == pModule)
            return (true);
    }

    return (false);
}

bool DebuggerBreakpoint::AddBoundModule(DebuggerModule *pModule)
{
    // Make sure we don't add it twice.
    if (IsBoundToModule(pModule))
        return (false);

    // Create new node
    BreakpointModuleNode *pNewNode = new BreakpointModuleNode;
    _ASSERTE(pNewNode != NULL && "Out of memory!!!");

    // OOM?
    if (!pNewNode)
        return (false);

    // Tack it onto the front of the list
    pNewNode->m_pModule = pModule;
    pNewNode->m_pNext = m_pModuleList;
    m_pModuleList = pNewNode;

    // Indicate success
    return (true);
}

bool DebuggerBreakpoint::RemoveBoundModule(DebuggerModule *pModule)
{
    if (!IsBoundToModule(pModule))
        return (false);

    // Find the module in the list
    for (BreakpointModuleNode **ppCur = &m_pModuleList;
        *ppCur != NULL && (*ppCur)->m_pModule != pModule;
        ppCur = &((*ppCur)->m_pNext));

    _ASSERTE(*ppCur != NULL);

    // Remove the module from the list
    BreakpointModuleNode *pDel = *ppCur;

    // First case, the node is the first one in the list
	if (pDel == m_pModuleList) {
        m_pModuleList = pDel->m_pNext;
        pDel->m_pModule = NULL;
        pDel->m_pNext = NULL;
        delete pDel;
		return (true);
	}

	// Otherwise, get the module before pDel in the list
    for (BreakpointModuleNode *pBefore = m_pModuleList; pBefore != NULL; pBefore = pBefore->m_pNext)
    {
        if (pBefore->m_pNext == pDel)
            break;
    }
    _ASSERTE(pBefore != NULL);
    pBefore->m_pNext = pDel->m_pNext;
    pDel->m_pModule = NULL;
    pDel->m_pNext = NULL;
    delete pDel;

    return (true);
}


/* ------------------------------------------------------------------------- *
 * Debugger FilePathCache
 * ------------------------------------------------------------------------- */

// This function looks for an existing "foo.deb" file and reads in the 
// contents and fills the structures.
HRESULT DebuggerFilePathCache::Init (void)
{
    int i=0;

    // Set the path elements from the current path.
    _ASSERTE (g_pShell->m_currentSourcesPath != NULL);

    WCHAR *pszTemp;

    if ((pszTemp = new WCHAR [wcslen(g_pShell->m_currentSourcesPath)+1]) != NULL)
    {
        wcscpy (pszTemp, g_pShell->m_currentSourcesPath);
        g_pShell->UpdateCurrentPath (pszTemp);
        delete [] pszTemp;
    }

    // free up the cache
    for (i=0; i<m_iCacheCount; i++)
    {
        delete [] m_rpstrModName [i];
        delete [] m_rpstrFullPath [i];

        m_rpstrModName [i] = NULL;
        m_rpstrFullPath [i] = NULL;
        m_rDocs [i] = NULL;
    }

    m_iCacheCount = 0;

    return S_OK;
}

// This function is used for separating out the individual paths
// from the passed path string
HRESULT DebuggerFilePathCache::InitPathArray (WCHAR *pstrName)
{
    bool bDone = false;
    int iBegin;
    int iEnd;
    int iCounter = 0;
    int iIndex = 0;

    // first, free the existing array members (if any)
    while (m_iPathCount-- > 0)
    {
        delete [] m_rstrPath [m_iPathCount];
        m_rstrPath [m_iPathCount] = NULL;
    }

    MAKE_ANSIPTR_FROMWIDE(nameA, pstrName);
    _ASSERTE (nameA != NULL);
    if (nameA == NULL)
        return (E_OUTOFMEMORY);


    while (bDone == false)
    {
        iBegin = iCounter;
        while ((nameA [iCounter] != ';') && (nameA [iCounter] != '\0'))
            iCounter++;

        if (nameA [iCounter] == '\0')
            bDone = true;

        iEnd = iCounter++;

        if (iEnd != iBegin)
        {
            int iStrLen = iEnd - iBegin;

            _ASSERTE (iStrLen > 0);
            _ASSERTE (iIndex < MAX_PATH_ELEMS);
            if ((m_rstrPath [iIndex] = new CHAR [iStrLen + 1]) != NULL)
            {
                // copy the extracted string
                strncpy (m_rstrPath [iIndex], &(nameA [iBegin]), iStrLen);

                // null terminate
                m_rstrPath [iIndex][iStrLen] = L'\0';

                iIndex++;
            }
            else
                return (E_OUTOFMEMORY);
        }
    }

    m_iPathCount = iIndex;

    return (S_OK);
}



int DebuggerFilePathCache::GetFileFromCache(DebuggerModule *pModule,
                                            ISymUnmanagedDocument *doc, 
                                            CHAR **ppstrFName)
{
    *ppstrFName = NULL;
    if ((m_iCacheCount == 0) || (pModule == NULL) || !doc)
        return -1;

    for (int i=0; i<m_iCacheCount; i++)
    {

        if (m_rDocs [i] == doc)
        {
            // check if the module names also match

            // allocate memory and store the data
            WCHAR strModuleName [MAX_PATH+1];
            ULONG32 NameLength;

            // Initialize module name to null
            strModuleName [0] = L'\0';

            // Now get the module name
            pModule ->GetICorDebugModule()->GetName(MAX_PATH, &NameLength, strModuleName);

            // Convert module name to ANSI and store
            MAKE_ANSIPTR_FROMWIDE (ModNameA, strModuleName);
            _ASSERTE (ModNameA != NULL);

            // Convert the module name to lowercae before comparing
            char *pszTemp = ModNameA;

            while (*pszTemp != '\0')
            {
                *pszTemp = tolower (*pszTemp);
                pszTemp++;
            }

            if (!strcmp (ModNameA, m_rpstrModName [i]))
            {
                // The names match. So return the source file name
                _ASSERTE (m_rpstrFullPath[i] != NULL);
                if ((*ppstrFName = new char [strlen(m_rpstrFullPath[i]) + 1]) != NULL)
                {
                    strcpy (*ppstrFName, m_rpstrFullPath[i]);
                }

                // found it. So exit loop.
                return (i);
            }
        }
    }

    return (-1);
}


BOOL    DebuggerFilePathCache::UpdateFileCache (DebuggerModule *pModule, 
                                                ISymUnmanagedDocument *doc,
                                                CHAR *pFullPath)
{
    char *pszString;

    // first, convert the file name to lowercase
    char *pTemp = pFullPath;

    if (pTemp)
    {
        while (*pTemp)
        {
            *pTemp = tolower (*pTemp);
            pTemp++;
        }
    }

    // check if this is an addition or modification
    int iCacheIndex = GetFileFromCache (pModule, doc, &pszString);

    if (iCacheIndex != -1)
    {
        // if the names match, then no need to do anything. Simply return!
        if (!strcmp (pFullPath, pszString))
        {
            delete [] pszString;
            return true;
        }

        delete [] pszString;

        _ASSERTE (iCacheIndex < m_iCacheCount);
        // an entry already exists - so update it

        // first, delete the existing path
        delete [] m_rpstrFullPath [iCacheIndex];

        if ((m_rpstrFullPath [iCacheIndex] = new char [strlen (pFullPath) +1]) == NULL)
        {
            // free up the memory allocated for module name
            delete [] m_rpstrModName [iCacheIndex];
            m_rpstrModName [iCacheIndex] = NULL;
            m_rDocs [iCacheIndex] = NULL;
            return false;
        }

        strcpy (m_rpstrFullPath [iCacheIndex], pFullPath);
        return true;
    }
    
    // Create a new entry
    if (pFullPath)
    {
        if (m_iCacheCount < MAX_CACHE_ELEMS)
        {
            m_rpstrModName [m_iCacheCount] = NULL;
            m_rpstrFullPath [m_iCacheCount] = NULL;
            m_rDocs [m_iCacheCount] = NULL;

            // allocate memory and store the data
            WCHAR strModuleName [MAX_PATH+1];
            ULONG32 NameLength;

            // Initialize module name to null
            strModuleName [0] = L'\0';

            // Now get the module name
            pModule ->GetICorDebugModule()->GetName(MAX_PATH, &NameLength, strModuleName);

            // Convert module name to ANSI and store
            MAKE_ANSIPTR_FROMWIDE (ModNameA, strModuleName);
            _ASSERTE (ModNameA != NULL);

            if ((m_rpstrModName [m_iCacheCount] = new char [strlen (ModNameA) +1]) == NULL)
                return false;

            strcpy (m_rpstrModName[m_iCacheCount], ModNameA);

            // convert the module name to lowercase
            char *pszTemp = m_rpstrModName [m_iCacheCount];
            while (*pszTemp != '\0')
            {
                *pszTemp = tolower (*pszTemp);
                pszTemp++;
            }

            // Also store full pathname and document
            if ((m_rpstrFullPath [m_iCacheCount] = new char [strlen (pFullPath) +1]) == NULL)
            {
                // free up the memory alloacted for module name
                delete [] m_rpstrModName [m_iCacheCount];
                m_rpstrModName [m_iCacheCount] = NULL;
                return false;
            }

            strcpy (m_rpstrFullPath [m_iCacheCount], pFullPath);

            m_rDocs [m_iCacheCount] = doc;
            doc->AddRef();

            m_iCacheCount++;

        }
        else
            return false;
    }

    return true;
}



// This sets the full file name as well as the stripped file name
BOOL    ModuleSourceFile::SetFullFileName (ISymUnmanagedDocument *doc,
                                           LPCSTR pstrFullFileName)
{

    m_SFDoc = doc;
    m_SFDoc->AddRef();

    int iLen = MultiByteToWideChar (CP_ACP, 0, pstrFullFileName, -1, NULL, 0); 

    m_pstrFullFileName = new WCHAR [iLen];

    _ASSERTE (m_pstrFullFileName != NULL);

    if (m_pstrFullFileName)
    {
        if (MultiByteToWideChar (CP_ACP, 0, pstrFullFileName, -1, m_pstrFullFileName, iLen))
        {
            // strip the path and store just the lowercase file name
            WCHAR       rcFile[_MAX_FNAME];
            WCHAR       rcExt[_MAX_EXT];

            _wsplitpath(m_pstrFullFileName, NULL, NULL, rcFile, rcExt);
            wcscat(rcFile, rcExt);
            iLen = wcslen (rcFile);

            m_pstrStrippedFileName = new WCHAR [iLen + 1];

            wcscpy(m_pstrStrippedFileName, rcFile);
        }
        else
            return false;
    }
    else
        return false;

    return true;
}


void DebuggerShell::DumpMemory(BYTE *pbMemory, 
                               CORDB_ADDRESS ApparantStartAddr,
                               ULONG32 cbMemory, 
                               ULONG32 WORD_SIZE, 
                               ULONG32 iMaxOnOneLine, 
                               BOOL showAddr)
{
    int nBase;
    WCHAR wsz[20];
    ULONG32 iPadding;
    ULONG32 ibPrev;
            
    if (m_rgfActiveModes & DSM_DISPLAY_REGISTERS_AS_HEX)
        nBase = 16;
    else
        nBase = 10;

    ULONG32 ib = 0;

    while (ib < cbMemory)
    {
        if ((ib % (WORD_SIZE * iMaxOnOneLine)) == 0)
        {
            // beginning or end of line
            if (ib != 0)
            {
                if (WORD_SIZE == 1)
                {
                    // end of 2nd+line: spit out bytes in ASCII/Unicode
                    Write(L"  ");
                            
                    for (ULONG32 ibPrev = ib - (WORD_SIZE * iMaxOnOneLine); ibPrev < ib; ibPrev++)
                    {
                        BYTE b = *(pbMemory + ibPrev);

                        if (b >= 0x21 && b <= 0x7e) // print only printable characters
                            Write(L"%C", b);
                        else
                            Write(L".");
                    }
                }
            }   //spit out address to be displayed

            if (showAddr)
                Write(L"\n%8x", (ULONG32)ApparantStartAddr + ib);
        }

        if ((ib % WORD_SIZE) == 0)
        {
            //put spaces between words
            Write(L" ");
        }

        // print bytes in hex
        BYTE *pThisByte = pbMemory + ib + ((ib % WORD_SIZE) - WORD_SIZE) +
            (((2 * WORD_SIZE) - 1) - ((ib % WORD_SIZE) * (WORD_SIZE -1)));
        _itow((int)*pThisByte, wsz, nBase);

        // make sure to always print at least two characters
        if ((*(pThisByte) < 0x10 && nBase == 16) || (*(pThisByte) < 10 && nBase == 10))
            Write(L"0%s", wsz);
        else
            Write(L"%s", wsz);

        ib++;
    }
            
    if ((ib % (WORD_SIZE * iMaxOnOneLine)) != 0)
    {
        // stopped halfway through last line put the missing spaces in so this doesn't look weird
        for (iPadding = (WORD_SIZE * iMaxOnOneLine) - (ib % (WORD_SIZE * iMaxOnOneLine)); iPadding > 0; iPadding--)
        {
            if ((iPadding % WORD_SIZE) == 0)
                Write(L" ");

            Write(L" ");
        }

        Write(L" ");
    }

    // print out the characters for the final line
    ibPrev = ib - (ib % (WORD_SIZE * iMaxOnOneLine));

    if (ibPrev == ib) //we landed on the line edge
    {
        ibPrev = ib - (WORD_SIZE * iMaxOnOneLine); 
        Write(L"  ");
    }

    if (WORD_SIZE == 1)
    {
        for (; ibPrev < ib; ibPrev++)
        {   
            BYTE b = *(pbMemory + ibPrev);

            if ((b < 'A' || b > 'z') && (b != '?'))
                Write(L".");
            else
                Write(L"%C", b);
        }
    }
}

//
// Some very basic filtering of first chance exceptions. This builds a list of exception types to catch or ignore. If
// you pass NULL for exType, it will just print the current list.
//
HRESULT DebuggerShell::HandleSpecificException(WCHAR *exType, bool shouldCatch)
{
    ExceptionHandlingInfo *i;
    ExceptionHandlingInfo *h = NULL;

    // Find any existing entry.
    for (i = m_exceptionHandlingList; i != NULL; i = i->m_next)
    {
        if ((exType != NULL) && !wcscmp(exType, i->m_exceptionType))
            h = i;
        else
            Write(L"%s %s\n", i->m_catch ? L"Catch " : L"Ignore", i->m_exceptionType);
    }

    if (exType != NULL)
    {
        // If none was found, make a new one and shove it into the front of the list.
        if (h == NULL)
        {
            h = new ExceptionHandlingInfo();

            if (h == NULL)
                return E_OUTOFMEMORY;
        
            // Make a copy of the exception type.
            h->m_exceptionType = new WCHAR[wcslen(exType) + 1];

            if (h->m_exceptionType == NULL)
            {
                delete h;
                return E_OUTOFMEMORY;
            }
        
            wcscpy(h->m_exceptionType, exType);

            h->m_next = m_exceptionHandlingList;
            m_exceptionHandlingList = h;
        }

        // Remember if we should catch or ignore this exception type.
        h->m_catch = shouldCatch;

        Write(L"%s %s\n", h->m_catch ? L"Catch " : L"Ignore", h->m_exceptionType);
    }
    
    return S_OK;
}

//
// If we have specific exception handling info for a given exception type, this will return S_OK and fill in
// shouldCatch. Otherwise, returns S_FALSE.
//
bool DebuggerShell::ShouldHandleSpecificException(ICorDebugValue *pException)
{
    ICorDebugClass *iclass = NULL;
    ICorDebugObjectValue *iobject = NULL;
    ICorDebugModule *imodule = NULL;
    
    // Default to the global catch/ignore setting for first chance exceptions.
    bool stop = g_pShell->m_catchException;

    // Add an extra reference to pException. StripReferences is going to release it as soon as it dereferences it, but
    // the caller is expecting it to still be alive.
    pException->AddRef();
    
    // We need the type name out of this exception object.
    HRESULT hr = StripReferences(&pException, false);

    if (FAILED(hr))
        goto Exit;

    // Grab the element type so we can verify its an object.
    CorElementType type;
    hr = pException->GetType(&type);

    if (FAILED(hr))
        goto Exit;

    if ((type != ELEMENT_TYPE_CLASS) && (type != ELEMENT_TYPE_OBJECT))
        goto Exit;

    // It had better be an object by this point...
    hr = pException->QueryInterface(IID_ICorDebugObjectValue, (void **) &iobject);

    if (FAILED(hr))
        goto Exit;

    // Snagg the object's class.
    hr = iobject->GetClass(&iclass);
    
    if (FAILED(hr))
        goto Exit;

    // Get the class's token
    mdTypeDef tdClass;
    hr = iclass->GetToken(&tdClass);

    if (FAILED(hr))
        goto Exit;

    // Get the module from this class
    iclass->GetModule(&imodule);
    
    if (FAILED(hr))
        goto Exit;

    DebuggerModule *dm = DebuggerModule::FromCorDebug(imodule);
    _ASSERTE(dm != NULL);

    // Get the class name
    WCHAR       className[MAX_CLASSNAME_LENGTH];
    ULONG       classNameSize;
    mdToken     parentTD;

    hr = dm->GetMetaData()->GetTypeDefProps(tdClass, className, MAX_CLASSNAME_LENGTH, &classNameSize, NULL, &parentTD);
    
    if (FAILED(hr))
        goto Exit;

    ExceptionHandlingInfo *i;

    // Find any existing entry.
    for (i = m_exceptionHandlingList; i != NULL; i = i->m_next)
    {
        if (!wcscmp(className, i->m_exceptionType))
            break;
    }

    // If we've found an extry for this exception type, then handle it based on what the user asked for.
    if (i != NULL)
    {
        stop = i->m_catch;
    }

Exit:
    if (imodule)
        RELEASE(imodule);

    if (iclass)
        RELEASE(iclass);

    if (iobject)
        RELEASE(iobject);
    
    return stop;
}

//
// Do a command once for every thread in the process.
//
void DebuggerShell::DoCommandForAllThreads(const WCHAR *string)
{
    HRESULT hr;
    ICorDebugThreadEnum *e = NULL;
    ICorDebugThread *ithread = NULL;

    // Must have a current process.
    if (m_currentProcess == NULL)
    {
        Error(L"Process not running.\n");
        goto Exit;
    }

    // Enumerate the process' threads
    hr = m_currentProcess->EnumerateThreads(&e);

    if (FAILED(hr))
    {
        ReportError(hr);
        goto Exit;
    }

    ULONG count;  // indicates how many records were retrieved

    hr = e->GetCount(&count);

    if (FAILED(hr))
    {
        ReportError(hr);
        goto Exit;
    }

    // Alert user if there's no threads.
    if (count == 0)
    {
        Write(L"There are no managed threads\n");
        goto Exit;
    }

    m_stopLooping = false;
    
    // Execute the command once for each thread in the process
    for (hr = e->Next(1, &ithread, &count);
         SUCCEEDED(hr) && (count == 1) && !m_stopLooping && (m_currentProcess != NULL);
         hr = e->Next(1, &ithread, &count))
    {
        // Make this thread the current thread.
        SetCurrentThread(m_currentProcess, ithread);
        SetDefaultFrame();

        Write(L"\n\n");
        PrintThreadState(ithread);

        // Execute the command in the context of this thread.
        DoCommand(string);
                
        RELEASE(ithread);
    }

    // If the call to Next fails...
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Exit;
    }

Exit:
    if (e)
        RELEASE(e);
}


/* ------------------------------------------------------------------------- *
 * Methods for a signature formatter, stolen from the internals of the Runtime
 * ------------------------------------------------------------------------- */

SigFormat::SigFormat(IMetaDataImport *importer, PCCOR_SIGNATURE sigBlob, ULONG sigBlobSize, WCHAR *methodName)
{
    _fmtSig = NULL;
    _size = 0;
    _pos = 0;
    _sigBlob = sigBlob;
    _sigBlobSize = sigBlobSize;
    _memberName = methodName;
    _importer = importer;
}
    
SigFormat::~SigFormat()
{
    if (_fmtSig)
        delete _fmtSig;
}

WCHAR *SigFormat::GetString()
{
    return _fmtSig;
}

#define SIG_INC 256

int SigFormat::AddSpace()
{
    if (_pos == _size) {
        WCHAR* temp = new WCHAR[_size+SIG_INC];
        if (!temp)
            return 0;
        memcpy(temp,_fmtSig,_size);
        delete _fmtSig;
        _fmtSig = temp;
        _size+=SIG_INC;
    }
    _fmtSig[_pos] = ' ';
    _fmtSig[++_pos] = 0;
    return 1;
}

int SigFormat::AddString(WCHAR *s)
{
    int len = (int)wcslen(s);
    // Allocate on overflow
    if (_pos + len >= _size) {
        int newSize = (_size+SIG_INC > _pos + len) ? _size+SIG_INC : _pos + len + SIG_INC; 
        WCHAR* temp = new WCHAR[newSize];
        if (!temp)
            return 0;
        memcpy(temp,_fmtSig,_size);
        delete _fmtSig;
        _fmtSig = temp;
        _size=newSize;
    }
    wcscpy(&_fmtSig[_pos],s);
    _pos += len;
    return 1;
}

HRESULT SigFormat::FormatSig()
{
    _size = SIG_INC;
    _pos = 0;
    _fmtSig = new WCHAR[_size];

    ULONG cb = 0;

    // Calling convention
    ULONG conv = _sigBlob[cb++];

    // Arg count
    ULONG cArgs;
    cb += CorSigUncompressData(&_sigBlob[cb], &cArgs);

    // Return type
    cb += AddType(&_sigBlob[cb]);
    AddSpace();
    
    if (_memberName != NULL)
        AddString(_memberName);
    else
        AddSpace();
    
    AddString(L"(");

    // Loop through all of the args
    for (UINT i = 0; i < cArgs; i++)
    {
       cb += AddType(&_sigBlob[cb]);

       if (i != cArgs - 1)
           AddString(L", ");
    }

    // Display vararg signature at end
    if (conv == IMAGE_CEE_CS_CALLCONV_VARARG)
    {
        if (cArgs)
            AddString(L", ");
        
        AddString(L"...");
    }

    AddString(L")");

    return S_OK;
}

ULONG SigFormat::AddType(PCCOR_SIGNATURE sigBlob)
{
    ULONG cb = 0;

    CorElementType type = (CorElementType)sigBlob[cb++];

    // Format the output
    switch (type) 
    {
    case ELEMENT_TYPE_VOID:     AddString(L"Void"); break;
    case ELEMENT_TYPE_BOOLEAN:  AddString(L"Boolean"); break;
    case ELEMENT_TYPE_I1:       AddString(L"SByte"); break;
    case ELEMENT_TYPE_U1:       AddString(L"Byte"); break;
    case ELEMENT_TYPE_I2:       AddString(L"Int16"); break;
    case ELEMENT_TYPE_U2:       AddString(L"UInt16"); break;
    case ELEMENT_TYPE_CHAR:     AddString(L"Char"); break;
    case ELEMENT_TYPE_I4:       AddString(L"Int32"); break;
    case ELEMENT_TYPE_U4:       AddString(L"UInt32"); break;
    case ELEMENT_TYPE_I8:       AddString(L"Int64"); break;
    case ELEMENT_TYPE_U8:       AddString(L"UInt64"); break;
    case ELEMENT_TYPE_R4:       AddString(L"Single"); break;
    case ELEMENT_TYPE_R8:       AddString(L"Double"); break;
    case ELEMENT_TYPE_OBJECT:   AddString(L"Object"); break;
    case ELEMENT_TYPE_STRING:   AddString(L"String"); break;
    case ELEMENT_TYPE_I:        AddString(L"Int"); break;
    case ELEMENT_TYPE_U:        AddString(L"UInt"); break;

    case ELEMENT_TYPE_VALUETYPE:
    case ELEMENT_TYPE_CLASS:
        {
            mdToken tk;

            cb += CorSigUncompressToken(&sigBlob[cb], &tk);

            MDUTF8CSTR szUtf8NamePtr;

            HRESULT hr;
            hr = _importer->GetNameFromToken(tk, &szUtf8NamePtr);

            if (SUCCEEDED(hr))
            {
                MAKE_WIDEPTR_FROMUTF8(nameW, szUtf8NamePtr);
                AddString(nameW);
            }
            else
                AddString(L"**Unknown Type**");
            
            break;
        }
    case ELEMENT_TYPE_TYPEDBYREF:
        {
            AddString(L"TypedReference");
            break;
        }

    case ELEMENT_TYPE_BYREF:
        {
            cb += AddType(&sigBlob[cb]);
            AddString(L" ByRef");
        }
        break;

    case ELEMENT_TYPE_SZARRAY:      // Single Dim, Zero
        {
            cb += AddType(&sigBlob[cb]);
            AddString(L"[]");
        }
        break;
        
    case ELEMENT_TYPE_ARRAY:        // General Array
        {
            cb += AddType(&sigBlob[cb]);

            AddString(L"[");

            // Skip over rank
            ULONG rank;
            cb += CorSigUncompressData(&sigBlob[cb], &rank);

            if (rank > 0)
            {
                // how many sizes?
                ULONG sizes;
                cb += CorSigUncompressData(&sigBlob[cb], &sizes);

                // read out all the sizes
                unsigned int i;

                for (i = 0; i < sizes; i++)
                {
                    ULONG dimSize;
                    cb += CorSigUncompressData(&sigBlob[cb], &dimSize);

                    if (i > 0)
                        AddString(L",");
                }

                // how many lower bounds?
                ULONG lowers;
                cb += CorSigUncompressData(&sigBlob[cb], &lowers);
                
                // read out all the lower bounds.
                for (i = 0; i < lowers; i++)
                {
                    int lowerBound;
                    cb += CorSigUncompressSignedInt(&sigBlob[cb], &lowerBound);
                }
            }

            AddString(L"]");
        }
        break;

    case ELEMENT_TYPE_PTR:
        {
            cb += AddType(&sigBlob[cb]);
            AddString(L"*");
            break;
        }

    case ELEMENT_TYPE_CMOD_REQD:
        AddString(L"CMOD_REQD");
        cb += AddType(&sigBlob[cb]);
        break;
        
    case ELEMENT_TYPE_CMOD_OPT:
        AddString(L"CMOD_OPT");
        cb += AddType(&sigBlob[cb]);
        break;
        
    case ELEMENT_TYPE_MODIFIER:
        cb += AddType(&sigBlob[cb]);
        break;
    
    case ELEMENT_TYPE_PINNED:
        AddString(L"pinned");
        cb += AddType(&sigBlob[cb]);
        break;
    
    case ELEMENT_TYPE_SENTINEL:
        break;
    
    default:
        AddString(L"**UNKNOWN TYPE**");
    }
    
    return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <windows.h>
#include <crtdbg.h>
#include <malloc.h>
#include <direct.h>

#include "DebuggerUtil.h"
#include "dshell.h"
#include "__file__.h"

#define MAX_CLASSNAME_LENGTH    1024

#ifdef _DEBUG

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\internalonly.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: InternalOnly.cpp
//
// Internal only helper code that should never go outside of Microsoft.
//
//*****************************************************************************
#ifndef __InternalOnly_h__
#define __InternalOnly_h__

#ifndef BadError
#define BadError(hr) (hr)
#endif

#ifndef PostError
#define PostError(hr) (hr)
#endif

#ifndef OutOfMemory
#define OutOfMemory() (E_OUTOFMEMORY)
#endif

/* ------------------------------------------------------------------------- *
 * Global variable declarations
 * ------------------------------------------------------------------------- */
// Every time an EnC happens, we bump this up.  @todo We should probably
// adjust the granularity so that it's per appdomain, or per assembly,
// but for now we'll just do the extra work.
extern ULONG g_EditAndContinueCounter;


class EditAndContinueDebuggerCommand : public DebuggerCommand
{
public:
    EditAndContinueDebuggerCommand(const WCHAR *name, int minMatchLength = 0);
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args);
    void Help(Shell *shell);
    const WCHAR *ShortHelp(Shell *shell);
protected:
    void SetILMaps(ICorDebugEditAndContinueSnapshot *pISnapshot,
                   DebuggerShell *shell);
};

class CompileForEditAndContinueCommand : public DebuggerCommand
{
public:
    CompileForEditAndContinueCommand(const WCHAR *name, int minMatchLength = 0);
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args);
    void Help(Shell *shell);
    const WCHAR *ShortHelp(Shell *shell);
};

class DisassembleDebuggerCommand : public DebuggerCommand
{
public:
    DisassembleDebuggerCommand(const WCHAR *name, int minMatchLength = 0);
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args);
    void Help(Shell *shell);
    const WCHAR *ShortHelp(Shell *shell);
};

class ConnectDebuggerCommand : public DebuggerCommand
{
public:
    ConnectDebuggerCommand(const WCHAR *name, int minMatchLength = 0);
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args);
    void Help(Shell *shell);
    const WCHAR *ShortHelp(Shell *shell);
};

class ClearUnmanagedExceptionCommand : public DebuggerCommand
{
public:
    ClearUnmanagedExceptionCommand(const WCHAR *name, int minMatchLength = 0);
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args);
    void Help(Shell *shell);
    const WCHAR *ShortHelp(Shell *shell);
};

// Unmanaged commands
class UnmanagedThreadsDebuggerCommand : public DebuggerCommand
{
private:
	BOOL  m_unmanaged;
public:
    UnmanagedThreadsDebuggerCommand(const WCHAR *name, int minMatchLength = 0);
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args);
    void Help(Shell *shell);
    const WCHAR *ShortHelp(Shell *shell);
};

class UnmanagedWhereDebuggerCommand : public DebuggerCommand
{
private:
	BOOL  m_unmanaged;

public:
    UnmanagedWhereDebuggerCommand(const WCHAR *name, int minMatchLength = 0);
    void Do(DebuggerShell *shell, ICorDebug *cor, const WCHAR *args);
	void Help(Shell *shell);
    const WCHAR *ShortHelp(Shell *shell);
};

//@Todo:  this is a stolen copy of the code from stgpool.cpp because
// (a) I need this code to test E&C, and (b) we can't link in full utilcode
// because this ships as a sample.

//*****************************************************************************
// Unfortunately the CreateStreamOnHGlobal is a little too smart in that
// it gets its size from GlobalSize.  This means that even if you give it the
// memory for the stream, it has to be globally allocated.  We don't want this
// because we have the stream read only in the middle of a memory mapped file.
// CreateStreamOnMemory and the corresponding, internal only stream object solves
// that problem.
//*****************************************************************************
class CInMemoryStream : public IStream
{
public:
    CInMemoryStream() :
        m_pMem(0),
        m_cbSize(0),
        m_cbCurrent(0),
        m_cRef(1)
    { }

    void InitNew(
        void        *pMem,
        ULONG       cbSize)
    {
        m_pMem = pMem;
        m_cbSize = cbSize;
        m_cbCurrent = 0;
    }

    ULONG STDMETHODCALLTYPE AddRef() {
        return (InterlockedIncrement((long *) &m_cRef));
    }


    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppOut);

    HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);

    HRESULT STDMETHODCALLTYPE Write(const void  *pv, ULONG cb, ULONG *pcbWritten);

    HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);

    HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream     *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten);

    HRESULT STDMETHODCALLTYPE Commit(
        DWORD       grfCommitFlags)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE Revert()
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD       dwLockType)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD       dwLockType)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG     *pstatstg,
        DWORD       grfStatFlag)
    {
        pstatstg->cbSize.QuadPart = m_cbSize;
        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE Clone(
        IStream     **ppstm)
    {
        return (BadError(E_NOTIMPL));
    }

    static HRESULT CreateStreamOnMemory(           // Return code.
                                 void        *pMem,                  // Memory to create stream on.
                                 ULONG       cbSize,                 // Size of data.
                                 IStream     **ppIStream);            // Return stream object here.

private:
    void        *m_pMem;                // Memory for the read.
    ULONG       m_cbSize;               // Size of the memory.
    ULONG       m_cbCurrent;            // Current offset.
    ULONG       m_cRef;                 // Ref count.
};


#endif // __InternalOnly_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\utf.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.

--*/



//
//  Include Files.
//

#include <ole2.h>
#define NlsStrLenW(x) lstrlenW(x)
#include "utf.h"




//
//  Forward Declarations.
//

int
UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);



//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTFCPInfo
//
//  Gets the CPInfo for the given UTF code page.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer)
{
    int ctr;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - lpCPInfo is NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            lpCPInfo->MaxCharSize = 5;
            break;
        }
        case ( CP_UTF8 ) :
        {
            lpCPInfo->MaxCharSize = 3;
            break;
        }
    }

    (lpCPInfo->DefaultChar)[0] = '?';
    (lpCPInfo->DefaultChar)[1] = (BYTE)0;

    for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
    {
        (lpCPInfo->LeadByte)[ctr] = (BYTE)0;
    }

    if (fExVer)
    {
        LPCPINFOEXW lpCPInfoEx = (LPCPINFOEXW)lpCPInfo;

        lpCPInfoEx->UnicodeDefaultChar = L'?';
        lpCPInfoEx->CodePage = CodePage;
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  UTFToUnicode
//
//  Maps a UTF character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchMultiByte <= -1)
    {
        cchMultiByte = (int)(strlen(lpMultiByteStr) + 1);
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UTF7ToUnicode( lpMultiByteStr,
                                cchMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UTF8ToUnicode( lpMultiByteStr,
                                cchMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF
//
//  Maps a Unicode character string to its UTF string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //     - lpDefaultChar and lpUsedDefaultChar not NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchWideChar == 0) || (cchMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cchMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) ||
         (lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UnicodeToUTF7( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cchMultiByte );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UnicodeToUTF8( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cchMultiByte );
            break;
        }
    }

    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTF7ToUnicode
//
//  Maps a UTF-7 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    LPCSTR pUTF7 = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer to hold temporary bits
    int iPos = 0;                 // 6-bit position pointer in the buffer
    int cchWC = 0;                // # of Unicode code points generated


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        if (*pUTF7 > ASCII)
        {
            //
            //  Error - non ASCII char, so zero extend it.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF7;
            }
            cchWC++;
        }
        else if (!fShift)
        {
            //
            //  Not in shifted sequence.
            //
            if (*pUTF7 == SHIFT_IN)
            {
                if (cchSrc && (pUTF7[1] == SHIFT_OUT))
                {
                    //
                    //  "+-" means "+"
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    pUTF7++;
                    cchSrc--;
                    cchWC++;
                }
                else
                {
                    //
                    //  Start a new shift sequence.
                    //
                    fShift = TRUE;
                }
            }
            else
            {
                //
                //  No need to shift.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR)*pUTF7;
                }
                cchWC++;
            }
        }
        else
        {
            //
            //  Already in shifted sequence.
            //
            if (nBitBase64[*pUTF7] == -1)
            {
                //
                //  Any non Base64 char also ends shift state.
                //
                if (*pUTF7 != SHIFT_OUT)
                {
                    //
                    //  Not "-", so write it to the buffer.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    cchWC++;
                }

                //
                //  Reset bits.
                //
                fShift = FALSE;
                dwBit = 0;
                iPos = 0;
            }
            else
            {
                //
                //  Store the bits in the 6-bit buffer and adjust the
                //  position pointer.
                //
                dwBit |= ((DWORD)nBitBase64[*pUTF7]) << (26 - iPos);
                iPos += 6;
            }

            //
            //  Output the 16-bit Unicode value.
            //
            while (iPos >= 16)
            {
                if (cchDest)
                {
                    if (cchWC < cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)(dwBit >> 16);
                    }
                    else
                    {
                        break;
                    }
                }
                cchWC++;

                dwBit <<= 16;
                iPos -= 16;
            }
            if (iPos >= 16)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }

        pUTF7++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    char UTF8;


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                //
                //  Make room for the trail byte and add the trail byte
                //  value.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] <<= 6;
                    lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                }

                if (nTB == 0)
                {
                    //
                    //  End of sequence.  Advance the output counter.
                    //
                    cchWC++;
                }
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF7
//
//  Maps a Unicode character string to its UTF-7 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer
    int iPos = 0;                 // 6-bit position in buffer
    int cchU7 = 0;                // # of UTF7 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU7 < cchDest)))
    {
        if ((*lpWC > ASCII) || (fShiftChar[*lpWC]))
        {
            //
            //  Need shift.  Store 16 bits in buffer.
            //
            dwBit |= ((DWORD)*lpWC) << (16 - iPos);
            iPos += 16;

            if (!fShift)
            {
                //
                //  Not in shift state, so add "+".
                //
                if (cchDest)
                {
                    lpDestStr[cchU7] = SHIFT_IN;
                }
                cchU7++;

                //
                //  Go into shift state.
                //
                fShift = TRUE;
            }

            //
            //  Output 6 bits at a time as Base64 chars.
            //
            while (iPos >= 6)
            {
                if (cchDest)
                {
                    if (cchU7 < cchDest)
                    {
                        //
                        //  26 = 32 - 6
                        //
                        lpDestStr[cchU7] = cBase64[(int)(dwBit >> 26)];
                    }
                    else
                    {
                        break;
                    }
                }

                cchU7++;
                dwBit <<= 6;           // remove from bit buffer
                iPos -= 6;             // adjust position pointer
            }
            if (iPos >= 6)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }
        else
        {
            //
            //  No need to shift.
            //
            if (fShift)
            {
                //
                //  End the shift sequence.
                //
                fShift = FALSE;

                if (iPos != 0)
                {
                    //
                    //  Some bits left in dwBit.
                    //
                    if (cchDest)
                    {
                        if ((cchU7 + 1) < cchDest)
                        {
                            lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                    else
                    {
                        cchU7 += 2;
                    }

                    dwBit = 0;         // reset bit buffer
                    iPos  = 0;         // reset postion pointer
                }
                else
                {
                    //
                    //  Simply end the shift sequence.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchU7++] = SHIFT_OUT;
                    }
                    else
                    {
                        cchU7++;
                    }
                }
            }

            //
            //  Write the character to the buffer.
            //  If the character is "+", then write "+-".
            //
            if (cchDest)
            {
                if (cchU7 < cchDest)
                {
                    lpDestStr[cchU7++] = (char)*lpWC;

                    if (*lpWC == SHIFT_IN)
                    {
                        if (cchU7 < cchDest)
                        {
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU7++;

                if (*lpWC == SHIFT_IN)
                {
                    cchU7++;
                }
            }
        }

        lpWC++;
    }

    //
    //  See if we're still in the shift state.
    //
    if (fShift)
    {
        if (iPos != 0)
        {
            //
            //  Some bits left in dwBit.
            //
            if (cchDest)
            {
                if ((cchU7 + 1) < cchDest)
                {
                    lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                    lpDestStr[cchU7++] = SHIFT_OUT;
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7 += 2;
            }
        }
        else
        {
            //
            //  Simply end the shift sequence.
            //
            if (cchDest)
            {
                lpDestStr[cchU7++] = SHIFT_OUT;
            }
            else
            {
                cchU7++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-7 characters written.
    //
    return (cchU7);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int cchU8 = 0;                // # of UTF8 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        if (*lpWC <= ASCII)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchU8] = (char)*lpWC;
            }
            cchU8++;
        }
        else if (*lpWC <= UTF8_2_MAX)
        {
            //
            //  Found 2 byte sequence if < 0x07ff (11 bits).
            //
            if (cchDest)
            {
                if ((cchU8 + 1) < cchDest)
                {
                    //
                    //  Use upper 5 bits in first byte.
                    //  Use lower 6 bits in second byte.
                    //
                    lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU8 += 2;
            }
        }
        else
        {
            //
            //  Found 3 byte sequence.
            //
            if (cchDest)
            {
                if ((cchU8 + 2) < cchDest)
                {
                    //
                    //  Use upper  4 bits in first byte.
                    //  Use middle 6 bits in second byte.
                    //  Use lower  6 bits in third byte.
                    //
                    lpDestStr[cchU8++] = UTF8_1ST_OF_3 | (*lpWC >> 12);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                    lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU8 += 3;
            }
        }

        lpWC++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\utf.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    utf.h

Abstract:

    This file contains the header information for the UTF module of NLS.

Revision History:

    02-06-96    JulieB    Created.

--*/



//
//  Constant Declarations.
//

#define ASCII             0x007f

#define SHIFT_IN          '+'     // beginning of a shift sequence
#define SHIFT_OUT         '-'     // end       of a shift sequence

#define UTF8_2_MAX        0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2     0xc0    // 110x xxxx
#define UTF8_1ST_OF_3     0xe0    // 1110 xxxx
#define UTF8_TRAIL        0x80    // 10xx xxxx

#define HIGER_6_BIT(u)    ((u) >> 12)
#define MIDDLE_6_BIT(u)   (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)    ((u) & 0x003f)

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)




/////////////////////////
//                     //
//  Unicode -> UTF-7   //
//                     //
/////////////////////////

//
//  Convert one Unicode to 2 2/3 Base64 chars in a shifted sequence.
//  Each char represents a 6-bit portion of the 16-bit Unicode char.
//
CONST char cBase64[] =

  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  // A : 000000 .... 011001  ( 0 - 25)
  "abcdefghijklmnopqrstuvwxyz"  // a : 011010 .... 110011  (26 - 51)
  "0123456789"                  // 0 : 110100 .... 111101  (52 - 61)
  "+/";                         // + : 111110, / : 111111  (62 - 63)

//
//  To determine if an ASCII char needs to be shifted.
//    1 :     to be shifted
//    0 : not to be shifted
//
CONST BOOLEAN fShiftChar[] =
{
  0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,    // Null, Tab, LF, CR
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // Space '() +,-./
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,    // 0123456789:    ?
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  ABCDEFGHIJKLMNO
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,    // PQRSTUVWXYZ
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  abcdefghijklmno
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1     // pqrstuvwxyz
};




/////////////////////////
//                     //
//  UTF-7 -> Unicode   //
//                     //
/////////////////////////

//
//  Convert a Base64 char in a shifted sequence to a 6-bit portion of a
//  Unicode char.
//  -1 means it is not a Base64
//
CONST char nBitBase64[] =
{
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,   //            +   /
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,   // 0123456789
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,   //  ABCDEFGHIJKLMNO
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,   // PQRSTUVWXYZ
  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,   //  abcdefghijklmno
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1    // pqrstuvwxyz
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\delayimp\delayhk1.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define STRICT
#include <windows.h>
#pragma hdrstop
#include "delayImp.h"

// The "total hook" hook that gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == dliStartProcessing on this call.
//
extern "C"
PfnDliHook   __pfnDliFailureHook = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\source.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"


#ifdef _INTERNAL_DEBUG_SUPPORT_    
#include "InternalOnly.h"
#endif 

#define BUF_SIZE 256

/* ------------------------------------------------------------------------- *
 * Debugger base class
 * ------------------------------------------------------------------------- */

DebuggerHashTable::~DebuggerHashTable()
{
    HASHFIND    find;

    for (DebuggerHashEntry *entry = (DebuggerHashEntry *) FindFirstEntry(&find);
        entry != NULL;
        entry = (DebuggerHashEntry *) FindNextEntry(&find))
        delete entry->pBase;
}

HRESULT DebuggerHashTable::AddBase(DebuggerBase *pBase)
{
    if (!m_initialized)
    {
        HRESULT hr = NewInit(m_iBuckets, 
                             sizeof(DebuggerHashEntry), 0xffff);
        if (hr != S_OK)
            return (hr);

        m_initialized = true;
    }

    DebuggerHashEntry *entry = (DebuggerHashEntry *) Add(HASH(pBase->GetToken()));

    if (entry == NULL)
        return (E_FAIL);
    else
        entry->pBase = pBase;

    return (S_OK);
}

DebuggerBase *DebuggerHashTable::GetBase(ULONG id)
{
    if (!m_initialized)
        return (NULL);

    DebuggerHashEntry *entry 
    = (DebuggerHashEntry *) Find(HASH(id), KEY(id)); 
    if (entry == NULL)
        return (NULL);
    else
        return (entry->pBase);
}

BOOL DebuggerHashTable::RemoveBase(ULONG id)
{
    if (!m_initialized)
        return (FALSE);

    DebuggerHashEntry *entry 
    = (DebuggerHashEntry *) Find(HASH(id), KEY(id));

    if (entry == NULL)
        return (FALSE);

    DebuggerBase *base = entry->pBase;

    Delete(HASH(id), (HASHENTRY *) entry);
    delete base;

    return (TRUE);
}

void DebuggerHashTable::RemoveAll()
{
    HASHFIND    find;

    for (DebuggerHashEntry *entry = (DebuggerHashEntry *) FindFirstEntry(&find);
        entry != NULL;
        entry = (DebuggerHashEntry *) FindNextEntry(&find))
        delete entry->pBase;

    Clear();
}

DebuggerBase *DebuggerHashTable::FindFirst(HASHFIND *find)
{
    DebuggerHashEntry *entry = (DebuggerHashEntry *) FindFirstEntry(find);
    if (entry == NULL)
        return (NULL);
    else
        return (entry->pBase);
}

DebuggerBase *DebuggerHashTable::FindNext(HASHFIND *find)
{
    DebuggerHashEntry *entry = (DebuggerHashEntry *) FindNextEntry(find);
    if (entry == NULL)
        return (NULL);
    else
        return (entry->pBase);
}

/* ------------------------------------------------------------------------- *
 * DebuggerClass
 * ------------------------------------------------------------------------- */
DebuggerClass::DebuggerClass (ICorDebugClass *pClass)
    : DebuggerBase ((ULONG)pClass),
        m_szName (NULL),
        m_szNamespace (NULL)
{
}

DebuggerClass::~DebuggerClass ()
{
    delete m_szName;
    delete m_szNamespace;
}

void DebuggerClass::SetName (WCHAR *pszName, WCHAR *pszNamespace)
{
    if (pszName != NULL)
    {
        int iLength = wcslen (pszName);
        if ((m_szName = new WCHAR [iLength+1]) != NULL)
            wcscpy (m_szName, pszName);
    }

    if (pszNamespace != NULL)
    {
        int iLength = wcslen (pszNamespace);
        if ((m_szNamespace = new WCHAR [iLength+1]) != NULL)
            wcscpy (m_szNamespace, pszNamespace);
    }
}

WCHAR *DebuggerClass::GetName (void) 
{
    return m_szName;
}

WCHAR *DebuggerClass::GetNamespace (void) 
{
    return m_szNamespace;
}

/* ------------------------------------------------------------------------- *
 * DebuggerModule
 * ------------------------------------------------------------------------- */

DebuggerModule::DebuggerModule(ICorDebugModule* imodule)
    : DebuggerBase((ULONG)imodule),
      m_sourceFiles(11), m_functions(37), m_functionsByIF(11), m_szName(NULL),
      m_loadedClasses(11), m_breakpoints(NULL), m_pISymUnmanagedReader(NULL)
{
    // Also initialize the source file array
    for (int i=0; i<MAX_SF_BUCKETS; i++)
        m_pModSourceFile [i] = NULL;
    // Indicate that source file names are not yet loaded
    m_fSFNamesLoaded = false;

    imodule->AddRef();

#ifdef _INTERNAL_DEBUG_SUPPORT_
    m_EnCLastUpdated = 0;
#endif
}

HRESULT DebuggerModule::Init(WCHAR *pSearchPath)
{
    // Get the necessary metadata interfaces now...
    HRESULT hr = GetICorDebugModule()->GetMetaDataInterface(
                                           IID_IMetaDataImport,
                                           (IUnknown**)&m_pIMetaDataImport);

    if (FAILED(hr))
        return hr;

    // Get the module name
    WCHAR moduleName[MAX_PATH];
    ULONG32 nameLen;

    hr = GetICorDebugModule()->GetName(MAX_PATH, &nameLen, moduleName);
    _ASSERTE(nameLen <= MAX_PATH);

    // Don't get a reader if its a dynamic module... syms for those
    // come in on update later.
    BOOL isDynamic = FALSE;
    hr = GetICorDebugModule()->IsDynamic(&isDynamic);
    _ASSERTE(SUCCEEDED(hr));

    BOOL isInMemory = FALSE;
    hr = GetICorDebugModule()->IsInMemory(&isInMemory);
    _ASSERTE(SUCCEEDED(hr));

    if (isDynamic || isInMemory)
        return hr;
    
    // Get a symbol binder.
    ISymUnmanagedBinder *binder;
    hr = CoCreateInstance(CLSID_CorSymBinder_SxS, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISymUnmanagedBinder,
                          (void**)&binder);

    if (FAILED(hr))
    {
        g_pShell->Write(L"Error: couldn't get a CorSymBinder for "
                        L"symbol loading.\n");
        return S_FALSE;
    }

    // Ask the binder for a reader for this module.
    m_pISymUnmanagedReader = NULL;
    
    hr = binder->GetReaderForFile(m_pIMetaDataImport,
                                  moduleName,
                                  pSearchPath, // use global search path
                                  &m_pISymUnmanagedReader);

    // Release the binder
    binder->Release();

    if (FAILED(hr))
    {
        g_pShell->Write(L"Warning: couldn't load symbols for %s\n",
                        moduleName);

        // Oddly enough, sometimes GetReaderForFile actually gives us back a reader even if it couldn't load the symbols
        // for the module. In this case, we release the reader and set the value to NULL. NULL indicates to the rest of
        // cordbg that there are no syms available for this module.
        if (m_pISymUnmanagedReader != NULL)
        {
            m_pISymUnmanagedReader->Release();
            m_pISymUnmanagedReader = NULL;
        }
        
        return S_OK;
    }

    return hr;
}

DebuggerModule::~DebuggerModule()
{
    while (m_breakpoints != NULL)
    {
        DebuggerCodeBreakpoint *bp = m_breakpoints->m_next;
        delete m_breakpoints;
        m_breakpoints = bp;
    }

    if (g_pShell != NULL)
    {
        DebuggerBreakpoint *bp = g_pShell->m_breakpoints;

        while (bp != NULL)
        {
            if (bp->IsBoundToModule(this))
                bp->RemoveBoundModule(this);

            bp = bp->m_next;
        }
    }
    
    GetICorDebugModule()->Release();

    if (m_pIMetaDataImport)
        m_pIMetaDataImport->Release();

    if (m_pISymUnmanagedReader)
        m_pISymUnmanagedReader->Release();


    DeleteModuleSourceFiles();
    
    // Need to get rid of all functions associated with this module.
    m_functions.RemoveAll();

    delete m_szName;
}

DebuggerSourceFile *DebuggerModule::LookupSourceFile(const WCHAR *name)
{
    GUID g = {0};
    ISymUnmanagedDocument *doc;
    DebuggerSourceFile *pRet = NULL;

    if (!m_pISymUnmanagedReader)
        return NULL;
    
    // Get the doc corresponding to the name
    HRESULT hr = m_pISymUnmanagedReader->GetDocument((WCHAR*)name, g, g, g, &doc);

    if (SUCCEEDED(hr) && doc!=NULL)
    {
        // Try and resolve the document to a DebuggerSourceFile
        pRet = ResolveSourceFile(doc);
        _ASSERTE(pRet);

        // Release the doc
        doc->Release();
    }

    return (pRet);
}

DebuggerSourceFile *DebuggerModule::ResolveSourceFile(ISymUnmanagedDocument *doc)
{
    // Not addref'd
    doc = FindDuplicateDocumentByURL(doc);

    DebuggerSourceFile *file =
        (DebuggerSourceFile*)m_sourceFiles.GetBase((ULONG)doc);

    if (file == NULL)
    {
        file = new DebuggerSourceFile(this, doc);
        _ASSERTE(file != NULL);

        if (file != NULL)
            m_sourceFiles.AddBase(file);
    }

    return (file);
}

DebuggerFunction *DebuggerModule::ResolveFunction(mdMethodDef md,
                                                  ICorDebugFunction *iFunction)
{
    // Make sure we don't have obviously invalid arguments
    _ASSERTE((md != mdMethodDefNil) || (iFunction != NULL));

    // What will be returned
    DebuggerFunction *function;

    // Get a pointer to the DebuggerFunction object
    if (md != mdMethodDefNil)
        function = (DebuggerFunction *)m_functions.GetBase(md);
    else
        function = (DebuggerFunction *)m_functionsByIF.GetBase((ULONG)iFunction);

    // Has not been created yet
    if (function == NULL)
    {
        // Create a new object
        function = new DebuggerFunction(this, md, iFunction);
        _ASSERTE(function != NULL);
        
        // Out of memory
        if (function == NULL)
        {
            g_pShell->ReportError(E_OUTOFMEMORY);
            return NULL;
        }

        // Init the DebuggerFunction object
        HRESULT hr = function->Init();

        // Error check
        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            delete function;
            return NULL;
        }

        // Add the DebuggerFunction object to the appropriate collection
        if (md != mdMethodDefNil)
            m_functions.AddBase(function);
        else
            m_functionsByIF.AddBase(function);
    }

    // Return DebuggerFunction pointer
    return (function);
}

DebuggerFunction *DebuggerModule::ResolveFunction(ISymUnmanagedMethod *method,
                                                  ICorDebugFunction *iFunction)
{
    HRESULT hr = S_OK;
    
    mdMethodDef tk;

    hr = method->GetToken(&tk);

    if (FAILED(hr))
        return NULL;
    else
        return ResolveFunction(tk, iFunction);
}

DebuggerModule *DebuggerModule::FromCorDebug(ICorDebugModule *module)
{
    // Return the DebuggerModule object
    return (g_pShell->ResolveModule(module));
}


HRESULT DebuggerModule::LoadSourceFileNames (void)
{
    HRESULT hr = S_OK;
    int     iBucket;

    if (m_fSFNamesLoaded
#ifdef _INTERNAL_DEBUG_SUPPORT_    
        && g_EditAndContinueCounter <= m_EnCLastUpdated
#endif
       )
        return S_OK;

    // Get all of the source files within this module.
    ULONG32 docCount;
    ISymUnmanagedDocument **allDocs;

    if (!m_pISymUnmanagedReader)
        return S_OK;

    // How many documents?
    hr = m_pISymUnmanagedReader->GetDocuments(0, &docCount, NULL);

    if (FAILED(hr))
        return hr;

    // Allocate space for the documents.
    allDocs = (ISymUnmanagedDocument**)_alloca(docCount * sizeof(ISymUnmanagedDocument*));
    _ASSERTE(allDocs != NULL);
    
    hr = m_pISymUnmanagedReader->GetDocuments(docCount, &docCount, allDocs);

    if (FAILED(hr))
        return hr;
    
    // Loop over the documents, setting up each's name and path
    // accordingly.
    for (ULONG32 i = 0; i < docCount; i++)
    {
        WCHAR docName[256];
        ULONG32 s;

        hr = allDocs[i]->GetURL(256, &s, docName);

        if (FAILED(hr))
            break;

        // This will actually take a long time, esp. for things like mscorlib.dll
        // so we'll only go looking for previous versions if the module's been
        // EnC'd (ie, the first time we just assume everything's new).
        if (
#ifdef _INTERNAL_DEBUG_SUPPORT_    
    		m_EnCLastUpdated < g_EditAndContinueCounter &&    
#endif        
            SearchForDocByString(docName))
            continue; //we've already got a pointer to this, so don't re-create it.

        // @todo: the rest of the code expects an ASCII name. Fix that
        // sometime soon.
        MAKE_ANSIPTR_FROMWIDE(docNameA, docName);

        int iLen;
        iLen = strlen(docNameA);
            
        if (iLen)
        {
            // strip the path and store just the lowercase file name
            CHAR        rcFile[MAX_PATH];
            _splitpath(docNameA, NULL, NULL, rcFile, NULL);

            // make the file name lowercase
            int j=0;
            while (rcFile [j] != '\0')
            {
                rcFile[j] = tolower(rcFile[j]);
                j++;
            }

            // Based on the stripped file name, decide the bucket in
            // which it should go
            if (rcFile [0] < 'a') 
                iBucket = 0;
            else if (rcFile [0] > 'z')
                iBucket = MAX_SF_BUCKETS - 1;
            else
                iBucket = (rcFile [0] - 'a') % MAX_SF_BUCKETS;

            // Allocate a new ModuleSourceFile object
            ModuleSourceFile *pmsf = new ModuleSourceFile;

            if (pmsf)
            {
                if (!pmsf->SetFullFileName(allDocs[i], docNameA))
                {
                    hr = E_FAIL;
                    delete pmsf;
                    break;
                }

                // Add this ModuleSourceFile object to the cache
                pmsf->SetNext (m_pModSourceFile [iBucket]);
                m_pModSourceFile [iBucket] = pmsf;
            }
            else
            {
                // out of memory
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        RELEASE(allDocs[i]);
    }

    // Indicate that the module's source files have been cached 
    if (SUCCEEDED (hr))
    {
        m_fSFNamesLoaded = true;
#ifdef _INTERNAL_DEBUG_SUPPORT_    
        m_EnCLastUpdated = g_EditAndContinueCounter;
#endif
    }
    
    return hr;
}

void DebuggerModule::DeleteModuleSourceFiles(void)
{
    // Go through all the buckets and release the cached ModuleSourceFiles
    for (int i=0; i<MAX_SF_BUCKETS; i++)
    {
        ModuleSourceFile *pMod = m_pModSourceFile [i];
        ModuleSourceFile *pTemp = NULL;

        while (pMod)
        {
            pTemp = pMod;
            pMod = pTemp->GetNext();
            delete pTemp;           
        }
        
        m_pModSourceFile [i] = NULL;
    }
}

HRESULT DebuggerModule::MatchStrippedFNameInModule 
                                            (
                                            WCHAR *pstrFileName, // file name to look for (assumed to have been converted to  lower case)
                                            WCHAR **ppstrMatchedNames, // returned array containing full paths of matched filenames
                                            ISymUnmanagedDocument **ppDocs, // returned aray containing documents for source file
                                            int *piCount // number of files which matched the given filename
                                            )
{
    HRESULT hr;

    *piCount = 0;
    _ASSERTE (pstrFileName);

    // The filename length should be > 0 
    if (!wcslen (pstrFileName))
        return (E_INVALIDARG);

    if ((hr = LoadSourceFileNames ()) != S_OK)
        return hr;

    hr = E_FAIL;

    // first, extract strip the path+file name  down to just the "file.ext" name
    WCHAR   rcFile[_MAX_FNAME];
    WCHAR   rcExt[_MAX_EXT];

    // _wsplitpath has a bug where it corrupts the stack if a ( is in the pstFilename
    if (wcsstr(pstrFileName, L"("))
    {
        return E_FAIL;
    }
    _wsplitpath(pstrFileName, NULL, NULL, rcFile, rcExt);
    wcscat(rcFile, rcExt);

    // get the bucket in which this file should be searched for
    int iBucketIndex;

    if (rcFile [0] < 'a') 
        iBucketIndex = 0;
    else if (rcFile [0] > 'z')
        iBucketIndex = MAX_SF_BUCKETS - 1;
    else
        iBucketIndex = (rcFile [0] - 'a') % MAX_SF_BUCKETS;

    ModuleSourceFile *pmsf = m_pModSourceFile [iBucketIndex];

    // Search the whole list to find the files names which match
    while (pmsf)
    {
        WCHAR   *pStrippedFileName = pmsf->GetStrippedFileName();
        WCHAR   strTemp [MAX_PATH];

        // convert the name to lowercase before comparing
        wcscpy (strTemp, pStrippedFileName);

        int i=0;
        while (strTemp [i] != L'\0')
        {
            strTemp [i] = towlower (strTemp [i]);
            i++;
        }

        
        if (!wcscmp (strTemp, rcFile))
        {
            _ASSERTE (*piCount < MAX_FILE_MATCHES_PER_MODULE);
            // found a match
            ppstrMatchedNames [*piCount] = pmsf->GetFullFileName();
            ppDocs [*piCount] = pmsf->GetDocument();
            (*piCount)++;
            hr = S_OK;
        }

        pmsf = pmsf->GetNext();
    }

    return hr;
}

//***********************************************************************************************
// This will search through all of the debugger's ModuleSourceFile entries and find
// the stored ISymUnmanagedDocument pointer that has the same URL as the document
// passed in.  This is necessary due to a deficiency in the ISym* interface not being
// able to return the same ISymUnmanagedDocument pointer for the same document.
//***********************************************************************************************

ISymUnmanagedDocument *DebuggerModule::FindDuplicateDocumentByURL(ISymUnmanagedDocument *pDoc)
{
    _ASSERTE(pDoc);
    HRESULT  hr;

    /////////////////////////////////////////////////////////
    // Make sure all the source documents have been loaded

    hr = LoadSourceFileNames();
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr))
        return (NULL);

    ///////////////////////////////////////////
    // Get the URL of the document passed in

    ULONG32  ccUrl;
    WCHAR   *szUrl;

    // Find out how long the URL is
    hr = pDoc->GetURL(0, &ccUrl, NULL);
    _ASSERTE(SUCCEEDED(hr));

    // Allocate the memory for it
    szUrl = (WCHAR *)_alloca((ccUrl + 1) * sizeof(WCHAR));

    // Get the URL
    hr = pDoc->GetURL(ccUrl + 1, &ccUrl, szUrl);
    _ASSERTE(SUCCEEDED(hr));

    ////////////////////////////////////////////////////////////////////
    // Whip through all the ModuleSourceFile entries and find a match

    return SearchForDocByString(szUrl);
}

ISymUnmanagedDocument *DebuggerModule::SearchForDocByString(WCHAR *szUrl)
{
    HRESULT hr = S_OK;
    
    for (int i = 0; i < MAX_SF_BUCKETS; i++)
    {
        ModuleSourceFile *pMSF = m_pModSourceFile[i];

        while (pMSF)
        {
            /////////////////////////////////////////
            // Get the URL of the current document

            ULONG32  ccUrlCur;
            WCHAR   *szUrlCur;
            ISymUnmanagedDocument *pDocCur = pMSF->GetDocument();
            _ASSERTE(pDocCur);

            // Find out how long the URL is
            hr = pDocCur->GetURL(0, &ccUrlCur, NULL);
            _ASSERTE(SUCCEEDED(hr));

            // Allocate the memory for it
            szUrlCur = (WCHAR *)_alloca((ccUrlCur + 1) * sizeof(WCHAR));

            // Get the URL
            hr = pDocCur->GetURL(ccUrlCur + 1, &ccUrlCur, szUrlCur);
            _ASSERTE(SUCCEEDED(hr));

            ///////////////////////////////////////////////////////////////////////
            // Is this document a match?  If so, go ahead and return the pointer

            if (wcscmp(szUrl, szUrlCur) == 0)
                return pDocCur;

            ///////////////////////////////////////////////
            // Get the next document and continue search

            pMSF = pMSF->GetNext();
        }
    }

    //////////////////////
    // Indicate failure

    return (NULL);
}


HRESULT     DebuggerModule::MatchFullFileNameInModule (WCHAR *pstrFileName, 
                                                       ISymUnmanagedDocument **pDoc)
{

    int iBucketIndex;

    HRESULT hr;

    _ASSERTE (pstrFileName);

    // The filename length should be > 0 
    if (!wcslen (pstrFileName))
        return (E_INVALIDARG);

    if ((hr = LoadSourceFileNames ()) != S_OK)
        return hr;

    hr = E_FAIL; // assume we won't find it in this module.

    // first, extract strip the path+file name  down to just the "file.ext" name

    WCHAR   rcFile[_MAX_FNAME];
    WCHAR   rcExt[_MAX_EXT];
    WCHAR   buf[1024];

    // _wsplitpath has a bug where it corrupts the stack if a ( is in the pstFilename
    if (wcsstr(pstrFileName, L"("))
    {
        return E_FAIL;
    }
    _wsplitpath(pstrFileName, buf, buf, rcFile, rcExt);
    wcscat(rcFile, rcExt);

    // get the bucket in which this file should be searched for
    if (rcFile [0] < 'a') 
        iBucketIndex = 0;
    else if (rcFile [0] > 'z')
        iBucketIndex = MAX_SF_BUCKETS - 1;
    else
        iBucketIndex = (rcFile [0] - 'a') % MAX_SF_BUCKETS;

    ModuleSourceFile *pmsf = m_pModSourceFile [iBucketIndex];

    // Search the whole list to find the files name which matches
    while (pmsf)
    {
        WCHAR   *pFullFileName = pmsf->GetFullFileName();

        if (!wcscmp (pFullFileName, pstrFileName))
        {
            // found a match
            *pDoc = pmsf->GetDocument();
            hr = S_OK;
            break;
        }

        pmsf = pmsf->GetNext();
        if (!pmsf)
        {
            hr = E_FAIL;
            break;
        }
    }

    return hr;
}


void DebuggerModule::SetName (WCHAR *pszName)
{
    if (pszName != NULL)
    {
        m_szName = new WCHAR [wcslen (pszName) + 1];
        if (m_szName != NULL)
        {
            wcscpy (m_szName, pszName);
        }
    }
}

//
// Update the symbols for this module. Creates the syms if they aren't
// already created.
//
HRESULT DebuggerModule::UpdateSymbols(IStream *pStream)
{
    HRESULT hr = S_OK;

    // If we don't already have a reader, create one.
    if (m_pISymUnmanagedReader == NULL)
    {
        ISymUnmanagedBinder *pBinder = NULL;
        
        hr = CoCreateInstance(CLSID_CorSymBinder_SxS, NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ISymUnmanagedBinder,
                              (void**)&pBinder);

        if (SUCCEEDED(hr))
        {
            hr = pBinder->GetReaderFromStream(m_pIMetaDataImport,
                                              pStream,
                                              &m_pISymUnmanagedReader);
    
            if (FAILED(hr))
                m_pISymUnmanagedReader = NULL;

            pBinder->Release();
        }
    }
    else
    {
        // We already have a reader, so just replace the symbols. We
        // replace instead of update because we are doing this only
        // for dynamic modules and the syms are cumulative.
        hr = m_pISymUnmanagedReader->ReplaceSymbolStore(NULL, pStream);
    }
    
    return hr;
}

void DebuggerShell::PrintGlobalVariable (mdFieldDef mdTok, 
                                         WCHAR  *wszName,
                                         DebuggerModule *dm)
{
    ICorDebugModule *mod = dm->GetICorDebugModule();
    ICorDebugValue *val = NULL;
    HRESULT hr = S_OK;

    _ASSERTE( mod != NULL );
    
    hr = mod->GetGlobalVariableValue(mdTok, &val);
    if (FAILED(hr))
        return;

    this->PrintVariable(wszName, val, 0, TRUE);

    Write(L"\n");
}

#define PRINT_ALL       1
#define MATCH_N_CHARS   2
#define MATCH_ALL_CHARS 3

BOOL DebuggerModule::PrintGlobalVariables (WCHAR *szSearchString, 
                                           char *szModName,
                                           DebuggerModule *dm)
{
	BOOL fWildCard = FALSE;
	int iMatchKind;
	ULONG iLength = wcslen (szSearchString);
	char szSearchName [MAX_SYMBOL_NAME_LENGTH];

	BOOL fDone = FALSE;
	for (ULONG i=0; i<iLength; i++)
	{
		if (szSearchString [i] == L'*')
		{
			fWildCard = TRUE;
			iLength = i;
			break;
		}
	}

    if (iLength==0)
    {
        // print all symbols
        iMatchKind = PRINT_ALL;
    }
    else
    {
        szSearchString [iLength] = L'\0';
        MAKE_UTF8PTR_FROMWIDE (szSearchName1, szSearchString);

        strcpy (szSearchName, szSearchName1);

        if (fWildCard)
        {
            // match 'iLength' characters only
            iMatchKind = MATCH_N_CHARS;
        }
        else
        {
            // match the whole string
            iMatchKind = MATCH_ALL_CHARS;
        }
    }

    // first, look for the global functions
    HCORENUM phEnum = 0;
    mdMethodDef rTokens[100];
    ULONG count;
    HRESULT hr;
    MDUTF8CSTR name;
    MDUTF8STR  u_name;
    MDUTF8STR  szMDName;
    bool anythingPrinted = false;
 
    u_name = new char[MAX_CLASSNAME_LENGTH];

    do 
    {
        hr = m_pIMetaDataImport->EnumFields(&phEnum, NULL, &rTokens[0], 100, &count);

        if (!SUCCEEDED(hr))
        {
            g_pShell->ReportError(hr);
            goto ErrExit;
        }

        for (i = 0; i < count; i++)
        {
            hr = m_pIMetaDataImport->GetNameFromToken(rTokens[i], &name);

            if (name == NULL)
                continue;

            MAKE_WIDEPTR_FROMUTF8( wszName, name );

            szMDName = (MDUTF8STR) name;

            if (iMatchKind == PRINT_ALL)
            {
                g_pShell->PrintGlobalVariable (rTokens[i], 
                                               wszName,
                                               dm);
                anythingPrinted = true;
            }
            else
            {
                if (iMatchKind == MATCH_N_CHARS)
                {
                    if (!strncmp (szMDName, szSearchName, iLength))
                    {
                        g_pShell->PrintGlobalVariable (rTokens[i], 
                                                       wszName,
                                                       dm);
                        anythingPrinted = true;
                    }
                }
                else
                {
                    if (!strcmp (szMDName, szSearchName))
                    {
                        g_pShell->PrintGlobalVariable (rTokens[i], 
                                                       wszName,
                                                       dm);
                        anythingPrinted = true;
                    }
                }
            }
        }
    }
    while (count > 0); 

ErrExit:    
    delete u_name;

    if (!anythingPrinted)
        return FALSE;
    return TRUE;
}

BOOL DebuggerModule::PrintMatchingSymbols (WCHAR *szSearchString, char *szModName)
{
	BOOL fWildCard = FALSE;
	int iMatchKind;
	ULONG iLength = wcslen (szSearchString);
	char szSearchName [MAX_SYMBOL_NAME_LENGTH];

	BOOL fDone = FALSE;
	for (ULONG i=0; i<iLength; i++)
	{
		if (szSearchString [i] == L'*')
		{
			fWildCard = TRUE;
			iLength = i;
			break;
		}
	}

    if (iLength==0)
    {
        // print all symbols
        iMatchKind = PRINT_ALL;
    }
    else
    {
        szSearchString [iLength] = L'\0';
        MAKE_UTF8PTR_FROMWIDE (szSearchName1, szSearchString);

        strcpy (szSearchName, szSearchName1);

        if (fWildCard)
        {
            // match 'iLength' characters only
            iMatchKind = MATCH_N_CHARS;
        }
        else
        {
            // match the whole string
            iMatchKind = MATCH_ALL_CHARS;
        }
    }

    // first, look for the global functions
    HCORENUM phEnum = 0;
    mdMethodDef rTokens[100];
	mdTypeDef rClassTokens [100];
    ULONG count;
    HRESULT hr;
    MDUTF8CSTR name;
    MDUTF8CSTR name1;
    MDUTF8STR  u_name;
    MDUTF8STR  szMDName;
    bool anythingPrinted = false;
    char *szMethod = NULL;
    int iLengthOfMethod = 0;
 
    u_name = new char[MAX_CLASSNAME_LENGTH];

    do 
    {
        hr = m_pIMetaDataImport->EnumMethods(&phEnum, NULL, &rTokens[0], 100, &count);

        if (!SUCCEEDED(hr))
        {
            g_pShell->ReportError(hr);
            goto ErrExit;
        }

        for (i = 0; i < count; i++)
        {
            hr = m_pIMetaDataImport->GetNameFromToken(rTokens[i], &name);

            if (name == NULL)
                continue;

            szMDName = (MDUTF8STR) name;

            if (iMatchKind == PRINT_ALL)
            {
                g_pShell->Write (L"%S!::%S\n", szModName, szMDName);
                anythingPrinted = true;
            }
            else
            {
                if (iMatchKind == MATCH_N_CHARS)
                {
                    if (!strncmp (szMDName, szSearchName, iLength))
                    {
                        g_pShell->Write (L"%S!::%S\n", szModName, szMDName);
                        anythingPrinted = true;
                    }
                }
                else
                {
                    if (!strcmp (szMDName, szSearchName))
                    {
                        g_pShell->Write (L"%S!::%S\n", szModName, szMDName);
                        anythingPrinted = true;
                    }
                }
            }
        }
    }
    while (count > 0); 

    // We might be looking for a class::method, in which case we want to match
    // the class part, then the method part.
    szMethod= strstr(szSearchName, "::");
    iLengthOfMethod = 0;
    
    if (szMethod != NULL)
    {
        _ASSERTE((szMethod - szSearchName) >= 0);
        _ASSERTE(*(szMethod++) == ':');
        _ASSERTE(*(szMethod++) == ':');
        
        iLengthOfMethod = iLength - (szMethod - szSearchName);
        iLength -= (iLengthOfMethod +2); //Don't match the "::"
    }


    // now enumerate all the classes...
    phEnum = 0;
    do
    {
        hr = m_pIMetaDataImport->EnumTypeDefs (&phEnum, &rClassTokens[0], 100, &count);

        if (!SUCCEEDED(hr))
        {
            g_pShell->ReportError(hr);
            goto ErrExit;
        }

        for (i = 0; i < count; i++)
        {
            BOOL fMatchFound = FALSE;
            WCHAR wszClassName [MAX_SYMBOL_NAME_LENGTH];
            ULONG ulClassNameLen;
            DWORD dwTypeDefFlags;
            mdToken tkExtends;

            wszClassName [0] = L'\0';

            hr = m_pIMetaDataImport->GetTypeDefProps (rClassTokens [i],
                                                      wszClassName,
                                                      MAX_SYMBOL_NAME_LENGTH-1,
                                                      &ulClassNameLen,
                                                      &dwTypeDefFlags,
                                                      &tkExtends);                                                      

            if (wcslen (wszClassName) == 0)
                continue;

            MAKE_UTF8PTR_FROMWIDE (szMDClassName, wszClassName);

            if (iMatchKind == PRINT_ALL)
            {
                fMatchFound = TRUE;
            }
            else
            {
                if (iMatchKind == MATCH_N_CHARS)
                {
                    if (!strncmp (szMDClassName, szSearchName, iLength))
                    {
                        fMatchFound = TRUE;
                    }
                }
                else
                {
                    if (!strcmp (szMDClassName, szSearchName))
                    {
                        fMatchFound = TRUE;
                    }
                }
            }


            if (fMatchFound)
            {
                ULONG ulMethodCount;
                HCORENUM phMethodEnum = 0;
                do
                {
                    ulMethodCount = 0;
                    hr = m_pIMetaDataImport->EnumMethods(&phMethodEnum, rClassTokens [i], &rTokens[0], 100, &ulMethodCount);

                    if (!SUCCEEDED(hr))
                    {
                        g_pShell->ReportError(hr);
                        goto ErrExit;
                    }

					for (ULONG j = 0; j < ulMethodCount; j++)
					{
						name1 = NULL;
						hr = m_pIMetaDataImport->GetNameFromToken(rTokens[j], &name1);

                        if ((name1 == NULL)||(strlen (name1) == 0))
                            continue;

                        fMatchFound = FALSE;
                        
                        if (iMatchKind == PRINT_ALL)
                        {
                            fMatchFound = TRUE;
                        }
                        else
                        {
                            if (iMatchKind == MATCH_N_CHARS) 
                            {
                                if (szMethod == NULL)
                                {
                                    // We matched all the characters we were given,
                                    // so print anything herein out.
                                    fMatchFound = TRUE;
                                }
                                else if (!strncmp (szMethod, name1, iLengthOfMethod))
                                {
                                    fMatchFound = TRUE;
                                }
                            }
                            else
                            {
                                if (szMethod != NULL && 
                                    !strcmp (szMethod, name1))
                                {
                                    fMatchFound = TRUE;
                                }
                            }
                        }

                        if (fMatchFound == TRUE)
                        {
                            szMDName = (MDUTF8STR)name1;

                            g_pShell->Write (L"%S!%S::%S\n", szModName, szMDClassName, szMDName);
                            anythingPrinted = true;
                        }
                    }
                }
                while (ulMethodCount > 0);
            }
        }

    }while (count > 0);

ErrExit:    
    delete u_name;

    if (!anythingPrinted)
        return FALSE;
    return TRUE;
}


/* ------------------------------------------------------------------------- *
 * DebuggerSourceFile
 * ------------------------------------------------------------------------- */

DebuggerSourceFile::DebuggerSourceFile(DebuggerModule *module,
                                       ISymUnmanagedDocument *doc)
    : DebuggerBase((LONG)doc), m_module(module), 
      m_allBlocksLoaded(false), 
      m_totalLines(0), m_lineStarts(NULL), 
      m_source(NULL), m_sourceTextLoaded(false), 
      m_name(NULL), m_path(NULL),
      m_sourceNotFound(FALSE)
{
    _ASSERTE(doc);

    ULONG32 nameLen = 0;

    // Keep a hold of the document pointer
    m_doc = doc;
    m_doc->AddRef();

    // Get the length of the name first
    HRESULT hr = doc->GetURL(0, &nameLen, NULL);

    // Allocate space for the name
    if (SUCCEEDED(hr))
    {
        m_name = new WCHAR[nameLen + 1];

        if (m_name)
        {
            // Now, copy the name for real.
            hr = doc->GetURL(nameLen + 1, &nameLen, m_name);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    
    // If unsuccessful, don't initialize the source name
    if (FAILED(hr))
    {
        g_pShell->Write(L"Error loading source file info from symbol "
                        L"store.\n");
        g_pShell->ReportError(hr);

        if (m_name)
            delete [] m_name;
        
        m_name = NULL;
    }
}

DebuggerSourceFile::~DebuggerSourceFile()
{
    _ASSERTE(m_doc);
    m_doc->Release();
    m_doc = NULL;

    delete [] m_source;
    delete [] m_lineStarts;
    delete [] m_path;
    delete [] m_name;
}

// LoadText loads the text of a source file and builds a table of pointers
// to the start of each line.
//
// @todo: will probally want to return extended error information one day
// instead of just true or false.
//
BOOL DebuggerSourceFile::LoadText(const WCHAR* path, bool bChangeOfName)
{
    BOOLEAN fRetVal = FALSE;
    char *sourceA = NULL;
    int size = 0;
    WCHAR* ptr = NULL;
    unsigned int i = 0;
    int ilen = 0;
    
    if (m_sourceTextLoaded)
        return (TRUE);

    // Where to store fully qualified name
    char fullyQualifiedName[MAX_PATH];

    // Must convert to ANSI for Win9x users
    MAKE_ANSIPTR_FROMWIDE(pathA, path);
    _ASSERTE(pathA != NULL);


    HRESULT hr;

    // Let the shell see if it can resolve the source location.
    if ((hr = g_pShell->ResolveSourceFile(this, pathA, fullyQualifiedName, MAX_PATH, bChangeOfName)) != S_OK)
    {
        if (!m_sourceNotFound)
        {
            g_pShell->Write(L"\nError loading source file '%s': File not found\n", m_name == NULL ? L"unknown" : m_name);
            m_sourceNotFound = TRUE;
        }

        return (FALSE);

    }
    
    
    m_sourceNotFound = FALSE;

    // Read the source file into memory.
    HANDLE hFile = CreateFileA(fullyQualifiedName, GENERIC_READ,
                               FILE_SHARE_READ, NULL, OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());

        // No luck, report error.
        g_pShell->ReportError(hr);
        return (FALSE);
    }

    DWORD sizeA = SafeGetFileSize(hFile, NULL);

    if (sizeA == 0xFFFFFFFF)
    {
        g_pShell->ReportError(HRESULT_FROM_WIN32(GetLastError()));
        CloseHandle(hFile);
        return (FALSE);
    }

    sourceA = new char[ (sizeA * sizeof(char)) ];
    if (sourceA == NULL)
    {
        g_pShell->Write( L"Insufficient memory to load file '%s'\n",m_name );
        CloseHandle(hFile);
        return (FALSE);
    }

    DWORD sizeReadA;
    BOOL ret = ReadFile(hFile, (void*) sourceA, sizeA, &sizeReadA, NULL);

    CloseHandle(hFile);

    if ((ret == FALSE) || (sizeA != sizeReadA))
    {
        if (ret == FALSE)
            g_pShell->ReportError(HRESULT_FROM_WIN32(GetLastError()));

        goto LExit;
    }

    // In unicode files, the first two bytes are 0xFF and 0xFE
    if ((BYTE)(sourceA[0]) == 0xff && (BYTE)(sourceA[1]) == 0xfe)
    {
        // Calculate the number of unicode chars
        _ASSERTE(sizeA%2 == 0);
        size = sizeA/2;

        // Skip the first unicode char
        size--;

        // Alocate the memory
        m_source = new WCHAR[size + 1]; // +1 for null

        // Copy the source file into the memory
        memcpy((BYTE *)m_source, sourceA+2, size * sizeof(WCHAR));

        // Null terminate
        m_source[size] = L'\0';
    }

    else
    {
        // Pick the code page to use in translation
        UINT codePage = CP_ACP;  // Default to ANSI
        SIZE_T bytesToSkip = 0;  // Don't skip any chars by default

        // UTF-8 files can start with 0xef 0xbb 0xbf
        if ((BYTE)(sourceA[0]) == 0xef &&
            (BYTE)(sourceA[1]) == 0xbb &&
            (BYTE)(sourceA[2]) == 0xbf)
        {
            codePage = CP_UTF8;
            bytesToSkip = 3;
        }

        // Translate the source file into UNICODE
        size = WszMultiByteToWideChar(
            codePage, 0, sourceA + bytesToSkip,
            sizeA - bytesToSkip, NULL, 0);

        m_source = new WCHAR[size+1];
        _ASSERTE(m_source != NULL);

        if (m_source == NULL)
            goto LExit;

        WszMultiByteToWideChar(
            codePage, 0, sourceA + bytesToSkip,
            sizeA - bytesToSkip, m_source, size);

        // Null terminate the wide string array
        m_source [size] = L'\0';
    }

    //
    // Figure out how many lines are in this file.
    //
    ptr = m_source;
    m_totalLines = 0;

    while (ptr < (m_source + size))
    {
        if (*ptr++ == L'\n')
            m_totalLines++;
    }

    // account for the fact that the last line of the 
    // file may contain text. So number of lines needs 
    // to be incremented if this is the case.
    if ((size > 0) && (*(ptr-1) != L'\n'))
        m_totalLines++;

    // Build an array to point to the beginning of each line of the file.
    // Chop up the file into separate strings while we're at it.
    if (m_totalLines == 0)
        goto LExit;


    m_lineStarts = new WCHAR*[m_totalLines];
    _ASSERTE(m_lineStarts != NULL);

    if (m_lineStarts == NULL)
    {
        delete m_source;
        goto LExit;
    }

    ptr = m_source;
    m_lineStarts[i++] = ptr;

    while (ptr < (m_source + size))
    {
        if (*ptr++ == '\n')
        {
            *(ptr - 1) = '\0';

            if ((ptr > m_source + 1) && (*(ptr - 2) == '\r'))
                *(ptr - 2) = '\0';

            if (i < m_totalLines)
                m_lineStarts[i++] = ptr;
        }
    }

    m_sourceTextLoaded = TRUE;

    ilen = MultiByteToWideChar(CP_ACP, 0, fullyQualifiedName, -1, NULL, 0);
    m_path = new WCHAR[ilen+1];
    if (m_path)
        MultiByteToWideChar(CP_ACP, 0, fullyQualifiedName, -1, m_path, ilen+1);
    fRetVal =  (TRUE);
 LExit:
    if (sourceA != NULL )
    {
        delete [] sourceA;
        sourceA = NULL;
    }
    
    return fRetVal;
}

BOOL DebuggerSourceFile::ReloadText(const WCHAR *path, bool bChangeOfName)
{
    m_sourceTextLoaded = FALSE;

    if (m_source != NULL)
    {
        delete m_source;
        m_source = NULL;
    }

    if (m_lineStarts != NULL)
    {
        delete m_lineStarts;
        m_lineStarts = NULL;
    }

    m_totalLines = 0;

    return (LoadText(path, bChangeOfName));
}

unsigned int DebuggerSourceFile::FindClosestLine(unsigned int line,
                                                 bool silently)
{
    HRESULT hr = S_OK;

    // Find and return the closest line in this document.
    ULONG32 closeLine;
    hr = GetDocument()->FindClosestLine(line, &closeLine);

    if (SUCCEEDED(hr))
    {
        // @TODO: This is a symbolstore failure.  Bug 28393.
        if ((hr == S_FALSE) ||
            ((closeLine > (line + 3)) || (closeLine < (line - 3))))
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
        return closeLine;
    else
    {
        if (!silently)
            g_pShell->Write(L"Warning: source line may not have code. "
                            L"Breakpoint binding may fail.\n");

        return line;
    }
}

/* ------------------------------------------------------------------------- *
 * DebuggerFunction
 * ------------------------------------------------------------------------- */

//
// _skipTypeInSignature -- skip past a type in a given signature.
// Returns the number of bytes used by the type in the signature.
//
static ULONG _skipTypeInSignature(PCCOR_SIGNATURE sig)
{
    ULONG cb = 0;
    ULONG elementType;

    cb += CorSigUncompressData(&sig[cb], &elementType);

    if ((elementType == ELEMENT_TYPE_CLASS) ||
        (elementType == ELEMENT_TYPE_VALUETYPE))
    {
        // Skip over typeref.
        mdToken typeRef;
        cb += CorSigUncompressToken(&sig[cb], &typeRef);
    }
    else if ((elementType == ELEMENT_TYPE_PTR) ||
             (elementType == ELEMENT_TYPE_BYREF) ||
             (elementType == ELEMENT_TYPE_PINNED) ||
             (elementType == ELEMENT_TYPE_SZARRAY))
    {
        // Skip over extra embedded type.
        cb += _skipTypeInSignature(&sig[cb]);
    }
    else if ((elementType == ELEMENT_TYPE_ARRAY) ||
             (elementType == ELEMENT_TYPE_ARRAY))
    {
        // Skip over extra embedded type.
        cb += _skipTypeInSignature(&sig[cb]);

        // Skip over rank
        ULONG rank;
        cb += CorSigUncompressData(&sig[cb], &rank);

        if (rank > 0)
        {
            // how many sizes?
            ULONG sizes;
            cb += CorSigUncompressData(&sig[cb], &sizes);

            // read out all the sizes
            unsigned int i;

            for (i = 0; i < sizes; i++)
            {
                ULONG dimSize;
                cb += CorSigUncompressData(&sig[cb], &dimSize);
            }

            // how many lower bounds?
            ULONG lowers;
            cb += CorSigUncompressData(&sig[cb], &lowers);

            // read out all the lower bounds.
            for (i = 0; i < lowers; i++)
            {
                int lowerBound;
                cb += CorSigUncompressSignedInt(&sig[cb], &lowerBound);
            }
        }
    }

    return (cb);
}

//
// Static, global byte used to represent a signature for a class. A pointer
// to this is used as the signature for the "this" argument to methods
//
static const BYTE g_ObjectSignature = ELEMENT_TYPE_CLASS;

//
// DebuggerFunction
//
// @todo VC_HACK: the extra hash and the work to notice if the method def
// token is nil is to support debugging VC_HACK programs.
//
DebuggerFunction::DebuggerFunction(DebuggerModule *m, mdMethodDef md,
                                   ICorDebugFunction *iFunction)
    : DebuggerBase(md), m_module(m), m_class(0), m_ifunction(iFunction), 
      m_isStatic(false),  m_allBlocksLoaded(false), m_allScopesLoaded(false),
      m_arguments(NULL), m_argCount(0), m_VCHack(FALSE),
      m_returnType(NULL), m_signature(NULL), m_name(NULL), m_className(NULL),
      m_namespaceName(NULL),
      m_ilCode(NULL), m_ilCodeSize(0), m_nativeCode(NULL), m_nativeCodeSize(0),
      m_symMethod(NULL), m_SPCount(0), m_SPOffsets(NULL), m_SPDocuments(NULL),
      m_SPLines(NULL)
{
    if (md == mdMethodDefNil)
    {
        m_token = (ULONG) iFunction;
        iFunction->AddRef();
        m_VCHack = TRUE;
    }
}


//
// Obtain & Cache sequence point information
//
HRESULT DebuggerFunction::CacheSequencePoints(void)
{
    HRESULT hr = S_OK;
    
    if (m_SPCount)
    {
        if (m_SPOffsets != NULL)
        {
            delete [] m_SPOffsets;
        }

        if (m_SPDocuments != NULL)
        {
            // Need to release all the interface pointers first
            for (ULONG32 i = 0; i < m_SPCount; i++)
                m_SPDocuments[i]->Release();

            delete [] m_SPDocuments;
        }

        if (m_SPLines != NULL)
        {
            delete [] m_SPLines;
        }
    }
    
    // Now, load up the sequence points for this function since we
    // know that we'll need them later.
    if (m_symMethod)
    {
        hr = m_symMethod->GetSequencePointCount(&m_SPCount);

        TESTANDRETURNHR(hr);

        if (m_SPCount)
        {
            m_SPOffsets = new ULONG32[m_SPCount];

            if (!m_SPOffsets)
                return E_OUTOFMEMORY;
    
            m_SPDocuments = new ISymUnmanagedDocument*[m_SPCount];

            if (!m_SPDocuments)
                return E_OUTOFMEMORY;
    
            m_SPLines = new ULONG32[m_SPCount];

            if (!m_SPCount)
                return E_OUTOFMEMORY;

            ULONG32 actualCount;
        
            hr = m_symMethod->GetSequencePoints(m_SPCount, &actualCount, m_SPOffsets,
                                                m_SPDocuments, m_SPLines, NULL, NULL, NULL);

            TESTANDRETURNHR(hr);

            _ASSERTE(actualCount == m_SPCount);

            // This is to search the existing documents of the function's module to find
            // the ISymUnmanagedDocument that matches the ones passed in to m_SPDocuments,
            // because as it is the ISym* implementation doesn't find existing docs and just
            // addref them, it creates a brand new ISymUnmgdDoc object every time we call
            // things like GetSequencePoints, so we need to do the work to resolve all these
            // ISymUnmgdDoc pointers to a common one.

            ISymUnmanagedDocument *pPrevFrom = NULL;
            ISymUnmanagedDocument *pPrevTo   = NULL;
            ULONG32 i;
            ULONG32 j;

            for (i = 0, j = 0; i < m_SPCount; i++)
            {
                // Some wacky compilers out there (we won't name any names) emit a special line number that is a signal
                // to other wacky debuggers (again, no names to protect the innocent) for some of the sequence
                // points. These line numbers only serve to confuse the user, so we strip them out of the sequence point
                // array as we see them.
                if ((m_SPLines[i] == 0xfeefee) || (m_SPLines[i] == 0xfeefed))
                    continue;

                if (i != j)
                {
                    m_SPLines[j] = m_SPLines[i];
                    m_SPDocuments[j] = m_SPDocuments[i];
                    m_SPOffsets[j] = m_SPOffsets[i];
                }
                
                // Only do a full search if this pointer's not the same as the previous
                // (In most cases, the array of ISymUnmgdDocs will all be pointers to the
                // same object
                if (m_SPDocuments[j] != pPrevFrom)
                {
                    // Returns a non-addref'd pointer
                    ISymUnmanagedDocument *pDoc = m_module->FindDuplicateDocumentByURL(m_SPDocuments[j]);
                    _ASSERTE(pDoc);

                    // Save the result
                    pPrevFrom = m_SPDocuments[j];
                    pPrevTo = pDoc;
                }

                m_SPDocuments[j]->Release();
                m_SPDocuments[j] = pPrevTo;
                m_SPDocuments[j]->AddRef();

                j++;
            }

            m_SPCount = j;
        }
    }
    
    return hr;
}

//
// Initialize a DebuggerFunction object.
//
HRESULT DebuggerFunction::Init(void)
{
    if (m_VCHack)
        return (S_OK);

    HRESULT hr = S_OK;
    
    m_nEditAndContinueLastSynched = g_pShell->m_cEditAndContinues;

    // Get the symbol reader method for this method.
    if (GetModule()->GetSymbolReader() != NULL)
    {
        hr = GetModule()->GetSymbolReader()->GetMethod(GetToken(), &m_symMethod);

        if (hr != S_OK)
            m_symMethod = NULL;
    }
    else
        m_symMethod = NULL;

    CacheSequencePoints();

    //
    // Get properties of the method.
    //
    mdTypeDef   classToken = mdTypeDefNil;
    WCHAR       methodName[BUF_SIZE];
    ULONG       methodNameLength = 0;
    PCCOR_SIGNATURE sigBlob = NULL;
    ULONG       sigBlobSize = 0;
    DWORD       methodAttr = 0;
    ULONG       cb = 0;

    hr = m_module->GetMetaData()->GetMethodProps(GetToken(),
                                                 &classToken,
                                                 methodName,
                                                 MAX_CLASSNAME_LENGTH,
                                                 &methodNameLength,
                                                 &methodAttr,
                                                 &sigBlob,
                                                 &sigBlobSize,
                                                 NULL, NULL);

    TESTANDRETURNHR(hr);

    m_signature = sigBlob; //@todo - do we have to release this, or is
                           // this a pointer into MD owned space?
    m_class = classToken;
    m_name = new WCHAR[methodNameLength];
    _ASSERTE(m_name != NULL);

    if (m_name == NULL)
        return (E_OUTOFMEMORY);

    memcpy(m_name, methodName, methodNameLength * sizeof(WCHAR));

    //
    // Get properites of this method's class. (Mostly for the class name.)
    //
    if (m_class != mdTypeDefNil)
    {
        WCHAR       fullName[MAX_CLASSNAME_LENGTH];
        ULONG       fullNameSize = 0;
        WCHAR       *Namespace;
        ULONG       NamespaceSize=0;
        WCHAR       *className;
        ULONG       classNameSize = 0;

        hr = m_module->GetMetaData()->GetTypeDefProps(classToken,
                                                      fullName, MAX_CLASSNAME_LENGTH,
                                                      &fullNameSize,
                                                      NULL, NULL);
        TESTANDRETURNHR(hr);

        Namespace = fullName;
        className  = wcsrchr(fullName, L'.');
        if (className)
            *className++ = 0;
        else
        {
            Namespace = L"";
            className = fullName;
        }

        NamespaceSize = wcslen(Namespace) + 1;
        classNameSize = wcslen(className) + 1;

        m_namespaceName = new WCHAR[NamespaceSize+1];
        _ASSERTE(m_namespaceName != NULL);

        if (m_namespaceName == NULL)
            return (E_OUTOFMEMORY);

        memcpy(m_namespaceName, Namespace, NamespaceSize * sizeof(WCHAR));

        if (wcslen(Namespace))
            wcscat (m_namespaceName, L".");
        else
            m_namespaceName[0] = L'\0';


        m_className = new WCHAR[classNameSize];
        _ASSERTE(m_className != NULL);

        if (m_className == NULL)
            return (E_OUTOFMEMORY);

        memcpy(m_className, className, classNameSize * sizeof(WCHAR));    
    }
    else
    {
        m_className = new WCHAR[1];
        _ASSERTE(m_className != NULL);
        
        if (m_className == NULL)
            return (E_OUTOFMEMORY);
        m_className [0] = L'\0';

        m_namespaceName = new WCHAR[1];
        _ASSERTE(m_namespaceName != NULL);
        
        if (m_namespaceName == NULL)
            return (E_OUTOFMEMORY);
        m_namespaceName [0] = L'\0';
    }

    //
    // Make sure we have a method signature.
    //
    ULONG callConv;
    cb += CorSigUncompressData(&sigBlob[cb], &callConv);
    _ASSERTE(callConv != IMAGE_CEE_CS_CALLCONV_FIELD);

    //
    // Grab the argument count.
    //
    ULONG argCount;
    cb += CorSigUncompressData(&sigBlob[cb], &argCount);
    m_argCount = argCount;

    //
    // Have the return type point directly to the return type in the
    // method signature.
    //
    m_returnType = &sigBlob[cb];

    //
    // Skip past the return type.
    //
    cb += _skipTypeInSignature(&sigBlob[cb]);

    m_isStatic = (methodAttr & mdStatic) != 0;

    unsigned int i;

    if (!m_isStatic)
        m_argCount++;

    if (m_argCount)
    {
        m_arguments = new DebuggerVarInfo[m_argCount];

        if (m_arguments == NULL)
        {
            m_argCount = 0;
            return (S_OK);
        }

        if (!m_isStatic)
        {
            char *newName = new char[5];
            _ASSERTE(newName != NULL);
            strcpy(newName, "this");
            m_arguments[0].name = newName;
            m_arguments[0].sig = (PCCOR_SIGNATURE) &g_ObjectSignature; // never really used...
            m_arguments[0].varNumber = 0;

            i = 1;
        }
        else
            i = 0;

        for (; i < m_argCount; i++)
        {
            m_arguments[i].name = NULL;
            m_arguments[i].sig = &sigBlob[cb];
            m_arguments[i].varNumber = i;

            cb += _skipTypeInSignature(&sigBlob[cb]);
        }
    }

    hr = m_module->GetICorDebugModule()->GetFunctionFromToken(GetToken(),
                                                              &m_ifunction);

    if( FAILED(hr) )
        return hr;

    // Now, load any argument names.
    if (m_argCount > 0)
    {
        HCORENUM paramEnum = NULL;
        bool fCloseEnum = false;
        IMetaDataImport *pIMI = m_module->GetMetaData();

        while (TRUE)
        {
            mdParamDef param[1];
            ULONG      numParams = 0;

            hr = pIMI->EnumParams(&paramEnum,
                                  GetToken(),
                                  param, 1, &numParams);

            if (SUCCEEDED(hr) && (numParams == 0))
            {
                fCloseEnum = true;
                hr = S_OK;
                break;
            }

            if (FAILED(hr))
                break;

            fCloseEnum = true;

            WCHAR name[BUF_SIZE];
            ULONG nameLen;
            ULONG seq;

            hr = pIMI->GetParamProps(param[0], 0,
                                     &seq, name, BUF_SIZE, &nameLen,
                                     NULL, NULL, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                char* newName = new char[nameLen];
                _ASSERTE(newName != NULL);

                unsigned int i;

                for (i = 0; i < nameLen; i++)
                    newName[i] = (char)(name[i]); // @TODO LBS - should we be using some form of mbs to unicode here?

                if (m_isStatic)
                    seq--;

                if (seq < m_argCount)
                    m_arguments[seq].name = newName;
                else
                    delete [] newName;
            }
            else
                break;
        }

        if (fCloseEnum)
            pIMI->CloseEnum(paramEnum);

        // Give any unnamed aguments names now...
        for (i = 0; i < m_argCount; i++)
        {
            if (m_arguments[i].name == NULL)
            {
                char *newName = new char[07];
                _ASSERTE(newName != NULL);
                sprintf(newName, "Arg%d", i);
                m_arguments[i].name = newName;
            }
        }
    }

    return (hr);
}


DebuggerFunction::~DebuggerFunction()
{

    if (m_arguments != NULL)
    {
        unsigned int i;

        for (i = 0; i < m_argCount; i++)
            delete [] (char *) m_arguments[i].name;

        delete [] m_arguments;
    }

    delete m_nativeCode;
    delete m_ilCode;
    delete [] m_name;
    delete [] m_className;
    delete [] m_namespaceName;

    if (g_pShell != NULL)
        g_pShell->m_invalidCache = false;

    if (m_ifunction != NULL)
        RELEASE(m_ifunction);

    if (m_symMethod)
    {
        if (m_SPOffsets)
            delete [] m_SPOffsets;
        
        if (m_SPDocuments)
        {
            for (ULONG32 i = 0; i < m_SPCount; i++)
                m_SPDocuments[i]->Release();
            
            delete [] m_SPDocuments;
        }
        
        if (m_SPLines)
            delete [] m_SPLines;
        
        RELEASE(m_symMethod);
    }
#ifdef _DEBUG
    else
        _ASSERTE(!m_SPDocuments && !m_SPOffsets && m_SPLines == 0);
#endif
}

//
// Find the lowest line number that corresponds to a given IP with the method.
//
HRESULT DebuggerFunction::FindLineFromIP(UINT_PTR ip,
                                         DebuggerSourceFile **pDoc,
                                         unsigned int *line)
{
    HRESULT hr = S_FALSE;

    *pDoc = NULL;
    *line = 0;

    unsigned int i;

    // Make sure we've got the most recent copy....
    if (g_pShell->m_cEditAndContinues != m_nEditAndContinueLastSynched)
    {
       hr = CacheSequencePoints();
       
        if (FAILED( hr ) )
            return hr;
            
        m_nEditAndContinueLastSynched = g_pShell->m_cEditAndContinues;
    }

    // Only search if we have something to search over
    if (m_SPCount > 0)
    {
        // If ip is lower than the first ip...
        if (m_SPOffsets[0] <= ip)
        {
            // Find the first entry that corresponds to this ip.
            for (i = 0; i < m_SPCount; i++)
                if (m_SPOffsets[i] >= ip)
                    break;

            // If not an exact match, then we're one too high.
            if (((i == m_SPCount) || (m_SPOffsets[i] != ip)) && (i > 0))
                i--;

            *line = m_SPLines[i];
            VERIFY(*pDoc = GetModule()->ResolveSourceFile(m_SPDocuments[i]));

            hr = S_OK;
        }
    }

    return hr;
}


//
// Get the line stepping range for the given ip.
//

void DebuggerFunction::GetStepRangesFromIP(UINT_PTR ip, 
                                           COR_DEBUG_STEP_RANGE **range,
                                           SIZE_T *rangeCount)
{
    HRESULT hr;
    //
    // !!! Really, we should find _all_ source lines, not just one. (?)
    //

    DebuggerSourceFile *file = NULL;
    unsigned int line;

    *range = NULL;
    *rangeCount = 0;

    hr = FindLineFromIP(ip, &file, &line);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return;
    }

    if (file == NULL || !file->LoadText(g_pShell->m_currentSourcesPath, false))
        return;

    ULONG32 *rangeArray = NULL;
    ULONG32 rangeArraySize = 0;

    // How many ranges are there?
    if (m_symMethod)
    {
        hr = m_symMethod->GetRanges(file->GetDocument(),
                                    line, 0,
                                    0, &rangeArraySize, NULL);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return;
        }
    }

    if (rangeArraySize > 0)
    {
        // Make room and get the ranges.
        rangeArray = (ULONG32*)_alloca(sizeof(ULONG32) * rangeArraySize);
        _ASSERTE(rangeArray != NULL);
    
        hr = m_symMethod->GetRanges(file->GetDocument(),
                                    line, 0,
                                    rangeArraySize,
                                    &rangeArraySize,
                                    rangeArray);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return;
        }
    
        // lineRangeCount should be a reasonable approximation of
        // memory to allocate.
        *range = new COR_DEBUG_STEP_RANGE[rangeArraySize / 2]; 
        _ASSERTE(*range != NULL);

        COR_DEBUG_STEP_RANGE *r = *range;

        for (ULONG32 i = 0; i < rangeArraySize; i += 2)
        {
            r->startOffset = rangeArray[i];
            r->endOffset = rangeArray[i+1];

            r++;
        }
    }
    else
        *range = NULL;

    *rangeCount = rangeArraySize / 2;
}


//
// Given a scope, determine how many local vars are "active" at the given
// line number. The count includes any locals that are active in scopes
// that are children of the given scope.
//
void DebuggerFunction::CountActiveLocalVars(ISymUnmanagedScope* head,
                                            unsigned int ip,
                                            unsigned int* varCount)
{
    if (head != NULL)
    {
        ULONG32 startOffset, endOffset;

        HRESULT hr = head->GetStartOffset(&startOffset);
        _ASSERTE(SUCCEEDED(hr));
        hr = head->GetEndOffset(&endOffset);
        _ASSERTE(SUCCEEDED(hr));
        
        if ((ip >= startOffset) && (ip <= endOffset))
        {
            ULONG32 childCount;

            // How many children?
            hr = head->GetChildren(0, &childCount, NULL);

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);
                return;
            }

            if (childCount > 0)
            {
                // Make room for the children
                CQuickBytes childrenBuf;
                ISymUnmanagedScope **children =
                    (ISymUnmanagedScope**)childrenBuf.Alloc(sizeof(ISymUnmanagedScope*) * childCount);
                if (children == NULL)
                {
                    g_pShell->Error(L"Could not get memory for children scopes\n");
                    return;
                }

                // Get the children
                hr = head->GetChildren(childCount, &childCount, children);

                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    return;
                }
                
                for (ULONG32 i = 0; i < childCount; i++)
                {
                    CountActiveLocalVars(children[i], ip, varCount);
                    RELEASE(children[i]);
                }
            }
            
            ULONG32 vc;
            hr = head->GetLocalCount(&vc);
            _ASSERTE(SUCCEEDED(hr));
            
            *varCount += vc;
        }
    }
}


//
// Given a scope and an array of DebuggerVarInfo pointers, fill up the array
// with pointers to every "active" local variable within the scope, including
// any active locals in child scopes. The size of the varPtrs array is
// passed in as varCount and is used for bounds checking.
//
void DebuggerFunction::FillActiveLocalVars(ISymUnmanagedScope* head,
                                           unsigned int ip,
                                           unsigned int varCount,
                                           unsigned int* currentVar,
                                           DebuggerVariable* varPtrs)
{
    if (head != NULL)
    {
        ULONG32 startOffset, endOffset;

        HRESULT hr = head->GetStartOffset(&startOffset);
        _ASSERTE(SUCCEEDED(hr));
        hr = head->GetEndOffset(&endOffset);
        _ASSERTE(SUCCEEDED(hr));
        
        if ((ip >= startOffset) && (ip <= endOffset))
        {
            ULONG32 childCount;

            // How many children?
            hr = head->GetChildren(0, &childCount, NULL);

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);
                return;
            }

            if (childCount > 0)
            {
                // Make room for the children
                CQuickBytes childrenBuf;
                ISymUnmanagedScope **children =
                    (ISymUnmanagedScope**)childrenBuf.Alloc(sizeof(ISymUnmanagedScope*) * childCount);
                if (children == NULL)
                {
                    g_pShell->Error(L"Could not get memory for children scopes\n");
                    return;
                }

                // Get the children
                hr = head->GetChildren(childCount, &childCount, children);

                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    return;
                }
                
                for (ULONG32 i = 0; i < childCount; i++)
                {
                    FillActiveLocalVars(children[i], ip, varCount,
                                        currentVar, varPtrs);
                    RELEASE(children[i]);
                }
            }

            // Fill in any locals on this scope.
            ULONG32 localCount;

            // How many locals?
            hr = head->GetLocalCount(&localCount);

            if (FAILED(hr))
            {
                g_pShell->ReportError(hr);
                return;
            }

            if (localCount > 0)
            {
                // Make room for the localc
                CQuickBytes localsBuf;
                ISymUnmanagedVariable **locals =
                    (ISymUnmanagedVariable**)localsBuf.Alloc(sizeof(ISymUnmanagedVariable*) *
                                            localCount);
                if (locals == NULL)
                {
                    g_pShell->Error(L"Could not get memory for children\n");
                    return;
                }
                
                hr = head->GetLocals(localCount, &localCount, locals);
            
                if (FAILED(hr))
                {
                    g_pShell->ReportError(hr);
                    return;
                }

                for (ULONG32 i = 0; i < localCount; i++)
                {
                    _ASSERTE(*currentVar < varCount);

                    // Get the size of the name.
                    ULONG32 nameSize;

                    hr = locals[i]->GetName(0, &nameSize, NULL);
                    
                    if (FAILED(hr))
                    {
                        g_pShell->ReportError(hr);
                        return;
                    }

                    // Allocate space for the name.
                    varPtrs[*currentVar].m_name = new WCHAR[nameSize + 1];

                    if (varPtrs[*currentVar].m_name == NULL)
                    {
                        g_pShell->ReportError(E_OUTOFMEMORY);
                        return;
                    }

                    // Get the name.
                    hr = locals[i]->GetName(nameSize + 1, &nameSize,
                                            varPtrs[*currentVar].m_name);
                
                    if (FAILED(hr))
                    {
                        g_pShell->ReportError(hr);
                        return;
                    }

#ifdef _DEBUG
                    ULONG32 addrKind;
                    hr = locals[i]->GetAddressKind(&addrKind);
                    _ASSERTE(addrKind == ADDR_IL_OFFSET);
#endif                    

                    hr = locals[i]->GetAddressField1(&(varPtrs[*currentVar].m_varNumber));

                    if (FAILED(hr))
                    {
                        g_pShell->ReportError(hr);
                        return;
                    }

                    (*currentVar)++;
                }
            }
        }
    }
}


//
// Build a list of the active local variables within a method at a given IP.
//
bool DebuggerFunction::GetActiveLocalVars(UINT_PTR ip,
                                          DebuggerVariable** vars,
                                          unsigned int* count)
{
    HRESULT hr = S_OK;

    *vars = NULL;
    *count = 0;

    // Grab the root scope for this method.
    ISymUnmanagedScope *rootScope = NULL;

    if (m_symMethod)
    {
        hr = m_symMethod->GetRootScope(&rootScope);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return false;
        }
    }

    // No work to do if there is no scope info for this method!
    if (!rootScope)
        return false;

    // Count the active locals.
    unsigned int localCount = 0;

    CountActiveLocalVars(rootScope, ip, &localCount);

    // No work to do if there aren't any locals in scope.
    if (localCount == 0)
    {
        rootScope->Release();
        return true;
    }

    // Allocate and fillup a list of DebuggerVariable pointers to
    // each variable.
    DebuggerVariable *varPtrs = new DebuggerVariable[localCount];
    _ASSERTE(varPtrs != NULL);

    if (varPtrs != NULL)
    {
        unsigned int currentVar = 0;

        FillActiveLocalVars(rootScope, ip, localCount,
                            &currentVar, varPtrs);
    }
    else
        localCount = 0;

    *vars = varPtrs;
    *count = localCount;

    rootScope->Release();

    return true;
}

DebuggerFunction *DebuggerFunction::FromCorDebug(ICorDebugFunction *function)
{
    mdMethodDef md;
    HRESULT hr;

    // Get the method def token for function
    hr = function->GetToken(&md);

    // Error check
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return NULL;
    }

    // Now get the module interface, so we can get a pointer to the CorDbg
    // DebuggerModule object
    ICorDebugModule *imodule;
    hr = function->GetModule(&imodule);
    
    // Error check
    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return NULL;
    }

    // Get a pointer to the CorDbg module
    DebuggerModule *m = DebuggerModule::FromCorDebug(imodule);
    _ASSERTE(m);  // should never fail

    // Release the interface
    imodule->Release();

    // Use the debugger module to resolve the function to a DebuggerFunction ptr
    return (m->ResolveFunction(md, function));
}

HRESULT DebuggerFunction::LoadCode(BOOL native)
{
    _ASSERTE(g_pShell != NULL);

    if (native)
    {
        ICorDebugCode *icode;
        HRESULT hr = m_ifunction->GetNativeCode(&icode);

        if (FAILED(hr) && hr != CORDBG_E_CODE_NOT_AVAILABLE)
            return (hr);

        ULONG32 size;
        icode->GetSize(&size);

        if (m_nativeCode)
            delete [] m_nativeCode;
        
        m_nativeCode = new BYTE [size];
        _ASSERTE(m_nativeCode != NULL);
        m_nativeCodeSize = size;

        if (m_nativeCode == NULL)
        {
            icode->Release();
            return (E_OUTOFMEMORY);
        }

        hr = icode->GetCode(0, size, size, 
                            m_nativeCode, &m_nativeCodeSize);

        icode->Release();

        if (FAILED(hr))
        {
            delete m_nativeCode;
            return (hr);
        }

        return (S_OK);
    }
    else
    {
        ICorDebugCode *icode;
        HRESULT hr = m_ifunction->GetILCode(&icode);
        
        if (FAILED(hr))
            return (hr);

        ULONG32 size;
        icode->GetSize(&size);

        if (m_ilCode != NULL)
            delete m_ilCode;

        m_ilCode = new BYTE [size];
        m_ilCodeSize = size;

        if (m_ilCode == NULL)
        {
            icode->Release();
            return (E_OUTOFMEMORY);
        }

        hr = icode->GetCode(0, size, size, 
                            m_ilCode, &m_ilCodeSize);

        icode->Release();

        if (FAILED(hr))
        {
            delete m_ilCode;
            return (hr);
        }

        return (S_OK);
    }
}

BOOL DebuggerFunction::ValidateInstruction(BOOL native, SIZE_T offset)
{
    if (FAILED(LoadCode(native)))
        return (FALSE);

    BYTE *codeStart;
    BYTE *codeEnd;
    
    if (native)
    {
        if (offset >= m_nativeCodeSize)
            return (false);

        codeStart = m_nativeCode;
        codeEnd = m_nativeCode + m_nativeCodeSize;
    }
    else
    {
        if (offset >= m_ilCodeSize)
            return (false);

        codeStart = m_ilCode;
        codeEnd = m_ilCode + m_ilCodeSize;
    }

    SIZE_T walk = 0;

#ifdef _INTERNAL_DEBUG_SUPPORT_
    while (walk < offset)
        walk = WalkInstruction(native, walk, codeStart, codeEnd);
#endif

    return (walk == offset);
}

/* ------------------------------------------------------------------------- *
 * DebuggerCodeBreakpoint
 * ------------------------------------------------------------------------- */

DebuggerCodeBreakpoint::DebuggerCodeBreakpoint(int breakpointID, 
                                               DebuggerModule *module,
                                               DebuggerFunction *function, 
                                               SIZE_T offset, BOOL il,
                                               DWORD threadID)
    : m_id(breakpointID), m_module(module), m_function(function), 
      m_offset(offset), m_il(il), m_threadID(threadID),
      m_ibreakpoint(NULL), m_parent(NULL)
{
    m_next = m_module->m_breakpoints;
    m_module->m_breakpoints = this;
    m_id = breakpointID;
}

DebuggerCodeBreakpoint::DebuggerCodeBreakpoint(
                            int breakpointID, DebuggerModule *module,
                            DebuggerSourceCodeBreakpoint *parent, 
                            DebuggerFunction *function, SIZE_T offset, BOOL il,
                            DWORD threadID)
    : m_id(breakpointID), m_module(module), m_function(function), 
      m_offset(offset), m_il(il), 
      m_threadID(threadID), 
      m_ibreakpoint(NULL), m_parent(parent)
{
    m_next = parent->m_breakpoints;
    parent->m_breakpoints = this;
    m_id = parent->m_id;
}

DebuggerCodeBreakpoint::~DebuggerCodeBreakpoint()
{
    DebuggerCodeBreakpoint  **next;

    //
    // Remove either global list or parent list
    //

    if (m_parent == NULL)
        next = &m_module->m_breakpoints;
    else
        next = &m_parent->m_breakpoints;

    while ((*next) != this)
        next = &((*next)->m_next);

    *next = (*next)->m_next;

    //
    // Destroy the cor breakpoint
    //

    if (m_ibreakpoint != NULL)
    {
        m_ibreakpoint->Release();
    }
}

bool DebuggerCodeBreakpoint::Activate()
{
    if (m_ibreakpoint == NULL && m_function != NULL)
    {
        ICorDebugCode *icode = NULL;

        HRESULT hr;

        if (m_il)
            hr = m_function->m_ifunction->GetILCode(&icode);
        else
            hr = m_function->m_ifunction->GetNativeCode(&icode);

        if (SUCCEEDED(hr) || hr == CORDBG_E_CODE_NOT_AVAILABLE)
            hr = icode->CreateBreakpoint(m_offset, &m_ibreakpoint);

        if (icode)
            icode->Release();
    }

    if (m_ibreakpoint != NULL)
    {
        m_ibreakpoint->Activate(TRUE);
        return (true);
    }
    else
        return (false);
}

void DebuggerCodeBreakpoint::Deactivate()
{
    if (m_ibreakpoint != NULL)
    {
        m_ibreakpoint->Activate(FALSE);
        m_ibreakpoint->Release();
        m_ibreakpoint = NULL;
    }
}

bool DebuggerCodeBreakpoint::Match(ICorDebugBreakpoint *ibreakpoint)
{
    return (ibreakpoint == m_ibreakpoint);
}

void DebuggerCodeBreakpoint::Print()
{
    g_pShell->Write(L"%s+0x%x(%s) [%sactive]", 
                    m_function->GetName(), m_offset, 
                    m_il ? L"il" : L"native",
                    m_ibreakpoint == NULL ? L"in" : L"");
}

DebuggerSourceCodeBreakpoint::DebuggerSourceCodeBreakpoint(
                                               int breakpointID,
                                               DebuggerSourceFile *file, 
                                               SIZE_T lineNumber,
                                               DWORD threadID)
    : DebuggerCodeBreakpoint(breakpointID, file->m_module, NULL, 
                             0, FALSE, threadID), 
      m_file(file), m_lineNumber(lineNumber), m_breakpoints(NULL),
      m_initSucceeded(false)
{
    DebuggerModule          *m = file->m_module;

    // GetMethodFromDocumentPosition to get an ISymUnmanagedMethod from this doc.
    ISymUnmanagedMethod *pSymMethod;

    HRESULT hr = m->GetSymbolReader()->GetMethodFromDocumentPosition(
                                                        file->GetDocument(),
                                                        lineNumber, 0,
                                                        &pSymMethod);

    if (FAILED(hr))
    {
        g_pShell->Write(L"Failed to find method to match source line. "
                        L"Unable to set breakpoint.\n");
        g_pShell->ReportError(hr);
        return;
    }
    
    // Make a regular breakpoint a the start of each line range.
    ULONG32 *rangeArray = NULL;
    ULONG32 rangeArraySize = 0;

    // How many ranges are there?
    hr = pSymMethod->GetRanges(file->GetDocument(),
                               lineNumber, 0,
                               0, &rangeArraySize, NULL);

    if (FAILED(hr))
    {
        g_pShell->ReportError(hr);
        return;
    }

    if (rangeArraySize > 0)
    {
        // Make room and get the ranges.
        rangeArray = (ULONG32*)_alloca(sizeof(ULONG32) * rangeArraySize);
        _ASSERTE(rangeArray != NULL);
    
        hr = pSymMethod->GetRanges(file->GetDocument(),
                                   lineNumber, 0,
                                   rangeArraySize,
                                   &rangeArraySize,
                                   rangeArray);

        if (FAILED(hr))
        {
            g_pShell->ReportError(hr);
            return;
        }

        DebuggerFunction *f = m->ResolveFunction(pSymMethod, NULL);

        if (rangeArraySize == 2)
        {
            m_function = f;
            m_offset = rangeArray[0];
            m_il = TRUE;
        }
        else
        {
            for (ULONG32 i = 0; i < rangeArraySize; i += 2)
            {
                if (i > 0 && (rangeArray [i-1] == rangeArray [i]))
                    continue;

                new DebuggerCodeBreakpoint(breakpointID, file->m_module, 
                                         this, f, rangeArray[i], TRUE, 
                                         m_threadID);
            }
        }
    }

    // Lame way of indicating that a constructor succeeded
    m_initSucceeded = true;
}

DebuggerSourceCodeBreakpoint::~DebuggerSourceCodeBreakpoint()
{
    while (m_breakpoints != NULL)
        delete m_breakpoints;
}

bool DebuggerSourceCodeBreakpoint::Activate()
{
    bool result = true;

    DebuggerCodeBreakpoint::Activate();

    DebuggerCodeBreakpoint *b = m_breakpoints;

    while (b != NULL)
    {
        result = b->Activate() && result;
        b = b->m_next;
    }

    return (result);
}

void DebuggerSourceCodeBreakpoint::Deactivate()
{
    DebuggerCodeBreakpoint::Deactivate();

    DebuggerCodeBreakpoint *b = m_breakpoints;

    while (b != NULL)
    {
        b->Deactivate();
        b = b->m_next;
    }
}

bool DebuggerSourceCodeBreakpoint::Match(ICorDebugBreakpoint *ibreakpoint)
{
    if (ibreakpoint == m_ibreakpoint)
        return (true);

    DebuggerCodeBreakpoint *bp = m_breakpoints;
    while (bp != NULL)
    {
        if (bp->m_ibreakpoint == ibreakpoint)
            return (true);
        bp = bp->m_next;
    }

    return (false);
}

void DebuggerSourceCodeBreakpoint::Print()
{
    DebuggerCodeBreakpoint *bp = m_breakpoints;

    if (bp == NULL)
        DebuggerCodeBreakpoint::Print();
    else
        while (bp != NULL)
        {
            bp->Print();
            bp = bp->m_next;
        }
}

/* ------------------------------------------------------------------------- *
 * StepperHashTable class
 * ------------------------------------------------------------------------- */


HRESULT StepperHashTable::Initialize()
{
    HRESULT hr = NewInit(m_iBuckets, 
                         sizeof(StepperHashEntry), 0xffff);
    if (FAILED(hr))
          return (hr);

    m_initialized = true;
    return S_OK;
}


HRESULT StepperHashTable::AddStepper(ICorDebugStepper *pStepper)
{
    if (!m_initialized)
    {
        HRESULT hr = NewInit(m_iBuckets, 
                             sizeof(StepperHashEntry), 0xffff);
        if (FAILED(hr))
            return (hr);

        m_initialized = true;
    }

    StepperHashEntry *entry = (StepperHashEntry *) Add(HASH(pStepper));

    if (entry == NULL)
        return (E_FAIL);
    else
        entry->pStepper = pStepper;

    pStepper->AddRef(); //don't want this to disappear from under
        //the table's feet

    return (S_OK);
}

bool StepperHashTable::IsStepperPresent(ICorDebugStepper *pStepper)
{
    if (!m_initialized)
        return false;

    StepperHashEntry *entry 
    = (StepperHashEntry *) Find(HASH(pStepper), KEY(pStepper)); 
    if (entry == NULL)
        return false;
    else
        return true;
}

BOOL StepperHashTable::RemoveStepper(ICorDebugStepper *pStepper)
{
    if (!m_initialized)
        return (FALSE);

    StepperHashEntry *entry 
    = (StepperHashEntry *) Find(HASH(pStepper), KEY(pStepper));

    if (entry == NULL)
        return (FALSE);

    Delete(HASH(pStepper), (HASHENTRY *) entry);

    RELEASE(pStepper);

    return (TRUE);
}

void StepperHashTable::ReleaseAll()
{
    if (!m_initialized)
        return;

    HASHFIND find;
    ICorDebugStepper *pStepper = NULL;
    
    pStepper = FindFirst(&find);
    while( pStepper != NULL)
    {
        RELEASE( pStepper );
        RemoveStepper( pStepper );
    
        pStepper = FindNext(&find);
    }

    Clear();    
}

ICorDebugStepper *StepperHashTable::FindFirst(HASHFIND *find)
{
    if (!m_initialized)
        return NULL;
        
    StepperHashEntry *entry = (StepperHashEntry *) FindFirstEntry(find);
    if (entry == NULL)
        return NULL;
    else
        return entry->pStepper;
}

ICorDebugStepper *StepperHashTable::FindNext(HASHFIND *find)
{
    if (!m_initialized)
        return NULL;

    StepperHashEntry *entry = (StepperHashEntry *) FindNextEntry(find);
    if (entry == NULL)
        return NULL;
    else
        return entry->pStepper;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\debug\shell\shell.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ------------------------------------------------------------------------- *
 * debug\shell.h: generic shell class
 * ------------------------------------------------------------------------- */

#ifndef SHELL_H_
#define SHELL_H_

#include <string.h>

/* ------------------------------------------------------------------------- *
 * Class forward declations
 * ------------------------------------------------------------------------- */

class Shell;
class ShellCommand;
class ShellCommandTable;
class HelpShellCommand;

/* ------------------------------------------------------------------------- *
 * Abstract ShellCommand class
 *
 * All commands that the shell will support must be derived from this class.
 * ------------------------------------------------------------------------- */

class ShellCommand
{
protected:
    
    const WCHAR *m_pName;		// full command name
    WCHAR m_pShortcutName[64];	// shortcut syntax

    // The minimum subset of name that must be typed in
    int m_minMatchLength;
    
    // does this command have a shortcut?
    BOOL m_bHasShortcut;

public:
    ShellCommand(const WCHAR *name, int MatchLength = 0);

    virtual ~ShellCommand()
    {
    }

    /*********************************************************************
     * Methods
     */

    /*
     * Executes the shell command
     */
    virtual void Do(Shell *shell, const WCHAR *args) = 0;

    /*
     * Displays a help message to the user
     */
    virtual void Help(Shell *shell);

    /*
     * Returns a short help message for the user
     */
    virtual const WCHAR *ShortHelp(Shell *shell)
    {
        // Name is a good default.
        return m_pName;
    }

    /*
     * Returns the name of the command
     */
    const WCHAR *GetName()
    {
        return m_pName;
    }
    
    /*
     * Returns the shortcut name of the command
     */
    const WCHAR *GetShortcutName()
	{
		return m_pShortcutName;
   	}

    /*
     * Returns the minimum match length
     */
    int GetMinMatchLength()
    {
        return m_minMatchLength;
    }
    
    /*
     * Returns whether the name has a shortcut
     */
    BOOL HasShortcut()
    {
        return m_bHasShortcut;
    }

};

/* ------------------------------------------------------------------------- *
 * Abstract Shell class
 *
 * A basic outline of a command shell, used by the debugger.
 * ------------------------------------------------------------------------- */

const int BUFFER_SIZE = 1024;

class Shell
{
private:
    // The collection of the available commands
    ShellCommandTable *m_pCommands;

    // The last command executed
    WCHAR m_lastCommand[BUFFER_SIZE];

    // A buffer for reading input
    WCHAR m_buffer[BUFFER_SIZE];

protected:
    // The input prompt
    WCHAR *m_pPrompt;

public:
    Shell();
    ~Shell();

    /*********************************************************************
     * Shell I/O routines
     */

    /*
     * Read a line of input from the user, getting a maximum of maxCount chars
     */
    virtual bool ReadLine(WCHAR *buffer, int maxCount) = 0;

    /*
     * Write a line of output to the shell
     */
    virtual HRESULT Write(const WCHAR *buffer, ...) = 0;

    /*
     * Write an error to the shell
     */
    virtual void Error(const WCHAR *buffer, ...) = 0;

    void ReportError(long res);
    void SystemError();

    /*********************************************************************
     * Shell functionality
     */

    /*
     * This will add a command to the collection of available commands
     */
    void AddCommand(ShellCommand *command);

    /*
     * This will get a command from the available commands by matching the
     * command name with string.
     */
    ShellCommand *GetCommand(const WCHAR *string, size_t length);

    /*
     * This will get a command from the available commands by matching the
     * command name with string.
     */
    void PutCommand(FILE *f);

    /*
     * This will read a command from the user
     */
    void ReadCommand();

    /*
     * This will attempt to match string with a command and execute it with
     * the arguments following the command string.
     */
    void DoCommand(const WCHAR *string);

    /*
     * This will call DoCommand once for each thread in the process.
     */
    virtual void DoCommandForAllThreads(const WCHAR *string) = 0;

    /*
     * This will provide a listing of the commands available to the shell.
     */
    void Help();

    // utility methods: 
    bool GetStringArg(const WCHAR * &string, const WCHAR * &result);
    bool GetIntArg(const WCHAR * &string, int &result);
    bool GetInt64Arg(const WCHAR * &string, unsigned __int64 &result);

    size_t GetArgArray(WCHAR *argString, const WCHAR **argArray, size_t argMax);

    const WCHAR *GetPrompt()
    {
        return m_pPrompt;
    }

    void SetPrompt(const WCHAR *prompt)
    {
        m_pPrompt = new WCHAR[wcslen(prompt)];
        wcscpy(m_pPrompt, prompt);
    }
};

/* ------------------------------------------------------------------------- *
 * Predefined command classes
 * ------------------------------------------------------------------------- */

class HelpShellCommand : public ShellCommand
{
public:
    HelpShellCommand(const WCHAR *name, int minMatchLength = 0)
    : ShellCommand(name, minMatchLength)
    {
        
    }

    /*
     * This will display help for the command given in args, or help on the
     * help command if args is empty.
     */
    void Do(Shell *shell, const WCHAR *args);

    /*
     * This will provide help for the help command.
     */
    void Help(Shell *shell);

    const WCHAR *ShortHelp(Shell *shell);
};

#endif /* SHELL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\delayimp\delayhk2.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define STRICT
#include <windows.h>
#pragma hdrstop
#include "delayImp.h"

// The "total hook" hook that gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == dliStartProcessing on this call.
//
extern "C"
PfnDliHook   __pfnDliNotifyHook = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\delayimp\delayhlp2.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define STRICT
#include <windows.h>
#pragma hdrstop
#include "delayImp2.h"

extern "C"
PUnloadInfo __puiHead = 0;

struct ULI : public UnloadInfo {
    ULI(PCImgDelayDescr pidd_) {
        pidd = pidd_;
        Link();
        }

    ~ULI() {
        Unlink();
        }

    void *
    operator new(size_t cb) {
        return ::LocalAlloc(LPTR, cb);
        }

    void
    operator delete(void * pv) {
        ::LocalFree(pv);
        }

    void
    Unlink() {
        PUnloadInfo *   ppui = &__puiHead;

        while (*ppui && *ppui != this) {
            ppui = &((*ppui)->puiNext);
            }
        if (*ppui == this) {
            *ppui = puiNext;
            }
        }

    void
    Link() {
        puiNext = __puiHead;
        __puiHead = this;
        }
    };

// For our own internal use, we convert to the old
// format for convenience.
//
struct InternalImgDelayDescr {
    DWORD           grAttrs;        // attributes
    LPCSTR          szName;         // pointer to dll name
    HMODULE *       phmod;          // address of module handle
    PImgThunkData   pIAT;           // address of the IAT
    PCImgThunkData  pINT;           // address of the INT
    PCImgThunkData  pBoundIAT;      // address of the optional bound IAT
    PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT
    DWORD           dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    };

typedef InternalImgDelayDescr *         PIIDD;
typedef const InternalImgDelayDescr *   PCIIDD;

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE);

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS);

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc);

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS, HMODULE);


// Do the InterlockedExchange magic
//
#if !defined(InterlockedExchangePointer)
    #if defined(_WIN64)
        #pragma intrinsic(_InterlockedExchangePointer)
        PVOID WINAPI _InterlockedExchangePointer(IN PVOID * pvDst, IN PVOID pvSrc);
        #define InterlockedExchangePointer _InterlockedExchangePointer

    #else
        #define InterlockedExchangePointer(dst, src) InterlockedExchange(LPLONG(dst), LONG(src))

    #endif
#endif

#if defined(_X86_) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif

#if !defined(PULONG_PTR)
#if defined(_WIN64)
typedef unsigned __int64 *      PULONG_PTR;
#else
typedef _W64 unsigned long *    PULONG_PTR;
#endif
#endif

extern "C"
FARPROC WINAPI
__delayLoadHelper2(
    PCImgDelayDescr     pidd,
    FARPROC *           ppfnIATEntry
    ) {

    // Set up some data we use for the hook procs but also useful for
    // our own use
    //
    InternalImgDelayDescr   idd = {
        pidd->grAttrs,
        PFromRva(pidd->rvaDLLName, LPCSTR(0)),
        PFromRva(pidd->rvaHmod, (HMODULE*)0),
        PFromRva(pidd->rvaIAT, PImgThunkData(0)),
        PFromRva(pidd->rvaINT, PCImgThunkData(0)),
        PFromRva(pidd->rvaBoundIAT, PCImgThunkData(0)),
        PFromRva(pidd->rvaUnloadIAT, PCImgThunkData(0)),
        pidd->dwTimeStamp
        };

    DelayLoadInfo   dli = {
        sizeof DelayLoadInfo,
        pidd,
        ppfnIATEntry,
        idd.szName,
            { 0 },
        0,
        0,
        0
        };

    if (0 == (idd.grAttrs & dlattrRva)) {
        PDelayLoadInfo  rgpdli[1] = { &dli };

        RaiseException(
            VcppException(ERROR_SEVERITY_ERROR, ERROR_INVALID_PARAMETER),
            0,
            1,
            PULONG_PTR(rgpdli)
            );
        return 0;
        }

    HMODULE hmod = *idd.phmod;

    // Calculate the index for the name in the import name table.
    // N.B. it is ordered the same as the IAT entries so the calculation
    // comes from the IAT side.
    //
    unsigned        iINT;
    iINT = IndexFromPImgThunkData(PCImgThunkData(ppfnIATEntry), idd.pIAT);

    PCImgThunkData  pitd = &(idd.pINT[iINT]);

    if (dli.dlp.fImportByName = !IMAGE_SNAP_BY_ORDINAL(pitd->u1.Ordinal)) {
        dli.dlp.szProcName = LPCSTR(PFromRva(RVA(UINT_PTR(pitd->u1.AddressOfData)), PIMAGE_IMPORT_BY_NAME(0))->Name);
        }
    else {
        dli.dlp.dwOrdinal = DWORD(IMAGE_ORDINAL(pitd->u1.Ordinal));
        }

    // Call the initial hook.  If it exists and returns a function pointer,
    // abort the rest of the processing and just return it for the call.
    //
    FARPROC pfnRet = NULL;

    if (__pfnDliNotifyHook) {
        if (pfnRet = ((*__pfnDliNotifyHook)(dliStartProcessing, &dli))) {
            goto HookBypass;
            }
        }

    if (hmod == 0) {
        if (__pfnDliNotifyHook) {
            hmod = HMODULE(((*__pfnDliNotifyHook)(dliNotePreLoadLibrary, &dli)));
            }
        if (hmod == 0) {
            hmod = ::LoadLibrary(dli.szDll);
            }
        if (hmod == 0) {
            dli.dwLastError = ::GetLastError();
            if (__pfnDliFailureHook) {
                // when the hook is called on LoadLibrary failure, it will
                // return 0 for failure and an hmod for the lib if it fixed
                // the problem.
                //
                hmod = HMODULE((*__pfnDliFailureHook)(dliFailLoadLib, &dli));
                }

            if (hmod == 0) {
                PDelayLoadInfo  rgpdli[1] = { &dli };

                RaiseException(
                    VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND),
                    0,
                    1,
                    PULONG_PTR(rgpdli)
                    );
                
                // If we get to here, we blindly assume that the handler of the exception
                // has magically fixed everything up and left the function pointer in 
                // dli.pfnCur.
                //
                return dli.pfnCur;
                }
            }

        // Store the library handle.  If it is already there, we infer
        // that another thread got there first, and we need to do a
        // FreeLibrary() to reduce the refcount
        //
        HMODULE hmodT = HMODULE(InterlockedExchangePointer((PVOID*)(idd.phmod), PVOID(hmod)));
        if (hmodT != hmod) {
            // add lib to unload list if we have unload data
            if (pidd->rvaUnloadIAT) {
                new ULI(pidd);
                }
            }
        else {
            ::FreeLibrary(hmod);
            }
        
        }

    // Go for the procedure now.
    dli.hmodCur = hmod;
    if (__pfnDliNotifyHook) {
        pfnRet = (*__pfnDliNotifyHook)(dliNotePreGetProcAddress, &dli);
        }
    if (pfnRet == 0) {
        if (pidd->rvaBoundIAT && pidd->dwTimeStamp) {
            // bound imports exist...check the timestamp from the target image
            PIMAGE_NT_HEADERS   pinh(PinhFromImageBase(hmod));

            if (pinh->Signature == IMAGE_NT_SIGNATURE &&
                TimeStampOfImage(pinh) == idd.dwTimeStamp &&
                FLoadedAtPreferredAddress(pinh, hmod)) {

                OverlayIAT(idd.pIAT, idd.pBoundIAT);
                pfnRet = FARPROC(idd.pIAT[iINT].u1.Function);
                goto HookBypass;
                }
            }

        pfnRet = ::GetProcAddress(hmod, dli.dlp.szProcName);
        }

    if (pfnRet == 0) {
        dli.dwLastError = ::GetLastError();
        if (__pfnDliFailureHook) {
            // when the hook is called on GetProcAddress failure, it will
            // return 0 on failure and a valid proc address on success
            //
            pfnRet = (*__pfnDliFailureHook)(dliFailGetProc, &dli);
            }
        if (pfnRet == 0) {
            PDelayLoadInfo  rgpdli[1] = { &dli };

            RaiseException(
                VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND),
                0,
                1,
                PULONG_PTR(rgpdli)
                );

            // If we get to here, we blindly assume that the handler of the exception
            // has magically fixed everything up and left the function pointer in 
            // dli.pfnCur.
            //
            pfnRet = dli.pfnCur;
            }
        }


    *ppfnIATEntry = pfnRet;

HookBypass:
    if (__pfnDliNotifyHook) {
        dli.dwLastError = 0;
        dli.hmodCur = hmod;
        dli.pfnCur = pfnRet;
        (*__pfnDliNotifyHook)(dliNoteEndProcessing, &dli);
        }
    return pfnRet;
    }

#pragma intrinsic(strlen,memcmp,memcpy)

extern "C"
BOOL WINAPI
__FUnloadDelayLoadedDLL2(LPCSTR szDll) {
    
    BOOL        fRet = FALSE;
    PUnloadInfo pui = __puiHead;
    
    for (pui = __puiHead; pui; pui = pui->puiNext) {
        LPCSTR  szName = PFromRva(pui->pidd->rvaDLLName, LPCSTR(0));
        if (memcmp(szDll, szName, strlen(szName)) == 0) {
            break;
            }
        }

    if (pui && pui->pidd->rvaUnloadIAT) {
        PCImgDelayDescr     pidd = pui->pidd;
        HMODULE *           phmod = PFromRva(pidd->rvaHmod, (HMODULE*)0);
        HMODULE             hmod = *phmod;

        OverlayIAT(
            PFromRva(pidd->rvaIAT, PImgThunkData(0)),
            PFromRva(pidd->rvaUnloadIAT, PCImgThunkData(0))
            );
        ::FreeLibrary(hmod);
        *phmod = NULL;
        
        delete reinterpret_cast<ULI*> (pui);

        fRet = TRUE;
        }

    return fRet;
    }

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE hmod) {
    return PIMAGE_NT_HEADERS(PBYTE(hmod) + PIMAGE_DOS_HEADER(hmod)->e_lfanew);
    }

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc) {
    memcpy(pitdDst, pitdSrc, CountOfImports(pitdDst) * sizeof IMAGE_THUNK_DATA);
    }

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS pinh) {
    return pinh->FileHeader.TimeDateStamp;
    }

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS pinh, HMODULE hmod) {
    return UINT_PTR(hmod) == pinh->OptionalHeader.ImageBase;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\delayimp\delayhlp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define STRICT
#include <windows.h>
#include <basetsd.h>
#pragma hdrstop
#include "delayImp.h"

extern "C"
PUnloadInfo __puiHead = 0;

struct ULI : public UnloadInfo {
    ULI(PCImgDelayDescr pidd_) {
        pidd = pidd_;
        Link();
        }

    ~ULI() {
        Unlink();
        }

    void *
    operator new(size_t cb) {
        return ::LocalAlloc(LPTR, cb);
        }

    void
    operator delete(void * pv) {
        ::LocalFree(pv);
        }

    void
    Unlink() {
        PUnloadInfo *   ppui = &__puiHead;

        while (*ppui && *ppui != this) {
            ppui = &((*ppui)->puiNext);
            }
        if (*ppui == this) {
            *ppui = puiNext;
            }
        }

    void
    Link() {
        puiNext = __puiHead;
        __puiHead = this;
        }
    };

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE);

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS);

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc);

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS, HMODULE);

extern "C"
FARPROC WINAPI
__delayLoadHelper(
    PCImgDelayDescr pidd,
    FARPROC *       ppfnIATEntry
    ) {

    // Set up some data we use for the hook procs but also useful for
    // our own use
    //
    DelayLoadInfo   dli = {
        sizeof DelayLoadInfo,
        pidd,
        ppfnIATEntry,
        pidd->szName,
            { 0 },
        0,
        0,
        0
        };


    HMODULE hmod = *(pidd->phmod);

    // Calculate the index for the name in the import name table.
    // N.B. it is ordered the same as the IAT entries so the calculation
    // comes from the IAT side.
    //
    unsigned        iINT;
    iINT = IndexFromPImgThunkData(PCImgThunkData(ppfnIATEntry), pidd->pIAT);

    PCImgThunkData  pitd = &((pidd->pINT)[iINT]);

    if (dli.dlp.fImportByName = ((pitd->u1.Ordinal & IMAGE_ORDINAL_FLAG) == 0)) {
#ifdef _WIN64
        dli.dlp.szProcName = LPCSTR(pitd->u1.AddressOfData);
#else // !_WIN64
        dli.dlp.szProcName = LPCSTR(pitd->u1.AddressOfData->Name);
#endif
        }
    else {
        dli.dlp.dwOrdinal = DWORD(IMAGE_ORDINAL(pitd->u1.Ordinal));
        }

    // Call the initial hook.  If it exists and returns a function pointer,
    // abort the rest of the processing and just return it for the call.
    //
    FARPROC pfnRet = NULL;

    if (__pfnDliNotifyHook) {
        if (pfnRet = ((*__pfnDliNotifyHook)(dliStartProcessing, &dli))) {
            goto HookBypass;
            }
        }

    if (hmod == 0) {
        if (__pfnDliNotifyHook) {
            hmod = HMODULE(((*__pfnDliNotifyHook)(dliNotePreLoadLibrary, &dli)));
            }
        if (hmod == 0) {
            hmod = ::LoadLibrary(dli.szDll);
            }
        if (hmod == 0) {
            dli.dwLastError = ::GetLastError();
            if (__pfnDliFailureHook) {
                // when the hook is called on LoadLibrary failure, it will
                // return 0 for failure and an hmod for the lib if it fixed
                // the problem.
                //
                hmod = HMODULE((*__pfnDliFailureHook)(dliFailLoadLib, &dli));
                }

            if (hmod == 0) {
                PDelayLoadInfo  pdli = &dli;

                RaiseException(
                    VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND),
                    0,
                    1,
                    PUINT_PTR(&pdli)
                    );
                
                // If we get to here, we blindly assume that the handler of the exception
                // has magically fixed everything up and left the function pointer in 
                // dli.pfnCur.
                //
                return dli.pfnCur;
                }
            }

        // Store the library handle.  If it is already there, we infer
        // that another thread got there first, and we need to do a
        // FreeLibrary() to reduce the refcount
        //
        HMODULE hmodT = HMODULE(::InterlockedExchange(LPLONG(pidd->phmod), LONG(hmod)));
        if (hmodT != hmod) {
            // add lib to unload list if we have unload data
            if (pidd->pUnloadIAT) {
                ULI *   puli = new ULI(pidd);
                (void *)puli;
                }
            }
        else {
            ::FreeLibrary(hmod);
            }
        
        }

    // Go for the procedure now.
    dli.hmodCur = hmod;
    {
        // Set preloaded information
        BOOL fByPass = FALSE;
        if (pidd->pBoundIAT && pidd->dwTimeStamp) {
            PIMAGE_NT_HEADERS pinh(PinhFromImageBase(hmod));
            if (pinh->Signature == IMAGE_NT_SIGNATURE &&
                TimeStampOfImage(pinh) == pidd->dwTimeStamp &&
                FLoadedAtPreferredAddress(pinh, hmod)) {
                
                OverlayIAT(pidd->pIAT, pidd->pBoundIAT);
                fByPass = TRUE;
            }
        }           
        
        FARPROC pfnFunction = NULL;
        PCImgThunkData pThunk;
        FARPROC *ppFunc;
        pThunk = pidd->pINT;
        ppFunc = (FARPROC*) &((pidd->pIAT)[0]);
    
        while(pThunk->u1.Ordinal != NULL) {
            if (dli.dlp.fImportByName = ((pThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) == 0)) {
#ifdef _WIN64
                dli.dlp.szProcName = LPCSTR(pThunk->u1.AddressOfData);
#else // !_WIN64
                dli.dlp.szProcName = LPCSTR(pThunk->u1.AddressOfData->Name);
#endif
            }
            else {
                dli.dlp.dwOrdinal = DWORD(IMAGE_ORDINAL(pThunk->u1.Ordinal));
            }
            
            if (__pfnDliNotifyHook) {
                pfnFunction = (*__pfnDliNotifyHook)(dliNotePreGetProcAddress, &dli);
            }
            if (pfnFunction == 0 && fByPass) {
                pfnFunction = *ppFunc;
            }
            else {
                pfnFunction = ::GetProcAddress(hmod, dli.dlp.szProcName);
            }
        
            if (pfnFunction == 0) {
                dli.dwLastError = ::GetLastError();
                if (__pfnDliFailureHook) {
                    // when the hook is called on GetProcAddress failure, it will
                    // return 0 on failure and a valid proc address on success
                    //
                    pfnFunction = (*__pfnDliFailureHook)(dliFailGetProc, &dli);
                }
                if (pfnFunction == 0) {
                    PDelayLoadInfo  pdli = &dli;
                    
                    RaiseException(
                                   VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND),
                                   0,
                                   1,
                                   PUINT_PTR(&pdli)
                                   );
                    
                    // If we get to here, we blindly assume that the handler of the exception
                    // has magically fixed everything up and left the function pointer in 
                    // dli.pfnCur.
                    //
                    pfnFunction = dli.pfnCur;
                }
            }

            *ppFunc = pfnFunction;
            if (__pfnDliNotifyHook) {
                dli.dwLastError = 0;
                dli.pfnCur = pfnFunction;
                (*__pfnDliNotifyHook)(dliNoteEndProcessing, &dli);
            }
            if(ppFunc == ppfnIATEntry) {
                pfnRet = pfnFunction;
            }
            ppFunc++;
            pThunk++;
        }
        return pfnRet;
    }

HookBypass:
    if (__pfnDliNotifyHook) {
        dli.dwLastError = 0;
        dli.hmodCur = hmod;
        dli.pfnCur = pfnRet;
        (*__pfnDliNotifyHook)(dliNoteEndProcessing, &dli);
        }
    return pfnRet;
}


#pragma intrinsic(strlen,memcmp,memcpy)

extern "C"
BOOL WINAPI
__FUnloadDelayLoadedDLL(LPCSTR szDll) {
    
    BOOL        fRet = FALSE;
    PUnloadInfo pui = __puiHead;
    
    for (pui = __puiHead; pui; pui = pui->puiNext) {
        if (memcmp(szDll, pui->pidd->szName, strlen(pui->pidd->szName)) == 0) {
            break;
            }
        }

    if (pui && pui->pidd->pUnloadIAT) {
        PCImgDelayDescr pidd = pui->pidd;
        HMODULE         hmod = *pidd->phmod;

        OverlayIAT(pidd->pIAT, pidd->pUnloadIAT);
        ::FreeLibrary(hmod);
        *pidd->phmod = NULL;
        
        delete reinterpret_cast<ULI*> (pui);

        fRet = TRUE;
        }

    return fRet;
    }

static inline
PIMAGE_NT_HEADERS WINAPI
PinhFromImageBase(HMODULE hmod) {
    return PIMAGE_NT_HEADERS(PCHAR(hmod) + PIMAGE_DOS_HEADER(hmod)->e_lfanew);
    }

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc) {
    memcpy(pitdDst, pitdSrc, CountOfImports(pitdDst) * sizeof IMAGE_THUNK_DATA);
    }

static inline
DWORD WINAPI
TimeStampOfImage(PIMAGE_NT_HEADERS pinh) {
    return pinh->FileHeader.TimeDateStamp;
    }

static inline
bool WINAPI
FLoadedAtPreferredAddress(PIMAGE_NT_HEADERS pinh, HMODULE hmod) {
    return DWORD(hmod) == pinh->OptionalHeader.ImageBase;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\makefile.inc ===
!if "$(LINKONLY)" == "1"

CopyAdditionalBits:
        copy /y mcxHandler.rgs $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)
        copy /y mcxHandler.rgs $(TARGETCOMPLUS)
        copy /y mcxHandler.rgm $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)
        copy /y mcxHandler.rgm $(TARGETCOMPLUS)
!else

CopyAdditionalBits:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\mcxhandler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// mcxHandler.h : Declaration of the CmcxHandler

#ifndef __mcxHandler_H_
#define __mcxHandler_H_
#include "shellapi.h"
#include "shlobj.h"
#include "shlguid.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CmcxHandler
class ATL_NO_VTABLE CmcxHandler : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CmcxHandler, &CLSID_mcxHandler>,
	public IDispatchImpl<ImcxHandler, &IID_ImcxHandler, &LIBID_mcxhndlrLib>,
	public CComControl<CmcxHandler>,
	public IPersistMoniker,
	public IOleObject,
	public IRunnableObjectImpl<CmcxHandler>,
	public IShellExecuteHook
{
public:
	CmcxHandler()
	{
		m_pszFileName=NULL;
		m_pszURL=NULL;
	}

	~CmcxHandler()
	{
		if (m_pszFileName)
			SysFreeString(m_pszFileName);
		if (m_pszURL)
			SysFreeString(m_pszURL);

	}
    BYTE  m_SecurityUniqueID[MAX_SIZE_SECURITY_ID]; //security id
	DWORD m_dwSUIDSize; //size of m_SecurityUniqueID
    DWORD m_dwINetZone; // internet zone
	LPOLESTR m_pszFileName; //downloaded file name
	LPOLESTR m_pszURL; //downloaded file name
	HRESULT m_hrLoad;  //hresult from processing moniker data

DECLARE_REGISTRY_RESOURCEID(IDR_mcxHandler)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CmcxHandler)
	COM_INTERFACE_ENTRY(ImcxHandler)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IPersistMoniker)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IRunnableObject)
	COM_INTERFACE_ENTRY_IID(IID_IShellExecuteHook,IShellExecuteHook)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CmcxHandler)
END_PROPERTY_MAP()


public:
// IPersistMoniker
	STDMETHOD(GetClassID)(CLSID *pClassID);
	STDMETHOD(IsDirty) (VOID );
	STDMETHOD(Load)	   (BOOL fFullyAvailable, IMoniker *pmkSrc, IBindCtx *pbc,DWORD grfMode);
	STDMETHOD(Save)(IMoniker *pmkDst,IBindCtx *pbc,BOOL fRemember);
	STDMETHOD(SaveCompleted )(IMoniker *pmkNew,IBindCtx *pbc);
	STDMETHOD(GetCurMoniker)(IMoniker **ppimkCur);
// IOleObject
	STDMETHOD(SetClientSite)(IOleClientSite* pClientSite);
	STDMETHOD(GetClientSite)(IOleClientSite** ppClientSite);
	STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp,LPCOLESTR szContainerObj);
	STDMETHOD(Close)(DWORD dwSaveOption);
	STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker* pMk);
	STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppMk);
	STDMETHOD(InitFromData)(IDataObject* pDataObject, BOOL fCreation, DWORD dwReserved);
	STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject** ppDataObject);
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite*pActiveSite,LONG lindex,HWND hwndParent, LPCRECT lprcPosRect);
	STDMETHOD(EnumVerbs)(IEnumOLEVERB** ppEnumOleVerb);
	STDMETHOD(Update)();
	STDMETHOD(IsUpToDate)();
	STDMETHOD(GetUserClassID)(CLSID* pClsid);
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR*pszUserType);
	STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL* psizel);
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL* psizel);
	STDMETHOD(Advise)(IAdviseSink* pAdvSink, DWORD* pdwConnection);
	STDMETHOD(Unadvise)(DWORD dwConnection);
	STDMETHOD(EnumAdvise )(IEnumSTATDATA** ppenumadvise);
	STDMETHOD(GetMiscStatus)(DWORD dwAspect,LPDWORD pdwStatus);
	STDMETHOD(SetColorScheme)(LOGPALETTE* pLogpal);
	
//IRunnableObject
	STDMETHOD(Run)(LPBINDCTX pbc);
//IShellExecute
	STDMETHOD(Execute) (LPSHELLEXECUTEINFO pei);

//We always will end here...
	static HANDLE RunAssembly(LPUTF8 szURL, LPUTF8 szZone, LPUTF8 szSite,LPCSTR szParameters);

	//////////////////
#define ToHex(val) val <= 9 ? val + '0': val - 10 + 'A'
    static DWORD ConvertToHex(WCHAR* strForm, BYTE* byteForm, DWORD dwSize)
    {
        DWORD i = 0;
        DWORD j = 0;
        for(i = 0; i < dwSize; i++) {
            strForm[j++] =  ToHex((0xf & byteForm[i]));
            strForm[j++] =  ToHex((0xf & (byteForm[i] >> 4)));
        }
        strForm[j] = L'\0';
        return j;
    }
	/////////////////
};


#endif //__mcxHandler_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\mcxhandler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// mcxHandler.cpp : Implementation of CmcxHandler
#include "stdpch.h"
#include "mcxhndlr.h"
#include "mcxHandler.h"
#include <process.h>
#include <shlobj.h>
#include <stdlib.h>
/////////////////////////////////////////////////////////////////////////////
// CmcxHandler
#define CORIESECURITY_ZONE             0x01
#define CORIESECURITY_SITE             0x02
#define IEEXEC_RUNASDLL		           0x100
#define IEEXEC_HASPARAMETERS           0x200



STDMETHODIMP CmcxHandler::GetClassID(CLSID *pClassID)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::IsDirty (VOID)
{
	return S_FALSE;
}

STDMETHODIMP CmcxHandler::Load(
    BOOL fFullyAvailable,
    IMoniker *pmkSrc,
    IBindCtx *pbc,
    DWORD grfMode
)
{
	if (m_pszURL)
	{
		LPMALLOC lpMalloc;
		if (!FAILED(CoGetMalloc(1,&lpMalloc)))
		{
			lpMalloc->Free(m_pszURL);
			lpMalloc->Release();
		}
		m_pszURL=NULL;
	}
	m_hrLoad=pmkSrc->GetDisplayName(pbc, NULL, &m_pszURL);
	if (Wszlstrcmpi(m_pszURL+wcslen(m_pszURL)-4,L".MCX")!=0)
		return E_UNEXPECTED ;
	if (FAILED(m_hrLoad)) return m_hrLoad;
	IInternetSecurityManager * pSecurityManager=NULL;
	m_hrLoad=CoInternetCreateSecurityManager(NULL,
                                                 &pSecurityManager,
                                                 0);
	if (FAILED(m_hrLoad)) 
		return m_hrLoad;    
	
	m_dwSUIDSize = MAX_SIZE_SECURITY_ID;

	DWORD flags = 0;
    m_hrLoad = pSecurityManager->MapUrlToZone(m_pszURL,&m_dwINetZone,flags);


    if(!FAILED(m_hrLoad)) 
	{
        m_hrLoad = pSecurityManager->GetSecurityId(m_pszURL,m_SecurityUniqueID,&m_dwSUIDSize,0);
	}
	pSecurityManager->Release();
	if (FAILED(m_hrLoad))
		return m_hrLoad;    
	return S_OK;
};

STDMETHODIMP CmcxHandler::Save(IMoniker *pmkDst, IBindCtx *pbc, BOOL fRemember)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::SaveCompleted(IMoniker *pmkNew, IBindCtx *pbc)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::GetCurMoniker(IMoniker **ppimkCur)
{
	return E_NOTIMPL;
}
STDMETHODIMP CmcxHandler::SetClientSite(IOleClientSite *pClientSite)
{
	m_spClientSite=pClientSite;
	return S_OK;
}

STDMETHODIMP CmcxHandler::GetClientSite(IOleClientSite **ppClientSite)
{
	return m_spClientSite->QueryInterface(IID_IOleClientSite,(LPVOID*)ppClientSite);
}

STDMETHODIMP CmcxHandler::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::Close(DWORD dwSaveOption)
{
	return S_OK;
}

STDMETHODIMP CmcxHandler::SetMoniker(DWORD dwWhichMoniker, IMoniker *pMk)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppMk)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::InitFromData(IDataObject *pDataObject, BOOL fCreation, DWORD dwReserved)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::GetClipboardData(DWORD dwReserved, IDataObject **ppDataObject)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
	if (iVerb!=0)
		return S_OK;	

  
    WCHAR dummy[MAX_SIZE_SECURITY_ID * 2 + 1];
    DWORD j = ConvertToHex(dummy, m_SecurityUniqueID, m_dwSUIDSize);

	MAKE_UTF8PTR_FROMWIDE(url, m_pszURL);

    CHAR zone[33];
    _itoa(m_dwINetZone, zone, 10);
    MAKE_UTF8PTR_FROMWIDE(site, dummy);

	HANDLE h=RunAssembly(url,zone,site,NULL);
	if (h!=INVALID_HANDLE_VALUE)
		WaitForSingleObject(h,INFINITE);
	return S_OK;
}

STDMETHODIMP CmcxHandler::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::Update()
{
	return S_OK;
}


STDMETHODIMP CmcxHandler::IsUpToDate()
{
	return S_OK;
}

STDMETHODIMP CmcxHandler::GetUserClassID(CLSID *pClsid)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	return S_OK;	
}

STDMETHODIMP CmcxHandler::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	return E_NOTIMPL;
}


STDMETHODIMP CmcxHandler::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::Unadvise(DWORD dwConnection)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::EnumAdvise(IEnumSTATDATA **ppenumadvise)
{
	return E_NOTIMPL;
}

STDMETHODIMP CmcxHandler::GetMiscStatus(DWORD dwAspect, LPDWORD pdwStatus)
{
	*pdwStatus=OLEMISC_SETCLIENTSITEFIRST|OLEMISC_INSIDEOUT|OLEMISC_STATIC|OLEMISC_INVISIBLEATRUNTIME|OLEMISC_ALWAYSRUN;
	return S_OK;
}

STDMETHODIMP CmcxHandler::SetColorScheme(LOGPALETTE *pLogpal)
{
	return E_NOTIMPL;
}

HANDLE _spawnlh(int reserved, LPCSTR program, LPCSTR arg0, ...)
{
	char s[MAX_PATH]={0};
	va_list vl;
	va_start(vl,program);
	LPCSTR sStr=va_arg(vl,LPCSTR);
	while (sStr)
	{
		if (strlen(s)+strlen(sStr)+2>MAX_PATH)
			break;
		strcat(s,sStr);
		strcat(s," ");
		sStr=va_arg(vl,LPCSTR);
	}
	va_end(vl);
	STARTUPINFO si={0};
	si.cb=sizeof(si);
	PROCESS_INFORMATION pi;

	BOOL z=CreateProcessA(program,s,NULL,NULL,TRUE,0,NULL,NULL/**/,&si,&pi);
	if(!z)
		return INVALID_HANDLE_VALUE;
	else 
		return pi.hProcess;

};


HANDLE CmcxHandler::RunAssembly(LPUTF8 szURL, LPUTF8 szZone, LPUTF8 szSite, LPCSTR szParameters)
{
    const CHAR pExec[] = "IEExec.exe";
	CHAR buffer[MAX_PATH];
    buffer[0] = '\0';
    DWORD length = GetModuleFileNameA(_Module.m_hInst, buffer, MAX_PATH);
    if(length) {
        CHAR* path = strrchr(buffer, '\\');
        if(path && (MAX_PATH - (path - buffer) + sizeof(pExec) < MAX_PATH)) {
            path++;
            strcpy(path, pExec);
        }
    }

    CHAR flags[33];
    DWORD dwFlags = IEEXEC_RUNASDLL;
	if (szZone)
		dwFlags|=CORIESECURITY_ZONE;
	if (szSite)
	dwFlags|=CORIESECURITY_SITE;
	if(szParameters)
		dwFlags|=IEEXEC_HASPARAMETERS;
	_itoa(dwFlags, flags, 10);
	HANDLE i;
	if (szZone)
		if (szSite)
			i = _spawnlh(_P_WAIT, buffer, buffer, szURL, flags, szZone, szSite, szParameters, NULL);
		else
			i = _spawnlh(_P_WAIT, buffer, buffer, szURL, flags, szZone, szParameters, NULL);
	else
		if (szSite)
			i = _spawnlh(_P_WAIT, buffer, buffer, szURL, flags, szSite, szParameters, NULL);
		else
			i = _spawnlh(_P_WAIT, buffer, buffer, szURL, flags, szParameters, NULL);

	return i;
}
 
STDMETHODIMP CmcxHandler::Run(LPBINDCTX pbc)
{
	LPMONIKER pimkName;
	m_spClientSite->GetMoniker(OLEGETMONIKER_FORCEASSIGN, OLEWHICHMK_CONTAINER, &pimkName);
	Load(FALSE,pimkName,pbc,0);
	DoVerb(0,NULL,m_spClientSite,-1,NULL,NULL);
	return S_OK;
}


STDMETHODIMP CmcxHandler::Execute (LPSHELLEXECUTEINFO pei)
{
	if (!pei||!pei->lpFile)
		return S_FALSE;

	if (PathIsURL(pei->lpFile)&&(strlen(pei->lpFile)<8||_strnicmp(pei->lpFile,"file://",7)!=0))
		return S_FALSE;

	char sFullFileName[MAX_PATH*2];

	if (!PathIsURL(pei->lpFile)&&PathIsRelative(pei->lpFile))
	{
		char sCurDir[MAX_PATH+1];
		if (pei->lpDirectory!=NULL)
			strcpy(sCurDir,pei->lpDirectory);
		else
			if(!GetCurrentDirectoryA(MAX_PATH+1,sCurDir))
				return E_UNEXPECTED;

		PathCombine(sFullFileName,sCurDir,pei->lpFile);
	}
	else
		strcpy(sFullFileName,pei->lpFile);

	LPCSTR sExt = sFullFileName+strlen(sFullFileName)-4;
	if (sExt>sFullFileName && _stricmp(sExt,".mcx")==0)
	{
		DWORD newlen=strlen(sFullFileName)*4;
		char * sResStr=new char[newlen]  ;
		if (sResStr==NULL)
			return E_OUTOFMEMORY;
		UrlCanonicalize(sFullFileName,sResStr,&newlen,URL_ESCAPE_UNSAFE);
		MAKE_WIDEPTR_FROMANSI(wstr,sResStr);
		MAKE_UTF8PTR_FROMWIDE(utfstr,wstr);
		delete[] sResStr;
		pei->hProcess = CmcxHandler::RunAssembly(utfstr,NULL,NULL,pei->lpParameters); 
		pei->hInstApp=(HINSTANCE)64;
		return S_OK;
	}
	else
		return S_FALSE;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\delayimp\delayimp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// DelayImp.h
//
//  define structures and prototypes necessary for delay loading of imports
//
#pragma once
#if !defined(_delayimp_h)
#define _delayimp_h

#if defined(__cplusplus)
#define ExternC extern "C"
#else
#define ExternC
#endif

typedef IMAGE_THUNK_DATA *          PImgThunkData;
typedef const IMAGE_THUNK_DATA *    PCImgThunkData;

typedef struct ImgDelayDescr {
    DWORD           grAttrs;        // attributes
    LPCSTR          szName;         // pointer to dll name
    HMODULE *       phmod;          // address of module handle
    PImgThunkData   pIAT;           // address of the IAT
    PCImgThunkData  pINT;           // address of the INT
    PCImgThunkData  pBoundIAT;      // address of the optional bound IAT
    PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT
    DWORD           dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescr, * PImgDelayDescr;

typedef const ImgDelayDescr *   PCImgDelayDescr;

//
// Delay load import hook notifications
//
enum {
    dliStartProcessing,             // used to bypass or note helper only
    dliNotePreLoadLibrary,          // called just before LoadLibrary, can
                                    //  override w/ new HMODULE return val
    dliNotePreGetProcAddress,       // called just before GetProcAddress, can
                                    //  override w/ new FARPROC return value
    dliFailLoadLib,                 // failed to load library, fix it by
                                    //  returning a valid HMODULE
    dliFailGetProc,                 // failed to get proc address, fix it by
                                    //  returning a valid FARPROC
    dliNoteEndProcessing,           // called after all processing is done, no
                                    //  no bypass possible at this point except
                                    //  by longjmp()/throw()/RaiseException.
    };

typedef struct DelayLoadProc {
    BOOL                fImportByName;
    union {
        LPCSTR          szProcName;
        DWORD           dwOrdinal;
        };
    } DelayLoadProc;

typedef struct DelayLoadInfo {
    DWORD               cb;         // size of structure
    PCImgDelayDescr     pidd;       // raw form of data (everything is there)
    FARPROC *           ppfn;       // points to address of function to load
    LPCSTR              szDll;      // name of dll
    DelayLoadProc       dlp;        // name or ordinal of procedure
    HMODULE             hmodCur;    // the hInstance of the library we have loaded
    FARPROC             pfnCur;     // the actual function that will be called
    DWORD               dwLastError;// error received (if an error notification)
    } DelayLoadInfo, * PDelayLoadInfo;

typedef FARPROC (WINAPI *PfnDliHook)(
    unsigned        dliNotify,
    PDelayLoadInfo  pdli
    );

// utility function for calculating the index of the current import
// for all the tables (INT, BIAT, UIAT, and IAT).
__inline unsigned
IndexFromPImgThunkData(PCImgThunkData pitdCur, PCImgThunkData pitdBase) {
    return unsigned(pitdCur - pitdBase);
    }

//
// Unload support
//

// routine definition; takes a pointer to a name to unload, or NULL to
// unload all the delay load dlls in the list.
//
ExternC
BOOL WINAPI
__FUnloadDelayLoadedDLL(LPCSTR szDll);

// structure definitions for the list of unload records
typedef struct UnloadInfo * PUnloadInfo;
typedef struct UnloadInfo {
    PUnloadInfo     puiNext;
    PCImgDelayDescr pidd;
    } UnloadInfo;

// the default delay load helper places the unloadinfo records in the list
// headed by the following pointer.
ExternC
extern
PUnloadInfo __puiHead;

//
// Exception information
//
#define FACILITY_VISUALCPP  ((LONG)0x6d)
#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

// utility function for calculating the count of imports given the base
// of the IAT.  NB: this only works on a valid IAT!
__inline unsigned
CountOfImports(PCImgThunkData pitdBase) {
    unsigned        cRet = 0;
    PCImgThunkData  pitd = pitdBase;
    while (pitd->u1.Function) {
        pitd++;
        cRet++;
        }
    return cRet;
    }

//
// Hook pointers
//

// The "notify hook" gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == {
//  dliStartProcessing |
//  dliPreLoadLibrary  |
//  dliPreGetProc |
//  dliNoteEndProcessing}
//  on this call.
//
ExternC
extern
PfnDliHook   __pfnDliNotifyHook;

// This is the failure hook, dliNotify = {dliFailLoadLib|dliFailGetProc}
ExternC
extern
PfnDliHook   __pfnDliFailureHook;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\delayimp\delayimp2.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// DelayImp.h
//
//  define structures and prototypes necessary for delay loading of imports
//
#pragma once
#if !defined(_delayimp_h)
#define _delayimp_h

#if defined(_DELAY_IMP_VER)
#undef _DELAY_IMP_VER
#endif

#define _DELAY_IMP_VER  2

#if defined(__cplusplus)
#define ExternC extern "C"
#else
#define ExternC
#endif

typedef IMAGE_THUNK_DATA *          PImgThunkData;
typedef const IMAGE_THUNK_DATA *    PCImgThunkData;
typedef DWORD                       RVA;

typedef struct ImgDelayDescr {
    DWORD           grAttrs;        // attributes
    RVA             rvaDLLName;     // RVA to dll name
    RVA             rvaHmod;        // RVA of module handle
    RVA             rvaIAT;         // RVA of the IAT
    RVA             rvaINT;         // RVA of the INT
    RVA             rvaBoundIAT;    // RVA of the optional bound IAT
    RVA             rvaUnloadIAT;   // RVA of optional copy of original IAT
    DWORD           dwTimeStamp;    // 0 if not bound,
                                    // O.W. date/time stamp of DLL bound to (Old BIND)
    } ImgDelayDescr, * PImgDelayDescr;

typedef const ImgDelayDescr *   PCImgDelayDescr;

enum DLAttr {                   // Delay Load Attributes
    dlattrRva = 0x1,                // RVAs are used instead of pointers
    };

//
// Delay load import hook notifications
//
enum {
    dliStartProcessing,             // used to bypass or note helper only
    dliNotePreLoadLibrary,          // called just before LoadLibrary, can
                                    //  override w/ new HMODULE return val
    dliNotePreGetProcAddress,       // called just before GetProcAddress, can
                                    //  override w/ new FARPROC return value
    dliFailLoadLib,                 // failed to load library, fix it by
                                    //  returning a valid HMODULE
    dliFailGetProc,                 // failed to get proc address, fix it by
                                    //  returning a valid FARPROC
    dliNoteEndProcessing,           // called after all processing is done, no
                                    //  no bypass possible at this point except
                                    //  by longjmp()/throw()/RaiseException.
    };

typedef struct DelayLoadProc {
    BOOL                fImportByName;
    union {
        LPCSTR          szProcName;
        DWORD           dwOrdinal;
        };
    } DelayLoadProc;

typedef struct DelayLoadInfo {
    DWORD               cb;         // size of structure
    PCImgDelayDescr     pidd;       // raw form of data (everything is there)
    FARPROC *           ppfn;       // points to address of function to load
    LPCSTR              szDll;      // name of dll
    DelayLoadProc       dlp;        // name or ordinal of procedure
    HMODULE             hmodCur;    // the hInstance of the library we have loaded
    FARPROC             pfnCur;     // the actual function that will be called
    DWORD               dwLastError;// error received (if an error notification)
    } DelayLoadInfo, * PDelayLoadInfo;

typedef FARPROC (WINAPI *PfnDliHook)(
    unsigned        dliNotify,
    PDelayLoadInfo  pdli
    );

// utility function for calculating the index of the current import
// for all the tables (INT, BIAT, UIAT, and IAT).
__inline unsigned
IndexFromPImgThunkData(PCImgThunkData pitdCur, PCImgThunkData pitdBase) {
    return (unsigned) (pitdCur - pitdBase);
    }

// C++ template utility function for converting RVAs to pointers
//
#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
ExternC
__declspec(allocate(".base"))
extern
IMAGE_DOS_HEADER __ImageBase;
#else
ExternC
extern
IMAGE_DOS_HEADER __ImageBase;
#endif

#if defined(__cplusplus)
template <class X>
X * PFromRva(RVA rva, const X *) {
    return (X*)(PBYTE(&__ImageBase) + rva);
    }
#else
__inline
void *
WINAPI
PFromRva(RVA rva, void *unused) {
    return (PVOID)(&__ImageBase + rva);
    }
#endif

//
// Unload support
//

// routine definition; takes a pointer to a name to unload
//
ExternC
BOOL WINAPI
__FUnloadDelayLoadedDLL2(LPCSTR szDll);

// structure definitions for the list of unload records
typedef struct UnloadInfo * PUnloadInfo;
typedef struct UnloadInfo {
    PUnloadInfo     puiNext;
    PCImgDelayDescr pidd;
    } UnloadInfo;

// the default delay load helper places the unloadinfo records in the list
// headed by the following pointer.
ExternC
extern
PUnloadInfo __puiHead;

//
// Exception information
//
#define FACILITY_VISUALCPP  ((LONG)0x6d)
#define VcppException(sev,err)  ((sev) | (FACILITY_VISUALCPP<<16) | err)

// utility function for calculating the count of imports given the base
// of the IAT.  NB: this only works on a valid IAT!
__inline unsigned
CountOfImports(PCImgThunkData pitdBase) {
    unsigned        cRet = 0;
    PCImgThunkData  pitd = pitdBase;
    while (pitd->u1.Function) {
        pitd++;
        cRet++;
        }
    return cRet;
    }

//
// Hook pointers
//

// The "notify hook" gets called for every call to the
// delay load helper.  This allows a user to hook every call and
// skip the delay load helper entirely.
//
// dliNotify == {
//  dliStartProcessing |
//  dliPreLoadLibrary  |
//  dliPreGetProc |
//  dliNoteEndProcessing}
//  on this call.
//
ExternC
extern
PfnDliHook   __pfnDliNotifyHook;

ExternC
extern
PfnDliHook   __pfnDliNotifyHook2;

// This is the failure hook, dliNotify = {dliFailLoadLib|dliFailGetProc}
ExternC
extern
PfnDliHook   __pfnDliFailureHook;

ExternC
extern
PfnDliHook   __pfnDliFailureHook2;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define IDR_mcxHandler                101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdpch.cpp : source file that includes just the standard includes

#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "mcxhndlr.dll"
#define VER_FILEDESCRIPTION_STR "ActiveX for mcx files\0"
#define VER_ORIGFILENAME_STR    "mcxhndlr.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\mcxhndlr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// mcxhndlr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f mcxhndlrps.mk in the project directory.

#include "stdpch.h"
#include <initguid.h>
#include "mcxhndlr.h"

#include "mcxhndlr_i.c"
#include "mcxHandler.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_mcxHandler, CmcxHandler)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_mcxhndlrLib);
		OnUnicodeSystem();
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}


void CALLBACK RunDotCom(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
	if (!lpszCmdLine)
		return;

	LPSTR lpszCL=(LPSTR) alloca(strlen(lpszCmdLine)+1);
	strcpy(lpszCL,lpszCmdLine);
	LPSTR lpszPar=strchr(lpszCL,' ');
	if (lpszPar)
		lpszPar++[0]='\0';

	DWORD newlen=strlen(lpszCL)*4;
	char * sResStr=new char[newlen]  ;
	if (sResStr==NULL)
		return;
	UrlCanonicalize(lpszCL,sResStr,&newlen,URL_ESCAPE_UNSAFE);

	MAKE_WIDEPTR_FROMANSI(wstr,sResStr);
	MAKE_UTF8PTR_FROMWIDE(utfstr,wstr);
	delete[] sResStr;
	CmcxHandler::RunAssembly(utfstr,NULL,NULL,lpszPar); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdpch.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDPCH_H__F417431A_CFF9_42F7_809F_F83D337BA6CF__INCLUDED_)
#define AFX_STDPCH_H__F417431A_CFF9_42F7_809F_F83D337BA6CF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _WINGDI_

//#include <winver.h>
#ifdef UNICODE
#error Not an UNICODE application: supposed to work only under Win32
#endif

#include "ATL/atlbase.h"
extern CComModule _Module;
#include "ATL/atlcom.h"
#include "ATL/atlctl.h"

#include "WinWrap.h"



typedef LPSTR   LPUTF8;

#define MAKE_UTF8PTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (long)((wcslen(widestr) + 1) * 2 * sizeof(char)); \
    LPUTF8 ptrname = (LPUTF8)alloca(__l##ptrname); \
    INT32 __lresult##ptrname=WszWideCharToMultiByte(CP_UTF8, 0, widestr, -1, ptrname, __l##ptrname-1, NULL, NULL); \
    if (__lresult##ptrname==0 && ::GetLastError()==ERROR_INSUFFICIENT_BUFFER) { \
       INT32 __lsize##ptrname=WszWideCharToMultiByte(CP_UTF8, 0, widestr, -1, NULL, 0, NULL, NULL); \
       ptrname = (LPSTR)alloca(__lsize##ptrname); \
       WszWideCharToMultiByte(CP_UTF8, 0, widestr, -1, ptrname, __lsize##ptrname, NULL, NULL);\
    }


#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname; \
    LPWSTR ptrname;	\
    __l##ptrname = WszMultiByteToWideChar(CP_ACP, 0, ansistr, -1, 0, 0); \
	ptrname = (LPWSTR) alloca(__l##ptrname*sizeof(WCHAR));	\
    WszMultiByteToWideChar(CP_ACP, 0, ansistr, -1, ptrname, __l##ptrname);

#endif // !defined(AFX_STDPCH_H__F417431A_CFF9_42F7_809F_F83D337BA6CF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\atl\atlbase.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Active Template Library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4268) // const static/global data initialized to zeros
#pragma warning(disable: 4291) // allow placement new
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include "atldef.h"

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <comcat.h>
#include <stddef.h>

#ifdef new
#pragma push_macro("new")
#define _ATL_REDEF_NEW
#undef new
#endif

#include <tchar.h>
#include <malloc.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

#include <shlwapi.h>

#pragma pack(push, _ATL_PACKING)

#if defined(_ATL_DLL)
	#pragma comment(lib, "atl.lib")
#endif

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = {0xb6ea2050,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = {0xb6ea2051,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IInternalConnection = {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD dw);

struct _ATL_TERMFUNC_ELEM
{
	_ATL_TERMFUNC* pFunc;
	DWORD dw;
	_ATL_TERMFUNC_ELEM* pNext;
};

struct _ATL_OBJMAP_ENTRY
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
	_ATL_CATMAPFUNC* pfnGetCategoryMap;
	HRESULT WINAPI RevokeClassObject()
	{
		return CoRevokeClassObject(dwRegister);
	}
	HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
	{
		IUnknown* p = NULL;
		if (pfnGetClassObject == NULL)
			return S_OK;
		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
		if (SUCCEEDED(hRes))
			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
		if (p != NULL)
			p->Release();
		return hRes;
	}
// Added in ATL 3.0
	void (WINAPI *pfnObjectMain)(bool bStarting);
};

struct _ATL_REGMAP_ENTRY
{
	LPCOLESTR     szKey;
	LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
	void* m_pThis;
	DWORD m_dwThreadID;
	_AtlCreateWndData* m_pNext;
};

struct _ATL_MODULE
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	union
	{
		CRITICAL_SECTION m_csTypeInfoHolder;
		CRITICAL_SECTION m_csStaticDataInit;
	};
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
	DWORD dwAtlBuildVer;
	_AtlCreateWndData* m_pCreateWndList;
	bool m_bDestroyHeap;
	GUID* pguidVer;
	DWORD m_dwHeaps;    // Number of heaps we have (-1)
	HANDLE* m_phHeaps;
	int m_nHeap;        // Which heap to choose from
	_ATL_TERMFUNC_ELEM* m_pTermFuncs;
};

const int _nAtlModuleVer1Size = 100;

//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	DWORD dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(IStream* pStream);
ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
	DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
	HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI_(DWORD) AtlGetVersion(void* pReserved);
ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject);
ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM);
ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD dw);


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

namespace ATL
{

enum atlTraceFlags
{
	// Application defined categories
	atlTraceUser        = 0x00000001,
	atlTraceUser2       = 0x00000002,
	atlTraceUser3       = 0x00000004,
	atlTraceUser4       = 0x00000008,
	// ATL defined categories
	atlTraceGeneral     = 0x00000020,
	atlTraceCOM         = 0x00000040,
	atlTraceQI      = 0x00000080,
	atlTraceRegistrar   = 0x00000100,
	atlTraceRefcount    = 0x00000200,
	atlTraceWindowing   = 0x00000400,
	atlTraceControls    = 0x00000800,
	atlTraceHosting     = 0x00001000,
	atlTraceDBClient    = 0x00002000,
	atlTraceDBProvider  = 0x00004000,
	atlTraceSnapin      = 0x00008000,
	atlTraceNotImpl     = 0x00010000,
};

#ifndef ATL_TRACE_CATEGORY
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#endif

#ifdef _DEBUG

#ifndef ATL_TRACE_LEVEL
#define ATL_TRACE_LEVEL 0
#endif

inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
	if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		char szBuffer[512];

		nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringA("ATL: ");
		OutputDebugStringA(szBuffer);
		va_end(args);
	}
}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
	ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringW(szBuffer);
	va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
	if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		WCHAR szBuffer[512];

		nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
		ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringW(L"ATL: ");
		OutputDebugStringW(szBuffer);
		va_end(args);
	}
}
#endif //!OLE2ANSI


#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#define ATLTRACE2           AtlTrace2
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE2(atlTraceNotImpl, 2, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACE2           1 ? (void)0 : AtlTrace2
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG





/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "olepro32.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")

static HRESULT AtlSetChildSite(IUnknown* punkChild, IUnknown* punkParent)
{
	if (punkChild == NULL)
		return E_POINTER;

	HRESULT hr;
	IObjectWithSite* pChildSite = NULL;
	hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
	if (SUCCEEDED(hr) && pChildSite != NULL)
	{
		hr = pChildSite->SetSite(punkParent);
		pChildSite->Release();
	}
	return hr;
}

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
	private:
		STDMETHOD_(ULONG, AddRef)()=0;
		STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr()
	{
		p=NULL;
	}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return (T*)p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp) const
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	T* p;
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CComQIPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL); return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComQIPtr<T,piid>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	T* operator=(IUnknown* lp)
	{
		return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp)
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	T* p;
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown>
{
public:
	typedef IUnknown _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(IUnknown* lp)
	{
		//Actually do a QI to get identity
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IUnknown, (void **)&p);
	}
	CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComQIPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator IUnknown*() const
	{
		return p;
	}
	IUnknown& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	IUnknown** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	IUnknown* operator=(IUnknown* lp)
	{
		//Actually do a QI to get identity
		return (IUnknown*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
	}
	IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
	{
		return (IUnknown*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(IUnknown* pT) const
	{
		return p < pT;
	}
	bool operator==(IUnknown* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	IUnknown* Detach()
	{
		IUnknown* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp)
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	IUnknown* p;
};

#define com_cast CComQIPtr

/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
	CAdapt()
	{
	}
	CAdapt(const T& rSrc)
	{
		m_T = rSrc;
	}

	CAdapt(const CAdapt& rSrCA)
	{
		m_T = rSrCA.m_T;
	}

	CAdapt& operator=(const T& rSrc)
	{
		m_T = rSrc;
		return *this;
	}
	bool operator<(const T& rSrc) const
	{
		return m_T < rSrc;
	}
	bool operator==(const T& rSrc) const
	{
		return m_T == rSrc;
	}
	operator T&()
	{
		return m_T;
	}

	operator const T&() const
	{
		return m_T;
	}

	T m_T;
};

/////////////////////////////////////////////////////////////////////////////
// GUID comparison

inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
	  ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
	  ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
	  ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
	  ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
	  ((PLONG) &rguid1)[3] == 0x00000046);
#else
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	void Init() {InitializeCriticalSection(&m_sec);}
	void Term() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
	~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
	void Lock() {}
	void Unlock() {}
	void Init() {}
	void Term() {}
};

class CComMultiThreadModelNoCS
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
	static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComSingleThreadModel ThreadModelNoCS;
};

#if defined(_ATL_SINGLE_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);

#ifdef _ATL_DEBUG_INTERFACES
struct _QIThunk
{
	STDMETHOD(QueryInterface)(REFIID iid, void** pp)
	{
		ATLASSERT(m_dwRef >= 0);
		return pUnk->QueryInterface(iid, pp);
	}
	STDMETHOD_(ULONG, AddRef)()
	{
		if (bBreak)
			DebugBreak();
		pUnk->AddRef();
		return InternalAddRef();
	}
	ULONG InternalAddRef()
	{
		if (bBreak)
			DebugBreak();
		ATLASSERT(m_dwRef >= 0);
		long l = InterlockedIncrement(&m_dwRef);
		ATLTRACE(_T("%d> "), m_dwRef);
		AtlDumpIID(iid, lpszClassName, S_OK);
		if (l > m_dwMaxRef)
			m_dwMaxRef = l;
		return l;
	}
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(f3)();
	STDMETHOD(f4)();
	STDMETHOD(f5)();
	STDMETHOD(f6)();
	STDMETHOD(f7)();
	STDMETHOD(f8)();
	STDMETHOD(f9)();
	STDMETHOD(f10)();
	STDMETHOD(f11)();
	STDMETHOD(f12)();
	STDMETHOD(f13)();
	STDMETHOD(f14)();
	STDMETHOD(f15)();
	STDMETHOD(f16)();
	STDMETHOD(f17)();
	STDMETHOD(f18)();
	STDMETHOD(f19)();
	STDMETHOD(f20)();
	STDMETHOD(f21)();
	STDMETHOD(f22)();
	STDMETHOD(f23)();
	STDMETHOD(f24)();
	STDMETHOD(f25)();
	STDMETHOD(f26)();
	STDMETHOD(f27)();
	STDMETHOD(f28)();
	STDMETHOD(f29)();
	STDMETHOD(f30)();
	STDMETHOD(f31)();
	STDMETHOD(f32)();
	STDMETHOD(f33)();
	STDMETHOD(f34)();
	STDMETHOD(f35)();
	STDMETHOD(f36)();
	STDMETHOD(f37)();
	STDMETHOD(f38)();
	STDMETHOD(f39)();
	STDMETHOD(f40)();
	STDMETHOD(f41)();
	STDMETHOD(f42)();
	STDMETHOD(f43)();
	STDMETHOD(f44)();
	STDMETHOD(f45)();
	STDMETHOD(f46)();
	STDMETHOD(f47)();
	STDMETHOD(f48)();
	STDMETHOD(f49)();
	STDMETHOD(f50)();
	STDMETHOD(f51)();
	STDMETHOD(f52)();
	STDMETHOD(f53)();
	STDMETHOD(f54)();
	STDMETHOD(f55)();
	STDMETHOD(f56)();
	STDMETHOD(f57)();
	STDMETHOD(f58)();
	STDMETHOD(f59)();
	STDMETHOD(f60)();
	STDMETHOD(f61)();
	STDMETHOD(f62)();
	STDMETHOD(f63)();
	STDMETHOD(f64)();
	STDMETHOD(f65)();
	STDMETHOD(f66)();
	STDMETHOD(f67)();
	STDMETHOD(f68)();
	STDMETHOD(f69)();
	STDMETHOD(f70)();
	STDMETHOD(f71)();
	STDMETHOD(f72)();
	STDMETHOD(f73)();
	STDMETHOD(f74)();
	STDMETHOD(f75)();
	STDMETHOD(f76)();
	STDMETHOD(f77)();
	STDMETHOD(f78)();
	STDMETHOD(f79)();
	STDMETHOD(f80)();
	STDMETHOD(f81)();
	STDMETHOD(f82)();
	STDMETHOD(f83)();
	STDMETHOD(f84)();
	STDMETHOD(f85)();
	STDMETHOD(f86)();
	STDMETHOD(f87)();
	STDMETHOD(f88)();
	STDMETHOD(f89)();
	STDMETHOD(f90)();
	STDMETHOD(f91)();
	STDMETHOD(f92)();
	STDMETHOD(f93)();
	STDMETHOD(f94)();
	STDMETHOD(f95)();
	STDMETHOD(f96)();
	STDMETHOD(f97)();
	STDMETHOD(f98)();
	STDMETHOD(f99)();
	STDMETHOD(f100)();
	STDMETHOD(f101)();
	STDMETHOD(f102)();
	STDMETHOD(f103)();
	STDMETHOD(f104)();
	STDMETHOD(f105)();
	STDMETHOD(f106)();
	STDMETHOD(f107)();
	STDMETHOD(f108)();
	STDMETHOD(f109)();
	STDMETHOD(f110)();
	STDMETHOD(f111)();
	STDMETHOD(f112)();
	STDMETHOD(f113)();
	STDMETHOD(f114)();
	STDMETHOD(f115)();
	STDMETHOD(f116)();
	STDMETHOD(f117)();
	STDMETHOD(f118)();
	STDMETHOD(f119)();
	STDMETHOD(f120)();
	STDMETHOD(f121)();
	STDMETHOD(f122)();
	STDMETHOD(f123)();
	STDMETHOD(f124)();
	STDMETHOD(f125)();
	STDMETHOD(f126)();
	STDMETHOD(f127)();
	STDMETHOD(f128)();
	STDMETHOD(f129)();
	STDMETHOD(f130)();
	STDMETHOD(f131)();
	STDMETHOD(f132)();
	STDMETHOD(f133)();
	STDMETHOD(f134)();
	STDMETHOD(f135)();
	STDMETHOD(f136)();
	STDMETHOD(f137)();
	STDMETHOD(f138)();
	STDMETHOD(f139)();
	STDMETHOD(f140)();
	STDMETHOD(f141)();
	STDMETHOD(f142)();
	STDMETHOD(f143)();
	STDMETHOD(f144)();
	STDMETHOD(f145)();
	STDMETHOD(f146)();
	STDMETHOD(f147)();
	STDMETHOD(f148)();
	STDMETHOD(f149)();
	STDMETHOD(f150)();
	STDMETHOD(f151)();
	STDMETHOD(f152)();
	STDMETHOD(f153)();
	STDMETHOD(f154)();
	STDMETHOD(f155)();
	STDMETHOD(f156)();
	STDMETHOD(f157)();
	STDMETHOD(f158)();
	STDMETHOD(f159)();
	STDMETHOD(f160)();
	STDMETHOD(f161)();
	STDMETHOD(f162)();
	STDMETHOD(f163)();
	STDMETHOD(f164)();
	STDMETHOD(f165)();
	STDMETHOD(f166)();
	STDMETHOD(f167)();
	STDMETHOD(f168)();
	STDMETHOD(f169)();
	STDMETHOD(f170)();
	STDMETHOD(f171)();
	STDMETHOD(f172)();
	STDMETHOD(f173)();
	STDMETHOD(f174)();
	STDMETHOD(f175)();
	STDMETHOD(f176)();
	STDMETHOD(f177)();
	STDMETHOD(f178)();
	STDMETHOD(f179)();
	STDMETHOD(f180)();
	STDMETHOD(f181)();
	STDMETHOD(f182)();
	STDMETHOD(f183)();
	STDMETHOD(f184)();
	STDMETHOD(f185)();
	STDMETHOD(f186)();
	STDMETHOD(f187)();
	STDMETHOD(f188)();
	STDMETHOD(f189)();
	STDMETHOD(f190)();
	STDMETHOD(f191)();
	STDMETHOD(f192)();
	STDMETHOD(f193)();
	STDMETHOD(f194)();
	STDMETHOD(f195)();
	STDMETHOD(f196)();
	STDMETHOD(f197)();
	STDMETHOD(f198)();
	STDMETHOD(f199)();
	STDMETHOD(f200)();
	STDMETHOD(f201)();
	STDMETHOD(f202)();
	STDMETHOD(f203)();
	STDMETHOD(f204)();
	STDMETHOD(f205)();
	STDMETHOD(f206)();
	STDMETHOD(f207)();
	STDMETHOD(f208)();
	STDMETHOD(f209)();
	STDMETHOD(f210)();
	STDMETHOD(f211)();
	STDMETHOD(f212)();
	STDMETHOD(f213)();
	STDMETHOD(f214)();
	STDMETHOD(f215)();
	STDMETHOD(f216)();
	STDMETHOD(f217)();
	STDMETHOD(f218)();
	STDMETHOD(f219)();
	STDMETHOD(f220)();
	STDMETHOD(f221)();
	STDMETHOD(f222)();
	STDMETHOD(f223)();
	STDMETHOD(f224)();
	STDMETHOD(f225)();
	STDMETHOD(f226)();
	STDMETHOD(f227)();
	STDMETHOD(f228)();
	STDMETHOD(f229)();
	STDMETHOD(f230)();
	STDMETHOD(f231)();
	STDMETHOD(f232)();
	STDMETHOD(f233)();
	STDMETHOD(f234)();
	STDMETHOD(f235)();
	STDMETHOD(f236)();
	STDMETHOD(f237)();
	STDMETHOD(f238)();
	STDMETHOD(f239)();
	STDMETHOD(f240)();
	STDMETHOD(f241)();
	STDMETHOD(f242)();
	STDMETHOD(f243)();
	STDMETHOD(f244)();
	STDMETHOD(f245)();
	STDMETHOD(f246)();
	STDMETHOD(f247)();
	STDMETHOD(f248)();
	STDMETHOD(f249)();
	STDMETHOD(f250)();
	STDMETHOD(f251)();
	STDMETHOD(f252)();
	STDMETHOD(f253)();
	STDMETHOD(f254)();
	STDMETHOD(f255)();
	STDMETHOD(f256)();
	STDMETHOD(f257)();
	STDMETHOD(f258)();
	STDMETHOD(f259)();
	STDMETHOD(f260)();
	STDMETHOD(f261)();
	STDMETHOD(f262)();
	STDMETHOD(f263)();
	STDMETHOD(f264)();
	STDMETHOD(f265)();
	STDMETHOD(f266)();
	STDMETHOD(f267)();
	STDMETHOD(f268)();
	STDMETHOD(f269)();
	STDMETHOD(f270)();
	STDMETHOD(f271)();
	STDMETHOD(f272)();
	STDMETHOD(f273)();
	STDMETHOD(f274)();
	STDMETHOD(f275)();
	STDMETHOD(f276)();
	STDMETHOD(f277)();
	STDMETHOD(f278)();
	STDMETHOD(f279)();
	STDMETHOD(f280)();
	STDMETHOD(f281)();
	STDMETHOD(f282)();
	STDMETHOD(f283)();
	STDMETHOD(f284)();
	STDMETHOD(f285)();
	STDMETHOD(f286)();
	STDMETHOD(f287)();
	STDMETHOD(f288)();
	STDMETHOD(f289)();
	STDMETHOD(f290)();
	STDMETHOD(f291)();
	STDMETHOD(f292)();
	STDMETHOD(f293)();
	STDMETHOD(f294)();
	STDMETHOD(f295)();
	STDMETHOD(f296)();
	STDMETHOD(f297)();
	STDMETHOD(f298)();
	STDMETHOD(f299)();
	STDMETHOD(f300)();
	STDMETHOD(f301)();
	STDMETHOD(f302)();
	STDMETHOD(f303)();
	STDMETHOD(f304)();
	STDMETHOD(f305)();
	STDMETHOD(f306)();
	STDMETHOD(f307)();
	STDMETHOD(f308)();
	STDMETHOD(f309)();
	STDMETHOD(f310)();
	STDMETHOD(f311)();
	STDMETHOD(f312)();
	STDMETHOD(f313)();
	STDMETHOD(f314)();
	STDMETHOD(f315)();
	STDMETHOD(f316)();
	STDMETHOD(f317)();
	STDMETHOD(f318)();
	STDMETHOD(f319)();
	STDMETHOD(f320)();
	STDMETHOD(f321)();
	STDMETHOD(f322)();
	STDMETHOD(f323)();
	STDMETHOD(f324)();
	STDMETHOD(f325)();
	STDMETHOD(f326)();
	STDMETHOD(f327)();
	STDMETHOD(f328)();
	STDMETHOD(f329)();
	STDMETHOD(f330)();
	STDMETHOD(f331)();
	STDMETHOD(f332)();
	STDMETHOD(f333)();
	STDMETHOD(f334)();
	STDMETHOD(f335)();
	STDMETHOD(f336)();
	STDMETHOD(f337)();
	STDMETHOD(f338)();
	STDMETHOD(f339)();
	STDMETHOD(f340)();
	STDMETHOD(f341)();
	STDMETHOD(f342)();
	STDMETHOD(f343)();
	STDMETHOD(f344)();
	STDMETHOD(f345)();
	STDMETHOD(f346)();
	STDMETHOD(f347)();
	STDMETHOD(f348)();
	STDMETHOD(f349)();
	STDMETHOD(f350)();
	STDMETHOD(f351)();
	STDMETHOD(f352)();
	STDMETHOD(f353)();
	STDMETHOD(f354)();
	STDMETHOD(f355)();
	STDMETHOD(f356)();
	STDMETHOD(f357)();
	STDMETHOD(f358)();
	STDMETHOD(f359)();
	STDMETHOD(f360)();
	STDMETHOD(f361)();
	STDMETHOD(f362)();
	STDMETHOD(f363)();
	STDMETHOD(f364)();
	STDMETHOD(f365)();
	STDMETHOD(f366)();
	STDMETHOD(f367)();
	STDMETHOD(f368)();
	STDMETHOD(f369)();
	STDMETHOD(f370)();
	STDMETHOD(f371)();
	STDMETHOD(f372)();
	STDMETHOD(f373)();
	STDMETHOD(f374)();
	STDMETHOD(f375)();
	STDMETHOD(f376)();
	STDMETHOD(f377)();
	STDMETHOD(f378)();
	STDMETHOD(f379)();
	STDMETHOD(f380)();
	STDMETHOD(f381)();
	STDMETHOD(f382)();
	STDMETHOD(f383)();
	STDMETHOD(f384)();
	STDMETHOD(f385)();
	STDMETHOD(f386)();
	STDMETHOD(f387)();
	STDMETHOD(f388)();
	STDMETHOD(f389)();
	STDMETHOD(f390)();
	STDMETHOD(f391)();
	STDMETHOD(f392)();
	STDMETHOD(f393)();
	STDMETHOD(f394)();
	STDMETHOD(f395)();
	STDMETHOD(f396)();
	STDMETHOD(f397)();
	STDMETHOD(f398)();
	STDMETHOD(f399)();
	STDMETHOD(f400)();
	STDMETHOD(f401)();
	STDMETHOD(f402)();
	STDMETHOD(f403)();
	STDMETHOD(f404)();
	STDMETHOD(f405)();
	STDMETHOD(f406)();
	STDMETHOD(f407)();
	STDMETHOD(f408)();
	STDMETHOD(f409)();
	STDMETHOD(f410)();
	STDMETHOD(f411)();
	STDMETHOD(f412)();
	STDMETHOD(f413)();
	STDMETHOD(f414)();
	STDMETHOD(f415)();
	STDMETHOD(f416)();
	STDMETHOD(f417)();
	STDMETHOD(f418)();
	STDMETHOD(f419)();
	STDMETHOD(f420)();
	STDMETHOD(f421)();
	STDMETHOD(f422)();
	STDMETHOD(f423)();
	STDMETHOD(f424)();
	STDMETHOD(f425)();
	STDMETHOD(f426)();
	STDMETHOD(f427)();
	STDMETHOD(f428)();
	STDMETHOD(f429)();
	STDMETHOD(f430)();
	STDMETHOD(f431)();
	STDMETHOD(f432)();
	STDMETHOD(f433)();
	STDMETHOD(f434)();
	STDMETHOD(f435)();
	STDMETHOD(f436)();
	STDMETHOD(f437)();
	STDMETHOD(f438)();
	STDMETHOD(f439)();
	STDMETHOD(f440)();
	STDMETHOD(f441)();
	STDMETHOD(f442)();
	STDMETHOD(f443)();
	STDMETHOD(f444)();
	STDMETHOD(f445)();
	STDMETHOD(f446)();
	STDMETHOD(f447)();
	STDMETHOD(f448)();
	STDMETHOD(f449)();
	STDMETHOD(f450)();
	STDMETHOD(f451)();
	STDMETHOD(f452)();
	STDMETHOD(f453)();
	STDMETHOD(f454)();
	STDMETHOD(f455)();
	STDMETHOD(f456)();
	STDMETHOD(f457)();
	STDMETHOD(f458)();
	STDMETHOD(f459)();
	STDMETHOD(f460)();
	STDMETHOD(f461)();
	STDMETHOD(f462)();
	STDMETHOD(f463)();
	STDMETHOD(f464)();
	STDMETHOD(f465)();
	STDMETHOD(f466)();
	STDMETHOD(f467)();
	STDMETHOD(f468)();
	STDMETHOD(f469)();
	STDMETHOD(f470)();
	STDMETHOD(f471)();
	STDMETHOD(f472)();
	STDMETHOD(f473)();
	STDMETHOD(f474)();
	STDMETHOD(f475)();
	STDMETHOD(f476)();
	STDMETHOD(f477)();
	STDMETHOD(f478)();
	STDMETHOD(f479)();
	STDMETHOD(f480)();
	STDMETHOD(f481)();
	STDMETHOD(f482)();
	STDMETHOD(f483)();
	STDMETHOD(f484)();
	STDMETHOD(f485)();
	STDMETHOD(f486)();
	STDMETHOD(f487)();
	STDMETHOD(f488)();
	STDMETHOD(f489)();
	STDMETHOD(f490)();
	STDMETHOD(f491)();
	STDMETHOD(f492)();
	STDMETHOD(f493)();
	STDMETHOD(f494)();
	STDMETHOD(f495)();
	STDMETHOD(f496)();
	STDMETHOD(f497)();
	STDMETHOD(f498)();
	STDMETHOD(f499)();
	STDMETHOD(f500)();
	STDMETHOD(f501)();
	STDMETHOD(f502)();
	STDMETHOD(f503)();
	STDMETHOD(f504)();
	STDMETHOD(f505)();
	STDMETHOD(f506)();
	STDMETHOD(f507)();
	STDMETHOD(f508)();
	STDMETHOD(f509)();
	STDMETHOD(f510)();
	STDMETHOD(f511)();
	STDMETHOD(f512)();
	STDMETHOD(f513)();
	STDMETHOD(f514)();
	STDMETHOD(f515)();
	STDMETHOD(f516)();
	STDMETHOD(f517)();
	STDMETHOD(f518)();
	STDMETHOD(f519)();
	STDMETHOD(f520)();
	STDMETHOD(f521)();
	STDMETHOD(f522)();
	STDMETHOD(f523)();
	STDMETHOD(f524)();
	STDMETHOD(f525)();
	STDMETHOD(f526)();
	STDMETHOD(f527)();
	STDMETHOD(f528)();
	STDMETHOD(f529)();
	STDMETHOD(f530)();
	STDMETHOD(f531)();
	STDMETHOD(f532)();
	STDMETHOD(f533)();
	STDMETHOD(f534)();
	STDMETHOD(f535)();
	STDMETHOD(f536)();
	STDMETHOD(f537)();
	STDMETHOD(f538)();
	STDMETHOD(f539)();
	STDMETHOD(f540)();
	STDMETHOD(f541)();
	STDMETHOD(f542)();
	STDMETHOD(f543)();
	STDMETHOD(f544)();
	STDMETHOD(f545)();
	STDMETHOD(f546)();
	STDMETHOD(f547)();
	STDMETHOD(f548)();
	STDMETHOD(f549)();
	STDMETHOD(f550)();
	STDMETHOD(f551)();
	STDMETHOD(f552)();
	STDMETHOD(f553)();
	STDMETHOD(f554)();
	STDMETHOD(f555)();
	STDMETHOD(f556)();
	STDMETHOD(f557)();
	STDMETHOD(f558)();
	STDMETHOD(f559)();
	STDMETHOD(f560)();
	STDMETHOD(f561)();
	STDMETHOD(f562)();
	STDMETHOD(f563)();
	STDMETHOD(f564)();
	STDMETHOD(f565)();
	STDMETHOD(f566)();
	STDMETHOD(f567)();
	STDMETHOD(f568)();
	STDMETHOD(f569)();
	STDMETHOD(f570)();
	STDMETHOD(f571)();
	STDMETHOD(f572)();
	STDMETHOD(f573)();
	STDMETHOD(f574)();
	STDMETHOD(f575)();
	STDMETHOD(f576)();
	STDMETHOD(f577)();
	STDMETHOD(f578)();
	STDMETHOD(f579)();
	STDMETHOD(f580)();
	STDMETHOD(f581)();
	STDMETHOD(f582)();
	STDMETHOD(f583)();
	STDMETHOD(f584)();
	STDMETHOD(f585)();
	STDMETHOD(f586)();
	STDMETHOD(f587)();
	STDMETHOD(f588)();
	STDMETHOD(f589)();
	STDMETHOD(f590)();
	STDMETHOD(f591)();
	STDMETHOD(f592)();
	STDMETHOD(f593)();
	STDMETHOD(f594)();
	STDMETHOD(f595)();
	STDMETHOD(f596)();
	STDMETHOD(f597)();
	STDMETHOD(f598)();
	STDMETHOD(f599)();
	STDMETHOD(f600)();
	STDMETHOD(f601)();
	STDMETHOD(f602)();
	STDMETHOD(f603)();
	STDMETHOD(f604)();
	STDMETHOD(f605)();
	STDMETHOD(f606)();
	STDMETHOD(f607)();
	STDMETHOD(f608)();
	STDMETHOD(f609)();
	STDMETHOD(f610)();
	STDMETHOD(f611)();
	STDMETHOD(f612)();
	STDMETHOD(f613)();
	STDMETHOD(f614)();
	STDMETHOD(f615)();
	STDMETHOD(f616)();
	STDMETHOD(f617)();
	STDMETHOD(f618)();
	STDMETHOD(f619)();
	STDMETHOD(f620)();
	STDMETHOD(f621)();
	STDMETHOD(f622)();
	STDMETHOD(f623)();
	STDMETHOD(f624)();
	STDMETHOD(f625)();
	STDMETHOD(f626)();
	STDMETHOD(f627)();
	STDMETHOD(f628)();
	STDMETHOD(f629)();
	STDMETHOD(f630)();
	STDMETHOD(f631)();
	STDMETHOD(f632)();
	STDMETHOD(f633)();
	STDMETHOD(f634)();
	STDMETHOD(f635)();
	STDMETHOD(f636)();
	STDMETHOD(f637)();
	STDMETHOD(f638)();
	STDMETHOD(f639)();
	STDMETHOD(f640)();
	STDMETHOD(f641)();
	STDMETHOD(f642)();
	STDMETHOD(f643)();
	STDMETHOD(f644)();
	STDMETHOD(f645)();
	STDMETHOD(f646)();
	STDMETHOD(f647)();
	STDMETHOD(f648)();
	STDMETHOD(f649)();
	STDMETHOD(f650)();
	STDMETHOD(f651)();
	STDMETHOD(f652)();
	STDMETHOD(f653)();
	STDMETHOD(f654)();
	STDMETHOD(f655)();
	STDMETHOD(f656)();
	STDMETHOD(f657)();
	STDMETHOD(f658)();
	STDMETHOD(f659)();
	STDMETHOD(f660)();
	STDMETHOD(f661)();
	STDMETHOD(f662)();
	STDMETHOD(f663)();
	STDMETHOD(f664)();
	STDMETHOD(f665)();
	STDMETHOD(f666)();
	STDMETHOD(f667)();
	STDMETHOD(f668)();
	STDMETHOD(f669)();
	STDMETHOD(f670)();
	STDMETHOD(f671)();
	STDMETHOD(f672)();
	STDMETHOD(f673)();
	STDMETHOD(f674)();
	STDMETHOD(f675)();
	STDMETHOD(f676)();
	STDMETHOD(f677)();
	STDMETHOD(f678)();
	STDMETHOD(f679)();
	STDMETHOD(f680)();
	STDMETHOD(f681)();
	STDMETHOD(f682)();
	STDMETHOD(f683)();
	STDMETHOD(f684)();
	STDMETHOD(f685)();
	STDMETHOD(f686)();
	STDMETHOD(f687)();
	STDMETHOD(f688)();
	STDMETHOD(f689)();
	STDMETHOD(f690)();
	STDMETHOD(f691)();
	STDMETHOD(f692)();
	STDMETHOD(f693)();
	STDMETHOD(f694)();
	STDMETHOD(f695)();
	STDMETHOD(f696)();
	STDMETHOD(f697)();
	STDMETHOD(f698)();
	STDMETHOD(f699)();
	STDMETHOD(f700)();
	STDMETHOD(f701)();
	STDMETHOD(f702)();
	STDMETHOD(f703)();
	STDMETHOD(f704)();
	STDMETHOD(f705)();
	STDMETHOD(f706)();
	STDMETHOD(f707)();
	STDMETHOD(f708)();
	STDMETHOD(f709)();
	STDMETHOD(f710)();
	STDMETHOD(f711)();
	STDMETHOD(f712)();
	STDMETHOD(f713)();
	STDMETHOD(f714)();
	STDMETHOD(f715)();
	STDMETHOD(f716)();
	STDMETHOD(f717)();
	STDMETHOD(f718)();
	STDMETHOD(f719)();
	STDMETHOD(f720)();
	STDMETHOD(f721)();
	STDMETHOD(f722)();
	STDMETHOD(f723)();
	STDMETHOD(f724)();
	STDMETHOD(f725)();
	STDMETHOD(f726)();
	STDMETHOD(f727)();
	STDMETHOD(f728)();
	STDMETHOD(f729)();
	STDMETHOD(f730)();
	STDMETHOD(f731)();
	STDMETHOD(f732)();
	STDMETHOD(f733)();
	STDMETHOD(f734)();
	STDMETHOD(f735)();
	STDMETHOD(f736)();
	STDMETHOD(f737)();
	STDMETHOD(f738)();
	STDMETHOD(f739)();
	STDMETHOD(f740)();
	STDMETHOD(f741)();
	STDMETHOD(f742)();
	STDMETHOD(f743)();
	STDMETHOD(f744)();
	STDMETHOD(f745)();
	STDMETHOD(f746)();
	STDMETHOD(f747)();
	STDMETHOD(f748)();
	STDMETHOD(f749)();
	STDMETHOD(f750)();
	STDMETHOD(f751)();
	STDMETHOD(f752)();
	STDMETHOD(f753)();
	STDMETHOD(f754)();
	STDMETHOD(f755)();
	STDMETHOD(f756)();
	STDMETHOD(f757)();
	STDMETHOD(f758)();
	STDMETHOD(f759)();
	STDMETHOD(f760)();
	STDMETHOD(f761)();
	STDMETHOD(f762)();
	STDMETHOD(f763)();
	STDMETHOD(f764)();
	STDMETHOD(f765)();
	STDMETHOD(f766)();
	STDMETHOD(f767)();
	STDMETHOD(f768)();
	STDMETHOD(f769)();
	STDMETHOD(f770)();
	STDMETHOD(f771)();
	STDMETHOD(f772)();
	STDMETHOD(f773)();
	STDMETHOD(f774)();
	STDMETHOD(f775)();
	STDMETHOD(f776)();
	STDMETHOD(f777)();
	STDMETHOD(f778)();
	STDMETHOD(f779)();
	STDMETHOD(f780)();
	STDMETHOD(f781)();
	STDMETHOD(f782)();
	STDMETHOD(f783)();
	STDMETHOD(f784)();
	STDMETHOD(f785)();
	STDMETHOD(f786)();
	STDMETHOD(f787)();
	STDMETHOD(f788)();
	STDMETHOD(f789)();
	STDMETHOD(f790)();
	STDMETHOD(f791)();
	STDMETHOD(f792)();
	STDMETHOD(f793)();
	STDMETHOD(f794)();
	STDMETHOD(f795)();
	STDMETHOD(f796)();
	STDMETHOD(f797)();
	STDMETHOD(f798)();
	STDMETHOD(f799)();
	STDMETHOD(f800)();
	STDMETHOD(f801)();
	STDMETHOD(f802)();
	STDMETHOD(f803)();
	STDMETHOD(f804)();
	STDMETHOD(f805)();
	STDMETHOD(f806)();
	STDMETHOD(f807)();
	STDMETHOD(f808)();
	STDMETHOD(f809)();
	STDMETHOD(f810)();
	STDMETHOD(f811)();
	STDMETHOD(f812)();
	STDMETHOD(f813)();
	STDMETHOD(f814)();
	STDMETHOD(f815)();
	STDMETHOD(f816)();
	STDMETHOD(f817)();
	STDMETHOD(f818)();
	STDMETHOD(f819)();
	STDMETHOD(f820)();
	STDMETHOD(f821)();
	STDMETHOD(f822)();
	STDMETHOD(f823)();
	STDMETHOD(f824)();
	STDMETHOD(f825)();
	STDMETHOD(f826)();
	STDMETHOD(f827)();
	STDMETHOD(f828)();
	STDMETHOD(f829)();
	STDMETHOD(f830)();
	STDMETHOD(f831)();
	STDMETHOD(f832)();
	STDMETHOD(f833)();
	STDMETHOD(f834)();
	STDMETHOD(f835)();
	STDMETHOD(f836)();
	STDMETHOD(f837)();
	STDMETHOD(f838)();
	STDMETHOD(f839)();
	STDMETHOD(f840)();
	STDMETHOD(f841)();
	STDMETHOD(f842)();
	STDMETHOD(f843)();
	STDMETHOD(f844)();
	STDMETHOD(f845)();
	STDMETHOD(f846)();
	STDMETHOD(f847)();
	STDMETHOD(f848)();
	STDMETHOD(f849)();
	STDMETHOD(f850)();
	STDMETHOD(f851)();
	STDMETHOD(f852)();
	STDMETHOD(f853)();
	STDMETHOD(f854)();
	STDMETHOD(f855)();
	STDMETHOD(f856)();
	STDMETHOD(f857)();
	STDMETHOD(f858)();
	STDMETHOD(f859)();
	STDMETHOD(f860)();
	STDMETHOD(f861)();
	STDMETHOD(f862)();
	STDMETHOD(f863)();
	STDMETHOD(f864)();
	STDMETHOD(f865)();
	STDMETHOD(f866)();
	STDMETHOD(f867)();
	STDMETHOD(f868)();
	STDMETHOD(f869)();
	STDMETHOD(f870)();
	STDMETHOD(f871)();
	STDMETHOD(f872)();
	STDMETHOD(f873)();
	STDMETHOD(f874)();
	STDMETHOD(f875)();
	STDMETHOD(f876)();
	STDMETHOD(f877)();
	STDMETHOD(f878)();
	STDMETHOD(f879)();
	STDMETHOD(f880)();
	STDMETHOD(f881)();
	STDMETHOD(f882)();
	STDMETHOD(f883)();
	STDMETHOD(f884)();
	STDMETHOD(f885)();
	STDMETHOD(f886)();
	STDMETHOD(f887)();
	STDMETHOD(f888)();
	STDMETHOD(f889)();
	STDMETHOD(f890)();
	STDMETHOD(f891)();
	STDMETHOD(f892)();
	STDMETHOD(f893)();
	STDMETHOD(f894)();
	STDMETHOD(f895)();
	STDMETHOD(f896)();
	STDMETHOD(f897)();
	STDMETHOD(f898)();
	STDMETHOD(f899)();
	STDMETHOD(f900)();
	STDMETHOD(f901)();
	STDMETHOD(f902)();
	STDMETHOD(f903)();
	STDMETHOD(f904)();
	STDMETHOD(f905)();
	STDMETHOD(f906)();
	STDMETHOD(f907)();
	STDMETHOD(f908)();
	STDMETHOD(f909)();
	STDMETHOD(f910)();
	STDMETHOD(f911)();
	STDMETHOD(f912)();
	STDMETHOD(f913)();
	STDMETHOD(f914)();
	STDMETHOD(f915)();
	STDMETHOD(f916)();
	STDMETHOD(f917)();
	STDMETHOD(f918)();
	STDMETHOD(f919)();
	STDMETHOD(f920)();
	STDMETHOD(f921)();
	STDMETHOD(f922)();
	STDMETHOD(f923)();
	STDMETHOD(f924)();
	STDMETHOD(f925)();
	STDMETHOD(f926)();
	STDMETHOD(f927)();
	STDMETHOD(f928)();
	STDMETHOD(f929)();
	STDMETHOD(f930)();
	STDMETHOD(f931)();
	STDMETHOD(f932)();
	STDMETHOD(f933)();
	STDMETHOD(f934)();
	STDMETHOD(f935)();
	STDMETHOD(f936)();
	STDMETHOD(f937)();
	STDMETHOD(f938)();
	STDMETHOD(f939)();
	STDMETHOD(f940)();
	STDMETHOD(f941)();
	STDMETHOD(f942)();
	STDMETHOD(f943)();
	STDMETHOD(f944)();
	STDMETHOD(f945)();
	STDMETHOD(f946)();
	STDMETHOD(f947)();
	STDMETHOD(f948)();
	STDMETHOD(f949)();
	STDMETHOD(f950)();
	STDMETHOD(f951)();
	STDMETHOD(f952)();
	STDMETHOD(f953)();
	STDMETHOD(f954)();
	STDMETHOD(f955)();
	STDMETHOD(f956)();
	STDMETHOD(f957)();
	STDMETHOD(f958)();
	STDMETHOD(f959)();
	STDMETHOD(f960)();
	STDMETHOD(f961)();
	STDMETHOD(f962)();
	STDMETHOD(f963)();
	STDMETHOD(f964)();
	STDMETHOD(f965)();
	STDMETHOD(f966)();
	STDMETHOD(f967)();
	STDMETHOD(f968)();
	STDMETHOD(f969)();
	STDMETHOD(f970)();
	STDMETHOD(f971)();
	STDMETHOD(f972)();
	STDMETHOD(f973)();
	STDMETHOD(f974)();
	STDMETHOD(f975)();
	STDMETHOD(f976)();
	STDMETHOD(f977)();
	STDMETHOD(f978)();
	STDMETHOD(f979)();
	STDMETHOD(f980)();
	STDMETHOD(f981)();
	STDMETHOD(f982)();
	STDMETHOD(f983)();
	STDMETHOD(f984)();
	STDMETHOD(f985)();
	STDMETHOD(f986)();
	STDMETHOD(f987)();
	STDMETHOD(f988)();
	STDMETHOD(f989)();
	STDMETHOD(f990)();
	STDMETHOD(f991)();
	STDMETHOD(f992)();
	STDMETHOD(f993)();
	STDMETHOD(f994)();
	STDMETHOD(f995)();
	STDMETHOD(f996)();
	STDMETHOD(f997)();
	STDMETHOD(f998)();
	STDMETHOD(f999)();
	STDMETHOD(f1000)();
	STDMETHOD(f1001)();
	STDMETHOD(f1002)();
	STDMETHOD(f1003)();
	STDMETHOD(f1004)();
	STDMETHOD(f1005)();
	STDMETHOD(f1006)();
	STDMETHOD(f1007)();
	STDMETHOD(f1008)();
	STDMETHOD(f1009)();
	STDMETHOD(f1010)();
	STDMETHOD(f1011)();
	STDMETHOD(f1012)();
	STDMETHOD(f1013)();
	STDMETHOD(f1014)();
	STDMETHOD(f1015)();
	STDMETHOD(f1016)();
	STDMETHOD(f1017)();
	STDMETHOD(f1018)();
	STDMETHOD(f1019)();
	STDMETHOD(f1020)();
	STDMETHOD(f1021)();
	STDMETHOD(f1022)();
	STDMETHOD(f1023)();
	STDMETHOD(f1024)();
	_QIThunk(IUnknown* pOrig, LPCTSTR p, const IID& i, UINT n, bool b)
	{
		lpszClassName = p;
		iid = i;
		nIndex = n;
		m_dwRef = 0;
		m_dwMaxRef = 0;
		pUnk = pOrig;
		bBreak = b;
		bNonAddRefThunk = false;
	}
	IUnknown* pUnk;
	long m_dwRef;
	long m_dwMaxRef;
	LPCTSTR lpszClassName;
	IID iid;
	UINT nIndex;
	bool bBreak;
	bool bNonAddRefThunk;
	void Dump()
	{
		TCHAR buf[256];
		if (m_dwRef != 0)
		{
			wsprintf(buf, _T("INTERFACE LEAK: RefCount = %d, MaxRefCount = %d, {Allocation = %d} "), m_dwRef, m_dwMaxRef, nIndex);
			OutputDebugString(buf);
			AtlDumpIID(iid, lpszClassName, S_OK);
		}
		else
		{
			wsprintf(buf, _T("NonAddRef Thunk LEAK: {Allocation = %d}\n"), nIndex);
			OutputDebugString(buf);
		}
	}
};
#endif


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
		{
			m_aT[nIndex].~T();
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		}
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
				m_aT[i].~T();
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(&m_aT[nIndex]) Wrapper(t);
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;  // not found
	}
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
	BOOL Add(T t)
	{
		return CSimpleArray< T >::Add(t);
	}
	BOOL Remove(T t)
	{
		return CSimpleArray< T >::Remove(t);
	}
	T operator[] (int nIndex) const
	{
		return CSimpleArray< T >::operator[](nIndex);
	}
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
			m_aKey[nIndex].~TKey();
			m_aVal[nIndex].~TVal();
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aKey != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
			{
				m_aKey[i].~TKey();
				m_aVal[i].~TVal();
			}
			free(m_aKey);
			m_aKey = NULL;
		}
		if(m_aVal != NULL)
		{
			free(m_aVal);
			m_aVal = NULL;
		}

		m_nSize = 0;
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation

	template <typename T>
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <typename _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(&m_aKey[nIndex]) Wrapper<TKey>(key);
		new(&m_aVal[nIndex]) Wrapper<TVal>(val);
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;  // not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;  // not found
	}
};


class CComModule;
__declspec(selectany) CComModule* _pModule=NULL;

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
_declspec(selectany) GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

class CComModule : public _ATL_MODULE
{
// Operations
public:
	static GUID m_libid;
#ifdef _ATL_DEBUG_INTERFACES
	UINT m_nIndexQI;
	UINT m_nIndexBreakAt;
	CSimpleArray<_QIThunk*>* m_paThunks;
#endif // _ATL_DEBUG_INTERFACES

	void AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
	{
		AtlModuleAddCreateWndData(this, pData, pObject);
	}
	void* ExtractCreateWndData()
	{
		return AtlModuleExtractCreateWndData(this);
	}

	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
	{
		pguidVer = &GUID_ATLVer30;
		_pModule = this;
		cbSize = sizeof(_ATL_MODULE);
		dwAtlBuildVer = _ATL_VER;
		AtlModuleInit(this, p, h);
		if (plibid != NULL)
			memcpy((void*)&m_libid, plibid, sizeof(GUID));
#ifdef _ATL_MIN_CRT
		// Create a base heap
		m_hHeap = HeapCreate(0, 0, 0);

#ifndef _ATL_NO_MP_HEAP
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		if (si.dwNumberOfProcessors > 1)
		{
			DWORD dwHeaps = si.dwNumberOfProcessors * 2;
			m_dwHeaps = 0xFFFFFFFF;
			for (int bits = 0; bits < 32; bits++)
			{
				if (dwHeaps & 0x80000000)
					break;
				dwHeaps <<= 1;
				m_dwHeaps >>= 1;
			}
			m_dwHeaps >>= 1;

			// Allocate more heaps for each processor
			m_phHeaps = (HANDLE*) HeapAlloc(m_hHeap, _ATL_HEAPFLAGS, sizeof(HANDLE) * (m_dwHeaps + 1));
			for (DWORD i = 0; i <= m_dwHeaps; i++)
				m_phHeaps[i] = HeapCreate(0, 0, 0);
		}
		else
#endif
		{
			m_phHeaps = NULL;
			m_dwHeaps = 0;
		}
#endif
#ifdef _ATL_DEBUG_INTERFACES
		m_nIndexQI = 0;
		m_nIndexBreakAt = 0;
		m_paThunks = NULL;
		ATLTRY(m_paThunks = new CSimpleArray<_QIThunk*>);
		if (m_paThunks == NULL)
			return E_OUTOFMEMORY;
#endif // _ATL_DEBUG_INTERFACES
		return S_OK;
	}
#ifdef _ATL_DEBUG_INTERFACES
	HRESULT AddThunk(IUnknown** pp, LPCTSTR lpsz, REFIID iid)
	{
		if ((pp == NULL) || (*pp == NULL))
			return E_POINTER;
		IUnknown* p = *pp;
		_QIThunk* pThunk = NULL;
		EnterCriticalSection(&m_csObjMap);
		// Check if exists already for identity
		if (InlineIsEqualUnknown(iid))
		{
			for (int i = 0; i < m_paThunks->GetSize(); i++)
			{
				if (m_paThunks->operator[](i)->pUnk == p)
				{
					m_paThunks->operator[](i)->InternalAddRef();
					pThunk = m_paThunks->operator[](i);
					break;
				}
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
				return E_OUTOFMEMORY;
			pThunk->InternalAddRef();
			m_paThunks->Add(pThunk);
		}
		LeaveCriticalSection(&m_csObjMap);
		*pp = (IUnknown*)pThunk;
		return S_OK;
	}
	HRESULT AddNonAddRefThunk(IUnknown* p, LPCTSTR lpsz, IUnknown** ppThunkRet)
	{
		_QIThunk* pThunk = NULL;
		EnterCriticalSection(&m_csObjMap);
		// Check if exists already for identity
		for (int i = 0; i < m_paThunks->GetSize(); i++)
		{
			if (m_paThunks->operator[](i)->pUnk == p)
			{
				m_paThunks->operator[](i)->bNonAddRefThunk = true;
				pThunk = m_paThunks->operator[](i);
				break;
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
			{
				*ppThunkRet = NULL;
				return E_OUTOFMEMORY;
			}
			pThunk->bNonAddRefThunk = true;
			m_paThunks->Add(pThunk);
		}
		LeaveCriticalSection(&m_csObjMap);
		*ppThunkRet = (IUnknown*)pThunk;
		return S_OK;;
	}
	void DeleteNonAddRefThunk(IUnknown* pUnk)
	{
		EnterCriticalSection(&m_csObjMap);
		for (int i = 0; i < m_paThunks->GetSize(); i++)
		{
			if (m_paThunks->operator[](i)->pUnk == pUnk)
			{
				delete m_paThunks->operator[](i);
				m_paThunks->RemoveAt(i);
				break;
			}
		}
		LeaveCriticalSection(&m_csObjMap);
	}
	void DeleteThunk(_QIThunk* p)
	{
		EnterCriticalSection(&m_csObjMap);
		int nIndex = m_paThunks->Find(p);
		if (nIndex != -1)
		{
			delete m_paThunks->operator[](nIndex);
			m_paThunks->RemoveAt(nIndex);
		}
		LeaveCriticalSection(&m_csObjMap);
	}
	bool DumpLeakedThunks()
	{
		bool b = false;
		for (int i = 0; i < m_paThunks->GetSize(); i++)
		{
			b = true;
			m_paThunks->operator[](i)->Dump();
			delete m_paThunks->operator[](i);
		}
		m_paThunks->RemoveAll();
		return b;
	}
#endif // _ATL_DEBUG_INTERFACES
	void Term()
	{
#ifdef _ATL_DEBUG_INTERFACES
		m_bDestroyHeap = false; // prevent heap from going away
		AtlModuleTerm(this);
		DumpLeakedThunks();
		delete m_paThunks;
#ifndef _ATL_NO_MP_HEAP
		if (m_phHeaps != NULL)
		{
			for (DWORD i = 0; i <= m_dwHeaps; i++)
				HeapDestroy(m_phHeaps[i]);
		}
#endif
		if (m_hHeap != NULL)
			HeapDestroy(m_hHeap);
#else
		AtlModuleTerm(this);
#endif // _ATL_DEBUG_INTERFACES
	}

	HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD dw)
	{
		return AtlModuleAddTermFunc(this, pFunc, dw);
	}

	LONG Lock()
	{
		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
	}
	LONG Unlock()
	{
		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount()
	{
		return m_nLockCnt;
	}

	HINSTANCE GetModuleInstance() {return m_hInst;}
	HINSTANCE GetResourceInstance() {return m_hInstResource;}
	HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

	// Registry support (helpers)
	HRESULT RegisterTypeLib()
	{
		return AtlModuleRegisterTypeLib(this, NULL);
	}
	HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
	{
		USES_CONVERSION;
		return AtlModuleRegisterTypeLib(this, T2COLE(lpszIndex));
	}
	HRESULT UnRegisterTypeLib()
	{
		return AtlModuleUnRegisterTypeLib(this, NULL);
	}
	HRESULT UnRegisterTypeLib(LPCTSTR lpszIndex)
	{
		USES_CONVERSION;
		return AtlModuleUnRegisterTypeLib(this, T2COLE(lpszIndex));
	}
	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
	{
		return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
	}

	HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
	{
		return AtlModuleUnregisterServer(this, pCLSID);
	}
	HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL)
	{
		return AtlModuleUnregisterServerEx(this, bUnRegTypeLib, pCLSID);
	}

	// Resource-based Registration
	HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		USES_CONVERSION;
		return AtlModuleUpdateRegistryFromResourceD(this, T2COLE(lpszRes), bRegister,
			pMapEntries);
	}
	HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		return AtlModuleUpdateRegistryFromResourceD(this,
			(LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
	}

#ifdef _ATL_STATIC_REGISTRY
	// Statically linking to Registry Ponent
	HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
#endif

	// Standard Registration
	HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
	HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
	HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID);

	// Register/Revoke All Class Factories with the OS (EXE only)
	HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
	{
		return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
	}
	HRESULT RevokeClassObjects()
	{
		return AtlModuleRevokeClassObjects(this);
	}

	// Obtain a Class Factory (DLL only)
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
	{
		return AtlModuleGetClassObject(this, rclsid, riid, ppv);
	}

	// Only used in CComAutoThreadModule
	HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
	{
		ATLASSERT(FALSE);
		return E_NOTIMPL;
	}
	static HRESULT RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc);

	static void ReplaceSingleQuote(LPOLESTR lpDest, LPCOLESTR lp)
	{
		while (*lp)
		{
			*lpDest++ = *lp;
			if (*lp == OLESTR('\''))
				*lpDest++ = *lp;
			lp++;
		}
		*lpDest = NULL;
	}
};

#ifdef _ATL_DEBUG_INTERFACES
inline ULONG _QIThunk::Release()
{
	if (bBreak)
		DebugBreak();
	ATLASSERT(m_dwRef > 0);
	ULONG l = InterlockedDecrement(&m_dwRef);
	ATLTRACE(_T("%d< "), m_dwRef);
	AtlDumpIID(iid, lpszClassName, S_OK);
	pUnk->Release();
	if (l == 0 && !bNonAddRefThunk)
		_pModule->DeleteThunk(this);
	return l;
}
inline static void atlBadThunkCall()
{
	ATLASSERT(FALSE && "Call through deleted thunk");
}
#define IMPL_THUNK(n)\
__declspec(naked) inline HRESULT _QIThunk::f##n()\
{\
	__asm mov eax, [esp+4]\
	__asm cmp dword ptr [eax+8], 0\
	__asm jg goodref\
	__asm call atlBadThunkCall\
	__asm goodref:\
	__asm mov eax, [esp+4]\
	__asm mov eax, dword ptr [eax+4]\
	__asm mov [esp+4], eax\
	__asm mov eax, dword ptr [eax]\
	__asm mov eax, dword ptr [eax+4*n]\
	__asm jmp eax\
}

IMPL_THUNK(3)
IMPL_THUNK(4)
IMPL_THUNK(5)
IMPL_THUNK(6)
IMPL_THUNK(7)
IMPL_THUNK(8)
IMPL_THUNK(9)
IMPL_THUNK(10)
IMPL_THUNK(11)
IMPL_THUNK(12)
IMPL_THUNK(13)
IMPL_THUNK(14)
IMPL_THUNK(15)
IMPL_THUNK(16)
IMPL_THUNK(17)
IMPL_THUNK(18)
IMPL_THUNK(19)
IMPL_THUNK(20)
IMPL_THUNK(21)
IMPL_THUNK(22)
IMPL_THUNK(23)
IMPL_THUNK(24)
IMPL_THUNK(25)
IMPL_THUNK(26)
IMPL_THUNK(27)
IMPL_THUNK(28)
IMPL_THUNK(29)
IMPL_THUNK(30)
IMPL_THUNK(31)
IMPL_THUNK(32)
IMPL_THUNK(33)
IMPL_THUNK(34)
IMPL_THUNK(35)
IMPL_THUNK(36)
IMPL_THUNK(37)
IMPL_THUNK(38)
IMPL_THUNK(39)
IMPL_THUNK(40)
IMPL_THUNK(41)
IMPL_THUNK(42)
IMPL_THUNK(43)
IMPL_THUNK(44)
IMPL_THUNK(45)
IMPL_THUNK(46)
IMPL_THUNK(47)
IMPL_THUNK(48)
IMPL_THUNK(49)
IMPL_THUNK(50)
IMPL_THUNK(51)
IMPL_THUNK(52)
IMPL_THUNK(53)
IMPL_THUNK(54)
IMPL_THUNK(55)
IMPL_THUNK(56)
IMPL_THUNK(57)
IMPL_THUNK(58)
IMPL_THUNK(59)
IMPL_THUNK(60)
IMPL_THUNK(61)
IMPL_THUNK(62)
IMPL_THUNK(63)
IMPL_THUNK(64)
IMPL_THUNK(65)
IMPL_THUNK(66)
IMPL_THUNK(67)
IMPL_THUNK(68)
IMPL_THUNK(69)
IMPL_THUNK(70)
IMPL_THUNK(71)
IMPL_THUNK(72)
IMPL_THUNK(73)
IMPL_THUNK(74)
IMPL_THUNK(75)
IMPL_THUNK(76)
IMPL_THUNK(77)
IMPL_THUNK(78)
IMPL_THUNK(79)
IMPL_THUNK(80)
IMPL_THUNK(81)
IMPL_THUNK(82)
IMPL_THUNK(83)
IMPL_THUNK(84)
IMPL_THUNK(85)
IMPL_THUNK(86)
IMPL_THUNK(87)
IMPL_THUNK(88)
IMPL_THUNK(89)
IMPL_THUNK(90)
IMPL_THUNK(91)
IMPL_THUNK(92)
IMPL_THUNK(93)
IMPL_THUNK(94)
IMPL_THUNK(95)
IMPL_THUNK(96)
IMPL_THUNK(97)
IMPL_THUNK(98)
IMPL_THUNK(99)
IMPL_THUNK(100)
IMPL_THUNK(101)
IMPL_THUNK(102)
IMPL_THUNK(103)
IMPL_THUNK(104)
IMPL_THUNK(105)
IMPL_THUNK(106)
IMPL_THUNK(107)
IMPL_THUNK(108)
IMPL_THUNK(109)
IMPL_THUNK(110)
IMPL_THUNK(111)
IMPL_THUNK(112)
IMPL_THUNK(113)
IMPL_THUNK(114)
IMPL_THUNK(115)
IMPL_THUNK(116)
IMPL_THUNK(117)
IMPL_THUNK(118)
IMPL_THUNK(119)
IMPL_THUNK(120)
IMPL_THUNK(121)
IMPL_THUNK(122)
IMPL_THUNK(123)
IMPL_THUNK(124)
IMPL_THUNK(125)
IMPL_THUNK(126)
IMPL_THUNK(127)
IMPL_THUNK(128)
IMPL_THUNK(129)
IMPL_THUNK(130)
IMPL_THUNK(131)
IMPL_THUNK(132)
IMPL_THUNK(133)
IMPL_THUNK(134)
IMPL_THUNK(135)
IMPL_THUNK(136)
IMPL_THUNK(137)
IMPL_THUNK(138)
IMPL_THUNK(139)
IMPL_THUNK(140)
IMPL_THUNK(141)
IMPL_THUNK(142)
IMPL_THUNK(143)
IMPL_THUNK(144)
IMPL_THUNK(145)
IMPL_THUNK(146)
IMPL_THUNK(147)
IMPL_THUNK(148)
IMPL_THUNK(149)
IMPL_THUNK(150)
IMPL_THUNK(151)
IMPL_THUNK(152)
IMPL_THUNK(153)
IMPL_THUNK(154)
IMPL_THUNK(155)
IMPL_THUNK(156)
IMPL_THUNK(157)
IMPL_THUNK(158)
IMPL_THUNK(159)
IMPL_THUNK(160)
IMPL_THUNK(161)
IMPL_THUNK(162)
IMPL_THUNK(163)
IMPL_THUNK(164)
IMPL_THUNK(165)
IMPL_THUNK(166)
IMPL_THUNK(167)
IMPL_THUNK(168)
IMPL_THUNK(169)
IMPL_THUNK(170)
IMPL_THUNK(171)
IMPL_THUNK(172)
IMPL_THUNK(173)
IMPL_THUNK(174)
IMPL_THUNK(175)
IMPL_THUNK(176)
IMPL_THUNK(177)
IMPL_THUNK(178)
IMPL_THUNK(179)
IMPL_THUNK(180)
IMPL_THUNK(181)
IMPL_THUNK(182)
IMPL_THUNK(183)
IMPL_THUNK(184)
IMPL_THUNK(185)
IMPL_THUNK(186)
IMPL_THUNK(187)
IMPL_THUNK(188)
IMPL_THUNK(189)
IMPL_THUNK(190)
IMPL_THUNK(191)
IMPL_THUNK(192)
IMPL_THUNK(193)
IMPL_THUNK(194)
IMPL_THUNK(195)
IMPL_THUNK(196)
IMPL_THUNK(197)
IMPL_THUNK(198)
IMPL_THUNK(199)
IMPL_THUNK(200)
IMPL_THUNK(201)
IMPL_THUNK(202)
IMPL_THUNK(203)
IMPL_THUNK(204)
IMPL_THUNK(205)
IMPL_THUNK(206)
IMPL_THUNK(207)
IMPL_THUNK(208)
IMPL_THUNK(209)
IMPL_THUNK(210)
IMPL_THUNK(211)
IMPL_THUNK(212)
IMPL_THUNK(213)
IMPL_THUNK(214)
IMPL_THUNK(215)
IMPL_THUNK(216)
IMPL_THUNK(217)
IMPL_THUNK(218)
IMPL_THUNK(219)
IMPL_THUNK(220)
IMPL_THUNK(221)
IMPL_THUNK(222)
IMPL_THUNK(223)
IMPL_THUNK(224)
IMPL_THUNK(225)
IMPL_THUNK(226)
IMPL_THUNK(227)
IMPL_THUNK(228)
IMPL_THUNK(229)
IMPL_THUNK(230)
IMPL_THUNK(231)
IMPL_THUNK(232)
IMPL_THUNK(233)
IMPL_THUNK(234)
IMPL_THUNK(235)
IMPL_THUNK(236)
IMPL_THUNK(237)
IMPL_THUNK(238)
IMPL_THUNK(239)
IMPL_THUNK(240)
IMPL_THUNK(241)
IMPL_THUNK(242)
IMPL_THUNK(243)
IMPL_THUNK(244)
IMPL_THUNK(245)
IMPL_THUNK(246)
IMPL_THUNK(247)
IMPL_THUNK(248)
IMPL_THUNK(249)
IMPL_THUNK(250)
IMPL_THUNK(251)
IMPL_THUNK(252)
IMPL_THUNK(253)
IMPL_THUNK(254)
IMPL_THUNK(255)
IMPL_THUNK(256)
IMPL_THUNK(257)
IMPL_THUNK(258)
IMPL_THUNK(259)
IMPL_THUNK(260)
IMPL_THUNK(261)
IMPL_THUNK(262)
IMPL_THUNK(263)
IMPL_THUNK(264)
IMPL_THUNK(265)
IMPL_THUNK(266)
IMPL_THUNK(267)
IMPL_THUNK(268)
IMPL_THUNK(269)
IMPL_THUNK(270)
IMPL_THUNK(271)
IMPL_THUNK(272)
IMPL_THUNK(273)
IMPL_THUNK(274)
IMPL_THUNK(275)
IMPL_THUNK(276)
IMPL_THUNK(277)
IMPL_THUNK(278)
IMPL_THUNK(279)
IMPL_THUNK(280)
IMPL_THUNK(281)
IMPL_THUNK(282)
IMPL_THUNK(283)
IMPL_THUNK(284)
IMPL_THUNK(285)
IMPL_THUNK(286)
IMPL_THUNK(287)
IMPL_THUNK(288)
IMPL_THUNK(289)
IMPL_THUNK(290)
IMPL_THUNK(291)
IMPL_THUNK(292)
IMPL_THUNK(293)
IMPL_THUNK(294)
IMPL_THUNK(295)
IMPL_THUNK(296)
IMPL_THUNK(297)
IMPL_THUNK(298)
IMPL_THUNK(299)
IMPL_THUNK(300)
IMPL_THUNK(301)
IMPL_THUNK(302)
IMPL_THUNK(303)
IMPL_THUNK(304)
IMPL_THUNK(305)
IMPL_THUNK(306)
IMPL_THUNK(307)
IMPL_THUNK(308)
IMPL_THUNK(309)
IMPL_THUNK(310)
IMPL_THUNK(311)
IMPL_THUNK(312)
IMPL_THUNK(313)
IMPL_THUNK(314)
IMPL_THUNK(315)
IMPL_THUNK(316)
IMPL_THUNK(317)
IMPL_THUNK(318)
IMPL_THUNK(319)
IMPL_THUNK(320)
IMPL_THUNK(321)
IMPL_THUNK(322)
IMPL_THUNK(323)
IMPL_THUNK(324)
IMPL_THUNK(325)
IMPL_THUNK(326)
IMPL_THUNK(327)
IMPL_THUNK(328)
IMPL_THUNK(329)
IMPL_THUNK(330)
IMPL_THUNK(331)
IMPL_THUNK(332)
IMPL_THUNK(333)
IMPL_THUNK(334)
IMPL_THUNK(335)
IMPL_THUNK(336)
IMPL_THUNK(337)
IMPL_THUNK(338)
IMPL_THUNK(339)
IMPL_THUNK(340)
IMPL_THUNK(341)
IMPL_THUNK(342)
IMPL_THUNK(343)
IMPL_THUNK(344)
IMPL_THUNK(345)
IMPL_THUNK(346)
IMPL_THUNK(347)
IMPL_THUNK(348)
IMPL_THUNK(349)
IMPL_THUNK(350)
IMPL_THUNK(351)
IMPL_THUNK(352)
IMPL_THUNK(353)
IMPL_THUNK(354)
IMPL_THUNK(355)
IMPL_THUNK(356)
IMPL_THUNK(357)
IMPL_THUNK(358)
IMPL_THUNK(359)
IMPL_THUNK(360)
IMPL_THUNK(361)
IMPL_THUNK(362)
IMPL_THUNK(363)
IMPL_THUNK(364)
IMPL_THUNK(365)
IMPL_THUNK(366)
IMPL_THUNK(367)
IMPL_THUNK(368)
IMPL_THUNK(369)
IMPL_THUNK(370)
IMPL_THUNK(371)
IMPL_THUNK(372)
IMPL_THUNK(373)
IMPL_THUNK(374)
IMPL_THUNK(375)
IMPL_THUNK(376)
IMPL_THUNK(377)
IMPL_THUNK(378)
IMPL_THUNK(379)
IMPL_THUNK(380)
IMPL_THUNK(381)
IMPL_THUNK(382)
IMPL_THUNK(383)
IMPL_THUNK(384)
IMPL_THUNK(385)
IMPL_THUNK(386)
IMPL_THUNK(387)
IMPL_THUNK(388)
IMPL_THUNK(389)
IMPL_THUNK(390)
IMPL_THUNK(391)
IMPL_THUNK(392)
IMPL_THUNK(393)
IMPL_THUNK(394)
IMPL_THUNK(395)
IMPL_THUNK(396)
IMPL_THUNK(397)
IMPL_THUNK(398)
IMPL_THUNK(399)
IMPL_THUNK(400)
IMPL_THUNK(401)
IMPL_THUNK(402)
IMPL_THUNK(403)
IMPL_THUNK(404)
IMPL_THUNK(405)
IMPL_THUNK(406)
IMPL_THUNK(407)
IMPL_THUNK(408)
IMPL_THUNK(409)
IMPL_THUNK(410)
IMPL_THUNK(411)
IMPL_THUNK(412)
IMPL_THUNK(413)
IMPL_THUNK(414)
IMPL_THUNK(415)
IMPL_THUNK(416)
IMPL_THUNK(417)
IMPL_THUNK(418)
IMPL_THUNK(419)
IMPL_THUNK(420)
IMPL_THUNK(421)
IMPL_THUNK(422)
IMPL_THUNK(423)
IMPL_THUNK(424)
IMPL_THUNK(425)
IMPL_THUNK(426)
IMPL_THUNK(427)
IMPL_THUNK(428)
IMPL_THUNK(429)
IMPL_THUNK(430)
IMPL_THUNK(431)
IMPL_THUNK(432)
IMPL_THUNK(433)
IMPL_THUNK(434)
IMPL_THUNK(435)
IMPL_THUNK(436)
IMPL_THUNK(437)
IMPL_THUNK(438)
IMPL_THUNK(439)
IMPL_THUNK(440)
IMPL_THUNK(441)
IMPL_THUNK(442)
IMPL_THUNK(443)
IMPL_THUNK(444)
IMPL_THUNK(445)
IMPL_THUNK(446)
IMPL_THUNK(447)
IMPL_THUNK(448)
IMPL_THUNK(449)
IMPL_THUNK(450)
IMPL_THUNK(451)
IMPL_THUNK(452)
IMPL_THUNK(453)
IMPL_THUNK(454)
IMPL_THUNK(455)
IMPL_THUNK(456)
IMPL_THUNK(457)
IMPL_THUNK(458)
IMPL_THUNK(459)
IMPL_THUNK(460)
IMPL_THUNK(461)
IMPL_THUNK(462)
IMPL_THUNK(463)
IMPL_THUNK(464)
IMPL_THUNK(465)
IMPL_THUNK(466)
IMPL_THUNK(467)
IMPL_THUNK(468)
IMPL_THUNK(469)
IMPL_THUNK(470)
IMPL_THUNK(471)
IMPL_THUNK(472)
IMPL_THUNK(473)
IMPL_THUNK(474)
IMPL_THUNK(475)
IMPL_THUNK(476)
IMPL_THUNK(477)
IMPL_THUNK(478)
IMPL_THUNK(479)
IMPL_THUNK(480)
IMPL_THUNK(481)
IMPL_THUNK(482)
IMPL_THUNK(483)
IMPL_THUNK(484)
IMPL_THUNK(485)
IMPL_THUNK(486)
IMPL_THUNK(487)
IMPL_THUNK(488)
IMPL_THUNK(489)
IMPL_THUNK(490)
IMPL_THUNK(491)
IMPL_THUNK(492)
IMPL_THUNK(493)
IMPL_THUNK(494)
IMPL_THUNK(495)
IMPL_THUNK(496)
IMPL_THUNK(497)
IMPL_THUNK(498)
IMPL_THUNK(499)
IMPL_THUNK(500)
IMPL_THUNK(501)
IMPL_THUNK(502)
IMPL_THUNK(503)
IMPL_THUNK(504)
IMPL_THUNK(505)
IMPL_THUNK(506)
IMPL_THUNK(507)
IMPL_THUNK(508)
IMPL_THUNK(509)
IMPL_THUNK(510)
IMPL_THUNK(511)
IMPL_THUNK(512)
IMPL_THUNK(513)
IMPL_THUNK(514)
IMPL_THUNK(515)
IMPL_THUNK(516)
IMPL_THUNK(517)
IMPL_THUNK(518)
IMPL_THUNK(519)
IMPL_THUNK(520)
IMPL_THUNK(521)
IMPL_THUNK(522)
IMPL_THUNK(523)
IMPL_THUNK(524)
IMPL_THUNK(525)
IMPL_THUNK(526)
IMPL_THUNK(527)
IMPL_THUNK(528)
IMPL_THUNK(529)
IMPL_THUNK(530)
IMPL_THUNK(531)
IMPL_THUNK(532)
IMPL_THUNK(533)
IMPL_THUNK(534)
IMPL_THUNK(535)
IMPL_THUNK(536)
IMPL_THUNK(537)
IMPL_THUNK(538)
IMPL_THUNK(539)
IMPL_THUNK(540)
IMPL_THUNK(541)
IMPL_THUNK(542)
IMPL_THUNK(543)
IMPL_THUNK(544)
IMPL_THUNK(545)
IMPL_THUNK(546)
IMPL_THUNK(547)
IMPL_THUNK(548)
IMPL_THUNK(549)
IMPL_THUNK(550)
IMPL_THUNK(551)
IMPL_THUNK(552)
IMPL_THUNK(553)
IMPL_THUNK(554)
IMPL_THUNK(555)
IMPL_THUNK(556)
IMPL_THUNK(557)
IMPL_THUNK(558)
IMPL_THUNK(559)
IMPL_THUNK(560)
IMPL_THUNK(561)
IMPL_THUNK(562)
IMPL_THUNK(563)
IMPL_THUNK(564)
IMPL_THUNK(565)
IMPL_THUNK(566)
IMPL_THUNK(567)
IMPL_THUNK(568)
IMPL_THUNK(569)
IMPL_THUNK(570)
IMPL_THUNK(571)
IMPL_THUNK(572)
IMPL_THUNK(573)
IMPL_THUNK(574)
IMPL_THUNK(575)
IMPL_THUNK(576)
IMPL_THUNK(577)
IMPL_THUNK(578)
IMPL_THUNK(579)
IMPL_THUNK(580)
IMPL_THUNK(581)
IMPL_THUNK(582)
IMPL_THUNK(583)
IMPL_THUNK(584)
IMPL_THUNK(585)
IMPL_THUNK(586)
IMPL_THUNK(587)
IMPL_THUNK(588)
IMPL_THUNK(589)
IMPL_THUNK(590)
IMPL_THUNK(591)
IMPL_THUNK(592)
IMPL_THUNK(593)
IMPL_THUNK(594)
IMPL_THUNK(595)
IMPL_THUNK(596)
IMPL_THUNK(597)
IMPL_THUNK(598)
IMPL_THUNK(599)
IMPL_THUNK(600)
IMPL_THUNK(601)
IMPL_THUNK(602)
IMPL_THUNK(603)
IMPL_THUNK(604)
IMPL_THUNK(605)
IMPL_THUNK(606)
IMPL_THUNK(607)
IMPL_THUNK(608)
IMPL_THUNK(609)
IMPL_THUNK(610)
IMPL_THUNK(611)
IMPL_THUNK(612)
IMPL_THUNK(613)
IMPL_THUNK(614)
IMPL_THUNK(615)
IMPL_THUNK(616)
IMPL_THUNK(617)
IMPL_THUNK(618)
IMPL_THUNK(619)
IMPL_THUNK(620)
IMPL_THUNK(621)
IMPL_THUNK(622)
IMPL_THUNK(623)
IMPL_THUNK(624)
IMPL_THUNK(625)
IMPL_THUNK(626)
IMPL_THUNK(627)
IMPL_THUNK(628)
IMPL_THUNK(629)
IMPL_THUNK(630)
IMPL_THUNK(631)
IMPL_THUNK(632)
IMPL_THUNK(633)
IMPL_THUNK(634)
IMPL_THUNK(635)
IMPL_THUNK(636)
IMPL_THUNK(637)
IMPL_THUNK(638)
IMPL_THUNK(639)
IMPL_THUNK(640)
IMPL_THUNK(641)
IMPL_THUNK(642)
IMPL_THUNK(643)
IMPL_THUNK(644)
IMPL_THUNK(645)
IMPL_THUNK(646)
IMPL_THUNK(647)
IMPL_THUNK(648)
IMPL_THUNK(649)
IMPL_THUNK(650)
IMPL_THUNK(651)
IMPL_THUNK(652)
IMPL_THUNK(653)
IMPL_THUNK(654)
IMPL_THUNK(655)
IMPL_THUNK(656)
IMPL_THUNK(657)
IMPL_THUNK(658)
IMPL_THUNK(659)
IMPL_THUNK(660)
IMPL_THUNK(661)
IMPL_THUNK(662)
IMPL_THUNK(663)
IMPL_THUNK(664)
IMPL_THUNK(665)
IMPL_THUNK(666)
IMPL_THUNK(667)
IMPL_THUNK(668)
IMPL_THUNK(669)
IMPL_THUNK(670)
IMPL_THUNK(671)
IMPL_THUNK(672)
IMPL_THUNK(673)
IMPL_THUNK(674)
IMPL_THUNK(675)
IMPL_THUNK(676)
IMPL_THUNK(677)
IMPL_THUNK(678)
IMPL_THUNK(679)
IMPL_THUNK(680)
IMPL_THUNK(681)
IMPL_THUNK(682)
IMPL_THUNK(683)
IMPL_THUNK(684)
IMPL_THUNK(685)
IMPL_THUNK(686)
IMPL_THUNK(687)
IMPL_THUNK(688)
IMPL_THUNK(689)
IMPL_THUNK(690)
IMPL_THUNK(691)
IMPL_THUNK(692)
IMPL_THUNK(693)
IMPL_THUNK(694)
IMPL_THUNK(695)
IMPL_THUNK(696)
IMPL_THUNK(697)
IMPL_THUNK(698)
IMPL_THUNK(699)
IMPL_THUNK(700)
IMPL_THUNK(701)
IMPL_THUNK(702)
IMPL_THUNK(703)
IMPL_THUNK(704)
IMPL_THUNK(705)
IMPL_THUNK(706)
IMPL_THUNK(707)
IMPL_THUNK(708)
IMPL_THUNK(709)
IMPL_THUNK(710)
IMPL_THUNK(711)
IMPL_THUNK(712)
IMPL_THUNK(713)
IMPL_THUNK(714)
IMPL_THUNK(715)
IMPL_THUNK(716)
IMPL_THUNK(717)
IMPL_THUNK(718)
IMPL_THUNK(719)
IMPL_THUNK(720)
IMPL_THUNK(721)
IMPL_THUNK(722)
IMPL_THUNK(723)
IMPL_THUNK(724)
IMPL_THUNK(725)
IMPL_THUNK(726)
IMPL_THUNK(727)
IMPL_THUNK(728)
IMPL_THUNK(729)
IMPL_THUNK(730)
IMPL_THUNK(731)
IMPL_THUNK(732)
IMPL_THUNK(733)
IMPL_THUNK(734)
IMPL_THUNK(735)
IMPL_THUNK(736)
IMPL_THUNK(737)
IMPL_THUNK(738)
IMPL_THUNK(739)
IMPL_THUNK(740)
IMPL_THUNK(741)
IMPL_THUNK(742)
IMPL_THUNK(743)
IMPL_THUNK(744)
IMPL_THUNK(745)
IMPL_THUNK(746)
IMPL_THUNK(747)
IMPL_THUNK(748)
IMPL_THUNK(749)
IMPL_THUNK(750)
IMPL_THUNK(751)
IMPL_THUNK(752)
IMPL_THUNK(753)
IMPL_THUNK(754)
IMPL_THUNK(755)
IMPL_THUNK(756)
IMPL_THUNK(757)
IMPL_THUNK(758)
IMPL_THUNK(759)
IMPL_THUNK(760)
IMPL_THUNK(761)
IMPL_THUNK(762)
IMPL_THUNK(763)
IMPL_THUNK(764)
IMPL_THUNK(765)
IMPL_THUNK(766)
IMPL_THUNK(767)
IMPL_THUNK(768)
IMPL_THUNK(769)
IMPL_THUNK(770)
IMPL_THUNK(771)
IMPL_THUNK(772)
IMPL_THUNK(773)
IMPL_THUNK(774)
IMPL_THUNK(775)
IMPL_THUNK(776)
IMPL_THUNK(777)
IMPL_THUNK(778)
IMPL_THUNK(779)
IMPL_THUNK(780)
IMPL_THUNK(781)
IMPL_THUNK(782)
IMPL_THUNK(783)
IMPL_THUNK(784)
IMPL_THUNK(785)
IMPL_THUNK(786)
IMPL_THUNK(787)
IMPL_THUNK(788)
IMPL_THUNK(789)
IMPL_THUNK(790)
IMPL_THUNK(791)
IMPL_THUNK(792)
IMPL_THUNK(793)
IMPL_THUNK(794)
IMPL_THUNK(795)
IMPL_THUNK(796)
IMPL_THUNK(797)
IMPL_THUNK(798)
IMPL_THUNK(799)
IMPL_THUNK(800)
IMPL_THUNK(801)
IMPL_THUNK(802)
IMPL_THUNK(803)
IMPL_THUNK(804)
IMPL_THUNK(805)
IMPL_THUNK(806)
IMPL_THUNK(807)
IMPL_THUNK(808)
IMPL_THUNK(809)
IMPL_THUNK(810)
IMPL_THUNK(811)
IMPL_THUNK(812)
IMPL_THUNK(813)
IMPL_THUNK(814)
IMPL_THUNK(815)
IMPL_THUNK(816)
IMPL_THUNK(817)
IMPL_THUNK(818)
IMPL_THUNK(819)
IMPL_THUNK(820)
IMPL_THUNK(821)
IMPL_THUNK(822)
IMPL_THUNK(823)
IMPL_THUNK(824)
IMPL_THUNK(825)
IMPL_THUNK(826)
IMPL_THUNK(827)
IMPL_THUNK(828)
IMPL_THUNK(829)
IMPL_THUNK(830)
IMPL_THUNK(831)
IMPL_THUNK(832)
IMPL_THUNK(833)
IMPL_THUNK(834)
IMPL_THUNK(835)
IMPL_THUNK(836)
IMPL_THUNK(837)
IMPL_THUNK(838)
IMPL_THUNK(839)
IMPL_THUNK(840)
IMPL_THUNK(841)
IMPL_THUNK(842)
IMPL_THUNK(843)
IMPL_THUNK(844)
IMPL_THUNK(845)
IMPL_THUNK(846)
IMPL_THUNK(847)
IMPL_THUNK(848)
IMPL_THUNK(849)
IMPL_THUNK(850)
IMPL_THUNK(851)
IMPL_THUNK(852)
IMPL_THUNK(853)
IMPL_THUNK(854)
IMPL_THUNK(855)
IMPL_THUNK(856)
IMPL_THUNK(857)
IMPL_THUNK(858)
IMPL_THUNK(859)
IMPL_THUNK(860)
IMPL_THUNK(861)
IMPL_THUNK(862)
IMPL_THUNK(863)
IMPL_THUNK(864)
IMPL_THUNK(865)
IMPL_THUNK(866)
IMPL_THUNK(867)
IMPL_THUNK(868)
IMPL_THUNK(869)
IMPL_THUNK(870)
IMPL_THUNK(871)
IMPL_THUNK(872)
IMPL_THUNK(873)
IMPL_THUNK(874)
IMPL_THUNK(875)
IMPL_THUNK(876)
IMPL_THUNK(877)
IMPL_THUNK(878)
IMPL_THUNK(879)
IMPL_THUNK(880)
IMPL_THUNK(881)
IMPL_THUNK(882)
IMPL_THUNK(883)
IMPL_THUNK(884)
IMPL_THUNK(885)
IMPL_THUNK(886)
IMPL_THUNK(887)
IMPL_THUNK(888)
IMPL_THUNK(889)
IMPL_THUNK(890)
IMPL_THUNK(891)
IMPL_THUNK(892)
IMPL_THUNK(893)
IMPL_THUNK(894)
IMPL_THUNK(895)
IMPL_THUNK(896)
IMPL_THUNK(897)
IMPL_THUNK(898)
IMPL_THUNK(899)
IMPL_THUNK(900)
IMPL_THUNK(901)
IMPL_THUNK(902)
IMPL_THUNK(903)
IMPL_THUNK(904)
IMPL_THUNK(905)
IMPL_THUNK(906)
IMPL_THUNK(907)
IMPL_THUNK(908)
IMPL_THUNK(909)
IMPL_THUNK(910)
IMPL_THUNK(911)
IMPL_THUNK(912)
IMPL_THUNK(913)
IMPL_THUNK(914)
IMPL_THUNK(915)
IMPL_THUNK(916)
IMPL_THUNK(917)
IMPL_THUNK(918)
IMPL_THUNK(919)
IMPL_THUNK(920)
IMPL_THUNK(921)
IMPL_THUNK(922)
IMPL_THUNK(923)
IMPL_THUNK(924)
IMPL_THUNK(925)
IMPL_THUNK(926)
IMPL_THUNK(927)
IMPL_THUNK(928)
IMPL_THUNK(929)
IMPL_THUNK(930)
IMPL_THUNK(931)
IMPL_THUNK(932)
IMPL_THUNK(933)
IMPL_THUNK(934)
IMPL_THUNK(935)
IMPL_THUNK(936)
IMPL_THUNK(937)
IMPL_THUNK(938)
IMPL_THUNK(939)
IMPL_THUNK(940)
IMPL_THUNK(941)
IMPL_THUNK(942)
IMPL_THUNK(943)
IMPL_THUNK(944)
IMPL_THUNK(945)
IMPL_THUNK(946)
IMPL_THUNK(947)
IMPL_THUNK(948)
IMPL_THUNK(949)
IMPL_THUNK(950)
IMPL_THUNK(951)
IMPL_THUNK(952)
IMPL_THUNK(953)
IMPL_THUNK(954)
IMPL_THUNK(955)
IMPL_THUNK(956)
IMPL_THUNK(957)
IMPL_THUNK(958)
IMPL_THUNK(959)
IMPL_THUNK(960)
IMPL_THUNK(961)
IMPL_THUNK(962)
IMPL_THUNK(963)
IMPL_THUNK(964)
IMPL_THUNK(965)
IMPL_THUNK(966)
IMPL_THUNK(967)
IMPL_THUNK(968)
IMPL_THUNK(969)
IMPL_THUNK(970)
IMPL_THUNK(971)
IMPL_THUNK(972)
IMPL_THUNK(973)
IMPL_THUNK(974)
IMPL_THUNK(975)
IMPL_THUNK(976)
IMPL_THUNK(977)
IMPL_THUNK(978)
IMPL_THUNK(979)
IMPL_THUNK(980)
IMPL_THUNK(981)
IMPL_THUNK(982)
IMPL_THUNK(983)
IMPL_THUNK(984)
IMPL_THUNK(985)
IMPL_THUNK(986)
IMPL_THUNK(987)
IMPL_THUNK(988)
IMPL_THUNK(989)
IMPL_THUNK(990)
IMPL_THUNK(991)
IMPL_THUNK(992)
IMPL_THUNK(993)
IMPL_THUNK(994)
IMPL_THUNK(995)
IMPL_THUNK(996)
IMPL_THUNK(997)
IMPL_THUNK(998)
IMPL_THUNK(999)
IMPL_THUNK(1000)
IMPL_THUNK(1001)
IMPL_THUNK(1002)
IMPL_THUNK(1003)
IMPL_THUNK(1004)
IMPL_THUNK(1005)
IMPL_THUNK(1006)
IMPL_THUNK(1007)
IMPL_THUNK(1008)
IMPL_THUNK(1009)
IMPL_THUNK(1010)
IMPL_THUNK(1011)
IMPL_THUNK(1012)
IMPL_THUNK(1013)
IMPL_THUNK(1014)
IMPL_THUNK(1015)
IMPL_THUNK(1016)
IMPL_THUNK(1017)
IMPL_THUNK(1018)
IMPL_THUNK(1019)
IMPL_THUNK(1020)
IMPL_THUNK(1021)
IMPL_THUNK(1022)
IMPL_THUNK(1023)
IMPL_THUNK(1024)

#endif

__declspec(selectany) GUID CComModule::m_libid = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
	_ATL_CREATORFUNC* pfnCreateInstance;
	const IID* piid;
	HANDLE hEvent;
	LPSTREAM pStream;
	HRESULT hRes;
};

class CComApartment
{
public:
	CComApartment()
	{
		m_nLockCnt = 0;
	}
	static UINT ATL_CREATE_OBJECT;
	static DWORD WINAPI _Apartment(void* pv)
	{
		return ((CComApartment*)pv)->Apartment();
	}
	DWORD Apartment()
	{
		CoInitialize(NULL);
		MSG msg;
		while(GetMessage(&msg, 0, 0, 0))
		{
			if (msg.message == ATL_CREATE_OBJECT)
			{
				_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
				IUnknown* pUnk = NULL;
				pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
				if (SUCCEEDED(pdata->hRes))
					pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
				if (SUCCEEDED(pdata->hRes))
				{
					pUnk->Release();
					ATLTRACE2(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
				}
				SetEvent(pdata->hEvent);
			}
			DispatchMessage(&msg);
		}
		CoUninitialize();
		return 0;
	}
	LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
	LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount() {return m_nLockCnt;}

	DWORD m_dwThreadID;
	HANDLE m_hThread;
	LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
	CComSimpleThreadAllocator()
	{
		m_nThread = 0;
	}
	int GetThread(CComApartment* /*pApt*/, int nThreads)
	{
		if (++m_nThread == nThreads)
			m_nThread = 0;
		return m_nThread;
	}
	int m_nThread;
};

template <class ThreadAllocator = CComSimpleThreadAllocator>
class CComAutoThreadModule : public CComModule
{
public:
	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL, int nThreads = GetDefaultThreads());
	~CComAutoThreadModule();
	HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
	LONG Lock();
	LONG Unlock();
	DWORD dwThreadID;
	int m_nThreads;
	CComApartment* m_pApartments;
	ThreadAllocator m_Allocator;
	static int GetDefaultThreads()
	{
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		return si.dwNumberOfProcessors * 4;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	/*explicit*/ CComBSTR(int nSize)
	{
		m_str = ::SysAllocStringLen(NULL, nSize);
	}
	/*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	/*explicit*/ CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	/*explicit*/ CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	/*explicit*/ CComBSTR(REFGUID src)
	{
		LPOLESTR szGuid;
		StringFromCLSID(src, &szGuid);
		m_str = ::SysAllocString(szGuid);
		CoTaskMemFree(szGuid);
	}
	CComBSTR& operator=(const CComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			if (m_str)
				::SysFreeString(m_str);
			m_str = src.Copy();
		}
		return *this;
	}

	CComBSTR& operator=(LPCOLESTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = ::SysAllocString(pSrc);
		return *this;
	}

	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	HRESULT CopyTo(BSTR* pbstr)
	{
		ATLASSERT(pbstr != NULL);
		if (pbstr == NULL)
			return E_POINTER;
		*pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
		if (*pbstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}
	void Attach(BSTR src)
	{
		ATLASSERT(m_str == NULL);
		m_str = src;
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const
	{
		return (m_str == NULL);
	}
	HRESULT Append(const CComBSTR& bstrSrc)
	{
		return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
	}
	HRESULT Append(LPCOLESTR lpsz)
	{
		return Append(lpsz, ocslen(lpsz));
	}
	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	HRESULT AppendBSTR(BSTR p)
	{
		return Append(p, SysStringLen(p));
	}
	HRESULT Append(LPCOLESTR lpsz, int nLen)
	{
		int n1 = Length();
		BSTR b;
		b = ::SysAllocStringLen(NULL, n1+nLen);
		if (b == NULL)
			return E_OUTOFMEMORY;
		memcpy(b, m_str, n1*sizeof(OLECHAR));
		memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
		b[n1+nLen] = NULL;
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}
	HRESULT ToLower()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharLower(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	HRESULT ToUpper()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharUpper(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	bool LoadString(HINSTANCE hInst, UINT nID)
	{
		USES_CONVERSION;
		TCHAR sz[512];
		UINT nLen = ::LoadString(hInst, nID, sz, 512);
		ATLASSERT(nLen < 511);
		SysFreeString(m_str);
		m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
		return (nLen != 0);
	}
	bool LoadString(UINT nID)
	{
		return LoadString(_pModule->m_hInstResource, nID);
	}

	CComBSTR& operator+=(const CComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
		return *this;
	}
	bool operator<(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return false;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) < 0;
		return m_str == NULL;
	}
	bool operator==(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return true;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) == 0;
		return false;
	}
	bool operator<(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return false;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) < 0;
		return m_str == NULL;
	}
	bool operator==(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return true;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) == 0;
		return false;
	}
#ifndef OLE2ANSI
	CComBSTR(LPCSTR pSrc)
	{
		m_str = A2WBSTR(pSrc);
	}

	CComBSTR(int nSize, LPCSTR sz)
	{
		m_str = A2WBSTR(sz, nSize);
	}

	void Append(LPCSTR lpsz)
	{
		USES_CONVERSION;
		LPCOLESTR lpo = A2COLE(lpsz);
		Append(lpo, ocslen(lpo));
	}

	CComBSTR& operator=(LPCSTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = A2WBSTR(pSrc);
		return *this;
	}
#endif
	HRESULT WriteToStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ULONG cb;
		ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0;
		HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
		if (FAILED(hr))
			return hr;
		return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
	}
	HRESULT ReadFromStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ATLASSERT(m_str == NULL); // should be empty
		ULONG cbStrLen = 0;
		HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
		if ((hr == S_OK) && (cbStrLen != 0))
		{
			//subtract size for terminating NULL which we wrote out
			//since SysAllocStringByteLen overallocates for the NULL
			m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
			if (m_str == NULL)
				hr = E_OUTOFMEMORY;
			else
				hr = pStream->Read((void*) m_str, cbStrLen, NULL);
		}
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
	CComVariant()
	{
		vt = VT_EMPTY;
	}
	~CComVariant()
	{
		Clear();
	}

	CComVariant(const VARIANT& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(const CComVariant& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(BSTR bstrSrc)
	{
		vt = VT_EMPTY;
		*this = bstrSrc;
	}
	CComVariant(LPCOLESTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}

#ifndef OLE2ANSI
	CComVariant(LPCSTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
#endif

	CComVariant(bool bSrc)
	{
		vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	}

	CComVariant(int nSrc)
	{
		vt = VT_I4;
		lVal = nSrc;
	}
	CComVariant(BYTE nSrc)
	{
		vt = VT_UI1;
		bVal = nSrc;
	}
	CComVariant(short nSrc)
	{
		vt = VT_I2;
		iVal = nSrc;
	}
	CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		vt = vtSrc;
		lVal = nSrc;
	}
	CComVariant(float fltSrc)
	{
		vt = VT_R4;
		fltVal = fltSrc;
	}
	CComVariant(double dblSrc)
	{
		vt = VT_R8;
		dblVal = dblSrc;
	}
	CComVariant(CY cySrc)
	{
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	CComVariant(IDispatch* pSrc)
	{
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	CComVariant(IUnknown* pSrc)
	{
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}

// Assignment Operators
public:
	CComVariant& operator=(const CComVariant& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}
	CComVariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	CComVariant& operator=(BSTR bstrSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(bstrSrc);
		if (bstrVal == NULL && bstrSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	CComVariant& operator=(LPCOLESTR lpszSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpszSrc)
	{
		USES_CONVERSION;
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(A2COLE(lpszSrc));

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}
	#endif

	CComVariant& operator=(bool bSrc)
	{
		if (vt != VT_BOOL)
		{
			InternalClear();
			vt = VT_BOOL;
		}
	#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
	#pragma warning(default: 4310) // cast truncates constant value
		return *this;
	}

	CComVariant& operator=(int nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;

		return *this;
	}

	CComVariant& operator=(BYTE nSrc)
	{
		if (vt != VT_UI1)
		{
			InternalClear();
			vt = VT_UI1;
		}
		bVal = nSrc;
		return *this;
	}

	CComVariant& operator=(short nSrc)
	{
		if (vt != VT_I2)
		{
			InternalClear();
			vt = VT_I2;
		}
		iVal = nSrc;
		return *this;
	}

	CComVariant& operator=(long nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	CComVariant& operator=(float fltSrc)
	{
		if (vt != VT_R4)
		{
			InternalClear();
			vt = VT_R4;
		}
		fltVal = fltSrc;
		return *this;
	}

	CComVariant& operator=(double dblSrc)
	{
		if (vt != VT_R8)
		{
			InternalClear();
			vt = VT_R8;
		}
		dblVal = dblSrc;
		return *this;
	}

	CComVariant& operator=(CY cySrc)
	{
		if (vt != VT_CY)
		{
			InternalClear();
			vt = VT_CY;
		}
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
		return *this;
	}

	CComVariant& operator=(IDispatch* pSrc)
	{
		InternalClear();
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
		return *this;
	}

	CComVariant& operator=(IUnknown* pSrc)
	{
		InternalClear();
		vt = VT_UNKNOWN;
		punkVal = pSrc;

		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
		return *this;
	}


// Comparison Operators
public:
	bool operator==(const VARIANT& varSrc) const
	{
		if (this == &varSrc)
			return true;

		// Variants not equal if types don't match
		if (vt != varSrc.vt)
			return false;

		// Check type specific values
		switch (vt)
		{
			case VT_EMPTY:
			case VT_NULL:
				return true;

			case VT_BOOL:
				return boolVal == varSrc.boolVal;

			case VT_UI1:
				return bVal == varSrc.bVal;

			case VT_I2:
				return iVal == varSrc.iVal;

			case VT_I4:
				return lVal == varSrc.lVal;

			case VT_R4:
				return fltVal == varSrc.fltVal;

			case VT_R8:
				return dblVal == varSrc.dblVal;

			case VT_BSTR:
				return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
						(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

			case VT_ERROR:
				return scode == varSrc.scode;

			case VT_DISPATCH:
				return pdispVal == varSrc.pdispVal;

			case VT_UNKNOWN:
				return punkVal == varSrc.punkVal;

			default:
				ATLASSERT(false);
				// fall through
		}

		return false;
	}
	bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
	bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_LT;}
	bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_GT;}

// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
	HRESULT Attach(VARIANT* pSrc)
	{
		// Clear out the variant
		HRESULT hr = Clear();
		if (!FAILED(hr))
		{
			// Copy the contents and give control to CComVariant
			memcpy(this, pSrc, sizeof(VARIANT));
			pSrc->vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT Detach(VARIANT* pDest)
	{
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (!FAILED(hr))
		{
			// Copy the contents and remove control from CComVariant
			memcpy(pDest, this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
	{
		VARIANT* pVar = const_cast<VARIANT*>(pSrc);
		// Convert in place if pSrc is NULL
		if (pVar == NULL)
			pVar = this;
		// Do nothing if doing in place convert and vts not different
		return ::VariantChangeType(this, pVar, 0, vtNew);
	}

	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
	HRESULT InternalClear()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
		return hr;
	}

	void InternalCopy(const VARIANT* pSrc)
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
	}
};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
				if (FAILED(hr))
					return hr;
			}
			if (spStream != NULL)
				return OleSaveToStream(spStream, pStream);
			else
				return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
		bstrWrite = bstrVal;

	return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
	ATLASSERT(pStream != NULL);
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead;
	hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
	if (hr == S_FALSE)
		hr = E_FAIL;
	if (FAILED(hr))
		return hr;

	vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = OleLoadFromStream(pStream,
				(vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
				(void**)&punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
	{
		hr = pStream->Read((void*) &bVal, cbRead, NULL);
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
		return hr;
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey();
	~CRegKey();

// Attributes
public:
	operator HKEY() const;
	HKEY m_hKey;

// Operations
public:
	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL);
	LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_ALL_ACCESS);
	LONG Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	LONG DeleteSubKey(LPCTSTR lpszSubKey);
	LONG RecurseDeleteKey(LPCTSTR lpszKey);
	LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	ATLASSERT(m_hKey == NULL);
	m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	ATLASSERT(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	ATLASSERT(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		ATLASSERT(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

inline LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
	ATLASSERT(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

inline LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

inline LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	ATLASSERT(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	ATLASSERT(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	DWORD dwSize = 256;
	TCHAR szBuffer[256];
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

inline HRESULT CComModule::RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

// Statically linking to Registry Ponent
inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	ATL::CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
   TCHAR szModuleShort[_MAX_PATH];
   GetShortPathName(szModule, szModuleShort, _MAX_PATH);
   LPOLESTR pszModule = T2OLE(szModuleShort);

	int nLen = ocslen(pszModule);
	LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
	ReplaceSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
			ro.ResourceUnregister(pszModule, nResID, szType);
}

inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	ATL::CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
   TCHAR szModuleShort[_MAX_PATH];
   GetShortPathName(szModule, szModuleShort, _MAX_PATH);
   LPOLESTR pszModule = T2OLE(szModuleShort);

	int nLen = ocslen(pszModule);
	LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
	ReplaceSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	LPCOLESTR pszRes = T2COLE(lpszRes);
	return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
			ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif //_ATL_STATIC_REGISTRY

inline HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(m_hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

	hRes = RegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = RegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
			{
			   // Convert to short path to work around bug in NT4's CreateProcess
			   TCHAR szModuleShort[_MAX_PATH];
			   GetShortPathName(szModule, szModuleShort, _MAX_PATH);
					key.SetKeyValue(szLS32, szModuleShort);
			}
				else
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION;
	CRegKey key;

	key.Attach(HKEY_CLASSES_ROOT);
	if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
		key.RecurseDeleteKey(lpszProgID);
	if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
		key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	if (key.Open(key, _T("CLSID"), KEY_READ) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer


template <class T>
class CVBufHelper
{
public:
	virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
	CVirtualBuffer() {}
	T* m_pBase;
	T* m_pCurrent;
	T* m_pTop;
	int m_nMaxElements;
public:
	CVirtualBuffer(int nMaxElements)
	{
		m_nMaxElements = nMaxElements;
		m_pBase = (T*) VirtualAlloc(NULL, sizeof(T) * nMaxElements,
			MEM_RESERVE, PAGE_READWRITE);
		m_pTop = m_pCurrent = m_pBase;
		// Commit first page - chances are this is all that will be used
		VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
	}
	~CVirtualBuffer()
	{
		VirtualFree(m_pBase, 0, MEM_RELEASE);
	}
	int Except(LPEXCEPTION_POINTERS lpEP)
	{
		EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
		if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
			return EXCEPTION_CONTINUE_SEARCH;
		BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
		VirtualAlloc(pAddress, ((BYTE*)m_pTop - (BYTE*)m_pBase), MEM_COMMIT, PAGE_READWRITE);
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	void Seek(int nElement)
	{
		m_pCurrent = &m_pBase[nElement];
	}
	void SetAt(int nElement, const T& Element)
	{
		__try
		{
			T* p = &m_pBase[nElement]
			*p = Element;
			m_pTop = p > m_pTop ? p : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}

	}
	template <class Q>
	void WriteBulk(Q& helper)
	{
		__try
		{
			m_pCurrent = helper(m_pBase);
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	void Write(const T& Element)
	{
		__try
		{
			*m_pCurrent = Element;
			m_pCurrent++;
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	T& Read()
	{
		return *m_pCurrent;
	}
	operator BSTR()
	{
		BSTR bstrTemp;
		__try
		{
			bstrTemp = SysAllocStringByteLen((char*) m_pBase,
				(UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
		}
		__except(Except(GetExceptionInformation()))
		{
		}
		return bstrTemp;
	}
	const T& operator[](int nElement) const
	{
		return m_pBase[nElement];
	}
	operator T*()
	{
		return m_pBase;
	}
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;


inline HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	if (atlTraceQI & ATL_TRACE_CATEGORY)
	{
		USES_CONVERSION;
		CRegKey key;
		TCHAR szName[100];
		DWORD dwType,dw = sizeof(szName);

		LPOLESTR pszGUID = NULL;
		StringFromCLSID(iid, &pszGUID);
		OutputDebugString(pszClassName);
		OutputDebugString(_T(" - "));

		// Attempt to find it in the interfaces section
		key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ);
		if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
		{
			*szName = 0;
			RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
			OutputDebugString(szName);
			goto cleanup;
		}
		// Attempt to find it in the clsid section
		key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
		if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
		{
			*szName = 0;
			RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
			OutputDebugString(_T("(CLSID\?\?\?) "));
			OutputDebugString(szName);
			goto cleanup;
		}
		OutputDebugString(OLE2T(pszGUID));
	cleanup:
		if (hr != S_OK)
			OutputDebugString(_T(" - failed"));
		OutputDebugString(_T("\n"));
		CoTaskMemFree(pszGUID);
	}
	return hr;
}

#pragma pack(pop)

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG       0x037F

}; //namespace ATL
using namespace ATL;

//only suck in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#ifdef _ATL_REDEF_NEW
#pragma pop_macro("new")
#undef _ATL_REDEF_NEW
#endif

#endif // __ATLBASE_H__

//All exports go here
#ifdef _ATLBASE_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	ATLASSERT(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return lpszTemp-lpszPathName;
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	ATLASSERT(pThis != NULL);
	// First entry in the com map should be a simple map entry
	ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return S_OK;
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
			{
				ATLASSERT(!bBlind);
				IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return S_OK;
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return hRes;
			}
		}
		pEntries++;
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
	return S_OK;
}

ATLINLINE ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

ATLINLINE ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	while(1)
	{
		dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

		if (dwRet == WAIT_OBJECT_0)
			return TRUE;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			break;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return TRUE; // Event is now signaled.
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	USES_CONVERSION;
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	if (HIWORD(lpszDesc) == 0) //id
	{
		UINT nID = LOWORD((DWORD)lpszDesc);
		ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
		if (LoadString(hInst, nID, szDesc, 1024) == 0)
		{
			ATLASSERT(FALSE);
			lstrcpy(szDesc, _T("Unknown Error"));
		}
		lpszDesc = T2OLE(szDesc);
		if (hRes == 0)
			hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	}

	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		if (dwHelpID != 0 && lpszHelpFile != NULL)
		{
			pICEI->SetHelpContext(dwHelpID);
			pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
		}
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

struct _ATL_MODULE20
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	CRITICAL_SECTION m_csTypeInfoHolder;
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
};

typedef _ATL_MODULE _ATL_MODULE30;

struct _ATL_OBJMAP_ENTRY20
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
};

typedef _ATL_OBJMAP_ENTRY _ATL_OBJMAP_ENTRY30;

inline _ATL_OBJMAP_ENTRY* _NextObjectMapEntry(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* pEntry)
{
	if (pM->cbSize == sizeof(_ATL_MODULE20))
		return (_ATL_OBJMAP_ENTRY*)(((BYTE*)pEntry) + sizeof(_ATL_OBJMAP_ENTRY20));
	return pEntry+1;
}

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLINLINE ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
#ifdef _ATL_DLL_IMPL
	if ((pM->cbSize != _nAtlModuleVer1Size) && (pM->cbSize != sizeof(_ATL_MODULE)))
		return E_INVALIDARG;
#else
	ATLASSERT(pM->cbSize == sizeof(_ATL_MODULE));
#endif
	pM->m_pObjMap = p;
	pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
	pM->m_nLockCnt=0L;
	pM->m_hHeap = NULL;
	InitializeCriticalSection(&pM->m_csTypeInfoHolder);
	InitializeCriticalSection(&pM->m_csWindowCreate);
	InitializeCriticalSection(&pM->m_csObjMap);
#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer1Size)
#endif
	{
		pM->m_pCreateWndList = NULL;
		pM->m_bDestroyHeap = true;
		pM->m_dwHeaps = 0;
		pM->m_nHeap = 0;
		pM->m_phHeaps = NULL;
		pM->m_pTermFuncs = NULL;
		if (pM->m_pObjMap != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
			while (pEntry->pclsid != NULL)
			{
				pEntry->pfnObjectMain(true); //initialize class resources
				pEntry = _NextObjectMapEntry(pM, pEntry);
			}
		}
	}

	return S_OK;
}

ATLINLINE ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	return hRes;
}

ATLINLINE ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	return hRes;
}

ATLINLINE ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	*ppv = NULL;
	while (pEntry->pclsid != NULL)
	{
		if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
			{
				EnterCriticalSection(&pM->m_csObjMap);
				if (pEntry->pCF == NULL)
					hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
				LeaveCriticalSection(&pM->m_csObjMap);
			}
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

ATLINLINE ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	if (pM->m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
#ifdef _ATL_DLL_IMPL
			if (pM->cbSize > _nAtlModuleVer1Size)
#endif
				pEntry->pfnObjectMain(false); //cleanup class resources
			pEntry = _NextObjectMapEntry(pM, pEntry);
		}
	}
	DeleteCriticalSection(&pM->m_csTypeInfoHolder);
	DeleteCriticalSection(&pM->m_csWindowCreate);
	DeleteCriticalSection(&pM->m_csObjMap);

#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer1Size)
#endif
	{
		_ATL_TERMFUNC_ELEM* pElem = pM->m_pTermFuncs;
		_ATL_TERMFUNC_ELEM* pNext = NULL;
		while (pElem != NULL)
		{
			pElem->pFunc(pElem->dw);
			pNext = pElem->pNext;
			delete pElem;
			pElem = pNext;
		}
		if (pM->m_hHeap != NULL && pM->m_bDestroyHeap)
		{
#ifndef _ATL_NO_MP_HEAP
			if (pM->m_phHeaps != NULL)
			{
				for (DWORD i = 0; i <= pM->m_dwHeaps; i++)
					HeapDestroy(pM->m_phHeaps[i]);
			}
#endif
			HeapDestroy(pM->m_hHeap);
		}
	}
	return S_OK;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD dw)
{
	HRESULT hr = S_OK;
	_ATL_TERMFUNC_ELEM* pNew = NULL;
	ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
	if (pNew == NULL)
		hr = E_OUTOFMEMORY;
	else
	{
		pNew->pFunc = pFunc;
		pNew->dw = dw;
		EnterCriticalSection(&pM->m_csStaticDataInit);
		pNew->pNext = pM->m_pTermFuncs;
		pM->m_pTermFuncs = pNew;
		LeaveCriticalSection(&pM->m_csStaticDataInit);
	}
	return hr;
}

ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid,
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
	  return( S_OK );
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
	  CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
	  // Since not all systems have the category manager installed, we'll allow
	  // the registration to succeed even though we didn't register our
	  // categories.  If you really want to register categories on a system
	  // without the category manager, you can either manually add the
	  // appropriate entries to your registry script (.rgs), or you can
	  // redistribute comcat.dll.
	  return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
	  catid = *pEntry->pcatid;
	  if( bRegister )
	  {
		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
		 {
			hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
			   &catid );
		 }
		 else
		 {
			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
			hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
			   &catid );
		 }
		 if( FAILED( hResult ) )
		 {
			return( hResult );
		 }
	  }
	  else
	  {
		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
		 {
			pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
		 }
		 else
		 {
			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
			pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
		 }
	  }
	  pEntry++;
   }

   return( S_OK );
}

ATLINLINE ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription != NULL &&
				pEntry->pfnGetObjectDescription() != NULL)
					continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		hRes = pEntry->pfnUpdateRegistry(TRUE);
		if (FAILED(hRes))
			break;
		if (pM->cbSize == sizeof(_ATL_MODULE))
		{
			hRes = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
				pEntry->pfnGetCategoryMap(), TRUE );
			if (FAILED(hRes))
				break;
		}
	}
	if (SUCCEEDED(hRes) && bRegTypeLib)
		hRes = AtlModuleRegisterTypeLib(pM, 0);
	return hRes;
}

ATLINLINE ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription != NULL
				&& pEntry->pfnGetObjectDescription() != NULL)
				continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		pEntry->pfnUpdateRegistry(FALSE); //unregister
		AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
			pEntry->pfnGetCategoryMap(), FALSE );
	}
	if (bUnRegTypeLib)
		AtlModuleUnRegisterTypeLib(pM, 0);
	return S_OK;
}

ATLINLINE ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
	return AtlModuleUnregisterServerEx(pM, FALSE, pCLSID);
}

ATLINLINE ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
	USES_CONVERSION;
	ATLASSERT(pM != NULL);
	HRESULT hRes = S_OK;
	CComPtr<IRegistrar> p;
	if (pReg != NULL)
		p = pReg;
	else
	{
		hRes = CoCreateInstance(CLSID_Registrar, NULL,
			CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
	}
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);

	  // Convert to short path to work around bug in NT4's CreateProcess
	  TCHAR szModuleShort[_MAX_PATH];
	  GetShortPathName(szModule, szModuleShort, _MAX_PATH);
	  LPOLESTR pszModule = T2OLE(szModuleShort);

		int nLen = ocslen(pszModule);
		LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
		CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
		p->AddReplacement(OLESTR("Module"), pszModuleQuote);

		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				ATLASSERT(NULL != pMapEntries->szData);
				p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
				pMapEntries++;
			}
		}
		LPCOLESTR szType = OLESTR("REGISTRY");
		if (HIWORD(lpszRes)==0)
		{
			if (bRegister)
				hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
			else
				hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
		}
		else
		{
			if (bRegister)
				hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
			else
				hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
		}

	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLINLINE ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
	*pbstrPath = NULL;
	*ppTypeLib = NULL;
	ATLASSERT(pM != NULL);
	USES_CONVERSION;
	ATLASSERT(pM->m_hInstTypeLib != NULL);
	TCHAR szModule[_MAX_PATH+10];
	GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
	if (lpszIndex != NULL)
		lstrcat(szModule, OLE2CT(lpszIndex));
	LPOLESTR lpszModule = T2OLE(szModule);
	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE(szModule);
		hr = LoadTypeLib(lpszModule, ppTypeLib);
	}
	if (SUCCEEDED(hr))
		*pbstrPath = OLE2BSTR(lpszModule);
	return hr;
}

ATLINLINE ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	typedef HRESULT (WINAPI *PFNRTL)(REFGUID, WORD, WORD, LCID, SYSKIND);
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		TLIBATTR* ptla;
		HRESULT hr = pTypeLib->GetLibAttr(&ptla);
		if (SUCCEEDED(hr))
		{
			HINSTANCE h = LoadLibrary(_T("oleaut32.dll"));
			if (h != NULL)
			{
				PFNRTL pfn = (PFNRTL) GetProcAddress(h, "UnRegisterTypeLib");
				if (pfn != NULL)
					hr = pfn(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
				FreeLibrary(h);
			}
			pTypeLib->ReleaseTLibAttr(ptla);
		}
	}
	return hr;
}

ATLINLINE ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		OLECHAR szDir[_MAX_PATH];
		ocscpy(szDir, bstrPath);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
	}
	return hr;
}

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(void* /* pReserved */)
{
	return _ATL_VER;
}

ATLINLINE ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject)
{
	pData->m_pThis = pObject;
	pData->m_dwThreadID = ::GetCurrentThreadId();
	::EnterCriticalSection(&pM->m_csWindowCreate);
	pData->m_pNext = pM->m_pCreateWndList;
	pM->m_pCreateWndList = pData;
	::LeaveCriticalSection(&pM->m_csWindowCreate);
}

ATLINLINE ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM)
{
	void* pv = NULL;
	::EnterCriticalSection(&pM->m_csWindowCreate);
	_AtlCreateWndData* pEntry = pM->m_pCreateWndList;
	if(pEntry != NULL)
	{
		DWORD dwThreadID = ::GetCurrentThreadId();
		_AtlCreateWndData* pPrev = NULL;
		while(pEntry != NULL)
		{
			if(pEntry->m_dwThreadID == dwThreadID)
			{
				if(pPrev == NULL)
					pM->m_pCreateWndList = pEntry->m_pNext;
				else
					pPrev->m_pNext = pEntry->m_pNext;
				pv = pEntry->m_pThis;
				break;
			}
			pPrev = pEntry;
			pEntry = pEntry->m_pNext;
		}
	}
	::LeaveCriticalSection(&pM->m_csWindowCreate);
	return pv;
}

/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
{
	ATLASSERT(pDllVersionInfo != NULL);
	if(::IsBadWritePtr(pDllVersionInfo, sizeof(DWORD)))
		return E_INVALIDARG;

	// We must get this function explicitly because some DLLs don't implement it.
	DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
	if(pfnDllGetVersion == NULL)
		return E_NOTIMPL;

	return (*pfnDllGetVersion)(pDllVersionInfo);
}

inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
{
	HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
	if(hInstDLL == NULL)
		return E_FAIL;
	HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
	::FreeLibrary(hInstDLL);
	return hRet;
}

// Common Control Versions:
//   Win95/WinNT 4.0    maj=4 min=00
//   IE 3.x     maj=4 min=70
//   IE 4.0     maj=4 min=71
inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
	if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
		return E_INVALIDARG;

	DLLVERSIONINFO dvi;
	::ZeroMemory(&dvi, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);
	HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}
	else if(hRet == E_NOTIMPL)
	{
		// If DllGetVersion is not there, then the DLL is a version
		// previous to the one shipped with IE 3.x
		*pdwMajor = 4;
		*pdwMinor = 0;
		hRet = S_OK;
	}

	return hRet;
}

// Shell Versions:
//   Win95/WinNT 4.0                    maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop  maj=4 min=00
//   IE 4.0 with Web Integrated Desktop         maj=4 min=71
//   IE 4.01 with Web Integrated Desktop        maj=4 min=72
inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
	if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
		return E_INVALIDARG;

	DLLVERSIONINFO dvi;
	::ZeroMemory(&dvi, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);
	HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}
	else if(hRet == E_NOTIMPL)
	{
		// If DllGetVersion is not there, then the DLL is a version
		// previous to the one shipped with IE 4.x
		*pdwMajor = 4;
		*pdwMinor = 0;
		hRet = S_OK;
	}

	return hRet;
}

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time
#undef _ATLBASE_IMPL

#endif // _ATLBASE_IMPL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\atl\atlcom.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Active Template Library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

EXTERN_C const IID IID_ITargetFrame;

namespace ATL
{

#define CComConnectionPointContainerImpl IConnectionPointContainerImpl
#define CComISupportErrorInfoImpl ISupportErrorInfoImpl
#define CComProvideClassInfo2Impl IProvideClassInfoImpl
#define CComDualImpl IDispatchImpl

#ifdef _ATL_DEBUG_QI
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_QI

#ifdef _ATL_DEBUG_QI
#define _ATLDUMPIID(iid, name, hr) AtlDumpIID(iid, name, hr)
#else
#define _ATLDUMPIID(iid, name, hr) hr
#endif

#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className)\
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
		lpszHelpFile, iid, hRes, hInst);
}

#ifndef OLE2ANSI
inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	DWORD dwHelpID, LPCSTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	ATLASSERT(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), dwHelpID, A2CW(lpszHelpFile),
		iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	ATLASSERT(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), 0, NULL, iid, hRes, NULL);
}
#endif

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}

//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl : public IPersist
{
public:
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_FAIL;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
class CComDispatchDriver
{
public:
	CComDispatchDriver()
	{
		p = NULL;
	}
	CComDispatchDriver(IDispatch* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComDispatchDriver(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IDispatch, (void **)&p);
	}
	~CComDispatchDriver() { if (p) p->Release(); }
	void Release() {if (p) p->Release(); p=NULL;}
	operator IDispatch*() {return p;}
	IDispatch& operator*() {ATLASSERT(p!=NULL); return *p; }
	IDispatch** operator&() {ATLASSERT(p==NULL); return &p; }
	IDispatch* operator->() {ATLASSERT(p!=NULL); return p; }
	IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
	IDispatch* operator=(IUnknown* lp)
	{
		return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}

	HRESULT GetPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = GetProperty(p, dwDispID, pVar);
		return hr;
	}
	HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
	{
		ATLASSERT(p);
		return GetProperty(p, dwDispID, pVar);
	}
	HRESULT PutPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = PutProperty(p, dwDispID, pVar);
		return hr;
	}
	HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
	{
		ATLASSERT(p);
		return PutProperty(p, dwDispID, pVar);
	}
	HRESULT GetIDOfName(LPCOLESTR lpsz, DISPID* pdispid)
	{
		return p->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpsz, 1, LOCALE_USER_DEFAULT, pdispid);
	}
	// Invoke a method by DISPID with no parameters
	HRESULT Invoke0(DISPID dispid, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { NULL, NULL, 0, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with no parameters
	HRESULT Invoke0(LPCOLESTR lpszName, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke0(dispid, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with a single parameter
	HRESULT Invoke1(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with a single parameter
	HRESULT Invoke1(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke1(dispid, pvarParam1, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with two parameters
	HRESULT Invoke2(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
	{
		CComVariant varArgs[2] = { *pvarParam2, *pvarParam1 };
		DISPPARAMS dispparams = { &varArgs[0], NULL, 2, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with two parameters
	HRESULT Invoke2(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke2(dispid, pvarParam1, pvarParam2, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with N parameters
	HRESULT InvokeN(DISPID dispid, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { pvarParams, NULL, nParams, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with Nparameters
	HRESULT InvokeN(LPCOLESTR lpszName, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = InvokeN(dispid, pvarParams, nParams, pvarRet);
		return hr;
	}
	static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID,
		VARIANT* pVar)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::GetProperty\n"));
		DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
		return pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
				&dispparamsNoArgs, pVar, NULL, NULL);
	}

	static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID,
		VARIANT* pVar)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::PutProperty\n"));
		DISPPARAMS dispparams = {NULL, NULL, 1, 1};
		dispparams.rgvarg = pVar;
		DISPID dispidPut = DISPID_PROPERTYPUT;
		dispparams.rgdispidNamedArgs = &dispidPut;

		if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH || 
			(pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))
		{
			HRESULT hr = pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
				&dispparams, NULL, NULL, NULL);
			if (SUCCEEDED(hr))
				return hr;
		}

		return pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
				&dispparams, NULL, NULL, NULL);
	}

	IDispatch* p;
};

//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
	static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
};
typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;

//////////////////////////////////////////////////////////////////////////////
// ATL Persistence

struct ATL_PROPMAP_ENTRY
{
	LPCOLESTR szDesc;
	DISPID dispid;
	const CLSID* pclsidPropPage;
	const IID* piidDispatch;
	DWORD dwOffsetData;
	DWORD dwSizeData;
	VARTYPE vt;
};

// This one is DEPRECATED and is used for ATL 2.X controls
// it includes an implicit m_sizeExtent
#define BEGIN_PROPERTY_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	typedef theClass _PropMapClass; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{ \
			{OLESTR("_cx"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cx), sizeof(long), VT_UI4}, \
			{OLESTR("_cy"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cy), sizeof(long), VT_UI4},

// This one can be used on any type of object, but does not
// include the implicit m_sizeExtent
#define BEGIN_PROP_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	typedef theClass _PropMapClass; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{

#define PROP_ENTRY(szDesc, dispid, clsid) \
		{OLESTR(szDesc), dispid, &clsid, &IID_IDispatch, 0, 0, 0},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
		{OLESTR(szDesc), dispid, &clsid, &iidDispatch, 0, 0, 0},

#define PROP_PAGE(clsid) \
		{NULL, NULL, &clsid, &IID_NULL, 0, 0, 0},

#define PROP_DATA_ENTRY(szDesc, member, vt) \
		{OLESTR(szDesc), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, member), sizeof(((_PropMapClass*)0)->member), vt},

#define END_PROPERTY_MAP() \
			{NULL, 0, NULL, &IID_NULL, 0, 0, 0} \
		}; \
		return pPropMap; \
	}

#define END_PROP_MAP() \
			{NULL, 0, NULL, &IID_NULL, 0, 0, 0} \
		}; \
		return pPropMap; \
	}


#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
	HRESULT hr = S_OK;
	DWORD dwVer;
	hr = pStm->Read(&dwVer, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;
	if (dwVer > _ATL_VER)
		return E_FAIL;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD)pThis);
			hr = pStm->Read(pData, pMap[i].dwSizeData, NULL);
			if (FAILED(hr))
				return hr;
			continue;
		}

		CComVariant var;

		hr = var.ReadFromStream(pStm);
		if (FAILED(hr))
			break;

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}
	}
	return hr;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm,
	BOOL /* fClearDirty */, ATL_PROPMAP_ENTRY* pMap,
	void* pThis, IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
	DWORD dw = _ATL_VER;
	HRESULT hr = pStm->Write(&dw, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD)pThis);
			hr = pStm->Write(pData, pMap[i].dwSizeData, NULL);
			if (FAILED(hr))
				return hr;
			continue;
		}

		CComVariant var;
		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}

		hr = var.WriteToStream(pStm);
		if (FAILED(hr))
			break;
	}
	return hr;
}
#endif //_ATL_DLL


#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
	USES_CONVERSION;
	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		CComVariant var;

		// If raw entry skip it - we don't handle it for property bags just yet
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD)pThis);
			HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
			if (SUCCEEDED(hr))
			{
				// check the type - we only deal with limited set
				switch (pMap[i].vt)
				{
				case VT_UI1:
				case VT_I1:
					*((BYTE*)pData) = var.bVal;
					break;
				case VT_BOOL:
					*((VARIANT_BOOL*)pData) = var.boolVal;
					break;
				case VT_UI2:
					*((short*)pData) = var.iVal;
					break;
				case VT_UI4:
				case VT_INT:
				case VT_UINT:
					*((long*)pData) = var.lVal;
					break;
				}
			}
			continue;
		}

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		if (FAILED(hr))
		{
			if (hr == E_INVALIDARG)
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Property %s not in Bag\n"), OLE2CT(pMap[i].szDesc));
			}
			else
			{
				// Many containers return different ERROR values for Member not found
				ATLTRACE2(atlTraceCOM, 0, _T("Error attempting to read Property %s from PropertyBag \n"), OLE2CT(pMap[i].szDesc));
			}
			continue;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}
	}
	return S_OK;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
	BOOL /* fClearDirty */, BOOL /* fSaveAllProperties */,
	ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
	if (pPropBag == NULL)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("PropBag pointer passed in was invalid\n"));
		return E_POINTER;
	}

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		CComVariant var;

		// If raw entry skip it - we don't handle it for property bags just yet
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD)pThis);
			// check the type - we only deal with limited set
			bool bTypeOK = false;
			switch (pMap[i].vt)
			{
			case VT_UI1:
			case VT_I1:
				var.bVal = *((BYTE*)pData);
				bTypeOK = true;
				break;
			case VT_BOOL:
				var.boolVal = *((VARIANT_BOOL*)pData);
				bTypeOK = true;
				break;
			case VT_UI2:
				var.iVal = *((short*)pData);
				bTypeOK = true;
				break;
			case VT_UI4:
			case VT_INT:
			case VT_UINT:
				var.lVal = *((long*)pData);
				bTypeOK = true;
				break;
			}
			if (bTypeOK)
			{
				var.vt = pMap[i].vt;
				HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
				if (FAILED(hr))
					return hr;
			}
			continue;
		}

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		{
			if (var.punkVal == NULL)
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Warning skipping empty IUnknown in Save\n"));
				continue;
			}
		}

		HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}
#endif //_ATL_DLL


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl : public IPersistStreamInit
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::GetClassID\n"));
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStream
	STDMETHOD(IsDirty)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
	}
	STDMETHOD(Load)(LPSTREAM pStm)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
	}
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Save\n"));
		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
	}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */)
	{
		ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax"));
	}

	// IPersistStreamInit
	STDMETHOD(InitNew)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::InitNew\n"));
		return S_OK;
	}

	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = AtlIPersistStreamInit_Load(pStm, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr))
			pT->m_bRequiresSave = FALSE;
		return hr;

	}
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		return AtlIPersistStreamInit_Save(pStm, fClearDirty, pMap, pT, pT->GetUnknown());
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl : public IPersistStorage
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::GetClassID\n"));
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStorage
	STDMETHOD(IsDirty)(void)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::IsDirty\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->IsDirty() : E_FAIL;
	}
	STDMETHOD(InitNew)(IStorage*)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::InitNew\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->InitNew() : E_FAIL;
	}
	STDMETHOD(Load)(IStorage* pStorage)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Load\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Load(spStream);
		}
		return hr;
	}
	STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Save\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			static LPCOLESTR vszContents = OLESTR("Contents");
			hr = pStorage->CreateStream(vszContents,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Save(spStream, fSameAsLoad);
		}
		return hr;
	}
	STDMETHOD(SaveCompleted)(IStorage* /* pStorage */)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::SaveCompleted\n"));
		return S_OK;
	}
	STDMETHOD(HandsOffStorage)(void)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::HandsOffStorage\n"));
		return S_OK;
	}
private:
	IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
	T* pT = static_cast<T*>(this);
	IPersistStreamInit* p;
	if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
		pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
	return p;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl : public IPersistPropertyBag
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::GetClassID\n"));
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistPropertyBag
	//
	STDMETHOD(InitNew)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::InitNew\n"));
		return S_OK;
	}
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
	}
	STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
	}
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = AtlIPersistPropertyBag_Load(pPropBag, pErrorLog, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr))
			pT->m_bRequiresSave = FALSE;
		return hr;
	}
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		return AtlIPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap, pT, pT->GetUnknown());
	}
};

//////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor
class CSecurityDescriptor
{
public:
	CSecurityDescriptor();
	~CSecurityDescriptor();

public:
	HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
	HRESULT AttachObject(HANDLE hObject);
	HRESULT Initialize();
	HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
	HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
	HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
	HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
	HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Revoke(LPCTSTR pszPrincipal);

	// utility functions
	// Any PSID you get from these functions should be free()ed
	static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
	static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
	static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
	static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
	static HRESULT CopyACL(PACL pDest, PACL pSrc);
	static HRESULT GetCurrentUserSID(PSID *ppSid);
	static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

public:
	PSECURITY_DESCRIPTOR m_pSD;
	PSID m_pOwner;
	PSID m_pGroup;
	PACL m_pDACL;
	PACL m_pSACL;
};

inline CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

inline CSecurityDescriptor::~CSecurityDescriptor()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}

inline HRESULT CSecurityDescriptor::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
	if (m_pSD == NULL)
		return E_OUTOFMEMORY;

	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		ATLASSERT(FALSE);
		return hr;
	}
	// Set the DACL to allow EVERYONE
	SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
	return S_OK;
}

inline HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
	PSID pUserSid = NULL;
	PSID pGroupSid = NULL;
	HRESULT hr;

	Initialize();
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (SUCCEEDED(hr))
	{
		hr = SetOwner(pUserSid, bDefaulted);
		if (SUCCEEDED(hr))
			hr = SetGroup(pGroupSid, bDefaulted);
	}
	if (pUserSid != NULL)
		free(pUserSid);
	if (pGroupSid != NULL)
		free(pGroupSid);
	return hr;
}

inline HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
	PSID pUserSid = NULL;
	PSID pGroupSid = NULL;
	HRESULT hr;

	Initialize();
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (SUCCEEDED(hr))
	{
		hr = SetOwner(pUserSid, bDefaulted);
		if (SUCCEEDED(hr))
			hr = SetGroup(pGroupSid, bDefaulted);
	}
	if (pUserSid != NULL)
		free(pUserSid);
	if (pGroupSid != NULL)
		free(pGroupSid);
	return hr;
}

inline HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
	ATLASSERT(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (m_pOwner == NULL)
		return E_OUTOFMEMORY;
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	ATLASSERT(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}

inline HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
	ATLASSERT(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (m_pGroup == NULL)
		return E_OUTOFMEMORY;
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	ATLASSERT(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}

inline HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

inline HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

inline HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

inline HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	CloseHandle(hToken);
	return hr;
}

inline HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	CloseHandle(hToken);
	return hr;
}

inline HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
	DWORD dwSize;
	HRESULT hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			ATLASSERT(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (ptkUser == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid;
		pSid = (PSID) malloc(dwSize);
		if (pSid == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		ATLASSERT(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			ATLASSERT(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (ptkGroup == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid;
		pSid = (PSID) malloc(dwSize);
		if (pSid == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		ATLASSERT(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


inline HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
	HANDLE tkHandle;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		tkUser = (TOKEN_USER *) malloc(tkSize);
		if (tkUser == NULL)
			return E_OUTOFMEMORY;

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);
			if (*ppSid == NULL)
				return E_OUTOFMEMORY;

			memcpy(*ppSid, tkUser->User.Sid, sidLength);
			CloseHandle(tkHandle);

			free(tkUser);
			return S_OK;
		}
		else
		{
			free(tkUser);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


inline HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return HRESULT_FROM_WIN32(GetLastError());
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


inline HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	ACCESS_ALLOWED_ACE* pACE;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;

	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			m_pDACL = (PACL) malloc(pDACL->AclSize);
			if (m_pDACL == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto failedMemory;
			}

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pDACL->AceCount; i++)
			{
				if (!GetAce(pDACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			m_pSACL = (PACL) malloc(pSACL->AclSize);
			if (m_pSACL == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto failedMemory;
			}

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pSACL->AceCount; i++)
			{
				if (!GetAce(pSACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
		goto failed;

	return hr;

failed:
	hr = HRESULT_FROM_WIN32(hr);

failedMemory:
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSD)
	{
		free(m_pSD);
		m_pSD = NULL;
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
	if (pSD == NULL)
		return E_OUTOFMEMORY;

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


inline HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

inline HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL = NULL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	ATLTRY(newACL = (PACL) new BYTE[aclSize]);
	if (newACL == NULL)
		return E_OUTOFMEMORY;

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


inline HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL = NULL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	ATLTRY(newACL = (PACL) new BYTE[aclSize]);
	if (newACL == NULL)
		return E_OUTOFMEMORY;

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


inline HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	ULONG i;
	LPVOID ace;
	ACCESS_ALLOWED_ACE *accessAllowedAce;
	ACCESS_DENIED_ACE *accessDeniedAce;
	SYSTEM_AUDIT_ACE *systemAuditAce;
	PSID principalSID;
	DWORD returnValue;
	ACE_HEADER *aceHeader;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	for (i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pAcl, i, &ace))
		{
			free(principalSID);
			return HRESULT_FROM_WIN32(GetLastError());
		}

		aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		}
	}
	free(principalSID);
	return S_OK;
}


inline HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
	HRESULT hr;
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID   luid;
	HANDLE hTokenUsed;

	// if no token specified open process token
	if (hToken == 0)
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			return hr;
		}
	}
	else
		hTokenUsed = hToken;

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

template <class T1>
class CComCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		ATLASSERT(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <class T1>
class CComInternalCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		ATLASSERT(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->_InternalQueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <HRESULT hr>
class CComFailCreator
{
public:
	static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID*)
	{
		return hr;
	}
};

template <class T1, class T2>
class CComCreator2
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		ATLASSERT(*ppv == NULL);
		return (pv == NULL) ? 
			T1::CreateInstance(NULL, riid, ppv) : 
			T2::CreateInstance(pv, riid, ppv);
	}
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_POLY_AGGREGATABLE(x) public:\
	typedef CComCreator< CComPolyObject< x > > _CreatorClass;

struct _ATL_CREATORDATA
{
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
	static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
	DWORD dwOffsetVar;
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar>
class _CComCacheData
{
public:
	static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar>::data = {dwVar, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
	DWORD dwOffset;
	const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
	static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
	{offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
	{
		ATLASSERT(*ppv == NULL);
		ATLASSERT(pv != NULL);
		T* p = (T*) pv;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
	}
};

#ifdef _ATL_DEBUG
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(DWORD)_T(#x), \
		(_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#define _ATL_DECLARE_GET_UNKNOWN(x)\
	IUnknown* GetUnknown() \
	{ \
		IUnknown* p; \
		_Module.AddNonAddRefThunk(_GetRawUnknown(), _T(#x), &p); \
		return p; \
	}
#else
#define _ATL_DECLARE_GET_UNKNOWN(x) IUnknown* GetUnknown() {return _GetRawUnknown();}
#endif

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public: \
	typedef x _ComMapClass; \
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw)\
	{\
		_ComMapClass* p = (_ComMapClass*)pv;\
		p->Lock();\
		HRESULT hRes = CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\
		p->Unlock();\
		return hRes;\
	}\
	IUnknown* _GetRawUnknown() \
	{ ATLASSERT(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((int)this+_GetEntries()->dw); } \
	_ATL_DECLARE_GET_UNKNOWN(x)\
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) \
	{ return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); } \
	const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() { \
	static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() {return GetUnknown();}

#ifndef _ATL_NO_UUIDOF
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

#define COM_INTERFACE_ENTRY_BREAK(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_Break},

#define COM_INTERFACE_ENTRY_NOINTERFACE(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_NoInterface},

#define COM_INTERFACE_ENTRY(x)\
	{&_ATL_IIDOF(x), \
	offsetofclass(x, _ComMapClass), \
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
	{&iid,\
	offsetofclass(x, _ComMapClass),\
	_ATL_SIMPLEMAPENTRY},

// The impl macros are now obsolete
#define COM_INTERFACE_ENTRY_IMPL(x)\
	COM_INTERFACE_ENTRY_IID(_ATL_IIDOF(x), x##Impl<_ComMapClass>)

#define COM_INTERFACE_ENTRY_IMPL_IID(iid, x)\
	COM_INTERFACE_ENTRY_IID(iid, x##Impl<_ComMapClass>)
//

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&_ATL_IIDOF(x),\
	(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
	{&iid,\
	(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
	{&iid, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
	{NULL, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
	{&iid,\
	(DWORD)&_CComCreatorData<\
		CComInternalCreator< CComTearOffObject< x > >\
		>::data,\
	_Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk)\
	{&iid,\
	(DWORD)&_CComCacheData<\
		CComCreator< CComCachedTearOffObject< x > >,\
		(DWORD)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	(DWORD)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
	{NULL,\
	(DWORD)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid)\
	{&iid,\
	(DWORD)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid)\
	{NULL,\
	(DWORD)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
	{NULL,\
	(DWORD)&_CComChainData<classname, _ComMapClass>::data,\
	_Chain},

#ifdef _ATL_DEBUG
#define END_COM_MAP() {NULL, 0, 0}}; return &_entries[1];} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#else
#define END_COM_MAP() {NULL, 0, 0}}; return _entries;} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#endif // _ATL_DEBUG

#define BEGIN_CATEGORY_MAP(x)\
   static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {\
   static const struct _ATL_CATMAP_ENTRY pMap[] = {
#define IMPLEMENTED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_IMPLEMENTED, &catid },
#define REQUIRED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_REQUIRED, &catid },
#define END_CATEGORY_MAP()\
   { _ATL_CATMAP_ENTRY_END, NULL } };\
   return( pMap ); }

#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance, class::_CreatorClass::CreateInstance, NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },
#define OBJECT_ENTRY_NON_CREATEABLE(class) {&CLSID_NULL, class::UpdateRegistry, NULL, NULL, NULL, 0, NULL, class::GetCategoryMap, class::ObjectMain },

#ifdef _ATL_DEBUG
extern HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#endif // _ATL_DEBUG


// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRootBase
{
public:
	CComObjectRootBase()
	{
		m_dwRef = 0L;
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	// For library initialization only
	HRESULT _AtlFinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() {}
	void _AtlFinalRelease() {}

	//ObjectMain is called during Module::Init and Module::Term
	static void WINAPI ObjectMain(bool /* bStarting */) {}

	static HRESULT WINAPI InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
	{
		ATLASSERT(pThis != NULL);
		// First entry in the com map should be a simple map entry
		ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
		LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
	#endif // _ATL_DEBUG_INTERFACES
		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
	#ifdef _ATL_DEBUG_INTERFACES
		_Module.AddThunk((IUnknown**)ppvObject, pszClassName, iid);
	#endif // _ATL_DEBUG_INTERFACES
		return _ATLDUMPIID(iid, pszClassName, hRes);
	}

//Outer funcs
	ULONG OuterAddRef()
	{
		return m_pOuterUnknown->AddRef();
	}
	ULONG OuterRelease()
	{
		return m_pOuterUnknown->Release();
	}
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{
		return m_pOuterUnknown->QueryInterface(iid, ppvObject);
	}

	void SetVoid(void*) {}
	void InternalFinalConstructAddRef() {}
	void InternalFinalConstructRelease()
	{
		ATLASSERT(m_dwRef == 0);
	}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()


	static HRESULT WINAPI _Break(void* /* pv */, REFIID iid, void** /* ppvObject */, DWORD /* dw */)
	{
		iid;
		_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
		DebugBreak();
		return S_FALSE;
	}
	static HRESULT WINAPI _NoInterface(void* /* pv */, REFIID /* iid */, void** /* ppvObject */, DWORD /* dw */)
	{
		return E_NOINTERFACE;
	}
	static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw)
	{
		_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
		return pcd->pFunc(pv, iid, ppvObject);
	}
	static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		IUnknown* p = *(IUnknown**)((DWORD)pv + dw);
		if (p != NULL)
			hRes = p->QueryInterface(iid, ppvObject);
		return hRes;
	}
	static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw)
	{
		_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
		void* p = (void*)((DWORD)pv + pcd->dwOffset);
		return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
	}
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
		IUnknown** pp = (IUnknown**)((DWORD)pv + pcd->dwOffsetVar);
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
		if (*pp != NULL)
			hRes = (*pp)->QueryInterface(iid, ppvObject);
		return hRes;
	}

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

//foward declaration
template <class ThreadModel>
class CComObjectRootEx;

template <class ThreadModel>
class CComObjectLockT
{
public:
	CComObjectLockT(CComObjectRootEx<ThreadModel>* p)
	{
		if (p)
			p->Lock();
		m_p = p;
	}

	~CComObjectLockT()
	{
		if (m_p)
			m_p->Unlock();
	}
	CComObjectRootEx<ThreadModel>* m_p;
};

template <> class CComObjectLockT<CComSingleThreadModel>;

template <class ThreadModel>
class CComObjectRootEx : public CComObjectRootBase
{
public:
	typedef ThreadModel _ThreadModel;
	typedef _ThreadModel::AutoCriticalSection _CritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	ULONG InternalAddRef()
	{
		ATLASSERT(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		ATLASSERT(m_dwRef > 0);
		return _ThreadModel::Decrement(&m_dwRef);
	}

	void Lock() {m_critsec.Lock();}
	void Unlock() {m_critsec.Unlock();}
private:
	_CritSec m_critsec;
};

template <>
class CComObjectRootEx<CComSingleThreadModel> : public CComObjectRootBase
{
public:
	typedef CComSingleThreadModel _ThreadModel;
	typedef _ThreadModel::AutoCriticalSection _CritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	ULONG InternalAddRef()
	{
		ATLASSERT(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		return _ThreadModel::Decrement(&m_dwRef);
	}

	void Lock() {}
	void Unlock() {}
};

template <>
class CComObjectLockT<CComSingleThreadModel>
{
public:
	CComObjectLockT(CComObjectRootEx<CComSingleThreadModel>*) {}
	~CComObjectLockT() {}
};

typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;

#if defined(_WINDLL) | defined(_USRDLL)
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)
#define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(CComClassFactoryAutoThread)
#define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton<obj>)

#define DECLARE_OBJECT_DESCRIPTION(x)\
	static LPCTSTR WINAPI GetObjectDescription()\
	{\
		return _T(x);\
	}

#define DECLARE_NO_REGISTRY()\
	static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\
	{return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
			flags, bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(x, bRegister);\
	}

//DECLARE_STATIC_* provided for backward compatibility
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x)
#define DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x)
#endif //_ATL_STATIC_REGISTRY

template<class Base> class CComObject; // fwd decl

template <class Owner, class ThreadModel = CComObjectThreadModel>
class CComTearOffObjectBase : public CComObjectRootEx<ThreadModel>
{
public:
	typedef Owner _OwnerClass;
	CComObject<Owner>* m_pOwner;
	CComTearOffObjectBase() {m_pOwner = NULL;}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	typedef Base _BaseClass;
	CComObject(void* = NULL)
	{
		_Module.Lock();
	}
	// Set refcount to 1 to protect destruction
	~CComObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		_Module.Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
{
	ATLASSERT(pp != NULL);
	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectCached(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectCached()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)()
	{
		m_csCached.Lock();
		ULONG l = InternalAddRef();
		if (m_dwRef == 2)
			_Module.Lock();
		m_csCached.Unlock();
		return l;
	}
	STDMETHOD_(ULONG, Release)()
	{
		m_csCached.Lock();
		InternalRelease();
		ULONG l = m_dwRef;
		m_csCached.Unlock();
		if (l == 0)
			delete this;
		else if (l == 1)
			_Module.Unlock();
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectNoLock()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectGlobal()
	{
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
	STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectStack()
	{
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}


	STDMETHOD_(ULONG, AddRef)() {ATLASSERT(FALSE);return 0;}
	STDMETHOD_(ULONG, Release)(){ATLASSERT(FALSE);return 0;}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{ATLASSERT(FALSE);return E_NOINTERFACE;}
	HRESULT m_hResFinalConstruct;
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}
#ifdef _ATL_DEBUG_INTERFACES
	~CComContainedObject()
	{
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
		_Module.DeleteNonAddRefThunk(m_pOuterUnknown);
	}
#endif

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hr = OuterQueryInterface(iid, ppvObject);
		if (FAILED(hr) && _GetRawUnknown() != m_pOuterUnknown)
			hr = _InternalQueryInterface(iid, ppvObject);
		return hr;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown()
	{
#ifdef _ATL_DEBUG_INTERFACES
		IUnknown* p;
		_Module.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject"), &p);
		return p;
#else
		return m_pOuterUnknown;
#endif
	}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject :
	public IUnknown,
	public CComObjectRootEx< contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComAggObject(void* pv) : m_contained(pv)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComAggObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComAggObject<contained>** pp)
	{
		ATLASSERT(pp != NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		CComAggObject<contained>* p = NULL;
		ATLTRY(p = new CComAggObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};

///////////////////////////////////////////////////////////////////////////////
// CComPolyObject can be either aggregated or not aggregated

template <class contained>
class CComPolyObject :
	public IUnknown,
	public CComObjectRootEx< contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComPolyObject(void* pv) : m_contained(pv ? pv : this)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		InternalAddRef();
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		HRESULT hr = m_contained.FinalConstruct();
		InternalRelease();
		return hr;
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComPolyObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComPolyObject<contained>** pp)
	{
		ATLASSERT(pp != NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		CComPolyObject<contained>* p = NULL;
		ATLTRY(p = new CComPolyObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};

template <class Base>
class CComTearOffObject : public Base
{
public:
	CComTearOffObject(void* pv)
	{
		ATLASSERT(m_pOwner == NULL);
		m_pOwner = reinterpret_cast<CComObject<Base::_OwnerClass>*>(pv);
		m_pOwner->AddRef();
	}
	// Set refcount to 1 to protect destruction
	~CComTearOffObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		m_pOwner->Release();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		return m_pOwner->QueryInterface(iid, ppvObject);
	}
};

template <class contained>
class CComCachedTearOffObject :
	public IUnknown,
	public CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>
{
public:
	typedef contained _BaseClass;
	CComCachedTearOffObject(void* pv) :
		m_contained(((contained::_OwnerClass*)pv)->GetControllingUnknown())
	{
		ATLASSERT(m_contained.m_pOwner == NULL);
		m_contained.m_pOwner = reinterpret_cast<CComObject<contained::_OwnerClass>*>(pv);
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComCachedTearOffObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
	}


	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

class CComClassFactory :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactory)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// can't ask for anything other than IUnknown when aggregating
			
			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("CComClassFactory: asked for non IUnknown interface while creating an aggregated object"));
				hRes = CLASS_E_NOAGGREGATION;
			}
			else
				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
		}
		return hRes;
	}

	STDMETHOD(LockServer)(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 : 
	public IClassFactory2,
	public CComObjectRootEx<CComGlobalsThreadModel>,
	public license
{
public:
	typedef license _LicenseClass;
	typedef CComClassFactory2<license> _ComMapClass;
BEGIN_COM_MAP(CComClassFactory2<license>)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(LockServer)(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;
		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;

		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	// IClassFactory2
	STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved,
				REFIID riid, BSTR bstrKey, void** ppvObject)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;
		if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
			 ((bstrKey == NULL) && !IsLicenseValid()) )
			return CLASS_E_NOTLICENSED;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
	}
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey)
	{
		if (pbstrKey == NULL)
			return E_POINTER;
		*pbstrKey = NULL;

		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;
		return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
	}
	STDMETHOD(GetLicInfo)(LICINFO* pLicInfo)
	{
		if (pLicInfo == NULL)
			return E_POINTER;
		pLicInfo->cbLicInfo = sizeof(LICINFO);
		pLicInfo->fLicVerified = IsLicenseValid();
		BSTR bstr = NULL;
		pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
		::SysFreeString(bstr);
		return S_OK;
	}
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling class factory

class CComClassFactoryAutoThread :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactoryAutoThread)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// cannot aggregate across apartments
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
				hRes = _Module.CreateInstance(m_pfnCreateInstance, riid, ppvObj);
		}
		return hRes;
	}
	STDMETHODIMP LockServer(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Singleton Class Factory
template <class T>
class CComClassFactorySingleton : public CComClassFactory
{
public:
	void FinalRelease()
	{
		CoDisconnectObject(m_Obj.GetUnknown(), 0);
	}

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// aggregation is not supported in Singletons
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
			{
				if (m_Obj.m_hResFinalConstruct != S_OK)
					hRes = m_Obj.m_hResFinalConstruct;
				else
					hRes = m_Obj.QueryInterface(riid, ppvObj);
			}
		}
		return hRes;
	}
	CComObjectGlobal<T> m_Obj;
};

template <class T, const CLSID* pclsid = &CLSID_NULL>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
	static LPCTSTR WINAPI GetObjectDescription() {return NULL;}
	static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {return NULL;};
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile,
			iid, hRes);
	}
	static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst);
	}
	static HRESULT WINAPI Error(UINT nID, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile,
			iid, hRes, hInst);
	}
#ifndef OLE2ANSI
	static HRESULT WINAPI Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCSTR lpszDesc, DWORD dwHelpID,
		LPCSTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID,
			lpszHelpFile, iid, hRes);
	}
#endif
	template <class Q>
	static HRESULT CreateInstance(IUnknown* punkOuter, Q** pp)
	{
		return T::_CreatorClass::CreateInstance(punkOuter, __uuidof(Q), (void**) pp);
	}
	template <class Q>
	static HRESULT CreateInstance(Q** pp)
	{
		return T::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**) pp);
	}
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
	};
	stringdispid* m_pMap;
	int m_nCount;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
	HRESULT GetTI(LCID lcid);
	HRESULT EnsureTI(LCID lcid)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		return hr;
	}

	// This function is called by the module on exit
	// It is registered through _Module.AddTermFunc()
	static void __stdcall Cleanup(DWORD dw)
	{
		CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;
		if (p->m_pInfo != NULL)
			p->m_pInfo->Release();
		p->m_pInfo = NULL;
		delete [] p->m_pMap;
		p->m_pMap = NULL;
	}

	HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
	{
		HRESULT hRes = E_POINTER;
		if (pptinfo != NULL)
			hRes = GetTI(lcid, pptinfo);
		return hRes;
	}
	HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
		{
			for (int i=0; i<(int)cNames; i++)
			{
				int n = ocslen(rgszNames[i]);
				for (int j=m_nCount-1; j>=0; j--)
				{
					if ((n == m_pMap[j].nLen) &&
						(memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
					{
						rgdispid[i] = m_pMap[j].id;
						break;
					}
				}
				if (j < 0)
				{
					hRes = m_pInfo->GetIDsOfNames(rgszNames + i, 1, &rgdispid[i]);
					if (FAILED(hRes))
						break;
				}
			}
		}
		return hRes;
	}

	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		return hRes;
	}
	HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
	{
		TYPEATTR* pta;
		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
		if (SUCCEEDED(hr))
		{
			m_nCount = pta->cFuncs;
			m_pMap = m_nCount == 0 ? 0 : new stringdispid[m_nCount];
			for (int i=0; i<m_nCount; i++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
				{
					CComBSTR bstrName;
					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
					{
						m_pMap[i].bstr.Attach(bstrName.Detach());
						m_pMap[i].nLen = SysStringLen(m_pMap[i].bstr);
						m_pMap[i].id = pfd->memid;
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			pTypeInfo->ReleaseTypeAttr(pta);
		}
		return S_OK;
	}
};


inline HRESULT CComTypeInfoHolder::GetTI(LCID lcid)
{
	//If this assert occurs then most likely didn't initialize properly
	ATLASSERT(m_plibid != NULL && m_pguid != NULL);
	ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

	if (m_pInfo != NULL)
		return S_OK;
	HRESULT hRes = E_FAIL;
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
			if (SUCCEEDED(hRes))
			{
				CComPtr<ITypeInfo> spInfo(spTypeInfo);
				CComPtr<ITypeInfo2> spTypeInfo2;
				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
					spInfo = spTypeInfo2;

				LoadNameCache(spInfo);
				m_pInfo = spInfo.Detach();
			}
			pTypeLib->Release();
		}
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
	_Module.AddTermFunc(Cleanup, (DWORD)this);
	return hRes;
}

//////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
//
template <class T>
class ATL_NO_VTABLE IObjectWithSiteImpl : public IObjectWithSite
{
public:
	STDMETHOD(SetSite)(IUnknown *pUnkSite)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::SetSite\n"));
		T* pT = static_cast<T*>(this);
		pT->m_spUnkSite = pUnkSite;
		return S_OK;
	}
	STDMETHOD(GetSite)(REFIID riid, void **ppvSite)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::GetSite\n"));
		T* pT = static_cast<T*>(this);
		ATLASSERT(ppvSite);
		HRESULT hRes = E_POINTER;
		if (ppvSite != NULL)
		{
			if (pT->m_spUnkSite)
				hRes = pT->m_spUnkSite->QueryInterface(riid, ppvSite);
			else
			{
				*ppvSite = NULL;
				hRes = E_FAIL;
			}
		}
		return hRes;
	}

	HRESULT SetChildSite(IUnknown* punkChild)
	{
		if (punkChild == NULL)
			return E_POINTER;

		HRESULT hr;
		CComPtr<IObjectWithSite> spChildSite;
		hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&spChildSite);
		if (SUCCEEDED(hr))
			hr = spChildSite->SetSite((IUnknown*)this);

		return hr;
	}

	static HRESULT SetChildSite(IUnknown* punkChild, IUnknown* punkParent)
	{
		return AtlSetChildSite(punkChild, punkParent);
	}

	CComPtr<IUnknown> m_spUnkSite;
};

//////////////////////////////////////////////////////////////////////////////
// IServiceProvider
//
template <class T>
class ATL_NO_VTABLE IServiceProviderImpl : public IServiceProvider
{
public:
	STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void** ppvObject)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IServiceProviderImpl::QueryService\n"));
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryService(guidService, riid, ppvObject);
	}
};

#define BEGIN_SERVICE_MAP(x) public: \
	HRESULT _InternalQueryService(REFGUID guidService, REFIID riid, void** ppvObject) \
	{

#define SERVICE_ENTRY(x) \
		if (InlineIsEqualGUID(guidService, x)) \
			return QueryInterface(riid, ppvObject);

#define SERVICE_ENTRY_CHAIN(x) \
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spProvider(x); \
		if (spProvider != NULL) \
			return spProvider->QueryService(guidService, riid, ppvObject);

#define END_SERVICE_MAP() \
		return E_NOINTERFACE; \
	}


/////////////////////////////////////////////////////////////////////////////
// IDispEventImpl

#ifdef _ATL_DLL
ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor);
#else
ATLINLINE ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor)
{
	HRESULT hr = E_FAIL;
	if (punkObj != NULL)
	{
		CComPtr<IDispatch> spDispatch;
		hr = punkObj->QueryInterface(IID_IDispatch, (void**)&spDispatch);
		if (SUCCEEDED(hr))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hr = spDispatch->GetTypeInfo(0, 0, &spTypeInfo);
			if (SUCCEEDED(hr))
			{
				CComPtr<ITypeLib> spTypeLib;
				hr = spTypeInfo->GetContainingTypeLib(&spTypeLib, 0);
				if (SUCCEEDED(hr))
				{
					TLIBATTR* plibAttr;
					hr = spTypeLib->GetLibAttr(&plibAttr);
					if (SUCCEEDED(hr))
					{
						memcpy(plibid, &plibAttr->guid, sizeof(GUID));
						*pdwMajor = plibAttr->wMajorVerNum;
						*pdwMinor = plibAttr->wMinorVerNum;
						spTypeLib->ReleaseTLibAttr(plibAttr);
						// First see if the object is willing to tell us about the
						// default source interface via IProvideClassInfo2
						CComPtr<IProvideClassInfo2> spInfo;
						hr = punkObj->QueryInterface(IID_IProvideClassInfo2, (void**)&spInfo);
						if (SUCCEEDED(hr) && spInfo != NULL)
							hr = spInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid);
						else
						{
							// No, we have to go hunt for it
							CComPtr<ITypeInfo> spInfoCoClass;
							// If we have a clsid, use that
							// Otherwise, try to locate the clsid from IPersist
							CComPtr<IPersist> spPersist;
							CLSID clsid;
							hr = punkObj->QueryInterface(IID_IPersist, (void**)&spPersist);
							if (SUCCEEDED(hr))
							{
								hr = spPersist->GetClassID(&clsid);
								if (SUCCEEDED(hr))
								{
									hr = spTypeLib->GetTypeInfoOfGuid(clsid, &spInfoCoClass);
									if (SUCCEEDED(hr))
									{
										TYPEATTR* pAttr=NULL;
										spInfoCoClass->GetTypeAttr(&pAttr);
										if (pAttr != NULL)
										{
											HREFTYPE hRef;
											for (int i = 0; i < pAttr->cImplTypes; i++)
											{
												int nType;
												hr = spInfoCoClass->GetImplTypeFlags(i, &nType);
												if (SUCCEEDED(hr))
												{
													if (nType == (IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE))
													{
														// we found it
														hr = spInfoCoClass->GetRefTypeOfImplType(i, &hRef);
														if (SUCCEEDED(hr))
														{
															CComPtr<ITypeInfo> spInfo;
															hr = spInfoCoClass->GetRefTypeInfo(hRef, &spInfo);
															if (SUCCEEDED(hr))
															{
																TYPEATTR* pAttrIF;
																spInfo->GetTypeAttr(&pAttrIF);
																if (pAttrIF != NULL)
																{
																	memcpy(piid, &pAttrIF->guid, sizeof(GUID));
																}
																spInfo->ReleaseTypeAttr(pAttrIF);
															}
														}
														break;
													}
												}
											}
											spInfoCoClass->ReleaseTypeAttr(pAttr);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
}
#endif // _ATL_DLL


#if defined(_M_ALPHA)
	#pragma message("ALPHA code for CComStdCallThunk needs to be verified!")
	#pragma pack(push,4)
	template <class T>
	class CComStdCallThunk
	{
	public:
		typedef void (__stdcall T::*TMFP)();

		void* pVtable;
		void* pFunc;
		DWORD ldah_at;      //  ldah    at, HIWORD(func)
		DWORD ldah_a0;      //  ldah    a0, HIWORD(this)
		DWORD lda_at;       //  lda     at, LOWORD(func)(at)
		DWORD lda_a0;       //  lda     a0, LOWORD(this)(a0)
		DWORD jmp;          //  jmp     zero,(at),0
		void Init(TMFP dw, void* pThis)
		{
			union {
				DWORD dwFunc;
				TMFP pfn;
			} pfn;
			pfn.pfn = dw;
			pVtable = &pFunc;
			pFunc = &m_mov;
			thunk.ldah_at = (0x279f0000 | HIWORD(pFunc)) + (LOWORD(pFunc)>>15);
			thunk.ldah_a0 = (0x261f0000 | HIWORD(pThis)) + (LOWORD(pThis)>>15);
			thunk.lda_at = 0x239c0000 | LOWORD(pFunc);
			thunk.lda_a0 = 0x22100000 | LOWORD(pThis);
			thunk.jmp = 0x6bfc0000;
			FlushInstructionCache(GetCurrentProcess(), this, sizeof(CComStdCallThunk));
		}
	};
	#pragma pack(pop)
#elif defined (_M_IX86)
	#pragma pack(push,1)
	template <class T>
	class CComStdCallThunk
	{
	public:
		typedef void (__stdcall T::*TMFP)();

		void* pVtable;
		void* pFunc;
		DWORD	m_mov;          // mov dword ptr [esp+4], pThis
		DWORD   m_this;         //
		BYTE    m_jmp;          // jmp func
		DWORD   m_relproc;      // relative jmp
		void Init(TMFP dw, void* pThis)
		{
			union {
				DWORD dwFunc;
				TMFP pfn;
			} pfn;
			pfn.pfn = dw;
			pVtable = &pFunc;
			pFunc = &m_mov;
			m_mov = 0x042444C7;
			m_this = (DWORD)pThis;
			m_jmp = 0xE9;
			m_relproc = (int)pfn.dwFunc - ((int)this+sizeof(CComStdCallThunk));
			FlushInstructionCache(GetCurrentProcess(), this, sizeof(CComStdCallThunk));
		}
	};
	#pragma pack(pop)
#else
	#error Only ALPHA and X86 supported
#endif

#ifndef _ATL_MAX_VARTYPES
#define _ATL_MAX_VARTYPES 8
#endif

struct _ATL_FUNC_INFO
{
	CALLCONV cc;
	VARTYPE vtReturn;
	SHORT nParams;
	VARTYPE pVarTypes[_ATL_MAX_VARTYPES];
};

class ATL_NO_VTABLE _IDispEvent
{
public:
	_IDispEvent() {m_dwEventCookie = 0xFEFEFEFE;}
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
	GUID m_libid; // used for dynamic case
	IID m_iid; // used for dynamic case
    unsigned short m_wMajorVerNum;    // Major version number. used for dynamic case
    unsigned short m_wMinorVerNum;    // Minor version number. used for dynamic case
	DWORD m_dwEventCookie;
	HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
	{
		ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
		return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
	}
	HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
};

template <UINT nID, const IID* piid>
class ATL_NO_VTABLE _IDispEventLocator : public _IDispEvent
{
public:
};

template <UINT nID, class T, const IID* pdiid>
class ATL_NO_VTABLE IDispEventSimpleImpl : public _IDispEventLocator<nID, pdiid>
{
public:
	STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject)
	{
		if (InlineIsEqualGUID(riid, *pdiid) || 
			InlineIsEqualUnknown(riid) ||
			InlineIsEqualGUID(riid, IID_IDispatch) ||
			InlineIsEqualGUID(riid, m_iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, _T("IDispEventImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
			return S_OK;
		}
		else
			return E_NOINTERFACE;
	}

	// These are here only to support use in non-COM objects	
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{return E_NOTIMPL;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return E_NOTIMPL;}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return E_NOTIMPL;}

	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD /*wFlags*/, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* /*pexcepinfo*/, UINT* /*puArgErr*/)
	{
		T* pT = static_cast<T*>(this);
		const _ATL_EVENT_ENTRY<T>* pMap = T::_GetSinkMap();
		const _ATL_EVENT_ENTRY<T>* pFound = NULL;
		void (__stdcall T::*pEvent)() = NULL;
		while (pMap->piid != NULL)
		{
			if ((pMap->nControlID == nID) && (pMap->dispid == dispidMember) && 
				(pMap->piid == pdiid)) //comparing pointers here should be adequate
			{
				pFound = pMap;
				break;
			}
			pMap++;
		}
		if (pFound == NULL)
			return S_OK;
		

		_ATL_FUNC_INFO info;
		_ATL_FUNC_INFO* pInfo;
		if (pFound->pInfo != NULL)
			pInfo = pFound->pInfo;
		else
		{
			pInfo = &info;
			HRESULT hr = GetFuncInfoFromId(*pdiid, dispidMember, lcid, info);
			if (FAILED(hr))
				return S_OK;
		}
		InvokeFromFuncInfo(pFound->pfn, *pInfo, pdispparams, pvarResult);
		return S_OK;
	}

	//Helper for invoking the event
	HRESULT InvokeFromFuncInfo(void (__stdcall T::*pEvent)(), _ATL_FUNC_INFO& info, DISPPARAMS* pdispparams, VARIANT* pvarResult)
	{
		T* pT = static_cast<T*>(this);
		VARIANTARG** pVarArgs = info.nParams ? (VARIANTARG**)alloca(sizeof(VARIANTARG*)*info.nParams) : 0;
		for (int i=0; i<info.nParams; i++)
			pVarArgs[i] = &pdispparams->rgvarg[info.nParams - i - 1];

		CComStdCallThunk<T> thunk;
		thunk.Init(pEvent, pT);
		CComVariant tmpResult;
		if (pvarResult == NULL)
			pvarResult = &tmpResult;

		HRESULT hr = DispCallFunc(
			&thunk,
			0,
			info.cc,
			info.vtReturn,
			info.nParams,
			info.pVarTypes,
			pVarArgs,
			pvarResult);
		ATLASSERT(SUCCEEDED(hr));
		return hr;
	}

	//Helper for finding the function index for a DISPID
	virtual HRESULT GetFuncInfoFromId(const IID& iid, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
	{
		return E_NOTIMPL;
	}
	//Helpers for sinking events on random IUnknown*
	HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
	{
		ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
		return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
	}
	HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
	HRESULT DispEventAdvise(IUnknown* pUnk)
	{
		return _IDispEvent::DispEventAdvise(pUnk, pdiid);
	}
	HRESULT DispEventUnadvise(IUnknown* pUnk)
	{
		return _IDispEvent::DispEventUnadvise(pUnk, pdiid);
	}
};

//Helper for advising connections points from a sink map
template <class T>
inline HRESULT AtlAdviseSinkMap(T* pT, bool bAdvise)
{
	ATLASSERT(::IsWindow(pT->m_hWnd));
	const _ATL_EVENT_ENTRY<T>* pEntries = T::_GetSinkMap();
	if (pEntries == NULL)
		return S_OK;
	HRESULT hr = S_OK;
	while (pEntries->piid != NULL)
	{
		_IDispEvent* pDE = (_IDispEvent*)((DWORD)pT+pEntries->nOffset);
		bool bNotAdvised = pDE->m_dwEventCookie == 0xFEFEFEFE;
		if (bAdvise ^ bNotAdvised)
		{
			pEntries++;
			continue;
		}
		hr = E_FAIL;
		HWND h = pT->GetDlgItem(pEntries->nControlID);
		ATLASSERT(h != NULL);
		if (h != NULL)
		{
			CComPtr<IUnknown> spUnk;
			AtlAxGetControl(h, &spUnk);
			ATLASSERT(spUnk != NULL);
			if (spUnk != NULL)
			{
				if (bAdvise)
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventAdvise(spUnk, pEntries->piid);
					else
					{
						AtlGetObjectSourceInterface(spUnk, &pDE->m_libid, &pDE->m_iid, &pDE->m_wMajorVerNum, &pDE->m_wMinorVerNum);
						hr = pDE->DispEventAdvise(spUnk, &pDE->m_iid);
					}
				}
				else
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventUnadvise(spUnk, pEntries->piid);
					else
						hr = pDE->DispEventUnadvise(spUnk, &pDE->m_iid);
				}
				ATLASSERT(hr == S_OK);
			}
		}
		if (FAILED(hr))
			break;
		pEntries++;
	}
	return hr;
}

template <UINT nID, class T, const IID* pdiid = &IID_NULL, const GUID* plibid = &GUID_NULL, 
	WORD wMajor = 0, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispEventImpl : public IDispEventSimpleImpl<nID, T, pdiid>
{
public:
	typedef tihclass _tihclass;

	IDispEventImpl()
	{
		m_libid = *plibid;
		m_iid = *pdiid;
		m_wMajorVerNum = wMajor;
		m_wMinorVerNum = wMinor;
	}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{*pctinfo = 1; return S_OK;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

	//Helper for finding the function index for a DISPID
	HRESULT GetFuncInfoFromId(const IID& /*iid*/, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
	{
		CComPtr<ITypeInfo> spTypeInfo;
		if (InlineIsEqualGUID(*_tih.m_plibid, GUID_NULL))
		{
			_tih.m_plibid = &m_libid;
			_tih.m_pguid = &m_iid;
			_tih.m_wMajor = m_wMajorVerNum;
			_tih.m_wMinor = m_wMinorVerNum;
		}
		HRESULT hr = _tih.GetTI(lcid, &spTypeInfo);
		if (FAILED(hr))
			return hr;
		CComQIPtr<ITypeInfo2, &IID_ITypeInfo2> spTypeInfo2 = spTypeInfo;
		FUNCDESC* pFuncDesc = NULL;
		if (spTypeInfo2 != NULL)
		{
			UINT nIndex;
			hr = spTypeInfo2->GetFuncIndexOfMemId(dispidMember, INVOKE_FUNC, &nIndex);
			if (FAILED(hr))
				return hr;
			hr = spTypeInfo->GetFuncDesc(nIndex, &pFuncDesc);
			if (FAILED(hr))
				return hr;
		}
		else // search for funcdesc
		{
			TYPEATTR* pAttr;
			hr = spTypeInfo->GetTypeAttr(&pAttr);
			if (FAILED(hr))
				return hr;
			for (int i=0;i<pAttr->cFuncs;i++)
			{
				hr = spTypeInfo->GetFuncDesc(i, &pFuncDesc);
				if (FAILED(hr))
					return hr;
				if (pFuncDesc->memid == dispidMember)
					break;
				spTypeInfo->ReleaseFuncDesc(pFuncDesc);
				pFuncDesc = NULL;
			}
			spTypeInfo->ReleaseTypeAttr(pAttr);
			if (pFuncDesc == NULL)
				return E_FAIL;
		}

		// If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
		// before including atlcom.h
		ATLASSERT(pFuncDesc->cParams <= _ATL_MAX_VARTYPES);
		if (pFuncDesc->cParams > _ATL_MAX_VARTYPES)
			return E_FAIL;

		for (int i=0; i<pFuncDesc->cParams; i++)
		{
			info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[pFuncDesc->cParams - i - 1].tdesc.vt;
			if (info.pVarTypes[i] == VT_PTR)
				info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[pFuncDesc->cParams - i - 1].tdesc.lptdesc->vt | VT_BYREF;
			if (info.pVarTypes[i] == VT_USERDEFINED)
				info.pVarTypes[i] = GetUserDefinedType(spTypeInfo,pFuncDesc->lprgelemdescParam[pFuncDesc->cParams-i-1].tdesc.hreftype);
		}

		VARTYPE vtReturn = pFuncDesc->elemdescFunc.tdesc.vt;
		switch(vtReturn)
		{
		case VT_INT:
			vtReturn = VT_I4;
			break;
		case VT_UINT:
			vtReturn = VT_UI4;
			break;
		case VT_VOID:
			vtReturn = VT_EMPTY; // this is how DispCallFunc() represents void
			break;
		case VT_HRESULT:
			vtReturn = VT_ERROR;
			break;
		}
		info.vtReturn = vtReturn;
		info.cc = pFuncDesc->callconv;
		info.nParams = pFuncDesc->cParams;
		spTypeInfo->ReleaseFuncDesc(pFuncDesc);
		return S_OK;
	}
	VARTYPE GetUserDefinedType(ITypeInfo *pTI, HREFTYPE hrt)
	{
		CComPtr<ITypeInfo> spTypeInfo;
		VARTYPE vt = VT_USERDEFINED;
		HRESULT hr = E_FAIL;
		hr = pTI->GetRefTypeInfo(hrt, &spTypeInfo);
		if(FAILED(hr))
			return vt;
		TYPEATTR *pta=NULL;

		spTypeInfo->GetTypeAttr(&pta);
		if(pta && pta->typekind == TKIND_ALIAS)
		{
			if (pta->tdescAlias.vt == VT_USERDEFINED)
				GetUserDefinedType(spTypeInfo,pta->tdescAlias.hreftype);
			else
				vt = pta->tdescAlias.vt;
		}
	
		if(pta)
			spTypeInfo->ReleaseTypeAttr(pta);
		return vt;

	}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{return _tih.GetTI(lcid, ppInfo);}
};


template <UINT nID, class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
	{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};

template <class T>
struct _ATL_EVENT_ENTRY
{
	UINT nControlID;			//ID identifying object instance
	const IID* piid;			//dispinterface IID
	int nOffset;				//offset of dispinterface from this pointer
	DISPID dispid;				//DISPID of method/property
	void (__stdcall T::*pfn)();	//method to invoke
	_ATL_FUNC_INFO* pInfo;
};



//Sink map is used to set up event handling
#define BEGIN_SINK_MAP(_class)\
	static const _ATL_EVENT_ENTRY<_class>* _GetSinkMap()\
	{\
		typedef _class _atl_event_classtype;\
		static const _ATL_EVENT_ENTRY<_class> map[] = {


#define SINK_ENTRY_INFO(id, iid, dispid, fn, info) {id, &iid, (int)(static_cast<_IDispEventLocator<id, &iid>*>((_atl_event_classtype*)8))-8, dispid, (void (__stdcall _atl_event_classtype::*)())fn, info},
#define SINK_ENTRY_EX(id, iid, dispid, fn) SINK_ENTRY_INFO(id, iid, dispid, fn, NULL)
#define SINK_ENTRY(id, dispid, fn) SINK_ENTRY_EX(id, IID_NULL, dispid, fn)
#define END_SINK_MAP() {0, NULL, 0, 0, NULL, NULL} }; return map;}

/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl

template <class T, const IID* piid, const GUID* plibid = &CComModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispatchImpl : public T
{
public:
	typedef tihclass _tihclass;
// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
	}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		return _tih.GetTI(lcid, ppInfo);
	}
};

template <class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfoImpl
template <const CLSID* pcoclsid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfoImpl : public IProvideClassInfo
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}

protected:
	static _tihclass _tih;
};

template <const CLSID* pcoclsid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};

/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfo2Impl
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfo2Impl : public IProvideClassInfo2
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}
	STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID)
	{
		if (pGUID == NULL)
			return E_POINTER;

		if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID && psrcid)
		{
			*pGUID = *psrcid;
			return S_OK;
		}
		*pGUID = GUID_NULL;
		return E_FAIL;
	}

protected:
	static _tihclass _tih;
};


template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfoImpl

template <const IID* piid>
class ATL_NO_VTABLE ISupportErrorInfoImpl : public ISupportErrorInfo
{
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static HRESULT copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T)); return S_OK;}
	static void init(T*) {}
	static void destroy(T*) {}
};

template<>
class _Copy<VARIANT>
{
public:
	static HRESULT copy(VARIANT* p1, VARIANT* p2) {return VariantCopy(p1, p2);}
	static void init(VARIANT* p) {p->vt = VT_EMPTY;}
	static void destroy(VARIANT* p) {VariantClear(p);}
};

template<>
class _Copy<LPOLESTR>
{
public:
	static HRESULT copy(LPOLESTR* p1, LPOLESTR* p2)
	{
		HRESULT hr = S_OK;
		(*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1));
		if (*p1 == NULL)
			hr = E_OUTOFMEMORY;
		else
			ocscpy(*p1,*p2);
		return hr;
	}
	static void init(LPOLESTR* p) {*p = NULL;}
	static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);}
};

template<>
class _Copy<OLEVERB>
{
public:
	static HRESULT copy(OLEVERB* p1, OLEVERB* p2)
	{
		HRESULT hr = S_OK;
		*p1 = *p2;
		if (p2->lpszVerbName == NULL)
			return S_OK;
		p1->lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2->lpszVerbName)+1));
		if (p1->lpszVerbName == NULL)
			hr = E_OUTOFMEMORY;
		else
			ocscpy(p1->lpszVerbName,p2->lpszVerbName);
		return hr;
	}
	static void init(OLEVERB* p) { p->lpszVerbName = NULL;}
	static void destroy(OLEVERB* p) { if (p->lpszVerbName) CoTaskMemFree(p->lpszVerbName);}
};

template<>
class _Copy<CONNECTDATA>
{
public:
	static HRESULT copy(CONNECTDATA* p1, CONNECTDATA* p2)
	{
		*p1 = *p2;
		if (p1->pUnk)
			p1->pUnk->AddRef();
		return S_OK;
	}
	static void init(CONNECTDATA* ) {}
	static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
	static HRESULT copy(T** p1, T** p2)
	{
		*p1 = *p2;
		if (*p1)
			(*p1)->AddRef();
		return S_OK;
	}
	static void init(T** ) {}
	static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class ATL_NO_VTABLE CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	HRESULT Init(T* begin, T* end, IUnknown* pUnk,
		CComEnumFlags flags = AtlFlagNoCopy);
	CComPtr<IUnknown> m_spUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	T* pelt = rgelt;
	while(nMin--)
	{
		HRESULT hr = Copy::copy(pelt, m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			if (pceltFetched != NULL)
				*pceltFetched = 0;
			return hr;
		}
		pelt++;
		m_iter++;
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(ULONG celt)
{
	m_iter += celt;
	if (m_iter <= m_end)
		return S_OK;
	m_iter = m_end;
	return S_FALSE;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(Base** ppEnum)
{
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			// If the data is a copy then we need to keep "this" object around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_spUnk);
			if (SUCCEEDED(hRes))
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(T* begin, T* end, IUnknown* pUnk,
	CComEnumFlags flags)
{
	if (flags == AtlFlagCopy)
	{
		ATLASSERT(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[end-begin])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			HRESULT hr = Copy::copy(m_iter, i);
			if (FAILED(hr))
			{
				T* p = m_begin;
				while (p < m_iter)
					Copy::destroy(p++);
				delete [] m_begin;
				m_begin = m_end = m_iter = NULL;
				return hr;
			}
			m_iter++;
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_spUnk = pUnk;
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnum :
	public CComEnumImpl<Base, piid, T, Copy>,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnum<Base, piid, T, Copy > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class Base, const IID* piid, class T, class Copy, class CollType>
class ATL_NO_VTABLE IEnumOnSTLImpl : public Base
{
public:
	HRESULT Init(IUnknown *pUnkForRelease, CollType& collection)
	{
		m_spUnk = pUnkForRelease;
		m_pcollection = &collection;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void)
	{
		if (m_pcollection == NULL)
			return E_FAIL;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Clone)(Base** ppEnum);
//Data
	CComPtr<IUnknown> m_spUnk;
	CollType* m_pcollection;
	CollType::iterator m_iter;
};

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_pcollection == NULL)
		return E_FAIL;

	ULONG nActual = 0;
	HRESULT hr = S_OK;
	T* pelt = rgelt;
	while (SUCCEEDED(hr) && m_iter != m_pcollection->end() && nActual < celt)
	{
		hr = Copy::copy(pelt, &*m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			nActual = 0;
		}
		else
		{
			pelt++;
			m_iter++;
			nActual++;
		}
	}
	if (pceltFetched)
		*pceltFetched = nActual;
	if (SUCCEEDED(hr) && (nActual < celt))
		hr = S_FALSE;
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Skip(ULONG celt)
{
	HRESULT hr = S_OK;
	while (celt--)
	{
		if (m_iter != m_pcollection->end())
			m_iter++;
		else
		{
			hr = S_FALSE;
			break;
		}
	}
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Clone(Base** ppEnum)
{
	typedef CComObject<CComEnumOnSTL<Base, piid, T, Copy, CollType> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			hRes = p->Init(m_spUnk, *m_pcollection);
			if (SUCCEEDED(hRes))
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnumOnSTL :
	public IEnumOnSTLImpl<Base, piid, T, Copy, CollType>,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel > _CComEnum;
	typedef IEnumOnSTLImpl<Base, piid, T, Copy, CollType > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class T, class CollType, class ItemType, class CopyItem, class EnumType>
class ICollectionOnSTLImpl : public T
{
public:
	STDMETHOD(get_Count)(long* pcount)
	{
		if (pcount == NULL)
			return E_POINTER;
		*pcount = m_coll.size();
		return S_OK;
	}
	STDMETHOD(get_Item)(long Index, ItemType* pvar)
	{
		//Index is 1-based
		if (pvar == NULL)
			return E_POINTER;
		HRESULT hr = E_FAIL;
		Index--;
		CollType::iterator iter = m_coll.begin();
		while (iter != m_coll.end() && Index > 0)
		{
			iter++;
			Index--;
		}
		if (iter != m_coll.end())
			hr = CopyItem::copy(pvar, &*iter);
		return hr;
	}
	STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hRes = S_OK;
		CComObject<EnumType>* p;
		hRes = CComObject<EnumType>::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			hRes = p->Init(this, m_coll);
			if (hRes == S_OK)
				hRes = p->QueryInterface(IID_IUnknown, (void**)ppUnk);
		}
		if (hRes != S_OK)
			delete p;
		return hRes;
	}
	CollType m_coll;
};

//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl : public ISpecifyPropertyPages
{
public:
	// ISpecifyPropertyPages
	//
	STDMETHOD(GetPages)(CAUUID* pPages)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("ISpecifyPropertyPagesImpl::GetPages\n"));
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		return GetPagesHelper(pPages, pMap);
	}
protected:
	HRESULT GetPagesHelper(CAUUID* pPages, ATL_PROPMAP_ENTRY* pMap)
	{
		ATLASSERT(pMap != NULL);
		if (pMap == NULL)
			return E_POINTER;

		int nCnt = 0;
		// Get count of unique pages to alloc the array
		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			// only allow non data entry types
			if (pMap[i].vt == 0)
			{
				// Does this property have a page?  CLSID_NULL means it does not
				if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
					nCnt++;
			}
		}
		pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
		if (pPages->pElems == NULL)
			return E_OUTOFMEMORY;
		// reset count of items we have added to the array
		nCnt = 0;
		for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			// only allow non data entry types
			if (pMap[i].vt == 0)
			{
				// Does this property have a page?  CLSID_NULL means it does not
				if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
				{
					BOOL bFound = FALSE;
					// Search through array we are building up to see
					// if it is already in there
					for (int j=0; j<nCnt; j++)
					{
						if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
						{
							// It's already there, so no need to add it again
							bFound = TRUE;
							break;
						}
					}
					// If we didn't find it in there then add it
					if (!bFound)
						pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
				}
			}
		}
		pPages->cElems = nCnt;
		return S_OK;
	}

};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
	DWORD dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
	typedef x _atl_conn_classtype;\
	static const _ATL_CONNMAP_ENTRY* GetConnMap(int* pnEntries) {\
	static const _ATL_CONNMAP_ENTRY _entries[] = {
// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(iid){offsetofclass(_ICPLocator<&iid>, _atl_conn_classtype)-\
	offsetofclass(IConnectionPointContainerImpl<_atl_conn_classtype>, _atl_conn_classtype)},
#define END_CONNECTION_POINT_MAP() {(DWORD)-1} }; \
	if (pnEntries) *pnEntries = sizeof(_entries)/sizeof(_ATL_CONNMAP_ENTRY) - 1; \
	return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComUnkArray
{
public:
	CComUnkArray()
	{
		memset(m_arr, 0, sizeof(IUnknown*)*nMaxSize);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	static DWORD WINAPI GetCookie(IUnknown** pp)
	{
		return (DWORD)pp;
	}
	static IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		return dwCookie ? *(IUnknown**)dwCookie : 0;
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return &m_arr[nMaxSize];
	}
protected:
	IUnknown* m_arr[nMaxSize];
};

template <unsigned int nMaxSize>
inline DWORD CComUnkArray<nMaxSize>::Add(IUnknown* pUnk)
{
	for (IUnknown** pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			return (DWORD)pp; // return cookie
		}
	}
	// If this fires then you need a larger array
	ATLASSERT(0);
	return 0;
}

template <unsigned int nMaxSize>
inline BOOL CComUnkArray<nMaxSize>::Remove(DWORD dwCookie)
{
	IUnknown** pp = (IUnknown**)dwCookie;
	BOOL b = ((pp >= begin()) && (pp < end()));
	if (b)
		*pp = NULL;
	return b;
}

template<>
class CComUnkArray<1>
{
public:
	CComUnkArray()
	{
		m_arr[0] = NULL;
	}
	DWORD Add(IUnknown* pUnk)
	{
		if (m_arr[0] != NULL)
		{
			// If this fires then you need a larger array
			ATLASSERT(0);
			return 0;
		}
		m_arr[0] = pUnk;
		return (DWORD)&m_arr[0];
	}
	BOOL Remove(DWORD dwCookie)
	{
		if (dwCookie != (DWORD)&m_arr[0])
			return FALSE;
		m_arr[0] = NULL;
		return TRUE;
	}
	static DWORD WINAPI GetCookie(IUnknown** pp)
	{
		return (DWORD)pp;
	}
	static IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		return dwCookie ? *(IUnknown**)dwCookie : 0;
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return (&m_arr[0])+1;
	}
protected:
	IUnknown* m_arr[1];
};

class CComDynamicUnkArray
{
public:
	CComDynamicUnkArray()
	{
		m_nSize = 0;
		m_ppUnk = NULL;
	}

	~CComDynamicUnkArray()
	{
		if (m_nSize > 1)
			free(m_ppUnk);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	static DWORD WINAPI GetCookie(IUnknown** pp)
	{
		return (DWORD)*pp;
	}
	static IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		return (IUnknown*)dwCookie;
	}
	IUnknown** begin()
	{
		return (m_nSize < 2) ? &m_pUnk : m_ppUnk;
	}
	IUnknown** end()
	{
		return (m_nSize < 2) ? (&m_pUnk)+m_nSize : &m_ppUnk[m_nSize];
	}

	IUnknown* GetAt(int nIndex)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return NULL;

		return (m_nSize < 2) ? m_pUnk : m_ppUnk[nIndex];
	}
	int GetSize() const
	{
		return m_nSize;
	}

	void clear()
	{
		if (m_nSize > 1)
			free(m_ppUnk);
		m_nSize = 0;
	}
protected:
	union
	{
		IUnknown** m_ppUnk;
		IUnknown* m_pUnk;
	};
	int m_nSize;
};

inline DWORD CComDynamicUnkArray::Add(IUnknown* pUnk)
{
	IUnknown** pp = NULL;
	if (m_nSize == 0) // no connections
	{
		m_pUnk = pUnk;
		m_nSize = 1;
		return (DWORD)m_pUnk;
	}
	else if (m_nSize == 1)
	{
		//create array
		pp = (IUnknown**)malloc(sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		if (pp == NULL)
			return 0;
		memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		*pp = m_pUnk;
		m_ppUnk = pp;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			return (DWORD)pUnk;
		}
	}
	int nAlloc = m_nSize*2;
	pp = (IUnknown**)realloc(m_ppUnk, sizeof(IUnknown*)*nAlloc);
	if (pp == NULL)
		return 0;
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);
	m_ppUnk[m_nSize] = pUnk;
	m_nSize = nAlloc;
	return (DWORD)pUnk;
}

inline BOOL CComDynamicUnkArray::Remove(DWORD dwCookie)
{
	IUnknown** pp;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
	if (m_nSize == 1)
	{
		if ((DWORD)m_pUnk == dwCookie)
		{
			m_nSize = 0;
			return TRUE;
		}
		return FALSE;
	}
	for (pp=begin();pp<end();pp++)
	{
		if ((DWORD)*pp == dwCookie)
		{
			*pp = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

template <const IID* piid>
class ATL_NO_VTABLE _ICPLocator
{
public:
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IConnectionPointImpl : public _ICPLocator<piid>
{
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
	typedef CDV _CDV;
public:
	~IConnectionPointImpl();
	STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject)
	{
		if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualUnknown(riid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
			return S_OK;
		}
		else
			return E_NOINTERFACE;
	}

	STDMETHOD(GetConnectionInterface)(IID* piid2)
	{
		if (piid2 == NULL)
			return E_POINTER;
		*piid2 = *piid;
		return S_OK;
	}
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC)
	{
		T* pT = static_cast<T*>(this);
		// No need to check ppCPC for NULL since QI will do that for us
		return pT->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
	}
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);
	CDV m_vec;
};

template <class T, const IID* piid, class CDV>
IConnectionPointImpl<T, piid, CDV>::~IConnectionPointImpl()
{
	IUnknown** pp = m_vec.begin();
	while (pp < m_vec.end())
	{
		if (*pp != NULL)
			(*pp)->Release();
		pp++;
	}
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	T* pT = static_cast<T*>(this);
	IUnknown* p;
	HRESULT hRes = S_OK;
	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;
	IID iid;
	GetConnectionInterface(&iid);
	hRes = pUnkSink->QueryInterface(iid, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		pT->Lock();
		*pdwCookie = m_vec.Add(p);
		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;
		pT->Unlock();
		if (hRes != S_OK)
			p->Release();
	}
	else if (hRes == E_NOINTERFACE)
		hRes = CONNECT_E_CANNOTCONNECT;
	if (FAILED(hRes))
		*pdwCookie = 0;
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Unadvise(DWORD dwCookie)
{
	T* pT = static_cast<T*>(this);
	pT->Lock();
	IUnknown* p = _CDV::GetUnknown(dwCookie);
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	pT->Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::EnumConnections(
	IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	T* pT = static_cast<T*>(this);
	pT->Lock();
	CONNECTDATA* pcd = NULL;
	ATLTRY(pcd = new CONNECTDATA[m_vec.end()-m_vec.begin()])
	if (pcd == NULL)
	{
		delete pEnum;
		pT->Unlock();
		return E_OUTOFMEMORY;
	}
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)
	{
		if (*pp != NULL)
		{
			(*pp)->AddRef();
			pend->pUnk = *pp;
			pend->dwCookie = _CDV::GetCookie(pp);
			pend++;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
	pT->Unlock();
	HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IConnectionPointContainerImpl

template <class T>
class ATL_NO_VTABLE IConnectionPointContainerImpl : public IConnectionPointContainer
{
	typedef CComEnum<IEnumConnectionPoints,
		&IID_IEnumConnectionPoints, IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:
	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum)
	{
		if (ppEnum == NULL)
			return E_POINTER;
		*ppEnum = NULL;
		CComEnumConnectionPoints* pEnum = NULL;
		ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
		if (pEnum == NULL)
			return E_OUTOFMEMORY;

		int nCPCount;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(&nCPCount);

		// allocate an initialize a vector of connection point object pointers
		IConnectionPoint** ppCP = (IConnectionPoint**)alloca(sizeof(IConnectionPoint*)*nCPCount);

		int i = 0;
		while (pEntry->dwOffset != (DWORD)-1)
		{
			ppCP[i++] = (IConnectionPoint*)((int)this+pEntry->dwOffset);
			pEntry++;
		}

		// copy the pointers: they will AddRef this object
		HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
			(IConnectionPoint**)&ppCP[nCPCount],
			reinterpret_cast<IConnectionPointContainer*>(this), AtlFlagCopy);
		if (FAILED(hRes))
		{
			delete pEnum;
			return hRes;
		}
		hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
		if (FAILED(hRes))
			delete pEnum;
		return hRes;
	}
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP)
	{
		if (ppCP == NULL)
			return E_POINTER;
		*ppCP = NULL;
		HRESULT hRes = CONNECT_E_NOCONNECTION;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(NULL);
		IID iid;
		while (pEntry->dwOffset != (DWORD)-1)
		{
			IConnectionPoint* pCP =
				(IConnectionPoint*)((int)this+pEntry->dwOffset);
			if (SUCCEEDED(pCP->GetConnectionInterface(&iid)) &&
				InlineIsEqualGUID(riid, iid))
			{
				*ppCP = pCP;
				pCP->AddRef();
				hRes = S_OK;
				break;
			}
			pEntry++;
		}
		return hRes;
	}
};


#endif //!_ATL_NO_CONNECTION_POINTS

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CComAutoThreadModule

template <class ThreadAllocator>
inline HRESULT CComAutoThreadModule<ThreadAllocator>::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid, int nThreads)
{
	m_nThreads = nThreads;
	m_pApartments = NULL;
	ATLTRY(m_pApartments = new CComApartment[m_nThreads]);
	ATLASSERT(m_pApartments != NULL);
	if(m_pApartments == NULL)
		return E_OUTOFMEMORY;
	for (int i = 0; i < nThreads; i++)
		m_pApartments[i].m_hThread = CreateThread(NULL, 0, CComApartment::_Apartment, (void*)&m_pApartments[i], 0, &m_pApartments[i].m_dwThreadID);
	CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT"));
	return CComModule::Init(p, h, plibid);
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Lock()
{
	LONG l = CComModule::Lock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Lock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Unlock()
{
	LONG l = CComModule::Unlock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Unlock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
HRESULT CComAutoThreadModule<ThreadAllocator>::CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj)
{
	_ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance;
	_AtlAptCreateObjData data;
	data.pfnCreateInstance = pFunc;
	data.piid = &riid;
	data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	data.hRes = S_OK;
	int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads);
	::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&data);
	AtlWaitWithMessageLoop(data.hEvent);
	CloseHandle(data.hEvent);
	if (SUCCEEDED(data.hRes))
		data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj);
	return data.hRes;
}

template <class ThreadAllocator>
CComAutoThreadModule<ThreadAllocator>::~CComAutoThreadModule()
{
	for (int i=0; i < m_nThreads; i++)
	{
		::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0);
		::WaitForSingleObject(m_pApartments[i].m_hThread, INFINITE);
	}
	delete[] m_pApartments;
}


}; //namespace ATL

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\atl\atlctl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Active Template Library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include "atlwin.h"

#include <objsafe.h>
#include <urlmon.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")


#define DECLARE_VIEW_STATUS(statusFlags) \
	DWORD _GetViewStatus() \
	{ \
		return statusFlags; \
	}

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#include "atliface.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

struct ATL_DRAWINFO
{
	UINT cbSize;
	DWORD dwDrawAspect;
	LONG lindex;
	DVTARGETDEVICE* ptd;
	HDC hicTargetDev;
	HDC hdcDraw;
	LPCRECTL prcBounds; //Rectangle in which to draw
	LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
	BOOL bOptimize;
	BOOL bZoomed;
	BOOL bRectInHimetric;
	SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
	SIZEL ZoomDen;
};

namespace ATL
{

#pragma pack(push, _ATL_PACKING)

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T, class WinBase> class CComControl;

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent


// Helper functions for safely communicating with objects who sink IPropertyNotifySink
class CFirePropNotifyEvent
{
public:
	// Ask any objects sinking the IPropertyNotifySink notification if it is ok to edit a specified property
	static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				HRESULT hr = S_OK;
				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
				if (pSink)
					hr = pSink->OnRequestEdit(dispID);
				cd.pUnk->Release();
				if (hr == S_FALSE)
					return S_FALSE;
			}
		}
		return S_OK;
	}
	// Notify any objects sinking the IPropertyNotifySink notification that a property has changed
	static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
				if (pSink)
					pSink->OnChanged(dispID);
				cd.pUnk->Release();
			}
		}
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// CComControlBase

// Holds the essential data members for an ActiveX control and useful helper functions
class ATL_NO_VTABLE CComControlBase
{
public:
	CComControlBase(HWND& h) : m_hWndCD(h)
	{
		memset(this, 0, sizeof(CComControlBase));
		m_phWndCD = &h;
		m_sizeExtent.cx = 2*2540;
		m_sizeExtent.cy = 2*2540;
		m_sizeNatural = m_sizeExtent;
	}
	~CComControlBase()
	{
		if (m_hWndCD != NULL)
			::DestroyWindow(m_hWndCD);
		ATLTRACE2(atlTraceControls,2,_T("Control Destroyed\n"));
	}

// methods
public:
	// Control helper functions can go here non-virtuals only please

	// Mark the control 'dirty' so the container will save it
	void SetDirty(BOOL bDirty)
	{
		m_bRequiresSave = bDirty;
	}
	// Obtain the dirty state for the control 
	BOOL GetDirty()
	{
		return m_bRequiresSave ? TRUE : FALSE;
	}
	// Get the zoom factor (numerator & denominator) which is factor of the natural extent
	void GetZoomInfo(ATL_DRAWINFO& di);
	// Sends a notification that the moniker for the control has changed
	HRESULT SendOnRename(IMoniker *pmk)
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnRename(pmk);
		return hRes;
	}
	// Sends a notification that the control has just saved its data
	HRESULT SendOnSave()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnSave();
		return hRes;
	}
	// Sends a notification that the control has closed its advisory sinks
	HRESULT SendOnClose()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnClose();
		return hRes;
	}
	// Sends a notification that the control's data has changed
	HRESULT SendOnDataChange(DWORD advf = 0);
	// Sends a notification that the control's representation has changed
	HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1)
	{
		if (m_spAdviseSink)
			m_spAdviseSink->OnViewChange(dwAspect, lindex);
		return S_OK;
	}
	// Sends a notification to the container that the control has received focus
	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if (m_bInPlaceActive)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
			CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
			if (m_bInPlaceActive && spSite != NULL)
				spSite->OnFocus(TRUE);
		}
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))
			spSite->OnFocus(FALSE);
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnMouseActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		BOOL bUserMode = TRUE;
		HRESULT hRet = GetAmbientUserMode(bUserMode);
		// UI activate if in user mode only
		// allow activation if we can't determine mode
		if (FAILED(hRet) || bUserMode)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
		}
		bHandled = FALSE;
		return 1;
	}
	BOOL PreTranslateAccelerator(LPMSG /*pMsg*/, HRESULT& /*hRet*/)
	{
		return FALSE;
	}

	HRESULT GetAmbientProperty(DISPID dispid, VARIANT& var)
	{
		HRESULT hRes = E_FAIL;
		if (m_spAmbientDispatch.p != NULL)
			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
		return hRes;
	}
	HRESULT GetAmbientAppearance(short& nAppearance)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
		ATLASSERT(var.vt == VT_I2 || var.vt == VT_UI2 || var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		nAppearance = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientBackColor(OLE_COLOR& BackColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		BackColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayName(BSTR& bstrDisplayName)
	{
		CComVariant var;
		if (bstrDisplayName)
		{
			SysFreeString(bstrDisplayName);
			bstrDisplayName = NULL;
		}
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
		if (SUCCEEDED(hRes))
		{
			if (var.vt != VT_BSTR)
				return E_FAIL;
			bstrDisplayName = var.bstrVal;
			var.vt = VT_EMPTY;
			var.bstrVal = NULL;
		}
		return hRes;
	}
	HRESULT GetAmbientFont(IFont** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientFontDisp(IFontDisp** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFontDisp, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientForeColor(OLE_COLOR& ForeColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		ForeColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientLocaleID(LCID& lcid)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
		ATLASSERT((var.vt == VT_UI4 || var.vt == VT_I4) || FAILED(hRes));
		lcid = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientScaleUnits(BSTR& bstrScaleUnits)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
		ATLASSERT(var.vt == VT_BSTR || FAILED(hRes));
		bstrScaleUnits = var.bstrVal;
		return hRes;
	}
	HRESULT GetAmbientTextAlign(short& nTextAlign)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
		ATLASSERT(var.vt == VT_I2 || FAILED(hRes));
		nTextAlign = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientUserMode(BOOL& bUserMode)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bUserMode = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientUIDead(BOOL& bUIDead)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bUIDead = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowGrabHandles(BOOL& bShowGrabHandles)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bShowGrabHandles = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowHatching(BOOL& bShowHatching)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bShowHatching = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientMessageReflect(BOOL& bMessageReflect)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bMessageReflect = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientAutoClip(BOOL& bAutoClip)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bAutoClip = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayAsDefault(BOOL& bDisplaysDefault)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bDisplaysDefault = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientSupportsMnemonics(BOOL& bSupportMnemonics)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bSupportMnemonics = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientPalette(HPALETTE& hPalette)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		hPalette = reinterpret_cast<HPALETTE>(var.lVal);
		return hRes;
	}

	HRESULT InternalGetSite(REFIID riid, void** ppUnkSite)
	{
		ATLASSERT(ppUnkSite != NULL);
		if (ppUnkSite == NULL)
			return E_POINTER;
		if (m_spClientSite == NULL)
		{
			*ppUnkSite = NULL;
			return S_OK;
		}
		return m_spClientSite->QueryInterface(riid, ppUnkSite);
	}

	BOOL DoesVerbUIActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
				b = TRUE;
				break;
		}
		// if no ambient dispatch then in old style OLE container
		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
			b = TRUE;
		return b;
	}

	BOOL DoesVerbActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
			case OLEIVERB_SHOW:
			case OLEIVERB_INPLACEACTIVATE:
				b = TRUE;
				break;
		}
		return b;
	}

	BOOL SetControlFocus(BOOL bGrab);
	HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont,
		QACONTROL *pQACtrl);
	HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent);
	HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);

	HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite);
	HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite);
	HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	HRESULT IOleObject_Close(DWORD dwSaveOption);
	HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
	HRESULT IOleInPlaceObject_UIDeactivate(void);
	HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip);
	HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
		DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
		LPCRECTL prcBounds, LPCRECTL prcWBounds);
	HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);

	HRESULT FireViewChange();
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos) = 0;
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv) = 0;
	virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
	virtual HRESULT OnDraw(ATL_DRAWINFO& /*di*/)
	{
		return S_OK;
	}


// Attributes
public:
	CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
	CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
	CComPtr<IOleClientSite> m_spClientSite;
	CComPtr<IAdviseSink> m_spAdviseSink;
	CComDispatchDriver m_spAmbientDispatch;

	SIZE m_sizeNatural; //unscaled size in himetric
	SIZE m_sizeExtent;  //current extents in himetric
	RECT m_rcPos; // position in pixels
#pragma warning(disable: 4510 4610) // unnamed union
	union
	{
		HWND& m_hWndCD;
		HWND* m_phWndCD;
	};
#pragma warning(default: 4510 4610)
	union
	{
		// m_nFreezeEvents is the only one actually used
		int m_nFreezeEvents; // count of freezes versus thaws

		// These are here to make stock properties work
		IPictureDisp* m_pMouseIcon;
		IPictureDisp* m_pPicture;
		IFontDisp* m_pFont;
		OLE_COLOR m_clrBackColor;
		OLE_COLOR m_clrBorderColor;
		OLE_COLOR m_clrFillColor;
		OLE_COLOR m_clrForeColor;
		BSTR m_bstrText;
		BSTR m_bstrCaption;
		BOOL m_bValid;
		BOOL m_bTabStop;
		BOOL m_bBorderVisible;
		BOOL m_bEnabled;
		LONG m_nBackStyle;
		LONG m_nBorderStyle;
		LONG m_nBorderWidth;
		LONG m_nDrawMode;
		LONG m_nDrawStyle;
		LONG m_nDrawWidth;
		LONG m_nFillStyle;
		SHORT m_nAppearance;
		LONG m_nMousePointer;
		LONG m_nReadyState;
	};

	unsigned m_bNegotiatedWnd:1;
	unsigned m_bWndLess:1;
	unsigned m_bInPlaceActive:1;
	unsigned m_bUIActive:1;
	unsigned m_bUsingWindowRgn:1;
	unsigned m_bInPlaceSiteEx:1;
	unsigned m_bWindowOnly:1;
	unsigned m_bRequiresSave:1;
	unsigned m_bWasOnceWindowless:1;
	unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
	unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
	unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
	unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
	unsigned m_bDrawGetDataInHimetric:1; //instead of pixels

	DECLARE_VIEW_STATUS(VIEWSTATUS_OPAQUE)
};

inline HRESULT CComControlBase::IQuickActivate_QuickActivate(QACONTAINER *pQACont,
	QACONTROL *pQACtrl)
{
	ATLASSERT(pQACont != NULL);
	ATLASSERT(pQACtrl != NULL);
	if (!pQACont || !pQACtrl)
		return E_POINTER;

	HRESULT hRes;
	ULONG uCB = pQACtrl->cbSize;
	memset(pQACtrl, 0, uCB);
	pQACtrl->cbSize = uCB;

	// get all interfaces we are going to need
	CComPtr<IOleObject> pOO;
	ControlQueryInterface(IID_IOleObject, (void**)&pOO);
	CComPtr<IViewObjectEx> pVOEX;
	ControlQueryInterface(IID_IViewObjectEx, (void**)&pVOEX);
	CComPtr<IPointerInactive> pPI;
	ControlQueryInterface(IID_IPointerInactive, (void**)&pPI);
	CComPtr<IProvideClassInfo2> pPCI;
	ControlQueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);

	if (pOO == NULL || pVOEX == NULL)
		return E_FAIL;

	pOO->SetClientSite(pQACont->pClientSite);

	if (pQACont->pAdviseSink != NULL)
	{
		ATLTRACE2(atlTraceControls,2,_T("Setting up IOleObject Advise\n"));
		pVOEX->SetAdvise(DVASPECT_CONTENT, 0, pQACont->pAdviseSink);
	}

	CComPtr<IConnectionPointContainer> pCPC;
	ControlQueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	if (pQACont->pPropertyNotifySink)
	{
		ATLTRACE2(atlTraceControls,2,_T("Setting up PropNotify CP\n"));
		CComPtr<IConnectionPoint> pCP;
		if (pCPC != NULL)
		{
			hRes = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
			if (SUCCEEDED(hRes))
				pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);
		}
	}

	if (pPCI)
	{
		GUID iidDefaultSrc;
		if (SUCCEEDED(pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
			&iidDefaultSrc)))
		{
			if (pQACont->pUnkEventSink)
			{
				ATLTRACE2(atlTraceControls,2,_T("Setting up Default Out Going Interface\n"));
				CComPtr<IConnectionPoint> pCP;
				if (pCPC != NULL)
				{
					hRes = pCPC->FindConnectionPoint(iidDefaultSrc, &pCP);
					if (SUCCEEDED(hRes))
						pCP->Advise(pQACont->pUnkEventSink, &pQACtrl->dwEventCookie);
				}
			}
		}
	}
	// give information to container
	if (pOO != NULL)
		pOO->GetMiscStatus(DVASPECT_CONTENT, &pQACtrl->dwMiscStatus);

	if (pVOEX != NULL)
		pVOEX->GetViewStatus(&pQACtrl->dwViewStatus);

	if (pPI != NULL)
		pPI->GetActivationPolicy(&pQACtrl->dwPointerActivationPolicy);
	return S_OK;
}

inline BOOL CComControlBase::SetControlFocus(BOOL bGrab)
{
	if (m_bWndLess)
	{
		if (!m_bUIActive && bGrab)
			if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE)))
				return FALSE;

		return (m_spInPlaceSite->SetFocus(bGrab) == S_OK);
	}
	else
	{
		// we've got a window.
		//
		if (m_bInPlaceActive)
		{
			HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD);
			if (!m_bUIActive && bGrab)
				return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
			else
			{
				if (!::IsChild(hwnd, ::GetFocus()))
					::SetFocus(hwnd);
				return TRUE;
			}
		}
	}
	return FALSE;
}

inline HRESULT CComControlBase::DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent)
{
	HRESULT hr = S_OK;
	CComQIPtr <ISpecifyPropertyPages, &IID_ISpecifyPropertyPages> spPages;
	CComQIPtr <IOleObject, &IID_IOleObject> spObj;
	CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);

	if (spSite)
	{
		hr = spSite->ShowPropertyFrame();
		if (SUCCEEDED(hr))
			return hr;
	}

	CComPtr<IUnknown> pUnk;
	ControlQueryInterface(IID_IUnknown, (void**)&pUnk);
	ATLASSERT(pUnk != NULL);
	CAUUID pages;
	spPages = pUnk;
	if (spPages)
	{
		hr = spPages->GetPages(&pages);
		if (SUCCEEDED(hr))
		{
			spObj = pUnk;
			if (spObj)
			{
				LPOLESTR szTitle = NULL;

				spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

				LCID lcid;
				if (FAILED(GetAmbientLocaleID(lcid)))
					lcid = LOCALE_USER_DEFAULT;

				hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle,
					1, &pUnk.p, pages.cElems, pages.pElems, lcid, 0, 0);

				CoTaskMemFree(szTitle);
			}
			else
			{
				hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
			}
			CoTaskMemFree(pages.pElems);
		}
	}
	else
	{
		hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
	}

	return hr;
}

inline HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/)
{
	HRESULT hr;

	if (m_spClientSite == NULL)
		return S_OK;

	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);

	if (!m_bNegotiatedWnd)
	{
		if (!m_bWindowOnly)
			// Try for windowless site
			hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);

		if (m_spInPlaceSite)
		{
			m_bInPlaceSiteEx = TRUE;
			// CanWindowlessActivate returns S_OK or S_FALSE
			if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )
			{
				m_bWndLess = TRUE;
				m_bWasOnceWindowless = TRUE;
			}
			else
			{
				m_bWndLess = FALSE;
			}
		}
		else
		{
			m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
			if (m_spInPlaceSite)
				m_bInPlaceSiteEx = TRUE;
			else
				hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
		}
	}

	ATLASSERT(m_spInPlaceSite);
	if (!m_spInPlaceSite)
		return E_FAIL;

	m_bNegotiatedWnd = TRUE;

	if (!m_bInPlaceActive)
	{

		BOOL bNoRedraw = FALSE;
		if (m_bWndLess)
			m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
		else
		{
			if (m_bInPlaceSiteEx)
				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
			else
			{
				hr = m_spInPlaceSite->CanInPlaceActivate();
				// CanInPlaceActivate returns S_FALSE or S_OK
				if (FAILED(hr))
					return hr;
				if ( hr != S_OK )
				{
				   // CanInPlaceActivate returned S_FALSE.
				   return( E_FAIL );
				}
				m_spInPlaceSite->OnInPlaceActivate();
			}
		}
	}

	m_bInPlaceActive = TRUE;

	// get location in the parent window,
	// as well as some information about the parent
	//
	OLEINPLACEFRAMEINFO frameInfo;
	RECT rcPos, rcClip;
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	HWND hwndParent;
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

		if (!m_bWndLess)
		{
			if (m_hWndCD)
			{
				ShowWindow(m_hWndCD, SW_SHOW);
				if (!::IsChild(m_hWndCD, ::GetFocus()))
					::SetFocus(m_hWndCD);
			}
			else
			{
				HWND h = CreateControlWindow(hwndParent, rcPos);
				ATLASSERT(h != NULL);	// will assert if creation failed
				ATLASSERT(h == m_hWndCD);
				h;	// avoid unused warning
			}
		}

		pIPO->SetObjectRects(&rcPos, &rcClip);
	}

	CComPtr<IOleInPlaceActiveObject> spActiveObject;
	ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

	// Gone active by now, take care of UIACTIVATE
	if (DoesVerbUIActivate(iVerb))
	{
		if (!m_bUIActive)
		{
			m_bUIActive = TRUE;
			hr = m_spInPlaceSite->OnUIActivate();
			if (FAILED(hr))
				return hr;

			SetControlFocus(TRUE);
			// set ourselves up in the host.
			//
			if (spActiveObject)
			{
				if (spInPlaceFrame)
					spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
				if (spInPlaceUIWindow)
					spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
			}

			if (spInPlaceFrame)
				spInPlaceFrame->SetBorderSpace(NULL);
			if (spInPlaceUIWindow)
				spInPlaceUIWindow->SetBorderSpace(NULL);
		}
	}

	m_spClientSite->ShowObject();

	return S_OK;
}

inline HRESULT CComControlBase::SendOnDataChange(DWORD advf)
{
	HRESULT hRes = S_OK;
	if (m_spDataAdviseHolder)
	{
		CComPtr<IDataObject> pdo;
		if (SUCCEEDED(ControlQueryInterface(IID_IDataObject, (void**)&pdo)))
			hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);
	}
	return hRes;
}

inline HRESULT CComControlBase::IOleObject_SetClientSite(IOleClientSite *pClientSite)
{
	ATLASSERT(pClientSite == NULL || m_spClientSite == NULL);
	m_spClientSite = pClientSite;
	m_spAmbientDispatch.Release();
	if (m_spClientSite != NULL)
	{
		m_spClientSite->QueryInterface(IID_IDispatch,
			(void**) &m_spAmbientDispatch.p);
	}
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_GetClientSite(IOleClientSite **ppClientSite)
{
	ATLASSERT(ppClientSite);
	if (ppClientSite == NULL)
		return E_POINTER;

	*ppClientSite = m_spClientSite;
	if (m_spClientSite != NULL)
		m_spClientSite.p->AddRef();
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_Advise(IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	HRESULT hr = S_OK;
	if (m_spOleAdviseHolder == NULL)
		hr = CreateOleAdviseHolder(&m_spOleAdviseHolder);
	if (SUCCEEDED(hr))
		hr = m_spOleAdviseHolder->Advise(pAdvSink, pdwConnection);
	return hr;
}

inline HRESULT CComControlBase::IOleObject_Close(DWORD dwSaveOption)
{
	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);
	if (m_hWndCD)
	{
		if (m_spClientSite)
			m_spClientSite->OnShowWindow(FALSE);
	}

	if (m_bInPlaceActive)
	{
		HRESULT hr = pIPO->InPlaceDeactivate();
		if (FAILED(hr))
			return hr;
		ATLASSERT(!m_bInPlaceActive);
	}
	if (m_hWndCD)
	{
		ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	// handle the save flag.
	//
	if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY ||
		dwSaveOption == OLECLOSE_PROMPTSAVE) && m_bRequiresSave)
	{
		if (m_spClientSite)
			m_spClientSite->SaveObject();
		SendOnSave();
	}

	m_spInPlaceSite.Release();
	m_bNegotiatedWnd = FALSE;
	m_bWndLess = FALSE;
	m_bInPlaceSiteEx = FALSE;
	m_spAdviseSink.Release();
	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void)
{
	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);

	if (!m_bInPlaceActive)
		return S_OK;
	pIPO->UIDeactivate();

	m_bInPlaceActive = FALSE;

	// if we have a window, tell it to go away.
	//
	if (m_hWndCD)
	{
		ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	if (m_spInPlaceSite)
		m_spInPlaceSite->OnInPlaceDeactivate();

	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_UIDeactivate(void)
{
	// if we're not UIActive, not much to do.
	//
	if (!m_bUIActive)
		return S_OK;

	m_bUIActive = FALSE;

	// notify frame windows, if appropriate, that we're no longer ui-active.
	//
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	OLEINPLACEFRAMEINFO frameInfo;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	RECT rcPos, rcClip;

	HWND hwndParent; 
	// This call to GetWindow is a fix for Delphi
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
		if (spInPlaceUIWindow)
			spInPlaceUIWindow->SetActiveObject(NULL, NULL);
		if (spInPlaceFrame)
			spInPlaceFrame->SetActiveObject(NULL, NULL);
	}
	// we don't need to explicitly release the focus here since somebody
	// else grabbing the focus is what is likely to cause us to get lose it
	//
	m_spInPlaceSite->OnUIDeactivate(FALSE);

	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
	if (prcPos == NULL || prcClip == NULL)
		return E_POINTER;

	m_rcPos = *prcPos;
	if (m_hWndCD)
	{
		// the container wants us to clip, so figure out if we really
		// need to
		//
		RECT rcIXect;
		BOOL b = IntersectRect(&rcIXect, prcPos, prcClip);
		HRGN tempRgn = NULL;
		if (b && !EqualRect(&rcIXect, prcPos))
		{
			OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
			tempRgn = CreateRectRgnIndirect(&rcIXect);
		}

		SetWindowRgn(m_hWndCD, tempRgn, TRUE);

		// set our control's location, but don't change it's size at all
		// [people for whom zooming is important should set that up here]
		//
		SIZEL size = {prcPos->right - prcPos->left, prcPos->bottom - prcPos->top};
		SetWindowPos(m_hWndCD, NULL, prcPos->left,
					 prcPos->top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
	}

	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;
	if (psizel == NULL)
		return E_POINTER;

	BOOL bSizeMatchesNatural =
		memcmp(psizel, &m_sizeNatural, sizeof(SIZE)) == 0;

	if (m_bAutoSize) //object can't do any other size
		return (bSizeMatchesNatural) ? S_OK : E_FAIL;

	BOOL bResized = FALSE;
	if (memcmp(psizel, &m_sizeExtent, sizeof(SIZE)) != 0)
	{
		m_sizeExtent = *psizel;
		bResized = TRUE;
	}
	if (m_bResizeNatural && !bSizeMatchesNatural)
	{
		m_sizeNatural = *psizel;
		bResized = TRUE;
	}

	if (m_bRecomposeOnResize && bResized)
	{
		SendOnDataChange();
		FireViewChange();
	}
	return S_OK;
}

inline HRESULT CComControlBase::IViewObject_Draw(DWORD dwDrawAspect, LONG lindex,
	void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
	LPCRECTL prcBounds, LPCRECTL prcWBounds)
{
	ATLTRACE2(atlTraceControls,2,_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
		dwDrawAspect, lindex, ptd, hicTargetDev, hdcDraw);
#ifdef _DEBUG
	if (prcBounds == NULL)
		ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=NULL\n"));
	else
		ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds->left,
			prcBounds->top, prcBounds->right, prcBounds->bottom);
	if (prcWBounds == NULL)
		ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=NULL\n"));
	else
		ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds->left,
			prcWBounds->top, prcWBounds->right, prcWBounds->bottom);
#endif

	if (prcBounds == NULL)
	{
		if (!m_bWndLess)
			return E_INVALIDARG;
		prcBounds = (RECTL*)&m_rcPos;
	}

	// support the aspects required for multi-pass drawing
	switch (dwDrawAspect)
	{
		case DVASPECT_CONTENT:
		case DVASPECT_OPAQUE:
		case DVASPECT_TRANSPARENT:
			break;
		default:
			ATLASSERT(FALSE);
			return DV_E_DVASPECT;
			break;
	}

	// make sure nobody forgets to do this
	if (ptd == NULL)
		hicTargetDev = NULL;

	BOOL bOptimize = FALSE;
	if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb >= sizeof(DVASPECTINFO))
		bOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = dwDrawAspect;
	di.lindex = lindex;
	di.ptd = ptd;
	di.hicTargetDev = hicTargetDev;
	di.hdcDraw = hdcDraw;
	di.prcBounds = prcBounds;
	di.prcWBounds = prcWBounds;
	di.bOptimize = bOptimize;
	return OnDrawAdvanced(di);
}

inline HRESULT CComControlBase::IDataObject_GetData(FORMATETC *pformatetcIn,
	STGMEDIUM *pmedium)
{
	if (pmedium == NULL)
		return E_POINTER;
	memset(pmedium, 0, sizeof(STGMEDIUM));
	ATLTRACE2(atlTraceControls,2,_T("Format = %x\n"), pformatetcIn->cfFormat);
	ATLTRACE2(atlTraceControls,2,_T("TYMED = %x\n"), pformatetcIn->tymed);

	if ((pformatetcIn->tymed & TYMED_MFPICT) == 0)
		return DATA_E_FORMATETC;

	SIZEL sizeMetric, size;
	if (m_bDrawFromNatural)
		sizeMetric = m_sizeNatural;
	else
		sizeMetric = m_sizeExtent;
	if (!m_bDrawGetDataInHimetric)
		AtlHiMetricToPixel(&sizeMetric, &size);
	else
		size = sizeMetric;
	RECTL rectl = {0 ,0, size.cx, size.cy};

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.ptd = NULL;
	di.hicTargetDev = NULL;
	di.prcBounds = &rectl;
	di.prcWBounds = &rectl;
	di.bOptimize = TRUE; //we do a SaveDC/RestoreDC
	di.bRectInHimetric = m_bDrawGetDataInHimetric;
	// create appropriate memory metafile DC
	di.hdcDraw = CreateMetaFile(NULL);

	// create attribute DC according to pformatetcIn->ptd

	SaveDC(di.hdcDraw);
	SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
	SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL);
	OnDrawAdvanced(di);
	RestoreDC(di.hdcDraw, -1);

	HMETAFILE hMF = CloseMetaFile(di.hdcDraw);
	if (hMF == NULL)
		return E_UNEXPECTED;

	HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));

	if (NULL==hMem)
	{
		DeleteMetaFile(hMF);
		return ResultFromScode(STG_E_MEDIUMFULL);
	}

	LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem);
	pMF->hMF=hMF;
	pMF->mm=MM_ANISOTROPIC;
	pMF->xExt=sizeMetric.cx;
	pMF->yExt=sizeMetric.cy;
	GlobalUnlock(hMem);

	pmedium->tymed = TYMED_MFPICT;
	pmedium->hGlobal = hMem;
	pmedium->pUnkForRelease = NULL;

	return S_OK;
}

inline HRESULT CComControlBase::FireViewChange()
{
	if (m_bInPlaceActive)
	{
		// Active
		if (m_hWndCD != NULL)
			::InvalidateRect(m_hWndCD, NULL, TRUE); // Window based
		else if (m_spInPlaceSite != NULL)
			m_spInPlaceSite->InvalidateRect(NULL, TRUE); // Windowless
	}
	else // Inactive
		SendOnViewChange(DVASPECT_CONTENT);
	return S_OK;
}

inline void CComControlBase::GetZoomInfo(ATL_DRAWINFO& di)
{
	const RECTL& rcPos = *di.prcBounds;
	SIZEL sizeDen;
	if (m_bDrawFromNatural)
		sizeDen = m_sizeNatural;
	else
		sizeDen = m_sizeExtent;
	if (!di.bRectInHimetric)
		AtlHiMetricToPixel(&sizeDen, &sizeDen);
	SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top};
	di.ZoomNum.cx = sizeNum.cx;
	di.ZoomNum.cy = sizeNum.cy;
	di.ZoomDen.cx = sizeDen.cx;
	di.ZoomDen.cy = sizeDen.cy;
	if (sizeDen.cx == 0 || sizeDen.cy == 0 ||
		sizeNum.cx == 0 || sizeNum.cy == 0)
	{
		di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1;
		di.bZoomed = FALSE;
	}
	else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy)
		di.bZoomed = TRUE;
	else
		di.bZoomed = FALSE;
}

inline HRESULT CComControlBase::OnDrawAdvanced(ATL_DRAWINFO& di)
{
	BOOL bDeleteDC = FALSE;
	if (di.hicTargetDev == NULL)
	{
		di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd);
		bDeleteDC = (di.hicTargetDev != di.hdcDraw);
	}
	RECTL rectBoundsDP = *di.prcBounds;
	BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE;
	if (!bMetafile)
	{
		::LPtoDP(di.hicTargetDev, (LPPOINT)&rectBoundsDP, 2);
		SaveDC(di.hdcDraw);
		SetMapMode(di.hdcDraw, MM_TEXT);
		SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
		SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
		di.bOptimize = TRUE; //since we save the DC we can do this
	}
	di.prcBounds = &rectBoundsDP;
	GetZoomInfo(di);

	HRESULT hRes = OnDraw(di);
	if (bDeleteDC)
		::DeleteDC(di.hicTargetDev);
	if (!bMetafile)
		RestoreDC(di.hdcDraw, -1);
	return hRes;
}

inline LRESULT CComControlBase::OnPaint(UINT /* uMsg */, WPARAM wParam,
	LPARAM /* lParam */, BOOL& /* lResult */)
{
	RECT rc;
	PAINTSTRUCT ps;

	HDC hdc = (wParam != NULL) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);
	if (hdc == NULL)
		return 0;
	::GetClientRect(m_hWndCD, &rc);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.hdcDraw = hdc;
	di.prcBounds = (LPCRECTL)&rc;

	OnDrawAdvanced(di);
	if (wParam == NULL)
		::EndPaint(m_hWndCD, &ps);
	return 0;
}

template <class T, class WinBase =  CWindowImpl< T > >
class ATL_NO_VTABLE CComControl :  public CComControlBase, public WinBase
{
public:
	CComControl() : CComControlBase(m_hWnd) {}
	HRESULT FireOnRequestEdit(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
	}
	HRESULT FireOnChanged(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
	}
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv)
	{
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryInterface(iid, ppv);
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}

	typedef CComControl< T, WinBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_PAINT, CComControlBase::OnPaint)
		MESSAGE_HANDLER(WM_SETFOCUS, CComControlBase::OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, CComControlBase::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, CComControlBase::OnMouseActivate)
	END_MSG_MAP()
};

//////////////////////////////////////////////////////////////////////////////
// CComCompositeControl

#ifndef _ATL_NO_HOSTING
template <class T>
class CComCompositeControl : public CComControl< T, CAxDialogImpl< T > >
{
public:
	CComCompositeControl()
	{
		m_hbrBackground = NULL;
	}
	~CComCompositeControl()
	{
		DeleteObject(m_hbrBackground);
	}
	HRESULT AdviseSinkMap(bool bAdvise)
	{
		if(!bAdvise && m_hWnd == NULL)
		{
			// window is gone, controls are already unadvised
			ATLTRACE2(atlTraceControls, 1, _T("CComCompositeControl::AdviseSinkMap called after the window was destroyed\n"));
			return S_OK;
		}
		T* pT = static_cast<T*>(this);
		return AtlAdviseSinkMap(pT, bAdvise);
	}
	HBRUSH m_hbrBackground;
	HRESULT SetBackgroundColorFromAmbient()
	{
		if (m_hbrBackground != NULL)
		{
			DeleteObject(m_hbrBackground);
			m_hbrBackground = NULL;
		}
		OLE_COLOR clr;
		HRESULT hr = GetAmbientBackColor(clr);
		if (SUCCEEDED(hr))
		{
			COLORREF rgb;
			::OleTranslateColor(clr, NULL, &rgb);
			m_hbrBackground = ::CreateSolidBrush(rgb);
			EnumChildWindows(m_hWnd, (WNDENUMPROC)BackgroundColorEnumProc, (LPARAM) clr);
		}
		return hr;
	}
	static BOOL CALLBACK BackgroundColorEnumProc(HWND hwnd, LPARAM l)
	{
		CAxWindow wnd(hwnd);
		CComPtr<IAxWinAmbientDispatch> spDispatch;
		wnd.QueryHost(&spDispatch);
		if (spDispatch != NULL)
			spDispatch->put_BackColor((OLE_COLOR)l);
		return TRUE;
	}
	LRESULT OnDialogColor(UINT, WPARAM w, LPARAM, BOOL&)
	{
		HDC dc = (HDC) w;
		LOGBRUSH lb;
		::GetObject(m_hbrBackground, sizeof(lb), (void*)&lb);
		::SetBkColor(dc, lb.lbColor);
		return (LRESULT)m_hbrBackground;
	}
	HWND Create(HWND hWndParent, RECT& /*rcPos*/, LPARAM dwInitParam = NULL)
	{
		CComControl< T, CAxDialogImpl< T > >::Create(hWndParent, dwInitParam);
		SetBackgroundColorFromAmbient();
		if (m_hWnd != NULL)
			ShowWindow(SW_SHOWNOACTIVATE);
		return m_hWnd;
	}
	BOOL CalcExtent(SIZE& size)
	{
		HINSTANCE hInstance = _Module.GetResourceInstance();
		LPCTSTR lpTemplateName = MAKEINTRESOURCE(T::IDD);
		HRSRC hDlgTempl = FindResource(hInstance, lpTemplateName, RT_DIALOG);
		if (hDlgTempl == NULL)
			return FALSE;
		HGLOBAL hResource = LoadResource(hInstance, hDlgTempl);
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hResource);
		if (pDlgTempl == NULL)
			return FALSE;
		AtlGetDialogSize(pDlgTempl, &size);
		AtlPixelToHiMetric(&size, &size);
		return TRUE;
	}
//Implementation
	BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet)
	{
		hRet = S_OK;
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return FALSE;
		// find a direct child of the dialog from the window that has focus
		HWND hWndCtl = ::GetFocus();
		if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
		{
			do
			{
				hWndCtl = ::GetParent(hWndCtl);
			}
			while (::GetParent(hWndCtl) != m_hWnd);
		}
		// give controls a chance to translate this message
		if (::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg) == 1)
			return TRUE;

		// special handling for keyboard messages
		DWORD dwDlgCode = ::SendMessage(pMsg->hwnd, WM_GETDLGCODE, 0, 0L);
		switch(pMsg->message)
		{
		case WM_CHAR:
			if(dwDlgCode == 0)	// no dlgcode, possibly an ActiveX control
				return FALSE;	// let the container process this
			break;
		case WM_KEYDOWN:
			switch(LOWORD(pMsg->wParam))
			{
			case VK_TAB:
				// prevent tab from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTTAB) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (::GetKeyState(VK_SHIFT) >= 0)  // not pressed
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_LEFT:
			case VK_UP:
			case VK_RIGHT:
			case VK_DOWN:
				// prevent arrows from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTARROWS) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (pMsg->wParam == VK_RIGHT || pMsg->wParam == VK_DOWN)	// going forward
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_EXECUTE:
			case VK_RETURN:
			case VK_ESCAPE:
			case VK_CANCEL:
				// we don't want to handle these, let the container do it
				return FALSE;
			}
			break;
		}

		return IsDialogMessage(pMsg);
	}
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void)
	{
		AdviseSinkMap(false); //unadvise
		return CComControl<T, CAxDialogImpl<T> >::IOleInPlaceObject_InPlaceDeactivate();
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		HWND h = pT->Create(hWndParent, rcPos);
		if (h != NULL)
			AdviseSinkMap(true);
		return h;
	}
	virtual HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		if(!m_bInPlaceActive)
		{
			HPEN hPen = (HPEN)::GetStockObject(BLACK_PEN);
			HBRUSH hBrush = (HBRUSH)::GetStockObject(GRAY_BRUSH);
			::SelectObject(di.hdcDraw, hPen);
			::SelectObject(di.hdcDraw, hBrush);
			::Rectangle(di.hdcDraw, di.prcBounds->left, di.prcBounds->top, di.prcBounds->right, di.prcBounds->bottom);
			::SetTextColor(di.hdcDraw, ::GetSysColor(COLOR_WINDOWTEXT));
			::SetBkMode(di.hdcDraw, TRANSPARENT);
			::DrawText(di.hdcDraw, _T("ATL Composite Control"), -1, (LPRECT)di.prcBounds, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
		}
		return S_OK;
	}
	typedef CComControl< T, CAxDialogImpl< T > >	baseClass;
	BEGIN_MSG_MAP(CComCompositeControl< T >)
		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnDialogColor)
		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnDialogColor)
		MESSAGE_HANDLER(WM_SETFOCUS, baseClass::OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, baseClass::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, baseClass::OnMouseActivate)
	END_MSG_MAP()

	BEGIN_SINK_MAP(T)
	END_SINK_MAP()
};
#endif //_ATL_NO_HOSTING

// Forward declarations
//
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;

template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T> class CBindStatusCallback;


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl : public IOleControl
{
public:
	STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
	}
	STDMETHOD(OnMnemonic)(LPMSG /* pMsg */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
	}
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		dispid;
		ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::OnAmbientPropertyChange\n"));
		ATLTRACE2(atlTraceControls,2,_T(" -- DISPID = %d (%d)\n"), dispid);
		return S_OK;
	}
	STDMETHOD(FreezeEvents)(BOOL bFreeze)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::FreezeEvents\n"));
		if (bFreeze)
			pT->m_nFreezeEvents++;
		else
			pT->m_nFreezeEvents--;
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl : public IQuickActivate
{
public:
	STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::QuickActivate\n"));
		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
	}
	STDMETHOD(SetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::SetContentExtent\n"));
		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
	}
	STDMETHOD(GetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl : public IOleObject
{
public:
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetClientSite\n"));
		return pT->IOleObject_SetClientSite(pClientSite);
	}
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetClientSite\n"));
		return pT->IOleObject_GetClientSite(ppClientSite);
	}
	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetHostNames\n"));
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Close\n"));
		return pT->IOleObject_Close(dwSaveOption);
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
	}

	// Helpers for DoVerb - Over-rideable in user class
	HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent)
	{
		T* pT = static_cast<T*>(this);
		BOOL bDesignMode = FALSE;
		CComVariant var;
		// if container doesn't support this property
		// don't allow design mode
		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
			bDesignMode = TRUE;
		if (bDesignMode)
			return pT->DoVerbProperties(prcPosRect, hwndParent);
		else
			return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
	}
	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbShow();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbShow();
		}
		return hr;
	}
	HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbInPlaceActivate();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbInPlaceActivate();
			if (SUCCEEDED(hr))
				pT->FireViewChange();
		}
		return hr;
	}
	HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (!pT->m_bUIActive)
		{
			hr = pT->OnPreVerbUIActivate();
			if (SUCCEEDED(hr))
			{
				hr = pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
				if (SUCCEEDED(hr))
					hr = pT->OnPostVerbUIActivate();
			}
		}
		return hr;
	}
	HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbHide();
		if (SUCCEEDED(hr))
		{
			pT->UIDeactivate();
			if (pT->m_hWnd)
				pT->ShowWindow(SW_HIDE);
			hr = pT->OnPostVerbHide();
		}
		return hr;
	}
	HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbOpen();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbOpen();
		return hr;
	}
	HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbDiscardUndo();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbDiscardUndo();
		return hr;
	}
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* pMsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::DoVerb(%d)\n"), iVerb);
		ATLASSERT(pT->m_spClientSite);

		HRESULT hr = E_NOTIMPL;
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_INPLACEACTIVATE:
			hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_UIACTIVATE:
			hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_HIDE:
			hr = pT->DoVerbHide(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_OPEN:
			hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_DISCARDUNDOSTATE:
			hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_PROPERTIES:
			hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
		}
		return hr;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumVerbs\n"));
		ATLASSERT(ppEnumOleVerb);
		if (!ppEnumOleVerb)
			return E_POINTER;
		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
	}
	STDMETHOD(Update)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Update\n"));
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::IsUpToDate\n"));
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserClassID\n"));
		ATLASSERT(pClsid);
		if (!pClsid)
			return E_POINTER;
		*pClsid = T::GetObjectCLSID();
		return S_OK;
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserType\n"));
		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetExtent\n"));
		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetExtent\n"));
		if (dwDrawAspect != DVASPECT_CONTENT)
			return E_FAIL;
		if (psizel == NULL)
			return E_POINTER;
		*psizel = pT->m_sizeExtent;
		return S_OK;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Advise\n"));
		return pT->IOleObject_Advise(pAdvSink, pdwConnection);
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Unadvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
		return hRes;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumAdvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
		return hRes;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetMiscStatus\n"));
		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
	}
// Implementation
public:
	HRESULT OnPreVerbShow() { return S_OK; }
	HRESULT OnPostVerbShow() { return S_OK; }
	HRESULT OnPreVerbInPlaceActivate() { return S_OK; }
	HRESULT OnPostVerbInPlaceActivate() { return S_OK; }
	HRESULT OnPreVerbUIActivate() { return S_OK; }
	HRESULT OnPostVerbUIActivate() { return S_OK; }
	HRESULT OnPreVerbHide() { return S_OK; }
	HRESULT OnPostVerbHide() { return S_OK; }
	HRESULT OnPreVerbOpen() { return S_OK; }
	HRESULT OnPostVerbOpen() { return S_OK; }
	HRESULT OnPreVerbDiscardUndo() { return S_OK; }
	HRESULT OnPostVerbDiscardUndo() { return S_OK; }
};

//local struct used for implementation
#pragma pack(push, 1)
struct _ATL_DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
};
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl : public IPropertyPage
{

public:
	void SetDirty(BOOL bDirty)
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_bDirty != bDirty)
		{
			pT->m_bDirty = bDirty;
			pT->m_pPageSite->OnStatusChange(bDirty ? PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE : 0);
		}
	}

	IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		pT->m_pPageSite = NULL;
		pT->m_size.cx = 0;
		pT->m_size.cy = 0;
		pT->m_dwTitleID = 0;
		pT->m_dwHelpFileID = 0;
		pT->m_dwDocStringID = 0;
		pT->m_dwHelpContext = 0;
		pT->m_ppUnk = NULL;
		pT->m_nObjects = 0;
		pT->m_bDirty = FALSE;
		pT->m_hWnd = NULL;
	}

	~IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_pPageSite != NULL)
			pT->m_pPageSite->Release();

		for (UINT i = 0; i < m_nObjects; i++)
			pT->m_ppUnk[i]->Release();

		delete[] pT->m_ppUnk;
	}

	// IPropertyPage
	//
	STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetPageSite\n"));

		if (!pPageSite && pT->m_pPageSite)
		{
			pT->m_pPageSite->Release();
			pT->m_pPageSite = NULL;
			return S_OK;
		}

		if (!pPageSite && !pT->m_pPageSite)
			return S_OK;

		if (pPageSite && pT->m_pPageSite)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : setting page site again with non NULL value\n"));
			return E_UNEXPECTED;
		}

		pT->m_pPageSite = pPageSite;
		pT->m_pPageSite->AddRef();
		return S_OK;
	}
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Activate\n"));

		if (pRect == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : Passed a NULL rect\n"));
			return E_POINTER;
		}

		pT->m_hWnd = pT->Create(hWndParent);
		Move(pRect);

		m_size.cx = pRect->right - pRect->left;
		m_size.cy = pRect->bottom - pRect->top;

		return S_OK;

	}
	STDMETHOD(Deactivate)( void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Deactivate\n"));

		if (pT->m_hWnd)
		{
			ATLTRACE2(atlTraceControls,2,_T("Destroying Dialog\n"));
			if (::IsWindow(pT->m_hWnd))
				pT->DestroyWindow();
			pT->m_hWnd = NULL;
		}

		return S_OK;

	}
	STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::GetPageInfo\n"));

		if (pPageInfo == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : PROPPAGEINFO passed == NULL\n"));
			return E_POINTER;
		}

		HRSRC hRsrc = FindResource(_Module.GetResourceInstance(),
								   MAKEINTRESOURCE(T::IDD), RT_DIALOG);
		if (hRsrc == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Could not find resource template\n"));
			return E_UNEXPECTED;
		}

		HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc);
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hGlob);
		if (pDlgTempl == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		AtlGetDialogSize(pDlgTempl, &m_size);

		pPageInfo->cb = sizeof(PROPPAGEINFO);
		pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
		pPageInfo->size = m_size;
		pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
		pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
		pPageInfo->dwHelpContext = pT->m_dwHelpContext;

		return S_OK;
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetObjects\n"));

		if (ppUnk == NULL)
			return E_POINTER;

		if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
		{
			for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
				pT->m_ppUnk[iObj]->Release();

			delete [] pT->m_ppUnk;
		}

		pT->m_ppUnk = NULL;
		ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

		if (pT->m_ppUnk == NULL)
			return E_OUTOFMEMORY;

		for (UINT i = 0; i < nObjects; i++)
		{
			ppUnk[i]->AddRef();
			pT->m_ppUnk[i] = ppUnk[i];
		}

		pT->m_nObjects = nObjects;

		return S_OK;
	}
	STDMETHOD(Show)(UINT nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Show\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		ShowWindow(pT->m_hWnd, nCmdShow);
		return S_OK;
	}
	STDMETHOD(Move)(LPCRECT pRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Move\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		if (pRect == NULL)
			return E_POINTER;

		MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
				 pRect->bottom - pRect->top, TRUE);

		return S_OK;

	}
	STDMETHOD(IsPageDirty)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::IsPageDirty\n"));
		return pT->m_bDirty ? S_OK : S_FALSE;
	}
	STDMETHOD(Apply)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Apply\n"));
		return S_OK;
	}
	STDMETHOD(Help)(LPCOLESTR pszHelpDir)
	{
		T* pT = static_cast<T*>(this);
		USES_CONVERSION;

		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Help\n"));
		CComBSTR szFullFileName(pszHelpDir);
		LPOLESTR szFileName = LoadStringHelper(pT->m_dwHelpFileID);
		szFullFileName.Append(OLESTR("\\"));
		szFullFileName.Append(szFileName);
		CoTaskMemFree(szFileName);
		WinHelp(pT->m_hWnd, OLE2CT(szFullFileName), HELP_CONTEXTPOPUP, NULL);
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(MSG *pMsg)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
			(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return S_FALSE;

		return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
	}

	IPropertyPageSite* m_pPageSite;
	IUnknown** m_ppUnk;
	ULONG m_nObjects;
	SIZE m_size;
	UINT m_dwTitleID;
	UINT m_dwHelpFileID;
	UINT m_dwDocStringID;
	DWORD m_dwHelpContext;
	BOOL m_bDirty;

//methods
public:

	BEGIN_MSG_MAP(IPropertyPageImpl<T>)
		MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
	END_MSG_MAP()

	LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
	{
		if (wParam == GWL_EXSTYLE)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
			lpss->styleNew |= WS_EX_CONTROLPARENT;
			return 0;
		}
		return 1;
	}

	LPOLESTR LoadStringHelper(UINT idRes)
	{
		USES_CONVERSION;

		TCHAR szTemp[_MAX_PATH];
		LPOLESTR sz;
		sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR));
		if (sz == NULL)
			return NULL;
		sz[0] = NULL;

		if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH))
			ocscpy(sz, T2OLE(szTemp));
		else
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : Failed to load string from res\n"));
		}

		return sz;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl<T>
{
public:

	STDMETHOD(EditProperty)(DISPID dispID)
	{
		ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
	}
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl : public IPerPropertyBrowsing
{
public:
	STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
		T* pT = static_cast<T*>(this);
		*pBstr = NULL;
		CComVariant var;
		if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &var)))
			return S_FALSE;

		BSTR bstrTemp = var.bstrVal;
		if (var.vt != VT_BSTR)
		{
			CComVariant varDest;
			if (FAILED(::VariantChangeType(&varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR)))
				return S_FALSE;
			bstrTemp = varDest.bstrVal;
		}
		*pBstr = SysAllocString(bstrTemp);
		if (*pBstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}

	STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			if (pMap[i].szDesc == NULL)
				continue;

			// reject data entry types
			if (pMap[i].dwSizeData != 0)
				continue;

			if (pMap[i].dispid == dispID)
			{
				ATLASSERT(pMap[i].pclsidPropPage != NULL);
				*pClsid = *(pMap[i].pclsidPropPage);
				return S_OK;
			}
		}
		*pClsid = CLSID_NULL;
		return E_INVALIDARG;
	}
	STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut)
	{
		dispID;
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
		if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
			return E_POINTER;

		pCaStringsOut->cElems = 0;
		pCaStringsOut->pElems = NULL;
		pCaCookiesOut->cElems = 0;
		pCaCookiesOut->pElems = NULL;
		return S_OK;
	}
	STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/)
	{
		ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl : public IViewObjectEx
{
public:
	STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
					DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
					LPCRECTL prcBounds, LPCRECTL prcWBounds,
					BOOL (__stdcall * /*pfnContinue*/)(DWORD dwContinue),
					DWORD /*dwContinue*/)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::Draw\n"));
		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
			prcBounds, prcWBounds);
	}

	STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
	}
	STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
	}
	STDMETHOD(Unfreeze)(DWORD /* dwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
	}
	STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::SetAdvise\n"));
		pT->m_spAdviseSink = pAdvSink;
		return S_OK;
	}
	STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetAdvise\n"));
		if (ppAdvSink != NULL)
		{
			*ppAdvSink = pT->m_spAdviseSink;
			if (pT->m_spAdviseSink)
				pT->m_spAdviseSink.p->AddRef();
		}
		return S_OK;
	}

	// IViewObject2
	//
	STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetExtent\n"));
		*lpsizel = pT->m_sizeExtent;
		return S_OK;
	}

	// IViewObjectEx
	//
	STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
	}

	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = pT->_GetViewStatus();
		return S_OK;
	}
	STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitPoint\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitRect\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			RECT rc;
			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetNaturalExtent\n"));
		HRESULT hRes = E_FAIL;
		if (pExtentInfo == NULL || psizel == NULL)
			hRes = E_POINTER;
		else if (dwAspect == DVASPECT_CONTENT)
		{
			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
			{
				*psizel = pT->m_sizeNatural;
				hRes = S_OK;
			}
		}
		return hRes;
	}

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl : public IOleInPlaceObjectWindowless
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceActiveObject::GetWindow as well
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceObject
	//
	STDMETHOD(InPlaceDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
		return pT->IOleInPlaceObject_InPlaceDeactivate();
	}
	STDMETHOD(UIDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
		return pT->IOleInPlaceObject_UIDeactivate();
	}
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
	}
	STDMETHOD(ReactivateAndUndo)(void)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
	}

	// IOleInPlaceObjectWindowless
	//
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
		T* pT = static_cast<T*>(this);
		BOOL b = pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult);
		return b ? S_OK : S_FALSE;
	}

	STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl : public IOleInPlaceActiveObject
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceObjectWindowless::GetWindow as well
	STDMETHOD(GetWindow)(HWND *phwnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceActiveObject
	//
	STDMETHOD(TranslateAccelerator)(LPMSG pMsg)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRet = S_OK;
		if (pT->PreTranslateAccelerator(pMsg, hRet))
			return hRet;
		CComPtr<IOleControlSite> spCtlSite;
		hRet = pT->InternalGetSite(IID_IOleControlSite, (void**)&spCtlSite);
		if (SUCCEEDED(hRet))
		{
			if (spCtlSite != NULL)
			{
				DWORD dwKeyMod = 0;
				if (::GetKeyState(VK_SHIFT) < 0)
					dwKeyMod += 1;	// KEYMOD_SHIFT
				if (::GetKeyState(VK_CONTROL) < 0)
					dwKeyMod += 2;	// KEYMOD_CONTROL
				if (::GetKeyState(VK_MENU) < 0)
					dwKeyMod += 4;	// KEYMOD_ALT
				hRet = spCtlSite->TranslateAccelerator(pMsg, dwKeyMod);
			}
			else
				hRet = S_FALSE;
		}
		return (hRet == S_OK) ? S_OK : S_FALSE;
	}
	STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
		T* pT = static_cast<T*>(this);
		if (fActivate == FALSE)
			pT->IOleInPlaceObject_UIDeactivate();
		return S_OK;
	}
	STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
		return S_OK;
	}
	STDMETHOD(EnableModeless)(BOOL /* fEnable */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
		return S_OK;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl : public IPointerInactive
{
public:
	// IPointerInactive
	//
	STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
	}
	STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
	}
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl : public IRunnableObject
{
public:
	// IRunnableObject
	//
	STDMETHOD(GetRunningClass)(LPCLSID lpClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::GetRunningClass\n"));
		*lpClsid = GUID_NULL;
		return E_UNEXPECTED;
	}
	STDMETHOD(Run)(LPBINDCTX)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::Run\n"));
		return S_OK;
	}
	virtual BOOL STDMETHODCALLTYPE IsRunning()
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::IsRunning\n"));
		return TRUE;
	}
	STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::LockRunning\n"));
		return S_OK;
	}
	STDMETHOD(SetContainedObject)(BOOL /*fContained*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::SetContainedObject\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
template <class T>
class ATL_NO_VTABLE IDataObjectImpl : public IDataObject
{
public:
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::GetData\n"));
		T* pT = (T*) this;
		return pT->IDataObject_GetData(pformatetcIn, pmedium);
	}
	STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
	}
	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

		if (hr == S_OK)
			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

		return hr;
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DUnadvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = OLE_E_NOCONNECTION;
		else
			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
		return hr;
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::EnumDAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = E_FAIL;
		if (pT->m_spDataAdviseHolder != NULL)
			hr = pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
	public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
	typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//
// 2nd template parameter is the supported safety e.g.
// INTERFACESAFE_FOR_UNTRUSTED_CALLER - safe for scripting
// INTERFACESAFE_FOR_UNTRUSTED_DATA   - safe for initialization from data

template <class T, DWORD dwSupportedSafety>
class ATL_NO_VTABLE IObjectSafetyImpl : public IObjectSafety
{
public:
	IObjectSafetyImpl()
	{
		m_dwCurrentSafety = 0;
	}

	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::GetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
		
		HRESULT hr;
		IUnknown* pUnk;
		// Check if we support this interface
		hr = pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk);
		if (SUCCEEDED(hr))
		{
			// We support this interface so set the safety options accordingly
			pUnk->Release();	// Release the interface we just acquired
			*pdwSupportedOptions = dwSupportedSafety;
			*pdwEnabledOptions   = m_dwCurrentSafety;
		}
		else
		{
			// We don't support this interface
			*pdwSupportedOptions = 0;
			*pdwEnabledOptions   = 0;
		}
		return hr;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::SetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		IUnknown* pUnk;
		
		// Check if we support the interface and return E_NOINTEFACE if we don't
		if (FAILED(pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk)))
			return E_NOINTERFACE;
		pUnk->Release();	// Release the interface we just acquired
		
		// If we are asked to set options we don't support then fail
		if (dwOptionSetMask & ~dwSupportedSafety)
			return E_FAIL;

		// Set the safety options we have been asked to
		m_dwCurrentSafety = m_dwCurrentSafety  & ~dwEnabledOptions | dwOptionSetMask;
		return S_OK;
	}
	DWORD m_dwCurrentSafety;
};

template <class T>
class ATL_NO_VTABLE IOleLinkImpl : public IOleLink
{
	STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
	}

	STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
	}

	STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
	}

	STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
	};

	STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
	}

	STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleLink::GetSourceDisplayName\n"));
		*ppszDisplayName = NULL;
		return E_FAIL;
	}

	STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
	};

	STDMETHOD(BindIfRunning)()
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleLinkImpl::BindIfRunning\n"));
		return S_OK;
	};

	STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
	};

	STDMETHOD(UnbindSource)()
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
	};

	STDMETHOD(Update)(IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
	};
};

template <class T>
class ATL_NO_VTABLE CBindStatusCallback :
	public CComObjectRootEx<T::_ThreadModel::ThreadModelNoCS>,
	public IBindStatusCallback
{
	typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

public:

BEGIN_COM_MAP(CBindStatusCallback<T>)
	COM_INTERFACE_ENTRY(IBindStatusCallback)
END_COM_MAP()

	CBindStatusCallback()
	{
		m_pT = NULL;
		m_pFunc = NULL;
	}
	~CBindStatusCallback()
	{
		ATLTRACE2(atlTraceControls,2,_T("~CBindStatusCallback\n"));
	}

	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStartBinding\n"));
		m_spBinding = pBinding;
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG *pnPriority)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetPriority"));
		HRESULT hr = S_OK;
		if (pnPriority)
			*pnPriority = THREAD_PRIORITY_NORMAL;
		else
			hr = E_INVALIDARG;
		return S_OK;
	}

	STDMETHOD(OnLowResource)(DWORD reserved)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnLowResource"));
		return S_OK;
	}

	STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnProgress"));
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStopBinding\n"));
		(m_pT->*m_pFunc)(this, NULL, 0);
		m_spBinding.Release();
		m_spBindCtx.Release();
		m_spMoniker.Release();
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetBindInfo\n"));

		if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
			return E_INVALIDARG;

		*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
			BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

		ULONG cbSize = pbindInfo->cbSize;		// remember incoming cbSize
		memset(pbindInfo, 0, cbSize);			// zero out structure
		pbindInfo->cbSize = cbSize;				// restore cbSize
		pbindInfo->dwBindVerb = BINDVERB_GET;	// set verb
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnDataAvailable\n"));
		HRESULT hr = S_OK;

		// Get the Stream passed
		if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
		{
			if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
				m_spStream = pstgmed->pstm;
		}

		DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
		DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		// If there is some data to be read then go ahead and read them
		if (m_spStream)
		{
			if (dwRead > 0)
			{
				BYTE* pBytes = NULL;
				ATLTRY(pBytes = new BYTE[dwRead + 1]);
				if (pBytes == NULL)
					return E_OUTOFMEMORY;
				hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
				if (SUCCEEDED(hr))
				{
					pBytes[dwActuallyRead] = 0;
					if (dwActuallyRead>0)
					{
						(m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
						m_dwTotalRead += dwActuallyRead;
					}
				}
				delete[] pBytes;
			}
		}

		if (BSCF_LASTDATANOTIFICATION & grfBSCF)
			m_spStream.Release();
		return hr;
	}

	STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnObjectAvailable"));
		return S_OK;
	}

	HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
	{
		m_dwTotalRead = 0;
		m_dwAvailableToRead = 0;
		HRESULT hr = S_OK;
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
		CComPtr<IBindHost>	spBindHost;
		CComPtr<IStream>	spStream;
		if (spServiceProvider)
			spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

		if (spBindHost == NULL)
		{
			if (bRelative)
				return E_NOINTERFACE;  // relative asked for, but no IBindHost
			hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			if (SUCCEEDED(hr))
				hr = CreateBindCtx(0, &m_spBindCtx);

			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);
			else
				m_spMoniker.Release();

			if (SUCCEEDED(hr))
				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
		}
		else
		{
			hr = CreateBindCtx(0, &m_spBindCtx);
			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);

			if (SUCCEEDED(hr))
			{
				if (bRelative)
					hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
				else
					hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			}

			if (SUCCEEDED(hr))
			{
				hr = spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, static_cast<IBindStatusCallback*>(this), IID_IStream, (void**)&spStream);
				ATLTRACE2(atlTraceControls,2,_T("Bound"));
			}
		}
		return hr;
	}

	HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		m_pT = pT;
		m_pFunc = pFunc;
		return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
	}

	static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		CComObject<CBindStatusCallback<T> > *pbsc;
		HRESULT hRes = CComObject<CBindStatusCallback<T> >::CreateInstance(&pbsc);
		if (FAILED(hRes))
			return hRes;
		return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
	}

	CComPtr<IMoniker> m_spMoniker;
	CComPtr<IBindCtx> m_spBindCtx;
	CComPtr<IBinding> m_spBinding;
	CComPtr<IStream> m_spStream;
	T* m_pT;
	ATL_PDATAAVAILABLE m_pFunc;
	DWORD m_dwTotalRead;
	DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(type pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname; \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		if (*(&(pT->m_##pname)) != NULL) \
			SysFreeString(*(&(pT->m_##pname))); \
		*(&(pT->m_##pname)) = SysAllocString(pname); \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
		T* pT = (T*) this; \
		*p##pname = SysAllocString(pT->m_##pname); \
		return S_OK; \
	}


template < class T, class InterfaceName, const IID* piid, const GUID* plibid>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Font\n"));
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = 0;
		if (pFont)
		{
			CComQIPtr<IFont, &IID_IFont> p(pFont);
			if (p)
			{
				CComPtr<IFont> pFont;
				p->Clone(&pFont);
				if (pFont)
					pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Font\n"));
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = pFont;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Font\n"));
		T* pT = (T*) this;
		*ppFont = pT->m_pFont;
		if (*ppFont != NULL)
			(*ppFont)->AddRef();
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Picture\n"));
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Picture\n"));
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Picture\n"));
		T* pT = (T*) this;
		*ppPicture = pT->m_pPicture;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_MouseIcon\n"));
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_MouseIcon\n"));
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_MouseIcon\n"));
		T* pT = (T*) this;
		*ppPicture = pT->m_pMouseIcon;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
	IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(long /*hWnd*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Window\n"));
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_Window(long* phWnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Window\n"));
		T* pT = (T*) this;
		*phWnd = (long)pT->m_hWnd;
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(LONG, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(LONG, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(LONG, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(LONG, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(LONG, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(SHORT, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(LONG, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(LONG, ReadyState, nReadyState, DISPID_READYSTATE)
};

#pragma pack(pop)

}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLCTL_IMPL
#endif
#endif

#endif // __ATLCTL_H__

#ifdef _ATLCTL_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif


//All exports go here


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time 
#undef _ATLCTL_IMPL

#endif // _ATLCTL_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\atl\atldef.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Active Template Library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef UNDER_CE
	#error ATL not currently supported for CE
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DEBUG_REFCOUNT
#ifndef _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_INTERFACES
#endif
#endif

#ifdef _ATL_DEBUG_INTERFACES
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_INTERFACES

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" HRESULT __declspec(dllexport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllexport) x __stdcall
	#define ATLINLINE
#else
	#define ATLAPI HRESULT __stdcall
	#define ATLAPI_(x) x __stdcall
	#define ATLINLINE inline
#endif

#if defined (_CPPUNWIND) & (defined(_ATL_EXCEPTIONS) | defined(_AFX))
#define ATLTRY(x) try{x;} catch(...) {}
#else
#define ATLTRY(x) x;
#endif

#define offsetofclass(base, derived) ((DWORD)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#define _ATL_VER 0x0300 // Active Template Library version 3.0

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbc\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbi\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbc\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#include "ole2.h"						// OLE definitions
#include "CrtWrap.h"					// _ASSERTE macros.
#include "winwrap.h"                    // Windows wrappers.
#include "utilcode.h"					// Helper code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORDBC.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Debugging Services Controller\0"
#define VER_ORIGFILENAME_STR    "mscordbc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbc\mscordbc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MSCorDBC.cpp
//
// COM+ Debugging Services -- Runtime Controller DLL
//
// Dll* routines for entry points.
//
//*****************************************************************************
#include "stdafx.h"

//*****************************************************************************
// The main dll entry point for this module.  This routine is called by the
// OS when the dll gets loaded.  Nothing needs to be done for this DLL.
//*****************************************************************************
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	//@todo: Shoud we call DisableThreadLibraryCalls?  Or does this code
	//	need native thread attatch/detatch notifications?

	OnUnicodeSystem();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbi\makefile.inc ===
RegisterThisDll: $(CORLIBS)\mscordbi.lib 
!if "$(TARGETCOMPLUS)" != ""
	regsvr32 /s /c $(TARGETCOMPLUS)\mscordbi.dll
!else
	regsvr32 /s /c $(CORLIBS)\mscordbi.dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\atl\atlwin.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Active Template Library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN_H__
#define __ATLWIN_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlwin.h requires atlbase.h to be included first
#endif

struct _ATL_WNDCLASSINFOA;
struct _ATL_WNDCLASSINFOW;


#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoA(_ATL_MODULE* pM, _ATL_WNDCLASSINFOA* p, WNDPROC* pProc);
ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoW(_ATL_MODULE* pM, _ATL_WNDCLASSINFOW* p, WNDPROC* pProc);

#ifdef UNICODE
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoW
#else
#define AtlModuleRegisterWndClassInfo AtlModuleRegisterWndClassInfoA
#endif


#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);
ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix);
ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric);


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

struct _ATL_WNDCLASSINFOA
{
	WNDCLASSEXA m_wc;
	LPCSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	CHAR m_szAutoName[13];
	ATOM Register(WNDPROC* p)
	{
		return AtlModuleRegisterWndClassInfoA(&_Module, this, p);
	}
};
struct _ATL_WNDCLASSINFOW
{
	WNDCLASSEXW m_wc;
	LPCWSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCWSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	WCHAR m_szAutoName[13];
	ATOM Register(WNDPROC* p)
	{
		return AtlModuleRegisterWndClassInfoW(&_Module, this, p);
	}
};

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CWindow;
#ifndef _ATL_NO_HOSTING
template <class TBase = CWindow> class CAxWindowT;
#endif //!_ATL_NO_HOSTING
class CMessageMap;
class CDynamicChain;
typedef _ATL_WNDCLASSINFOA CWndClassInfoA;
typedef _ATL_WNDCLASSINFOW CWndClassInfoW;
#ifdef UNICODE
#define CWndClassInfo CWndClassInfoW
#else
#define CWndClassInfo CWndClassInfoA
#endif
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CWindowImpl;
template <class T, class TBase = CWindow> class CDialogImpl;
#ifndef _ATL_NO_HOSTING
template <class T, class TBase = CWindow> class CAxDialogImpl;
#endif //!_ATL_NO_HOSTING
template <WORD t_wDlgTemplateID, BOOL t_bCenter = TRUE> class CSimpleDialog;
template <class TBase = CWindow, class TWinTraits = CControlWinTraits> class CContainedWindowT;

/////////////////////////////////////////////////////////////////////////////
// CWindow - client side for a Windows window

class CWindow
{
public:
	static RECT rcDefault;
	HWND m_hWnd;

	CWindow(HWND hWnd = NULL)
	{
		m_hWnd = hWnd;
	}

	CWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	static LPCTSTR GetWndClassName()
	{
		return NULL;
	}

	void Attach(HWND hWndNew)
	{
		ATLASSERT(::IsWindow(hWndNew));
		m_hWnd = hWndNew;
	}

	HWND Detach()
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		return hWnd;
	}

	HWND Create(LPCTSTR lpstrWndClass, HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
			dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
			rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
			_Module.GetModuleInstance(), lpCreateParam);
		return m_hWnd;
	}

	HWND Create(LPCTSTR lpstrWndClass, HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		if(lpRect == NULL)
			lpRect = &rcDefault;
		m_hWnd = ::CreateWindowEx(dwExStyle, lpstrWndClass, szWindowName,
			dwStyle, lpRect->left, lpRect->top, lpRect->right - lpRect->left,
			lpRect->bottom - lpRect->top, hWndParent, hMenu,
			_Module.GetModuleInstance(), lpCreateParam);
		return m_hWnd;
	}

	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		if(!::DestroyWindow(m_hWnd))
			return FALSE;

		m_hWnd = NULL;
		return TRUE;
	}

// Attributes

	operator HWND() const { return m_hWnd; }

	DWORD GetStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::GetWindowLong(m_hWnd, GWL_STYLE);
	}

	DWORD GetExStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::GetWindowLong(m_hWnd, GWL_EXSTYLE);
	}

	LONG GetWindowLong(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowLong(m_hWnd, nIndex);
	}

	LONG SetWindowLong(int nIndex, LONG dwNewLong)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowLong(m_hWnd, nIndex, dwNewLong);
	}

	WORD GetWindowWord(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowWord(m_hWnd, nIndex);
	}

	WORD SetWindowWord(int nIndex, WORD wNewWord)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowWord(m_hWnd, nIndex, wNewWord);
	}

// Message Functions

	LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendMessage(m_hWnd,message,wParam,lParam);
	}

	BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::PostMessage(m_hWnd,message,wParam,lParam);
	}

	BOOL SendNotifyMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendNotifyMessage(m_hWnd, message, wParam, lParam);
	}

	// support for C style macros
	static LRESULT SendMessage(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(hWnd));
		return ::SendMessage(hWnd, message, wParam, lParam);
	}

// Window Text Functions

	BOOL SetWindowText(LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowText(m_hWnd, lpszString);
	}

	int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowText(m_hWnd, lpszStringBuf, nMaxCount);
	}

	int GetWindowTextLength() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowTextLength(m_hWnd);
	}

// Font Functions

	void SetFont(HFONT hFont, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
	}

	HFONT GetFont() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0);
	}

// Menu Functions (non-child windows only)

	HMENU GetMenu() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetMenu(m_hWnd);
	}

	BOOL SetMenu(HMENU hMenu)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetMenu(m_hWnd, hMenu);
	}

	BOOL DrawMenuBar()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DrawMenuBar(m_hWnd);
	}

	HMENU GetSystemMenu(BOOL bRevert) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetSystemMenu(m_hWnd, bRevert);
	}

	BOOL HiliteMenuItem(HMENU hMenu, UINT uItemHilite, UINT uHilite)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::HiliteMenuItem(m_hWnd, hMenu, uItemHilite, uHilite);
	}

// Window Size and Position Functions

	BOOL IsIconic() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsIconic(m_hWnd);
	}

	BOOL IsZoomed() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsZoomed(m_hWnd);
	}

	BOOL MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint);
	}

	BOOL MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MoveWindow(m_hWnd, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, bRepaint);
	}

	BOOL SetWindowPos(HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPos(m_hWnd, hWndInsertAfter, x, y, cx, cy, nFlags);
	}

	BOOL SetWindowPos(HWND hWndInsertAfter, LPCRECT lpRect, UINT nFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPos(m_hWnd, hWndInsertAfter, lpRect->left, lpRect->top, lpRect->right - lpRect->left, lpRect->bottom - lpRect->top, nFlags);
	}

	UINT ArrangeIconicWindows()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ArrangeIconicWindows(m_hWnd);
	}

	BOOL BringWindowToTop()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::BringWindowToTop(m_hWnd);
	}

	BOOL GetWindowRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowRect(m_hWnd, lpRect);
	}

	BOOL GetClientRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetClientRect(m_hWnd, lpRect);
	}

	BOOL GetWindowPlacement(WINDOWPLACEMENT FAR* lpwndpl) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowPlacement(m_hWnd, lpwndpl);
	}

	BOOL SetWindowPlacement(const WINDOWPLACEMENT FAR* lpwndpl)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowPlacement(m_hWnd, lpwndpl);
	}

// Coordinate Mapping Functions

	BOOL ClientToScreen(LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ClientToScreen(m_hWnd, lpPoint);
	}

	BOOL ClientToScreen(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(!::ClientToScreen(m_hWnd, (LPPOINT)lpRect))
			return FALSE;
		return ::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1);
	}

	BOOL ScreenToClient(LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScreenToClient(m_hWnd, lpPoint);
	}

	BOOL ScreenToClient(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(!::ScreenToClient(m_hWnd, (LPPOINT)lpRect))
			return FALSE;
		return ::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1);
	}

	int MapWindowPoints(HWND hWndTo, LPPOINT lpPoint, UINT nCount) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapWindowPoints(m_hWnd, hWndTo, lpPoint, nCount);
	}

	int MapWindowPoints(HWND hWndTo, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapWindowPoints(m_hWnd, hWndTo, (LPPOINT)lpRect, 2);
	}

// Update and Painting Functions

	HDC BeginPaint(LPPAINTSTRUCT lpPaint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::BeginPaint(m_hWnd, lpPaint);
	}

	void EndPaint(LPPAINTSTRUCT lpPaint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::EndPaint(m_hWnd, lpPaint);
	}

	HDC GetDC()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDC(m_hWnd);
	}

	HDC GetWindowDC()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowDC(m_hWnd);
	}

	int ReleaseDC(HDC hDC)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ReleaseDC(m_hWnd, hDC);
	}

	void Print(HDC hDC, DWORD dwFlags) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PRINT, (WPARAM)hDC, dwFlags);
	}

	void PrintClient(HDC hDC, DWORD dwFlags) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)hDC, dwFlags);
	}

	BOOL UpdateWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::UpdateWindow(m_hWnd);
	}

	void SetRedraw(BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_SETREDRAW, (WPARAM)bRedraw, 0);
	}

	BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetUpdateRect(m_hWnd, lpRect, bErase);
	}

	int GetUpdateRgn(HRGN hRgn, BOOL bErase = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetUpdateRgn(m_hWnd, hRgn, bErase);
	}

	BOOL Invalidate(BOOL bErase = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::InvalidateRect(m_hWnd, NULL, bErase);
	}

	BOOL InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::InvalidateRect(m_hWnd, lpRect, bErase);
	}

	BOOL ValidateRect(LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ValidateRect(m_hWnd, lpRect);
	}

	void InvalidateRgn(HRGN hRgn, BOOL bErase = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::InvalidateRgn(m_hWnd, hRgn, bErase);
	}

	BOOL ValidateRgn(HRGN hRgn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ValidateRgn(m_hWnd, hRgn);
	}

	BOOL ShowWindow(int nCmdShow)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowWindow(m_hWnd, nCmdShow);
	}

	BOOL IsWindowVisible() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowVisible(m_hWnd);
	}

	BOOL ShowOwnedPopups(BOOL bShow = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowOwnedPopups(m_hWnd, bShow);
	}

	HDC GetDCEx(HRGN hRgnClip, DWORD flags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDCEx(m_hWnd, hRgnClip, flags);
	}

	BOOL LockWindowUpdate(BOOL bLock = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::LockWindowUpdate(bLock ? m_hWnd : NULL);
	}

	BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL, HRGN hRgnUpdate = NULL, UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::RedrawWindow(m_hWnd, lpRectUpdate, hRgnUpdate, flags);
	}

// Timer Functions

	UINT SetTimer(UINT nIDEvent, UINT nElapse)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetTimer(m_hWnd, nIDEvent, nElapse, NULL);
	}

	BOOL KillTimer(UINT nIDEvent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::KillTimer(m_hWnd, nIDEvent);
	}

// Window State Functions

	BOOL IsWindowEnabled() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowEnabled(m_hWnd);
	}

	BOOL EnableWindow(BOOL bEnable = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableWindow(m_hWnd, bEnable);
	}

	HWND SetActiveWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetActiveWindow(m_hWnd);
	}

	HWND SetCapture()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetCapture(m_hWnd);
	}

	HWND SetFocus()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetFocus(m_hWnd);
	}

// Dialog-Box Item Functions

	BOOL CheckDlgButton(int nIDButton, UINT nCheck)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CheckDlgButton(m_hWnd, nIDButton, nCheck);
	}

	BOOL CheckRadioButton(int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton);
	}

	int DlgDirList(LPTSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT nFileType)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox, nIDStaticPath, nFileType);
	}

	int DlgDirListComboBox(LPTSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT nFileType)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirListComboBox(m_hWnd, lpPathSpec, nIDComboBox, nIDStaticPath, nFileType);
	}

	BOOL DlgDirSelect(LPTSTR lpString, int nCount, int nIDListBox)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirSelectEx(m_hWnd, lpString, nCount, nIDListBox);
	}

	BOOL DlgDirSelectComboBox(LPTSTR lpString, int nCount, int nIDComboBox)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nCount, nIDComboBox);
	}

	UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL, BOOL bSigned = TRUE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);
	}

	UINT GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);
	}
	BOOL GetDlgItemText(int nID, BSTR& bstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndCtl = GetDlgItem(nID);
		if(hWndCtl == NULL)
			return FALSE;

		return CWindow(hWndCtl).GetWindowText(bstrText);
	}
	HWND GetNextDlgGroupItem(HWND hWndCtl, BOOL bPrevious = FALSE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetNextDlgGroupItem(m_hWnd, hWndCtl, bPrevious);
	}

	HWND GetNextDlgTabItem(HWND hWndCtl, BOOL bPrevious = FALSE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetNextDlgTabItem(m_hWnd, hWndCtl, bPrevious);
	}

	UINT IsDlgButtonChecked(int nIDButton) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsDlgButtonChecked(m_hWnd, nIDButton);
	}

	LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam = 0, LPARAM lParam = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam);
	}

	BOOL SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned);
	}

	BOOL SetDlgItemText(int nID, LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetDlgItemText(m_hWnd, nID, lpszString);
	}

#ifndef _ATL_NO_HOSTING
	HRESULT GetDlgControl(int nID, REFIID iid, void** ppUnk)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(ppUnk != NULL);
		HRESULT hr = E_FAIL;
		HWND hWndCtrl = GetDlgItem(nID);
		if (hWndCtrl != NULL)
		{
			*ppUnk = NULL;
			CComPtr<IUnknown> spUnk;
			hr = AtlAxGetControl(hWndCtrl, &spUnk);
			if (SUCCEEDED(hr))
				hr = spUnk->QueryInterface(iid, ppUnk);
		}
		return hr;
	}
#endif //!_ATL_NO_HOSTING

// Scrolling Functions

	int GetScrollPos(int nBar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollPos(m_hWnd, nBar);
	}

	BOOL GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollRange(m_hWnd, nBar, lpMinPos, lpMaxPos);
	}

	BOOL ScrollWindow(int xAmount, int yAmount, LPCRECT lpRect = NULL, LPCRECT lpClipRect = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect);
	}

	int ScrollWindowEx(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate, UINT uFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
	}

	int ScrollWindowEx(int dx, int dy, UINT uFlags, LPCRECT lpRectScroll = NULL, LPCRECT lpRectClip = NULL, HRGN hRgnUpdate = NULL, LPRECT lpRectUpdate = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate, uFlags);
	}

	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollPos(m_hWnd, nBar, nPos, bRedraw);
	}

	BOOL SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollRange(m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
	}

	BOOL ShowScrollBar(UINT nBar, BOOL bShow = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowScrollBar(m_hWnd, nBar, bShow);
	}

	BOOL EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableScrollBar(m_hWnd, uSBFlags, uArrowFlags);
	}

// Window Access Functions

	HWND ChildWindowFromPoint(POINT point) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ChildWindowFromPoint(m_hWnd, point);
	}

	HWND ChildWindowFromPointEx(POINT point, UINT uFlags) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ChildWindowFromPointEx(m_hWnd, point, uFlags);
	}

	HWND GetTopWindow() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetTopWindow(m_hWnd);
	}

	HWND GetWindow(UINT nCmd) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindow(m_hWnd, nCmd);
	}

	HWND GetLastActivePopup() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetLastActivePopup(m_hWnd);
	}

	BOOL IsChild(HWND hWnd) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsChild(m_hWnd, hWnd);
	}

	HWND GetParent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetParent(m_hWnd);
	}

	HWND SetParent(HWND hWndNewParent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetParent(m_hWnd, hWndNewParent);
	}

// Window Tree Access

	int GetDlgCtrlID() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgCtrlID(m_hWnd);
	}

	int SetDlgCtrlID(int nID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SetWindowLong(m_hWnd, GWL_ID, nID);
	}

	HWND GetDlgItem(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetDlgItem(m_hWnd, nID);
	}

// Alert Functions

	BOOL FlashWindow(BOOL bInvert)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::FlashWindow(m_hWnd, bInvert);
	}

	int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = _T(""), UINT nType = MB_OK)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MessageBox(m_hWnd, lpszText, lpszCaption, nType);
	}

// Clipboard Functions

	BOOL ChangeClipboardChain(HWND hWndNewNext)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ChangeClipboardChain(m_hWnd, hWndNewNext);
	}

	HWND SetClipboardViewer()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetClipboardViewer(m_hWnd);
	}

	BOOL OpenClipboard()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::OpenClipboard(m_hWnd);
	}

// Caret Functions

	BOOL CreateCaret(HBITMAP hBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, hBitmap, 0, 0);
	}

	BOOL CreateSolidCaret(int nWidth, int nHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight);
	}

	BOOL CreateGrayCaret(int nWidth, int nHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight);
	}

	BOOL HideCaret()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::HideCaret(m_hWnd);
	}

	BOOL ShowCaret()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowCaret(m_hWnd);
	}

#ifdef _INC_SHELLAPI
// Drag-Drop Functions
	void DragAcceptFiles(BOOL bAccept = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept);
	}
#endif

// Icon Functions

	HICON SetIcon(HICON hIcon, BOOL bBigIcon = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon);
	}

	HICON GetIcon(BOOL bBigIcon = TRUE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0);
	}

// Help Functions

	BOOL WinHelp(LPCTSTR lpszHelp, UINT nCmd = HELP_CONTEXT, DWORD dwData = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::WinHelp(m_hWnd, lpszHelp, nCmd, dwData);
	}

	BOOL SetWindowContextHelpId(DWORD dwContextHelpId)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId);
	}

	DWORD GetWindowContextHelpId() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowContextHelpId(m_hWnd);
	}

// Hot Key Functions

	int SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, WM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0);
	}

	DWORD GetHotKey() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendMessage(m_hWnd, WM_GETHOTKEY, 0, 0);
	}

// Misc. Operations

//N new
	BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollInfo(m_hWnd, nBar, lpScrollInfo);
	}
	BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollInfo(m_hWnd, nBar, lpScrollInfo, bRedraw);
	}
	BOOL IsDialogMessage(LPMSG lpMsg)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsDialogMessage(m_hWnd, lpMsg);
	}

	void NextDlgCtrl() const
        {
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0L);
	}
	void PrevDlgCtrl() const
        {
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0L);
	}
	void GotoDlgCtrl(HWND hWndCtrl) const
        {
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)hWndCtrl, 1L);
	}

	BOOL ResizeClient(int nWidth, int nHeight, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		RECT rcWnd;
		if(!GetClientRect(&rcWnd))
			return FALSE;

		if(nWidth != -1)
			rcWnd.right = nWidth;
		if(nHeight != -1)
			rcWnd.bottom = nHeight;

		if(!::AdjustWindowRectEx(&rcWnd, GetStyle(), (!(GetStyle() & WS_CHILD) && (GetMenu() != NULL)), GetExStyle()))
			return FALSE;

		UINT uFlags = SWP_NOZORDER | SWP_NOMOVE;
		if(!bRedraw)
			uFlags |= SWP_NOREDRAW;

		return SetWindowPos(NULL, 0, 0, rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top, uFlags);
	}

	int GetWindowRgn(HRGN hRgn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowRgn(m_hWnd, hRgn);
	}
	int SetWindowRgn(HRGN hRgn, BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetWindowRgn(m_hWnd, hRgn, bRedraw);
	}
	HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DeferWindowPos(hWinPosInfo, m_hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
	}
	DWORD GetWindowThreadID()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetWindowThreadProcessId(m_hWnd, NULL);
	}
	DWORD GetWindowProcessID()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwProcessID;
		::GetWindowThreadProcessId(m_hWnd, &dwProcessID);
		return dwProcessID;
	}
	BOOL IsWindow()
	{
		return ::IsWindow(m_hWnd);
	}
	BOOL IsWindowUnicode()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::IsWindowUnicode(m_hWnd);
	}
	BOOL IsParentDialog()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TCHAR szBuf[8]; // "#32770" + NUL character
		GetClassName(GetParent(), szBuf, sizeof(szBuf)/sizeof(TCHAR));
		return lstrcmp(szBuf, _T("#32770")) == 0;
	}
	BOOL ShowWindowAsync(int nCmdShow)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::ShowWindowAsync(m_hWnd, nCmdShow);
	}

	HWND GetDescendantWindow(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// GetDlgItem recursive (return first found)
		// breadth-first for 1 level, then depth-first for next level

		// use GetDlgItem since it is a fast USER function
		HWND hWndChild, hWndTmp;
		CWindow wnd;
		if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL)
		{
			if(::GetTopWindow(hWndChild) != NULL)
			{
				// children with the same ID as their parent have priority
				wnd.Attach(hWndChild);
				hWndTmp = wnd.GetDescendantWindow(nID);
				if(hWndTmp != NULL)
					return hWndTmp;
			}
			return hWndChild;
		}

		// walk each child
		for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
			hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			wnd.Attach(hWndChild);
			hWndTmp = wnd.GetDescendantWindow(nID);
			if(hWndTmp != NULL)
				return hWndTmp;
		}

		return NULL;    // not found
	}

	void SendMessageToDescendants(UINT message, WPARAM wParam = 0, LPARAM lParam = 0, BOOL bDeep = TRUE)
	{
		CWindow wnd;
		for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
			hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
		{
			::SendMessage(hWndChild, message, wParam, lParam);

			if(bDeep && ::GetTopWindow(hWndChild) != NULL)
			{
				// send to child windows after parent
				wnd.Attach(hWndChild);
				wnd.SendMessageToDescendants(message, wParam, lParam, bDeep);
			}
		}
	}

	BOOL CenterWindow(HWND hWndCenter = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// determine owner window to center against
		DWORD dwStyle = GetStyle();
		if(hWndCenter == NULL)
		{
			if(dwStyle & WS_CHILD)
				hWndCenter = ::GetParent(m_hWnd);
			else
				hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
		}

		// get coordinates of the window relative to its parent
		RECT rcDlg;
		::GetWindowRect(m_hWnd, &rcDlg);
		RECT rcArea;
		RECT rcCenter;
		HWND hWndParent;
		if(!(dwStyle & WS_CHILD))
		{
			// don't center against invisible or minimized windows
			if(hWndCenter != NULL)
			{
				DWORD dwStyle = ::GetWindowLong(hWndCenter, GWL_STYLE);
				if(!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
					hWndCenter = NULL;
			}

			// center within screen coordinates
			::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);
			if(hWndCenter == NULL)
				rcCenter = rcArea;
			else
				::GetWindowRect(hWndCenter, &rcCenter);
		}
		else
		{
			// center within parent client coordinates
			hWndParent = ::GetParent(m_hWnd);
			ATLASSERT(::IsWindow(hWndParent));

			::GetClientRect(hWndParent, &rcArea);
			ATLASSERT(::IsWindow(hWndCenter));
			::GetClientRect(hWndCenter, &rcCenter);
			::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
		}

		int DlgWidth = rcDlg.right - rcDlg.left;
		int DlgHeight = rcDlg.bottom - rcDlg.top;

		// find dialog's upper left based on rcCenter
		int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
		int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

		// if the dialog is outside the screen, move it inside
		if(xLeft < rcArea.left)
			xLeft = rcArea.left;
		else if(xLeft + DlgWidth > rcArea.right)
			xLeft = rcArea.right - DlgWidth;

		if(yTop < rcArea.top)
			yTop = rcArea.top;
		else if(yTop + DlgHeight > rcArea.bottom)
			yTop = rcArea.bottom - DlgHeight;

		// map screen coordinates to child coordinates
		return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1,
			SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
	}

	BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
		DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
		if(dwStyle == dwNewStyle)
			return FALSE;

		::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle);
		if(nFlags != 0)
		{
			::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
				SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
		}

		return TRUE;
	}

	BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
		DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
		if(dwStyle == dwNewStyle)
			return FALSE;

		::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle);
		if(nFlags != 0)
		{
			::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
				SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
		}

		return TRUE;
	}

	BOOL GetWindowText(BSTR* pbstrText)
	{
		return GetWindowText(*pbstrText);
	}
	BOOL GetWindowText(BSTR& bstrText)
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		if (bstrText != NULL)
		{
			SysFreeString(bstrText);
			bstrText = NULL;
		}

		int nLen = ::GetWindowTextLength(m_hWnd);
		if(nLen == 0)
		{
			bstrText = ::SysAllocString(OLESTR(""));
			return (bstrText != NULL) ? TRUE : FALSE;
		}

		LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR));

		if(!::GetWindowText(m_hWnd, lpszText, nLen+1))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
	HWND GetTopLevelParent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndParent = m_hWnd;
		HWND hWndTmp;
		while((hWndTmp = ::GetParent(hWndParent)) != NULL)
			hWndParent = hWndTmp;

		return hWndParent;
	}

	HWND GetTopLevelWindow() const
	{
		ATLASSERT(::IsWindow(m_hWnd));

		HWND hWndParent;
		HWND hWndTmp = m_hWnd;

		do
		{
			hWndParent = hWndTmp;
			hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER);
		}
		while(hWndTmp != NULL);

		return hWndParent;
	}
};

_declspec(selectany) RECT CWindow::rcDefault = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };

/////////////////////////////////////////////////////////////////////////////
// CAxWindow - client side for an ActiveX host window

#ifndef _ATL_NO_HOSTING

template <class TBase = CWindow>
class CAxWindowT : public TBase
{
public:
// Constructors
	CAxWindowT(HWND hWnd = NULL) : TBase(hWnd)
	{ }

	CAxWindowT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("AtlAxWin");
	}

// Operations
	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
	}
	HWND Create(HWND hWndParent, LPRECT lpRect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, lpRect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
	}

	HRESULT CreateControl(LPCOLESTR lpszName, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return AtlAxCreateControl(lpszName, m_hWnd, pStream, ppUnkContainer);
	}

	HRESULT CreateControl(DWORD dwResID, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

		CComBSTR bstrURL(OLESTR("res://"));
		bstrURL.Append(szModule);
		bstrURL.Append(OLESTR("/"));
		TCHAR szResID[11];
		wsprintf(szResID, _T("%0d"), dwResID);
		bstrURL.Append(szResID);

		ATLASSERT(::IsWindow(m_hWnd));
		return AtlAxCreateControl(bstrURL, m_hWnd, pStream, ppUnkContainer);
	}

	HRESULT CreateControlEx(LPCOLESTR lpszName, IStream* pStream = NULL, 
			IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
			REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return AtlAxCreateControlEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
	}

	HRESULT CreateControlEx(DWORD dwResID,  IStream* pStream = NULL, 
			IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
			REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

		CComBSTR bstrURL(OLESTR("res://"));
		bstrURL.Append(szModule);
		bstrURL.Append(OLESTR("/"));
		TCHAR szResID[11];
		wsprintf(szResID, _T("%0d"), dwResID);
		bstrURL.Append(szResID);

		ATLASSERT(::IsWindow(m_hWnd));
		return AtlAxCreateControlEx(bstrURL, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
	}

	HRESULT AttachControl(IUnknown* pControl, IUnknown** ppUnkContainer)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return AtlAxAttachControl(pControl, m_hWnd, ppUnkContainer);
	}
	HRESULT QueryHost(REFIID iid, void** ppUnk)
	{
		ATLASSERT(ppUnk != NULL);
		HRESULT hr;
		*ppUnk = NULL;
		CComPtr<IUnknown> spUnk;
		hr = AtlAxGetHost(m_hWnd, &spUnk);
		if (SUCCEEDED(hr))
			hr = spUnk->QueryInterface(iid, ppUnk);
		return hr;
	}
	template <class Q>
	HRESULT QueryHost(Q** ppUnk)
	{
		return QueryHost(__uuidof(Q), (void**)ppUnk);
	}
	HRESULT QueryControl(REFIID iid, void** ppUnk)
	{
		ATLASSERT(ppUnk != NULL);
		HRESULT hr;
		*ppUnk = NULL;
		CComPtr<IUnknown> spUnk;
		hr = AtlAxGetControl(m_hWnd, &spUnk);
		if (SUCCEEDED(hr))
			hr = spUnk->QueryInterface(iid, ppUnk);
		return hr;
	}
	template <class Q>
	HRESULT QueryControl(Q** ppUnk)
	{
		return QueryControl(__uuidof(Q), (void**)ppUnk);
	}
	HRESULT SetExternalDispatch(IDispatch* pDisp)
	{
		HRESULT hr;
		CComPtr<IAxWinHostWindow> spHost;
		hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
		if (SUCCEEDED(hr))
			hr = spHost->SetExternalDispatch(pDisp);
		return hr;
	}
	HRESULT SetExternalUIHandler(IDocHostUIHandlerDispatch* pUIHandler)
	{
		HRESULT hr;
		CComPtr<IAxWinHostWindow> spHost;
		hr = QueryHost(IID_IAxWinHostWindow, (void**)&spHost);
		if (SUCCEEDED(hr))
			hr = spHost->SetExternalUIHandler(pUIHandler);
		return hr;
	}
};

typedef CAxWindowT<CWindow> CAxWindow;

#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// WindowProc thunks

#if defined(_M_IX86)
#pragma pack(push,1)
struct _WndProcThunk
{
	DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
	DWORD   m_this;         //
	BYTE    m_jmp;          // jmp WndProc
	DWORD   m_relproc;      // relative jmp
};
#pragma pack(pop)
#elif defined (_M_ALPHA)
// For ALPHA we will stick the this pointer into a0, which is where
// the HWND is.  However, we don't actually need the HWND so this is OK.
#pragma pack(push,4)
struct _WndProcThunk //this should come out to 20 bytes
{
	DWORD ldah_at;      //  ldah    at, HIWORD(func)
	DWORD ldah_a0;      //  ldah    a0, HIWORD(this)
	DWORD lda_at;       //  lda     at, LOWORD(func)(at)
	DWORD lda_a0;       //  lda     a0, LOWORD(this)(a0)
	DWORD jmp;          //  jmp     zero,(at),0
};
#pragma pack(pop)
#else
#error Only Alpha and X86 supported
#endif

class CWndProcThunk
{
public:
	union
	{
		_AtlCreateWndData cd;
		_WndProcThunk thunk;
	};
	void Init(WNDPROC proc, void* pThis)
	{
#if defined (_M_IX86)
		thunk.m_mov = 0x042444C7;  //C7 44 24 0C
		thunk.m_this = (DWORD)pThis;
		thunk.m_jmp = 0xe9;
		thunk.m_relproc = (int)proc - ((int)this+sizeof(_WndProcThunk));
#elif defined (_M_ALPHA)
		thunk.ldah_at = (0x279f0000 | HIWORD(proc)) + (LOWORD(proc)>>15);
		thunk.ldah_a0 = (0x261f0000 | HIWORD(pThis)) + (LOWORD(pThis)>>15);
		thunk.lda_at = 0x239c0000 | LOWORD(proc);
		thunk.lda_a0 = 0x22100000 | LOWORD(pThis);
		thunk.jmp = 0x6bfc0000;
#endif
		// write block from data cache and
		//  flush from instruction cache
		FlushInstructionCache(GetCurrentProcess(), &thunk, sizeof(thunk));
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMessageMap - abstract class that provides an interface for message maps

class ATL_NO_VTABLE CMessageMap
{
public:
	virtual BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
		LRESULT& lResult, DWORD dwMsgMapID) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Message map

#define BEGIN_MSG_MAP(theClass) \
public: \
	BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
	{ \
		BOOL bHandled = TRUE; \
		hWnd; \
		uMsg; \
		wParam; \
		lParam; \
		lResult; \
		bHandled; \
		switch(dwMsgMapID) \
		{ \
		case 0:

#define ALT_MSG_MAP(msgMapID) \
		break; \
		case msgMapID:

#define MESSAGE_HANDLER(msg, func) \
	if(uMsg == msg) \
	{ \
		bHandled = TRUE; \
		lResult = func(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define MESSAGE_RANGE_HANDLER(msgFirst, msgLast, func) \
	if(uMsg >= msgFirst && uMsg <= msgLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_HANDLER(id, code, func) \
	if(uMsg == WM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_ID_HANDLER(id, func) \
	if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_CODE_HANDLER(code, func) \
	if(uMsg == WM_COMMAND && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_HANDLER(id, cd, func) \
	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_ID_HANDLER(id, func) \
	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_CODE_HANDLER(cd, func) \
	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP(theChainClass) \
	{ \
		if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_MEMBER(theChainMember) \
	{ \
		if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_ALT(theChainClass, msgMapID) \
	{ \
		if(theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_ALT_MEMBER(theChainMember, msgMapID) \
	{ \
		if(theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_MSG_MAP_DYNAMIC(dynaChainID) \
	{ \
		if(CDynamicChain::CallChain(dynaChainID, hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define END_MSG_MAP() \
			break; \
		default: \
			ATLTRACE2(atlTraceWindowing, 0, _T("Invalid message map ID (%i)\n"), dwMsgMapID); \
			ATLASSERT(FALSE); \
			break; \
		} \
		return FALSE; \
	}


// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// Empty message map macro

#define DECLARE_EMPTY_MSG_MAP() \
public: \
	BOOL ProcessWindowMessage(HWND, UINT, WPARAM, LPARAM, LRESULT&, DWORD) \
	{ \
		return FALSE; \
	}

// Message reflection macros

#define REFLECT_NOTIFICATIONS() \
	{ \
		bHandled = TRUE; \
		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define DEFAULT_REFLECTION_HANDLER() \
	if(DefaultReflectionHandler(hWnd, uMsg, wParam, lParam, lResult)) \
		return TRUE;

/////////////////////////////////////////////////////////////////////////////
// CDynamicChain - provides support for dynamic chaining

class CDynamicChain
{
public:
	struct ATL_CHAIN_ENTRY
	{
		DWORD m_dwChainID;
		CMessageMap* m_pObject;
		DWORD m_dwMsgMapID;
	};

	CSimpleArray<ATL_CHAIN_ENTRY*> m_aChainEntry;

	CDynamicChain()
	{ }

	~CDynamicChain()
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL)
				delete m_aChainEntry[i];
		}
	}

	BOOL SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID = 0)
	{
	// first search for an existing entry

		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
			{
				m_aChainEntry[i]->m_pObject = pObject;
				m_aChainEntry[i]->m_dwMsgMapID = dwMsgMapID;
				return TRUE;
			}
		}

	// create a new one

		ATL_CHAIN_ENTRY* pEntry = NULL;
		ATLTRY(pEntry = new ATL_CHAIN_ENTRY);

		if(pEntry == NULL)
			return FALSE;

		pEntry->m_dwChainID = dwChainID;
		pEntry->m_pObject = pObject;
		pEntry->m_dwMsgMapID = dwMsgMapID;

	// search for an empty one

		for(i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] == NULL)
			{
				m_aChainEntry[i] = pEntry;
				return TRUE;
			}
		}

	// add a new one

		BOOL bRet = m_aChainEntry.Add(pEntry);

		if(!bRet)
		{
			delete pEntry;
			return FALSE;
		}

		return TRUE;
	}

	BOOL RemoveChainEntry(DWORD dwChainID)
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
			{
				delete m_aChainEntry[i];
				m_aChainEntry[i] = NULL;
				return TRUE;
			}
		}

		return FALSE;
	}

	BOOL CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
	{
		for(int i = 0; i < m_aChainEntry.GetSize(); i++)
		{
			if(m_aChainEntry[i] != NULL && m_aChainEntry[i]->m_dwChainID == dwChainID)
				return (m_aChainEntry[i]->m_pObject)->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_aChainEntry[i]->m_dwMsgMapID);
		}

		return FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo - Manages Windows class information

#define DECLARE_WND_CLASS(WndClassName) \
static CWndClassInfo& GetWndClassInfo() \
{ \
	static CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}

#define DECLARE_WND_CLASS_EX(WndClassName, style, bkgnd) \
static CWndClassInfo& GetWndClassInfo() \
{ \
	static CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}

#define DECLARE_WND_SUPERCLASS(WndClassName, OrigWndClassName) \
static CWndClassInfo& GetWndClassInfo() \
{ \
	static CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
		OrigWndClassName, NULL, NULL, TRUE, 0, _T("") \
	}; \
	return wc; \
}

/////////////////////////////////////////////////////////////////////////////
// CWinTraits - Defines various default values for a window

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0>
class CWinTraits
{
public:
	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return dwStyle == 0 ? t_dwStyle : dwStyle;
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return dwExStyle == 0 ? t_dwExStyle : dwExStyle;
	}
};

typedef CWinTraits<WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0>					CControlWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_APPWINDOW | WS_EX_WINDOWEDGE>		CFrameWinTraits;
typedef CWinTraits<WS_OVERLAPPEDWINDOW | WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, WS_EX_MDICHILD>	CMDIChildWinTraits;

typedef CWinTraits<0, 0> CNullTraits;

template <DWORD t_dwStyle = 0, DWORD t_dwExStyle = 0, class TWinTraits = CControlWinTraits>
class CWinTraitsOR
{
public:
	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return dwStyle | t_dwStyle | TWinTraits::GetWndStyle(dwStyle);
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return dwExStyle | t_dwExStyle | TWinTraits::GetWndExStyle(dwExStyle);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl - Implements a window

template <class TBase = CWindow>
class ATL_NO_VTABLE CWindowImplRoot : public TBase, public CMessageMap
{
public:
	CWndProcThunk m_thunk;
	const MSG* m_pCurrentMsg;

// Constructor/destructor
	CWindowImplRoot() : m_pCurrentMsg(NULL)
	{ }

	~CWindowImplRoot()
	{
#ifdef _DEBUG
		if(m_hWnd != NULL)	// should be cleared in WindowProc
		{
			ATLTRACE2(atlTraceWindowing, 0, _T("ERROR - Object deleted before window was destroyed\n"));
			ATLASSERT(FALSE);
		}
#endif //_DEBUG
	}

// Current message
	const MSG* GetCurrentMessage() const
	{
		return m_pCurrentMsg;
	}

// Message reflection support
	LRESULT ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	static BOOL DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult);
};

template <class TBase>
LRESULT CWindowImplRoot< TBase >::ReflectNotifications(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HWND hWndChild = NULL;

	switch(uMsg)
	{
	case WM_COMMAND:
		if(lParam != NULL)	// not from a menu
			hWndChild = (HWND)lParam;
		break;
	case WM_NOTIFY:
		hWndChild = ((LPNMHDR)lParam)->hwndFrom;
		break;
	case WM_PARENTNOTIFY:
		switch(LOWORD(wParam))
		{
		case WM_CREATE:
		case WM_DESTROY:
			hWndChild = (HWND)lParam;
			break;
		default:
			hWndChild = GetDlgItem(HIWORD(wParam));
			break;
		}
		break;
	case WM_DRAWITEM:
		if(wParam)	// not from a menu
			hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
		break;
	case WM_MEASUREITEM:
		if(wParam)	// not from a menu
			hWndChild = GetDlgItem(((LPMEASUREITEMSTRUCT)lParam)->CtlID);
		break;
	case WM_COMPAREITEM:
		if(wParam)	// not from a menu
			hWndChild = GetDlgItem(((LPCOMPAREITEMSTRUCT)lParam)->CtlID);
		break;
	case WM_DELETEITEM:
		if(wParam)	// not from a menu
			hWndChild = GetDlgItem(((LPDELETEITEMSTRUCT)lParam)->CtlID);
		break;
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
		hWndChild = (HWND)lParam;
		break;
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
		hWndChild = (HWND)lParam;
		break;
	default:
		break;
	}

	if(hWndChild == NULL)
	{
		bHandled = FALSE;
		return 1;
	}

	ATLASSERT(::IsWindow(hWndChild));
	return ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
}

template <class TBase>
BOOL CWindowImplRoot< TBase >::DefaultReflectionHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
	switch(uMsg)
	{
	case OCM_COMMAND:
	case OCM_NOTIFY:
	case OCM_PARENTNOTIFY:
	case OCM_DRAWITEM:
	case OCM_MEASUREITEM:
	case OCM_COMPAREITEM:
	case OCM_DELETEITEM:
	case OCM_VKEYTOITEM:
	case OCM_CHARTOITEM:
	case OCM_HSCROLL:
	case OCM_VSCROLL:
	case OCM_CTLCOLORBTN:
	case OCM_CTLCOLORDLG:
	case OCM_CTLCOLOREDIT:
	case OCM_CTLCOLORLISTBOX:
	case OCM_CTLCOLORMSGBOX:
	case OCM_CTLCOLORSCROLLBAR:
	case OCM_CTLCOLORSTATIC:
		lResult = ::DefWindowProc(hWnd, uMsg - OCM__BASE, wParam, lParam);
		return TRUE;
	default:
		break;
	}
	return FALSE;
}

template <class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImplBaseT : public CWindowImplRoot< TBase >
{
public:
	WNDPROC m_pfnSuperWindowProc;

	CWindowImplBaseT() : m_pfnSuperWindowProc(::DefWindowProc)
	{}

	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return TWinTraits::GetWndStyle(dwStyle);
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return TWinTraits::GetWndExStyle(dwExStyle);
	}

	virtual WNDPROC GetWindowProc()
	{
		return WindowProc;
	}
	static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
			DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam = NULL);
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::DestroyWindow(m_hWnd);
	}
	BOOL SubclassWindow(HWND hWnd);
	HWND UnsubclassWindow(BOOL bForce = FALSE);

	LRESULT DefWindowProc()
	{
		const MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
#ifdef STRICT
		return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
		return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
	}

	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		// override to do something, if needed
	}
};

typedef CWindowImplBaseT<CWindow>	CWindowImplBase;

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)_Module.ExtractCreateWndData();
	ATLASSERT(pThis != NULL);
	pThis->m_hWnd = hWnd;
	pThis->m_thunk.Init(pThis->GetWindowProc(), pThis);
	WNDPROC pProc = (WNDPROC)&(pThis->m_thunk.thunk);
	WNDPROC pOldProc = (WNDPROC)::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc);
#ifdef _DEBUG
	// check if somebody has subclassed us already since we discard it
	if(pOldProc != StartWindowProc)
		ATLTRACE2(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
	pOldProc;	// avoid unused warning
#endif
	return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
	// set a ptr to this message and save the old value
	MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
	const MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	// restore saved value for the current message
	ATLASSERT(pThis->m_pCurrentMsg == &msg);
	pThis->m_pCurrentMsg = pOldMsg;
	// do the default processing if message was not handled
	if(!bRet)
	{
		if(uMsg != WM_NCDESTROY)
			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
		else
		{
			// unsubclass, if needed
			LONG pfnWndProc = ::GetWindowLong(pThis->m_hWnd, GWL_WNDPROC);
			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLong(pThis->m_hWnd, GWL_WNDPROC) == pfnWndProc)
				::SetWindowLong(pThis->m_hWnd, GWL_WNDPROC, (LONG)pThis->m_pfnSuperWindowProc);
			// clear out window handle
			HWND hWnd = pThis->m_hWnd;
			pThis->m_hWnd = NULL;
			// clean up after window is destroyed
			pThis->OnFinalMessage(hWnd);
		}
	}
	return lRes;
}

template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
		DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam)
{
	ATLASSERT(m_hWnd == NULL);

	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
		nID = (UINT)this;

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)MAKELONG(atom, 0), szWindowName,
		dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
		rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
		_Module.GetModuleInstance(), lpCreateParam);

	ATLASSERT(m_hWnd == hWnd);

	return hWnd;
}

template <class TBase, class TWinTraits>
BOOL CWindowImplBaseT< TBase, TWinTraits >::SubclassWindow(HWND hWnd)
{
	ATLASSERT(m_hWnd == NULL);
	ATLASSERT(::IsWindow(hWnd));
	m_thunk.Init(GetWindowProc(), this);
	WNDPROC pProc = (WNDPROC)&(m_thunk.thunk);
	WNDPROC pfnWndProc = (WNDPROC)::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

// Use only if you want to subclass before window is destroyed,
// WindowProc will automatically subclass when  window goes away
template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::UnsubclassWindow(BOOL bForce /*= FALSE*/)
{
	ATLASSERT(m_hWnd != NULL);

	WNDPROC pOurProc = (WNDPROC)&(m_thunk.thunk);
	WNDPROC pActiveProc = (WNDPROC)::GetWindowLong(m_hWnd, GWL_WNDPROC);

	HWND hWnd = NULL;
	if (bForce || pOurProc == pActiveProc)
	{
		if(!::SetWindowLong(m_hWnd, GWL_WNDPROC, (LONG)m_pfnSuperWindowProc))
			return NULL;

		m_pfnSuperWindowProc = ::DefWindowProc;
		hWnd = m_hWnd;
		m_hWnd = NULL;
	}
	return hWnd;
}

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CWindowImpl : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	DECLARE_WND_CLASS(NULL)

	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		if (T::GetWndClassInfo().m_lpszOrigName == NULL)
			T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rcPos, szWindowName,
			dwStyle, dwExStyle, nID, atom, lpCreateParam);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CDialogImpl - Implements a dialog box

template <class TBase = CWindow>
class ATL_NO_VTABLE CDialogImplBaseT : public CWindowImplRoot< TBase >
{
public:
	virtual WNDPROC GetDialogProc()
	{
		return DialogProc;
	}
	static LRESULT CALLBACK StartDialogProc(HWND hWnd, UINT uMsg,
		WPARAM wParam, LPARAM lParam);
	static LRESULT CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL MapDialogRect(LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::MapDialogRect(m_hWnd, lpRect);
	}
	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		// override to do something, if needed
	}
	// has no meaning for a dialog, but needed for handlers that use it
	LRESULT DefWindowProc()
	{
		return 0;
	}
};

template <class TBase>
LRESULT CALLBACK CDialogImplBaseT< TBase >::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)_Module.ExtractCreateWndData();
	ATLASSERT(pThis != NULL);
	pThis->m_hWnd = hWnd;
	pThis->m_thunk.Init(pThis->GetDialogProc(), pThis);
	WNDPROC pProc = (WNDPROC)&(pThis->m_thunk.thunk);
	WNDPROC pOldProc = (WNDPROC)::SetWindowLong(hWnd, DWL_DLGPROC, (LONG)pProc);
#ifdef _DEBUG
	// check if somebody has subclassed us already since we discard it
	if(pOldProc != StartDialogProc)
		ATLTRACE2(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
	pOldProc;	// avoid unused warning
#endif
	return pProc(hWnd, uMsg, wParam, lParam);
}

template <class TBase>
LRESULT CALLBACK CDialogImplBaseT< TBase >::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)hWnd;
	// set a ptr to this message and save the old value
	MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
	const MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	// restore saved value for the current message
	ATLASSERT(pThis->m_pCurrentMsg == &msg);
	pThis->m_pCurrentMsg = pOldMsg;
	// set result if message was handled
	if(bRet)
	{
		switch (uMsg)
		{
		case WM_COMPAREITEM:
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_INITDIALOG:
		case WM_QUERYDRAGICON:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			return lRes;
			break;
		}
		::SetWindowLong(pThis->m_hWnd, DWL_MSGRESULT, lRes);
		return TRUE;
	}
	if(uMsg == WM_NCDESTROY)
	{
		// clear out window handle
		HWND hWnd = pThis->m_hWnd;
		pThis->m_hWnd = NULL;
		// clean up after dialog is destroyed
		pThis->OnFinalMessage(hWnd);
	}
	return FALSE;
}

typedef CDialogImplBaseT<CWindow>	CDialogImplBase;

template <class T, class TBase = CWindow>
class ATL_NO_VTABLE CDialogImpl : public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
	bool m_bModal;
	CDialogImpl() : m_bModal(false) { }
#endif //_DEBUG
	// modal dialogs
	int DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = true;
#endif //_DEBUG
		return ::DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, (DLGPROC)T::StartDialogProc, dwInitParam);
	}
	BOOL EndDialog(int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_bModal);	// must be a modal dialog
		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = false;
#endif //_DEBUG
		HWND hWnd = ::CreateDialogParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, (DLGPROC)T::StartDialogProc, dwInitParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(!m_bModal);	// must not be a modal dialog
		return ::DestroyWindow(m_hWnd);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CAxDialogImpl - Implements a dialog box that hosts ActiveX controls

#ifndef _ATL_NO_HOSTING

template <class T, class TBase = CWindow>
class ATL_NO_VTABLE CAxDialogImpl : public CDialogImplBaseT< TBase >
{
public:
#ifdef _DEBUG
	bool m_bModal;
	CAxDialogImpl() : m_bModal(false) { }
#endif //_DEBUG
	// modal dialogs
	int DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = true;
#endif //_DEBUG
		return AtlAxDialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, (DLGPROC)T::StartDialogProc, dwInitParam);
	}
	BOOL EndDialog(int nRetCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_bModal);	// must be a modal dialog
		return ::EndDialog(m_hWnd, nRetCode);
	}
	// modeless dialogs
	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);
#ifdef _DEBUG
		m_bModal = false;
#endif //_DEBUG
		HWND hWnd = AtlAxCreateDialog(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::IDD),
					hWndParent, (DLGPROC)T::StartDialogProc, dwInitParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}
	// for CComControl
	HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
	{
		return Create(hWndParent, dwInitParam);
	}
	BOOL DestroyWindow()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(!m_bModal);	// must not be a modal dialog
		return ::DestroyWindow(m_hWnd);
	}
};

#endif //_ATL_NO_HOSTING

/////////////////////////////////////////////////////////////////////////////
// CSimpleDialog - Prebuilt modal dialog that uses standard buttons

template <WORD t_wDlgTemplateID, BOOL t_bCenter = TRUE>
class CSimpleDialog : public CDialogImplBase
{
public:
	int DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);
		int nRet = ::DialogBox(_Module.GetResourceInstance(),
			MAKEINTRESOURCE(t_wDlgTemplateID), hWndParent, (DLGPROC)StartDialogProc);
		m_hWnd = NULL;
		return nRet;
	}

	typedef CSimpleDialog<t_wDlgTemplateID, t_bCenter>	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_RANGE_HANDLER(IDOK, IDNO, OnCloseCmd)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(t_bCenter)
			CenterWindow(GetParent());
		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		::EndDialog(m_hWnd, wID);
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow - Implements a contained window

template <class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CContainedWindowT : public TBase
{
public:
	CWndProcThunk m_thunk;
	LPCTSTR m_lpszClassName;
	WNDPROC m_pfnSuperWindowProc;
	CMessageMap* m_pObject;
	DWORD m_dwMsgMapID;
	const MSG* m_pCurrentMsg;

	// If you use this constructor you must supply
	// the Window Class Name, Object* and Message Map ID
	// Later to the Create call
	CContainedWindowT() : m_pCurrentMsg(NULL)
	{ }

	CContainedWindowT(LPTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID = 0)
		: m_lpszClassName(lpszClassName),
		m_pfnSuperWindowProc(::DefWindowProc),
		m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
		m_pCurrentMsg(NULL)
	{ }

	CContainedWindowT(CMessageMap* pObject, DWORD dwMsgMapID = 0)
		: m_lpszClassName(TBase::GetWndClassName()),
		m_pfnSuperWindowProc(::DefWindowProc),
		m_pObject(pObject), m_dwMsgMapID(dwMsgMapID),
		m_pCurrentMsg(NULL)
	{ }

	void SwitchMessageMap(DWORD dwMsgMapID)
	{
		m_dwMsgMapID = dwMsgMapID;
	}

	const MSG* GetCurrentMessage() const
	{
		return m_pCurrentMsg;
	}

	LRESULT DefWindowProc()
	{
		const MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
#ifdef STRICT
		return ::CallWindowProc(m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#else
		return ::CallWindowProc((FARPROC)m_pfnSuperWindowProc, m_hWnd, uMsg, wParam, lParam);
#endif
	}
	static LRESULT CALLBACK StartWindowProc(HWND hWnd, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
	{
		CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)_Module.ExtractCreateWndData();
		ATLASSERT(pThis != NULL);
		pThis->m_hWnd = hWnd;
		pThis->m_thunk.Init(WindowProc, pThis);
		WNDPROC pProc = (WNDPROC)&(pThis->m_thunk.thunk);
		WNDPROC pOldProc = (WNDPROC)::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc);
#ifdef _DEBUG
		// check if somebody has subclassed us already since we discard it
		if(pOldProc != StartWindowProc)
			ATLTRACE2(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
#else
		pOldProc;	// avoid unused warning
#endif
		return pProc(hWnd, uMsg, wParam, lParam);
	}

	static LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CContainedWindowT< TBase >* pThis = (CContainedWindowT< TBase >*)hWnd;
		ATLASSERT(pThis->m_hWnd != NULL);
		ATLASSERT(pThis->m_pObject != NULL);
		// set a ptr to this message and save the old value
		MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
		const MSG* pOldMsg = pThis->m_pCurrentMsg;
		pThis->m_pCurrentMsg = &msg;
		// pass to the message map to process
		LRESULT lRes;
		BOOL bRet = pThis->m_pObject->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, pThis->m_dwMsgMapID);
		// restore saved value for the current message
		ATLASSERT(pThis->m_pCurrentMsg == &msg);
		pThis->m_pCurrentMsg = pOldMsg;
		// do the default processing if message was not handled
		if(!bRet)
		{
			if(uMsg != WM_NCDESTROY)
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			else
			{
				// unsubclass, if needed
				LONG pfnWndProc = ::GetWindowLong(pThis->m_hWnd, GWL_WNDPROC);
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
				if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLong(pThis->m_hWnd, GWL_WNDPROC) == pfnWndProc)
					::SetWindowLong(pThis->m_hWnd, GWL_WNDPROC, (LONG)pThis->m_pfnSuperWindowProc);
				// clear out window handle
				pThis->m_hWnd = NULL;
			}
		}
		return lRes;
	}

	ATOM RegisterWndSuperclass()
	{
		ATOM atom = 0;
		LPTSTR szBuff = (LPTSTR)_alloca((lstrlen(m_lpszClassName) + 14) * sizeof(TCHAR));

		WNDCLASSEX wc;
		wc.cbSize = sizeof(WNDCLASSEX);

		// Try global class
		if(!::GetClassInfoEx(NULL, m_lpszClassName, &wc))
		{
			// try local class
			if(!::GetClassInfoEx(_Module.GetModuleInstance(), m_lpszClassName, &wc))
				return atom;
		}

		m_pfnSuperWindowProc = wc.lpfnWndProc;
		lstrcpy(szBuff, _T("ATL:"));
		lstrcat(szBuff, m_lpszClassName);

		WNDCLASSEX wc1;
		wc1.cbSize = sizeof(WNDCLASSEX);
		atom = (ATOM)::GetClassInfoEx(_Module.GetModuleInstance(), szBuff, &wc1);

		if(atom == 0)   // register class
		{
			wc.lpszClassName = szBuff;
			wc.lpfnWndProc = StartWindowProc;
			wc.hInstance = _Module.GetModuleInstance();
			wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes

			atom = ::RegisterClassEx(&wc);
		}

		return atom;
	}
	HWND Create(CMessageMap* pObject, DWORD dwMsgMapID, HWND hWndParent, RECT* prcPos,
		LPCTSTR szWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0,
		UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		m_lpszClassName = TBase::GetWndClassName();
		m_pfnSuperWindowProc = ::DefWindowProc;
		m_pObject = pObject;
		m_dwMsgMapID = dwMsgMapID;
		return Create(hWndParent, prcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
	}

	HWND Create(LPCTSTR lpszClassName, CMessageMap* pObject, DWORD dwMsgMapID, HWND hWndParent, RECT* prcPos, LPCTSTR szWindowName = NULL,
		DWORD dwStyle = 0, DWORD dwExStyle = 0, UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		m_lpszClassName = lpszClassName;
		m_pfnSuperWindowProc = ::DefWindowProc;
		m_pObject = pObject;
		m_dwMsgMapID = dwMsgMapID;
		return Create(hWndParent, prcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
	}


	// This function is Deprecated, use the version
	// which takes a RECT* instead
	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
		DWORD dwStyle = 0, DWORD dwExStyle = 0,
		UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		return Create(hWndParent, &rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
	}

	HWND Create(HWND hWndParent, RECT* prcPos, LPCTSTR szWindowName = NULL,
		DWORD dwStyle = 0, DWORD dwExStyle = 0,
		UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		ATLASSERT(m_hWnd == NULL);

		ATOM atom = RegisterWndSuperclass();
		if(atom == 0)
			return NULL;

		_Module.AddCreateWndData(&m_thunk.cd, this);

		if(nID == 0 && (dwStyle & WS_CHILD))
			nID = (UINT)this;

		dwStyle = TWinTraits::GetWndStyle(dwStyle);
		dwExStyle = TWinTraits::GetWndExStyle(dwExStyle);

		HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)MAKELONG(atom, 0), szWindowName,
								dwStyle,
								prcPos->left, prcPos->top,
								prcPos->right - prcPos->left,
								prcPos->bottom - prcPos->top,
								hWndParent, (HMENU)nID,
								_Module.GetModuleInstance(), lpCreateParam);
		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}

	BOOL SubclassWindow(HWND hWnd)
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));

		m_thunk.Init(WindowProc, this);
		WNDPROC pProc = (WNDPROC)&m_thunk.thunk;
		WNDPROC pfnWndProc = (WNDPROC)::SetWindowLong(hWnd, GWL_WNDPROC, (LONG)pProc);
		if(pfnWndProc == NULL)
			return FALSE;
		m_pfnSuperWindowProc = pfnWndProc;
		m_hWnd = hWnd;
		return TRUE;
	}

	// Use only if you want to subclass before window is destroyed,
	// WindowProc will automatically subclass when  window goes away
	HWND UnsubclassWindow(BOOL bForce = FALSE)
	{
		ATLASSERT(m_hWnd != NULL);

		WNDPROC pOurProc = (WNDPROC)&(m_thunk.thunk);
		WNDPROC pActiveProc = (WNDPROC)::GetWindowLong(m_hWnd, GWL_WNDPROC);

		HWND hWnd = NULL;
		if (bForce || pOurProc == pActiveProc)
		{
			if(!::SetWindowLong(m_hWnd, GWL_WNDPROC, (LONG)m_pfnSuperWindowProc))
				return NULL;

			m_pfnSuperWindowProc = ::DefWindowProc;
			hWnd = m_hWnd;
			m_hWnd = NULL;
		}
		return hWnd;
	}
};

typedef CContainedWindowT<CWindow>	CContainedWindow;

/////////////////////////////////////////////////////////////////////////////
// _DialogSizeHelper - helpers for calculating the size of a dialog template

class _DialogSizeHelper
{
public:
//local struct used for implementation
#pragma pack(push, 1)
	struct _ATL_DLGTEMPLATEEX
	{
		WORD dlgVer;
		WORD signature;
		DWORD helpID;
		DWORD exStyle;
		DWORD style;
		WORD cDlgItems;
		short x;
		short y;
		short cx;
		short cy;
	};
#pragma pack(pop)

	static void GetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		// If the dialog has a font we use it otherwise we default
		// to the system font.
		if (HasFont(pTemplate))
		{
			TCHAR szFace[LF_FACESIZE];
			WORD  wFontSize = 0;
			GetFont(pTemplate, szFace, &wFontSize);
			GetSizeInDialogUnits(pTemplate, pSize);
			ConvertDialogUnitsToPixels(szFace, wFontSize, pSize);
		}
		else
		{
			GetSizeInDialogUnits(pTemplate, pSize);
			LONG nDlgBaseUnits = GetDialogBaseUnits();
			pSize->cx = MulDiv(pSize->cx, LOWORD(nDlgBaseUnits), 4);
			pSize->cy = MulDiv(pSize->cy, HIWORD(nDlgBaseUnits), 8);
		}
	}

	static void ConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizePixel)
	{
		// Attempt to create the font to be used in the dialog box
		UINT cxSysChar, cySysChar;
		LOGFONT lf;
		HDC hDC = ::GetDC(NULL);
		int cxDlg = pSizePixel->cx;
		int cyDlg = pSizePixel->cy;

		ZeroMemory(&lf, sizeof(LOGFONT));
		lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
		lf.lfWeight = FW_NORMAL;
		lf.lfCharSet = DEFAULT_CHARSET;
		lstrcpy(lf.lfFaceName, pszFontFace);

		HFONT hNewFont = CreateFontIndirect(&lf);
		if (hNewFont != NULL)
		{
			TEXTMETRIC  tm;
			SIZE        size;
			HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont);
			GetTextMetrics(hDC, &tm);
			cySysChar = tm.tmHeight + tm.tmExternalLeading;
			::GetTextExtentPoint(hDC,
				_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
				&size);
			cxSysChar = (size.cx + 26) / 52;
			SelectObject(hDC, hFontOld);
			DeleteObject(hNewFont);
		}
		else
		{
			// Could not create the font so just use the system's values
			cxSysChar = LOWORD(GetDialogBaseUnits());
			cySysChar = HIWORD(GetDialogBaseUnits());
		}
		::ReleaseDC(NULL, hDC);

		// Translate dialog units to pixels
		pSizePixel->cx = MulDiv(cxDlg, cxSysChar, 4);
		pSizePixel->cy = MulDiv(cyDlg, cySysChar, 8);
	}

	static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
	{
		return ((_ATL_DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	static BOOL HasFont(const DLGTEMPLATE* pTemplate)
	{
		return (DS_SETFONT &
			(IsDialogEx(pTemplate) ?
				((_ATL_DLGTEMPLATEEX*)pTemplate)->style : pTemplate->style));
	}

	static BYTE* GetFontSizeField(const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);
		WORD* pw;

		if (bDialogEx)
			pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1);
		else
			pw = (WORD*)(pTemplate + 1);

		if (*pw == (WORD)-1)        // Skip menu name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		if (*pw == (WORD)-1)        // Skip class name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		while (*pw++);          // Skip caption string

		return (BYTE*)pw;
	}

	static BOOL GetFont(const DLGTEMPLATE* pTemplate, TCHAR* pszFace, WORD* pFontSize)
	{
		USES_CONVERSION;
		if (!HasFont(pTemplate))
			return FALSE;

		BYTE* pb = GetFontSizeField(pTemplate);
		*pFontSize = *(WORD*)pb;
		// Skip over font attributes to get to the font name
		pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1);

		_tcscpy(pszFace, W2T((WCHAR*)pb));
		return TRUE;
	}

	static void GetSizeInDialogUnits(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		if (IsDialogEx(pTemplate))
		{
			pSize->cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cx;
			pSize->cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cy;
		}
		else
		{
			pSize->cx = pTemplate->cx;
			pSize->cy = pTemplate->cy;
		}
	}
};

inline void AtlGetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize)
{
	_DialogSizeHelper::GetDialogSize(pTemplate, pSize);
}

}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLWIN_IMPL
#endif
#endif

#endif // __ATLWIN_H__

//All exports go here
#ifdef _ATLWIN_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

ATLINLINE ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoA(_ATL_MODULE* pM, _ATL_WNDCLASSINFOA* p, WNDPROC* pProc)
{
	if (p->m_atom == 0)
	{
		::EnterCriticalSection(&pM->m_csWindowCreate);
		if(p->m_atom == 0)
		{
			HINSTANCE hInst = pM->m_hInst;
			if (p->m_lpszOrigName != NULL)
			{
				ATLASSERT(pProc != NULL);
				LPCSTR lpsz = p->m_wc.lpszClassName;
				WNDPROC proc = p->m_wc.lpfnWndProc;

				WNDCLASSEXA wc;
				wc.cbSize = sizeof(WNDCLASSEX);
				// Try global class
				if(!::GetClassInfoExA(NULL, p->m_lpszOrigName, &wc))
				{
					// try process local
					if(!::GetClassInfoExA(_Module.GetModuleInstance(), p->m_lpszOrigName, &wc))
					{
						::LeaveCriticalSection(&pM->m_csWindowCreate);
						return 0;
					}
				}
				memcpy(&p->m_wc, &wc, sizeof(WNDCLASSEX));
				p->pWndProc = p->m_wc.lpfnWndProc;
				p->m_wc.lpszClassName = lpsz;
				p->m_wc.lpfnWndProc = proc;
			}
			else
			{
				p->m_wc.hCursor = ::LoadCursorA(p->m_bSystemCursor ? NULL : hInst,
					p->m_lpszCursorID);
			}

			p->m_wc.hInstance = hInst;
			p->m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
			if (p->m_wc.lpszClassName == NULL)
			{
				wsprintfA(p->m_szAutoName, "ATL:%8.8X", (DWORD)&p->m_wc);
				p->m_wc.lpszClassName = p->m_szAutoName;
			}
			WNDCLASSEXA wcTemp;
			memcpy(&wcTemp, &p->m_wc, sizeof(WNDCLASSEXW));
			p->m_atom = (ATOM)::GetClassInfoExA(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp);
			if (p->m_atom == 0)
				p->m_atom = ::RegisterClassExA(&p->m_wc);
		}
		::LeaveCriticalSection(&pM->m_csWindowCreate);
	}

	if (p->m_lpszOrigName != NULL)
	{
		ATLASSERT(pProc != NULL);
		ATLASSERT(p->pWndProc != NULL);
		*pProc = p->pWndProc;
	}
	return p->m_atom;
}

ATLINLINE ATLAPI_(ATOM) AtlModuleRegisterWndClassInfoW(_ATL_MODULE* pM, _ATL_WNDCLASSINFOW* p, WNDPROC* pProc)
{
	if (p->m_atom == 0)
	{
		::EnterCriticalSection(&pM->m_csWindowCreate);
		if(p->m_atom == 0)
		{
			HINSTANCE hInst = pM->m_hInst;
			if (p->m_lpszOrigName != NULL)
			{
				ATLASSERT(pProc != NULL);
				LPCWSTR lpsz = p->m_wc.lpszClassName;
				WNDPROC proc = p->m_wc.lpfnWndProc;

				WNDCLASSEXW wc;
				wc.cbSize = sizeof(WNDCLASSEX);
				// Try global class
				if(!::GetClassInfoExW(NULL, p->m_lpszOrigName, &wc))
				{
					// try process local
					if(!::GetClassInfoExW(_Module.GetModuleInstance(), p->m_lpszOrigName, &wc))
					{
						::LeaveCriticalSection(&pM->m_csWindowCreate);
						return 0;
					}
				}
				memcpy(&p->m_wc, &wc, sizeof(WNDCLASSEX));
				p->pWndProc = p->m_wc.lpfnWndProc;
				p->m_wc.lpszClassName = lpsz;
				p->m_wc.lpfnWndProc = proc;
			}
			else
			{
				p->m_wc.hCursor = ::LoadCursorW(p->m_bSystemCursor ? NULL : hInst,
					p->m_lpszCursorID);
			}

			p->m_wc.hInstance = hInst;
			p->m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
			if (p->m_wc.lpszClassName == NULL)
			{
				wsprintfW(p->m_szAutoName, L"ATL:%8.8X", (DWORD)&p->m_wc);
				p->m_wc.lpszClassName = p->m_szAutoName;
			}
			WNDCLASSEXW wcTemp;
			memcpy(&wcTemp, &p->m_wc, sizeof(WNDCLASSEXW));
			p->m_atom = (ATOM)::GetClassInfoExW(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp);
			if (p->m_atom == 0)
				p->m_atom = ::RegisterClassExW(&p->m_wc);
		}
		::LeaveCriticalSection(&pM->m_csWindowCreate);
	}

	if (p->m_lpszOrigName != NULL)
	{
		ATLASSERT(pProc != NULL);
		ATLASSERT(p->pWndProc != NULL);
		*pProc = p->pWndProc;
	}
	return p->m_atom;
}

ATLINLINE ATLAPI_(HDC) AtlCreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd)
{
	USES_CONVERSION;

	// cases  hdc, ptd, hdc is metafile, hic
//  NULL,    NULL,  n/a,    Display
//  NULL,   !NULL,  n/a,    ptd
//  !NULL,   NULL,  FALSE,  hdc
//  !NULL,   NULL,  TRUE,   display
//  !NULL,  !NULL,  FALSE,  ptd
//  !NULL,  !NULL,  TRUE,   ptd

	if (ptd != NULL)
	{
		LPDEVMODEOLE lpDevMode;
		LPOLESTR lpszDriverName;
		LPOLESTR lpszDeviceName;
		LPOLESTR lpszPortName;

		if (ptd->tdExtDevmodeOffset == 0)
			lpDevMode = NULL;
		else
			lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

		lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
		lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
		lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

		return ::CreateDC(OLE2CT(lpszDriverName), OLE2CT(lpszDeviceName),
			OLE2CT(lpszPortName), DEVMODEOLE2T(lpDevMode));
	}
	else if (hdc == NULL || GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
	else
		return hdc;
}

ATLINLINE ATLAPI_(void) AtlHiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	ATLASSERT(hDCScreen != NULL);
	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);

	lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);
	lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);
}

ATLINLINE ATLAPI_(void) AtlPixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
	int nPixelsPerInchX;    // Pixels per logical inch along width
	int nPixelsPerInchY;    // Pixels per logical inch along height

	HDC hDCScreen = GetDC(NULL);
	ATLASSERT(hDCScreen != NULL);
	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);

	lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, nPixelsPerInchX);
	lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, nPixelsPerInchY);
}


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time 
#undef _ATLWIN_IMPL

#endif // _ATLWIN_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbi\mscordbi.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MSCorDBI.cpp
//
// COM+ Debugging Services -- Debugger Interface DLL
//
// Dll* routines for entry points, and support for COM framework.  
//
//*****************************************************************************
#include "stdafx.h"

extern BOOL STDMETHODCALLTYPE DbgDllMain(HINSTANCE hInstance, DWORD dwReason,
                                         LPVOID lpReserved);

//*****************************************************************************
// The main dll entry point for this module.  This routine is called by the
// OS when the dll gets loaded.  Control is simply deferred to the main code.
//*****************************************************************************
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	//@todo: Shoud we call DisableThreadLibraryCalls?  Or does this code
	//	need native thread attatch/detatch notifications?

	// Defer to the main debugging code.
    return DbgDllMain(hInstance, dwReason, lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mcxhndlr\atl\statreg.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Active Template Library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H
#define __STATREG_H

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

namespace ATL
{
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");

class CExpansionVector
{
public:
	//Declare EXPANDER struct.  Only used locally.
	struct EXPANDER
	{
		LPOLESTR    szKey;
		LPOLESTR    szValue;
	};

	CExpansionVector()
	{
		m_cEls = 0;
		m_nSize=10;
		m_p = (EXPANDER**)malloc(m_nSize*sizeof(EXPANDER*));
	}
	~CExpansionVector()
	{
		 free(m_p);
	}
	HRESULT Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue)
	{
		USES_CONVERSION;
		HRESULT hr = S_OK;

		EXPANDER* pExpand = NULL;
		ATLTRY(pExpand = new EXPANDER);
		if (pExpand == NULL)
			return E_OUTOFMEMORY;

		DWORD cbKey = (ocslen(lpszKey)+1)*sizeof(OLECHAR);
		DWORD cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);
		pExpand->szKey = (LPOLESTR)CoTaskMemAlloc(cbKey);
		pExpand->szValue = (LPOLESTR)CoTaskMemAlloc(cbValue);
		if (pExpand->szKey == NULL || pExpand->szValue == NULL)
		{
			CoTaskMemFree(pExpand->szKey);
			CoTaskMemFree(pExpand->szValue);
			delete pExpand;
			return E_OUTOFMEMORY;
		}
		memcpy(pExpand->szKey, lpszKey, cbKey);
		memcpy(pExpand->szValue, lpszValue, cbValue);

		if (m_cEls == m_nSize)
		{
			m_nSize*=2;
			m_p = (EXPANDER**)realloc(m_p, m_nSize*sizeof(EXPANDER*));
		}

		if (NULL != m_p)
		{
			m_p[m_cEls] = pExpand;
			m_cEls++;
		}
		else
			hr = E_OUTOFMEMORY;

		return hr;

	}
	LPCOLESTR Find(LPTSTR lpszKey)
	{
		USES_CONVERSION;
		for (int iExpand = 0; iExpand < m_cEls; iExpand++)
		{
			if (!lstrcmpi(OLE2T(m_p[iExpand]->szKey), lpszKey)) //are equal
				return m_p[iExpand]->szValue;
		}
		return NULL;
	}
	HRESULT ClearReplacements()
	{
		for (int iExpand = 0; iExpand < m_cEls; iExpand++)
		{
			EXPANDER* pExp = m_p[iExpand];
			CoTaskMemFree(pExp->szValue);
			CoTaskMemFree(pExp->szKey);
			delete pExp;
		}
		m_cEls = 0;
		return S_OK;
	}

private:
	EXPANDER** m_p;
	int m_cEls;
	int m_nSize;
};

class CRegObject;

class CRegParser
{
public:
	CRegParser(CRegObject* pRegObj);

	HRESULT  PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg);
	HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

	void    SkipWhiteSpace();
	HRESULT NextToken(LPTSTR szToken);
	HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken);
	BOOL    CanForceRemoveKey(LPCTSTR szKey);
	BOOL    HasSubKeys(HKEY hkey);
	BOOL    HasValues(HKEY hkey);
	HRESULT RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
	BOOL    IsSpace(TCHAR ch);
	LPTSTR  m_pchCur;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}
	HRESULT HandleReplacements(LPTSTR& szToken);
	HRESULT SkipAssignment(LPTSTR szToken);

	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }
	static LPTSTR StrChr(LPTSTR lpsz, TCHAR ch);
	static HKEY HKeyFromString(LPTSTR szToken);
	static BYTE ChToByte(const TCHAR ch);
	static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt);
	static LPCTSTR rgszNeverDelete[];
	static const int cbNeverDelete;
	static const int MAX_VALUE;
	static const int MAX_TYPE;
	class CParseBuffer
	{
	public:
		int nPos;
		int nSize;
		LPTSTR p;
		CParseBuffer(int nInitial)
		{
			nPos = 0;
			nSize = nInitial;
			p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
		}
		~CParseBuffer()
		{
			CoTaskMemFree(p);
		}
		BOOL AddChar(const TCHAR* pch)
		{
			if (nPos == nSize) // realloc
			{
				nSize *= 2;
				p = (LPTSTR) CoTaskMemRealloc(p, nSize*sizeof(TCHAR));
			}
			p[nPos++] = *pch;
#ifndef _UNICODE
			if (IsDBCSLeadByte(*pch))
				p[nPos++] = *(pch + 1);
#endif
			return TRUE;
		}
		BOOL AddString(LPCOLESTR lpsz)
		{
			USES_CONVERSION;
			LPCTSTR lpszT = OLE2CT(lpsz);
			while (*lpszT)
			{
				AddChar(lpszT);
				lpszT++;
			}
			return TRUE;
		}
		LPTSTR Detach()
		{
			LPTSTR lp = p;
			p = NULL;
			return lp;
		}

	};
};

#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject
 : public IRegistrar
#else
class CRegObject
#endif
{
public:

	~CRegObject(){ClearReplacements();}
	HRESULT FinalConstruct() {return S_OK;}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, TRUE);
	}

	HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, FALSE);
	}

	HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, TRUE);
	}

	HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, FALSE);
	}

protected:

	HRESULT CommonFileRegister(LPCOLESTR pszFileName, BOOL bRegister);
	HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
	HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);

	static HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

	CExpansionVector                                m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};

inline HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.Add(lpszKey, lpszItem);
	m_csMap.Unlock();
	return hr;
}

inline HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
										 LPCTSTR szType, BOOL bRegister)
{
	USES_CONVERSION;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	LPTSTR      szReg;

	hInstResDll = LoadLibraryEx(OLE2CT(bstrFileName), NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), OLE2CT(bstrFileName));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		ATLTRACE2(atlTraceRegistrar, 0, (HIWORD(szID) == NULL) ? 
			_T("Failed to FindResource on ID:%d TYPE:%s\n") : 
			_T("Failed to FindResource on ID:%s TYPE:%s\n"), 
			szID, szType);
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadResource \n"));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;
	if (szRegA[dwSize] != NULL)
	{
		szRegA = (LPSTR)_alloca(dwSize+1);
		memcpy(szRegA, (void*)hReg, dwSize+1);
		szRegA[dwSize] = NULL;
	}

	szReg = A2T(szRegA);

	hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;
	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), FALSE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), FALSE);
}

inline HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
	USES_CONVERSION;
	CRegParser  parser(this);


	LPCTSTR szReg = OLE2CT(bstrData);

	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

	return hr;
}

inline HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


inline LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Find(lpszKey);
	if (lpsz == NULL) // not found!!
		ATLTRACE2(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
	m_csMap.Unlock();
	return lpsz;
}

inline HRESULT CRegObject::CommonFileRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
	USES_CONVERSION;

	CRegParser  parser(this);

	HANDLE hFile = CreateFile(OLE2CT(bstrFileName), GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to CreateFile on %s\n"), OLE2CT(bstrFileName));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	HRESULT hRes = S_OK;
	DWORD cbRead;
	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required
       if (cbFile == INVALID_FILE_SIZE)  { 
       	ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to GetFileSize on %s\n"), OLE2CT(bstrFileName));
       	return HRESULT_FROM_WIN32(GetLastError());
       }
	
	char* szReg = (char*)_alloca(cbFile + 1);
	if (ReadFile(hFile, szReg, cbFile, &cbRead, NULL) == 0)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Read Failed on file%s\n"), OLE2CT(bstrFileName));
		hRes =  HRESULT_FROM_WIN32(GetLastError());
	}
	if (SUCCEEDED(hRes))
	{
		szReg[cbRead] = NULL;
		LPTSTR szConverted = A2T(szReg);
		hRes = parser.RegisterBuffer(szConverted, bRegister);
	}
	CloseHandle(hFile);
	return hRes;
}

__declspec(selectany) LPCTSTR CRegParser::rgszNeverDelete[] = //Component Catagories
{
	_T("CLSID"), _T("TYPELIB")
};

__declspec(selectany) const int CRegParser::cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);
__declspec(selectany) const int CRegParser::MAX_VALUE=4096;
__declspec(selectany) const int CRegParser::MAX_TYPE=MAX_VALUE;


inline BOOL CRegParser::VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{szDwordVal,  VT_UI4},
		{szBinaryVal, VT_UI1}
	};

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;

}

inline BYTE CRegParser::ChToByte(const TCHAR ch)
{
	switch (ch)
	{
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
				return (BYTE) (ch - '0');
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
				return (BYTE) (10 + (ch - 'A'));
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
				return (BYTE) (10 + (ch - 'a'));
		default:
				ATLASSERT(FALSE);
				ATLTRACE2(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
				return 0;
	}
}

inline HKEY CRegParser::HKeyFromString(LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

inline LPTSTR CRegParser::StrChr(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

inline CRegParser::CRegParser(CRegObject* pRegObj)
{
	m_pRegObj           = pRegObj;
	m_pchCur            = NULL;
}

inline BOOL CRegParser::IsSpace(TCHAR ch)
{
	switch (ch)
	{
		case _T(' '):
		case _T('\t'):
		case _T('\r'):
		case _T('\n'):
				return TRUE;
	}

	return FALSE;
}

inline void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		m_pchCur = CharNext(m_pchCur);
}

inline HRESULT CRegParser::NextToken(LPTSTR szToken)
{
	USES_CONVERSION;

	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (NULL == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);

	// handle quoted value / key
	if (chQuote == *m_pchCur)
	{
		LPCTSTR szOrig = szToken;

		m_pchCur = CharNext(m_pchCur);

		while (NULL != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				m_pchCur = CharNext(m_pchCur);

			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);

			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		if (NULL == *m_pchCur)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = NULL;
		m_pchCur = CharNext(m_pchCur);
	}

	else
	{   // Handle non-quoted ie parse up till first "White Space"
		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		*szToken = NULL;
	}
	return S_OK;
}

inline HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken)
{
	USES_CONVERSION;
	HRESULT hr;

	TCHAR       szTypeToken[MAX_TYPE];
	VARTYPE     vt;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	if (FAILED(hr = NextToken(szTypeToken)))
		return hr;
	if (!VTFromRegType(szTypeToken, vt))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szTypeToken);
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

	TCHAR szValue[MAX_VALUE];
	SkipWhiteSpace();
	if (FAILED(hr = NextToken(szValue)))
		return hr;
	ULONG ulVal;

	switch (vt)
	{
	case VT_BSTR:
		lRes = rkParent.SetValue(szValue, szValueName);
		ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
		break;
	case VT_UI4:
		VarUI4FromStr(T2OLE(szValue), 0, 0, &ulVal);
		lRes = rkParent.SetValue(ulVal, szValueName);
		ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);
		break;
	case VT_UI1:
		{
			int cbValue = lstrlen(szValue);
			if (cbValue & 0x00000001)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			BYTE* rgBinary = (BYTE*)_alloca(cbValDiv2*sizeof(BYTE));
			memset(rgBinary, 0, cbValDiv2);
			if (rgBinary == NULL)
				return E_FAIL;
			for (int irg = 0; irg < cbValue; irg++)
				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));
			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);
			break;
		}
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		hr = HRESULT_FROM_WIN32(lRes);
	}

	if (FAILED(hr = NextToken(szToken)))
		return hr;

	return S_OK;
}

inline BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

inline BOOL CRegParser::HasSubKeys(HKEY hkey)
{
	DWORD       cbSubKeys = 0;

	if (FAILED(RegQueryInfoKey(hkey, NULL, NULL, NULL,
							   &cbSubKeys, NULL, NULL,
							   NULL, NULL, NULL, NULL, NULL)))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
		ATLASSERT(FALSE);
		return FALSE;
	}

	return cbSubKeys > 0;
}

inline BOOL CRegParser::HasValues(HKEY hkey)
{
	DWORD       cbValues = 0;

	LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL,
								  NULL, NULL, NULL,
								  &cbValues, NULL, NULL, NULL, NULL);
	if (ERROR_SUCCESS != lResult)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("RegQueryInfoKey Failed "));
		ATLASSERT(FALSE);
		return FALSE;
	}

	if (1 == cbValues)
	{
		DWORD cbMaxName= MAX_VALUE;
		TCHAR szValueName[MAX_VALUE];
		// Check to see if the Value is default or named
		lResult = RegEnumValue(hkey, 0, szValueName, &cbMaxName, NULL, NULL, NULL, NULL);
		if (ERROR_SUCCESS == lResult && (szValueName[0] != NULL))
			return TRUE; // Named Value means we have a value
		return FALSE;
	}

	return cbValues > 0; // More than 1 means we have a non-default value
}

inline HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		if (FAILED(hr = NextToken(szToken)))
			return hr;
		// Skip assignment
		SkipWhiteSpace();
		if (FAILED(hr = NextToken(szValue)))
			return hr;
		if (FAILED(hr = NextToken(szToken)))
			return hr;
	}

	return S_OK;
}

inline HRESULT CRegParser::PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg)
{
	USES_CONVERSION;
	ATLASSERT(lpszReg != NULL);
	ATLASSERT(ppszReg != NULL);
	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg)*2;
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	m_pchCur = lpszReg;
	HRESULT hr = S_OK;

	while (*m_pchCur != NULL) // look for end
	{
		if (*m_pchCur == _T('%'))
		{
			m_pchCur = CharNext(m_pchCur);
			if (*m_pchCur == _T('%'))
				pb.AddChar(m_pchCur);
			else
			{
				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					ATLTRACE2(atlTraceRegistrar, 0, _T("Error no closing % found\n"));
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}
				int nLength = lpszNext - m_pchCur;
				if (nLength > 31)
				{
					hr = E_FAIL;
					break;
				}
				TCHAR buf[32];
				lstrcpyn(buf, m_pchCur, nLength+1);
				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				pb.AddString(lpszVar);
				while (m_pchCur != lpszNext)
					m_pchCur = CharNext(m_pchCur);
			}
		}
		else
			pb.AddChar(m_pchCur);
		m_pchCur = CharNext(m_pchCur);
	}
	pb.AddChar(m_pchCur);
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}

inline HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

#ifdef _DEBUG
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	m_pchCur = szReg;

	// Preprocess szReg

	while (NULL != *m_pchCur)
	{
		if (FAILED(hr = NextToken(szToken)))
			break;
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		if (FAILED(hr = NextToken(szToken)))
			break;

		if (chLeftBracket != *szToken)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(szToken, hkBase, bRegister);
			if (FAILED(hr))
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(szToken, hkBase, FALSE);
				break;
			}
		}
		else
		{
			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))
				break;
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

inline HRESULT CRegParser::RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
	CRegKey keyCur;
	LONG    lRes;
	LPTSTR  szKey = NULL;
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	ATLTRACE2(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
	if (FAILED(hr = NextToken(szToken)))
		return hr;


	while (*szToken != chRightBracket) // Continue till we see a }
	{
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
		{
			if (FAILED(hr = NextToken(szToken)))
				break;

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
					return GenerateError(E_ATL_COMPOUND_KEY);

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}
				if (bTokenDelete)
				{
					if (FAILED(hr = NextToken(szToken)))
						break;
					if (FAILED(hr = SkipAssignment(szToken)))
						break;
					goto EndCheck;
				}
			}

		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			if (FAILED(hr = NextToken(szToken)))
				break;
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[_MAX_PATH];

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
					return hr;

				goto EndCheck;
			}
			else
			{
				if (!bRecover)
				{
					ATLTRACE2(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);
					CRegKey rkParent;
					rkParent.Attach(hkParent);
					rkParent.DeleteValue(szValueName);
					rkParent.Detach();
				}

				if (FAILED(hr = SkipAssignment(szToken)))
					break;
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
			return GenerateError(E_ATL_COMPOUND_KEY);

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_ALL_ACCESS);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					ATLTRACE2(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);
					lRes = keyCur.Create(hkParent, szToken);
					if (ERROR_SUCCESS != lRes)
						return GenerateError(E_ATL_CREATE_KEY_FAILED);
				}
			}

			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken == chEquals)
			{
				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default
					break;
			}
		}
		else
		{
			if (!bRecover && keyCur.Open(hkParent, szToken, KEY_READ) != ERROR_SUCCESS)
				bRecover = TRUE;

			// TRACE out Key open status and if in recovery mode
#ifdef _DEBUG
			if (!bRecover)
				ATLTRACE2(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);
			else
				ATLTRACE2(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#endif //_DEBUG

			// Remember Subkey
			if (szKey == NULL)
				szKey = (LPTSTR)_alloca(sizeof(TCHAR)*_MAX_PATH);
			lstrcpyn(szKey, szToken, _MAX_PATH);

			// If in recovery mode

			if (bRecover || HasSubKeys(keyCur) || HasValues(keyCur))
			{
				if (FAILED(hr = NextToken(szToken)))
					break;
				if (FAILED(hr = SkipAssignment(szToken)))
					break;


				if (*szToken == chLeftBracket)
				{
					if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover)))
						break;
					if (bRecover) // Turn off recovery if we are done
					{
						bRecover = bInRecovery;
						ATLTRACE2(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
						if (FAILED(hr = NextToken(szToken)))
							break;
						if (FAILED(hr = SkipAssignment(szToken)))
							break;
						continue;
					}
				}

				if (!bRecover && HasSubKeys(keyCur))
				{
					// See if the KEY is in the NeverDelete list and if so, don't
					if (CanForceRemoveKey(szKey))
					{
						ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);
						keyCur.RecurseDeleteKey(szKey);
					}
					if (FAILED(hr = NextToken(szToken)))
						break;
					continue;
				}

				if (bRecover)
					continue;
			}

			if (!bRecover && keyCur.Close() != ERROR_SUCCESS)
			   return GenerateError(E_ATL_CLOSE_KEY_FAILED);

			if (!bRecover && bDelete)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);
				CRegKey rkParent;
				rkParent.Attach(hkParent);
				rkParent.DeleteSubKey(szKey);
				rkParent.Detach();
			}

			if (FAILED(hr = NextToken(szToken)))
				break;
			if (FAILED(hr = SkipAssignment(szToken)))
				break;
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
			{
				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))
					break;
				if (FAILED(hr = NextToken(szToken)))
					break;
			}
		}
	}

	return hr;
}

}; //namespace ATL

#endif //__STATREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoree\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbi\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORDBI.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Debugging Services\0"
#define VER_ORIGFILENAME_STR    "mscordbi.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscordbi\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#include "winwrap.h"                    // Windows wrappers.
#include "utilcode.h"					// Helper code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoree\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#ifdef SERVER_GC
#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORSVR.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Common Language Runtime - Server\0"
#define VER_ORIGFILENAME_STR    "mscorsvr.dll\0"
#else
#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORWKS.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Common Language Runtime - WorkStation\0"
#define VER_ORIGFILENAME_STR    "mscorwks.dll\0"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoree\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#include <CrtWrap.h>
#include <winwrap.h>                    // Windows wrappers.

#include <ole2.h>						// OLE definitions
#include "oledb.h"						// OLE DB headers.
#include "oledberr.h"					// OLE DB Error messages.
#include "msdadc.h"						// Data type conversion service.

#define _COMPLIB_GUIDS_


#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED
#undef _WINGDI_


#include "Intrinsic.h"					// Functions to make intrinsic.


// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoree\mscoree.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MSCoree.cpp
//
// This small piece of code is used to load the Component Dictionary code in
// a way that is accessible from VB and other languages.  In addition, it
// uses the path name of the .dll from the registry because the Windows
// PE loader does not complete the path name used on load.  This means a 
// relative load of ".\foo.dll" and "c:\foo.dll" when they are the same file
// actually loads to copies of the code into memory.  Given the split usage
// of implib and CoCreateInstance, this is really bad.
//
// Note: This module is written in ANSI on purpose so that Win95 works with
// any wrapper functions.
//
//*****************************************************************************
#include "stdafx.h"                     // Standard header.

#include <UtilCode.h>                   // Utility helpers.
#include <PostError.h>                  // Error handlers
#define INIT_GUIDS  
#include <CorPriv.h>
#include <winwrap.h>
#include <InternalDebug.h>
#include <mscoree.h>
#include "ShimLoad.h"


class Thread;
Thread* SetupThread();


// For free-threaded marshaling, we must not be spoofed by out-of-process marshal data.
// Only unmarshal data that comes from our own process.
extern BYTE         g_UnmarshalSecret[sizeof(GUID)];
extern bool         g_fInitedUnmarshalSecret;


//DEFINE_GUID(IID_IFoo,0x0EAC4842L,0x8763,0x11CF,0xA7,0x43,0x00,0xAA,0x00,0xA3,0xF0,0x0D);
// Locals.
BOOL STDMETHODCALLTYPE EEDllMain( // TRUE on success, FALSE on error.
                       HINSTANCE    hInst,                  // Instance handle of the loaded module.
                       DWORD        dwReason,               // Reason for loading.
                       LPVOID       lpReserved);                // Unused.


// try to load a com+ class and give out an IClassFactory
HRESULT STDMETHODCALLTYPE EEDllGetClassObject(
                            REFCLSID rclsid,
                            REFIID riid,
                            LPVOID FAR *ppv);

HRESULT STDMETHODCALLTYPE EEDllCanUnloadNow(void);

HRESULT STDMETHODCALLTYPE CreateICorModule(REFIID riid, void **pCorModule); // instantiate an ICorModule interface
HRESULT STDMETHODCALLTYPE CreateICeeGen(REFIID riid, void **pCeeGen); // instantiate an ICeeGen interface

// Meta data startup/shutdown routines.
void  InitMd();
void  UninitMd();
STDAPI  MetaDataDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
STDAPI  MetaDataDllRegisterServerEx(HINSTANCE);
STDAPI  MetaDataDllUnregisterServer();
STDAPI  GetMDInternalInterface(
    LPVOID      pData, 
    ULONG       cbData, 
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnk);              // [out] Return interface on success.
STDAPI GetMDInternalInterfaceFromPublic(
    void        *pIUnkPublic,           // [IN] Given scope.
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnkInternal);      // [out] Return interface on success.
STDAPI GetMDPublicInterfaceFromInternal(
    void        *pIUnkPublic,           // [IN] Given scope.
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnkInternal);      // [out] Return interface on success.
STDAPI MDReOpenMetaDataWithMemory(
    void        *pImport,               // [IN] Given scope. public interfaces
    LPCVOID     pData,                  // [in] Location of scope data.
    ULONG       cbData);                // [in] Size of the data pointed to by pData.


HRESULT _GetCeeGen(REFIID riid, void** ppv);
void _FreeCeeGen();

extern HRESULT GetJPSPtr(bool bAllocate);


// Class used to unmarshal all com call wrapper IPs.
class ComCallUnmarshal : public IMarshal
{
public:

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID iid, void **ppv) {
        if (!ppv)
            return E_POINTER;

        *ppv = NULL;
        if (iid == IID_IUnknown) {
            *ppv = (IUnknown *)this;
            AddRef();
        } else if (iid == IID_IMarshal) {
            *ppv = (IMarshal *)this;
            AddRef();
        }
        return (*ppv != NULL) ? S_OK : E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef(void) {
        return 2; 
    }

    STDMETHODIMP_(ULONG) Release(void) {
        return 1;
    }

    // *** IMarshal methods ***
    STDMETHODIMP GetUnmarshalClass (REFIID riid, void * pv, ULONG dwDestContext, 
                                    void * pvDestContext, ULONG mshlflags, 
                                    LPCLSID pclsid) {
        // Marshal side only.
        _ASSERTE(FALSE);
        return E_NOTIMPL;
    }

    STDMETHODIMP GetMarshalSizeMax (REFIID riid, void * pv, ULONG dwDestContext, 
                                    void * pvDestContext, ULONG mshlflags, 
                                    ULONG * pSize) {
        // Marshal side only.
        _ASSERTE(FALSE);
        return E_NOTIMPL;
    }

    STDMETHODIMP MarshalInterface (LPSTREAM pStm, REFIID riid, void * pv,
                                   ULONG dwDestContext, LPVOID pvDestContext,
                                   ULONG mshlflags) {
        // Marshal side only.
        _ASSERTE(FALSE);
        return E_NOTIMPL;
    }

    STDMETHODIMP UnmarshalInterface (LPSTREAM pStm, REFIID riid, 
                                     void ** ppvObj) {
        ULONG bytesRead;
        ULONG mshlflags;
        HRESULT hr;

        // The marshal code added a reference to the object, but we return a
        // reference to the object as well, so don't change the ref count on the
        // success path. Need to release on error paths though (if we manage to
        // retrieve the IP, that is). If the interface was marshalled
        // TABLESTRONG or TABLEWEAK, there is going to be a ReleaseMarshalData
        // in the future, so we should AddRef the IP we're about to give out.
        // Note also that OLE32 requires us to advance the stream pointer even
        // in failure cases, hence the order of the stream read and SetupThread.

        // Read the raw IP out of the marshalling stream.
        hr = pStm->Read (ppvObj, sizeof (void *), &bytesRead);
        if (FAILED (hr) || (bytesRead != sizeof (void *)))
            return RPC_E_INVALID_DATA;

        // And then the marshal flags.
        hr = pStm->Read (&mshlflags, sizeof (void *), &bytesRead);
        if (FAILED (hr) || (bytesRead != sizeof (ULONG)))
            return RPC_E_INVALID_DATA;

        // And then verify our secret, to be sure that out-of-process clients aren't
        // trying to trick us into mis-interpreting their data as a ppvObj.  Note that
        // it is guaranteed that the secret data is initialized, or else we certainly
        // haven't written it into this buffer!
        if (!g_fInitedUnmarshalSecret)
            return E_UNEXPECTED;

        BYTE secret[sizeof(GUID)];

        hr = pStm->Read(secret, sizeof(secret), &bytesRead);
        if (FAILED(hr) || (bytesRead != sizeof(secret)))
            return RPC_E_INVALID_DATA;

        if (memcmp(g_UnmarshalSecret, secret, sizeof(secret)) != 0)
            return E_UNEXPECTED;

        // Setup logical thread if we've not already done so.
        Thread* pThread = SetupThread();
        if (pThread == NULL) {
            ((IUnknown *)*ppvObj)->Release ();
            return E_OUTOFMEMORY;
        }

        if (ppvObj && ((mshlflags == MSHLFLAGS_TABLESTRONG) || (mshlflags == MSHLFLAGS_TABLEWEAK)))
            // For table access we can just QI for the correct interface (this
            // will addref the IP, but that's OK since we need to keep an extra
            // ref on the IP until ReleaseMarshalData is called).
            hr = ((IUnknown *)*ppvObj)->QueryInterface(riid, ppvObj);
        else {
            // For normal access we QI for the correct interface then release
            // the old IP.
            IUnknown *pOldUnk = (IUnknown *)*ppvObj;
            hr = pOldUnk->QueryInterface(riid, ppvObj);
            pOldUnk->Release();
        }

        return hr;
    }

    STDMETHODIMP ReleaseMarshalData (LPSTREAM pStm) {
        IUnknown *pUnk;
        ULONG bytesRead;
        ULONG mshlflags;
        HRESULT hr;

        if (!pStm)
            return E_POINTER;

        // Read the raw IP out of the marshalling stream. Do this first since we
        // need to update the stream pointer even in case of failures.
        hr = pStm->Read (&pUnk, sizeof (pUnk), &bytesRead);
        if (FAILED (hr) || (bytesRead != sizeof (pUnk)))
            return RPC_E_INVALID_DATA;

        // Now read the marshal flags.
        hr = pStm->Read (&mshlflags, sizeof (mshlflags), &bytesRead);
        if (FAILED (hr) || (bytesRead != sizeof (mshlflags)))
            return RPC_E_INVALID_DATA;

        if (!g_fInitedUnmarshalSecret)
            return E_UNEXPECTED;

        BYTE secret[sizeof(GUID)];

        hr = pStm->Read(secret, sizeof(secret), &bytesRead);
        if (FAILED(hr) || (bytesRead != sizeof(secret)))
            return RPC_E_INVALID_DATA;

        if (memcmp(g_UnmarshalSecret, secret, sizeof(secret)) != 0)
            return E_UNEXPECTED;

        pUnk->Release ();

        // Setup logical thread if we've not already done so.
        Thread* pThread = SetupThread();
        if (pThread == NULL)
            return E_OUTOFMEMORY;

        return S_OK;
    }

    STDMETHODIMP DisconnectObject (ULONG dwReserved) {
        // Setup logical thread if we've not already done so.
        Thread* pThread = SetupThread();
        if (pThread == NULL)
            return E_OUTOFMEMORY;

        // Nothing we can (or need to) do here. The client is using a raw IP to
        // access this server, so the server shouldn't go away until the client
        // Release()'s it.

        return S_OK;
    }


};


// Class factory for the com call wrapper unmarshaller.
class CComCallUnmarshalFactory : public IClassFactory
{
    ULONG               m_cbRefCount;
    ComCallUnmarshal    m_Unmarshaller;

  public:

    CComCallUnmarshalFactory() {
        m_cbRefCount = 1;
    }

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID iid, void **ppv) {
        if (!ppv)
            return E_POINTER;

        *ppv = NULL;
        if (iid == IID_IClassFactory || iid == IID_IUnknown) {
            *ppv = (IClassFactory *)this;
            AddRef();
        }
        return (*ppv != NULL) ? S_OK : E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef(void) {
        return 2; 
    }

    STDMETHODIMP_(ULONG) Release(void) {
        return 1;
    }

    // *** IClassFactory methods ***
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID iid, LPVOID FAR *ppv) {
        if (!ppv)
            return E_POINTER;

        *ppv = NULL;

        if (punkOuter != NULL)
            return CLASS_E_NOAGGREGATION;

        return m_Unmarshaller.QueryInterface(iid, ppv);
    }

    STDMETHODIMP LockServer(BOOL fLock) {
        return S_OK;
    }
};


// Buffer-overrun protection

#ifdef _X86_

extern void FatalInternalError();

void __cdecl CallFatalInternalError()
{
    FatalInternalError(); // Abort the process the EE-way
}

extern "C" {
    typedef void (__cdecl failure_report_function)(void);
    failure_report_function * __cdecl _set_security_error_handler(failure_report_function*);
}

void SetBufferOverrunHandler()
{
    failure_report_function * fOldHandler = _set_security_error_handler(&CallFatalInternalError);

    // If there was already a handler installed, don't overwrite it.
    if (fOldHandler != NULL)
    {
        _set_security_error_handler(fOldHandler);
    }
}

#else

void SetBufferOverrunHandler() {}

#endif // _X86_


extern "C" {

// Forwards.
interface ICompLibrary;


// Globals.
HINSTANCE       g_hThisInst;            // This library.
long            g_cCorInitCount = -1;   // Ref counting for init code.
HINSTANCE       g_pPeWriterDll = NULL;  // PEWriter DLL
BOOL            g_fLoadedByMscoree = FALSE;  // True if this library was loaded by mscoree.dll

// @todo: this is just for m3 because our com interop cannot yet
// detect shut down reliably and the assert kills the process
// badly on Win 9x.

// ---------------------------------------------------------------------------
// Impl for LoadStringRC Callback: In VM, we let the thread decide culture
// Return an int uniquely describing which language this thread is using for ui.
// ---------------------------------------------------------------------------
static int GetThreadUICultureId()
{
	CoInitializeEE(0);
    FPGETTHREADUICULTUREID fpGetThreadUICultureId=NULL;
	GetResourceCultureCallbacks(
		NULL,
		& fpGetThreadUICultureId,
		NULL
	);
	return fpGetThreadUICultureId?fpGetThreadUICultureId():UICULTUREID_DONTCARE;
}
// ---------------------------------------------------------------------------
// Impl for LoadStringRC Callback: In VM, we let the thread decide culture
// copy culture name into szBuffer and return length
// ---------------------------------------------------------------------------
static int GetThreadUICultureName(LPWSTR szBuffer, int length)
{
	CoInitializeEE(0);
    FPGETTHREADUICULTURENAME fpGetThreadUICultureName=NULL;
	GetResourceCultureCallbacks(
		&fpGetThreadUICultureName,
		NULL,
		NULL
	);
	return fpGetThreadUICultureName?fpGetThreadUICultureName(szBuffer,length):0;
}

// ---------------------------------------------------------------------------
// Impl for LoadStringRC Callback: In VM, we let the thread decide culture
// copy culture name into szBuffer and return length
// ---------------------------------------------------------------------------
static int GetThreadUICultureParentName(LPWSTR szBuffer, int length)
{
	CoInitializeEE(0);
    FPGETTHREADUICULTUREPARENTNAME fpGetThreadUICultureParentName=NULL;
	GetResourceCultureCallbacks(
		NULL,
		NULL,
		&fpGetThreadUICultureParentName
	);
	return fpGetThreadUICultureParentName?fpGetThreadUICultureParentName(szBuffer,length):0;
}



//*****************************************************************************
// Handle lifetime of loaded library.
//*****************************************************************************
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        {
            // Save the module handle.
            g_hThisInst = (HMODULE)hInstance;
			SetResourceCultureCallbacks(
				GetThreadUICultureName,
				GetThreadUICultureId,
				GetThreadUICultureParentName
			);

            // Prevent buffer-overruns
            SetBufferOverrunHandler();

            // Init unicode wrappers.
            OnUnicodeSystem();

            if (!EEDllMain((HINSTANCE)hInstance, dwReason, NULL))
                return (FALSE);
    
            // Init the error system.
            InitErrors(0);
            InitMd();
       
            // Debug cleanup code.
            _DbgInit((HINSTANCE)hInstance);
        }
        break;

    case DLL_PROCESS_DETACH:
        {
            if (lpReserved) {
                if (g_fLoadedByMscoree) {
                    if (BeforeFusionShutdown()) {
                        DWORD lgth = _MAX_PATH + 11;
                        WCHAR wszFile[_MAX_PATH + 11];
                        if (SUCCEEDED(GetInternalSystemDirectory(wszFile, &lgth))) {
                            wcscpy(wszFile+lgth-1, L"Fusion.dll");
                            HMODULE hFusionDllMod = WszGetModuleHandle(wszFile);
                            if (hFusionDllMod) {
                                ReleaseFusionInterfaces();
                                
                                VOID (STDMETHODCALLTYPE * pRealFunc)();
                                *((VOID**)&pRealFunc) = GetProcAddress(hFusionDllMod, "ReleaseURTInterfaces");
                                if (pRealFunc) pRealFunc();
                            }
                        }
                    }
                }
                else {
                    _ASSERTE(!"Extra MsCorSvr/Wks dll loaded in process");
                    DontReleaseFusionInterfaces();
                }
            }

            EEDllMain((HINSTANCE)hInstance, dwReason, NULL);
    
            UninitErrors();
            UninitMd();
            _DbgUninit();
        }
        break;

    case DLL_THREAD_DETACH:
        {
            EEDllMain((HINSTANCE)hInstance, dwReason, NULL);
        }
        break;
    }


    return (true);
}


} // extern "C"


void SetLoadedByMscoree()
{
    g_fLoadedByMscoree = TRUE;
}


HINSTANCE GetModuleInst()
{
    return (g_hThisInst);
}

// %%Globals: ----------------------------------------------------------------

// ---------------------------------------------------------------------------
// %%Function: DllGetClassObject        %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Parameters:
//  rclsid                  - reference to the CLSID of the object whose
//                            ClassObject is being requested
//  iid                     - reference to the IID of the interface on the
//                            ClassObject that the caller wants to communicate
//                            with
//  ppv                     - location to return reference to the interface
//                            specified by iid
// 
// Returns:
//  S_OK                    - if successful, valid interface returned in *ppv,
//                            otherwise *ppv is set to NULL and one of the
//                            following errors is returned:
//  E_NOINTERFACE           - ClassObject doesn't support requested interface
//  CLASS_E_CLASSNOTAVAILABLE - clsid does not correspond to a supported class
// 
// Description:
//  Returns a reference to the iid interface on the main COR ClassObject.
//  This function is one of the required by-name entry points for COM
// DLL's. Its purpose is to provide a ClassObject which by definition
// supports at least IClassFactory and can therefore create instances of
// objects of the given class.
// 
// @TODO: CClassFactory temporarily supports down-level COM. Once
// Windows.Class exists, that object will support IClassFactoryX, it will
// be ref-counted, etc, and we will find/create it here in DllGetClassObject.
// ---------------------------------------------------------------------------
STDAPI DllGetClassObjectInternal(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR *ppv)
{
    static CComCallUnmarshalFactory cfuS;
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if (rclsid == CLSID_ComCallUnmarshal)
    {
        hr = cfuS.QueryInterface(riid, ppv);
    }
    else if (rclsid == CLSID_CorMetaDataDispenser || rclsid == CLSID_CorMetaDataDispenserRuntime ||
             rclsid == CLSID_CorRuntimeHost)//       || rclsid == CLSID_CorAssemblyMetaDataDispenser )
    {
        hr = MetaDataDllGetClassObject(rclsid, riid, ppv);
    }
    else
    {
        hr = EEDllGetClassObject(rclsid,riid,ppv);
    }

    return hr;
}  // DllGetClassObject

STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR *ppv)
{
  return E_FAIL;
}


// ---------------------------------------------------------------------------
// %%Function: DllCanUnloadNow          %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Returns:
//  S_FALSE                 - Indicating that COR, once loaded, may not be
//                            unloaded.
// ---------------------------------------------------------------------------
STDAPI DllCanUnloadNowInternal(void)
{
   // The Shim should be only be calling this. 
   return EEDllCanUnloadNow();
}  // DllCanUnloadNowInternal

// ---------------------------------------------------------------------------
// %%Function: DllRegisterServerInternal %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Description:
//  Registers
// ---------------------------------------------------------------------------
STDAPI DllRegisterServerInternal(HINSTANCE hMod, LPCWSTR version)
{
    HRESULT hr;
    WCHAR szModulePath[_MAX_PATH];

    if (!WszGetModuleFileName(hMod, szModulePath, _MAX_PATH))
        return E_UNEXPECTED;
    
    // Get the version of the runtime
    WCHAR       rcVersion[_MAX_PATH];
    DWORD       lgth;
    IfFailRet(GetCORSystemDirectory(rcVersion, NumItems(rcVersion), &lgth));

    IfFailRet(REGUTIL::RegisterCOMClass(CLSID_ComCallUnmarshal,
                                        L"Com Call Wrapper Unmarshal Class",
                                        L"CCWU",
                                        1,
                                        L"ComCallWrapper",
                                        L"Both",
                                        szModulePath,
                                        hMod,
                                        NULL,
                                        rcVersion,
                                        false,
                                        false));

    return MetaDataDllRegisterServerEx(hMod);
}  // DllRegisterServer


// ---------------------------------------------------------------------------
// %%Function: DllRegisterServer        %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Description:
//  Registers
// ---------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
  //The shim should be handling this. Do nothing here
  //  return DllRegisterServerInternal(GetModuleInst());
  return E_FAIL;
}

// ---------------------------------------------------------------------------
// %%Function: DllUnregisterServer      %%Owner: NatBro   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
STDAPI DllUnregisterServerInternal(void)
{
    HRESULT hr;

    if (FAILED(hr = REGUTIL::UnregisterCOMClass(CLSID_ComCallUnmarshal,
                                                L"CCWU",
                                                1,
                                                L"ComCallWrapper",
                                                false)))
        return hr;

    return MetaDataDllUnregisterServer();
}  // DllUnregisterServer

// ---------------------------------------------------------------------------
// %%Function: MetaDataGetDispenser
// This function gets the Dispenser interface given the CLSID and REFIID.
// ---------------------------------------------------------------------------
STDAPI MetaDataGetDispenser(            // Return HRESULT
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    IClassFactory *pcf = NULL;
    HRESULT hr;

    hr = MetaDataDllGetClassObject(rclsid, IID_IClassFactory, (void **) &pcf);
    if (FAILED(hr)) 
        return (hr);

    hr = pcf->CreateInstance(NULL, riid, ppv);
    pcf->Release();

    return (hr);
}


// ---------------------------------------------------------------------------
// %%Function: GetMetaDataInternalInterface
// This function gets the IMDInternalImport given the metadata on memory.
// ---------------------------------------------------------------------------
STDAPI  GetMetaDataInternalInterface(
    LPVOID      pData,                  // [IN] in memory metadata section
    ULONG       cbData,                 // [IN] size of the metadata section
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [IN] desired interface
    void        **ppv)                  // [OUT] returned interface
{
    return GetMDInternalInterface(pData, cbData, flags, riid, ppv);
}

// ---------------------------------------------------------------------------
// %%Function: GetMetaDataInternalInterfaceFromPublic
// This function gets the internal scopeless interface given the public
// scopeless interface.
// ---------------------------------------------------------------------------
STDAPI  GetMetaDataInternalInterfaceFromPublic(
    void        *pv,                    // [IN] Given interface.
    REFIID      riid,                   // [IN] desired interface
    void        **ppv)                  // [OUT] returned interface
{
    return GetMDInternalInterfaceFromPublic(pv, riid, ppv);
}

// ---------------------------------------------------------------------------
// %%Function: GetMetaDataPublicInterfaceFromInternal
// This function gets the public scopeless interface given the internal
// scopeless interface.
// ---------------------------------------------------------------------------
STDAPI  GetMetaDataPublicInterfaceFromInternal(
    void        *pv,                    // [IN] Given interface.
    REFIID      riid,                   // [IN] desired interface.
    void        **ppv)                  // [OUT] returned interface
{
    return GetMDPublicInterfaceFromInternal(pv, riid, ppv);
}


// ---------------------------------------------------------------------------
// %%Function: ReopenMetaDataWithMemory
// This function gets the public scopeless interface given the internal
// scopeless interface.
// ---------------------------------------------------------------------------
STDAPI ReOpenMetaDataWithMemory(
    void        *pUnk,                  // [IN] Given scope. public interfaces
    LPCVOID     pData,                  // [in] Location of scope data.
    ULONG       cbData)                 // [in] Size of the data pointed to by pData.
{
    return MDReOpenMetaDataWithMemory(pUnk, pData, cbData);
}

// ---------------------------------------------------------------------------
// %%Function: GetAssemblyMDImport
// This function gets the IMDAssemblyImport given the filename
// ---------------------------------------------------------------------------
STDAPI GetAssemblyMDImport(             // Return code.
    LPCWSTR     szFileName,             // [in] The scope to open.
    REFIID      riid,                   // [in] The interface desired.
    IUnknown    **ppIUnk)               // [out] Return interface on success.
{
    return GetAssemblyMDInternalImport(szFileName, riid, ppIUnk);
}

// ---------------------------------------------------------------------------
// %%Function: CoInitializeCor
// 
// Parameters:
//  fFlags                  - Initialization flags for the engine.  See the
//                              COINITICOR enumerator for valid values.
// 
// Returns:
//  S_OK                    - On success
// 
// Description:
//  Reserved to initialize the Cor runtime engine explicitly.  Right now most
//  work is actually done inside the DllMain.
// ---------------------------------------------------------------------------
STDAPI          CoInitializeCor(DWORD fFlags)
{
    InterlockedIncrement(&g_cCorInitCount);
    return (S_OK);
}


// ---------------------------------------------------------------------------
// %%Function: CoUninitializeCor
// 
// Parameters:
//  none
// 
// Returns:
//  Nothing
// 
// Description:
//  Must be called by client on shut down in order to free up the system.
// ---------------------------------------------------------------------------
STDAPI_(void)   CoUninitializeCor(void)
{
    // Last one out shuts off the lights.
    if (InterlockedDecrement(&g_cCorInitCount) < 0)
    {
        // Free the JPS dll if loaded.  There must be no references when this is
        // done or else the jps.dll could get unloaded first and then freeing would
        // cause an exception.
        _FreeCeeGen();
    }
}


HRESULT _GetCeeGen(REFIID riid, void** ppv)
{
    if (!ppv)
        return E_POINTER;

    HRESULT hr = CreateICorModule(riid, ppv);
    if (SUCCEEDED(hr))
        return hr;
    hr = CreateICeeGen(riid, ppv);
    if (SUCCEEDED(hr))
        return hr;
    typedef HRESULT (*CreateICeeGenWriterFpType)(REFIID, void **);
    CreateICeeGenWriterFpType pProcAddr = NULL;
    if (! g_pPeWriterDll){
        DWORD lgth = _MAX_PATH + 12;
        WCHAR wszFile[_MAX_PATH + 12];
        hr = GetInternalSystemDirectory(wszFile, &lgth);
        if(FAILED(hr)) return hr;

        wcscpy(wszFile+lgth-1, L"mscorpe.dll");
        g_pPeWriterDll = WszLoadLibrary(wszFile);
    }
    if (g_pPeWriterDll) {
        pProcAddr = (CreateICeeGenWriterFpType)GetProcAddress(g_pPeWriterDll, "CreateICeeGenWriter");
        if (pProcAddr) {
            hr = pProcAddr(riid, ppv);
            if (SUCCEEDED(hr))
                return hr;
        }
    }
    return E_NOINTERFACE;
}

void _FreeCeeGen()
{
    if (g_pPeWriterDll)
    {
        FreeLibrary(g_pPeWriterDll);
        g_pPeWriterDll = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoree\sources.inc ===
#
# COR build instructions for this directory
#
#                               Bob Atkinson
#                               April 1997
SYNCHRONIZE_DRAIN=1
SYNCHRONIZE_BLOCK=1

NO_CRT                                  = 1
!include $(NTMAKEENV)\sources.COR       
USE_NOLIBS                              = 1
NO_NTDLL                                = 1

INCLUDES                                = $(INCLUDES);.;..;..\..\inc;..\..\..\inc;

MINORCOMP                               = mscor$(_CORFLAVOR)

TARGETNAME                              = $(CORBUILDENV)mscor$(_CORFLAVOR)
TARGETPATH                              = $(TARGETCORBIN)
TARGETTYPE                              = DYNLINK
UMTYPE                                  = windows
COFFBASE                                = mscor$(_CORFLAVOR)
CORFLIBS                                =

COR_C_FLAGS                             = $(COR_C_FLAGS) -DUNICODE -D_UNICODE -D__TIGGER__ 
CDEFINES                                = $(CDEFINES) $(COR_C_FLAGS)

EXCEPTION_HANDLING                      = $(SEHONLY)
PRECOMPILED_INCLUDE                     = ..\stdafx.h
PRECOMPILED_CXX                         = 1
PRECOMPILED_SOURCEFILE                  = ..\stdafx.cpp

!IFDEF _WINCEROOT
DLLDEF                          = ..\mscor$(_CORFLAVOR).def
!ELSEIF "$(_TGTCPUTYPE)"=="Alpha"
DLLDEF                          = ..\mscor$(_CORFLAVOR).AlphaDef
!ELSEIF "$(_TGTCPUTYPE)"=="IA64"
DLLDEF                          = ..\mscor$(_CORFLAVOR).IA64Def
COR_C_FLAGS                     = $(COR_C_FLAGS) -DFUSION_SUPPORTED
!ELSE
DLLDEF                          = ..\mscor$(_CORFLAVOR).NTdef
COR_C_FLAGS                     = $(COR_C_FLAGS) -DFUSION_SUPPORTED -DDEBUGGING_SUPPORTED -DEnC_SUPPORTED -DPROFILING_SUPPORTED
!ENDIF

CORTHUNKLIBS    =

LINKLIBS = \
                $(CORLIBS)\utilcode.lib \
                $(CORLIBS)\Format.lib   \
                $(CORLIBS)\cee_$(_CORFLAVOR).lib \
!IF "$(_TGTOS)"=="NT64"
                $(CORLIBS)\IPCManager.lib \
                $(CORLIBS)\corzap.lib
!ELSE
!IF "$(PROFILING_SUPPORTED_BUILD)"=="1"
                $(CORLIBS)\PerfCounters.lib \
!ENDIF
                $(CORLIBS)\IPCManager.lib \
                $(CORLIBS)\corzap.lib \
                $(CORLIBS)\minidump.lib
!ENDIF


SOURCELIBS = $(LINKLIBS)

!IFDEF _WINCEROOT
TARGETLIBS= $(COREDLLPATH) \
!ENDIF


!IFDEF _WINCEROOT
TARGETLIBS =    $(TARGETLIBS)                           \
                $(CORLIBS)\mdruntime.lib                        \
                $(CORLIBS)\mdruntimerw.lib                      \
                $(OLELIBS)\ole32.lib                            \
                $(OLELIBS)\uuid.lib                             \
                $(OLELIBS)\oleaut32.lib             \
                $(OLELIBS)\lpcrt.lib

!ELSEIF "$(_TGTCPUTYPE)"=="Alpha"
TARGETLIBS =    $(TARGETLIBS)                           \
                $(CORLIBS)\mdcompiler.lib                       \
                $(CORLIBS)\mdruntime.lib                        \
                $(CORLIBS)\mdruntimerw.lib                      \
                $(CORLIBS)\COMFloat.lib                         \
                $(CORLIBS)\delayimplib                          \
                $(SDK_LIB_PATH)\oledb$(DCRT).lib                \
                $(SDK_LIB_PATH)\wintrust.lib                    \
                $(SDK_LIB_PATH)\crypt32.lib                     \
                $(SDK_LIB_PATH)\urlmon.lib                      \
                $(CORLIBS)\ceefgen.lib                          \
                $(CORLIBS)\MsCorSec.lib                         \
                $(CORLIBS)\MsCorPe.lib                          \
                $(FUSION_LIB_PATH)\fusion.lib                   \
                $(CORLIBS)\MsCorEE.lib                          \
                $(SDK_LIB_PATH)\mpr.lib                         
!ELSE
TARGETLIBS =    $(TARGETLIBS)                                   \
                $(CORLIBS)\mdcompiler.lib                       \
                $(CORLIBS)\mdruntime.lib                        \
                $(CORLIBS)\mdruntimerw.lib                      \
                $(CORLIBS)\COMFloat_$(_CORFLAVOR).lib           \
                $(CORLIBS)\shimload.lib                         \
                $(CORLIBS)\delayimp.lib                         \
                $(SDK_LIB_PATH)\oledb$(DCRT).lib                \
                $(SDK_LIB_PATH)\wintrust.lib                    \
                $(SDK_LIB_PATH)\shlwapi.lib                     \
                $(SDK_LIB_PATH)\crypt32.lib                     \
                $(SDK_LIB_PATH)\urlmon.lib                      \
                $(SDK_LIB_PATH)\rsa32.lib                       \
                $(CORLIBS)\ceefgen.lib                          \
                $(CORLIBS)\MsCorSec.lib                         \
                $(CORLIBS)\MsCorPe.lib                          \
                $(FUSION_LIB_PATH)\fusion.lib                   \
                $(CORLIBS)\MsCorEE.lib                          \
                $(SDK_LIB_PATH)\mpr.lib                         \
                $(SDK_LIB_PATH)\shell32.lib                     \
!IF "$(DEBUGGING_SUPPORTED_BUILD)"=="1"
                $(CORLIBS)\cordbee_$(_CORFLAVOR).lib \
!ENDIF

!ENDIF

TARGETLIBS =    $(TARGETLIBS)                           \
                $(CORLIBS)\CorGUIDS.lib                 \
                $(CORLIBS)\COMNLS_$(_CORFLAVOR).lib 

!IFNDEF _WINCEROOT
DELAYLOADLIST   = ole32.dll;OLEAUT32.dll;crypt32.dll;urlmon.dll;MsCorSec.dll;mscorpe.dll;mpr.dll;shlwapi.dll

!if "$(FREEBUILD)"!="1"
!IF "$(_TGTCPUTYPE)"=="x86"
TARGETLIBS              =$(TARGETLIBS)                                  \
                         $(SDK_LIB_PATH)\msdis.lib

DELAYLOADLIST                   =$(DELAYLOADLIST);msdis140.dll
!ENDIF
!ENDIF

!if "$(DELAYLOAD)" != ""
DELAYLOAD               =$(DELAYLOAD);$(DELAYLOADLIST)
!else
DELAYLOAD               =$(DELAYLOADLIST)
!endif
!ENDIF # NDEF _WINCEROOT

SOURCES=                                                                \
                ..\MSCoree.cpp                                             \
                ..\DelayLoad.cpp                                           \
                ..\MsCorver.rc                                                                             

!if "$(LINKONLY)" == "1"
MISCFILES= $(TARGETPATH)\mscoree.vrg \
           $(TARGETPATH)\mscorier.vrg 
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoree\delayload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// DelayLoad.cpp
//
// This code defines the dealy load helper notification routines that will be
// invoked when a dll marked for delay load is processed.  A DLL is marked as
// delay load by using the DELAYLOAD=foo.dll directive in your sources file.
// This tells the linker to generate helpers for the imports of this dll instead
// of loading it directly.  If your application never touches those functions,
// the the dll is never loaded.  This improves (a) startup time each time the
// app runs, and (b) overall working set size in the case you never use the
// functionality.
//
// For more information, see:
//      file:\\orville\razzle\src\vctools\link\doc\delayload.doc
//
// This module provides a hook helper and exception handler.  The hook helper
// is used primarily in debug mode right now to determine what call stacks
// force a delay load of a dll.  If these call stacks are very common, then
// you should reconsider using a delay load.
//
// The exception handler is used to catch fatal errors like library not found
// or entry point missing.  If this happens you are dead and need to fail
// gracefully.
//
//*****************************************************************************
#include "stdafx.h"                     // Standard header.
#ifdef PLATFORM_WIN32
#include "delayimp.h"                   // Delay load header file.
#include "Winwrap.h"                    // Wrappers for Win32 api's.
#include "Utilcode.h"                   // Debug helpers.
#include "CorError.h"                   // Error codes from this EE.
#include "ShimLoad.h"


//********** Locals. **********************************************************
//CORCLBIMPORT HRESULT LoadStringRC(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet=false);
static DWORD _FormatMessage(LPWSTR szMsg, DWORD chMsg, DWORD dwLastError, ...);
static void _FailLoadLib(unsigned dliNotify, DelayLoadInfo *pdli);
static void _FailGetProc(unsigned dliNotify, DelayLoadInfo *pdli);

#if defined (_DEBUG) || defined (__delay_load_trace__)
static void _DbgPreLoadLibrary(int bBreak,  DelayLoadInfo *pdli);
#endif


//********** Globals. *********************************************************

// Override __pfnDllFailureHook.  This will give the delay code a callback
// for when a load failure occurs.  This failure hook is implemented below.
FARPROC __stdcall CorDelayErrorHook(unsigned dliNotify, DelayLoadInfo *pdli);
ExternC extern PfnDliHook __pfnDliFailureHook = CorDelayErrorHook;

// In trace mode, override the delay load hook.  Our hook does nothing but
// provide some diagnostic information for debugging.
FARPROC __stdcall CorDelayLoadHook(unsigned dliNotify, DelayLoadInfo *pdli);
ExternC extern PfnDliHook __pfnDliNotifyHook = CorDelayLoadHook;


//********** Code. ************************************************************


//*****************************************************************************
// Called for errors that might have occured.
//*****************************************************************************
FARPROC __stdcall CorDelayErrorHook(    // Always 0.
    unsigned        dliNotify,          // What event has occured, dli* flag.
    DelayLoadInfo   *pdli)              // Description of the event.
{
    // Chose operation to perform based on operation.
    switch (dliNotify)
    {
        // Failed to load the library.  Need to fail gracefully.
        case dliFailLoadLib:
        _FailLoadLib(dliNotify, pdli);
        break;

        // Failed to get the address of the given function, fail gracefully.
        case dliFailGetProc:
        _FailGetProc(dliNotify, pdli);
        break;

        // Unknown failure code.
        default:
        _ASSERTE(!"Unknown delay load failure code.");
        break;
    }

    // Stick a fork in us, we're done for good.
    ExitProcess(pdli->dwLastError);
    return (0);
}


//*****************************************************************************
// Format an error message using a system error (supplied through GetLastError)
// and any subtitution values required.
//*****************************************************************************
DWORD _FormatMessage(                   // How many characters written.
    LPWSTR      szMsg,                  // Buffer for formatted data.
    DWORD       chMsg,                  // How big is the buffer.
    DWORD       dwLastError,            // The last error code we got.
    ...)                                // Substitution values.
{
    DWORD       iRtn;
    va_list     marker;
    
    va_start(marker, dwLastError);
    iRtn = WszFormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM,                 // Flags.
            0,                                          // No source, use system.
            dwLastError,                                // Error code.
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),  // Use default langauge.
            szMsg,                                      // Output buffer.
            dwLastError,                                // Size of buffer.
            &marker);                                   // Substitution text.
    va_end(marker);
    return (iRtn);
}


//*****************************************************************************
// A library failed to load.  This is always a bad thing.
//*****************************************************************************
void _FailLoadLib(
    unsigned        dliNotify,          // What event has occured, dli* flag.
    DelayLoadInfo   *pdli)              // Description of the event.
{
    WCHAR       rcMessage[_MAX_PATH+500]; // Message for display.
    WCHAR       rcFmt[500]; // 500 is the number used by excep.cpp for mscorrc resources.
    HRESULT     hr;

    // Load a detailed error message from the resource file.    
    if (SUCCEEDED(hr = LoadStringRC(MSEE_E_LOADLIBFAILED, rcFmt, NumItems(rcFmt))))
    {
        swprintf(rcMessage, rcFmt, pdli->szDll, pdli->dwLastError);
    }
    else
    {
        // Foramt the Windows error first.
        if (!_FormatMessage(rcMessage, NumItems(rcMessage), pdli->dwLastError, pdli->szDll))
        {
            // Default to a hard coded error otherwise.
            swprintf(rcMessage, L"ERROR!  Failed to delay load library %hs, Win32 error %d, Delay error: %d\n", 
                    pdli->szDll, pdli->dwLastError, dliNotify);
        }
    }

#ifndef _ALPHA_
    // for some bizarre reason, calling OutputDebugString during delay load in non-debug mode on Alpha
    // kills program, so only do it when in debug mode (jenh)
#if defined (_DEBUG) || defined (__delay_load_trace__)
    // Give some feedback to the developer.
    wprintf(rcMessage);
    WszOutputDebugString(rcMessage);
#endif
#endif

    // Tell end user this process is screwed.
    CorMessageBoxCatastrophic(GetDesktopWindow(), rcMessage, L"MSCOREE.DLL", 
            MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL, TRUE);
    _ASSERTE(!"Failed to delay load library");
}


//*****************************************************************************
// A library failed to load.  This is always a bad thing.
//*****************************************************************************
void _FailGetProc(
    unsigned        dliNotify,          // What event has occured, dli* flag.
    DelayLoadInfo   *pdli)              // Description of the event.
{
    WCHAR       rcMessage[_MAX_PATH+756]; // Message for display.
    WCHAR       rcProc[256];            // Name of procedure with error.
    WCHAR       rcFmt[500]; // 500 is the number used by excep.cpp for mscorrc resources.
    HRESULT     hr;

    // Get a display name for debugging information.
    if (pdli->dlp.fImportByName)
        Wsz_mbstowcs(rcProc, pdli->dlp.szProcName, sizeof(rcProc) / sizeof(rcProc[0]) );
    else
        swprintf(rcProc, L"Ordinal: %d", pdli->dlp.dwOrdinal);

    // Load a detailed error message from the resource file.    
    if (SUCCEEDED(hr = LoadStringRC(MSEE_E_GETPROCFAILED, rcFmt, NumItems(rcFmt))))
    {
        swprintf(rcMessage, rcFmt, rcProc, pdli->szDll, pdli->dwLastError);
    }
    else
    {
        if (!_FormatMessage(rcMessage, NumItems(rcMessage), pdli->dwLastError, pdli->szDll))
        {
            // Default to a hard coded error otherwise.
            swprintf(rcMessage, L"ERROR!  Failed GetProcAddress() for %s, Win32 error %d, Delay error %d\n", 
                    rcProc, pdli->dwLastError, dliNotify);
        }
    }

#ifndef ALPHA
    // for some bizarre reason, calling OutputDebugString during delay load in non-debug mode on Alpha
    // kills program, so only do it when in debug mode (jenh)
#if defined (_DEBUG) || defined (__delay_load_trace__)
    // Give some feedback to the developer.
    wprintf(rcMessage);
    WszOutputDebugString(rcMessage);
#endif
#endif

    // Tell end user this process is screwed.
    CorMessageBoxCatastrophic(GetDesktopWindow(), rcMessage, L"MSCOREE.DLL", 
            MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL, TRUE);
    _ASSERTE(!"Failed to delay load GetProcAddress()");
}




//
//********** Tracing code. ****************************************************
//


//*****************************************************************************
// This routine is our Delay Load Helper.  It will get called for every delay
// load event that occurs while the application is running.
//*****************************************************************************
FARPROC __stdcall CorDelayLoadHook(     // Always 0.
    unsigned        dliNotify,          // What event has occured, dli* flag.
    DelayLoadInfo   *pdli)              // Description of the event.
{
    HMODULE result = NULL;

    switch(dliNotify) {
    case dliNotePreLoadLibrary:
        if(pdli->szDll) {
            DWORD  dwLength = _MAX_PATH;
            WCHAR  pName[_MAX_PATH];
            if(FAILED(GetInternalSystemDirectory(pName, &dwLength)))
                return NULL;
            
            MAKE_WIDEPTR_FROMANSI(pwLibrary, pdli->szDll);
            if(dwLength + __lpwLibrary + 1 >= _MAX_PATH)
                return NULL;
            
            wcscpy(pName+dwLength-1, pwLibrary);
            result = WszLoadLibraryEx(pName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        }
        break;
    default:
        break;
    }

#if defined (_DEBUG) || defined (__delay_load_trace__)

    static int  bBreak = false;         // true to break on events.
    static int  bInit = false;          // true after we've checked environment.
    // If we've not yet looked at our environment, then do so.
    if (!bInit)
    {
        WCHAR       rcBreak[16];

        // set DelayLoadBreak=[0|1]
        if (WszGetEnvironmentVariable(L"DelayLoadBreak", rcBreak, NumItems(rcBreak)))
        {
            // "1" means to break hard and display errors.
            if (*rcBreak == '1')
                bBreak = 1;
            // "2" means no break, but display errors.
            else if (*rcBreak == '2')
                bBreak = 2;
            else
                bBreak = false;
        }
        bInit = true;
    }

    // Chose operation to perform based on operation.
    switch (dliNotify)
    {
        // Called just before a load library takes place.  Use this opportunity
        // to display a debug trace message, and possible break if desired.
        case dliNotePreLoadLibrary:
        _DbgPreLoadLibrary(bBreak, pdli);
        break;
    }
#endif
    return (FARPROC) result;
}


#if defined (_DEBUG) || defined (__delay_load_trace__)

//*****************************************************************************
// Display a debug message so we know what's going on.  Offer to break in
// debugger if you want to see what call stack forced this library to load.
//*****************************************************************************
void _DbgPreLoadLibrary(
    int         bBreak,                 // true to break in debugger.
    DelayLoadInfo   *pdli)              // Description of the event.
{
#ifdef _ALPHA_
    // for some bizarre reason, calling OutputDebugString during delay load in non-debug mode on Alpha
    // kills program, so only do it when in debug mode (jenh)
    if (! IsDebuggerPresent())
        return;
#endif

    WCHAR       rcMessage[_MAX_PATH*2]; // Message for display.

    // Give some feedback to the developer.
    swprintf(rcMessage, L"Delay loading %hs\n", pdli->szDll);
    WszOutputDebugString(rcMessage);

    if (bBreak)
    {
        wprintf(rcMessage);

        if (bBreak == 1)
        {
            _ASSERTE(!"fyi - Delay loading library.  Set DelayLoadBreak=0 to disable this assert.");
        }
    }
}


#endif // _DEBUG

#endif // PLATFORM_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorie\server.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Server.cpp
//
// Defines the interfaces supported by this module
//
//
//*****************************************************************************
#include "stdpch.h"

#include "CFactory.h"
#include "utilcode.h"
#include "CorFltr.h"

CFactoryData g_FactoryDataArray[] =
{
    {&CLSID_CorMimeFilter, 
     CorFltr::Create, 
     L"Cor MIME Filter, CorFltr, CorFltr 1", // Friendly Name
     L"CorRegistration",
     L"CorFltr",
     1,
     NULL, 
     0}


} ;
int g_cFactoryDataEntries
    = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorie\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorie\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscorie.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET IE MIME Filter\0"
#define VER_ORIGFILENAME_STR    "mscorie.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorie\dllmain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// dllmain.cpp
//
// This module contains the public entry points for the COM+ MIME filter dll.  
//
//*****************************************************************************
#include "stdpch.h"
#ifdef _DEBUG
#define LOGGING
#endif
#include "log.h"
#include "corpermp.h"
#include "corfltr.h"

//
// Module instance
//
HINSTANCE GetModule();

static LPCWSTR g_msdownload =  L"PROTOCOLS\\Filter\\application/x-msdownload";
static LPCWSTR g_octetstring = L"PROTOCOLS\\Filter\\application/octet-stream";
static LPCWSTR g_complus =     L"PROTOCOLS\\Filter\\application/x-complus";

static HRESULT RegisterMime(LPCWSTR lpMimeName)
{
    HRESULT hr = S_OK;

    HKEY regKey = NULL;
    DWORD dwDisposition = 0;
    
    if(WszRegCreateKeyEx(HKEY_CLASSES_ROOT, 
                         lpMimeName, 0, NULL,
                         REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, 
                         NULL, &regKey, &dwDisposition) == ERROR_SUCCESS) {
        
        WCHAR wszID[64];               // The class ID to register.
        DWORD lgth = sizeof(wszID)/sizeof(wszID[0]);
        StringFromGUID2(CLSID_CorMimeFilter, wszID, lgth);
        if(WszRegSetValueEx(regKey,
                            L"CLSID",
                            0,
                            REG_SZ,
                            (BYTE*) wszID,
                            (Wszlstrlen(wszID)+1)*sizeof(WCHAR)) != ERROR_SUCCESS)
            hr = Win32Error();
        
        RegCloseKey(regKey);
    }
    else 
        hr = Win32Error();

    return hr;
}

static HRESULT UnregisterMime(LPCWSTR lpMimeName)
{
    WszRegDeleteKey(HKEY_CLASSES_ROOT, lpMimeName);
    return S_OK;
}

extern "C"
STDAPI DllRegisterServer ( void )
{

    HRESULT hr = S_OK;
    hr = CorFactoryRegister(GetModule());
    if(FAILED(hr)) goto exit;

    hr = RegisterMime(g_msdownload);
    if(FAILED(hr)) goto exit;

    hr = RegisterMime(g_octetstring);
    if(FAILED(hr)) goto exit;

    hr = RegisterMime(g_complus);
    if(FAILED(hr)) goto exit;

 exit:
    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:   Remove registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------


extern "C" 
STDAPI DllUnregisterServer ( void )
{
    HRESULT hr = S_OK;
    hr = CorFactoryUnregister();
    UnregisterMime(g_msdownload);
    UnregisterMime(g_octetstring);
    UnregisterMime(g_complus);
    return hr;
}

extern "C" 
STDAPI DllCanUnloadNow(void)
{
    return CorFactoryCanUnloadNow();
}


HINSTANCE g_hModule = NULL;

HINSTANCE GetModule()
{ return g_hModule; }

BOOL WINAPI DllMain(HANDLE hInstDLL,
                    DWORD   dwReason,
                    LPVOID  lpvReserved)
{
    BOOL    fReturn = TRUE;
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls((HINSTANCE)hInstDLL);
        g_hModule = (HMODULE)hInstDLL;

        // Init unicode wrappers.
        OnUnicodeSystem();

        InitializeLogging();
        break;

    case DLL_PROCESS_DETACH:
        ShutdownLogging();
        break;
    }

    return fReturn;
}

#ifndef DEBUG
int _cdecl main(int argc, char * argv[])
{
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorie\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// 
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorie\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#include <windows.h>
#include <winbase.h>
#include <windowsx.h>
#include <windef.h>
#include <limits.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

HINSTANCE GetModule();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorier\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "MSCORIER.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime IE resources\0"
#define VER_ORIGFILENAME_STR    "mscorier.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorier\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#define IDS_MAIN_HEADING        1001
#define IDS_NOT_SIGNED          1002
#define IDS_DISABLE             1003
#define IDS_ENABLE              1004
#define IDS_PROMPT              1005
#define IDS_SIGNED              1006

#define IDI_DOWNLOAD_ICON       2000
#define IDI_DOWNLOAD2_ICON      2001
#define IDB_DOWNLOAD_MAP        2003
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorld\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// 
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorld\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorld\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#include <windows.h>
#include <winbase.h>
#include <windowsx.h>
#include <windef.h>
#include <limits.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

HINSTANCE GetModule();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscories\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.cpp : source file that includes just the standard includes
// net.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdpch.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscories\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscories.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET IE SECURITY REGISTRATION\0"
#define VER_ORIGFILENAME_STR    "mscories.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscories\mscories.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CorFltr
#ifndef _CORFLT_H
#define _CORFLT_H

//*****************************************************************************
//  mscories.h 
//
//  This file is used to set the internet settings for managed
//  and unmanaged code permissions in the HKCU hive.  Internet
//  explorer will decide whether or not to enable, prompt, or
//  disable when users come across managed and unmanaged 
//  .Net Framework applications.
//
//  To install the registry keys, use:
//     rundll32 mscories.dll,Install
//
//  To uninstall the registry keys, use:
//      rundll32 mscories.dll,Uninstall
//
//  Written 4/18/2002 jfosler@microsoft.com
//
//
//*****************************************************************************

/*------------------------------------------------------------
    ePermissionType

    This enumeration corresponds to the internet explorer options:

        0 - Normally sets a given action as being allowed
        1 - Causes a prompt to appear
        3 - Disables the given action
    
    hungarian: ept
    --------------------------------------------------------------*/

enum ePermissionType
{
    Enable = 0,
    Prompt = 1,
    Disable = 3
};


/*------------------------------------------------------------
    eSecurityLevel

    This enumeration corresponds to the internet explorer 
    security levels for zones.

    hungarian: esl
    --------------------------------------------------------------*/
enum eSecurityLevel
{
    High     = 0x00012000,
    Low      = 0x00010000,
    Medium   = 0x00011000,
    MedLow   = 0x00010500,
    DefaultSecurity  = 0x00000000
};
        
    
/*------------------------------------------------------------
    ZONEDEFAULT

    Structure encapsulating the default settings for an
    internet zone
    
    hungarian: zd
    --------------------------------------------------------------*/
struct ZONEDEFAULT
{
    LPCTSTR pszZone;
    ePermissionType eptManagedPermission;
    ePermissionType eptUnmanagedPermission;
} ; 

// Set specific permissions for an internet zone.
HRESULT hrSetZonePermissions(HKEY *phkeyCurrentUser,
                             LPCTSTR pszZone,
                             ePermissionType managedPermission, 
                             ePermissionType unmanagedPermission);

// Set the default permissions for a particular internet zone.
HRESULT hrSetDefaultPermissions(HKEY * phkeyCurrentUser, const ZONEDEFAULT * pzdZone);

// Determine if the managed and unmanaged keys have been set for a particular zone
bool PermissionsAlreadySet(HKEY * phkeyCurrentUser, LPCTSTR pszZone);
    
// Given an internet zone, set the managed and unmanaged keys for that zone
HRESULT CheckAndSetZone(HKEY * phkeyCurrentUser, const ZONEDEFAULT * pzdZoneDefault);

// Return the security level for a particular internet zone
eSecurityLevel GetSecurityLevel(HKEY * phkeyCurrentUser, LPCTSTR pszZone);

// Error logging routine
void vCheckAndLogError(HRESULT hr, LPCTSTR lptstrKey);


// External function to be invoked through RunDLL32.
void CALLBACK Install(
                      HWND hwnd,        // handle to owner window
                      HINSTANCE hinst,  // instance handle for the DLL
                      LPTSTR lpCmdLine, // string the DLL will parse
                      int nCmdShow      // show state
                      );


// Given an internet zone, check if the managed and unmanaged keys are set and remove them
HRESULT CheckAndRemoveZone( HKEY * phkeyInternetSettingsKey, const ZONEDEFAULT * pzdZone);
    
// Remove the managed and unmanaged keys from a particular zone
HRESULT CleanZone (HKEY *phkeyInternetSettingsKey,  LPCTSTR pszZone);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscories\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#pragma once

// Windows Header Files:
#include <windows.h>

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorld\server.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Server.cpp
//
// Defines the interfaces supported by this module
//
//
//*****************************************************************************
#include "stdpch.h"

#include "CFactory.h"
#include "utilcode.h"
#include "CorLoad.h"

CFactoryData g_FactoryDataArray[] =
{
    {&CLSID_CodeProcessor, 
     CorLoad::Create, 
     L"Cor Remote Loader, CorLoad, CorLoad 1", // Friendly Name
     L"CorTransientLoader",
     L"CorLoad",
     1,
     NULL, 
     0},
    
} ;
int g_cFactoryDataEntries
    = sizeof(g_FactoryDataArray) / sizeof(CFactoryData) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorld\dllmain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// dllmain.cpp
//
// This module contains the public entry points for the COM+ MIME filter dll.  
//
//*****************************************************************************
#include "stdpch.h"
#ifdef _DEBUG
#define LOGGING
#endif
#include "log.h"
#include "corpermp.h"
#include "corfltr.h"
#include "iiehost.h"
#include <__file__.ver>
#include <StrongName.h>
#include "Mscoree.h"

//
// Module instance
//


HINSTANCE GetModule();
static DWORD g_RecursiveDownLoadIndex = -1;

static BOOL ValidRecursiveCheck()
{
    return (g_RecursiveDownLoadIndex == -1 ? FALSE : TRUE);
}

static BOOL SetValue(DWORD i)
{
    if(ValidRecursiveCheck()) {
        DWORD* pState = (DWORD*) TlsGetValue(g_RecursiveDownLoadIndex);
        if(pState != NULL) {
            *pState = i;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL RecursiveDownLoad()
{
    // When we have no index we cannot store the state
    // so we do not know when we are in a recursive down load
    if(!ValidRecursiveCheck())
        return FALSE;  

    DWORD* pState = (DWORD*) TlsGetValue(g_RecursiveDownLoadIndex);
    if(pState == NULL || *pState == 0)
        return FALSE;

    return TRUE;
}

BOOL SetRecursiveDownLoad()
{
    return SetValue(1);
}

BOOL ClearRecursiveDownLoad()
{
    return SetValue(0);
}


LPWSTR GetAssemblyName(LPWSTR szAssembly)
{
    HRESULT                     hr;
    IMetaDataDispenser         *pDisp;
    IMetaDataAssemblyImport    *pAsmImport;
    mdAssembly                  tkAssembly;
    BYTE                       *pbKey;
    DWORD                       cbKey;    

    static WCHAR                szAssemblyName[MAX_PATH + 512 + 1024];
    // MAX_PATH - for assembly name
    // 512 - for Version, Culture, PublicKeyToken string (some extra bytes here)
    // 1024 - for the PublicKeyToken, which is <= 1024 bytes.
    
    WCHAR                       szStrongName[1024];
    BYTE                       *pbToken;
    DWORD                       cbToken;
    DWORD                       i;

    // Initialize classic COM and get a metadata dispenser.
    if (FAILED(hr = CoInitialize(NULL))) {
        printf("Failed to initialize COM, error %08X\n", hr);
        return NULL;
    }

    if (FAILED(hr = CoCreateInstance(CLSID_CorMetaDataDispenser,
                                     NULL,
                                     CLSCTX_INPROC_SERVER, 
                                     IID_IMetaDataDispenser,
                                     (void**)&pDisp))) {
        printf("Failed to access metadata API, error %08X\n", hr);
        return NULL;
    }

    // Open a scope on the file.
    if (FAILED(hr = pDisp->OpenScope(szAssembly,
                                     0,
                                     IID_IMetaDataAssemblyImport,
                                     (IUnknown**)&pAsmImport))) {
        printf("Failed to open metadata scope on %S, error %08X\n", szAssembly, hr);
        return NULL;
    }

    // Determine the assemblydef token.
    if (FAILED(hr = pAsmImport->GetAssemblyFromScope(&tkAssembly))) {
        printf("Failed to locate assembly metadata in %S, error %08X\n", szAssembly, hr);
        return NULL;
    }

    // Read the assemblydef properties to get the public key and name.
    if (FAILED(hr = pAsmImport->GetAssemblyProps(tkAssembly,
                                                 (const void **)&pbKey,
                                                 &cbKey,
                                                 NULL,
                                                 szAssemblyName,
                                                 MAX_PATH,   // we need to reserve space in szAssemblyName, see below
                                                 NULL,
                                                 NULL,
                                                 NULL))) {
        printf("Failed to read strong name from %S, error %08X\n", szAssembly, hr);
        return NULL;
    }
    
    // Check for strong name.
    if ((pbKey == NULL) || (cbKey == 0)) {
        printf("Assembly is not strongly named\n");
        return NULL;
    }

    // Compress the strong name down to a token.
    if (!StrongNameTokenFromPublicKey(pbKey, cbKey, &pbToken, &cbToken)) {
        printf("Failed to convert strong name to token, error %08X\n", StrongNameErrorInfo());
        return NULL;
    }

    // tokens are speced at 8 bytes, so 512 should be enough.    
    _ASSERTE(cbToken <= 512);
    
    if(cbToken > 512)
    {
        printf("Strong name token is too large\n");
        return NULL;
    }
            
    // Turn the token into hex.
    for (i = 0; i < cbToken; i++)
        swprintf(&szStrongName[i * 2], L"%02X", pbToken[i]);

    // Build the name (in a static buffer).    
    wcscat(szAssemblyName, L", Version=");
    wcscat(szAssemblyName, VER_ASSEMBLYVERSION_WSTR);
    wcscat(szAssemblyName, L", Culture=neutral, PublicKeyToken=");
    wcscat(szAssemblyName, szStrongName);

    StrongNameFreeBuffer(pbToken);
    pAsmImport->Release();
    pDisp->Release();
    CoUninitialize();

    return szAssemblyName;
}


HRESULT RegisterAsMimePlayer(REFIID clsid,LPCWSTR mimetype)
{
    //MIME key

    HKEY hMime;
    HRESULT hr;
    long rslt;
    rslt=WszRegCreateKeyEx(HKEY_CLASSES_ROOT,L"MIME\\Database\\Content type",0,NULL,
        REG_OPTION_NON_VOLATILE,KEY_READ|KEY_WRITE,NULL,&hMime,NULL);
    hr=HRESULT_FROM_WIN32(rslt);
    if (SUCCEEDED(hr))
    {
        HKEY hMimetype;
        rslt=WszRegCreateKeyEx(hMime,mimetype,0,NULL,
                    REG_OPTION_NON_VOLATILE,KEY_READ|KEY_WRITE,NULL,&hMimetype,NULL);
        hr=HRESULT_FROM_WIN32(rslt);
        if (SUCCEEDED(hr))
        {
            LPOLESTR wszClsid;
            hr=StringFromCLSID(clsid,&wszClsid);
            if (SUCCEEDED(hr))
            {
                rslt=WszRegSetValueEx(hMimetype,L"CLSID",NULL,
                    REG_SZ,LPBYTE(wszClsid),wcslen(wszClsid)*2);
                hr=HRESULT_FROM_WIN32(rslt);
                CoTaskMemFree(wszClsid);
            }
            RegCloseKey(hMimetype);
        }
        RegCloseKey(hMime);
    }

    if(FAILED(hr))
        return hr;

    LPOLESTR sProgID;
    hr=ProgIDFromCLSID(clsid,&sProgID);
    if(SUCCEEDED(hr))
    {
        HKEY hClass;
        rslt=WszRegCreateKeyEx(HKEY_CLASSES_ROOT,sProgID,0,NULL,
                        REG_OPTION_NON_VOLATILE,KEY_READ|KEY_WRITE,NULL,&hClass,NULL);
        hr=HRESULT_FROM_WIN32(rslt);
        if(SUCCEEDED(hr))
        {
            DWORD flags=0x10000;
            rslt=WszRegSetValueEx(hClass,L"EditFlags",NULL,
                REG_BINARY,LPBYTE(&flags),sizeof(flags));
            hr=HRESULT_FROM_WIN32(rslt);
            RegCloseKey(hClass);
        }
        CoTaskMemFree(sProgID);
    }
    return hr;
}

HRESULT UnRegisterAsMimePlayer(REFIID clsid,LPCWSTR mimetype)
{
    HKEY hMime;
    HRESULT hr;
    long rslt;
    rslt=WszRegCreateKeyEx(HKEY_CLASSES_ROOT,L"MIME\\Database\\Content type",0,NULL,
        REG_OPTION_NON_VOLATILE,KEY_READ|KEY_WRITE,NULL,&hMime,NULL);
    hr=HRESULT_FROM_WIN32(rslt);
    if (SUCCEEDED(hr))
    {
        rslt=WszRegDeleteKey(hMime,mimetype);
        hr=HRESULT_FROM_WIN32(rslt);
        RegCloseKey(hMime);
    }
    return hr;
}

#define THIS_VERSION 1    

extern "C"
STDAPI DllRegisterServer ( void )
{
    
    WCHAR wszFullAssemblyName[MAX_PATH+10];
    if (WszGetModuleFileName(GetModule(),wszFullAssemblyName,MAX_PATH+1)==0)
        return E_UNEXPECTED;
    LPWSTR wszSl=wcsrchr(wszFullAssemblyName,L'\\');
    if (wszSl==NULL)
        wszSl=wszFullAssemblyName+wcslen(wszFullAssemblyName);
    LPWSTR wszBSl=wcsrchr(wszFullAssemblyName,L'/');
    if (wszBSl==NULL)
        wszBSl=wszFullAssemblyName+wcslen(wszFullAssemblyName);

    wcscpy(min(wszSl,wszBSl)+1,L"IEHost.dll");


    HRESULT hr = S_OK;
    hr = CorFactoryRegister(GetModule());

    // Get the version of the runtime
    WCHAR       rcVersion[_MAX_PATH];
    DWORD       lgth;
    hr = GetCORSystemDirectory(rcVersion, NumItems(rcVersion), &lgth);

    if(FAILED(hr)) goto exit;
    hr = REGUTIL::RegisterCOMClass(CLSID_IEHost,
                                   L"IE Filter for CLR activation",
                                   L"Microsoft",
                                   THIS_VERSION,
                                   L"IE.Manager",
                                   L"Both",
                                   NULL,             // No module
                                   GetModule(),
                                   GetAssemblyName(wszFullAssemblyName),
                                   rcVersion, 
                                   true,
                                   false);

    if(FAILED(hr)) goto exit;

    hr=RegisterAsMimePlayer(CLSID_CodeProcessor,g_wszApplicationComplus);
    
 exit:
    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:   Remove registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------


extern "C" 
STDAPI DllUnregisterServer ( void )
{
    HRESULT hr = CorFactoryUnregister();
    hr = UnRegisterAsMimePlayer(CLSID_CodeProcessor,g_wszApplicationComplus);
    hr = REGUTIL::UnregisterCOMClass(CLSID_IEHost,
                                     L"Microsoft",
                                     THIS_VERSION,
                                     L"IE.Manager",
                                     true);
    return hr;
}

extern "C" 
STDAPI DllCanUnloadNow(void)
{
    return CorFactoryCanUnloadNow();
}


HINSTANCE g_hModule = NULL;

HINSTANCE GetModule()
{ return g_hModule; }

BOOL WINAPI DllMain(HANDLE hInstDLL,
                    DWORD   dwReason,
                    LPVOID  lpvReserved)
{
    BOOL    fReturn = TRUE;
    BOOL    fIgnore;
    LPVOID  lpvData;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        g_hModule = (HMODULE)hInstDLL;
        
        // Init unicode wrappers.
        OnUnicodeSystem();
        
        InitializeLogging();

        // Try and get a TLS slot
        g_RecursiveDownLoadIndex = TlsAlloc(); 
        // break;  // Fall through Thread Attach

    case DLL_THREAD_ATTACH:
        if(ValidRecursiveCheck()) {
            lpvData = LocalAlloc(LPTR, sizeof(DWORD));
            if(lpvData != NULL) 
                fIgnore = TlsSetValue(g_RecursiveDownLoadIndex,
                                      lpvData);
        }
        break;
    case DLL_THREAD_DETACH:
        if(ValidRecursiveCheck()) {
            lpvData = TlsGetValue(g_RecursiveDownLoadIndex);
            if(lpvData != NULL) 
                LocalFree(lpvData);
        }
        break;

    case DLL_PROCESS_DETACH:
        ShutdownLogging();
        if(ValidRecursiveCheck())
            TlsFree(g_RecursiveDownLoadIndex);
        break;
    }

    return fReturn;
}

#ifndef DEBUG
int _cdecl main(int argc, char * argv[])
{
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscories\dllmain.cpp ===
/* ----------------------------------------------------------------
mscories.cpp

This file is used to set the internet settings for managed
and unmanaged code permissions in the HKCU hive.  Internet
explorer will decide whether or not to enable, prompt, or
disable when users come across managed and unmanaged 
.Net Framework applications.

To install the registry keys, use:
   rundll32 mscories.dll,Install

To uninstall the registry keys, use:
    rundll32 mscories.dll,Uninstall

Written 4/18/2002 jfosler@microsoft.com

Microsoft Confidential.
Copyright Microsoft Corporation 1996-2002, All Rights Reserved.
------------------------------------------------------------------*/

#include "stdpch.h"
#include "winwrap.h"
#include "mscories.h"

// We have some unreferenced formal parameters 
// in our top level functions - we need these 
// parameters to match the function definition
// that the API requires, but we don't actually
// use them.
#pragma warning( disable : 4100 )


/* --------------------------------------------------------
// The following represents default internet zone settings.
-------------------------------------------------------- */
//                                              Zone        Managed    Unmanaged
const ZONEDEFAULT kzdMyComputer              = {L"0",      Enable,     Enable};
const ZONEDEFAULT kzdLocalIntranet           = {L"1",      Enable,     Enable};
const ZONEDEFAULT kzdTrustedSites            = {L"2",      Enable,     Enable}; 
const ZONEDEFAULT kzdInternetZone            = {L"3",      Enable,     Enable};
const ZONEDEFAULT kzdRestrictedSitesZone     = {L"4",      Disable,    Disable};

/* ---------------------------------------------
// The following represents registry keys
---------------------------------------------*/
const LPCWSTR  lpstrManagedCodeKey      =   L"2001";
const LPCWSTR  lpstrUnmanagedCodeKey    =   L"2004";
const LPCWSTR  lpstrCurrentLevelKey =   L"CurrentLevel";
const LPCWSTR  lpstrHKCUInternetSettingsZonesHive        =  L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones";



/*------------------------------------------------------------
// Install -
// 
// Goes through HKCU and adds permissions for managed and 
// unmanaged code for each internet zone.
// 
// This function is meant to be invoked through RunDll32.exe.
// rundll32 DllName,FunctionName [Arguments]

// RunDLL32 expects the exported function to have the following 
// function signature:
//          void CALLBACK FunctionName(
//          HWND hwnd,        // handle to owner window 
//          HINSTANCE hinst,  // instance handle for the DLL
//          LPTSTR lpCmdLine, // string the DLL will parse
//          int nCmdShow      // show state
//          );
// 
// To use this function, use: rundll32 mscories.dll,Install 
//
// For more information, search on RunDLL32 in MSDN Platform SDK.
// 
--------------------------------------------------------------*/
void CALLBACK Install(
  HWND hwnd,        // handle to owner window
  HINSTANCE hinst,  // instance handle for the DLL
  LPWSTR lpCmdLine, // string the DLL will parse
  int nCmdShow      // show state
)
{
    OnUnicodeSystem();
    HKEY hkeyInternetSettingsKey;

    /* Open HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Zones */
    HRESULT hr = WszRegOpenKeyEx(HKEY_CURRENT_USER, 
                    lpstrHKCUInternetSettingsZonesHive,
                    NULL,
                    KEY_ALL_ACCESS,
                    &hkeyInternetSettingsKey);

    vCheckAndLogError(hr, lpstrHKCUInternetSettingsZonesHive);
    
    if (hr == ERROR_SUCCESS)            
    {       
        /* Set managed and unmanaged keys for my computer */
        hr = CheckAndSetZone(&hkeyInternetSettingsKey, &kzdMyComputer);
        vCheckAndLogError(hr, kzdMyComputer.pszZone);

        /* Set managed and unmanaged keys for my computer */
        hr = CheckAndSetZone(&hkeyInternetSettingsKey, &kzdLocalIntranet);
        vCheckAndLogError(hr, kzdLocalIntranet.pszZone);

        /* Set managed and unmanaged keys for trusted sites */
        hr = CheckAndSetZone(&hkeyInternetSettingsKey, &kzdTrustedSites);
        vCheckAndLogError(hr, kzdTrustedSites.pszZone);

        /* Set managed and unmanaged keys for internet zone */
        hr = CheckAndSetZone(&hkeyInternetSettingsKey, &kzdInternetZone);
        vCheckAndLogError(hr, kzdInternetZone.pszZone);

        /* Set managed and unmanaged keys for restricted sites zone */
        hr = CheckAndSetZone(&hkeyInternetSettingsKey, &kzdRestrictedSitesZone);
        vCheckAndLogError(hr, kzdRestrictedSitesZone.pszZone);

        if (hkeyInternetSettingsKey != NULL)
            RegCloseKey(hkeyInternetSettingsKey);

    }


}

/*-------------------------------------------------------------------
// vCheckAndLogError 
// 
// UNDONE: where should we log errors?  System log?
-------------------------------------------------------------------*/
void vCheckAndLogError(HRESULT hr, LPCWSTR lptstrKey)
{
    
}

/*-------------------------------------------------------------------
// CheckAndSetZone 
//
// Given a handle to HKCU and a zone, checks to see if the permissions
// have already been set - if they havent, it explicitly sets the
// managed and unmanaged code permissions for the zone.
//
-------------------------------------------------------------------*/
HRESULT CheckAndSetZone(HKEY * phkeyInternetSettingsKey, const ZONEDEFAULT * pzdZone)
{
    if (phkeyInternetSettingsKey == NULL) return E_UNEXPECTED;
    if (pzdZone == NULL)         return E_UNEXPECTED;
    
    HRESULT hr = S_OK; 

    if (! PermissionsAlreadySet(phkeyInternetSettingsKey, pzdZone->pszZone))
    {
        //
        // Get the security level for the zone by querying
        // HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\n\ "CurrentLevel"
        //
        eSecurityLevel slZoneSecurityLevel = GetSecurityLevel(phkeyInternetSettingsKey, pzdZone->pszZone);

        // Depending on the security level for the zone, go ahead and 
        // set the appropriate (enable, prompt, disable) for  
        // managed and unmanaged code.

        switch (slZoneSecurityLevel)
        {
        case High:
            hr = hrSetZonePermissions(phkeyInternetSettingsKey, pzdZone->pszZone, Disable, Disable);
            break;
        case Medium:
            hr = hrSetZonePermissions(phkeyInternetSettingsKey, pzdZone->pszZone, Enable, Enable);
            break;
        case MedLow:
            hr = hrSetZonePermissions(phkeyInternetSettingsKey, pzdZone->pszZone, Enable, Enable);
            break;
        case Low:
            hr = hrSetZonePermissions(phkeyInternetSettingsKey, pzdZone->pszZone, Enable, Enable);
            break;
        case DefaultSecurity:
        default:
            hr = hrSetDefaultPermissions(phkeyInternetSettingsKey, pzdZone);
            break;
        }

    }

    return hr;

}



/*-------------------------------------------------------------------
//
// GetSecurityLevel 
//
// Given a handle to HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\
// and a particular internet zone, figure out the current security level
// (High, Medium, MedLow, Low).
//
// If the CurrentLevel value does not exist it returns DefaultSecurity.
// If the CurrentLevel value is garbage, it returns DefaultSecurity.
//
-------------------------------------------------------------------*/

eSecurityLevel GetSecurityLevel(HKEY * phkeyInternetSettingsKey, LPCWSTR pszZone)
{
    if (phkeyInternetSettingsKey == NULL) return DefaultSecurity;
    if (pszZone == NULL)         return DefaultSecurity;


    //
    // Open the particular zone key: i.e.
    // HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\n\CurrentLevel
    // and figure out what the security level for the zone is.
    //

    HKEY hkeyInternetZoneKey;
    HRESULT hr = WszRegOpenKeyEx(*phkeyInternetSettingsKey, 
                    pszZone,
                    NULL,
                    KEY_ALL_ACCESS,
                    &hkeyInternetZoneKey);

    if (hr == ERROR_SUCCESS)
    {

        DWORD dwCurrentSecurityLevelForZone;
        DWORD dwRegDword = REG_DWORD;
        DWORD dwBytes = sizeof(dwCurrentSecurityLevelForZone);

        hr = WszRegQueryValueEx(
                                hkeyInternetZoneKey,                    // handle to key
                                lpstrCurrentLevelKey,                   // value name
                                NULL,                                   // reserved
                                &dwRegDword,                            // type buffer
                                reinterpret_cast<LPBYTE>(&dwCurrentSecurityLevelForZone),           // data buffer
                                &dwBytes  // size of data buffer
                                );

        //
        // Only return the security level if we succeeded to query the "CurrentLevel" key.
        //  -  If, for instance, in the unlikely event that someone changed 
        //     "CurrentLevel" to be a string called "High", then what we've got 
        //     in dwCurrentSecurityLevelForZone is total garbage, and we shouldn't return it.
        


        if (hr == ERROR_SUCCESS)
        {
            eSecurityLevel slSecurityLevel = static_cast<eSecurityLevel>(dwCurrentSecurityLevelForZone);
            
            // This is a bit of overkill, but it implies that everything we
            // return from this method is a known member of the eSecurityLevel
            // enumeration - that way if someone has set the CurrentLevel to a
            // DWORD we don't understand, we just return the default security.

            switch (slSecurityLevel)
            {
                case High:      // Deliberate fallthrough
                case Low:       // Deliberate fallthrough
                case MedLow:    // Deliberate fallthrough
                case Medium:
                    return slSecurityLevel;
                default:
                    return DefaultSecurity;
            }
        }
    }

    // If there were any errors, just return the default.
    return DefaultSecurity;
}


/*-------------------------------------------------------------------
// PermissionsAlreadySet 
//
// Given a handle to HKCU, queries the zone to see if permissions have already been set.
//
// Returns true when we are able to open "2001" and "2004" for a particular zone 
//             and determine that the values stored in those keys are valid.
//
// Returns false if there was any kind of an error opening/reading the key, 
//              the value is invalid, or the values 2001 or 2004 are missing.
// 
-------------------------------------------------------------------*/

bool PermissionsAlreadySet(HKEY *phkeyInternetSettingsKey, LPCWSTR pszZone)
{
    if (phkeyInternetSettingsKey == NULL) return false;
    if (pszZone == NULL)         return false;


    bool bPermissionsAlreadySet = false;

    //
    // Open HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Zones
    //
    
    HKEY hkeyInternetZoneKey;
    
    
    HRESULT hr = WszRegOpenKeyEx(*phkeyInternetSettingsKey, 
                    pszZone,
                    NULL,
                    KEY_ALL_ACCESS,
                    &hkeyInternetZoneKey);

        if (hr == ERROR_SUCCESS)
        {

        //
        // Query the unmanaged key "2004" to determine if it's already been set.
        //

        DWORD dwManagedLevel;
        DWORD dwRegDword = REG_DWORD;
        DWORD dwBytes = sizeof(dwManagedLevel);

        HRESULT hr = WszRegQueryValueEx(
                                hkeyInternetZoneKey,                        // handle to key
                                lpstrManagedCodeKey,                        // value name
                                NULL,                                       // reserved
                                &dwRegDword,                                // type buffer
                                reinterpret_cast<LPBYTE>(&dwManagedLevel),  // data buffer
                                &dwBytes                                    // size of data buffer
                                );

        // If the reg query succeeded and resulted in a valid DWORD as a 
        // setting for managed code, then the permissions have been already set.

        bPermissionsAlreadySet = (hr == S_OK );
        bPermissionsAlreadySet = (bPermissionsAlreadySet && 
                                    ((dwManagedLevel == Enable) 
                                    || (dwManagedLevel == Prompt) 
                                    || (dwManagedLevel == Disable)));

        //
        // Query the unmanaged key "2001" to determine if it's already been set.
        //

        DWORD dwUnmanagedLevel;
        dwBytes = sizeof(dwUnmanagedLevel);

        hr = WszRegQueryValueEx(
                            hkeyInternetZoneKey,                            // handle to key
                            lpstrUnmanagedCodeKey,                          // value name
                            NULL,                                           // reserved
                            &dwRegDword,                                    // type buffer
                            reinterpret_cast<LPBYTE>(&dwUnmanagedLevel),    // data buffer
                            &dwBytes                                        // size of data buffer
                            );

        // If the reg query succeeded and resulted in a valid DWORD as a 
        // setting for unmanaged as well as managed code, then the permissions 
        // have been already set.

        bPermissionsAlreadySet = (bPermissionsAlreadySet && (hr == S_OK ));
        bPermissionsAlreadySet = (bPermissionsAlreadySet && 
                                    ((dwUnmanagedLevel == Enable) 
                                    || (dwUnmanagedLevel == Prompt) 
                                    || (dwUnmanagedLevel == Disable)));


        if (hkeyInternetZoneKey != NULL)
               RegCloseKey(hkeyInternetZoneKey);
    
    }

    return bPermissionsAlreadySet;
}

/*-------------------------------------------------------------------
// hrSetDefaultPermissions 
//
// Given a handle to HKCU, sets the default permissions for a zone.
-------------------------------------------------------------------*/

HRESULT hrSetDefaultPermissions
(
 HKEY * phkeyInternetSettingsKey,       // Pointer to the previously opened handle to the internet settings key
 const ZONEDEFAULT * pzdZoneDefault     // Pointer to the structure containing the defaults for a particular zone
 )
{
    if (phkeyInternetSettingsKey == NULL) return E_UNEXPECTED;
    if (pzdZoneDefault == NULL)               return E_UNEXPECTED;

    return hrSetZonePermissions(  phkeyInternetSettingsKey, 
                                  pzdZoneDefault->pszZone, 
                                  pzdZoneDefault->eptManagedPermission, 
                                  pzdZoneDefault->eptUnmanagedPermission
                                );
    
}
/*-------------------------------------------------------------------
// hrSetZonePermissions 
// 
// Given a handle to HKCU, a string representing a zone (0 - 4), 
// set the managed and unmanaged permission type.
-------------------------------------------------------------------*/

HRESULT hrSetZonePermissions
(
 HKEY * phkeyInternetSettingsKey,       // Pointer to the previously opened handle to the InternetSettings\Zones key
 LPCWSTR pszZone,                       // String representing the particular zone to set
 ePermissionType managedPermission,     // The permissions for managed code execution
 ePermissionType unmanagedPermission    // The permissions for unmanaged code execution
 )
{
    if (phkeyInternetSettingsKey == NULL) return E_UNEXPECTED;
    if (pszZone == NULL)                  return E_UNEXPECTED;
     

        HKEY hkeyInternetZoneKey;

        /* Open HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\[zone] */
        HRESULT hr = WszRegOpenKeyEx(*phkeyInternetSettingsKey, 
                            pszZone,
                            NULL,
                            KEY_ALL_ACCESS,
                            &hkeyInternetZoneKey);

        
        if (hr == ERROR_SUCCESS)
        {   
            // 
            // Set the permissions for the "managed" key "2001"
            //

            DWORD dwManagedPermission = managedPermission;
            DWORD dwRegDword = REG_DWORD;
            DWORD dwBytes = sizeof(dwManagedPermission);

            hr = WszRegSetValueEx(
                                hkeyInternetZoneKey,                             // handle internet settings zone key
                                lpstrManagedCodeKey,                             // "2001" for managed code permission
                                NULL,                                            // reserved
                                dwRegDword,                                      // Create a DWORD
                                reinterpret_cast<LPBYTE>(&dwManagedPermission),  // Value of managed permission key 
                                dwBytes                                          // size of value data
                                );
            

            if (hr == ERROR_SUCCESS)
            {
                // 
                // Set the permissions for the "unmanaged" key "2004"
                //

                DWORD dwUnmanagedPermission = unmanagedPermission;
                
                hr = WszRegSetValueEx(
                                    hkeyInternetZoneKey,                             // handle internet settings zone key
                                    lpstrUnmanagedCodeKey,                           // "2004" for unmanaged code permission
                                    NULL,                                            // reserved
                                    REG_DWORD,                                       // Create a DWORD
                                    reinterpret_cast<LPBYTE>(&dwUnmanagedPermission),// Value of managed permission key 
                                    sizeof(dwUnmanagedPermission)                    // size of value data
                                    );
        
            }

            if (hkeyInternetZoneKey != NULL)
                RegCloseKey(hkeyInternetZoneKey);
        }
    
        return hr;

}

/*--------------------------  Removal of keys ----------------------------------*/

/*------------------------------------------------------------
// Unintstall -
// 
// Goes through HKCU and removes permissions for managed and 
// unmanaged code for each internet zone.
// 
// This function is meant to be invoked through RunDll32.exe.
// rundll32 DllName,FunctionName [Arguments]
// 
// RunDLL32 expects the exported function to have the following 
// function signature:
//          void CALLBACK FunctionName(
//          HWND hwnd,        // handle to owner window 
//          HINSTANCE hinst,  // instance handle for the DLL
//          LPWSTR lpCmdLine, // string the DLL will parse
//          int nCmdShow      // show state
//          );
//
// To invoke this function use: rundll32 mscories.dll,Uninstall
// For more information, search on RunDLL32 in MSDN Platform SDK.
// 
//
--------------------------------------------------------------*/
void CALLBACK Uninstall(
  HWND hwnd,        // handle to owner window
  HINSTANCE hinst,  // instance handle for the DLL
  LPWSTR lpCmdLine, // string the DLL will parse
  int nCmdShow      // show state
)
{
    OnUnicodeSystem();
    HKEY hkeyInternetSettingsKey;

    /* Open HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\Zones */
    HRESULT hr = WszRegOpenKeyEx(HKEY_CURRENT_USER, 
                    lpstrHKCUInternetSettingsZonesHive,
                    NULL,
                    KEY_ALL_ACCESS,
                    &hkeyInternetSettingsKey);

    vCheckAndLogError(hr, lpstrHKCUInternetSettingsZonesHive);
    
    if (hr == ERROR_SUCCESS)            
    {       
        /* Remove managed and unmanaged keys for my computer */
        hr = CheckAndRemoveZone(&hkeyInternetSettingsKey, &kzdMyComputer);
        vCheckAndLogError(hr, kzdMyComputer.pszZone);

        /* Remove managed and unmanaged keys for my computer */
        hr = CheckAndRemoveZone(&hkeyInternetSettingsKey, &kzdLocalIntranet);
        vCheckAndLogError(hr, kzdLocalIntranet.pszZone);

        /* Remove managed and unmanaged keys for trusted sites */
        hr = CheckAndRemoveZone(&hkeyInternetSettingsKey, &kzdTrustedSites);
        vCheckAndLogError(hr, kzdTrustedSites.pszZone);

        /* Remove managed and unmanaged keys for internet zone */
        hr = CheckAndRemoveZone(&hkeyInternetSettingsKey, &kzdInternetZone);
        vCheckAndLogError(hr, kzdInternetZone.pszZone);

        /* Remove managed and unmanaged keys for restricted sites zone */
        hr = CheckAndRemoveZone(&hkeyInternetSettingsKey, &kzdRestrictedSitesZone);
        vCheckAndLogError(hr, kzdRestrictedSitesZone.pszZone);

        if (hkeyInternetSettingsKey != NULL)
            RegCloseKey(hkeyInternetSettingsKey);

    }

}


/*-------------------------------------------------------------------
// CheckAndRemoveZone 
//
// Given a handle to HKCU and a zone, checks to see if the permissions
// have already been set - if they have, it calls code to clean up the 
// managed and unmanaged keys.
//
-------------------------------------------------------------------*/
HRESULT CheckAndRemoveZone
(
 HKEY * phkeyInternetSettingsKey, 
 const ZONEDEFAULT * pzdZone
)
{
    if (phkeyInternetSettingsKey == NULL) return E_UNEXPECTED;
    if (pzdZone == NULL)         return E_UNEXPECTED;
    
    HRESULT hr = S_OK; 

    if (PermissionsAlreadySet(phkeyInternetSettingsKey, pzdZone->pszZone))
    {
        hr = CleanZone(phkeyInternetSettingsKey, pzdZone->pszZone);
    }

    return hr;

}

/*-------------------------------------------------------------------
// CleanZone 
//
// Deletes the 2001 and 2004 keys from a particular internet zone.
//
-------------------------------------------------------------------*/
HRESULT CleanZone
(
 HKEY *phkeyInternetSettingsKey, 
 LPCWSTR pszZone
 )
{
    if (phkeyInternetSettingsKey == NULL) return E_UNEXPECTED;
    if (pszZone == NULL)                  return E_UNEXPECTED;

    HKEY hkeyInternetZoneKey;

    HRESULT hr = WszRegOpenKeyEx(*phkeyInternetSettingsKey, 
                            pszZone,
                            NULL,
                            KEY_ALL_ACCESS,
                            &hkeyInternetZoneKey);

    if (hr == ERROR_SUCCESS)
    {
        hr = WszRegDeleteValue(
                            hkeyInternetZoneKey,         // handle to InternetSettings/Zones/[n] key
                            lpstrUnmanagedCodeKey        // 2004
                             );

        if (hr == ERROR_SUCCESS)
        {
          hr = WszRegDeleteValue(
                            hkeyInternetZoneKey,   // handle to InternetSettings/Zones/[n] key
                            lpstrManagedCodeKey   // 2001
                             );
        }
    }

    if (hkeyInternetZoneKey != NULL)
        RegCloseKey(hkeyInternetZoneKey);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorld\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscorld.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Remote object loader\0"
#define VER_ORIGFILENAME_STR    "mscorld.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\cabout.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CAbout.h - header file for MMC snapin About info
//
//*****************************************************************************

#ifndef CABOUT_H_
#define CABOUT_H_

#include <UtilCode.h>
#include <CorError.h>

#include "cor.h"
#include <cordbpriv.h>
#include "mscormmc.h"

/* ------------------------------------------------------------------------- *
 * Forward class declarations
 * ------------------------------------------------------------------------- */

class CAbout;

/* ------------------------------------------------------------------------- *
 * Typedefs
 * ------------------------------------------------------------------------- */

#define COM_METHOD	HRESULT STDMETHODCALLTYPE

/* ------------------------------------------------------------------------- *
 * Base class
 * ------------------------------------------------------------------------- */

class CAbout : public ISnapinAbout
{
public: 
    SIZE_T      m_refCount;
    HBITMAP     m_hSmallImage;
    HBITMAP     m_hLargeImage;
    HBITMAP     m_hSmallImageOpen;
    HICON       m_hAppIcon;

    CAbout();
    virtual ~CAbout();

    //-----------------------------------------------------------
    // IUnknown support
    //-----------------------------------------------------------
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long        refCount = InterlockedDecrement((long *) &m_refCount);
        if (refCount == 0) delete this;
        return (refCount);
    }

	COM_METHOD QueryInterface(REFIID id, void **pInterface)
	{
		if (id == IID_ISnapinAbout)
			*pInterface = (ISnapinAbout*)this;
		else if (id == IID_IUnknown)
			*pInterface = (IUnknown*)(ISnapinAbout*)this;
		else
		{
			*pInterface = NULL;
			return E_NOINTERFACE;
		}

		AddRef();
		return S_OK;
	}
    //-----------------------------------------------------------
    // CAbout support
    //-----------------------------------------------------------
    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        if (id != IID_IUnknown && id != IID_ISnapinAbout)
            return (E_NOINTERFACE);

        CAbout *pAbt = new CAbout();

        if (pAbt == NULL)
            return (E_OUTOFMEMORY);

        *object = (ISnapinAbout*)pAbt;
        pAbt->AddRef();

        return (S_OK);
    }
    STDMETHODIMP GetSnapinDescription( 
                           /* [out] */ LPOLESTR *lpDescription);
    STDMETHODIMP GetProvider( 
                           /* [out] */ LPOLESTR *lpName);
    STDMETHODIMP GetSnapinVersion( 
                           /* [out] */ LPOLESTR *lpVersion);
    STDMETHODIMP GetSnapinImage( 
                           /* [out] */ HICON *hAppIcon);
    STDMETHODIMP GetStaticFolderImage( 
                           /* [out] */ HBITMAP *hSmallImage,
                           /* [out] */ HBITMAP *hSmallImageOpen,
                           /* [out] */ HBITMAP *hLargeImage,
                           /* [out] */ COLORREF *cMask);
};

#endif /* CABOUT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\makefile.inc ===
!if "$(LINKONLY)" == "1"


PlaceDll:
# The following binplace is commented out because we don't want RTM version in Everett target dir
!if "$(TARGETCOMPLUS)" != ""
       binplace -e -r $(TARGETCOMPLUS) -p placefil.txt $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscormmc.dll $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscormmc.pdb
       copy mscormmc.cfg $(TARGETCOMPLUS)
       copy mscorcfg.vrg $(TARGETCOMPLUS)
!endif
RegisterThisDll: $(CORLIBS)\mscormmc.lib 
!if "$(TARGETCOMPLUS)" != ""
	regsvr32 /s /c $(TARGETCOMPLUS)\mscormmc.dll
!else
	regsvr32 /s /c $(CORLIBS)\mscormmc.dll
!endif
CopyAdditionalBits:        

!else

RegisterThisDll: 
PlaceDll:
CopyAdditionalBits:        

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\cabout.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: CAbout.h - header file for MMC snapin About info
//
//*****************************************************************************

#ifndef CABOUT_H_
#define CABOUT_H_

#include <UtilCode.h>
#include <CorError.h>

#include "cor.h"
#include <cordbpriv.h>
#include "mscormmc.h"

/* ------------------------------------------------------------------------- *
 * Forward class declarations
 * ------------------------------------------------------------------------- */

class CAbout;

/* ------------------------------------------------------------------------- *
 * Typedefs
 * ------------------------------------------------------------------------- */

#define COM_METHOD	HRESULT STDMETHODCALLTYPE

/* ------------------------------------------------------------------------- *
 * Base class
 * ------------------------------------------------------------------------- */

class CAbout : public ISnapinAbout
{
public: 
    SIZE_T      m_refCount;
    HBITMAP     m_hSmallImage;
    HBITMAP     m_hLargeImage;
    HBITMAP     m_hSmallImageOpen;
    HICON       m_hAppIcon;

    CAbout();
    virtual ~CAbout();

    //-----------------------------------------------------------
    // IUnknown support
    //-----------------------------------------------------------
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long        refCount = InterlockedDecrement((long *) &m_refCount);
        if (refCount == 0) delete this;
        return (refCount);
    }

	COM_METHOD QueryInterface(REFIID id, void **pInterface)
	{
		if (id == IID_ISnapinAbout)
			*pInterface = (ISnapinAbout*)this;
		else if (id == IID_IUnknown)
			*pInterface = (IUnknown*)(ISnapinAbout*)this;
		else
		{
			*pInterface = NULL;
			return E_NOINTERFACE;
		}

		AddRef();
		return S_OK;
	}
    //-----------------------------------------------------------
    // CAbout support
    //-----------------------------------------------------------
    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        if (id != IID_IUnknown && id != IID_ISnapinAbout)
            return (E_NOINTERFACE);

        CAbout *pAbt = new CAbout();

        if (pAbt == NULL)
            return (E_OUTOFMEMORY);

        *object = (ISnapinAbout*)pAbt;
        pAbt->AddRef();

        return (S_OK);
    }
    STDMETHODIMP GetSnapinDescription( 
                           /* [out] */ LPOLESTR *lpDescription);
    STDMETHODIMP GetProvider( 
                           /* [out] */ LPOLESTR *lpName);
    STDMETHODIMP GetSnapinVersion( 
                           /* [out] */ LPOLESTR *lpVersion);
    STDMETHODIMP GetSnapinImage( 
                           /* [out] */ HICON *hAppIcon);
    STDMETHODIMP GetStaticFolderImage( 
                           /* [out] */ HBITMAP *hSmallImage,
                           /* [out] */ HBITMAP *hSmallImageOpen,
                           /* [out] */ HBITMAP *hLargeImage,
                           /* [out] */ COLORREF *cMask);
};

#endif /* CABOUT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\mscormmc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//*****************************************************************************
// Dllmain.cpp
//
//*****************************************************************************

#include "stdafx.h"                     // Standard header.
#define INIT_GUIDS

#include <mscoree.h>
#include <corperm.h>
#include <resource.h>
#include <corcompile.h>
#include <gchost.h>
#include "corpriv.h"

#include "..\shimr\msg.h"
#include <version\__file__.ver>
#include <version\__product__.ver>
// {9F6932F1-4A16-49D0-9CCA-0DCC977C41AA}
const GUID IID_CAbout =
{ 0x9F6932F1, 0x4A16, 0x49D0, { 0x9C, 0xCA, 0x0D, 0xCC, 0x97, 0x7C, 0x41, 0xAA } };
// {18BA7139-D98B-43C2-94DA-2604E34E175D}
const GUID IID_CData =
{ 0x18BA7139, 0xD98B, 0x43C2, { 0x94, 0xDA, 0x26, 0x04, 0xE3, 0x4E, 0x17, 0x5D } };
// {E07A1EB4-B9EA-3D7D-AC50-2BA0548188AC}
const GUID IID_CCommandHistory =
{ 0xE07A1EB4, 0xB9EA, 0x3D7D, { 0xAC, 0x50, 0x2B, 0xA0, 0x54, 0x81, 0x88, 0xAC } };
// {ABBB93E8-0809-38F7-AEC7-6BB938BB0570}
const GUID IID_CWizardPage =
{ 0xABBB93E8, 0x0809, 0x38F7, { 0xAE, 0xC7, 0x6B, 0xB9, 0x38, 0xBB, 0x05, 0x70 } };
// {48AA163A-93C3-30DF-B209-99CE04D4FF2D}
const GUID IID_CDataGridComboBox =
{ 0x48AA163A, 0x93C3, 0x30DF, { 0xB2, 0x09, 0x99, 0xCE, 0x04, 0xD4, 0xFF, 0x2D } };
// {67283557-1256-3349-A135-055B16327CED}
const GUID IID_CDataGridComboBoxColumnStyle =
{ 0x67283557, 0x1256, 0x3349, { 0xA1, 0x35, 0x05, 0x5B, 0x16, 0x32, 0x7C, 0xED } };
// {6A0162ED-4609-3A31-B89F-D590CCF75833}
const GUID IID_MMC_BUTTON_STATE =
{ 0x6A0162ED, 0x4609, 0x3A31, { 0xB8, 0x9F, 0xD5, 0x90, 0xCC, 0xF7, 0x58, 0x33 } };
// {3024B989-5633-39E8-B5F4-93A5D510CF99}
const GUID IID_MMC_PSO =
{ 0x3024B989, 0x5633, 0x39E8, { 0xB5, 0xF4, 0x93, 0xA5, 0xD5, 0x10, 0xCF, 0x99 } };
// {47FDDA97-D41E-3646-B2DD-5ECF34F76842}
const GUID IID_MMCN =
{ 0x47FDDA97, 0xD41E, 0x3646, { 0xB2, 0xDD, 0x5E, 0xCF, 0x34, 0xF7, 0x68, 0x42 } };

#include "CAbout.h"

#include "ClassFactory.h"
#include <mscormmc_i.c>

STDAPI DllUnregisterServer(void);

//********** Globals. *********************************************************
static const LPCWSTR g_szCoclassDesc    = L"CLR Admin Snapin About Info";
static const LPCWSTR g_szProgIDPrefix   = L"Microsoft.CLRAdmin";
static const LPCWSTR g_szThreadingModel = L"Both";
const int       g_iVersion = 1;         // Version of coclasses.
// This map contains the list of coclasses which are exported from this module.
const COCLASS_REGISTER g_CoClasses[] =
{
//  pClsid              szProgID            pfnCreateObject
    &IID_CAbout,        L"CAbout",          CAbout::CreateObject,
    &IID_CData,         L"CData",           NULL, // provided through runtime
    &IID_CCommandHistory,L"CCommandHistory",NULL, // provided through runtime
    &IID_CWizardPage,   L"CWizardPage",     NULL, // provided through runtime
    &IID_CDataGridComboBox,L"CDataGridComboBox",NULL, // provided through runtime
    &IID_CDataGridComboBoxColumnStyle,L"CDataGridComboBoxColumnStyle",NULL, // provided through runtime
    &IID_MMC_BUTTON_STATE,L"MMC_BUTTON_STATE",NULL, // provided through runtime
    &IID_MMC_PSO,       L"MMC_PSO",         NULL, // provided through runtime
    &IID_MMCN,          L"MMCN",            NULL, // provided through runtime
    NULL,               NULL,               NULL
};
ICorRuntimeHost* g_pCorHost=NULL;
HINSTANCE        g_hCOR=NULL;
HINSTANCE        g_hThis = NULL;
WCHAR g_wzRuntime[MAX_PATH];// = VER_PRODUCTVERSION_WSTR; //L"v1.x86chk";
WCHAR g_wzConfig[MAX_PATH];
HRESULT GetRuntime()
{
    HRESULT hr = S_OK;
    if(g_hCOR == NULL)
    {
        if(g_pCorHost == NULL)
        {
            if(!WszGetModuleFileName(g_hThis,g_wzRuntime,MAX_PATH)) return E_FAIL;
            WCHAR* pwc = wcsrchr(g_wzRuntime,'\\');
            if(pwc)
            {
                *pwc = 0;
                wcscpy(g_wzConfig,g_wzRuntime);
                wcscat(g_wzConfig,L"\\mscormmc.cfg");
                pwc = wcsrchr(g_wzRuntime,'\\');
                if(pwc)
                {
                    wcscpy(g_wzRuntime,pwc+1);
                }
            }

            hr = CorBindToRuntimeHost(g_wzRuntime, //L"v1.0.3705",//g_wzRuntime,                      // Version
                                      NULL,                             // Don't care (defaults to wks)
                                      g_wzConfig,
                                      NULL,                             // Reserved
                                      STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST,  // Startup flags
                                      CLSID_CorRuntimeHost, 
                                      IID_ICorRuntimeHost, 
                                      (void**)&g_pCorHost);  // Clsid, interface and return
            if(hr == S_FALSE) // Runtime has already been loaded!
            {
                WCHAR wzLoadedVersion[MAX_PATH];
                DWORD dw;
                if(SUCCEEDED(hr=GetCORVersion(wzLoadedVersion,MAX_PATH,&dw)))
                {
                    if(wcscmp(g_wzRuntime,wzLoadedVersion))
                    {
                        WCHAR wzErrorString[MAX_PATH<<1];
                        WCHAR wzErrorCaption[MAX_PATH];
                        WszLoadString(g_hThis, IDS_CANTLOADRT, wzErrorString, MAX_PATH<<1);      //Get error string from resource
                        wcscat(wzErrorString,wzLoadedVersion);
                        WszLoadString(g_hThis, IDS_RTVERCONFLICT, wzErrorCaption, MAX_PATH); //Get caption from resource
                        WszMessageBoxInternal(NULL,wzErrorString,
                                wzErrorCaption,MB_OK|MB_ICONERROR);
                        hr = E_FAIL;
                    }
                }
            }

        }
        if (SUCCEEDED(hr)) 
        {
            g_hCOR = WszLoadLibrary(L"mscoree.dll");
            if(g_hCOR == NULL)
                hr = HRESULT_FROM_WIN32(GetLastError());
            else hr = S_OK;
        }
    }
    return hr;
}

//-------------------------------------------------------------------
// DllCanUnloadNow
//-------------------------------------------------------------------
HRESULT (STDMETHODCALLTYPE* pDllCanUnloadNow)() = NULL;
STDAPI DllCanUnloadNow(void)
{
    if(pDllCanUnloadNow) return (*pDllCanUnloadNow)();
    //!! Do not trigger a GetRealDll() here! Ole can call this at any time
    //!! and we don't want to commit to a selection here!
    if (g_hCOR)
    {
        pDllCanUnloadNow = (HRESULT (STDMETHODCALLTYPE* )())GetProcAddress(g_hCOR, "DllCanUnloadNowInternal");
        if (pDllCanUnloadNow) return (*pDllCanUnloadNow)();
    }
    return S_OK;
  // If mscoree not loaded return S_OK
}  


//-------------------------------------------------------------------
// DllMain
//-------------------------------------------------------------------
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    g_hThis = (HINSTANCE)hInstance;

#ifdef _X86_
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Check to see if we are running on 386 systems. If yes return false 
        SYSTEM_INFO sysinfo;

        GetSystemInfo(&sysinfo);

        if (sysinfo.dwProcessorType == PROCESSOR_INTEL_386 || sysinfo.wProcessorLevel == 3 )
            return FALSE;           // If the processor is 386 return false

        OnUnicodeSystem();
    }
    else
#endif // _X86_

    if (dwReason == DLL_PROCESS_DETACH)
    {
    }
    return TRUE;
}


//-------------------------------------------------------------------
// DllGetClassObject
//-------------------------------------------------------------------
HRESULT (STDMETHODCALLTYPE * pDllGetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv) = NULL;
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv)
{
    HRESULT     hr = CLASS_E_CLASSNOTAVAILABLE;

    if(rclsid == IID_CAbout)
    {
        CClassFactory *pClassFactory;       // To create class factory object.
        const COCLASS_REGISTER *pCoClass;   // Loop control.
        // Scan for the right one.
        for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
        {
            if (*pCoClass->pClsid == rclsid)
            {
                // Allocate the new factory object.
                pClassFactory = new CClassFactory(pCoClass);
                if (!pClassFactory)
                    return (E_OUTOFMEMORY);
    
                // Pick the v-table based on the caller's request.
                hr = pClassFactory->QueryInterface(riid, ppv);
    
                // Always release the local reference, if QI failed it will be
                // the only one and the object gets freed.
                pClassFactory->Release();
                break;
            }
        }
    }
    else
    {
        if(pDllGetClassObject) hr = (*pDllGetClassObject)(rclsid,riid,ppv);
        else
        {
            if(SUCCEEDED(hr=GetRuntime()))
            {
                pDllGetClassObject = (HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(g_hCOR, "DllGetClassObject");
                hr = (pDllGetClassObject) ? (*pDllGetClassObject)(rclsid,riid,ppv) 
                                            : CLR_E_SHIM_RUNTIMEEXPORT;
            }
        }
    }
    return hr;
}

//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
HRESULT (STDMETHODCALLTYPE * pDllRegisterServer)() = NULL;
STDAPI DllRegisterServer()
{
    HRESULT hr;
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    WCHAR       rcModule[_MAX_PATH];    // This server's module name.

    // Init the Win32 wrappers.
    OnUnicodeSystem();

    // Erase all doubt from old entries.
    DllUnregisterServer();

    // Get the filename for this module.
    WszGetModuleFileName(g_hThis, rcModule, NumItems(rcModule));

    if(SUCCEEDED(hr = GetRuntime()))
    {
        // For each item in the coclass list, register it.
        for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
        {
            // Register the class with default values.
            if (FAILED(hr = REGUTIL::RegisterCOMClass(
                    *pCoClass->pClsid, 
                    g_szCoclassDesc, 
                    g_szProgIDPrefix,
                    g_iVersion, 
                    pCoClass->szProgID, 
                    g_szThreadingModel, 
                    rcModule,
                    g_hThis,
                    NULL,
                    g_wzRuntime,
                    false, //true,
                    false)))
            {
                DllUnregisterServer();
                break;
            }
        }
    
        if(pDllRegisterServer) hr = (*pDllRegisterServer)();
        else
        {
            pDllRegisterServer = (HRESULT (STDMETHODCALLTYPE *)())GetProcAddress(g_hCOR, "DllRegisterServer");
            hr = (pDllRegisterServer) ? (*pDllRegisterServer)()
                                        : CLR_E_SHIM_RUNTIMEEXPORT;
        }
    }
    return hr;
}


//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
HRESULT (STDMETHODCALLTYPE* pDllUnregisterServer)() = NULL;
STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    const COCLASS_REGISTER *pCoClass;   // Loop control.

    if(pDllUnregisterServer) hr = (*pDllUnregisterServer)();
    else
    {
        if(SUCCEEDED(hr=GetRuntime()))
        {
            pDllUnregisterServer = (HRESULT (STDMETHODCALLTYPE *)())GetProcAddress(g_hCOR, "DllUnregisterServerInternal");
            hr = (pDllUnregisterServer) ? (*pDllUnregisterServer)()
                                        : CLR_E_SHIM_RUNTIMEEXPORT;
        }
    }
    // For each item in the coclass list, unregister it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        REGUTIL::UnregisterCOMClass(*pCoClass->pClsid, g_szProgIDPrefix,
                    g_iVersion, pCoClass->szProgID, true);
    }
    return hr;
}

//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface( 
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;

    // Pick the right v-table based on the IID passed in.
    if (riid == IID_IUnknown)
        *ppvObject = (IUnknown *) this;
    else if (riid == IID_IClassFactory)
        *ppvObject = (IClassFactory *) this;

    // If successful, add a reference for out pointer and return.
    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;
    return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance( 
    IUnknown    *pUnkOuter,
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;
    _ASSERTE(m_pCoClass);

    // Aggregation is not supported by these objects.
    //if (pUnkOuter)
    //    return (CLASS_E_NOAGGREGATION);

    // Ask the object to create an instance of itself, and check the iid.
    hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
    return (hr);
}


HRESULT STDMETHODCALLTYPE CClassFactory::LockServer( 
    BOOL        fLock)
{
    return (S_OK);
}
//*****************************************************************************
//
//********** CAbout methods implementation.
//
//*****************************************************************************
STDMETHODIMP AllocOleStr(LPOLESTR* lpOle, WCHAR* wz)
{
    HRESULT hr = E_FAIL;
    if(lpOle && wz)
    {
        *lpOle = (LPOLESTR)CoTaskMemAlloc((ULONG)((wcslen(wz)+1)*sizeof(WCHAR)));
        if(*lpOle)
        {

            //USES_CONVERSION;
            wcscpy((WCHAR*)(*lpOle),wz);
            hr = S_OK;
        }
    }
    return hr;
}
STDMETHODIMP CAbout::GetSnapinDescription( 
                           /* [out] */ LPOLESTR *lpDescription)
{
    WCHAR wzDesc[MAX_PATH];
    
    WszLoadString(g_hThis, IDS_SNAPINDESC, wzDesc,MAX_PATH);
    return AllocOleStr(lpDescription, wzDesc);
}
STDMETHODIMP CAbout::GetProvider( 
                           /* [out] */ LPOLESTR *lpName)
{
    WCHAR wzProv[MAX_PATH];
   
    WszLoadString(g_hThis, IDS_SNAPINPROVIDER, wzProv,MAX_PATH); 
    return AllocOleStr(lpName, wzProv);
}

STDMETHODIMP CAbout::GetSnapinVersion( 
                           /* [out] */ LPOLESTR *lpVersion)
{
    WCHAR wzVer[MAX_PATH];
   
    WszLoadString(g_hThis, IDS_SNAPINVERSION, wzVer,MAX_PATH); 
    return AllocOleStr(lpVersion, wzVer);
}
STDMETHODIMP CAbout::GetSnapinImage( 
                           /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}

STDMETHODIMP CAbout::GetStaticFolderImage( 
                           /* [out] */ HBITMAP *hSmallImage,
                           /* [out] */ HBITMAP *hSmallImageOpen,
                           /* [out] */ HBITMAP *hLargeImage,
                           /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(255, 255, 255);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || 
         *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}
CAbout::CAbout(): m_refCount(0)
{
        
    m_hSmallImage =     (HBITMAP)LoadImageA(g_hThis, 
                        MAKEINTRESOURCEA(IDB_NETICON), IMAGE_BITMAP, 16, 
                        16, LR_LOADTRANSPARENT);
    m_hLargeImage =     (HBITMAP)LoadImageA(g_hThis, 
                        MAKEINTRESOURCEA(IDB_NETICON), IMAGE_BITMAP, 32, 
                        32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImageA(g_hThis, 
                        MAKEINTRESOURCEA(IDB_NETICON), IMAGE_BITMAP, 16, 
                        16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIconA(g_hThis, MAKEINTRESOURCEA(IDI_ICON1));
}

CAbout::~CAbout()
{
        
    DeleteObject((HGDIOBJ)m_hSmallImage);
    DeleteObject((HGDIOBJ)m_hLargeImage);
    DeleteObject((HGDIOBJ)m_hSmallImageOpen);
    DestroyIcon(m_hAppIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __ClassFactory__h__
#define __ClassFactory__h__

//#include <cordb.h>						// Public header definitions.


// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};



//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class CClassFactory :
	public IClassFactory
{
	CClassFactory() { }						// Can't use without data.
	
public:
	CClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	
	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}


	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);


private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};



#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#define _CRTIMP 
#include <winwrap.h>                    // Windows wrappers.
#include <utilcode.h>

#include <ole2.h>						// OLE definitions
#include "oledb.h"						// OLE DB headers.
#include "oledberr.h"					// OLE DB Error messages.
#include "msdadc.h"						// Data type conversion service.

#define _COMPLIB_GUIDS_


#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED
#undef _WINGDI_


#include "Intrinsic.h"					// Functions to make intrinsic.


// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORMMC.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Execution Engine Starter for MMC\0"
#define VER_ORIGFILENAME_STR    "mscormmc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define SHIM_INSTALLROOT                1
#define SHIM_INITERROR                  2
#define SHIM_PATHNOTFOUND				3
#define SHIM_LATESTVERSION				4
// Next default values for new objects
// 
#define IDB_NETICON                     10
#define IDI_ICON1                       20
#define IDS_SNAPINDESC                  30
#define IDS_SNAPINPROVIDER              31
#define IDS_SNAPINVERSION               32
#define IDS_CANTLOADRT                  33
#define IDS_RTVERCONFLICT               34

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#define _CRTIMP 
#include <winwrap.h>                    // Windows wrappers.
#include <utilcode.h>

#include <ole2.h>						// OLE definitions
#include "oledb.h"						// OLE DB headers.
#include "oledberr.h"					// OLE DB Error messages.
#include "msdadc.h"						// Data type conversion service.

#define _COMPLIB_GUIDS_


#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED
#undef _WINGDI_


#include "Intrinsic.h"					// Functions to make intrinsic.


// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\makefile.inc ===
!if "$(LINKONLY)" == "1"


PlaceDll:
!if "$(TARGETCOMPLUS)" != ""
        binplace -e -r $(TARGETCOMPLUS) -p placefil.txt $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscormmc11.dll $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscormmc11.pdb
        copy mscormmc11.cfg $(TARGETCOMPLUS)
        copy mscorcfg11.vrg $(TARGETCOMPLUS)
!endif
RegisterThisDll: $(CORLIBS)\mscormmc11.lib 
!if "$(TARGETCOMPLUS)" != ""
	regsvr32 /s /c $(TARGETCOMPLUS)\mscormmc11.dll
!else
	regsvr32 /s /c $(CORLIBS)\mscormmc11.dll
!endif
CopyAdditionalBits:        

!else

RegisterThisDll: 
PlaceDll:
CopyAdditionalBits:        

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoroc\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define SHIM_INSTALLROOT                1
#define SHIM_INITERROR                  2
#define SHIM_PATHNOTFOUND				3
#define SHIM_LATESTVERSION				4
// Next default values for new objects
// 
#define IDB_NETICON                     10
#define IDI_ICON1                       20
#define IDS_SNAPINNAME                  30
#define IDS_SNAPINDESC                  31
#define IDS_SNAPINPROVIDER              32
#define IDS_SNAPINVERSION               33
#define IDS_CANTLOADRT                  34
#define IDS_RTVERCONFLICT               35

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\mscormmc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//*****************************************************************************
// Dllmain.cpp
//
//*****************************************************************************

#include "stdafx.h"                     // Standard header.
#define INIT_GUIDS

#include <mscoree.h>
#include <corperm.h>
#include <resource.h>
#include <corcompile.h>
#include <gchost.h>
#include "corpriv.h"

#include "..\shimr\msg.h"
#include <version\__file__.ver>
#include <version\__product__.ver>
// {0b0d1ec3-c33b-454e-a530-dccd3660c4ca}
const GUID IID_CAbout =
{ 0x0b0d1ec3, 0xc33b, 0x454e, { 0xA5, 0x30, 0xDC, 0xCD, 0x36, 0x60, 0xC4, 0xCA } };
// {1270e004-f895-42be-8070-df90d60cbb75}
const GUID IID_CData =
{ 0x1270e004, 0xf895, 0x42be, { 0x80, 0x70, 0xDF, 0x90, 0xD6, 0x0C, 0xBB, 0x75 } };
// {04B1A7E3-4379-39D2-B003-57AF524D9AC5}
const GUID IID_CCommandHistory =
{ 0x04B1A7E3, 0x4379, 0x39D2, { 0xB0, 0x03, 0x57, 0xAF, 0x52, 0x4D, 0x9A, 0xC5 } };
// {1AC66142-6805-3C20-A589-49CC6B80E8FB}
const GUID IID_CWizardPage =
{ 0x1AC66142, 0x6805, 0x3C20, { 0xA5, 0x89, 0x49, 0xCC, 0x6B, 0x80, 0xE8, 0xFB } };
// {32B05DEB-DF56-3100-9EFC-599AD8700CCA}
const GUID IID_CDataGridComboBox =
{ 0x32B05DEB, 0xDF56, 0x3100, { 0x9E, 0xFC, 0x59, 0x9A, 0xD8, 0x70, 0x0C, 0xCA } };
// {20CC3E1F-95D8-3848-9109-5C9E43E8144E}
const GUID IID_CDataGridComboBoxColumnStyle =
{ 0x20CC3E1F, 0x95D8, 0x3848, { 0x91, 0x09, 0x5C, 0x9E, 0x43, 0xE8, 0x14, 0x4E } };
// {F22DD1A2-9695-3B41-B05E-585E33560EC1}
const GUID IID_MMC_BUTTON_STATE =
{ 0xF22DD1A2, 0x9695, 0x3B41, { 0xB0, 0x5E, 0x58, 0x5E, 0x33, 0x56, 0x0E, 0xC1 } };
// {E40C24F9-78A9-3791-94F8-03BC9F97CCE5}
const GUID IID_MMC_PSO =
{ 0xE40C24F9, 0x78A9, 0x3791, { 0x94, 0xF8, 0x03, 0xBC, 0x9F, 0x97, 0xCC, 0xE5 } };
// {BE42CA69-{ 0x9F6932F1, 0x4A16, 0x49D0, { 0x9C, 0xCA, 0x0D, 0xCC, 0x97, 0x7C, 0x41, 0xAA } };
const GUID IID_MMCN =
{ 0xBE42CA69, 0xD9DB, 0x3676, { 0x86, 0xC0, 0xB4, 0x34, 0x7D, 0xB0, 0xAB, 0x41 } };

#include "CAbout.h"

#include "ClassFactory.h"
#include <mscormmc_i.c>

STDAPI DllUnregisterServer(void);

//********** Globals. *********************************************************
static const LPCWSTR g_szCoclassDesc    = L"CLR Admin Snapin About Info";
static const LPCWSTR g_szProgIDPrefix   = L"Microsoft.CLRAdmin";
static const LPCWSTR g_szThreadingModel = L"Both";
const int       g_iVersion = 1;         // Version of coclasses.
// This map contains the list of coclasses which are exported from this module.
const COCLASS_REGISTER g_CoClasses[] =
{
//  pClsid              szProgID            pfnCreateObject
    &IID_CAbout,        L"CAbout",          CAbout::CreateObject,
    &IID_CData,         L"CData",           NULL, // provided through runtime
    &IID_CCommandHistory,L"CCommandHistory",NULL, // provided through runtime
    &IID_CWizardPage,   L"CWizardPage",     NULL, // provided through runtime
    &IID_CDataGridComboBox,L"CDataGridComboBox",NULL, // provided through runtime
    &IID_CDataGridComboBoxColumnStyle,L"CDataGridComboBoxColumnStyle",NULL, // provided through runtime
    &IID_MMC_BUTTON_STATE,L"MMC_BUTTON_STATE",NULL, // provided through runtime
    &IID_MMC_PSO,       L"MMC_PSO",         NULL, // provided through runtime
    &IID_MMCN,          L"MMCN",            NULL, // provided through runtime
    NULL,               NULL,               NULL
};
ICorRuntimeHost* g_pCorHost=NULL;
HINSTANCE        g_hCOR=NULL;
HINSTANCE        g_hThis = NULL;
WCHAR g_wzRuntime[MAX_PATH];// = VER_PRODUCTVERSION_WSTR; //L"v1.x86chk";
WCHAR g_wzConfig[MAX_PATH];
HRESULT GetRuntime()
{
    HRESULT hr = S_OK;
    if(g_hCOR == NULL)
    {
        if(g_pCorHost == NULL)
        {
            if(!WszGetModuleFileName(g_hThis,g_wzRuntime,MAX_PATH)) return E_FAIL;
            WCHAR* pwc = wcsrchr(g_wzRuntime,'\\');
            if(pwc)
            {
                *pwc = 0;
                wcscpy(g_wzConfig,g_wzRuntime);
                wcscat(g_wzConfig,L"\\mscormmc11.cfg");
                pwc = wcsrchr(g_wzRuntime,'\\');
                if(pwc)
                {
                    wcscpy(g_wzRuntime,pwc+1);
                }
            }

            hr = CorBindToRuntimeHost(g_wzRuntime, //L"v1.0.3705",//g_wzRuntime,                      // Version
                                      NULL,                             // Don't care (defaults to wks)
                                      g_wzConfig,
                                      NULL,                             // Reserved
                                      STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST,  // Startup flags
                                      CLSID_CorRuntimeHost, 
                                      IID_ICorRuntimeHost, 
                                      (void**)&g_pCorHost);  // Clsid, interface and return
            if(hr == S_FALSE) // Runtime has already been loaded!
            {
                WCHAR wzLoadedVersion[MAX_PATH];
                DWORD dw;
                if(SUCCEEDED(hr=GetCORVersion(wzLoadedVersion,MAX_PATH,&dw)))
                {
                    if(wcscmp(g_wzRuntime,wzLoadedVersion))
                    {
                        WCHAR wzErrorString[MAX_PATH<<1];
                        WCHAR wzErrorCaption[MAX_PATH];
                        WszLoadString(g_hThis, IDS_CANTLOADRT, wzErrorString, MAX_PATH<<1);      //Get error string from resource
                        wcscat(wzErrorString,wzLoadedVersion);
                        WszLoadString(g_hThis, IDS_RTVERCONFLICT, wzErrorCaption, MAX_PATH); //Get caption from resource
                        WszMessageBoxInternal(NULL,wzErrorString,
                                wzErrorCaption,MB_OK|MB_ICONERROR);
                        hr = E_FAIL;
                    }
                }
            }

        }
        if (SUCCEEDED(hr)) 
        {
            g_hCOR = WszLoadLibrary(L"mscoree.dll");
            if(g_hCOR == NULL)
                hr = HRESULT_FROM_WIN32(GetLastError());
            else hr = S_OK;
        }
    }
    return hr;
}

//-------------------------------------------------------------------
// DllCanUnloadNow
//-------------------------------------------------------------------
HRESULT (STDMETHODCALLTYPE* pDllCanUnloadNow)() = NULL;
STDAPI DllCanUnloadNow(void)
{
    if(pDllCanUnloadNow) return (*pDllCanUnloadNow)();
    //!! Do not trigger a GetRealDll() here! Ole can call this at any time
    //!! and we don't want to commit to a selection here!
    if (g_hCOR)
    {
        pDllCanUnloadNow = (HRESULT (STDMETHODCALLTYPE* )())GetProcAddress(g_hCOR, "DllCanUnloadNowInternal");
        if (pDllCanUnloadNow) return (*pDllCanUnloadNow)();
    }
    return S_OK;
  // If mscoree not loaded return S_OK
}  


//-------------------------------------------------------------------
// DllMain
//-------------------------------------------------------------------
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    g_hThis = (HINSTANCE)hInstance;

#ifdef _X86_
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Check to see if we are running on 386 systems. If yes return false 
        SYSTEM_INFO sysinfo;

        GetSystemInfo(&sysinfo);

        if (sysinfo.dwProcessorType == PROCESSOR_INTEL_386 || sysinfo.wProcessorLevel == 3 )
            return FALSE;           // If the processor is 386 return false

        OnUnicodeSystem();
    }
    else
#endif // _X86_

    if (dwReason == DLL_PROCESS_DETACH)
    {
    }
    return TRUE;
}


//-------------------------------------------------------------------
// DllGetClassObject
//-------------------------------------------------------------------
HRESULT (STDMETHODCALLTYPE * pDllGetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv) = NULL;
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv)
{
    HRESULT     hr = CLASS_E_CLASSNOTAVAILABLE;

    if(rclsid == IID_CAbout)
    {
        CClassFactory *pClassFactory;       // To create class factory object.
        const COCLASS_REGISTER *pCoClass;   // Loop control.
        // Scan for the right one.
        for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
        {
            if (*pCoClass->pClsid == rclsid)
            {
                // Allocate the new factory object.
                pClassFactory = new CClassFactory(pCoClass);
                if (!pClassFactory)
                    return (E_OUTOFMEMORY);
    
                // Pick the v-table based on the caller's request.
                hr = pClassFactory->QueryInterface(riid, ppv);
    
                // Always release the local reference, if QI failed it will be
                // the only one and the object gets freed.
                pClassFactory->Release();
                break;
            }
        }
    }
    else
    {
        if(pDllGetClassObject) hr = (*pDllGetClassObject)(rclsid,riid,ppv);
        else
        {
            if(SUCCEEDED(hr=GetRuntime()))
            {
                pDllGetClassObject = (HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(g_hCOR, "DllGetClassObject");
                hr = (pDllGetClassObject) ? (*pDllGetClassObject)(rclsid,riid,ppv) 
                                            : CLR_E_SHIM_RUNTIMEEXPORT;
            }
        }
    }
    return hr;
}

//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
HRESULT (STDMETHODCALLTYPE * pDllRegisterServer)() = NULL;
STDAPI DllRegisterServer()
{
    HRESULT hr;
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    WCHAR       rcModule[_MAX_PATH];    // This server's module name.

    // Init the Win32 wrappers.
    OnUnicodeSystem();

    // Erase all doubt from old entries.
    DllUnregisterServer();

    // Get the filename for this module.
    WszGetModuleFileName(g_hThis, rcModule, NumItems(rcModule));

    if(SUCCEEDED(hr = GetRuntime()))
    {
        // For each item in the coclass list, register it.
        for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
        {
            // Register the class with default values.
            if (FAILED(hr = REGUTIL::RegisterCOMClass(
                    *pCoClass->pClsid, 
                    g_szCoclassDesc, 
                    g_szProgIDPrefix,
                    g_iVersion, 
                    pCoClass->szProgID, 
                    g_szThreadingModel, 
                    rcModule,
                    g_hThis,
                    NULL,
                    g_wzRuntime,
                    false, //true,
                    false)))
            {
                DllUnregisterServer();
                break;
            }
        }
    
        if(pDllRegisterServer) hr = (*pDllRegisterServer)();
        else
        {
            pDllRegisterServer = (HRESULT (STDMETHODCALLTYPE *)())GetProcAddress(g_hCOR, "DllRegisterServer");
            hr = (pDllRegisterServer) ? (*pDllRegisterServer)()
                                        : CLR_E_SHIM_RUNTIMEEXPORT;
        }
    }
    return hr;
}


//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
HRESULT (STDMETHODCALLTYPE* pDllUnregisterServer)() = NULL;
STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    const COCLASS_REGISTER *pCoClass;   // Loop control.

    if(pDllUnregisterServer) hr = (*pDllUnregisterServer)();
    else
    {
        if(SUCCEEDED(hr=GetRuntime()))
        {
            pDllUnregisterServer = (HRESULT (STDMETHODCALLTYPE *)())GetProcAddress(g_hCOR, "DllUnregisterServerInternal");
            hr = (pDllUnregisterServer) ? (*pDllUnregisterServer)()
                                        : CLR_E_SHIM_RUNTIMEEXPORT;
        }
    }
    // For each item in the coclass list, unregister it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        REGUTIL::UnregisterCOMClass(*pCoClass->pClsid, g_szProgIDPrefix,
                    g_iVersion, pCoClass->szProgID, true);
    }
    return hr;
}

//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface( 
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;

    // Pick the right v-table based on the IID passed in.
    if (riid == IID_IUnknown)
        *ppvObject = (IUnknown *) this;
    else if (riid == IID_IClassFactory)
        *ppvObject = (IClassFactory *) this;

    // If successful, add a reference for out pointer and return.
    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;
    return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance( 
    IUnknown    *pUnkOuter,
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;
    _ASSERTE(m_pCoClass);

    // Aggregation is not supported by these objects.
    //if (pUnkOuter)
    //    return (CLASS_E_NOAGGREGATION);

    // Ask the object to create an instance of itself, and check the iid.
    hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
    return (hr);
}


HRESULT STDMETHODCALLTYPE CClassFactory::LockServer( 
    BOOL        fLock)
{
    return (S_OK);
}
//*****************************************************************************
//
//********** CAbout methods implementation.
//
//*****************************************************************************
STDMETHODIMP AllocOleStr(LPOLESTR* lpOle, WCHAR* wz)
{
    HRESULT hr = E_FAIL;
    if(lpOle && wz)
    {
        *lpOle = (LPOLESTR)CoTaskMemAlloc((ULONG)((wcslen(wz)+1)*sizeof(WCHAR)));
        if(*lpOle)
        {

            //USES_CONVERSION;
            wcscpy((WCHAR*)(*lpOle),wz);
            hr = S_OK;
        }
    }
    return hr;
}
STDMETHODIMP CAbout::GetSnapinDescription( 
                           /* [out] */ LPOLESTR *lpDescription)
{
    WCHAR wzDesc[MAX_PATH];
    
    WszLoadString(g_hThis, IDS_SNAPINDESC, wzDesc,MAX_PATH);
    return AllocOleStr(lpDescription, wzDesc);
}
STDMETHODIMP CAbout::GetProvider( 
                           /* [out] */ LPOLESTR *lpName)
{
    WCHAR wzProv[MAX_PATH];
   
    WszLoadString(g_hThis, IDS_SNAPINPROVIDER, wzProv,MAX_PATH); 
    return AllocOleStr(lpName, wzProv);
}

STDMETHODIMP CAbout::GetSnapinVersion( 
                           /* [out] */ LPOLESTR *lpVersion)
{
    WCHAR wzVer[MAX_PATH];
   
    WszLoadString(g_hThis, IDS_SNAPINVERSION, wzVer,MAX_PATH); 
    return AllocOleStr(lpVersion, wzVer);
}
STDMETHODIMP CAbout::GetSnapinImage( 
                           /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}

STDMETHODIMP CAbout::GetStaticFolderImage( 
                           /* [out] */ HBITMAP *hSmallImage,
                           /* [out] */ HBITMAP *hSmallImageOpen,
                           /* [out] */ HBITMAP *hLargeImage,
                           /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(255, 255, 255);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || 
         *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}
CAbout::CAbout(): m_refCount(0)
{
        
    m_hSmallImage =     (HBITMAP)LoadImageA(g_hThis, 
                        MAKEINTRESOURCEA(IDB_NETICON), IMAGE_BITMAP, 16, 
                        16, LR_LOADTRANSPARENT);
    m_hLargeImage =     (HBITMAP)LoadImageA(g_hThis, 
                        MAKEINTRESOURCEA(IDB_NETICON), IMAGE_BITMAP, 32, 
                        32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImageA(g_hThis, 
                        MAKEINTRESOURCEA(IDB_NETICON), IMAGE_BITMAP, 16, 
                        16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIconA(g_hThis, MAKEINTRESOURCEA(IDI_ICON1));
}

CAbout::~CAbout()
{
        
    DeleteObject((HGDIOBJ)m_hSmallImage);
    DeleteObject((HGDIOBJ)m_hLargeImage);
    DeleteObject((HGDIOBJ)m_hSmallImageOpen);
    DestroyIcon(m_hAppIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoroc\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __ClassFactory__h__
#define __ClassFactory__h__

//#include <cordb.h>						// Public header definitions.


// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};



//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class CClassFactory :
	public IClassFactory
{
	CClassFactory() { }						// Can't use without data.
	
public:
	CClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	
	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}


	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);


private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};



#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscormmc11\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORMMC11.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Execution Engine Starter for MMC\0"
#define VER_ORIGFILENAME_STR    "mscormmc11.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscornlp\mscornlp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  $/com99/src/dlls/mscornlp/MscorNLP.cpp
** Purpose: A wrapper DLL for NLS+ resource tables
** Date:    Feburary 9, 2000
** Author:  Rong Chen (rongc)
===========================================================*/
#include <windows.h>

BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    return (TRUE);
}

/*
 * Return a BYTE pointer to the beginning of a particular binary table.
 * The argument pTableName can be the following:
 *      big5.out bopomofo.out CharInfo.out ctype.out
 *      culture.out cultures.out ksc.out l_except.out
 *      l_intl.out prc.out prcp.out region.out sortkey.out
 *      sorttbls.out xjis.out
 */
LPBYTE STDMETHODCALLTYPE GetTable(LPCWSTR pTableName)
{
    if (_wcsicmp(pTableName, L"big5.nlp") == 0) {
        static BYTE big5_nlp[] = {
            #include "big5.out"
        };
        return big5_nlp;
    }

    if (_wcsicmp(pTableName, L"bopomofo.nlp") == 0) {
        static BYTE bopomofo_nlp[] = {
            #include "bopomofo.out"
        };
        return bopomofo_nlp;
    }

    if (_wcsicmp(pTableName, L"CharInfo.nlp") == 0) {
        static BYTE CharInfo_nlp[] = {
            #include "CharInfo.out"
        };
        return CharInfo_nlp;
    }

    if (_wcsicmp(pTableName, L"ctype.nlp") == 0) {
        static BYTE ctype_nlp[] = {
            #include "ctype.out"
        };
        return ctype_nlp;
    }

    if (_wcsicmp(pTableName, L"culture.nlp") == 0) {
        static BYTE culture_nlp[] = {
            #include "culture.out"
        };
        return culture_nlp;
    }

    if (_wcsicmp(pTableName, L"cultures.nlp") == 0) {
        static BYTE cultures_nlp[] = {
            #include "cultures.out"
        };
        return cultures_nlp;
    }

    if (_wcsicmp(pTableName, L"ksc.nlp") == 0) {
        static BYTE ksc_nlp[] = {
            #include "ksc.out"
        };
        return ksc_nlp;
    }

    if (_wcsicmp(pTableName, L"l_except.nlp") == 0) {
        static BYTE l_except_nlp[] = {
            #include "l_except.out"
        };
        return l_except_nlp;
    }

    if (_wcsicmp(pTableName, L"l_intl.nlp") == 0) {
        static BYTE l_intl_nlp[] = {
            #include "l_intl.out"
        };
        return l_intl_nlp;
    }

    if (_wcsicmp(pTableName, L"prc.nlp") == 0) {
        static BYTE prc_nlp[] = {
            #include "prc.out"
        };
        return prc_nlp;
    }

    if (_wcsicmp(pTableName, L"prcp.nlp") == 0) {
        static BYTE prcp_nlp[] = {
            #include "prcp.out"
        };
        return prcp_nlp;
    }

    if (_wcsicmp(pTableName, L"region.nlp") == 0) {
        static BYTE region_nlp[] = {
            #include "region.out"
        };
        return region_nlp;
    }

    if (_wcsicmp(pTableName, L"sortkey.nlp") == 0) {
        static BYTE sortkey_nlp[] = {
            #include "sortkey.out"
        };
        return sortkey_nlp;
    }

    if (_wcsicmp(pTableName, L"sorttbls.nlp") == 0) {
        static BYTE sorttbls_nlp[] = {
            #include "sorttbls.out"
        };
        return sorttbls_nlp;
    }

    if (_wcsicmp(pTableName, L"xjis.nlp") == 0) {
        static BYTE xjis_nlp[] = {
            #include "xjis.out"
        };
        return xjis_nlp;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscornlp\makefile.inc ===
#*============================================================
#*
#* Header:  $/com99/src/dlls/mscornlp/Makefile.inc
#* Purpose: To make MscorNLP.dll for NLS+ resource tables
#* Date:    Feburary 9, 2000
#* Author:  Rong Chen (rongc)
#* Copyright (c) 2000-2000, Microsoft Corp.  All rights reserved.
#*
#==========================================================*/

CFLAGS = $(CFLAGS) -Zm500

.SUFFIXES: .out .nlp

{..\..\BCL\System\Globalization\Tables}.nlp{$(_OBJDIR)\}.out:
    hd.exe $** > $*.hd
    sed.exe -f script.sed $*.hd > $@
    -del $*.hd

$(_OBJDIR)\mscornlp.obj : \
    $(_OBJDIR)\big5.out \
    $(_OBJDIR)\bopomofo.out \
    $(_OBJDIR)\CharInfo.out \
    $(_OBJDIR)\ctype.out \
    $(_OBJDIR)\culture.out \
    $(_OBJDIR)\cultures.out \
    $(_OBJDIR)\ksc.out \
    $(_OBJDIR)\l_except.out \
    $(_OBJDIR)\l_intl.out \
    $(_OBJDIR)\prc.out \
    $(_OBJDIR)\prcp.out \
    $(_OBJDIR)\region.out \
    $(_OBJDIR)\sortkey.out \
    $(_OBJDIR)\sorttbls.out \
    $(_OBJDIR)\xjis.out \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoroc\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#include <CrtWrap.h>
#include <winwrap.h>                    // Windows wrappers.

#include <ole2.h>						// OLE definitions
#include "oledb.h"						// OLE DB headers.
#include "oledberr.h"					// OLE DB Error messages.
#include "msdadc.h"						// Data type conversion service.


#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED
#undef _WINGDI_

//#include <atlbase.h>					// ATL template classes.

#include "Intrinsic.h"					// Functions to make intrinsic.

// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoroc\mscoroc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MSCoroc.cpp
//
//*****************************************************************************
#include "stdafx.h"                     // Standard header.
//#include <atlimpl.cpp>                    // ATL helpers.
#include "UtilCode.h"                   // Utility helpers.
#include "Errors.h"                     // Errors subsystem.
#define INIT_GUIDS  
#include "CorPriv.h"
#include "classfac.h"
#include <winwrap.h>
#include "InternalDebug.h"
#include <mscoree.h>
#include "PostError.h"
#include "corhost.h"
#include "CorPerm.h"

#include "corhlpr.cpp"

// Meta data startup/shutdown routines.
STDAPI  MetaDataDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
STDAPI  MetaDataDllRegisterServer();
STDAPI  MetaDataDllUnregisterServer();
STDAPI  GetMDInternalInterface(
    LPVOID      pData, 
    ULONG       cbData, 
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnk);              // [out] Return interface on success.

extern "C" {


// Globals.
HINSTANCE       g_hThisInst;            // This library.
long            g_cCorInitCount = -1;   // Ref counting for init code.
HINSTANCE       g_pPeWriterDll = NULL;  // PEWriter DLL

// @todo: this is just for m3 because our com interop cannot yet
// detect shut down reliably and the assert kills the process
// badly on Win 9x.
#ifdef _DEBUG
extern int      g_bMetaDataLeakDetect;
#endif


//*****************************************************************************
// Handle lifetime of loaded library.
//*****************************************************************************
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Init unicode wrappers.
        OnUnicodeSystem();

        // Save the module handle.
        g_hThisInst = (HMODULE)hInstance;

        // Init the error system.
        InitErrors(0);

        // Debug cleanup code.
        _DbgInit((HINSTANCE)hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        UninitErrors();
    }

    return (true);
}


} // extern "C"


HINSTANCE GetModuleInst()
{
    return (g_hThisInst);
}


// ---------------------------------------------------------------------------
// %%Function: DllGetClassObject        %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Parameters:
//  rclsid                  - reference to the CLSID of the object whose
//                            ClassObject is being requested
//  iid                     - reference to the IID of the interface on the
//                            ClassObject that the caller wants to communicate
//                            with
//  ppv                     - location to return reference to the interface
//                            specified by iid
// 
// Returns:
//  S_OK                    - if successful, valid interface returned in *ppv,
//                            otherwise *ppv is set to NULL and one of the
//                            following errors is returned:
//  E_NOINTERFACE           - ClassObject doesn't support requested interface
//  CLASS_E_CLASSNOTAVAILABLE - clsid does not correspond to a supported class
// 
// Description:
//  Returns a reference to the iid interface on the main COR ClassObject.
//  This function is one of the required by-name entry points for COM
// DLL's. Its purpose is to provide a ClassObject which by definition
// supports at least IClassFactory and can therefore create instances of
// objects of the given class.
// 
// @TODO: CClassFactory temporarily supports down-level COM. Once
// Windows.Class exists, that object will support IClassFactoryX, it will
// be ref-counted, etc, and we will find/create it here in DllGetClassObject.
// ---------------------------------------------------------------------------
STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR *ppv)
{
    static CClassFactory cfS;
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    if (rclsid == CLSID_CorMetaDataDispenser || rclsid == CLSID_CorMetaDataDispenserRuntime ||
             rclsid == CLSID_CorRuntimeHost)
        hr = MetaDataDllGetClassObject(rclsid, riid, ppv);
    return hr;
}  // DllGetClassObject

// ---------------------------------------------------------------------------
// %%Function: DllCanUnloadNow          %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Returns:
//  S_FALSE                 - Indicating that COR, once loaded, may not be
//                            unloaded.
// ---------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return S_OK;
}  // DllCanUnloadNow

// ---------------------------------------------------------------------------
// %%Function: DllRegisterServer        %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Description:
//  Registers
// ---------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    return MetaDataDllRegisterServer();
}  // DllRegisterServer

// ---------------------------------------------------------------------------
// %%Function: DllUnregisterServer      %%Owner: NatBro   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    return MetaDataDllUnregisterServer();
}  // DllUnregisterServer

// ---------------------------------------------------------------------------
// %%Function: MetaDataGetDispenser
// This function gets the Dispenser interface given the CLSID and REFIID.
// ---------------------------------------------------------------------------
STDAPI MetaDataGetDispenser(            // Return HRESULT
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    IClassFactory *pcf = NULL;
    HRESULT hr;

    hr = MetaDataDllGetClassObject(rclsid, IID_IClassFactory, (void **) &pcf);
    if (FAILED(hr)) 
        return (hr);

    hr = pcf->CreateInstance(NULL, riid, ppv);
    pcf->Release();

    return (hr);
}


// ---------------------------------------------------------------------------
// %%Function: GetMetaDataInternalInterface
// This function gets the Dispenser interface given the CLSID and REFIID.
// ---------------------------------------------------------------------------
STDAPI  GetMetaDataInternalInterface(
    LPVOID      pData,                  // [IN] in memory metadata section
    ULONG       cbData,                 // [IN] size of the metadata section
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [IN] desired interface
    void        **ppv)                  // [OUT] returned interface
{
    return GetMDInternalInterface(pData, cbData, flags, riid, ppv);
}


// ===========================================================================
//                    C C l a s s F a c t o r y   C l a s s
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: QueryInterface           %%Owner: NatBro   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(
    REFIID iid,
    void **ppv)
{
    *ppv = NULL;

    if (iid == IID_IClassFactory || iid == IID_IUnknown)
    {
        *ppv = (IClassFactory *)this;
        AddRef();
    }

    return (*ppv != NULL) ? S_OK : E_NOINTERFACE;
}  // CClassFactory::QueryInterface

// ---------------------------------------------------------------------------
// %%Function: CreateInstance           %%Owner: NatBro   %%Reviewed: 00/00/00
// ---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(
    LPUNKNOWN punkOuter,
    REFIID riid,
    void** ppv)
{
    *ppv = NULL;

    if (punkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    return E_NOTIMPL;
}  // CClassFactory::CreateInstance

// ---------------------------------------------------------------------------
// %%Function: LockServer               %%Owner: NatBro   %%Reviewed: 00/00/00
// 
// Description:
//  Unimplemented, always returns S_OK.
// ---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(
    BOOL fLock)
{
    return S_OK;
}  // CClassFactory::LockServer


//*******************************************************************
// stubs for disabled functionalities.
//*******************************************************************

HRESULT ExportTypeLibFromModule(                                             
    LPCWSTR     szModule,               // The module name.                  
    LPCWSTR     szTlb,                  // The typelib name.
    int         bRegister)              // If true, register the library.
{                                                                            
    _ASSERTE(!"E_NOTIMPL");                                                           
    return E_NOTIMPL;                                                      
}                                                                           
//*****************************************************************************
// Called by the class factory template to create a new instance of this object.
//*****************************************************************************
HRESULT CorHost::CreateObject(REFIID riid, void **ppUnk)
{ 
    _ASSERTE(!"E_NOTIMPL");                                                            //
    return E_NOTIMPL;                                                        //
}

HRESULT STDMETHODCALLTYPE
TranslateSecurityAttributes(CORSEC_PSET    *pPset,
                            BYTE          **ppbOutput,
                            DWORD          *pcbOutput,
                            BYTE          **ppbNonCasOutput,
                            DWORD          *pcbNonCasOutput,
                            DWORD          *pdwErrorIndex)
{
    return E_NOTIMPL;
}

extern mdAssemblyRef DefineAssemblyRefForImportedTypeLib(
    void        *pAssembly,             // Assembly importing the typelib.
    void        *pvModule,              // Module importing the typelib.
    IUnknown    *pIMeta,                // IMetaData* from import module.
    IUnknown    *pIUnk,                 // IUnknown to referenced Assembly.
    BSTR        *pwzNamespace)          // The namespace of the resolved assembly.
{
    return 0;
}

mdAssemblyRef DefineAssemblyRefForExportedAssembly(
    LPCWSTR     pszFullName,            // The full name of the assembly.
    IUnknown    *pIMeta)                // Metadata emit interface.
{
    return 0;
}

HRESULT STDMETHODCALLTYPE
GetAssembliesByName(LPCWSTR  szAppBase,
                    LPCWSTR  szPrivateBin,
                    LPCWSTR  szAssemblyName,
                    IUnknown *ppIUnk[],
                    ULONG    cMax,
                    ULONG    *pcAssemblies)
{
    return E_NOTIMPL;
}

STDAPI
CoInitializeEE(DWORD fFlags)
{
    return E_NOTIMPL;
}

STDAPI_(void)
CoUninitializeEE(BOOL fFlags)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\debug.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// Ultra-simple debug print utility.  set dbFlags to non-zero to turn on debug printfs 
// Note you use dbPrintf like this.  Note the extra parentheses.  This allows variable number of args
//		dbPrintf(("val = %d\n", val));

#ifndef DEBUG
#define dbPrintf(x)	{ }
// #define dbXXXPrintf(x)	{ }						// sample of adding another debug stream
#else
#include <stdio.h>

extern unsigned dbFlags;

#define DB_ALL 			0xFFFFFFFF

#define DB_GENERIC 		0x00000001
// #define DB_XXX 			0x00000002				// sample of adding another debug stream

#define dbPrintf(x)	{ if (dbFlags & DB_GENERIC) printf x; }

// #define dbXXXPrintf(x)	{ if (dbFlags & DB_XXX) printf x; }// sample of adding another debug stream

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\ceefilegenwriter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Derived class from CCeeGen which handles writing out
// the exe. All references to PEWriter pulled out of CCeeGen,
// and moved here
//
//

#include "stdafx.h"

#include <string.h>
#include <limits.h>
#include <basetsd.h>

#include "CorError.h"
#include "Stubs.h"
#include <PostError.h>

// Get the Symbol entry given the head and a 0-based index
IMAGE_SYMBOL* GetSymbolEntry(IMAGE_SYMBOL* pHead, int idx)
{
    return (IMAGE_SYMBOL*) (((BYTE*) pHead) + IMAGE_SIZEOF_SYMBOL * idx);
}

//*****************************************************************************
// To get a new instance, call CreateNewInstance() instead of new
//*****************************************************************************

HRESULT CeeFileGenWriter::CreateNewInstance(CCeeGen *pCeeFileGenFrom, CeeFileGenWriter* & pGenWriter)
{   
    pGenWriter = new CeeFileGenWriter;
    TESTANDRETURN(pGenWriter, E_OUTOFMEMORY);
    
    PEWriter *pPEWriter = new PEWriter;
    TESTANDRETURN(pPEWriter, E_OUTOFMEMORY);
    //HACK HACK HACK.  
    //What's really the correct thing to be doing here?
    //HRESULT hr = pPEWriter->Init(pCeeFileGenFrom ? pCeeFileGenFrom->getPESectionMan() : NULL);
    HRESULT hr = pPEWriter->Init(NULL);
    TESTANDRETURNHR(hr);

    //Create the general PEWriter.
    pGenWriter->m_peSectionMan = pPEWriter;
    hr = pGenWriter->Init(); // base class member to finish init
    TESTANDRETURNHR(hr);

    pGenWriter->setImageBase(CEE_IMAGE_BASE); // use same default as linker
    pGenWriter->setSubsystem(IMAGE_SUBSYSTEM_WINDOWS_CUI, CEE_IMAGE_SUBSYSTEM_MAJOR_VERSION, CEE_IMAGE_SUBSYSTEM_MINOR_VERSION);

    hr = pGenWriter->allocateIAT(); // so iat goes out first
    TESTANDRETURNHR(hr);

    hr = pGenWriter->allocateCorHeader();   // so cor header near front
    TESTANDRETURNHR(hr);

    //If we were passed a CCeeGen at the beginning, copy it's data now.
    if (pCeeFileGenFrom) {
        pCeeFileGenFrom->cloneInstance((CCeeGen*)pGenWriter);
    }

    // set il RVA to be after the preallocated sections
    pPEWriter->setIlRva(pGenWriter->m_iDataSectionIAT->dataLen());
    return hr;
} // HRESULT CeeFileGenWriter::CreateNewInstance()

CeeFileGenWriter::CeeFileGenWriter() // ctor is protected
{
    m_outputFileName = NULL;
    m_resourceFileName = NULL;
    m_dllSwitch = false;
    m_objSwitch = false;
    m_libraryName = NULL;
    m_libraryGuid = GUID_NULL;

    m_entryPoint = 0;
    m_comImageFlags = COMIMAGE_FLAGS_ILONLY;    // ceegen PEs don't have native code
    m_iatOffset = 0;

    m_dwMacroDefinitionSize = 0;
    m_dwMacroDefinitionRVA = NULL;

    m_dwManifestSize = 0;
    m_dwManifestRVA = NULL;

    m_dwStrongNameSize = 0;
    m_dwStrongNameRVA = NULL;

    m_dwVTableSize = 0;
    m_dwVTableRVA = NULL;

    m_linked = false;
    m_fixed = false;
} // CeeFileGenWriter::CeeFileGenWriter()

//*****************************************************************************
// Cleanup
//*****************************************************************************
HRESULT CeeFileGenWriter::Cleanup() // virtual 
{
    ((PEWriter *)m_peSectionMan)->Cleanup();  // call derived cleanup
    delete m_peSectionMan;
    m_peSectionMan = NULL; // so base class won't delete

    delete[] m_outputFileName;
    delete[] m_resourceFileName;

    if (m_iDataDlls) {
        for (int i=0; i < m_dllCount; i++) {
            if (m_iDataDlls[i].m_methodName)
                free(m_iDataDlls[i].m_methodName);
        }
        free(m_iDataDlls);
    }

    return CCeeGen::Cleanup();
} // HRESULT CeeFileGenWriter::Cleanup()

HRESULT CeeFileGenWriter::EmitMacroDefinitions(void *pData, DWORD cData)
{
#ifndef COMPRESSION_SUPPORTED    

    m_dwMacroDefinitionSize = 0;

#else
    CeeSection TextSection = getTextSection();
    BYTE *     pDestData;
    DWORD      dwCurOffsetInTextSection;
    DWORD      dwRVA;

    m_dwMacroDefinitionSize = cData + 2;        // two bytes for header

    pDestData = (BYTE*) TextSection.getBlock(m_dwMacroDefinitionSize, 4);
	if(pDestData == NULL) return E_OUTOFMEMORY;
    dwCurOffsetInTextSection = TextSection.dataLen() - m_dwMacroDefinitionSize;

    IMAGE_COR20_COMPRESSION_HEADER *macroHeader = (IMAGE_COR20_COMPRESSION_HEADER *) pDestData;
    pDestData += 2;  
    
    macroHeader->CompressionType = COR_COMPRESS_MACROS;
    macroHeader->Version         = 0;

    memcpy(pDestData, pData, cData);

    getMethodRVA(dwCurOffsetInTextSection, &dwRVA);
    m_dwMacroDefinitionRVA = dwRVA;

#endif
    
    return S_OK;
} // HRESULT CeeFileGenWriter::EmitMacroDefinitions()

HRESULT CeeFileGenWriter::link()
{
    HRESULT hr = checkForErrors();
    if (! SUCCEEDED(hr))
        return hr;

#ifdef COMPRESSION_SUPPORTED
    if (m_dwMacroDefinitionSize != 0) 
    {
        m_comImageFlags |= COMIMAGE_FLAGS_COMPRESSIONDATA;
        m_corHeader->CompressionData.VirtualAddress = m_dwMacroDefinitionRVA; 
        m_corHeader->CompressionData.Size = m_dwMacroDefinitionSize; 
    }
    else 
    {
        m_corHeader->CompressionData.VirtualAddress = 0;
        m_corHeader->CompressionData.Size = 0;
    }
#endif

    //@todo: this is using the overloaded Resource directory entry which needs to die
    m_corHeader->Resources.VirtualAddress = m_dwManifestRVA;
    m_corHeader->Resources.Size = m_dwManifestSize;

    m_corHeader->StrongNameSignature.VirtualAddress = m_dwStrongNameRVA;
    m_corHeader->StrongNameSignature.Size = m_dwStrongNameSize;

    m_corHeader->VTableFixups.VirtualAddress = m_dwVTableRVA;
    m_corHeader->VTableFixups.Size = m_dwVTableSize;

    getPEWriter().setCharacteristics(
//#ifndef _WIN64
        // @Todo: handle every platform.
        IMAGE_FILE_32BIT_MACHINE |
//#endif
        IMAGE_FILE_EXECUTABLE_IMAGE | 
        IMAGE_FILE_LINE_NUMS_STRIPPED | 
        IMAGE_FILE_LOCAL_SYMS_STRIPPED
    );

    m_corHeader->cb = sizeof(IMAGE_COR20_HEADER);
    m_corHeader->MajorRuntimeVersion = COR_VERSION_MAJOR;
    m_corHeader->MinorRuntimeVersion = COR_VERSION_MINOR;
    if (m_dllSwitch)
        getPEWriter().setCharacteristics(IMAGE_FILE_DLL);
    if (m_objSwitch)
        getPEWriter().clearCharacteristics(IMAGE_FILE_DLL | IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_LOCAL_SYMS_STRIPPED);
    m_corHeader->Flags = m_comImageFlags;
    m_corHeader->EntryPointToken = m_entryPoint;
    _ASSERTE(TypeFromToken(m_entryPoint) == mdtMethodDef || m_entryPoint == mdTokenNil || 
             TypeFromToken(m_entryPoint) == mdtFile);
    setDirectoryEntry(getCorHeaderSection(), IMAGE_DIRECTORY_ENTRY_COMHEADER, sizeof(IMAGE_COR20_HEADER), m_corHeaderOffset);

    if ((m_comImageFlags & COMIMAGE_FLAGS_IL_LIBRARY) == 0
        && !m_linked && !m_objSwitch)
    {
        hr = emitExeMain();
        if (FAILED(hr))
            return hr;

        hr = emitResourceSection();
        if (FAILED(hr))
            return hr;
    }

    m_linked = true;

    IfFailRet(getPEWriter().link());

    return S_OK;
} // HRESULT CeeFileGenWriter::link()


HRESULT CeeFileGenWriter::fixup()
{
    HRESULT hr;

    m_fixed = true;

    if (!m_linked)
        IfFailRet(link());

    CeeGenTokenMapper *pMapper = getTokenMapper();

    // Apply token remaps if there are any.
    if (! m_fTokenMapSupported && pMapper != NULL) {
        IMetaDataImport *pImport;
        hr = pMapper->GetMetaData(&pImport);
        _ASSERTE(SUCCEEDED(hr));
        hr = MapTokens(pMapper, pImport);
        pImport->Release();

    }

    // remap the entry point if entry point token has been moved
    if (pMapper != NULL && !m_objSwitch) 
    {
        mdToken tk = m_entryPoint;
        pMapper->HasTokenMoved(tk, tk);
        m_corHeader->EntryPointToken = tk;
    }

    IfFailRet(getPEWriter().fixup(pMapper)); 

    return S_OK;
} // HRESULT CeeFileGenWriter::fixup()

HRESULT CeeFileGenWriter::generateImage(void **ppImage)
{
    HRESULT hr;

    if (!m_fixed)
        IfFailRet(fixup());

    LPWSTR outputFileName = m_outputFileName;

    if (! outputFileName && ppImage == NULL) {
        if (m_comImageFlags & COMIMAGE_FLAGS_IL_LIBRARY)
            outputFileName = L"output.ill";
        else if (m_dllSwitch)
            outputFileName = L"output.dll";
        else if (m_objSwitch)
            outputFileName = L"output.obj";
        else
            outputFileName = L"output.exe";
    }

    // output file name and ppImage are mutually exclusive
    _ASSERTE((NULL == outputFileName && ppImage != NULL) || (outputFileName != NULL && NULL == ppImage));

    if (outputFileName != NULL)
    {
        IfFailRet(getPEWriter().write(outputFileName));

#if VERIFY_FILE
        hr = getPEWriter().verify(outputFileName);
        if (FAILED(hr))
        {
            _ASSERTE(!"Verification failure - investigate!!!!");
            WszDeleteFile(outputFileName);
            return hr;
        }
#endif

    }
    else
        IfFailRet(getPEWriter().write(ppImage));

    return S_OK;
} // HRESULT CeeFileGenWriter::generateImage()

HRESULT CeeFileGenWriter::setOutputFileName(LPWSTR fileName)
{
    if (m_outputFileName)
        delete[] m_outputFileName;
    m_outputFileName = (LPWSTR)new WCHAR[(lstrlenW(fileName) + 1)];
    TESTANDRETURN(m_outputFileName!=NULL, E_OUTOFMEMORY);
    wcscpy(m_outputFileName, fileName);
    return S_OK;
} // HRESULT CeeFileGenWriter::setOutputFileName()

HRESULT CeeFileGenWriter::setResourceFileName(LPWSTR fileName)
{
    if (m_resourceFileName)
        delete[] m_resourceFileName;
    m_resourceFileName = (LPWSTR)new WCHAR[(lstrlenW(fileName) + 1)];
    TESTANDRETURN(m_resourceFileName!=NULL, E_OUTOFMEMORY);
    wcscpy(m_resourceFileName, fileName);
    return S_OK;
} // HRESULT CeeFileGenWriter::setResourceFileName()

HRESULT CeeFileGenWriter::setLibraryName(LPWSTR libraryName)
{
    if (m_libraryName)
        delete[] m_libraryName;
    m_libraryName = (LPWSTR)new WCHAR[(lstrlenW(libraryName) + 1)];
    TESTANDRETURN(m_libraryName != NULL, E_OUTOFMEMORY);
    wcscpy(m_libraryName, libraryName);
    return S_OK;
} // HRESULT CeeFileGenWriter::setLibraryName()

HRESULT CeeFileGenWriter::setLibraryGuid(LPWSTR libraryGuid)
{
    return CLSIDFromString(libraryGuid, &m_libraryGuid);
} // HRESULT CeeFileGenWriter::setLibraryGuid()

//@todo: this entry point is only here so that down level clients of this interface
// can import the method by name in the exports table using the original name.
// These things really ought to be exported through a v-table so there is no
// name mangling issues.  It would make the export table much smaller as well.

HRESULT CeeFileGenWriter::emitLibraryName(IMetaDataEmit *emitter)
{
    HRESULT hr;
    IfFailRet(emitter->SetModuleProps(m_libraryName));
    
    // Set the GUID as a custom attribute, if it is not NULL_GUID.
    if (m_libraryGuid != GUID_NULL)
    {
        //@todo: there should be a better infrastructure for this.
        static COR_SIGNATURE _SIG[] = INTEROP_GUID_SIG;
        mdTypeRef tr;
        mdMemberRef mr;
        WCHAR wzGuid[40];
        BYTE  rgCA[50];
        IfFailRet(emitter->DefineTypeRefByName(mdTypeRefNil, INTEROP_GUID_TYPE_W, &tr));
        IfFailRet(emitter->DefineMemberRef(tr, L".ctor", _SIG, sizeof(_SIG), &mr));
        StringFromGUID2(m_libraryGuid, wzGuid, lengthof(wzGuid));
        memset(rgCA, 0, sizeof(rgCA));
        // Tag is 0x0001
        rgCA[0] = 1;
        // Length of GUID string is 36 characters.
        rgCA[2] = 0x24;
        // Convert 36 characters, skipping opening {, into 3rd byte of buffer.
        WszWideCharToMultiByte(CP_ACP,0, wzGuid+1,36, reinterpret_cast<char*>(&rgCA[3]),36, 0,0);
        hr = emitter->DefineCustomAttribute(1,mr,rgCA,41,0);
    }
    return (hr);
} // HRESULT CeeFileGenWriter::emitLibraryName()

HRESULT CeeFileGenWriter::setImageBase(size_t imageBase) 
{
    getPEWriter().setImageBase(imageBase);
    return S_OK;
} // HRESULT CeeFileGenWriter::setImageBase()

HRESULT CeeFileGenWriter::setFileAlignment(ULONG fileAlignment) 
{
    getPEWriter().setFileAlignment(fileAlignment);
    return S_OK;
} // HRESULT CeeFileGenWriter::setFileAlignment()

HRESULT CeeFileGenWriter::setSubsystem(DWORD subsystem, DWORD major, DWORD minor)
{
    getPEWriter().setSubsystem(subsystem, major, minor);
    return S_OK;
} // HRESULT CeeFileGenWriter::setSubsystem()

HRESULT CeeFileGenWriter::checkForErrors()
{
    if (TypeFromToken(m_entryPoint) == mdtMethodDef) {
        if (m_dllSwitch) {
//@todo: with current spec would need to check the binary sig of the entry point method
//          if ( (m_comImageFlags & COMIMAGE_FLAGS_ENTRY_CLASSMAIN) != 0) {
//              DEBUG_STMT(wprintf(L"***** Error: cannot specify COMIMAGE_ENTRY_FLAGS_CLASSMAIN for DLL\n"));
//              return (CEE_E_ENTRYPOINT);
//          }
        } 
        return S_OK;
    }
    return S_OK;
} // HRESULT CeeFileGenWriter::checkForErrors()

HRESULT CeeFileGenWriter::getMethodRVA(ULONG codeOffset, ULONG *codeRVA)
{
    _ASSERTE(codeRVA);
    *codeRVA = getPEWriter().getIlRva() + codeOffset;
    return S_OK;
} // HRESULT CeeFileGenWriter::getMethodRVA()

HRESULT CeeFileGenWriter::setDirectoryEntry(CeeSection &section, ULONG entry, ULONG size, ULONG offset)
{
    return getPEWriter().setDirectoryEntry((PEWriterSection*)(&section.getImpl()), entry, size, offset);
} // HRESULT CeeFileGenWriter::setDirectoryEntry()

HRESULT CeeFileGenWriter::getFileTimeStamp(time_t *pTimeStamp)
{
    return getPEWriter().getFileTimeStamp(pTimeStamp);
} // HRESULT CeeFileGenWriter::getFileTimeStamp()

#ifdef _X86_
HRESULT CeeFileGenWriter::setAddrReloc(UCHAR *instrAddr, DWORD value)
{
    *(DWORD *)instrAddr = value;
    return S_OK;
} // HRESULT CeeFileGenWriter::setAddrReloc()

HRESULT CeeFileGenWriter::addAddrReloc(CeeSection &thisSection, UCHAR *instrAddr, DWORD offset, CeeSection *targetSection)
{
    if (!targetSection) {
        thisSection.addBaseReloc(offset, srRelocHighLow);
    } else {
        thisSection.addSectReloc(offset, *targetSection, srRelocHighLow);
    }
    return S_OK;
} // HRESULT CeeFileGenWriter::addAddrReloc()

#elif defined(_IA64_)
HRESULT CeeFileGenWriter::setAddrReloc(UCHAR *instrAddr, DWORD value)
{
    _ASSERTE(!"NYI");
    return S_OK;
} // HRESULT CeeFileGenWriter::setAddrReloc()

HRESULT CeeFileGenWriter::addAddrReloc(CeeSection &thisSection, UCHAR *instrAddr, DWORD offset, CeeSection *targetSection)
{
    _ASSERTE(!"NYI");
    return S_OK;
} // HRESULT CeeFileGenWriter::addAddrReloc()

#elif defined(_ALPHA_)

// We are dealing with two DWORD instructions of the following form:
//      LDAH    t12,iat(zero)
//      LDn     t12,iat(t12)
// 
// The first instruction contains the high (16-bit) half of target iat address
// and the second contains the low half. Need to generate relocs for both

struct LoadIATInstrs {
    USHORT high;
    USHORT dummy;
    USHORT low;
    USHORT dummy2;
};

HRESULT CeeFileGenWriter::setAddrReloc(UCHAR *instrAddr, DWORD value)
{
    LoadIATInstrs *inst = (LoadIATInstrs*)instrAddr;
    inst->high = (USHORT)(value >> 16);
    inst->low = (USHORT)value;
    return S_OK;
} // HRESULT CeeFileGenWriter::setAddrReloc()

HRESULT CeeFileGenWriter::addAddrReloc(CeeSection &thisSection, UCHAR *instrAddr, DWORD offset, CeeSection *targetSection)
{
    LoadIATInstrs *inst = (LoadIATInstrs*)instrAddr;
    CeeSectionRelocExtra extra;
    extra.highAdj = inst->low;
    if (!targetSection) {
        thisSection.addBaseReloc(offset, srRelocHighAdj, &extra);
        thisSection.addBaseReloc(offset+sizeof(DWORD), srRelocLow);
    } else {
        thisSection.addSectReloc(offset, *targetSection, srRelocHighAdj, &extra);
        thisSection.addSectReloc(offset+sizeof(DWORD), *targetSection, srRelocLow);
    }
    return S_OK;
} // HRESULT CeeFileGenWriter::addAddrReloc()

#elif defined(CHECK_PLATFORM_BUILD)
#error "Platform NYI"
#endif

// create ExeMain and import directory into .text and the .iat into .data
//
// The structure of the import directory information is as follows, but it is not contiguous in 
// section. All the r/o data goes into the .text section and the iat array (which the loader
// updates with the imported addresses) goes into the .data section because WINCE needs it to be writable.
//
//    struct IData {
//      // one for each DLL, terminating in NULL
//      IMAGE_IMPORT_DESCRIPTOR iid[];      
//      // import lookup table: a set of entries for the methods of each DLL, 
//      // terminating each set with NULL
//      IMAGE_THUNK_DATA ilt[];
//      // hint/name table: an set of entries for each method of each DLL wiht
//      // no terminating entry
//      struct {
//          WORD Hint;
//          // null terminated string
//          BYTE Name[];
//      } ibn;      // Hint/name table
//      // import address table: a set of entries for the methods of each DLL, 
//      // terminating each set with NULL
//      IMAGE_THUNK_DATA iat[];
//      // one for each DLL, null terminated strings
//      BYTE DllName[];
//  };
//

// IAT must be first in its section, so have code here to allocate it up front
// prior to knowing other info such as if dll or not. This won't work if have > 1
// function imported, but we'll burn that bridge when we get to it.
HRESULT CeeFileGenWriter::allocateIAT()
{
    m_dllCount = 1;
    m_iDataDlls = (IDataDllInfo *)calloc(m_dllCount, sizeof(IDataDllInfo));
    if (m_iDataDlls == 0) {
        return E_OUTOFMEMORY;
    }
    m_iDataDlls[0].m_numMethods = 1;
    m_iDataDlls[0].m_methodName = 
                (char **)calloc(m_iDataDlls[0].m_numMethods, sizeof(char *));
    if (! m_iDataDlls[0].m_methodName) {
        return E_OUTOFMEMORY;
    }
    m_iDataDlls[0].m_name = "mscoree.dll";

    int iDataSizeIAT = 0;

    for (int i=0; i < m_dllCount; i++) {
        m_iDataDlls[i].m_iatOffset = iDataSizeIAT;
        iDataSizeIAT += (m_iDataDlls[i].m_numMethods + 1) * sizeof IMAGE_THUNK_DATA;
    }

    HRESULT hr = getSectionCreate(".text0", sdExecute, &m_iDataSectionIAT);
    TESTANDRETURNHR(hr);
    m_iDataOffsetIAT = m_iDataSectionIAT->dataLen();
    _ASSERTE(m_iDataOffsetIAT == 0);
    m_iDataIAT = m_iDataSectionIAT->getBlock(iDataSizeIAT);
    if (! m_iDataIAT) {
        return E_OUTOFMEMORY;
    }
    memset(m_iDataIAT, '\0', iDataSizeIAT);

    // Don't set the IAT directory entry yet, since we may not actually end up doing
    // an emitExeMain.

    return S_OK;
} // HRESULT CeeFileGenWriter::allocateIAT()

HRESULT CeeFileGenWriter::emitExeMain()
{
    HRESULT hr = E_FAIL;
    // Note: code later on in this method assumes that mscoree.dll is at 
    // index m_iDataDlls[0], with CorDllMain or CorExeMain at method[0]

    if (m_dllSwitch) {
        m_iDataDlls[0].m_methodName[0] = "_CorDllMain";
    } else {
        m_iDataDlls[0].m_methodName[0] = "_CorExeMain";
    }

    int iDataSizeIAT = 0;
    int iDataSizeRO = (m_dllCount + 1) * sizeof(IMAGE_IMPORT_DESCRIPTOR);
    CeeSection &iDataSectionRO = getTextSection();
    int iDataOffsetRO = iDataSectionRO.dataLen();

    for (int i=0; i < m_dllCount; i++) {
        m_iDataDlls[i].m_iltOffset = iDataSizeRO + iDataSizeIAT;
        iDataSizeIAT += (m_iDataDlls[i].m_numMethods + 1) * sizeof IMAGE_THUNK_DATA;
    }

    iDataSizeRO += iDataSizeIAT;

    for (i=0; i < m_dllCount; i++) {
        int delta = (iDataSizeRO + iDataOffsetRO) % 16;
        // make sure is on a 16-byte offset
        if (delta != 0)
            iDataSizeRO += (16 - delta);
        _ASSERTE((iDataSizeRO + iDataOffsetRO) % 16 == 0);
        m_iDataDlls[i].m_ibnOffset = iDataSizeRO;
        for (int j=0; j < m_iDataDlls[i].m_numMethods; j++) {
            int nameLen = (int)(strlen(m_iDataDlls[i].m_methodName[j]) + 1);
            iDataSizeRO += sizeof(WORD) + nameLen + nameLen%2;
        }
    }
    for (i=0; i < m_dllCount; i++) {
        m_iDataDlls[i].m_nameOffset = iDataSizeRO;
        iDataSizeRO += (int)(strlen(m_iDataDlls[i].m_name) + 2);
    }                                                             

    char *iDataRO = iDataSectionRO.getBlock(iDataSizeRO);
    if (! iDataRO) {
        return E_OUTOFMEMORY;
    }
    memset(iDataRO, '\0', iDataSizeRO);

    setDirectoryEntry(iDataSectionRO, IMAGE_DIRECTORY_ENTRY_IMPORT, iDataSizeRO, iDataOffsetRO);

    IMAGE_IMPORT_DESCRIPTOR *iid = (IMAGE_IMPORT_DESCRIPTOR *)iDataRO;        
    for (i=0; i < m_dllCount; i++) {

        // fill in the import descriptors for each DLL
        iid[i].OriginalFirstThunk = (ULONG)(m_iDataDlls[i].m_iltOffset + iDataOffsetRO);
        iid[i].Name = m_iDataDlls[i].m_nameOffset + iDataOffsetRO;
        iid[i].FirstThunk = (ULONG)(m_iDataDlls[i].m_iatOffset + m_iDataOffsetIAT);

        iDataSectionRO.addSectReloc(
            (unsigned)(iDataOffsetRO + (char *)(&iid[i].OriginalFirstThunk) - iDataRO), iDataSectionRO, srRelocAbsolute);
        iDataSectionRO.addSectReloc(
            (unsigned)(iDataOffsetRO + (char *)(&iid[i].Name) - iDataRO), iDataSectionRO, srRelocAbsolute);
        iDataSectionRO.addSectReloc(
            (unsigned)(iDataOffsetRO + (char *)(&iid[i].FirstThunk) - iDataRO), *m_iDataSectionIAT, srRelocAbsolute);

        // now fill in the import lookup table for each DLL
        IMAGE_THUNK_DATA *ilt = (IMAGE_THUNK_DATA*)
                        (iDataRO + m_iDataDlls[i].m_iltOffset);
        IMAGE_THUNK_DATA *iat = (IMAGE_THUNK_DATA*)
                        (m_iDataIAT + m_iDataDlls[i].m_iatOffset);

        int ibnOffset = m_iDataDlls[i].m_ibnOffset;
        for (int j=0; j < m_iDataDlls[i].m_numMethods; j++) {
#ifdef _WIN64
            ilt[j].u1.AddressOfData = (ULONGLONG)(ibnOffset + iDataOffsetRO);
            iat[j].u1.AddressOfData = (ULONGLONG)(ibnOffset + iDataOffsetRO);
#else // !_WIN64
            ilt[j].u1.AddressOfData = (ULONG)(ibnOffset + iDataOffsetRO);
            iat[j].u1.AddressOfData = (ULONG)(ibnOffset + iDataOffsetRO);
#endif
            iDataSectionRO.addSectReloc(
                (unsigned)(iDataOffsetRO + (char *)(&ilt[j].u1.AddressOfData) - iDataRO), iDataSectionRO, srRelocAbsolute);
            m_iDataSectionIAT->addSectReloc(
                (unsigned)(m_iDataOffsetIAT + (char *)(&iat[j].u1.AddressOfData) - m_iDataIAT), iDataSectionRO, srRelocAbsolute);
            int nameLen = (int)(strlen(m_iDataDlls[i].m_methodName[j]) + 1);
            memcpy(iDataRO + ibnOffset + offsetof(IMAGE_IMPORT_BY_NAME, Name), 
                                    m_iDataDlls[i].m_methodName[j], nameLen);
            ibnOffset += sizeof(WORD) + nameLen + nameLen%2;
        }

        // now fill in the import lookup table for each DLL
        strcpy(iDataRO + m_iDataDlls[i].m_nameOffset, m_iDataDlls[i].m_name);
    };

    // Put the entry point code into the PE file
    unsigned entryPointOffset = getTextSection().dataLen();
    int iatOffset = (int)(entryPointOffset + (m_dllSwitch ? CorDllMainIATOffset : CorExeMainIATOffset));
    const int align = 4;
    // WinCE needs to have the IAT offset on a 4-byte boundary because it will be loaded and fixed up even
    // for RISC platforms, where DWORDs must be 4-byte aligned.  So compute number of bytes to round up by 
    // to put iat offset on 4-byte boundary
    int diff = ((iatOffset + align -1) & ~(align-1)) - iatOffset;
    if (diff) {
        // force to 4-byte boundary
        if(NULL==getTextSection().getBlock(diff)) return E_OUTOFMEMORY;
        entryPointOffset += diff;
    }
    _ASSERTE((getTextSection().dataLen() + (m_dllSwitch ? CorDllMainIATOffset : CorExeMainIATOffset)) % 4 == 0);

    getPEWriter().setEntryPointTextOffset(entryPointOffset);
    if (m_dllSwitch) {
        UCHAR *dllMainBuf = (UCHAR*)getTextSection().getBlock(sizeof(DllMainTemplate));
        if(dllMainBuf==NULL) return E_OUTOFMEMORY;
        memcpy(dllMainBuf, DllMainTemplate, sizeof(DllMainTemplate));
        //mscoree.dll
        setAddrReloc(dllMainBuf+CorDllMainIATOffset, m_iDataDlls[0].m_iatOffset + m_iDataOffsetIAT);
        addAddrReloc(getTextSection(), dllMainBuf, entryPointOffset+CorDllMainIATOffset, m_iDataSectionIAT);
    } else {
        UCHAR *exeMainBuf = (UCHAR*)getTextSection().getBlock(sizeof(ExeMainTemplate));
        if(exeMainBuf==NULL) return E_OUTOFMEMORY;
        memcpy(exeMainBuf, ExeMainTemplate, sizeof(ExeMainTemplate));
        //mscoree.dll
        setAddrReloc(exeMainBuf+CorExeMainIATOffset, m_iDataDlls[0].m_iatOffset + m_iDataOffsetIAT);
        addAddrReloc(getTextSection(), exeMainBuf, entryPointOffset+CorExeMainIATOffset, m_iDataSectionIAT);
    }

    // Now set our IAT entry since we're using the IAT
    setDirectoryEntry(*m_iDataSectionIAT, IMAGE_DIRECTORY_ENTRY_IAT, iDataSizeIAT, m_iDataOffsetIAT);

    return S_OK;
} // HRESULT CeeFileGenWriter::emitExeMain()

// Like CreateProcess(), but waits for execution to finish
// Returns true if successful, false on failure.
// dwExitCode set to process' exitcode
extern int UseUnicodeAPIEx();

BOOL RunProcess(LPCWSTR tempResObj, LPCWSTR pszFilename, DWORD* pdwExitCode)
{
    BOOL fSuccess = FALSE;

    PROCESS_INFORMATION pi;

    DWORD cchSystemDir = MAX_PATH + 1;
    WCHAR wszSystemDir[MAX_PATH + 1];
    if (FAILED(GetInternalSystemDirectory(wszSystemDir, &cchSystemDir)))
        return FALSE;

    if( OnUnicodeSystem() ) {
        STARTUPINFOW start;
        ZeroMemory(&start, sizeof(STARTUPINFO));
        start.cb = sizeof(STARTUPINFO);
        start.dwFlags = STARTF_USESHOWWINDOW;
        start.wShowWindow = SW_HIDE;
    
        // Res file, so convert it
        WCHAR szCmdLine[_MAX_PATH<<2];
        
        // @todo: add /MACHINE:CEE flag when CvtRes.exe supports that feature.
        Wszwsprintf(szCmdLine,
                    L"%scvtres.exe /NOLOGO /READONLY /MACHINE:IX86 \"/OUT:%s\" \"%s\"",
                    wszSystemDir,
                    tempResObj,
                    pszFilename);     
        
        fSuccess = WszCreateProcess(
                                    NULL,
                                    szCmdLine,
                                    NULL,
                                    NULL, 
                                    true, 
                                    0,
                                    0, 
                                    NULL, 
                                    &start, 
                                    &pi);
    }
    else {
        // Res file, so convert it
        char szCmdLine[_MAX_PATH<<2];
        
        STARTUPINFOA start;
        ZeroMemory(&start, sizeof(STARTUPINFO));
        start.cb = sizeof(STARTUPINFO);
        start.dwFlags = STARTF_USESHOWWINDOW;
        start.wShowWindow = SW_HIDE;
        
        MAKE_ANSIPTR_FROMWIDE(pSystemDir, wszSystemDir);
        MAKE_ANSIPTR_FROMWIDE(pTemp, tempResObj);
        MAKE_ANSIPTR_FROMWIDE(pFilename, pszFilename);
        
        // @todo: add /MACHINE:CEE flag when CvtRes.exe supports that feature.
        sprintf(szCmdLine,
                "%scvtres.exe /NOLOGO /READONLY /MACHINE:IX86 \"/OUT:%s\" \"%s\"",
                pSystemDir,
                pTemp,
                pFilename);     
        
        fSuccess = CreateProcessA(
                                  NULL,
                                  szCmdLine,
                                  NULL,
                                  NULL, 
                                  true, 
                                  0,
                                  0, 
                                  NULL, 
                                  &start, 
                                  &pi);
    }

    // If process runs, wait for it to finish
    if (fSuccess) {
        CloseHandle(pi.hThread);

        WaitForSingleObject(pi.hProcess, INFINITE);

        GetExitCodeProcess(pi.hProcess, pdwExitCode);

        CloseHandle(pi.hProcess);
    }
    return fSuccess;
} // BOOL RunProcess()

// Ensure that pszFilename is an object file (not just a binary resource)
// If we convert, then return obj filename in pszTempFilename
HRESULT ConvertResource(const WCHAR * pszFilename, WCHAR *pszTempFilename)
{
    HANDLE hFile = WszCreateFile(pszFilename, GENERIC_READ, 
        FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

// failure
    if (!hFile || (hFile == INVALID_HANDLE_VALUE))
    {
        //dbprintf("Can't find resource files:%S\n", pszFilename);
        return HRESULT_FROM_WIN32(GetLastError());
    }

// Read first 4 bytes. If they're all 0, we have a win32 .res file which must be
// converted. (So call CvtRes.exe). Else it's an obj file.

    DWORD dwCount = -1;
    DWORD dwData;
    BOOL fRet = ReadFile(hFile,
                    &dwData,
                    4,
                    &dwCount,
                    NULL
    );
    
    CloseHandle(hFile);

    if (!fRet) {
        //dbprintf("Invalid resource file:%S\n", pszFilename);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (dwData != 0x00000000)
        return S_OK;

    WCHAR tempResObj[MAX_PATH+1];
    WCHAR tempResPath[MAX_PATH+1];
    HRESULT hr = S_OK;

    // bug fix 3862. Create the temp file where the temp path is at rather than where the application is at.
    if (!WszGetTempPath(MAX_PATH, tempResPath))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!WszGetTempFileName(tempResPath, L"RES", 0, tempResObj))
    {
        //dbprintf("GetTempFileName failed\n");
        return HRESULT_FROM_WIN32(GetLastError());
    }

    DWORD dwExitCode;
    fRet = RunProcess(tempResObj, pszFilename, &dwExitCode);

    if (!fRet) 
    {   // Couldn't run cvtres.exe
        return PostError(CEE_E_CVTRES_NOT_FOUND);
    } 
    else if (dwExitCode != 0) 
    {   // CvtRes.exe ran, but failed
        return HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
    } 
    else 
    {   // Conversion succesful, so return filename.
        wcscpy(pszTempFilename, tempResObj);
    }

    return S_OK;
} // HRESULT ConvertResource()



// This function reads a resource file and emits it into the generated PE file. 
// 1. We can only link resources in obj format. Must convert from .res to .obj
// with CvtRes.exe.
// 2. Must touch up all COFF relocs from .rsrc$01 (resource header) to .rsrc$02
// (resource raw data)
HRESULT CeeFileGenWriter::emitResourceSection()
{
    if (m_resourceFileName == NULL)
        return S_OK; 

// Make sure szResFileName is an obj, not just a .res; change name if we convert
    WCHAR szTempFileName[MAX_PATH+1];
    szTempFileName[0] = L'\0';
    HRESULT hr = ConvertResource(m_resourceFileName, szTempFileName);
    if (FAILED(hr)) return hr;
    
// Filename may change (if we convert .res to .obj), so have floating pointer
    const WCHAR* szResFileName;
    if (*szTempFileName)
        szResFileName = szTempFileName;
    else
        szResFileName = m_resourceFileName;

    _ASSERTE(szResFileName);

    // read the resource file and spit it out in the .rsrc section
    
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    IMAGE_FILE_HEADER *hMod = NULL;

    hr = S_OK;

    __try {
    __try {
        // create a mapped view of the .res file
        hFile = WszCreateFile(szResFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            //dbprintf("Resource file %S not found\n", szResFileName);
             HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
            __leave;
        }

        hMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, NULL);
                
        if (hMap == NULL) {
            //dbprintf("Invalid .res file: %S\n", szResFileName);
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        hMod = (IMAGE_FILE_HEADER*)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
        
        // test failure conditions
        if (hMod == NULL) {
            //dbprintf("Invalid .res file: %S:Can't get header\n", szResFileName);
            hr = HRESULT_FROM_WIN32(GetLastError());
            __leave;
        }

        if (hMod->SizeOfOptionalHeader != 0) {
            //dbprintf("Invalid .res file: %S:Illegal optional header\n", szResFileName);
             hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND); // GetLastError() = 0 since API worked.
            __leave;
        }

        // first section is directly after header
        IMAGE_SECTION_HEADER *pSection = (IMAGE_SECTION_HEADER *)(hMod+1);
        IMAGE_SECTION_HEADER *rsrc01 = NULL;    // resource header
        IMAGE_SECTION_HEADER *rsrc02 = NULL;    // resource data
        for (int i=0; i < hMod->NumberOfSections; i++) {
            if (strcmp(".rsrc$01", (char *)(pSection+i)->Name) == 0) {
                rsrc01 = pSection+i;
            } else if (strcmp(".rsrc$02", (char *)(pSection+i)->Name) == 0) {
                rsrc02 = pSection+i;
            }
        }
        if (!rsrc01 || !rsrc02) {
            //dbprintf("Invalid .res file: %S: Missing sections .rsrc$01 or .rsrc$02\n", szResFileName);            
             hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
            __leave;
        }

        PESection *rsrcSection;
        hr = getPEWriter().getSectionCreate(".rsrc", sdReadOnly, &rsrcSection);
        TESTANDLEAVEHR(hr);
        rsrcSection->directoryEntry(IMAGE_DIRECTORY_ENTRY_RESOURCE);
        char *data = rsrcSection->getBlock(rsrc01->SizeOfRawData + rsrc02->SizeOfRawData);
		if(data == NULL) return E_OUTOFMEMORY;       
    // Copy resource header
        memcpy(data, (char *)hMod + rsrc01->PointerToRawData, rsrc01->SizeOfRawData);

    

    // map all the relocs in .rsrc$01 using the reloc and symbol tables in the COFF object.,
    
        const int nTotalRelocs = rsrc01->NumberOfRelocations;       
        const IMAGE_RELOCATION* pReloc = (IMAGE_RELOCATION*) ((BYTE*) hMod + (rsrc01->PointerToRelocations));       
        IMAGE_SYMBOL* pSymbolTableHead = (IMAGE_SYMBOL*) (((BYTE*)hMod) + hMod->PointerToSymbolTable);
        
        DWORD dwOffsetInRsrc2;
        for(int iReloc = 0; iReloc < nTotalRelocs; iReloc ++, pReloc++) {
        // Compute Address where RVA is in $01      
            DWORD* pAddress = (DWORD*) (((BYTE*) hMod) + (rsrc01->PointerToRawData) + (pReloc->VirtualAddress));
            
         // index into symbol table, provides address into $02
            DWORD IdxSymbol = pReloc->SymbolTableIndex;
            IMAGE_SYMBOL* pSymbolEntry = GetSymbolEntry(pSymbolTableHead, IdxSymbol);

        // Ensure the symbol entry is valid for a resource.
            if ((pSymbolEntry->StorageClass != IMAGE_SYM_CLASS_STATIC) ||
                (pSymbolEntry->Type != IMAGE_SYM_TYPE_NULL) ||
                (pSymbolEntry->SectionNumber != 3)) // 3rd section is .rsrc$02
                {
                    //dbprintf("Invalid .res file: %S:Illegal symbol entry\n", szResFileName);
                    hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND); // GetLastError() = 0 since API worked.
                    __leave;
                }

        // Ensure that RVA is valid address (inside rsrc02)
            if (pSymbolEntry->Value >= rsrc02->SizeOfRawData) {
                //dbprintf("Invalid .res file: %S:Illegal rva into .rsrc$02\n", szResFileName);
                hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND); // GetLastError() = 0 since API worked.
                __leave;
            }


            dwOffsetInRsrc2 = pSymbolEntry->Value + rsrc01->SizeOfRawData;


        // Create reloc
            *(DWORD*)(data + pReloc->VirtualAddress) = dwOffsetInRsrc2; 
            rsrcSection->addSectReloc(pReloc->VirtualAddress, rsrcSection, srRelocAbsolute);            
        }

    // Copy $02 (resource raw) data
        memcpy(data+rsrc01->SizeOfRawData, (char *)hMod + rsrc02->PointerToRawData, rsrc02->SizeOfRawData);
    } __finally {
        if (hMod != NULL)
            UnmapViewOfFile(hMod);
        if (hMap != NULL)
            CloseHandle(hMap);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
        if (szResFileName == szTempFileName)
            // delete temporary file if we created one
            WszDeleteFile(szResFileName);
    }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        //dbprintf("Exception occured manipulating .res file %S\n", szResFileName);            
        return HRESULT_FROM_WIN32(ERROR_RESOURCE_DATA_NOT_FOUND);
    }
    return hr;
} // HRESULT CeeFileGenWriter::emitResourceSection()

HRESULT CeeFileGenWriter::setManifestEntry(ULONG size, ULONG offset)
{
    if (offset)
        m_dwManifestRVA = offset;
    else {
        CeeSection TextSection = getTextSection();
        getMethodRVA(TextSection.dataLen() - size, &m_dwManifestRVA);
    }

    m_dwManifestSize = size;
    return S_OK;
} // HRESULT CeeFileGenWriter::setManifestEntry()

HRESULT CeeFileGenWriter::setStrongNameEntry(ULONG size, ULONG offset)
{
    m_dwStrongNameRVA = offset;
    m_dwStrongNameSize = size;
    return S_OK;
} // HRESULT CeeFileGenWriter::setStrongNameEntry()

HRESULT CeeFileGenWriter::setVTableEntry(ULONG size, ULONG offset)
{
    if (offset && size)
    {
		void * pv;
        CeeSection TextSection = getTextSection();
        getMethodRVA(TextSection.dataLen(), &m_dwVTableRVA);
		if(pv = TextSection.getBlock(size))
			memcpy(pv,(void *)offset,size);
		else return E_OUTOFMEMORY;
        m_dwVTableSize = size;
    }

    return S_OK;
} // HRESULT CeeFileGenWriter::setVTableEntry()

HRESULT CeeFileGenWriter::setEnCRvaBase(ULONG dataBase, ULONG rdataBase)
{
    setEnCMode();
    getPEWriter().setEnCRvaBase(dataBase, rdataBase);
    return S_OK;
} // HRESULT CeeFileGenWriter::setEnCRvaBase()

HRESULT CeeFileGenWriter::computeSectionOffset(CeeSection &section, char *ptr,
                                               unsigned *offset)
{
    *offset = section.computeOffset(ptr);

    return S_OK;
} // HRESULT CeeFileGenWriter::computeSectionOffset()

HRESULT CeeFileGenWriter::computeOffset(char *ptr,
                                        CeeSection **pSection, unsigned *offset)
{
    TESTANDRETURNPOINTER(pSection);

    CeeSection **s = m_sections;
    CeeSection **sEnd = s + m_numSections;
    while (s < sEnd)
    {
        if ((*s)->containsPointer(ptr))
        {
            *pSection = *s;
            *offset = (*s)->computeOffset(ptr);

            return S_OK;
        }
        s++;
    }

    return E_FAIL;
} // HRESULT CeeFileGenWriter::computeOffset()

HRESULT CeeFileGenWriter::getCorHeader(IMAGE_COR20_HEADER **ppHeader)
{
    *ppHeader = m_corHeader;
    return S_OK;
} // HRESULT CeeFileGenWriter::getCorHeader()

// Globals.
HINSTANCE       g_hThisInst;            // This library.

//*****************************************************************************
// Handle lifetime of loaded library.
//*****************************************************************************
extern "C"
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        {   // Save the module handle.
            g_hThisInst = (HMODULE)hInstance;
        }
        break;
    }

    return (true);
} // BOOL WINAPI DllMain()


HINSTANCE GetModuleInst()
{
    return (g_hThisInst);
} // HINSTANCE GetModuleInst()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoroc\peparse.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning (disable : 4121) // ntkxapi.h(59) alignment warning
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;
#include <windows.h>
#include <CorHdr.h>
#include <ntimage.h>
#pragma warning (default : 4121)

static const char g_szCORMETA[] = ".cormeta";

// Following structure is copied from cor.h
#define IMAGE_DIRECTORY_ENTRY_COMHEADER     14


//
// @todo ia64: we need to update our PE parsing to properly distinguish
// between PE32 and PE+.
//

// Following two functions lifted from NT sources, imagedir.c
PIMAGE_SECTION_HEADER
Cor_RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS32 NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN ULONG FileLength
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    FileLength - Length of file for validation purposes

Return Value:

    NULL - The RVA was not found within any of the sections of the image.

    NON-NULL - Returns the pointer to the image section that contains
               the RVA

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        // Validate the section header (check that raw data in the section
        // is actually within the file).
        if (NtSection->PointerToRawData + NtSection->SizeOfRawData > FileLength)
            return NULL;
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}



PVOID
Cor_RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS32 NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN ULONG FileLength,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    FileLength - Length of file for validation purposes

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (!ARGUMENT_PRESENT( LastRvaSection ) ||
        (NtSection = *LastRvaSection) == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = Cor_RtlImageRvaToSection( NtHeaders,
                                          Base,
                                          Rva,
                                          FileLength
                                        );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}

HRESULT FindImageMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData, DWORD dwFileLength)
{
    IMAGE_COR20_HEADER      *pCorHeader;
    PIMAGE_NT_HEADERS32     pImageHeader;
    PIMAGE_SECTION_HEADER   pSectionHeader;

    pImageHeader = (PIMAGE_NT_HEADERS32)RtlpImageNtHeader(pImage);

    pSectionHeader = Cor_RtlImageRvaToVa(pImageHeader, pImage, 
                                         pImageHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress,
                                         dwFileLength,
                                         NULL);
    if (pSectionHeader)
    {
        // Check for a size which would indicate the retail header.
        DWORD dw = *(DWORD *) pSectionHeader;
        if (dw == sizeof(IMAGE_COR20_HEADER))

        {
            pCorHeader = (IMAGE_COR20_HEADER *) pSectionHeader;
            *ppMetaData = Cor_RtlImageRvaToVa(pImageHeader, pImage,
                                              pCorHeader->MetaData.VirtualAddress,
                                              dwFileLength,
                                              NULL);
            *pcbMetaData = pCorHeader->MetaData.Size;
        }
        else
        {
            return (E_FAIL);
        }
    }
    else
    {
        *ppMetaData = NULL;
        *pcbMetaData = 0;
    }

    if (*ppMetaData == NULL || *pcbMetaData == 0)
        return (E_FAIL);
    return (S_OK);
}


HRESULT FindObjMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData, DWORD dwFileLength)
{
    IMAGE_FILE_HEADER *pImageHdr;       // Header for the .obj file.
    IMAGE_SECTION_HEADER *pSectionHdr;  // Section header.
    WORD        i;                      // Loop control.

    // Get a pointer to the header and the first section.
    pImageHdr = (IMAGE_FILE_HEADER *) pImage;
    pSectionHdr = (IMAGE_SECTION_HEADER *)(pImageHdr + 1);

    // Avoid confusion.
    *ppMetaData = NULL;
    *pcbMetaData = 0;

    // Walk each section looking for .cormeta.
    for (i=0;  i<pImageHdr->NumberOfSections;  i++, pSectionHdr++)
    {
        // Simple comparison to section name.
        if (strcmp((const char *) pSectionHdr->Name, g_szCORMETA) == 0)
        {
            // Check that raw data in the section is actually within the file.
            if (pSectionHdr->PointerToRawData + pSectionHdr->SizeOfRawData > dwFileLength)
                break;
            *pcbMetaData = pSectionHdr->SizeOfRawData;
            *ppMetaData = (void *) ((long) pImage + pSectionHdr->PointerToRawData);
            break;
        }
    }

    // Check for errors.
    if (*ppMetaData == NULL || *pcbMetaData == 0)
        return (E_FAIL);
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoroc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCOROC.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft CEF MetaData Engine\0"
#define VER_ORIGFILENAME_STR    "mscoroc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscoroc\uncompressedstub.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: UncompressedInternal.CPP
//
// ===========================================================================
#include "CrtWrap.h" 

#include "metadata.h"
#include "..\..\complib\stgdb\Uncompressed.h"


//*****************************************************************************
// Given a scope, return the number of tokens in a given table 
//*****************************************************************************
HRESULT UncompressedInternal::GetCountWithTokenKind(     // return hresult
    mdScope     scope,                  // [IN] given scope
    DWORD       tkKind,                 // [IN] pass in the kind of token. 
    ULONG       *pcount)                // [OUT] return *pcount
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// enumerator init for typedef
//*****************************************************************************
HRESULT UncompressedInternal::EnumTypeDefInit( // return hresult
    mdScope     scope,                  // given scope
    HENUMInternal *phEnum)              // [OUT] buffer to fill for enumerator data
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************
// Enumerator initializer
//***************************************** 
HRESULT UncompressedInternal::EnumInit(     // return S_FALSE if record not found
    mdScope     scope,                  // [IN] given scope
    DWORD       tkKind,                 // [IN] which table to work on
    mdToken     tkParent,               // [IN] token to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************
// Get next value contained in the enumerator
//***************************************** 
bool UncompressedInternal::EnumNext(
    HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
    mdToken     *ptk)                   // [OUT] token to scope the search
{
	_ASSERTE(!"NYI!");
    return false;
}


//*****************************************
// Reset the enumerator to the beginning.
//***************************************** 
void UncompressedInternal::EnumReset(
    HENUMInternal *phEnum)              // [IN] the enumerator to be reset  
{
	_ASSERTE(!"NYI!");
    return;
}


//*****************************************
// Close the enumerator. 
//***************************************** 
void UncompressedInternal::EnumClose(
    HENUMInternal *phEnum)              // [IN] the enumerator to be closed
{
	_ASSERTE(!"NYI!");
    return;
}

//*****************************************
// Enumerator initializer for PermissionSets
//***************************************** 
HRESULT UncompressedInternal::EnumPermissionSetsInit(// return S_FALSE if record not found
    mdScope     scope,                  // [IN] given scope
    mdToken     tkParent,               // [IN] token to scope the search
    CorDeclSecurity Action,             // [IN] Action to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************
// Nagivator helper to navigate back to the parent token given a token.
// For example, given a memberdef token, it will return the containing typedef.
//
// the mapping is as following:
//  ---given child type---------parent type
//  mdMethodDef                 mdTypeDef
//  mdFieldDef                  mdTypeDef
//  mdMethodImpl                mdTypeDef
//  mdInterfaceImpl             mdTypeDef
//  mdParam                     mdMethodDef
//  mdProperty                  mdTypeDef
//  mdEvent                     mdTypeDef
//  @ hacky hacky   - Added special case for MemberRef
//
//***************************************** 
HRESULT UncompressedInternal::GetParentToken(
    mdScope     scope,                  // [IN] given scope
    mdToken     tkChild,                // [IN] given child token
    mdToken     *ptkParent)             // [OUT] returning parent
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// find custom value by name
//*****************************************************************************
HRESULT UncompressedInternal::FindCustomValue(
    mdScope     scope,                  // [IN] given scope
    mdToken     tk,                     // [IN] given token which custom value is associated with
    LPCSTR      szName,                 // [IN] given custom value's name
    mdCustomValue *pcv,                 // [OUT] return custom value token
    DWORD       *pdwValueType)          // [OUT] value type
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return custom value
//*****************************************************************************
HRESULT UncompressedInternal::GetCustomValueAsBlob(
    mdScope     scope,                  // [IN] given scope 
    mdCustomValue cv,                   // [IN] given custom value token
    void const  **ppBlob,               // [OUT] return the pointer to internal blob
    ULONG       *pcbSize)               // [OUT] return the size of the blob
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// Get information about a CustomValue.
//*****************************************************************************
HRESULT UncompressedInternal::GetCustomValueProps(  // S_OK or error.
    mdScope     scope,                  // The import scope.
    mdCustomValue at,                   // The attribute.
    LPCSTR      *pszCustomValue)        // Put attribute name here.
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return a pointer which points to meta data's internal string 
// return the the type name in utf8
//*****************************************************************************
HRESULT UncompressedInternal::GetNameOfTypeDef(// return hresult
    mdScope     scope,                  // given scope
    mdTypeDef   classdef,               // given typedef
    LPCSTR*     pszname,                // pointer to an internal UTF8 string
    LPCSTR*     psznamespace)           // pointer to the namespace.
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Given a scope and a FieldDef, return a pointer to FieldDef's name in UTF8
//*****************************************************************************
HRESULT UncompressedInternal::GetNameOfFieldDef(// return hresult
    mdScope     scope,                  // given scope
    mdFieldDef  fd,                     // given field 
    LPCSTR      *pszFieldName)          // pointer to an internal UTF8 string
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Given a scope and a classdef, return a pointer to classdef's name in UTF8
//*****************************************************************************
HRESULT UncompressedInternal::GetNameOfTypeRef(// return hresult
    mdScope     scope,                 // given scope
    mdTypeRef   classref,              // given a typedef
    LPCSTR*     pszname)               // pointer to an internal UTF8 string
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return flags for a given class
//*****************************************************************************
HRESULT UncompressedInternal::GetTypeDefProps(// return hresult
    mdScope     scope,                  // given scope
    mdTypeDef   td,                     // given classdef
    DWORD       *pdwAttr,               // return flags on class
    mdToken     *ptkExtends,            // [OUT] Put base class TypeDef/TypeRef here.
    DWORD       *pdwExtends)
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return guid pointer to MetaData internal guid pool given a given class
//*****************************************************************************
HRESULT UncompressedInternal::GetTypeDefGuidRef(    // return hresult
    mdScope     scope,              // given scope
    mdTypeDef   classdef,           // given classdef
    CLSID       **ppguid)           // clsid of this class
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return guid pointer to MetaData internal guid pool given a given class
//*****************************************************************************
HRESULT UncompressedInternal::GetTypeRefGuidRef(    // return hresult
    mdScope     scope,              // given scope
    mdTypeRef   classref,           // given classref
    CLSID       **ppguid)           // clsid of this class
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// Given a scope and a methoddef, return a pointer to methoddef's signature
//*****************************************************************************
HRESULT UncompressedInternal::GetLongSigOfMethodDef(
    mdScope     scope,                  // given scope
    mdMethodDef methoddef,              // given a methoddef 
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// Given a scope and a fielddef, return a pointer to fielddef's signature
//*****************************************************************************
HRESULT UncompressedInternal::GetLongSigOfFieldDef(
    mdScope     scope,                  // given scope
    mdFieldDef  fielddef,               // given a methoddef 
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Given a scope and a methoddef, return the flags and slot number
//*****************************************************************************
HRESULT UncompressedInternal::GetMethodDefProps(
    mdScope     scope,                  // The import scope.
    RID         mb,                     // The method for which to get props.
    DWORD       *pdwAttr,               // Put flags here.
    ULONG       *pulSlot)               // Put the Slot or ulSequence here.
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// Given a scope and a methoddef/methodimpl, return RVA and impl flags
//*****************************************************************************
HRESULT UncompressedInternal::GetMethodImplProps(       // S_OK or error.
    mdScope     es,                     // [IN] The emit scope
    mdToken     tk,                     // [IN] MethodDef or MethodImpl
    DWORD       *pulCodeRVA,            // [OUT] CodeRVA
    DWORD       *pdwImplFlags)          // [OUT] Impl. Flags
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return the memberref of methodimpl
//*****************************************************************************
HRESULT UncompressedInternal::GetMethodRefOfMethodImpl(
    mdScope     es,                     // [IN] give scope
    mdMethodImpl mi,                    // [IN] methodimpl token
    mdMemberRef *pmr)                   // [OUT] memberref token
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Given a scope and a methoddef, return the flags and RVA for the method
//*****************************************************************************
HRESULT UncompressedInternal::GetFieldDefProps(        // return hresult
    mdScope     scope,                  // given scope
    mdFieldDef  fd,                     // given memberdef
    DWORD       *pdwAttr)               // return method flags
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// Given the scope and interfaceimpl, return the classref and flags
//*****************************************************************************
HRESULT UncompressedInternal::GetTypeRefOfInterfaceImpl( // return hresult
    mdScope     scope,                  // given scope
    mdInterfaceImpl iiImpl,             // given a interfaceimpl
    mdToken     *ptkIface,              // return corresponding typeref or typedef
    DWORD       *pdwFlags)              // flags
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Given a scope and a classname, return the typedef
//*****************************************************************************
HRESULT UncompressedInternal::FindTypeDefInternal(       // return hresult
    mdScope     scope,                  // given scope
    LPCSTR      szClassName,            // given type name
    mdTypeDef   *ptypedef)              // return *ptypedef
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// Given a scope and a guid, return the typedef
//*****************************************************************************
HRESULT UncompressedInternal::FindTypeDefByGUID(       // return hresult
    mdScope     scope,                  // given scope
    REFGUID		guid,					// given guid
    mdTypeDef   *ptypedef)              // return *ptypedef
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Given a scope and a memberref, return a pointer to memberref's name and signature
//*****************************************************************************
HRESULT UncompressedInternal::GetNameAndSigOfMemberRef(  // return hresult
    mdScope     scope,                  // given scope
    mdMemberRef memberref,              // given a memberref 
    LPCSTR*     pszname,                // member name : pointer to an internal UTF8 string
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}



//*****************************************************************************
// Given a scope and a memberref, return typeref
//*****************************************************************************
HRESULT UncompressedInternal::GetTypeRefFromMemberRef(   // return hresult
    mdScope     scope,                  // given scope
    mdMemberRef memberref,              // given a typedef
    mdToken     *ptk)                   // return the typeref or typedef
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return properties of a paramdef
//*****************************************************************************/
HRESULT UncompressedInternal::GetParamDefProps (
    mdScope     scope,                  // given a scope
    mdParamDef  paramdef,               // given a paramdef
    LPCSTR      *pszName,               // [OUT] parameter's name. Point to a internal UTF8 string 
    USHORT      *pusSequence,           // [OUT] slot number for this parameter
    DWORD       *pdwAttr)               // [OUT] flags
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return the pack size of a class
//*****************************************************************************
HRESULT  UncompressedInternal::GetClassPackSize(
    mdScope     scope,                  // [IN] given scope
    mdTypeDef   td,                     // [IN] give typedef
    DWORD       *pdwPackSize)           // [OUT] 
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return the pack size of a class
//*****************************************************************************
HRESULT  UncompressedInternal::GetClassTotalSize(
    mdScope     scope,                  // [IN] given scope
    mdTypeDef   td,                     // [IN] give typedef
    DWORD       *pulClassSize)          // [OUT] 
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// init the layout enumerator of a class
//*****************************************************************************
HRESULT  UncompressedInternal::GetClassLayoutInit(
    mdScope     scope,                  // [IN] given scope
    mdTypeDef   td,                     // [IN] give typedef
    MD_CLASS_LAYOUT *pmdLayout)         // [OUT] set up the status of query here
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// init the layout enumerator of a class
//*****************************************************************************
HRESULT UncompressedInternal::GetClassLayoutNext(
    mdScope     scope,                  // [IN] given scope
    MD_CLASS_LAYOUT *pLayout,           // [IN|OUT] set up the status of query here
    mdFieldDef  *pfd,                   // [OUT] field def
    ULONG       *pulOffset)             // [OUT] field offset or sequence
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// return the field's native type signature
//*****************************************************************************
HRESULT  UncompressedInternal::GetFieldMarshal(
    mdScope     scope,                  // [IN] given scope
    mdToken     tk,                     // [IN] given fielddef or paramdef
    PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field
    ULONG       *pcbNativeType)         // [OUT] the count of bytes of *ppvNativeType
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// return default value of a token(could be paramdef, fielddef, or property
//*****************************************************************************
HRESULT UncompressedInternal::GetDefaultValue(   // return hresult
    mdScope     scope,                  // [IN] given scope
    mdToken     tk,                     // [IN] given FieldDef, ParamDef, or Property
    MDDefaultValue  *pMDDefaultValue)   // [OUT] default value
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return the layout of a class
//*****************************************************************************
HRESULT  _GetClassLayoutImp(
    IComponentRecords *pICR,            // [IN] ICR from given scope
    mdTypeDef   td,                     // [IN] give typedef
    DWORD       *pdwPackSize,           // [OUT] 
    COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array
    ULONG       cMax,                   // [IN] size of the array
    ULONG       *pcFieldOffset,         // [OUT] needed array size
    ULONG       *pulClassSize)          // [OUT] the size of the class
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************
// Returns the given ModuleRef properties.
//*****************************************************
HRESULT UncompressedInternal::GetModuleRefProps(        // return HRESULT
    mdScope     scope,              // [IN] given scope
    mdModuleRef mur,                // [IN] given ModuleRef
    LPCSTR      *pszName,           // [OUT] ModuleRef name
    GUID        **ppguid,           // [OUT] module identifier
    GUID        **ppmvid)           // [OUT] module version identifier
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

HRESULT UncompressedInternal::GetScopeProps(
    mdScope     scope,                  // [IN] given scope
    LPCSTR      *pszName,               // [OUT] scope name
    GUID        *ppid,                  // [OUT] guid of the scope
    GUID        *pmvid,                 // [OUT] version id
    LCID        *pLcid)                 // [OUT] lcid
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

HRESULT UncompressedInternal::FindParamOfMethod(// S_OK or error.
    mdScope     scope,                  // [IN] The import scope.
    mdMethodDef md,                     // [IN] The owning method of the param.
    ULONG       iSeq,                   // [IN] The sequence # of the param.
    mdParamDef  *pparamdef)             // [OUT] Put ParamDef token here.
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

HRESULT UncompressedInternal::GetExceptionProps(// S_OK, S_FALSE or error
    mdScope     scope,                  // [IN] The scope.
    mdToken		ex,                     // [IN] Exception token
    mdMethodDef *pmd,                   // [OUT] the memberdef that the exception can be thrown
    mdToken     *ptk)                   // [OUT] typedef/typeref token for the exception class
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Find property by name
//*****************************************************************************
HRESULT  UncompressedInternal::FindProperty(
    mdScope     scope,                  // [IN] given scope
    mdTypeDef   td,                     // [IN] given a typdef
    LPCSTR      szPropName,             // [IN] property name
    mdProperty  *pProp)                 // [OUT] return property token
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return the properties of a property
//*****************************************************************************
HRESULT  UncompressedInternal::GetPropertyProps(
    mdScope     scope,                  // [IN] The scope.
    mdProperty  prop,                   // [IN] property token
    LPCSTR      *pszProperty,           // [OUT] property name
    DWORD       *pdwPropFlags,          // [OUT] property flags.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob
    ULONG       *pcbSig,                // [OUT] count of bytes in *ppvSig
    mdToken     *pevNotifyChanging,     // [OUT] notify changing EventDef or EventRef
    mdToken     *pevNotifyChanged,      // [OUT] notify changed EventDef or EventRef
    mdFieldDef  *pmdBackingField)       // [OUT] backing field
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


//*****************************************************************************
// return an event by given the name
//*****************************************************************************
HRESULT  UncompressedInternal::FindEvent(
    mdScope     scope,                  // [IN] given scope
    mdTypeDef   td,                     // [IN] given a typdef
    LPCSTR      szEventName,            // [IN] event name
    mdEvent     *pEvent)                // [OUT] return event token
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}



//*****************************************************************************
// return the properties of an event
//*****************************************************************************
HRESULT  UncompressedInternal::GetEventProps(  // S_OK, S_FALSE, or error.
    mdScope     scope,                  // [IN] The scope.
    mdEvent     ev,                     // [IN] event token
    LPCSTR      *pszEvent,              // [OUT] Event name
    DWORD       *pdwEventFlags,         // [OUT] Event flags.
    mdToken     *ptkEventType)          // [OUT] EventType class
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// Find methoddef of a particular associate with a property or an event
//*****************************************************************************
HRESULT  UncompressedInternal::FindAssociate(
    mdScope     scope,                  // [IN] given a scope
    mdToken     evprop,                 // [IN] given a property or event token
    DWORD       dwSemantics,            // [IN] given a associate semantics(setter, getter, testdefault, reset)
    mdMethodDef *pmd)                   // [OUT] return method def token 
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}




//*****************************************************************************
// get counts of methodsemantics associated with a particular property/event
//*****************************************************************************
HRESULT  UncompressedInternal::EnumAssociateInit(
    mdScope     scope,                  // [IN] given a scope
    mdToken     evprop,                 // [IN] given a property or an event token
    HENUMInternal *phEnum)              // [IN] query result form GetPropertyAssociateCounts
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

//*****************************************************************************
// get all methodsemantics associated with a particular property/event
//*****************************************************************************
HRESULT  UncompressedInternal::GetAllAssociates(
    mdScope     scope,                  // [IN] given a scope
    HENUMInternal *phEnum,              // [IN] query result form GetPropertyAssociateCounts
    ASSOCIATE_RECORD *pAssociateRec,    // [OUT] struct to fill for output
    ULONG       cAssociateRec)          // [IN] size of the buffer
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


HRESULT UncompressedInternal::GetSigFromToken(// S_OK or error.
    mdScope     scope,                  // [IN] given scope.
    mdSignature mdSig,                  // [IN] Signature token.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
    ULONG       *pcbSig)                // [OUT] return size of signature.
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}


HRESULT UncompressedInternal::GetPermissionSetProps(
    mdScope     is,                     // [IN] given scope.
    mdPermission pm,                    // [IN] the permission token.
    DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
    void const  **ppvPermission,        // [OUT] permission blob.
    ULONG       *pcbPermission)         // [OUT] count of bytes of pvPermission.
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}



//*****************************************************************************
// Get property information associated with a method
//*****************************************************************************
HRESULT UncompressedInternal::GetPropertyInfoForMethodDef(   // Result.
    mdScope     scope,                  // [IN] given scope.
    mdMethodDef md,                     // [IN] methoddef
    mdProperty  *ppd,                   // [OUT] put property token here
    LPCSTR      *pName,                 // [OUT] put pointer to name here
    ULONG       *pSemantic)             // [OUT] put semantic here
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

HRESULT UncompressedInternal::ConvertTextSigToComSig(    // Return hresult.
    mdScope     scope,                  // given scope
    BOOL        fCreateTrIfNotFound,    // create typeref if not found
    LPCSTR      pSignature,             // class file format signature
    CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
    ULONG       *pcbCount)              // [OUT] the result size of signature
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

HRESULT UncompressedInternal::GetFixupList(
    mdScope     scope,                  // given scope
    IMAGE_COR_FIXUPENTRY rFixupEntries[], // Pointer to FixupLists
    ULONG       cMax,                   // Size of array
    ULONG       *pcFixupEntries)        // Number of entries put    
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

ULONG UncompressedInternal::GetFixupListCount(mdScope scope)
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}
HRESULT _FindMethodHelper(          // S_OK or error.
    mdScope     scope,                  // The import scope.
    mdTypeDef   cl,                     // The owning class of the method.
    void const  *szName,                // Name of the method. (unicode or utf8)
	PCCOR_SIGNATURE pvSigBlob,			// [IN] point to a blob value of COM+ signature
	ULONG		cbSigBlob,				// [IN] count of bytes in the signature blob
    mdMethodDef *pmb,					// [OUT] return found methoddef
    bool        isUnicodeString)        // true if unicode string otherwise utf8 string
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

__declspec(dllexport) HRESULT GetStgDatabase(StgDatabase **ppDB)
{
	_ASSERTE(!"NYI!");
    return E_NOTIMPL;
}

__declspec(dllexport) void DestroyStgDatabase(StgDatabase *pDB)
{
	_ASSERTE(!"NYI!");
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\ceefilegenwritertokens.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// CeeFileGenWriterTokens.cpp
//
// This code will walk the byte codes for all methods before they are saved
// to disk and apply the token fix-ups if they have moved.
//
// @todo:  I know this code is kind of gross.  After M6 the hope is that the
// consumers of ICeeFileGen will record fix-up locations for tokens so we
// don't have to walk the byte codes.
//
//*****************************************************************************
#include "stdafx.h"
#include "CeeGen.h"
#define DECLARE_DATA
#include "..\\..\\ildasm\\dasmenum.hpp"
#define MAX_CLASSNAME_LENGTH    1024

//********** Locals. **********************************************************
OPCODE DecodeOpcode(const BYTE *pCode, DWORD *pdwLen);



//********** Code. ************************************************************


//*****************************************************************************
// Method bodies are kept in the text section.  The meta data contains the
// RVA of each method body in the image.  The TextSection object contains the
// actual raw bytes where the method bodies are located.  This code will 
// determine the raw offset of each method based on the RVA kept in the meta
// data.
//*****************************************************************************

HRESULT CeeFileGenWriter::MapTokens(
    CeeGenTokenMapper *pMapper,
    IMetaDataImport *pImport)
{
    mdTypeDef   td;
    mdMethodDef md;
    ULONG       count;
    ULONG       MethodRVA;
    ULONG       codeOffset;
    ULONG       BaseRVA;
    DWORD       dwFlags;
    DWORD       iFlags;
    HCORENUM    hTypeDefs = 0, hEnum = 0;
    WCHAR       rcwName[MAX_CLASSNAME_LENGTH];
    HRESULT     hr;
    CeeSection  TextSection = getTextSection();

    // Ask for the base RVA of the first method in the stream.  All other
    // method RVA's are >= that value, and will give us the raw offset required.    

    hr = getMethodRVA(0, &BaseRVA);
    _ASSERTE(SUCCEEDED(hr));
    // do globals first
    while ((hr = pImport->EnumMethods(&hEnum, mdTokenNil, &md, 1, &count)) == S_OK)
    {
        hr = pImport->GetMethodProps(md, NULL, 
                    rcwName, lengthof(rcwName), NULL, 
                    &dwFlags, NULL, NULL,
                    &MethodRVA, &iFlags);
        _ASSERTE(SUCCEEDED(hr));

        if (MethodRVA == 0 || ((IsMdAbstract(dwFlags) || IsMiInternalCall(iFlags)) ||
                                   (! IsMiIL(iFlags) && ! IsMiOPTIL(iFlags))))
            continue;

        // The raw offset of the method is the RVA in the image minus
        // the first method in the text section.
        codeOffset = MethodRVA - BaseRVA;
        hr = MapTokensForMethod(pMapper, 
                    (BYTE *) TextSection.computePointer(codeOffset),
                    rcwName);
        if (FAILED(hr))
            goto ErrExit;
    }
    if (hEnum) pImport->CloseEnum(hEnum);
    hEnum = 0;
        
    while ((hr = pImport->EnumTypeDefs(&hTypeDefs, &td, 1, &count)) == S_OK)
    {
        while ((hr = pImport->EnumMethods(&hEnum, td, &md, 1, &count)) == S_OK)
        {
            hr = pImport->GetMethodProps(md, NULL, 
                        rcwName, lengthof(rcwName), NULL, 
                        &dwFlags, NULL, NULL,
                        &MethodRVA, &iFlags);
            _ASSERTE(SUCCEEDED(hr));

            if (MethodRVA == 0 || ((IsMdAbstract(dwFlags) || IsMiInternalCall(iFlags)) ||
                                   (! IsMiIL(iFlags) && ! IsMiOPTIL(iFlags))))
                continue;


            // The raw offset of the method is the RVA in the image minus
            // the first method in the text section.
            codeOffset = MethodRVA - BaseRVA;
            hr = MapTokensForMethod(pMapper, 
                        (BYTE *) TextSection.computePointer(codeOffset),
                        rcwName);
            if (FAILED(hr))
                goto ErrExit;
        }
            
        if (hEnum) pImport->CloseEnum(hEnum);
        hEnum = 0;
    }

ErrExit:
    if (hTypeDefs) pImport->CloseEnum(hTypeDefs);
    if (hEnum) pImport->CloseEnum(hEnum);
    return (hr);
}


//*****************************************************************************
// This method will walk the byte codes of an IL method looking for tokens.
// For each token found, it will check to see if it has been moved, and if
// so, apply the new token value in its place.
//*****************************************************************************
HRESULT CeeFileGenWriter::MapTokensForMethod(
    CeeGenTokenMapper *pMapper,
    BYTE        *pCode,
    LPCWSTR     szMethodName)
{
    mdToken     tkTo;
    DWORD       PC;

    COR_ILMETHOD_DECODER method((COR_ILMETHOD*) pCode);

    // If compressed IL is being emitted, this routine will have no idea how to walk the tokens,
    // so don't do it
    if (m_dwMacroDefinitionSize != 0) 
        return S_OK;

    pCode = const_cast<BYTE*>(method.Code);

    PC = 0;
    while (PC < method.CodeSize)
    {
        DWORD   Len;
        DWORD   i;
        OPCODE  instr;

        instr = DecodeOpcode(&pCode[PC], &Len);

        if (instr == CEE_COUNT)
        {
            _ASSERTE(0 && "Instruction decoding error\n");
            return E_FAIL;
        }


        PC += Len;

        switch (OpcodeInfo[instr].Type)
        {
            DWORD tk;

            default:
            {
                _ASSERTE(0 && "Unknown instruction\n");
                return E_FAIL;
            }

            case InlineNone:
            break;

            case ShortInlineI:
            case ShortInlineVar:
            case ShortInlineBrTarget:
            PC++;
            break;

            case InlineVar:
            PC += 2;
            break;

            case InlineI:
            case ShortInlineR:
            case InlineBrTarget:
            case InlineRVA:
            PC += 4;
            break;

            case InlineI8:
            case InlineR:
            PC += 8;
            break;

            case InlinePhi:
                {
                    DWORD cases = pCode[PC];
                    PC += 2 * cases + 1;
                    break;
                }

            case InlineSwitch:
            {
                DWORD cases = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);

                PC += 4;
                DWORD PC_nextInstr = PC + 4 * cases;

                for (i = 0; i < cases; i++)
                {
                    long offset = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);
                    long dest = PC_nextInstr + (long) offset;

                    PC += 4;
                }

                // skip bottom of loop which prints szString
                continue;
            }

            case InlineTok:
            case InlineSig:
            case InlineMethod:
            case InlineField:
            case InlineType:
            case InlineString:
            {
                tk = pCode[PC] + (pCode[PC+1] << 8) + (pCode[PC+2] << 16) + (pCode[PC+3] << 24);

                if (pMapper->HasTokenMoved(tk, tkTo))
                {
                    *(mdToken *) &pCode[PC] = tkTo;
                }

                PC += 4;
                break;
            }
        }
    }

    return S_OK;
}




OPCODE DecodeOpcode(const BYTE *pCode, DWORD *pdwLen)
{
    OPCODE opcode;

    *pdwLen = 1;
    opcode = OPCODE(pCode[0]);
    switch(opcode) {
        case CEE_PREFIX1:
            opcode = OPCODE(pCode[1] + 256);
            if (opcode < 0 || opcode >= CEE_COUNT)
                opcode = CEE_COUNT;
            *pdwLen = 2;
            break;
        case CEE_PREFIXREF:
        case CEE_PREFIX2:
        case CEE_PREFIX3:
        case CEE_PREFIX4:
        case CEE_PREFIX5:
        case CEE_PREFIX6:
        case CEE_PREFIX7:
            *pdwLen = 3;
            return CEE_COUNT;
        }
    return opcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\iceefilegen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
//  File: CEEGEN.CPP
// ===========================================================================
#include "stdafx.h"
#include "ICeeFileGen.h"
#include "CeeFileGenWriter.h"
#include "sighelper.h"

//@todo: Remove
//****************************************************************************
    HRESULT ICeeFileGen::EmitMethod ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::EmitSignature ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::SetEntryClassToken ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::GetEntryClassToken ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::SetEntryPointDescr ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::GetEntryPointDescr ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::SetEntryPointFlags ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::GetEntryPointFlags ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::CreateSig ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::AddSigArg ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::SetSigReturnType ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::SetSigCallingConvention ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
    HRESULT ICeeFileGen::DeleteSig ()
    {
        _ASSERTE("Depricated" && 0);
        return (E_FAIL);
    }
//****************************************************************************

HRESULT CreateICeeFileGen(ICeeFileGen** pCeeFileGen)
{
    // Have to init the win32 wrapper api's.
    OnUnicodeSystem();

    if (!pCeeFileGen)
        return E_POINTER;
    ICeeFileGen *gen = new ICeeFileGen();
    TESTANDRETURN(gen != NULL, E_OUTOFMEMORY);
    *pCeeFileGen = gen;
    return S_OK;
    
}

HRESULT DestroyICeeFileGen(ICeeFileGen** pCeeFileGen)
{
    if (!pCeeFileGen)
        return E_POINTER;
    delete *pCeeFileGen;
    *pCeeFileGen = NULL;
    return S_OK;
}

HRESULT ICeeFileGen::CreateCeeFile (HCEEFILE *ceeFile)
{
    if (!ceeFile)
        return E_POINTER;
    CeeFileGenWriter *gen = NULL;
    if (FAILED(CeeFileGenWriter::CreateNewInstance(NULL, gen))) return FALSE;
    TESTANDRETURN(gen != NULL, E_OUTOFMEMORY);
    *ceeFile = gen;

#ifdef _DEBUG
    WCHAR encRvaBuf[10];
    DWORD len = WszGetEnvironmentVariable(L"COMP_ENCRVA", encRvaBuf, sizeof(encRvaBuf));
	_ASSERTE(len < sizeof(encRvaBuf));
	if (len > 0) {
		WCHAR *dummy;
		DWORD rdataRvaBase = wcstol(encRvaBuf, &dummy, 16);
        SetEnCRVABase(*ceeFile, 0, rdataRvaBase);
    }
#endif
    return S_OK;
}

HRESULT ICeeFileGen::CreateCeeFileFromICeeGen (ICeeGen *pICeeGen, HCEEFILE *ceeFile)
{
    if (!ceeFile)
        return E_POINTER;
    CCeeGen *genFrom = reinterpret_cast<CCeeGen*>(pICeeGen);
    CeeFileGenWriter *gen = NULL;
    if (FAILED(CeeFileGenWriter::CreateNewInstance(genFrom, gen))) return FALSE;
    TESTANDRETURN(gen != NULL, E_OUTOFMEMORY);
    *ceeFile = gen;
    return S_OK;
}

HRESULT ICeeFileGen::DestroyCeeFile(HCEEFILE *ceeFile)
{
    if (!ceeFile)
        return E_POINTER;
    if (!*ceeFile)
        return E_POINTER;
    CeeFileGenWriter **gen = reinterpret_cast<CeeFileGenWriter**>(ceeFile);
    (*gen)->Cleanup();
    delete *gen;
    *ceeFile = NULL;
    return S_OK;
}

// The following methods should be removed completely if not used
// by 06/98.

HRESULT ICeeFileGen::GetRdataSection (HCEEFILE ceeFile, HCEESECTION *section)
{
    TESTANDRETURNPOINTER(section);
    TESTANDRETURNARG(ceeFile != 0);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    *section = &gen->getStringSection();
    return S_OK;
}

HRESULT ICeeFileGen::GetIlSection (HCEEFILE ceeFile, HCEESECTION *section)
{
    TESTANDRETURNPOINTER(section);
    TESTANDRETURNARG(ceeFile != 0);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    *section = &gen->getIlSection();
    return S_OK;
}


HRESULT ICeeFileGen::GetSectionCreate (HCEEFILE ceeFile, const char *name, DWORD flags, 
                                                        HCEESECTION *section)
{   
    TESTANDRETURNPOINTER(section);
    TESTANDRETURNARG(ceeFile != 0);
    TESTANDRETURNPOINTER(name); 

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    CeeSection **ceeSection = reinterpret_cast<CeeSection**>(section);

    HRESULT hr = gen->getSectionCreate(name, flags, ceeSection);
    return hr;
}

HRESULT ICeeFileGen::SetDirectoryEntry(HCEEFILE ceeFile, HCEESECTION section, ULONG num, ULONG size, ULONG offset)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(section);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    CeeSection &sec = *(reinterpret_cast<CeeSection*>(section));
    return(gen->setDirectoryEntry(sec, num, size, offset));
}

HRESULT ICeeFileGen::GetSectionDataLen (HCEESECTION section, ULONG *dataLen)
{
    TESTANDRETURNPOINTER(section);
    TESTANDRETURNPOINTER(dataLen);

    CeeSection *sec = reinterpret_cast<CeeSection*>(section);
    *dataLen = sec->dataLen();
    return S_OK;
}

HRESULT ICeeFileGen::GetSectionRVA (HCEESECTION section, ULONG *rva)
{
    TESTANDRETURNPOINTER(section);
    TESTANDRETURNPOINTER(rva);

    CeeSection *sec = reinterpret_cast<CeeSection*>(section);
    *rva = sec->getBaseRVA();
    return S_OK;
}

HRESULT ICeeFileGen::GetSectionBlock (HCEESECTION section, ULONG len,
                            ULONG align, void **ppBytes)
{
    TESTANDRETURNPOINTER(section);
    TESTANDRETURNPOINTER(ppBytes);

    CeeSection *sec = reinterpret_cast<CeeSection*>(section);
    void *bytes = sec->getBlock(len, align);
    TESTANDRETURN(bytes != NULL, E_OUTOFMEMORY);
    *ppBytes = bytes;
    return S_OK;
}

HRESULT ICeeFileGen::TruncateSection (HCEESECTION section, ULONG len)
{
    TESTANDRETURNPOINTER(section);

    CeeSection *sec = reinterpret_cast<CeeSection*>(section);
    return(sec->truncate(len));
}

HRESULT ICeeFileGen::AddSectionReloc (HCEESECTION section, ULONG offset, HCEESECTION relativeTo, CeeSectionRelocType relocType)
{
    TESTANDRETURNPOINTER(section);

    CeeSection *sec = reinterpret_cast<CeeSection*>(section);
    CeeSection *relSec = reinterpret_cast<CeeSection*>(relativeTo);

    if (relSec)
        return(sec->addSectReloc(offset, *relSec, relocType));
    else
        return(sec->addBaseReloc(offset, relocType));
}

HRESULT ICeeFileGen::SetSectionDirectoryEntry(HCEESECTION section, ULONG num)
{
    TESTANDRETURNPOINTER(section);

    printf("Warning: deprecated method. Use SetDirectoryEntry instead\n");
    CeeSection *sec = reinterpret_cast<CeeSection*>(section);
    return(sec->directoryEntry(num));
}

HRESULT ICeeFileGen::SetOutputFileName (HCEEFILE ceeFile, LPWSTR outputFileName)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(outputFileName);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->setOutputFileName(outputFileName));
}

HRESULT ICeeFileGen::GetOutputFileName (HCEEFILE ceeFile, LPWSTR *outputFileName)
{   
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(outputFileName);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    TESTANDRETURNPOINTER(outputFileName);
    *outputFileName = gen->getOutputFileName();
    return S_OK;
}


HRESULT ICeeFileGen::SetResourceFileName (HCEEFILE ceeFile, LPWSTR resourceFileName)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(resourceFileName);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->setResourceFileName(resourceFileName));
}

HRESULT ICeeFileGen::GetResourceFileName (HCEEFILE ceeFile, LPWSTR *resourceFileName)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(resourceFileName);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    TESTANDRETURNPOINTER(resourceFileName);
    *resourceFileName = gen->getResourceFileName();
    return S_OK;
}


HRESULT ICeeFileGen::SetImageBase(HCEEFILE ceeFile, size_t imageBase)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    gen->setImageBase(imageBase);
    return S_OK;
}

HRESULT ICeeFileGen::SetFileAlignment(HCEEFILE ceeFile, ULONG fileAlignment)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    gen->setFileAlignment(fileAlignment);
    return S_OK;
}

HRESULT ICeeFileGen::SetSubsystem(HCEEFILE ceeFile, DWORD subsystem, DWORD major, DWORD minor)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    gen->setSubsystem(subsystem, major, minor);
    return S_OK;
}

HRESULT ICeeFileGen::GetIMapTokenIface(HCEEFILE ceeFile, IMetaDataEmit *emitter, IUnknown **pIMapToken)
{
    _ASSERTE(!"This is an obsolete function!");
    return E_NOTIMPL;
}

HRESULT ICeeFileGen::EmitMetaData (HCEEFILE ceeFile, IMetaDataEmit *emitter,
                                                                mdScope scopeE)
{
    _ASSERTE(!"This is an obsolete function!");
    return E_NOTIMPL;
}

HRESULT ICeeFileGen::EmitLibraryName (HCEEFILE ceeFile, IMetaDataEmit *emitter,
                                                                mdScope scopeE)
{
    _ASSERTE(!"This is an obsolete function!");
    return E_NOTIMPL;
}

HRESULT ICeeFileGen::GetMethodRVA(HCEEFILE ceeFile, ULONG codeOffset, ULONG *codeRVA)
{
    TESTANDRETURNARG(ceeFile != 0);
    TESTANDRETURNPOINTER(codeRVA);
    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    gen->getMethodRVA(codeOffset, codeRVA);
    return S_OK;
}

HRESULT ICeeFileGen::EmitString(HCEEFILE ceeFile, LPWSTR strValue, ULONG *strRef)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->getStringSection().getEmittedStringRef(strValue, strRef));
}

HRESULT ICeeFileGen::LinkCeeFile (HCEEFILE ceeFile)
{
    TESTANDRETURNPOINTER(ceeFile);
    
    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->link();
}

HRESULT ICeeFileGen::FixupCeeFile (HCEEFILE ceeFile)
{
    TESTANDRETURNPOINTER(ceeFile);
    
    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->fixup();
}

HRESULT ICeeFileGen::GenerateCeeFile (HCEEFILE ceeFile)
{
    TESTANDRETURNPOINTER(ceeFile);
    
    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->generateImage(NULL);     // NULL means don't write in-memory buffer, uses outputFileName
}

// GenerateCeeMemoryImage - returns in ppImage an in-memory PE image allocated by CoTaskMemAlloc() 
// the caller is responsible for calling CoTaskMemFree on this memory image
HRESULT ICeeFileGen::GenerateCeeMemoryImage (HCEEFILE ceeFile, void **ppImage)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(ppImage);
    
    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->generateImage(ppImage);
}

HRESULT ICeeFileGen::SetEntryPoint(HCEEFILE ceeFile, mdMethodDef method)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->setEntryPoint(method);
}

HRESULT ICeeFileGen::GetEntryPoint(HCEEFILE ceeFile, mdMethodDef *method)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    TESTANDRETURNPOINTER(method);
    *method = gen->getEntryPoint();
    return S_OK;
}


HRESULT ICeeFileGen::SetComImageFlags (HCEEFILE ceeFile, DWORD mask)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->setComImageFlags(mask);
}

HRESULT ICeeFileGen::ClearComImageFlags (HCEEFILE ceeFile, DWORD mask)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->clearComImageFlags(mask);
}

HRESULT ICeeFileGen::GetComImageFlags (HCEEFILE ceeFile, DWORD *mask)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    TESTANDRETURNPOINTER(mask);
    *mask = gen->getComImageFlags();
    return S_OK;
}


HRESULT ICeeFileGen::SetDllSwitch (HCEEFILE ceeFile, BOOL dllSwitch)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->setDllSwitch(dllSwitch==TRUE));
}

HRESULT ICeeFileGen::GetDllSwitch (HCEEFILE ceeFile, BOOL *dllSwitch)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    TESTANDRETURNPOINTER(dllSwitch);
    *dllSwitch = gen->getDllSwitch();
    return S_OK;
}

HRESULT ICeeFileGen::SetObjSwitch (HCEEFILE ceeFile, BOOL objSwitch)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->setObjSwitch(objSwitch==TRUE));
}

HRESULT ICeeFileGen::GetObjSwitch (HCEEFILE ceeFile, BOOL *objSwitch)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    TESTANDRETURNPOINTER(objSwitch);
    *objSwitch = gen->getObjSwitch();
    return S_OK;
}


HRESULT ICeeFileGen::SetLibraryName (HCEEFILE ceeFile, LPWSTR LibraryName)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(LibraryName);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->setLibraryName(LibraryName));
}

HRESULT ICeeFileGen::SetLibraryGuid (HCEEFILE ceeFile, LPWSTR LibraryGuid)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(LibraryGuid);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->setLibraryGuid(LibraryGuid));
}

HRESULT ICeeFileGen::GetLibraryName (HCEEFILE ceeFile, LPWSTR *LibraryName)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(LibraryName);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    *LibraryName = gen->getLibraryName();
    return S_OK;
}



HRESULT ICeeFileGen::EmitMetaDataEx (HCEEFILE ceeFile, IMetaDataEmit *emitter)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(emitter);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->emitMetaData(emitter));
}

HRESULT ICeeFileGen::EmitMetaDataAt (HCEEFILE ceeFile, IMetaDataEmit *emitter, HCEESECTION section, DWORD offset, BYTE* buffer, unsigned buffLen)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(emitter);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    CeeSection* sec = reinterpret_cast<CeeSection*>(section);

    return(gen->emitMetaData(emitter, sec, offset, buffer, buffLen));
}

HRESULT ICeeFileGen::EmitLibraryNameEx (HCEEFILE ceeFile, IMetaDataEmit *emitter)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(emitter);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->emitLibraryName(emitter));
}

HRESULT ICeeFileGen::GetIMapTokenIfaceEx(HCEEFILE ceeFile, IMetaDataEmit *emitter, IUnknown **pIMapToken)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(pIMapToken);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->getMapTokenIface(pIMapToken);
}

HRESULT ICeeFileGen::AddNotificationHandler(HCEEFILE ceeFile,
                                            IUnknown *pHandler)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(pHandler);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->addNotificationHandler(pHandler);
}

HRESULT ICeeFileGen::EmitMacroDefinitions(HCEEFILE ceeFile, void *pData, DWORD cData)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->EmitMacroDefinitions(pData, cData);
}

HRESULT ICeeFileGen::SetManifestEntry(HCEEFILE ceeFile, ULONG size, ULONG offset)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->setManifestEntry(size, offset);
}

HRESULT ICeeFileGen::SetStrongNameEntry(HCEEFILE ceeFile, ULONG size, ULONG offset)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->setStrongNameEntry(size, offset);
}

HRESULT ICeeFileGen::ComputeSectionOffset(HCEESECTION section, char *ptr,
										  unsigned *offset)
{
    TESTANDRETURNPOINTER(section);

    CeeSection &sec = *(reinterpret_cast<CeeSection*>(section));

	*offset = sec.computeOffset(ptr);

	return S_OK;
}

HRESULT ICeeFileGen::ComputeSectionPointer(HCEESECTION section, ULONG offset,
										  char **ptr)
{
    TESTANDRETURNPOINTER(section);

    CeeSection &sec = *(reinterpret_cast<CeeSection*>(section));

	*ptr = sec.computePointer(offset);

	return S_OK;
}

HRESULT ICeeFileGen::ComputeOffset(HCEEFILE ceeFile, char *ptr,
								   HCEESECTION *pSection, unsigned *offset)
{
    TESTANDRETURNPOINTER(pSection);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);

	CeeSection *section;
	
	HRESULT hr = gen->computeOffset(ptr, &section, offset);

	if (SUCCEEDED(hr))
		*pSection = reinterpret_cast<HCEESECTION>(section);

	return hr;
}

HRESULT ICeeFileGen::SetEnCRVABase(HCEEFILE ceeFile, ULONG dataBase, ULONG rdataBase)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->setEnCRvaBase(dataBase, rdataBase);
}

HRESULT ICeeFileGen::GetCorHeader(HCEEFILE ceeFile,
								  IMAGE_COR20_HEADER **header)
{
    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
	return gen->getCorHeader(header);
}

HRESULT ICeeFileGen::SetVTableEntry(HCEEFILE ceeFile, ULONG size, ULONG offset)
{
    TESTANDRETURNPOINTER(ceeFile);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return gen->setVTableEntry(size, offset);
}

HRESULT ICeeFileGen::GetFileTimeStamp (HCEEFILE ceeFile, time_t *pTimeStamp)
{
    TESTANDRETURNPOINTER(ceeFile);
    TESTANDRETURNPOINTER(pTimeStamp);

    CeeFileGenWriter *gen = reinterpret_cast<CeeFileGenWriter*>(ceeFile);
    return(gen->getFileTimeStamp(pTimeStamp));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\pewriter.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"

#include "BlobFetcher.h"

#include "debug.h"

    /* This is the stub program that says it can't be run in DOS mode */
    /* it is x86 specific, but so is dos so I suppose that is OK */
static unsigned char x86StubPgm[] = { 
    0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f,
    0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20,
    0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    /* number of pad bytes to make 'len' bytes align to 'align' */
inline static unsigned roundUp(unsigned len, unsigned align) {
    return((len + align-1) & ~(align-1));
}

inline static unsigned padLen(unsigned len, unsigned align) {
    return(roundUp(len, align) - len);
}

// Stdio is not guaranteed to set GetLastError(), so make sure we have
// a default error in place.

inline HRESULT HRESULT_FROM_STDIO(int defaultvalue)
{
    HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
    if (hr == S_OK)
        hr = HRESULT_FROM_WIN32(defaultvalue);
    return hr;
} 

#define HRESULT_FROM_STDIO_WRITE() HRESULT_FROM_STDIO(ERROR_WRITE_FAULT)
#define HRESULT_FROM_STDIO_READ() HRESULT_FROM_STDIO(ERROR_READ_FAULT)

#ifndef IMAGE_DLLCHARACTERISTICS_NO_SEH
#define IMAGE_DLLCHARACTERISTICS_NO_SEH 0x400  // image does not use SEH, no SEH exist in image.
#endif

#define COPY_AND_ADVANCE(target, src, size) { \
                            ::memcpy((void *) target, (void *)src, size); \
                            ((char *)target) += size; }

/******************************************************************/
int __cdecl relocCmp(const void* a_, const void* b_) {

    const PESectionReloc* a = (const PESectionReloc*) a_;
    const PESectionReloc* b = (const PESectionReloc*) b_;
    return(a->offset - b->offset);
}

PERelocSection::PERelocSection(PEWriterSection *pBaseReloc)
{
   section = pBaseReloc;
   relocPage = -1; 
   relocSize = 0; 
   relocSizeAddr = NULL; 
   pages = 0;

#if _DEBUG
   lastRVA = 0;
#endif
} 

void PERelocSection::AddBaseReloc(unsigned rva, int type, unsigned short highAdj)
{
#if _DEBUG
    // Guarantee that we're adding relocs in strict increasing order.
    _ASSERTE(rva > lastRVA);
    lastRVA = rva;
#endif

    if (relocPage != (rva & ~0xFFF)) {
        if (relocSizeAddr) {        
            if ((relocSize & 1) == 1) {     // pad to an even number
				short *ps = (short*) section->getBlock(2);
				if(ps)
				{
					*ps = 0;
					relocSize++;
				}
            }
            *relocSizeAddr = relocSize*2 + sizeof(IMAGE_BASE_RELOCATION);                       
        }
        IMAGE_BASE_RELOCATION* base = (IMAGE_BASE_RELOCATION*) section->getBlock(sizeof(IMAGE_BASE_RELOCATION));
		if(base)
		{
			relocPage = (rva & ~0xFFF);  
			relocSize = 0;
			base->VirtualAddress = relocPage;
			// Size needs to be fixed up when we know it - save address here
			relocSizeAddr = &base->SizeOfBlock;
			pages++;
		}
    }

    relocSize++;
    unsigned short* offset = (unsigned short*) section->getBlock(2);
	if(offset)
	{
		*offset = (rva & 0xFFF) | (type << 12);
		if (type == srRelocHighAdj) {
			offset = (unsigned short*) section->getBlock(2);
			if(offset)
			{
				*offset = highAdj;
				relocSize++;
			}
		}
	}
}

void PERelocSection::Finish()
{
    // fixup the last reloc block (if there was one)
    if (relocSizeAddr) {
        if ((relocSize & 1) == 1) {     // pad to an even number
			short* psh = (short*) section->getBlock(2);
			if(psh)
			{
				*psh = 0;
				relocSize++;
			}
        }
        *relocSizeAddr = relocSize*2 + sizeof(IMAGE_BASE_RELOCATION);
    }   
    else if (pages == 0)
    {
        // 
        // We need a non-empty reloc directory, for pre-Win2K OS's
        // @todo: it would be nice to know when we're generating prejit exes
        // which don't have to be portable, then we could skip this under Win2K.
        //

        IMAGE_BASE_RELOCATION* base = (IMAGE_BASE_RELOCATION*) 
          section->getBlock(sizeof(IMAGE_BASE_RELOCATION));
		if(base)
		{
			base->VirtualAddress = 0;
			base->SizeOfBlock = sizeof(IMAGE_BASE_RELOCATION) + 2*sizeof(unsigned short);
            
			// Dummy reloc - "absolute" reloc on position 0
			unsigned short *offset = (unsigned short *) section->getBlock(2);
			if(offset)
			{
				*offset = (IMAGE_REL_BASED_ABSOLUTE << 12);

				// padding
				if(offset = (unsigned short *) section->getBlock(2))
					*offset = 0;
			}
		}
    }
}


/******************************************************************/
/* apply the relocs for this section.  Generate relocations in
   'relocsSection' too
   Only for Static Conversion
   Returns the last reloc page - pass back in to next call.  (Pass -1 for first call)
*/

void PEWriterSection::applyRelocs(size_t imageBase, PERelocSection* pBaseRelocSection, CeeGenTokenMapper *pTokenMapper,
                                       DWORD dataRvaBase, DWORD rdataRvaBase) 
{
    _ASSERTE(pBaseRelocSection); // need section to write relocs

    if (m_relocCur == m_relocStart)
        return;
    // dbPrintf(("APPLYING section relocs for section %s start RVA = 0x%x\n", m_name, m_baseRVA));

    // sort them to make the baseRelocs pretty
    qsort(m_relocStart, m_relocCur-m_relocStart, sizeof(PESectionReloc), relocCmp);

    for(PESectionReloc* cur = m_relocStart; cur < m_relocCur; cur++) {
        _ASSERTE(cur->offset + 4 <= m_blobFetcher.GetDataLen());

        UNALIGNED size_t* pos = (size_t*)m_blobFetcher.ComputePointer(cur->offset);

        // Compute offset from pointer if necessary
        //
        int type = cur->type;
        if (type & srRelocPtr)
        {
            if (type == srRelocRelativePtr)
                *pos = cur->section->computeOffset((char*)pos + *pos);
            else
                *pos = cur->section->computeOffset((char*)*pos);
            type &= ~srRelocPtr;
        }

        // dbPrintf(("   APPLYING at offset 0x%x to section %s\n", 
        //                      cur->offset, cur->section->m_name));
        if (type == srRelocAbsolute) {
            // we have a full 32-bit value at offset
            if (rdataRvaBase > 0 && ! strcmp((const char *)(cur->section->m_name), ".rdata"))
                *pos += rdataRvaBase;
            else if (dataRvaBase > 0 && ! strcmp((const char *)(cur->section->m_name), ".data"))
                *pos += dataRvaBase;
            else
                *pos += cur->section->m_baseRVA;
        } else if (type == srRelocMapToken) {
            mdToken newToken;
            if (pTokenMapper != NULL && pTokenMapper->HasTokenMoved((mdToken)*pos, newToken)) {
                // we have a mapped token
                *pos = newToken;
            }
        } else if (type == srRelocFilePos) {
            *pos += cur->section->m_filePos;
        } else if (type == srRelocRelative) {
            *pos += cur->section->m_baseRVA - (m_baseRVA + cur->offset);
        } else {
            if (type == srRelocLow) {
                // we have a the bottom 16-bits of a 32-bit value at offset
                *(USHORT*)pos += (USHORT)(imageBase + cur->section->m_baseRVA);
            } else if (type == srRelocHighLow) {
                // we have a full 32-bit value at offset
                *pos += imageBase + cur->section->m_baseRVA;
            } else if (type == srRelocHigh || type == srRelocHighAdj) {
                // we have a the top 16-bits of a 32-bit value at offset
                // need to add 0x8000 because when the two pieces are put back
                // together, the bottom 16 bits are sign-extended, so the 0x8000
                // will offset that sign extension by adding 1 to the top 16
                // if the high bit of the bottom 16 is 1.
                *(unsigned short*)pos += (USHORT)((imageBase + cur->section->m_baseRVA + cur->extra.highAdj + 0x8000) >> 16);
            }

            pBaseRelocSection->AddBaseReloc(m_baseRVA + cur->offset, cur->type, cur->extra.highAdj);
        }
    }
}

/******************************************************************/
HRESULT PEWriter::Init(PESectionMan *pFrom) {

    if (pFrom)
        *(PESectionMan*)this = *pFrom;
    else {
        HRESULT hr = PESectionMan::Init();  
        if (FAILED(hr))
            return hr;
    }
    time_t now;
    time(&now);

    // Save the timestamp so that we can give it out if someone needs
    // it.
    m_peFileTimeStamp = now;
    
    ntHeaders = new IMAGE_NT_HEADERS32;
    if (!ntHeaders)
        return E_OUTOFMEMORY;
    memset(ntHeaders, 0, sizeof(IMAGE_NT_HEADERS32));

    cEntries = IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR + 1;
    pEntries = new directoryEntry[cEntries];
    if (pEntries == NULL)
        return E_OUTOFMEMORY;
    memset(pEntries, 0, sizeof(*pEntries) * cEntries);

    ntHeaders->OptionalHeader.AddressOfEntryPoint = 0;
    ntHeaders->Signature = IMAGE_NT_SIGNATURE;
    ntHeaders->FileHeader.Machine = IMAGE_FILE_MACHINE_I386;
    ntHeaders->FileHeader.TimeDateStamp = (ULONG)now;
    ntHeaders->FileHeader.SizeOfOptionalHeader = sizeof(IMAGE_OPTIONAL_HEADER32);
    ntHeaders->FileHeader.Characteristics = 0;

    ntHeaders->OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;

    // Linker version should be consistent with current VC level
    ntHeaders->OptionalHeader.MajorLinkerVersion = 6;
    ntHeaders->OptionalHeader.MinorLinkerVersion = 0;

    ntHeaders->OptionalHeader.ImageBase = 0x400000;
    ntHeaders->OptionalHeader.SectionAlignment = IMAGE_NT_OPTIONAL_HDR_SECTION_ALIGNMENT;
    ntHeaders->OptionalHeader.FileAlignment = 0;
    ntHeaders->OptionalHeader.MajorOperatingSystemVersion = 4;
    ntHeaders->OptionalHeader.MinorOperatingSystemVersion = 0;
    ntHeaders->OptionalHeader.MajorImageVersion = 0;
    ntHeaders->OptionalHeader.MinorImageVersion = 0;
    ntHeaders->OptionalHeader.MajorSubsystemVersion = 4;
    ntHeaders->OptionalHeader.MinorSubsystemVersion = 0;
    ntHeaders->OptionalHeader.Win32VersionValue = 0;
    // FIX what should this be?
    ntHeaders->OptionalHeader.Subsystem = 0;

    ntHeaders->OptionalHeader.DllCharacteristics = 0;
    setDllCharacteristics(IMAGE_DLLCHARACTERISTICS_NO_SEH);
    
    ntHeaders->OptionalHeader.SizeOfStackReserve = 0x100000;
    ntHeaders->OptionalHeader.SizeOfStackCommit = 0x1000;
    ntHeaders->OptionalHeader.SizeOfHeapReserve = 0x100000;
    ntHeaders->OptionalHeader.SizeOfHeapCommit = 0x1000;
    ntHeaders->OptionalHeader.LoaderFlags = 0;
    ntHeaders->OptionalHeader.NumberOfRvaAndSizes = 16;

    m_ilRVA = -1;
    m_dataRvaBase = 0;
    m_rdataRvaBase = 0;
    m_encMode = FALSE;

    virtualPos = 0;
    filePos = 0;
    reloc = NULL;
    strtab = NULL;
    headers = NULL;
    headersEnd = NULL;

    m_file = NULL;

    return S_OK;
}

/******************************************************************/
HRESULT PEWriter::Cleanup() {    
    delete ntHeaders;

    if (headers != NULL)
        delete [] headers;

    if (pEntries != NULL)
        delete [] pEntries;

    return PESectionMan::Cleanup();
}

ULONG PEWriter::getIlRva() 
{    
    // assume that pe optional header is less than size of section alignment. So this
    // gives out the rva for the .text2 section, which is merged after the .text section
    // This is verified in debug build when actually write out the file
    _ASSERTE(m_ilRVA > 0);
    return m_ilRVA;
}

void PEWriter::setIlRva(ULONG offset) 
{    
    // assume that pe optional header is less than size of section alignment. So this
    // gives out the rva for the .text section, which is merged after the .text0 section
    // This is verified in debug build when actually write out the file
    m_ilRVA = roundUp(ntHeaders->OptionalHeader.SectionAlignment + offset, SUBSECTION_ALIGN);
}

HRESULT PEWriter::setDirectoryEntry(PEWriterSection *section, ULONG entry, ULONG size, ULONG offset)
{
    if (entry >= cEntries)
    {
        USHORT cNewEntries = cEntries * 2;
        if (entry >= cNewEntries)
            cNewEntries = (USHORT) entry+1;

        directoryEntry *pNewEntries = new directoryEntry [ cNewEntries ];
        if (pNewEntries == NULL)
            return E_OUTOFMEMORY;

        CopyMemory(pNewEntries, pEntries, cEntries * sizeof(*pNewEntries));
        ZeroMemory(pNewEntries + cEntries, (cNewEntries - cEntries) * sizeof(*pNewEntries));

        delete [] pEntries;
        pEntries = pNewEntries;
        cEntries = cNewEntries;
    }

    pEntries[entry].section = section;
    pEntries[entry].offset = offset;
    pEntries[entry].size = size;
    return S_OK;
}

void PEWriter::setEnCRvaBase(ULONG dataBase, ULONG rdataBase)
{
    m_dataRvaBase = dataBase;
    m_rdataRvaBase = rdataBase;
    m_encMode = TRUE;
}

//-----------------------------------------------------------------------------
// These 2 write functions must be implemented here so that they're in the same
// .obj file as whoever creates the FILE struct. We can't pass a FILE struct
// across a dll boundary (PEWriter.lib <--> MSCorXvt.dll) and use it.
//-----------------------------------------------------------------------------

HRESULT PEWriterSection::write(FILE *file)
{
    return m_blobFetcher.Write(file);
}

HRESULT PEWriterSection::verify(FILE *file)
{
    HRESULT hr = m_blobFetcher.Verify(file);
    _ASSERTE(SUCCEEDED(hr) || !"Verification failure - investigate!!!!");
    return hr;
}

//-----------------------------------------------------------------------------
// Write out the section to the stream
//-----------------------------------------------------------------------------
HRESULT CBlobFetcher::Write(FILE* file)
{
// Must write out each pillar (including idx = m_nIndexUsed), one after the other
    unsigned idx;
    for(idx = 0; idx <= m_nIndexUsed; idx ++) {
        if (m_pIndex[idx].GetDataLen() > 0)
        {
            ULONG length = m_pIndex[idx].GetDataLen();
            ULONG written = fwrite(m_pIndex[idx].GetRawDataStart(), 1, length, file);
            if (written != length)
                return HRESULT_FROM_STDIO_WRITE();
        }
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Write out the section to the stream
//-----------------------------------------------------------------------------
HRESULT CBlobFetcher::Verify(FILE* file)
{
// Must verify each pillar (including idx = m_nIndexUsed), one after the other
    unsigned idx;
    for(idx = 0; idx <= m_nIndexUsed; idx ++) {
        if (m_pIndex[idx].GetDataLen() > 0)
        {
            ULONG length = m_pIndex[idx].GetDataLen();
            CQuickBytes b;
            b.Alloc(length);
            ULONG read = fread(b.Ptr(), 1, length, file);
            if (read != length)
            {
                _ASSERTE(!"Verification failure - investigate!!!!");
                return HRESULT_FROM_STDIO_READ();
            }
            if (memcmp(b.Ptr(), m_pIndex[idx].GetRawDataStart(), length) != 0)
            {
                _ASSERTE(!"Verification failure - investigate!!!!");
                return HRESULT_FROM_WIN32(ERROR_FILE_INVALID);
            }
        }
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// These 2 write functions must be implemented here so that they're in the same
// .obj file as whoever creates the FILE struct. We can't pass a FILE struct
// across a dll boundary (PEWriter.lib <--> MSCorXvt.dll) and use it.
//-----------------------------------------------------------------------------

unsigned PEWriterSection::writeMem(void **ppMem)
{
    HRESULT hr = m_blobFetcher.WriteMem(ppMem);
    _ASSERTE(SUCCEEDED(hr));

    return m_blobFetcher.GetDataLen();
}

//-----------------------------------------------------------------------------
// Write out the section to memory
//-----------------------------------------------------------------------------
HRESULT CBlobFetcher::WriteMem(void **ppMem)
{
    char **ppDest = (char **)ppMem;
// Must write out each pillar (including idx = m_nIndexUsed), one after the other
    unsigned idx;
    for(idx = 0; idx <= m_nIndexUsed; idx ++) {
        if (m_pIndex[idx].GetDataLen() > 0)
    {
      // WARNING: macro - must enclose in curly braces
            COPY_AND_ADVANCE(*ppDest, m_pIndex[idx].GetRawDataStart(), m_pIndex[idx].GetDataLen());
    }
    }

    return S_OK;
}

/******************************************************************/

//
// Intermediate table to sort to help determine section order
//
struct entry {
    const char *name;
    unsigned char nameLength;
    signed char index;
    unsigned short arrayIndex;
};

HRESULT PEWriter::link() {

    //
    // NOTE: 
    // link() can be called more than once!  This is because at least one compiler
    // (the prejitter) needs to know the base addresses of some segments before it
    // builds others. It's up to the caller to insure the layout remains the same 
    // after changes are made, though.
    //

    //
    // Assign base addresses to all sections, and layout & merge PE sections
    //

    bool ExeOrDll = ((ntHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)!=0);

    //
    // Preserve current section order as much as possible, but apply the following
    // rules:
    //  - sections named "xxx#" are collated into a single PE section "xxx".  
    //      The contents of the CeeGen sections are sorted according to numerical 
    //      order & made contiguous in the PE section
    //  - "text" always comes first in the file
    //  - empty sections receive no PE section
    //

    //
    // Collate by name & sort by index
    // 

    int sectCount = (int)(getSectCur() - getSectStart());
    entry *entries = (entry *) _alloca(sizeof(entry) * sectCount);

    entry *e = entries;
    for (PEWriterSection **cur = getSectStart(); cur < getSectCur(); cur++) {

        //
        // Throw away any old headers we've used.
        //

        (*cur)->m_header = NULL;
    
        //
        // Don't allocate PE data for 0 length sections
        //

        if ((*cur)->dataLen() == 0)
            continue;

        //
        // Special case: omit "text0" from obj's
        //
        
        if (!ExeOrDll && strcmp((*cur)->m_name, ".text0") == 0)
            continue;

        e->name = (*cur)->m_name;

        //
        // Now compute the end of the text part of the section name.
        //

        _ASSERTE(strlen(e->name) < UCHAR_MAX);
        const char *p = e->name + strlen(e->name);
        int index = 0;
        if (isdigit(p[-1]))
        {
            while (--p > e->name)
            {
                if (!isdigit(*p))
                    break;
                index *= 10;
                index += *p - '0';
            }
            p++;
            
            //
            // Special case: put "xxx" after "xxx0" and before "xxx1"
            //

            if (index == 0)
                index = -1;
        }

        e->nameLength = (unsigned char)(p - e->name);
        e->index = index;
        e->arrayIndex = (unsigned short)(cur - getSectStart());
        e++;
    }

    entry *entriesEnd = e;

    //
    // Sort the entries according to alphabetical + numerical order
    //

    class sorter : public CQuickSort<entry>
    {
      public:
        sorter(entry *entries, int count) : CQuickSort<entry>(entries, count) {}

        int Compare(entry *first, entry *second)
        {
            int lenResult = first->nameLength - second->nameLength;
            int len;
            if (lenResult < 0)
                len = first->nameLength;
            else
                len = second->nameLength;
                
            int result = strncmp(first->name, second->name, len);

            if (result != 0)
                return result;
            else if (lenResult != 0)
                return lenResult;
            else
                return (int)(first->index - second->index);
        }
    } sorter(entries, (int)(entriesEnd - entries));

    sorter.Sort();

    //
    // Now, allocate a header for each unique section name.
    // Also record the minimum section index for each section
    // so we can preserve order as much as possible.
    //

    if (headers != NULL)
        delete [] headers;
    headers = new IMAGE_SECTION_HEADER [entriesEnd - entries + 1]; // extra for .reloc
    if (headers == NULL)
        return E_OUTOFMEMORY;

    memset(headers, 0, sizeof(*headers) * (entriesEnd - entries + 1));

    static char *specials[] = { ".text", ".cormeta", NULL };
    enum { SPECIAL_COUNT = 2 };

    entry *ePrev = NULL;
    IMAGE_SECTION_HEADER *h = headers-1;
    for (e = entries; e < entriesEnd; e++)
    {
        //
        // Store a sorting index into the VirtualAddress field
        //

        if (ePrev != NULL
            && e->nameLength == ePrev->nameLength
            && strncmp(e->name, ePrev->name, e->nameLength) == 0)
        {
            //
            // Adjust our sorting index if we're ahead in the
            // section list
            //
            if (h->VirtualAddress > SPECIAL_COUNT
                && e->arrayIndex < ePrev->arrayIndex)
                h->VirtualAddress = e->arrayIndex + SPECIAL_COUNT;

            // Store an approximation of the size of the section temporarily
            h->Misc.VirtualSize += getSectStart()[e->arrayIndex]->dataLen();
        }
        else
        {
            h++;
            strncpy((char *) h->Name, e->name, e->nameLength);

            //
            // Reserve some dummy "array index" values for
            // special sections at the start of the image
            //

            char **s = specials;
            while (TRUE)
            {
                if (*s == 0)
                {
                    h->VirtualAddress = e->arrayIndex + SPECIAL_COUNT;
                    break;
                }
                else if (strcmp((char *) h->Name, *s) == 0)
                {
                    h->VirtualAddress = (DWORD) (s - specials);
                    break;
                }
                s++;
            }
            
            // Store the entry index in this field temporarily
            h->SizeOfRawData = (DWORD)(e - entries);

            // Store an approximation of the size of the section temporarily
            h->Misc.VirtualSize = getSectStart()[e->arrayIndex]->dataLen();
        }
        ePrev = e;
    }

    headersEnd = ++h;

    //
    // Sort the entries according to alphabetical + numerical order
    //

    class headerSorter : public CQuickSort<IMAGE_SECTION_HEADER>
    {
      public:
        headerSorter(IMAGE_SECTION_HEADER *headers, int count) 
          : CQuickSort<IMAGE_SECTION_HEADER>(headers, count) {}

        int Compare(IMAGE_SECTION_HEADER *first, IMAGE_SECTION_HEADER *second)
        {
            return first->VirtualAddress - second->VirtualAddress;
        }
    } headerSorter(headers, (int)(headersEnd - headers));

    headerSorter.Sort();

	//
	// If it's not zero, it must have been set through
	//	setFileAlignment(), in which case we leave it untouched
	//
	if( 0 == ntHeaders->OptionalHeader.FileAlignment )
	{
	    //
	    // Figure out what file alignment to use.  For small files, use 512 bytes.
	    // For bigger files, use 4K for efficiency on win98.
	    //

	    unsigned RoundUpVal;
	    if (ExeOrDll)
	    {
	        const int smallFileAlignment = 0x200;
	        const int optimalFileAlignment = 0x1000;

	        int size = 0, waste = 0;
	        IMAGE_SECTION_HEADER *h = headers;
	        while (h < headersEnd)
	        {
	            size += roundUp(h->Misc.VirtualSize, optimalFileAlignment);
	            waste += padLen(h->Misc.VirtualSize, optimalFileAlignment);
	            h++;
	        }

	        // don't tolerate more than 25% waste if possible.
	        if (waste*4 > size)
	            RoundUpVal = smallFileAlignment;
	        else
	            RoundUpVal = optimalFileAlignment;
	    }
	    else
	    {
	        // Don't bother padding for objs
	        RoundUpVal = 4;
	    }

	    ntHeaders->OptionalHeader.FileAlignment = RoundUpVal;
	}
	
    //
    // Now, assign a section header & location to each section
    //

    ntHeaders->FileHeader.NumberOfSections = (WORD)(headersEnd - headers);

    if (ExeOrDll)
        ntHeaders->FileHeader.NumberOfSections++; // One more for .reloc

    filePos = roundUp(
        ntHeaders->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)+ 
        (ExeOrDll ? sizeof(IMAGE_DOS_HEADER)+sizeof(x86StubPgm)
                    +sizeof(IMAGE_NT_HEADERS32)
                  : sizeof(IMAGE_FILE_HEADER)), 
                  ntHeaders->OptionalHeader.FileAlignment
                  );
    ntHeaders->OptionalHeader.SizeOfHeaders = filePos;

    virtualPos = roundUp(filePos, ntHeaders->OptionalHeader.SectionAlignment);

    for (h = headers; h < headersEnd; h++)
    {
        h->VirtualAddress = virtualPos;
        h->PointerToRawData = filePos;

        e = entries + h->SizeOfRawData;
        
        PEWriterSection *s = getSectStart()[e->arrayIndex];
        s->m_baseRVA = virtualPos;
        s->m_filePos = filePos;
        s->m_header = h;
        h->Characteristics = s->m_flags;
        
        unsigned dataSize = s->dataLen();

        PEWriterSection *sPrev = s;
        ePrev = e;
        while (++e < entriesEnd)
        {
           if (e->nameLength != ePrev->nameLength
               || strncmp(e->name, ePrev->name, e->nameLength) != 0)
               break;

           s = getSectStart()[e->arrayIndex];
           _ASSERTE(s->m_flags == h->Characteristics);

           // @todo: add a field on section to specify alignment?
           // Need 16 byte alignment for import table.
           sPrev->m_filePad = padLen(dataSize, SUBSECTION_ALIGN);
           dataSize = roundUp(dataSize, SUBSECTION_ALIGN);

           s->m_baseRVA = virtualPos + dataSize;
           s->m_filePos = filePos + dataSize;
           s->m_header = h;
           sPrev = s;

           dataSize += s->dataLen();
           
           ePrev = e;
        }

        h->Misc.VirtualSize = dataSize;

        sPrev->m_filePad = padLen(
        					dataSize, 
        					ntHeaders->OptionalHeader.FileAlignment
        					);
        dataSize = roundUp(
        					dataSize, 
        					ntHeaders->OptionalHeader.FileAlignment
					        );
        h->SizeOfRawData = dataSize;
        filePos += dataSize;

        dataSize = roundUp(dataSize, ntHeaders->OptionalHeader.SectionAlignment);
        virtualPos += dataSize;
    }

    return S_OK;
}



HRESULT PEWriter::fixup(CeeGenTokenMapper *pMapper) {

    HRESULT hr;

    bool ExeOrDll = ((ntHeaders->FileHeader.Characteristics 
                      & IMAGE_FILE_EXECUTABLE_IMAGE)!=0);
    const unsigned RoundUpVal = ntHeaders->OptionalHeader.FileAlignment;

    if(ExeOrDll)
    {
        // 
        // Apply manual relocation for entry point field
        //

        PESection *textSection;
        IfFailRet(getSectionCreate(".text", 0, &textSection));

        if (ntHeaders->OptionalHeader.AddressOfEntryPoint != 0)
            ntHeaders->OptionalHeader.AddressOfEntryPoint += textSection->m_baseRVA;

        //
        // Apply normal relocs
        //

        IfFailRet(getSectionCreate(".reloc", sdReadOnly | IMAGE_SCN_MEM_DISCARDABLE, 
                                   (PESection **) &reloc));
        reloc->m_baseRVA = virtualPos;
        reloc->m_filePos = filePos;
        reloc->m_header = headersEnd++;
        strcpy((char *)reloc->m_header->Name, ".reloc");
        reloc->m_header->Characteristics = reloc->m_flags;
        reloc->m_header->VirtualAddress = virtualPos;
        reloc->m_header->PointerToRawData = filePos;

    #ifdef _DEBUG
        if (m_encMode)
            printf("Applying relocs for .rdata section with RVA %x\n", m_rdataRvaBase);
    #endif

        //
        // Sort the sections by RVA
        //

        CQuickArray<PEWriterSection *> sections;

        UINT count = getSectCur() - getSectStart();
        IfFailRet(sections.ReSize(count));
        UINT i = 0;
        for(PEWriterSection **cur = getSectStart(); cur < getSectCur(); cur++, i++) 
            sections[i] = *cur;

        class SectionSorter : public CQuickSort<PEWriterSection*>
        {
        public:
            SectionSorter(PEWriterSection **elts, SSIZE_T count) 
              : CQuickSort<PEWriterSection*>(elts, count) {}

            int Compare(PEWriterSection **e1, PEWriterSection **e2)
              { 
                  return (*e1)->getBaseRVA() - (*e2)->getBaseRVA();
              }
        } sorter(sections.Ptr(), sections.Size());

        sorter.Sort();

        PERelocSection relocSection(reloc);

        cur = sections.Ptr();
        PEWriterSection **curEnd = cur + sections.Size();
        while (cur < curEnd)
        {
            (*cur)->applyRelocs(ntHeaders->OptionalHeader.ImageBase, &relocSection, 
                                pMapper, m_dataRvaBase, m_rdataRvaBase);
			cur++;
        }

        relocSection.Finish();
        
        reloc->m_header->Misc.VirtualSize = reloc->dataLen();
        reloc->m_header->SizeOfRawData 
          = roundUp(reloc->m_header->Misc.VirtualSize, RoundUpVal);
        reloc->m_filePad = padLen(reloc->m_header->Misc.VirtualSize, RoundUpVal);
        filePos += reloc->m_header->SizeOfRawData;
        virtualPos += roundUp(reloc->m_header->Misc.VirtualSize, 
                              ntHeaders->OptionalHeader.SectionAlignment);


        if (reloc->m_header->Misc.VirtualSize == 0) 
        {
            //
            // Omit reloc section from section list.  (It will
            // still be there but the loader won't see it - this
            // only works because we've allocated it as the last
            // section.)
            //
            ntHeaders->FileHeader.NumberOfSections--;
        }
        else
        {
            //
            // Put reloc address in header
            //

            ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress 
              = reloc->m_header->VirtualAddress;
            ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size 
              = reloc->m_header->Misc.VirtualSize;
        }

        // compute ntHeader fields that depend on the sizes of other things
        for(IMAGE_SECTION_HEADER *h = headersEnd-1; h >= headers; h--) {    // go backwards, so first entry takes precedence
            if (h->Characteristics & IMAGE_SCN_CNT_CODE) {
                ntHeaders->OptionalHeader.BaseOfCode = h->VirtualAddress;
                ntHeaders->OptionalHeader.SizeOfCode += h->SizeOfRawData;
            }
            if (h->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) {
                ntHeaders->OptionalHeader.BaseOfData = h->VirtualAddress;
                ntHeaders->OptionalHeader.SizeOfInitializedData += h->SizeOfRawData;
            }
            if (h->Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) {
                ntHeaders->OptionalHeader.SizeOfUninitializedData += h->SizeOfRawData;
            }
        }

        for(cur = getSectCur()-1; getSectStart() <= cur; --cur) {   // go backwards, so first entry takes precedence
            if ((*cur)->getDirEntry() > 0) {        // Is it a directory entry
                // difficult to produce a useful error here, and can't produce on the call to the API that
                // sets this, so in non-debug mode, just generate a bad PE and they can dump it
                _ASSERTE((unsigned)((*cur)->getDirEntry()) < 
                            ntHeaders->OptionalHeader.NumberOfRvaAndSizes);
                ntHeaders->OptionalHeader.DataDirectory[(*cur)->getDirEntry()].VirtualAddress =  (*cur)->m_baseRVA;
                ntHeaders->OptionalHeader.DataDirectory[(*cur)->getDirEntry()].Size = (*cur)->dataLen();
            }
        }

        // handle the directory entries specified using the file.
        for (int i=0; i < cEntries; i++) {
            if (pEntries[i].section) {
                PEWriterSection *section = pEntries[i].section;
                _ASSERTE(pEntries[i].offset < section->dataLen());

                ntHeaders->OptionalHeader.DataDirectory[i].VirtualAddress 
                  = section->m_baseRVA + pEntries[i].offset;
                ntHeaders->OptionalHeader.DataDirectory[i].Size 
                  = pEntries[i].size;
            }
        }

        ntHeaders->OptionalHeader.SizeOfImage = virtualPos;
    } // end if(ExeOrDll)
    else //i.e., if OBJ
    {
        //
        // Clean up note:
        // I've cleaned up the executable linking path, but the .obj linking
        // is still a bit strange, what with a "extra" reloc & strtab sections
        // which are created after the linking step and get treated specially.  
        //
        // Perhaps somebody with a better handle
        // on .obj's can turn these into normal sections too, and perhaps
        // emit symbols for more than just the "text" section. -seantrow
        //

        reloc = new PEWriterSection(".reloc", 
                                    sdReadOnly | IMAGE_SCN_MEM_DISCARDABLE, 0x4000, 0);
		if(reloc == NULL) return E_OUTOFMEMORY;
        strtab = new PEWriterSection(".strtab", 
                                     sdReadOnly | IMAGE_SCN_MEM_DISCARDABLE, 0x4000, 0); //string table (if any)
		if(strtab == NULL) return E_OUTOFMEMORY;

        ntHeaders->FileHeader.SizeOfOptionalHeader = 0;
        //For each section set VirtualAddress to 0
        for(PEWriterSection **cur = getSectStart(); cur < getSectCur(); cur++) 
        {
            IMAGE_SECTION_HEADER* header = (*cur)->m_header;
            header->VirtualAddress = 0;
        }
        // Go over section relocations and build the Symbol Table, use .reloc section as buffer:
        DWORD tk=0, rva=0, NumberOfSymbols=0;
        BOOL  ToRelocTable = FALSE;
        DWORD TokInSymbolTable[16386];
        IMAGE_SYMBOL is;
        IMAGE_RELOCATION ir;
        ULONG StrTableLen = 4; //size itself only
        char* szSymbolName = NULL;
		char* pch;
        
        PESection *textSection;
        getSectionCreate(".text", 0, &textSection);

        for(PESectionReloc* rcur = textSection->m_relocStart; rcur < textSection->m_relocCur; rcur++) 
        {
            switch(rcur->type)
            {
                case 0x7FFA: // Ptr to symbol name
                    szSymbolName = (char*)(rcur->offset);
                    break;

                case 0x7FFC: // Ptr to file name
                    TokInSymbolTable[NumberOfSymbols++] = 0;
                    memset(&is,0,sizeof(IMAGE_SYMBOL));
                    memcpy(is.N.ShortName,".file\0\0\0",8);
                    is.Value = 0;
                    is.SectionNumber = IMAGE_SYM_DEBUG;
                    is.Type = IMAGE_SYM_DTYPE_NULL;
                    is.StorageClass = IMAGE_SYM_CLASS_FILE;
                    is.NumberOfAuxSymbols = 1;
					if(pch = reloc->getBlock(sizeof(IMAGE_SYMBOL))) 
						memcpy(pch,&is,sizeof(IMAGE_SYMBOL));
					else return E_OUTOFMEMORY;
                    TokInSymbolTable[NumberOfSymbols++] = 0;
                    memset(&is,0,sizeof(IMAGE_SYMBOL));
                    strcpy((char*)&is,(char*)(rcur->offset));
					if(pch = reloc->getBlock(sizeof(IMAGE_SYMBOL))) 
						memcpy(pch,&is,sizeof(IMAGE_SYMBOL));
					else return E_OUTOFMEMORY;
                    delete (char*)(rcur->offset);
                    ToRelocTable = FALSE;
                    tk = 0;
                    szSymbolName = NULL;
                    break;

                case 0x7FFB: // compid value
                    TokInSymbolTable[NumberOfSymbols++] = 0;
                    memset(&is,0,sizeof(IMAGE_SYMBOL));
                    memcpy(is.N.ShortName,"@comp.id",8);
                    is.Value = rcur->offset;
                    is.SectionNumber = IMAGE_SYM_ABSOLUTE;
                    is.Type = IMAGE_SYM_DTYPE_NULL;
                    is.StorageClass = IMAGE_SYM_CLASS_STATIC;
                    is.NumberOfAuxSymbols = 0;
					if(pch = reloc->getBlock(sizeof(IMAGE_SYMBOL))) 
						memcpy(pch,&is,sizeof(IMAGE_SYMBOL));
					else return E_OUTOFMEMORY;
                    ToRelocTable = FALSE;
                    tk = 0;
                    szSymbolName = NULL;
                    break;
                
                case 0x7FFF: // Token value, def
                    tk = rcur->offset;
                    ToRelocTable = FALSE;
                    break;

                case 0x7FFE: //Token value, ref
                    tk = rcur->offset;
                    ToRelocTable = TRUE;
                    break;

                case 0x7FFD: //RVA value
                    rva = rcur->offset;
                    if(tk)
                    {
                        // Add to SymbolTable
                        for(DWORD i = 0; (i < NumberOfSymbols)&&(tk != TokInSymbolTable[i]); i++);
                        if(i == NumberOfSymbols)
                        {
                            if(szSymbolName && *szSymbolName) // Add "extern" symbol and string table entry 
                            {
                                TokInSymbolTable[NumberOfSymbols++] = 0;
                                memset(&is,0,sizeof(IMAGE_SYMBOL));
                                i++; // so reloc record (if generated) points to COM token symbol
                                is.N.Name.Long = StrTableLen;
                                is.SectionNumber = 1; //textSection is the first one
                                is.StorageClass = IMAGE_SYM_CLASS_EXTERNAL;
                                is.NumberOfAuxSymbols = 0;
                                is.Value = rva;
                                if(TypeFromToken(tk) == mdtMethodDef)
                                {
                                    is.Type = 0x20; //IMAGE_SYM_DTYPE_FUNCTION;
                                }
								if(pch = reloc->getBlock(sizeof(IMAGE_SYMBOL))) 
									memcpy(pch,&is,sizeof(IMAGE_SYMBOL));
								else return E_OUTOFMEMORY;
                                DWORD l = (DWORD)(strlen(szSymbolName)+1); // don't forget zero terminator!
								if(pch = reloc->getBlock(1)) 
									memcpy(pch,szSymbolName,1);
								else return E_OUTOFMEMORY;
                                delete szSymbolName;
                                StrTableLen += l;
                            }
                            TokInSymbolTable[NumberOfSymbols++] = tk;
                            memset(&is,0,sizeof(IMAGE_SYMBOL));
                            sprintf((char*)is.N.ShortName,"%08X",tk);
                            is.SectionNumber = 1; //textSection is the first one
                            is.StorageClass = 0x6B; //IMAGE_SYM_CLASS_COM_TOKEN;
                            is.Value = rva;
                            if(TypeFromToken(tk) == mdtMethodDef)
                            {
                                is.Type = 0x20; //IMAGE_SYM_DTYPE_FUNCTION;
                                //is.NumberOfAuxSymbols = 1;
                            }
							if(pch = reloc->getBlock(sizeof(IMAGE_SYMBOL))) 
								memcpy(pch,&is,sizeof(IMAGE_SYMBOL));
							else return E_OUTOFMEMORY;
                            if(is.NumberOfAuxSymbols == 1)
                            {
                                BYTE dummy[sizeof(IMAGE_SYMBOL)];
                                memset(dummy,0,sizeof(IMAGE_SYMBOL));
                                dummy[0] = dummy[2] = 1;
								if(pch = reloc->getBlock(sizeof(IMAGE_SYMBOL))) 
									memcpy(pch,dummy,sizeof(IMAGE_SYMBOL));
								else return E_OUTOFMEMORY;
                                TokInSymbolTable[NumberOfSymbols++] = 0;
                            }
                        }
                        if(ToRelocTable)
                        {
                            IMAGE_SECTION_HEADER* phdr = textSection->m_header;
                            // Add to reloc table
                            ir.VirtualAddress = rva;
                            ir.SymbolTableIndex = i;
                            ir.Type = IMAGE_REL_I386_SECREL;
                            if(phdr->PointerToRelocations == 0) 
                                phdr->PointerToRelocations = phdr->PointerToRawData + phdr->SizeOfRawData;
                            phdr->NumberOfRelocations++;
							if(pch = reloc->getBlock(sizeof(IMAGE_RELOCATION))) 
								memcpy(pch,&is,sizeof(IMAGE_RELOCATION));
							else return E_OUTOFMEMORY;
                        }
                    }
                    ToRelocTable = FALSE;
                    tk = 0;
                    szSymbolName = NULL;
                    break;
            } //end switch(cur->type)
        } // end for all relocs
        // Add string table counter:
		if(pch = reloc->getBlock(sizeof(ULONG))) 
			memcpy(pch,&StrTableLen,sizeof(ULONG));
		else return E_OUTOFMEMORY;
        reloc->m_header->Misc.VirtualSize = reloc->dataLen();
        if(NumberOfSymbols)
        {
            // recompute the actual sizes and positions of all the sections
            filePos = roundUp(ntHeaders->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER)+ 
                                    sizeof(IMAGE_FILE_HEADER), RoundUpVal);
            for(cur = getSectStart(); cur < getSectCur(); cur++) 
            {
                IMAGE_SECTION_HEADER* header = (*cur)->m_header;
                header->Misc.VirtualSize = (*cur)->dataLen();
                header->VirtualAddress = 0;
                header->SizeOfRawData = roundUp(header->Misc.VirtualSize, RoundUpVal);
                header->PointerToRawData = filePos;

                filePos += header->SizeOfRawData;
            }
            ntHeaders->FileHeader.Machine = 0xC0EE; //COM+ EE
            ntHeaders->FileHeader.PointerToSymbolTable = filePos;
            ntHeaders->FileHeader.NumberOfSymbols = NumberOfSymbols;
            filePos += roundUp(reloc->m_header->Misc.VirtualSize+strtab->dataLen(),RoundUpVal);
        }
    } //end if OBJ

    const unsigned headerOffset = (ExeOrDll ? sizeof(IMAGE_DOS_HEADER) + sizeof(x86StubPgm) : 0);

    memset(&dosHeader, 0, sizeof(IMAGE_DOS_HEADER));
    dosHeader.e_magic = IMAGE_DOS_SIGNATURE;
    dosHeader.e_cblp = 0x90;            // bytes in last page
    dosHeader.e_cp = 3;                 // pages in file
    dosHeader.e_cparhdr = 4;            // size of header in paragraphs 
    dosHeader.e_maxalloc =  0xFFFF;     // maximum extra mem needed
    dosHeader.e_sp = 0xB8;              // initial SP value
    dosHeader.e_lfarlc = 0x40;          // file offset of relocations
    dosHeader.e_lfanew = headerOffset;  // file offset of NT header!

    return(S_OK);   // SUCCESS
}

HRESULT PEWriter::Open(LPCWSTR fileName, BOOL write)
{
    _ASSERTE(m_file == NULL);

    if (OnUnicodeSystem()) {
        m_file = _wfopen(fileName, write ? L"wb" : L"rb");    
        if (!m_file)
            return HRESULT_FROM_STDIO(write ? ERROR_WRITE_FAULT : ERROR_READ_FAULT);
    } else {
        char buffer[MAX_PATH];  
        char *fileNameMB = buffer;
        int length = WideCharToMultiByte(CP_ACP, 0, fileName, -1, fileNameMB, MAX_PATH, NULL, NULL);
        if (length == 0) {
            TESTANDRETURN(GetLastError() == ERROR_INSUFFICIENT_BUFFER, 
                          E_OUTOFMEMORY);
            length = WideCharToMultiByte(CP_ACP, 0, fileName, -1, NULL, 0, NULL, NULL);
            _ASSERTE(length > 0);
            fileNameMB = new char[length+1];
            TESTANDRETURN(fileNameMB, E_OUTOFMEMORY);
            length = WideCharToMultiByte(CP_ACP, 0, fileName, -1, fileNameMB, length, NULL, NULL);
            _ASSERTE(length > 0);
        }
        m_file = fopen(fileNameMB, write ? "wb" : "rb"); 
        if (!m_file)
            return HRESULT_FROM_STDIO(write ? ERROR_WRITE_FAULT : ERROR_READ_FAULT);
        if (fileNameMB != buffer)
            delete fileNameMB;
    }

    return S_OK;
}

HRESULT PEWriter::Seek(long offset)
{
    _ASSERTE(m_file != NULL);
    if (fseek(m_file, offset, SEEK_SET) == 0)
        return S_OK;
    else
        return HRESULT_FROM_STDIO_WRITE();
}

HRESULT PEWriter::Write(void *data, long size)
{
    _ASSERTE(m_file != NULL);
    
    CQuickBytes zero;
    if (data == NULL)
    {
        zero.ReSize(size);
        ZeroMemory(zero.Ptr(), size);
        data = zero.Ptr();
    }

    long written = fwrite(data, 1, size, m_file);
    if (written == size)
        return S_OK;
    else
        return HRESULT_FROM_STDIO_WRITE();
}

HRESULT PEWriter::Verify(void *data, long size)
{
    _ASSERTE(m_file != NULL);
    
    CQuickBytes zero;
    if (data == NULL)
    {
        zero.ReSize(size);
        ZeroMemory(zero.Ptr(), size);
        data = zero.Ptr();
    }

    CQuickBytes test;
    test.Alloc(size);

    long read = fread(test.Ptr(), 1, size, m_file);
    if (read != size)
    {
        _ASSERTE(!"Verification failure - investigate!!!!");
        return HRESULT_FROM_STDIO_READ();
    }
    else if (memcmp(test.Ptr(), data, size) != 0)
    {
        _ASSERTE(!"Verification failure - investigate!!!!");
        return HRESULT_FROM_WIN32(ERROR_FILE_INVALID);
    }

    return S_OK;
}

HRESULT PEWriter::Pad(long align)
{
    long offset = ftell(m_file);
    long pad = padLen(offset, align);
    if (pad > 0)
        return Write(NULL, pad);
    else
        return S_FALSE;
}

HRESULT PEWriter::Close()
{
    if (m_file == NULL)
        return S_OK;

    HRESULT hr;
    if (fclose(m_file) == 0)
        hr = S_OK;
    else
        hr = HRESULT_FROM_STDIO_WRITE();

    m_file = NULL;

    return hr;
}


/******************************************************************/
HRESULT PEWriter::write(const LPWSTR fileName) {

    HRESULT hr;

    bool ExeOrDll = ((ntHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)!=0);
    const unsigned RoundUpVal = ntHeaders->OptionalHeader.FileAlignment;

    IfFailGo(Open(fileName, TRUE));

    if(ExeOrDll)
    {
        IfFailGo(Write(&dosHeader, sizeof(IMAGE_DOS_HEADER)));
        IfFailGo(Write(x86StubPgm, sizeof(x86StubPgm)));
        IfFailGo(Write(ntHeaders, sizeof(IMAGE_NT_HEADERS32)));
    }
    else 
        IfFailGo(Write(&(ntHeaders->FileHeader),sizeof(IMAGE_FILE_HEADER)));

    IfFailGo(Write(headers, sizeof(IMAGE_SECTION_HEADER)*(headersEnd-headers)));

    IfFailGo(Pad(RoundUpVal));

    // write the actual data
    for (PEWriterSection **cur = getSectStart(); cur < getSectCur(); cur++) {
        if ((*cur)->m_header != NULL) {
            IfFailGo(Seek((*cur)->m_filePos));
            IfFailGo((*cur)->write(m_file));
            IfFailGo(Write(NULL, (*cur)->m_filePad));    
        }
    }

    if (!ExeOrDll)
    {
        // write the relocs section (Does nothing if relocs section is empty)
        IfFailGo(reloc->write(m_file));
        //write string table (obj only, empty for exe or dll)
        IfFailGo(strtab->write(m_file));
        size_t len = padLen(reloc->m_header->Misc.VirtualSize+strtab->dataLen(), RoundUpVal); 
        if (len > 0) 
            IfFailGo(Write(NULL, len));
    }

    return Close();

 ErrExit:
    Close();

    return hr;
}

HRESULT PEWriter::verify(const LPWSTR fileName) {

    HRESULT hr;

    bool ExeOrDll = ((ntHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)!=0);
    const unsigned RoundUpVal = ntHeaders->OptionalHeader.FileAlignment;

    IfFailGo(Open(fileName, FALSE));

    if(ExeOrDll)
    {
        IfFailGo(Verify(&dosHeader, sizeof(IMAGE_DOS_HEADER)));
        IfFailGo(Verify(x86StubPgm, sizeof(x86StubPgm)));
        IfFailGo(Verify(ntHeaders, sizeof(IMAGE_NT_HEADERS32)));
    }
    else 
        IfFailGo(Verify(&(ntHeaders->FileHeader),sizeof(IMAGE_FILE_HEADER)));

    IfFailGo(Verify(headers, sizeof(IMAGE_SECTION_HEADER)*(headersEnd-headers)));

    IfFailGo(Pad(RoundUpVal));

    // write the actual data
    for (PEWriterSection **cur = getSectStart(); cur < getSectCur(); cur++) {
        if ((*cur)->m_header != NULL) {
            IfFailGo(Seek((*cur)->m_filePos));
            IfFailGo((*cur)->verify(m_file));
            IfFailGo(Verify(NULL, (*cur)->m_filePad));    
        }
    }

    if (!ExeOrDll)
    {
        // write the relocs section (Does nothing if relocs section is empty)
        IfFailGo(reloc->verify(m_file));
        //write string table (obj only, empty for exe or dll)
        IfFailGo(strtab->verify(m_file));
        size_t len = padLen(reloc->m_header->Misc.VirtualSize+strtab->dataLen(), RoundUpVal); 
        if (len > 0) 
            IfFailGo(Verify(NULL, len));
    }

    return Close();

 ErrExit:
    Close();

    return hr;
}

HRESULT PEWriter::write(void ** ppImage) 
{
    bool ExeOrDll = ((ntHeaders->FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE)!=0);
    const unsigned RoundUpVal = ntHeaders->OptionalHeader.FileAlignment;
    char *pad = (char *) _alloca(RoundUpVal);
    memset(pad, 0, RoundUpVal);

    long lSize = filePos;
    if (!ExeOrDll)
    {
        lSize += reloc->dataLen();
        lSize += strtab->dataLen();
        lSize += padLen(reloc->m_header->Misc.VirtualSize+strtab->dataLen(), 
                        RoundUpVal);    
    }

    // dbPrintf("Total image size 0x%#X\n", lSize);

    // allocate the block we are handing back to the caller
    void * pImage = (void *) ::CoTaskMemAlloc(lSize);
    if (NULL == pImage)
    {
        // UNDONE: cleanup
        return E_OUTOFMEMORY;
    }

    // zero the memory
    ::memset(pImage, 0, lSize);

    char *pCur = (char *)pImage;

    if(ExeOrDll)
    {
        // PE Header
        COPY_AND_ADVANCE(pCur, &dosHeader, sizeof(IMAGE_DOS_HEADER));
        COPY_AND_ADVANCE(pCur, x86StubPgm, sizeof(x86StubPgm));
        COPY_AND_ADVANCE(pCur, ntHeaders, sizeof(IMAGE_NT_HEADERS32));
    }
    else
    {
        COPY_AND_ADVANCE(pCur, &(ntHeaders->FileHeader), sizeof(IMAGE_FILE_HEADER));
    }

    COPY_AND_ADVANCE(pCur, headers, sizeof(*headers)*(headersEnd - headers));

    // now the sections
    // write the actual data
    for (PEWriterSection **cur = getSectStart(); cur < getSectCur(); cur++) {
        if ((*cur)->m_header != NULL) {
            pCur = (char*)pImage + (*cur)->m_filePos;
            unsigned len = (*cur)->writeMem((void**)&pCur);
            _ASSERTE(len == (*cur)->dataLen());
            COPY_AND_ADVANCE(pCur, pad, (*cur)->m_filePad);
        }
    }

    // !!! Need to jump to the right place...

    if (!ExeOrDll)
    {
        // now the relocs (exe, dll) or symbol table (obj) (if any)
        // write the relocs section (Does nothing if relocs section is empty)
        reloc->writeMem((void **)&pCur);

        //write string table (obj only, empty for exe or dll)
        strtab->writeMem((void **)&pCur);

        // final pad
        size_t len = padLen(reloc->m_header->Misc.VirtualSize+strtab->dataLen(), RoundUpVal);   
        if (len > 0)
        {
            // WARNING: macro - must enclose in curly braces
            COPY_AND_ADVANCE(pCur, pad, len); 
        }
    }

    // make sure we wrote the exact numbmer of bytes expected
    _ASSERTE(lSize == (long)(pCur - (char *)pImage));

    // give pointer to memory image back to caller (who must free with ::CoTaskMemFree())
    *ppImage = pImage;

    // all done
    return S_OK;
}

HRESULT PEWriter::getFileTimeStamp(time_t *pTimeStamp)
{
    if (pTimeStamp)
        *pTimeStamp = m_peFileTimeStamp;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Common include file for utility code.
//*****************************************************************************
#include <stdlib.h>		// for qsort
#include <windows.h>
#include <time.h>
#include <assert.h>
#include <stdio.h>
#include <stddef.h>

#include <UtilCode.h>

#include <corpriv.h>

#include "PEWriter.h"
#include "ceegen.h"
#include "CeeFileGenWriter.h"
#include "CeeSectionString.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorrc\mscorrc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Mscorrc.cpp
//
// This just provides a load point for the .dll.
//
//*****************************************************************************
#include <windows.h>


//*****************************************************************************
// This function is called when the DLL is loaded/unloaded.  A code is passed
// giving a reason for being called.
//*****************************************************************************
BOOL APIENTRY DllMain( // TRUE = success, FALSE = failure.
    HINSTANCE	hModule,				// DLL's instance handle.
	DWORD		ul_reason_for_call,		// Cause of this call.
	LPVOID		lpReserved)
{
    if (ul_reason_for_call == DLL_PROCESS_ATTACH)
		DisableThreadLibraryCalls((HINSTANCE)hModule);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORPE.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime PE File Generator\0"
#define VER_ORIGFILENAME_STR    "mscorpe.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\stubs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Stubs.h
//
// This file contains a template for the default entry point stubs of a COM+
// IL only program.  One can emit these stubs (with some fix-ups) and make
// the code supplied the entry point value for the image.  The fix-ups will
// in turn cause mscoree.dll to be loaded and the correct entry point to be
// called.
//
//*****************************************************************************
#pragma once

#ifdef _X86_

//*****************************************************************************
// This stub is designed for a Windows application.  It will call the
// _CorExeMain function in mscoree.dll.  This entry point will in turn load
// and run the IL program.
//
// void ExeMain(void)
// {
//    _CorExeMain();
// }
//
// The code calls the imported functions through the iat, which must be
// emitted to the PE file.  The two addresses in the template must be replaced
// with the address of the corresponding iat entry which is fixed up by the
// loader when the image is paged in.
//*****************************************************************************
static const BYTE ExeMainTemplate[] =
{
	// Jump through IAT to _CorExeMain
	0xFF, 0x25,						// jmp iat[_CorDllMain entry]
		0x00, 0x00, 0x00, 0x00,	//	address to replace

};

#define ExeMainTemplateSize		sizeof(ExeMainTemplate)
#define CorExeMainIATOffset		2

//*****************************************************************************
// This stub is designed for a Windows application.  It will call the 
// _CorDllMain function in mscoree.dll with with the base entry point 
// for the loaded DLL.
// This entry point will in turn load and run the IL program.
//
// BOOL APIENTRY DllMain( HANDLE hModule, 
//                         DWORD ul_reason_for_call, 
//                         LPVOID lpReserved )
// {
// 	   return _CorDllMain(hModule, ul_reason_for_call, lpReserved);
// }

// The code calls the imported function through the iat, which must be
// emitted to the PE file.  The address in the template must be replaced
// with the address of the corresponding iat entry which is fixed up by the
// loader when the image is paged in.
//*****************************************************************************

static const BYTE DllMainTemplate[] = 
{
	// Call through IAT to CorDllMain 
	0xFF, 0x25,					// jmp iat[_CorDllMain entry]
		0x00, 0x00, 0x00, 0x00,	//   address to replace
};

#define DllMainTemplateSize		sizeof(DllMainTemplate)
#define CorDllMainIATOffset		2

#elif defined(_IA64_)

static const BYTE ExeMainTemplate[] =
{
	// Jump through IAT to _CorExeMain
	0xFF, 0x25,						// jmp iat[_CorDllMain entry]
		0x00, 0x00, 0x00, 0x00,	//	address to replace

};

#define ExeMainTemplateSize		sizeof(ExeMainTemplate)
#define CorExeMainIATOffset		2

static const BYTE DllMainTemplate[] = 
{
	// Call through IAT to CorDllMain 
	0xFF, 0x25,					// jmp iat[_CorDllMain entry]
		0x00, 0x00, 0x00, 0x00,	//   address to replace
};

#define DllMainTemplateSize		sizeof(DllMainTemplate)
#define CorDllMainIATOffset		2

#elif defined(_ALPHA_)

const BYTE ExeMainTemplate[] = 
{
	// load the high half of the address of the IAT
    0x00, 0x00, 0x7F, 0x27,     // ldah t12,_imp__CorExeMain(zero)
	// load the contents of the IAT entry into t12
	0x00, 0x00, 0x7B, 0xA3,     // ldl 	t12,_imp__CorExeMain(t12)
	// jump to the target address and don't save a return address
	0x00, 0x00, 0xFB, 0x6B,     // jmp 	zero,(t12),0
};

#define ExeMainTemplateSize		sizeof(ExeMainTemplate)
#define CorExeMainIATOffset		0

const BYTE DllMainTemplate[] = 
{
	// load the high half of the address of the IAT
    0x42, 0x00, 0x7F, 0x27,     // ldah t12,_imp__CorDLLMain(zero)
	// load the contents of the IAT entry into t12
	0x04, 0x82, 0x7B, 0xA3,     // ldl 	t12,_imp__CorDLLMain(t12)
	// jump to the target address and don't save a return address
	0x00, 0x00, 0xFB, 0x6B,     // jmp 	zero,(t12),0
};

#define DllMainTemplateSize		sizeof(DllMainTemplate)
#define CorDllMainIATOffset		0

#elif defined(CHECK_PLATFORM_BUILD)

#error "Platform NYI."

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorpe\pewriter.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef PEWriter_H
#define PEWriter_H

#include <CrtWrap.h>

#include <windows.h>

#include "CeeGen.h"

#include "PESectionMan.h"

class PEWriter;
class PEWriterSection;

struct _IMAGE_SECTION_HEADER;

#define SUBSECTION_ALIGN 16
/***************************************************************/
// PEWriter is derived from PESectionManager. While the base class just
// manages the sections, PEWriter can actually write them out.

class PEWriter : public PESectionMan
{
public:

    HRESULT Init(PESectionMan *pFrom);
    HRESULT Cleanup();

	HRESULT link();
	HRESULT fixup(CeeGenTokenMapper *pMapper);
    HRESULT write(const LPWSTR fileName);
    HRESULT verify(const LPWSTR fileName);
	HRESULT write(void **ppImage);

	// calling these functions is optinal
    void setImageBase(size_t);
    void setFileAlignment(ULONG);
    void stripRelocations(bool val);        // default = false

    // these affect the charactertics in the NT file header
	void setCharacteristics(unsigned mask);
	void clearCharacteristics(unsigned mask);

    // these affect the charactertics in the NT optional header
	void setDllCharacteristics(unsigned mask);
	void clearDllCharacteristics(unsigned mask);

	// sets the SubSystem field in the optional header
    void setSubsystem(unsigned subsystem, unsigned major, unsigned minor);

    // specify the entry point as an offset into the text section. The
	// method will convert into an RVA from the base
	void setEntryPointTextOffset(unsigned entryPoint);

	HRESULT setDirectoryEntry(PEWriterSection *section, ULONG entry, ULONG size, ULONG offset=0);

    int fileAlignment();

	// get the RVA for the IL section
	ULONG getIlRva();

	// set the RVA for the IL section by supplying offset to the IL section
	void setIlRva(DWORD offset);

	unsigned getSubsystem();

	size_t getImageBase();

    void setEnCRvaBase(ULONG dataBase, ULONG rdataBase);

    HRESULT getFileTimeStamp(time_t *pTimeStamp);

private:
	DWORD  m_ilRVA;
    BOOL   m_encMode;
    ULONG  m_dataRvaBase;
    ULONG  m_rdataRvaBase;
    time_t m_peFileTimeStamp;

    FILE   *m_file;

	PEWriterSection **getSectStart() {
		return (PEWriterSection**)sectStart;
	}
	PEWriterSection **getSectCur() {
		return (PEWriterSection**)sectCur;
	}
	void setSectCur(PEWriterSection **newCur) {
		sectCur = (PESection**)newCur;
	}

    IMAGE_NT_HEADERS32* ntHeaders;

	IMAGE_DOS_HEADER dosHeader;
	unsigned virtualPos;
	unsigned filePos;
	PEWriterSection *reloc;
	PEWriterSection *strtab;

	IMAGE_SECTION_HEADER *headers, *headersEnd;

	struct directoryEntry {
		PEWriterSection *section;
		ULONG offset;
		ULONG size;
	}  *pEntries;
    USHORT cEntries;

    HRESULT Open(LPCWSTR fileName, BOOL write);
    HRESULT Write(void *data, long size);
    HRESULT Verify(void *data, long size);
    HRESULT Seek(long offset);
    HRESULT Pad(long align);
    HRESULT Close();
};

// This class encapsulates emitting the base reloc section
class PERelocSection
{
 private:
    PEWriterSection *section;
    unsigned relocPage;
    unsigned relocSize;
    DWORD *relocSizeAddr;
    unsigned pages;

#ifdef _DEBUG
    unsigned lastRVA;
#endif

 public:
    PERelocSection(PEWriterSection *pBaseReloc);
    void AddBaseReloc(unsigned rva, int type, unsigned short highAdj);
    void Finish();
};

// don't add any new virtual methods or fields to this class. We cast a PESection object
// to a PEWriterSection object to get the right applyRelocs method, but the object is created
// as a PESection type.
class PEWriterSection : public PESection {
	friend class PEWriter;
    PEWriterSection(const char* name, unsigned flags, 
		unsigned estSize, unsigned estRelocs) : PESection(name, flags, estSize, estRelocs) {
	}
    void applyRelocs(size_t imageBase, PERelocSection* relocSection, CeeGenTokenMapper *pTokenMapper,
                     DWORD rdataRvaBase, DWORD dataRvaBase);
	HRESULT write(FILE *file);
	HRESULT verify(FILE *file);
    unsigned writeMem(void ** pMem);

};

inline int PEWriter::fileAlignment() {
    return ntHeaders->OptionalHeader.FileAlignment;
}

inline void PEWriter::setImageBase(size_t imageBase) {
    ntHeaders->OptionalHeader.ImageBase = (DWORD)imageBase;
}

inline void PEWriter::setFileAlignment(ULONG fileAlignment) {
    ntHeaders->OptionalHeader.FileAlignment = (DWORD)fileAlignment;
}

inline size_t PEWriter::getImageBase() {
    return ntHeaders->OptionalHeader.ImageBase;
}

inline void PEWriter::setSubsystem(unsigned subsystem, unsigned major, unsigned minor) {
    ntHeaders->OptionalHeader.Subsystem = subsystem;
    ntHeaders->OptionalHeader.MajorSubsystemVersion = major;
    ntHeaders->OptionalHeader.MinorSubsystemVersion = minor;
}

inline void PEWriter::setCharacteristics(unsigned mask) {
    ntHeaders->FileHeader.Characteristics |= mask;
}

inline void PEWriter::clearCharacteristics(unsigned mask) {
    ntHeaders->FileHeader.Characteristics &= ~mask;
}

inline void PEWriter::setDllCharacteristics(unsigned mask) {
	ntHeaders->OptionalHeader.DllCharacteristics |= mask; 
}

inline void PEWriter::clearDllCharacteristics(unsigned mask) {
	ntHeaders->OptionalHeader.DllCharacteristics &= ~mask; 
}

inline void PEWriter::setEntryPointTextOffset(unsigned offset) {
    ntHeaders->OptionalHeader.AddressOfEntryPoint = offset;
}

inline unsigned PEWriter::getSubsystem() {
    return ntHeaders->OptionalHeader.Subsystem;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorrc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCORRC.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime resources\0"
#define VER_ORIGFILENAME_STR    "mscorrc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorrc\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CompRC.rc
//

#define IDS_GENERAL_SVC_DESCRIPTION             0x01F4

#define IDS_DS_ACTIVESESSIONS                   0x1701
#define IDS_DS_DATASOURCENAME                   0x1702
#define IDS_DS_DATASOURCEREADONLY               0x1703
#define IDS_DS_DBMSNAME                         0x1704
#define IDS_DS_DBMSVER                          0x1705
#define IDS_DS_IDENTIFIERCASE                   0x1706
#define IDS_DS_DSOTHREADMODEL                   0x1707

#define IDS_EE_NDIRECT_UNSUPPORTED_SIG          0x1708
#define IDS_EE_THROW_HRESULT                    0x1709
#define IDS_EE_NDIRECT_BADNATL                  0x170a
#define IDS_EE_NDIRECT_LOADLIB                  0x170b
#define IDS_EE_NDIRECT_GETPROCADDRESS           0x170c
#define IDS_EE_COM_UNSUPPORTED_SIG              0x170d
#define IDS_EE_NDIRECT_BADOBJECT                0x170e
#define IDS_EE_NOSYNCHRONIZED                   0x170f
#define IDS_EE_DISPLAYNAME_NOT_FOUND            0x1710
#define IDS_EE_LOAD_NO_MAIN                     0x1711
#define IDS_EE_LOAD_BAD_MAIN_SIG                0x1712
#define IDS_EE_COM_UNSUPPORTED_TYPE             0x1713
#define IDS_EE_COM_UNSUPPORTED_VT_RECORD        0x1714

#define IDS_EE_LOAD_UNEXPECTED                  0x1715
#define IDS_EE_AMBIGUOUSINVOKE                  0x1716
#define IDS_EE_CALLBACK_UNSUPPORTED_SIG         0x1717
#define IDS_EE_NOTADELEGATE                     0x1718
#define IDS_EE_NOTNDIRECT                       0x1719
#define IDS_EE_TWO_LOADED_MSCOREE_TITLE         0x171a
#define IDS_EE_TWO_LOADED_MSCOREE_MSG           0x171b
#define IDS_EE_CUST_MARSHALER_ON_INVALID_TYPE   0x171c
#define IDS_EE_RETHROW_NOT_ALLOWED              0x171d
#define IDS_EE_INVALID_OLE_VARIANT              0x171e

#define IDS_EE_ADUNLOAD_DEFAULT                 0x171f

#define IDS_EE_FILE_NOT_FOUND                   0x80070002
#define IDS_EE_TOO_MANY_OPEN_FILES              0x80070004
#define IDS_EE_SHARING_VIOLATION                0x80070020
#define IDS_EE_LOCK_VIOLATION                   0x80070021
#define IDS_EE_OPEN_FAILED                      0x8007006D
#define IDS_EE_PATH_TOO_LONG                    0x8007006F
#define IDS_EE_INVALID_NAME                     0x8007007B
#define IDS_EE_PROC_NOT_FOUND                   0x8007007F
#define IDS_EE_UNRECOGNIZED_VOLUME              0x800703ED
#define IDS_EE_FILE_INVALID                     0x800703EE
#define IDS_EE_DLL_INIT_FAILED                  0x8007045A
#define IDS_EE_FILE_CORRUPT                     0x80070570
#define IDS_EE_DISK_CORRUPT                     0x80070571
#define IDS_EE_INTERNET_D                       0x800C000D

#define IDS_EE_FAILED_TO_LOAD                   0x1720
#define IDS_EE_TO_MANY_ARGUMENTS_IN_MAIN        0x1721
#define IDS_EE_FAILED_TO_FIND_MAIN              0x1722
#define IDS_EE_ILLEGAL_TOKEN_FOR_MAIN           0x1723
#define IDS_EE_MAIN_METHOD_MUST_BE_STATIC       0x1724
#define IDS_EE_MAIN_METHOD_HAS_INVALID_RTN      0x1725
#define IDS_EE_VTABLECALLSNOTSUPPORTED          0x1726
#define IDS_EE_BADPINVOKEFIELD                  0x1727
#define IDS_EE_BADPINVOKEFIELD_CHAR             0x1728
#define IDS_EE_BADPINVOKEFIELD_BOOLEAN          0x1729
#define IDS_EE_BADPINVOKEFIELD_I1               0x172a
#define IDS_EE_BADPINVOKEFIELD_I2               0x172b
#define IDS_EE_BADPINVOKEFIELD_I4               0x172c
#define IDS_EE_BADPINVOKEFIELD_I8               0x172d
#define IDS_EE_BADPINVOKEFIELD_I                0x172e
#define IDS_EE_BADPINVOKEFIELD_R4               0x172f
#define IDS_EE_BADPINVOKEFIELD_R8               0x1730
#define IDS_EE_BADPINVOKEFIELD_R                0x1731
#define IDS_EE_BADPINVOKEFIELD_PTR              0x1732
#define IDS_EE_BADPINVOKEFIELD_CLASS            0x1733
#define IDS_EE_BADPINVOKEFIELD_NOLAYOUT         0x1734
#define IDS_EE_BADPINVOKEFIELD_STRING           0x1735
#define IDS_EE_BADPINVOKEFIELD_DELEGATE         0x1736
#define IDS_EE_BADPINVOKEFIELD_NOCUSTOM         0x1737
#define IDS_EE_SAFEARRAYTYPEMISMATCH            0x1738
#define IDS_EE_SAFEARRAYRANKMISMATCH            0x1739
#define IDS_EE_BADPINVOKE_GENERIC               0x173a
#define IDS_EE_BADPINVOKE_CHAR                  0x173b
#define IDS_EE_BADPINVOKE_BOOLEAN               0x173c
#define IDS_EE_BADPINVOKE_I1                    0x173d
#define IDS_EE_BADPINVOKE_I2                    0x173e
#define IDS_EE_BADPINVOKE_I4                    0x173f
#define IDS_EE_BADPINVOKE_I8                    0x1740
#define IDS_EE_BADPINVOKE_I                     0x1741
#define IDS_EE_BADPINVOKE_R4                    0x1742
#define IDS_EE_BADPINVOKE_R8                    0x1743
#define IDS_EE_BADPINVOKE_R                     0x1744
#define IDS_EE_BADPINVOKE_PTR                   0x1745
#define IDS_EE_BADPINVOKE_NOLAYOUT              0x1746
#define IDS_EE_BADPINVOKE_STRING                0x1747
#define IDS_EE_BADPINVOKE_STRINGBUILDER         0x1748
#define IDS_EE_BADPINVOKE_DELEGATE              0x1749
#define IDS_EE_BADPINVOKE_FNPTR                 0x174a
#define IDS_EE_BADPINVOKE_INTERFACE             0x174b
#define IDS_EE_BADPINVOKE_CLASS                 0x174c
#define IDS_EE_BADPINVOKE_VALUETYPE             0x174d
#define IDS_EE_BADPINVOKE_OBJECT                0x174e
#define IDS_EE_BADPINVOKE_VARIANT               0x174f
#define IDS_EE_BADPINVOKE_DECIMAL               0x1750
#define IDS_EE_BADPINVOKE_GUID                  0x1751
#define IDS_EE_BADPINVOKE_CURRENCY              0x1752
#define IDS_EE_BADPINVOKE_DATETIME              0x1753
#define IDS_EE_BADPINVOKE_ARRAY                 0x1754
#define IDS_EE_BADPINVOKEFIELD_NOLPSTRUCT       0x1755
#define IDS_EE_BADPINVOKE_BADMANAGED            0x1756
#define IDS_EE_SRC_OBJ_NOT_COMOBJECT            0x1757
#define IDS_EE_DEST_TYPE_NOT_COMOBJECT          0x1758
#define IDS_EE_CANNOT_COERCE_COMOBJECT          0x1759
#define IDS_EE_QIFAILEDONCOMOBJ                 0x175a
#define IDS_EE_BADPINVOKE_PTRSUBTYPE            0x175b
#define IDS_EE_BADPINVOKE_PTRNONBLITTABLE       0x175c

#define IDS_EE_BADPINVOKE_RESTRICTION           0x175d
#define IDS_EE_BADPINVOKE_CHARARRAYRESTRICTION  0x175e
#define IDS_EE_BADPINVOKE_ASANYRESTRICTION      0x175f
#define IDS_EE_BADPINVOKE_VBBYVALSTRRESTRICTION 0x1760
#define IDS_EE_BADPINVOKE_AWORESTRICTION        0x1761
#define IDS_EE_BADPINVOKE_BVCRESTRICTION        0x1762
#define IDS_EE_BADPINVOKE_COPYCTORRESTRICTION   0x1763
#define IDS_EE_BADPINVOKE_VCRESTRICTION         0x1764
#define IDS_EE_BADPINVOKE_ARGITERATORRESTRICTION 0x1765
#define IDS_EE_BADPINVOKE_HANDLEREFRESTRICTION  0x1766

#define IDS_EE_ADUNLOAD_NOT_ALLOWED             0x1767
#define IDS_EE_ADUNLOAD_IN_FINALIZER            0x1768
#define IDS_EE_ADUNLOAD_CANT_UNWIND_THREAD      0x1769

#define IDS_STREAMS_FILE_EOF                    0x176a
#define IDS_STREAMS_FILE_OPEN                   0x176b
#define IDS_STREAMS_FILE_BUFFER                 0x176c
#define IDS_STREAMS_FILE_NAME                   0x176d
#define IDS_STREAMS_SEEK_MODIFIER               0x176e

#define IDS_SECURITY_DEMAND_DENIED              0x176f

#define IDS_CANNOT_MARSHAL                      0x1770
#define IDS_PINVOKE_STRINGBUILDEROVERFLOW       0x1771
#define IDS_EE_HASH_VAL_FAILED                  0x1772


#define IDS_CLASSLOAD_GENERIC                   0x80131522
#define IDS_CLASSLOAD_MODULELOAD                0x1773
#define IDS_CLASSLOAD_BADFORMAT                 0x1774
#define IDS_CLASSLOAD_CANTCREATEARRAYCLASS      0x1775
#define IDS_CLASSLOAD_NOCLSIDREG                0x1776
#define IDS_CLASSLOAD_MISSINGMETHOD             0x1777
#define IDS_CLASSLOAD_STATICVIRTUAL             0x1778
#define IDS_CLASSLOAD_REDUCEACCESS              0x1779
#define IDS_CLASSLOAD_BADPINVOKE                0x177a
#define IDS_CLASSLOAD_VALUECLASSTOOLARGE        0x177b
#define IDS_CLASSLOAD_NOTIMPLEMENTED            0x177c
#define IDS_CLASSLOAD_PARENTNULL                0x177d        
#define IDS_CLASSLOAD_PARENTINTERFACE           0x177e        
#define IDS_CLASSLOAD_INTERFACEOBJECT           0x177f            
#define IDS_CLASSLOAD_INTERFACENULL             0x1780            
#define IDS_CLASSLOAD_NOTINTERFACE              0x1781
#define IDS_CLASSLOAD_VALUEINSTANCEFIELD        0x1782
#define IDS_CLASSLOAD_BAD_NAME                  0x1784
#define IDS_CLASSLOAD_RANK_TOOLARGE             0x1785
#define IDS_CLASSLOAD_BAD_MANAGED_RVA           0x1786
#define IDS_CLASSLOAD_BAD_UNMANAGED_RVA         0x1787
#define IDS_CLASSLOAD_INHERITANCECHECK          0x1788
#define IDS_CLASSLOAD_ENCLOSING                 0x1789
#define IDS_CLASSLOAD_EXPLICIT_LAYOUT           0x178a
#define IDS_CLASSLOAD_SEALEDPARENT              0x178b
#define IDS_CLASSLOAD_NOMETHOD_NAME             0x178c
#define IDS_CLASSLOAD_PRIVATEVIRTUAL            0x178d
#define IDS_CLASSLOAD_BADSPECIALMETHOD          0x178e
#define IDS_CLASSLOAD_MI_DECLARATIONNOTFOUND    0x178f
#define IDS_CLASSLOAD_MI_MULTIPLEOVERRIDES      0x1790
#define IDS_CLASSLOAD_MI_ACCESS_FAILURE         0x1791
#define IDS_CLASSLOAD_MI_OVERRIDEIMPL           0x1792
#define IDS_CLASSLOAD_MI_BADSIGNATURE           0x1793
#define IDS_CLASSLOAD_MI_NOTIMPLEMENTED         0x1794
#define IDS_CLASSLOAD_MI_VIRTUALMISMATCH        0x1795
#define IDS_CLASSLOAD_MI_MUSTBEVIRTUAL          0x1796
#define IDS_CLASSLOAD_MISSINGMETHODRVA          0x1797
#define IDS_CLASSLOAD_FIELDTOOLARGE             0x1798
#define IDS_CLASSLOAD_CANTEXTEND                0x179a
#define IDS_CLASSLOAD_ZEROSIZE                  0x179b
#define IDS_CLASSLOAD_BAD_FIELD                 0x179d
#define IDS_CLASSLOAD_MI_ILLEGAL_BODY           0x179e
#define IDS_CLASSLOAD_MI_ILLEGAL_STATIC         0x179f
#define IDS_CLASSLOAD_MI_ILLEGAL_TOKEN_BODY     0x17a0
#define IDS_CLASSLOAD_MI_ILLEGAL_TOKEN_DECL     0x17a1
#define IDS_CLASSLOAD_MI_SEALED_DECL            0x17a2
#define IDS_CLASSLOAD_MI_FINAL_DECL             0x17a3
#define IDS_CLASSLOAD_MI_NONVIRTUAL_DECL        0x17a4
#define IDS_CLASSLOAD_MI_BODY_DECL_MISMATCH     0x17a5
#define IDS_CLASSLOAD_MI_MISSING_SIG_BODY       0x17a6
#define IDS_CLASSLOAD_MI_MISSING_SIG_DECL       0x17a7
#define IDS_CLASSLOAD_ASSEMBLYLOAD              0x17a8
#define IDS_CLASSLOAD_UNVERIFIABLE_FIELD_LAYOUT 0x17a9

#define IDS_FAIL_CAPTION                        0x17aa
#define IDS_FAIL_LOAD_JIT                       0x17ab
#define IDS_FAIL_LOAD_OPTJIT                    0x17ac
#define IDS_FAIL_LOAD_EJIT                      0x17ad
#define IDS_COMPLUS_ERROR                       0x17ae
#define IDS_FATAL_ERROR                         0x17af
#define IDS_ERROR                               0x17b0
#define IDS_INVALID_VARIANT_MSG                 0x17b1
#define IDS_INVALID_VARIANT_CAPTION             0x17b2
#define IDS_DEBUG_DIFF_BUILDS_ERR               0x17b3
#define IDS_DEBUG_SERVICE_CAPTION               0x17b4
#define IDS_DEBUG_JIT_DEBUGGER_UNAVAILABLE      0x17b5
#define IDS_DEBUG_NO_DEBUGGER_FOUND             0x17b6
#define IDS_DEBUG_USERBREAKPOINT                0x17b7
#define IDS_DEBUG_UNHANDLEDEXCEPTION            0x17b8
#define IDS_DEBUG_UNHANDLEDEXCEPTION_IPC        0x17b9
#define IDS_PERFORMANCEMON_WINNT_ERR            0x17ba
#define IDS_PERFORMANCEMON_WINNT_TITLE          0x17bb
#define IDS_PERFORMANCEMON_FUNCNOTFOUND         0x17bc
#define IDS_PERFORMANCEMON_FUNCNOTFOUND_TITLE   0x17bd
#define IDS_PERFORMANCEMON_PSAPINOTFOUND        0x17be
#define IDS_PERFORMANCEMON_PSAPINOTFOUND_TITLE  0x17bf

#define IDS_DEBUG_UNHANDLED_EXCEPTION_MSG       0x17c0
#define IDS_DEBUG_USER_BREAKPOINT_MSG           0x17c1

#define IDS_EE_ADUNLOAD_NOT_LOCAL               0x17c2

#define IDS_INVALID_REDIM                       0x17c3
#define IDS_INVALID_PINVOKE_CALLCONV            0x17c4
#define IDS_NOLAYOUT_IN_EMBEDDED_VALUECLASS     0x17c5
#define IDS_CLASSLOAD_NSTRUCT_PARENT            0x17c6
#define IDS_CLASSLOAD_NSTRUCT_EXPLICIT_OFFSET   0x17c7
#define IDS_UNI2ANSI_FAILURE_IN_NSTRUCT         0x17c8
#define IDS_ANSI2UNI_FAILURE_IN_NSTRUCT         0x17c9
#define IDS_WRONGSIZEARRAY_IN_NSTRUCT           0x17ca
#define IDS_UNI2ANSI_FAILURE                    0x17cb
#define IDS_ANSI2UNI_FAILURE                    0x17cc

#define IDS_EE_INVALIDLCIDPARAM                 0x17cd
#define IDS_ENCODEDPERMSET_DECODEFAILURE        0x17cf
#define IDS_BAD_MSCORLIB                        0x17d0
#define IDS_EE_INVALIDCOMSOURCEITF              0x17d1
#define IDS_EE_CANNOT_COERCE_BYREF_VARIANT      0x17d2
#define IDS_EE_WRAPPER_MUST_HAVE_DEF_CONS       0x17d3
#define IDS_EE_INVALID_STD_DISPID_NAME          0x17d4
#define IDS_EE_NO_IDISPATCH_ON_TARGET           0x17d5
#define IDS_EE_NON_STD_NAME_WITH_STD_DISPID     0x17d6
#define IDS_EE_INVOKE_NEW_ENUM_INVALID_RETURN   0x17d7
#define IDS_EE_USE_OF_RELEASED_COM_OBJECT       0x17d8
#define IDS_EE_COM_OBJECT_NO_LONGER_HAS_WRAPPER 0x17d9
#define IDS_EE_CALLBACK_NOT_CALLED_FROM_CCTOR   0x17da
#define IDS_EE_CALLBACK_ALREADY_REGISTERED      0x17de
#define IDS_EE_NDIRECT_BADNATL_CALLCONV         0x17df
#define IDS_EE_CANNOTCAST                       0x17e0
#define IDS_EE_NOTISOMORPHIC                    0x17e1

#define IDS_EE_OFFSETOF_NOFIELDFOUND            0x17e2
#define IDS_EE_COPY_OUTOFRANGE                  0x17e3
#define IDS_EE_CANNOTPIN                        0x17e4
#define IDS_EE_ARRAYWITHOFFSETOVERFLOW          0x17e5
#define IDS_EE_OUTOFLOCALS                      0x17e6
#define IDS_EE_NOCUSTOMMARSHALER                0x17e7
#define IDS_EE_SIZECONTROLOUTOFRANGE            0x17e8
#define IDS_EE_SIZECONTROLBADTYPE               0x17e9
#define IDS_EE_DUPLICATE_DECLSEC                0x17ea
#define IDS_EE_SAFEARRAYSZARRAYMISMATCH         0x17eb
#define IDS_EE_INVALID_VT_FOR_CUSTOM_MARHALER   0x17ec
#define IDS_EE_BAD_COMEXTENDS_CLASS             0x17ed

#define IDS_EE_METADATA_ERROR                   0x17ee
#define IDS_EE_ERRORTITLE                       0x17f0
#define IDS_EE_ERRORMESSAGETEMPLATE             0x17f1

#define IDS_EE_CRYPTO_UNKNOWN_ERROR             0x17f2
#define IDS_EE_CRYPTO_ILLEGAL_KEY_SIZE          0x17f3
#define IDS_EE_CRYPTO_UNKNOWN_OPERATION         0x17f4

#define IDS_EE_COM_COMPONENT_NOT_REG            0x17f5
#define SN_NO_SUITABLE_CSP_NAME                 0x17f6

#define IDS_EE_MISSING_FIELD                    0x17f7
#define IDS_EE_MISSING_METHOD                   0x17f8

#define IDS_EE_INTERFACE_NOT_DISPATCH_BASED     0x17f9

#define IDS_EE_UNHANDLED_EXCEPTION              0x17fc
#define IDS_EE_EXCEPTION_TOSTRING_FAILED        0x17fd

#define IDS_EE_FATAL_STACK_OVERFLOW             0x17fe
#define IDS_EE_FATAL_OUT_OF_MEMORY              0x17ff
#define IDS_EE_FATAL_ERROR                      0x1800

#define IDS_EE_PINVOKE_NOREFFORSIZEIS           0x1a01
#define IDS_EE_NO_IDISPATCH                     0x1a02


#define IDS_EE_SIGTOOCOMPLEX                    0x1a03
#define IDS_EE_STRUCTTOOCOMPLEX                 0x1a04
#define IDS_EE_STRUCTARRAYTOOLARGE              0x1a05
#define IDS_EE_NOSTRINGBUILDERFIELD             0x1a06
#define IDS_EE_NAME_UNKNOWN                     0x1a07
#define IDS_EE_NAME_INMEMORYMODULE              0x1a08
#define IDS_EE_NAME_INTEROP                     0x1a09
#define IDS_EE_THREAD_NOTSTARTED                0x1a0a
#define IDS_EE_NO_BACKING_CLASS_FACTORY         0x1a0b
#define IDS_EE_NAME_UNKNOWN_UNQ                 0x1a0c
#define IDS_EE_STRING_TOOLONG                   0x1a0d
#define IDS_CLASSLOAD_MI_PRIVATE_DECL           0x1a0e
#define IDS_EE_VARARG_NOT_SUPPORTED             0x1a0f

#define IDS_EE_INVALID_CA                       0x1a10
#define IDS_EE_INVALID_CA_EX                    0x1a11

#define IDS_EE_THREADSTART_STATE                0x1a12

#define IDS_EE_CANNOTCASTTO                     0x1a13
#define IDS_EE_THREAD_CANNOT_GET                0x1a15
#define IDS_EE_THREAD_SUSPEND_NON_RUNNING       0x1a16
#define IDS_EE_THREAD_RESUME_NON_RUNNING        0x1a17
#define IDS_EE_THREAD_RESUME_NON_USER_SUSPEND   0x1a18
#define IDS_EE_THREAD_DEAD_PRIORITY             0x1a19
#define IDS_EE_THREAD_DEAD_STATE                0x1a1a
#define IDS_EE_THREAD_BAD_STATE                 0x1a1b
#define IDS_EE_THREAD_ABORT_WHILE_SUSPEND       0x1a1c

#define IDS_EE_NOVARIANTRETURN                  0x1a1d

#define IDS_EE_PATH_HAS_IMPROPER_CHAR           0x1a1f
#define IDS_EE_PATH_ILLEGAL                     0x1a20

#define IDS_CLASSLOAD_BADOVERLAP                0x1a21

#define IDS_EE_SID_TIMEOUT                      0x1a22

#define IDS_EE_INVALID_SAFEARRAY                0x1a23

#define IDS_EE_METHOD_NOT_FOUND_ON_EV_PROV      0x1a24
#define IDS_EE_BAD_COMEVENTITF_CLASS            0x1a25

#define IDS_EE_INVALID_STRONGNAME               0x1a26
#define IDS_EE_INVALID_STRONGNAME_TITLE         0x1a27

#define IDS_EE_INVALID_DELEGATE_LAYOUT          0x1a28

#define IDS_EE_COREXEMAIN_FAILED_TITLE          0x1a29
#define IDS_EE_COREXEMAIN_FAILED_TEXT           0x1a2a
#define IDS_EE_COREXEMAIN2_FAILED_TITLE         0x1a2b
#define IDS_EE_COREXEMAIN2_FAILED_TEXT          0x1a2c

#define IDS_EE_PATH_INVALID_UNCPATH             0x1a2d

#define IDS_EE_ICUSTOMMARSHALERNOTIMPL          0x1a2e
#define IDS_EE_GETINSTANCENOTIMPL               0x1a2f

#define IDS_EE_BADPINVOKE_CUSTOMMARSHALER       0x1a30

#define IDS_CLASSLOAD_COMIMPCANNOTHAVELAYOUT    0x1a31

#define IDS_EE_GUID_REPRESENTS_NON_VC           0x1a32
#define IDS_EE_CANNOT_MAP_TO_MANAGED_VC         0x1a33

#define IDS_EE_SRC_COMOBJ_REL_NOT_IN_PROC       0x1a34

#define IDS_EE_MARSHAL_UNMAPPABLE_CHAR          0x1a35

#define IDS_EE_BADPINVOKEFIELD_CANTLOADSUBTYPE  0x1a36

#define IDS_EE_BADPINVOKEFIELD_BADMETADATA      0x1a37

#define IDS_EE_INTERNET_B                       0x1a38

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\acui.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


//*****************************************************************************
//*****************************************************************************

#include "stdpch.h"
#include "richedit.h"
#include "commctrl.h"

#include "winwrap.h"

#include "resource.h"
#include "acuihelp.h"
#include "acui.h"

IACUIControl::~IACUIControl ()
{
}

void IACUIControl::SetupButtons(HWND hWnd)
{
    LPWSTR pText = NULL;;
    if(!ShowYes(&pText))
        ShowWindow(GetDlgItem(hWnd, IDYES), SW_HIDE);
    else if(pText) 
        WszSetWindowText(GetDlgItem(hWnd, IDYES), pText);
    
    pText = NULL;
    if (!ShowNo(&pText))
        ShowWindow(GetDlgItem(hWnd, IDNO), SW_HIDE);
    else if(pText)
        WszSetWindowText(GetDlgItem(hWnd, IDNO), pText);

    pText = NULL;
    if (!ShowMore(&pText))
        ShowWindow(GetDlgItem(hWnd, IDMORE), SW_HIDE);
    else if(pText)
        WszSetWindowText(GetDlgItem(hWnd, IDMORE), pText);

}

//+---------------------------------------------------------------------------
//
//  Member:     IACUIControl::OnUIMessage, public
//
//  Synopsis:   responds to UI messages
//
//  Arguments:  [hwnd]   -- window
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message processing should continue, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
IACUIControl::OnUIMessage (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    switch ( uMsg )
    {
    case WM_INITDIALOG:
        {
            BOOL fReturn;

            fReturn = OnInitDialog(hwnd, wParam, lParam);

            ACUICenterWindow(hwnd);

            return( fReturn );
        }
        break;

    case WM_COMMAND:
        {
            WORD wNotifyCode = HIWORD(wParam);
            WORD wId = LOWORD(wParam);
            HWND hwndControl = (HWND)lParam;

            if ( wNotifyCode == BN_CLICKED )
            {
                if ( wId == IDYES )
                {
                    return( OnYes(hwnd) );
                }
                else if ( wId == IDNO )
                {
                    return( OnNo(hwnd) );
                }
                else if ( wId == IDMORE )
                {
                    return( OnMore(hwnd) );
                }
            }

            return( FALSE );
        }
        break;

    case WM_CLOSE:
        return( OnNo(hwnd) );
        break;

    default:
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIMessageProc
//
//  Synopsis:   message proc to process UI messages
//
//  Arguments:  [hwnd]   -- window
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message processing should continue, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK IACUIControl::ACUIMessageProc (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    IACUIControl* pUI = NULL;

    //
    // Get the control
    //

    if (uMsg == WM_INITDIALOG)
    {
        pUI = (IACUIControl *)lParam;
        WszSetWindowLong(hwnd, DWLP_USER, (LONG_PTR)lParam);
    }
    else
    {
        pUI = (IACUIControl *)WszGetWindowLong(hwnd, DWLP_USER);
    }

    //
    // If we couldn't find it, we must not have set it yet, so ignore this
    // message
    //

    if ( pUI == NULL )
    {
        return( FALSE );
    }

    //
    // Pass the message on to the control
    //

    return( pUI->OnUIMessage(hwnd, uMsg, wParam, lParam) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SubclassEditControlForLink
//
//  Synopsis:   subclasses the edit control for a link using the link subclass
//              data
//
//  Arguments:  [hwndDlg]  -- dialog
//              [hwndEdit] -- edit control
//              [wndproc]  -- window proc to subclass with
//              [plsd]     -- data to pass on to window proc
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID IACUIControl::SubclassEditControlForLink (HWND                       hwndDlg,
                                               HWND                       hwndEdit,
                                               WNDPROC                    wndproc,
                                               PTUI_LINK_SUBCLASS_DATA    plsd,
                                               HINSTANCE                  resources)
{
    //HWND hwndTip;
    plsd->hwndTip = CreateWindowA(
                          TOOLTIPS_CLASSA,
                          (LPSTR)NULL,
                          WS_POPUP | TTS_ALWAYSTIP,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          hwndDlg,
                          (HMENU)NULL,
                          resources,
                          NULL
                          );

    if ( plsd->hwndTip != NULL )
    {
        TOOLINFOA   tia;
        DWORD       cb;
        LPSTR       psz;

        memset(&tia, 0, sizeof(TOOLINFOA));
        tia.cbSize = sizeof(TOOLINFOA);
        tia.hwnd = hwndEdit;
        tia.uId = 1;
        tia.hinst = resources;

        WszSendMessage(hwndEdit, EM_GETRECT, 0, (LPARAM)&tia.rect);

        //
        // if plsd->uToolTipText is a string then convert it
        //
        if (plsd->uToolTipText &0xffff0000)
        {
            cb = WideCharToMultiByte(
                        0, 
                        0, 
                        (LPWSTR)plsd->uToolTipText, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (psz = new char[cb]))
            {
                return;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        (LPWSTR)plsd->uToolTipText, 
                        -1,
                        psz, 
                        cb, 
                        NULL, 
                        NULL);
            
            tia.lpszText = psz;
        }
        else
        {
            tia.lpszText = (LPSTR)plsd->uToolTipText;
        }

        WszSendMessage(plsd->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&tia);

        if (plsd->uToolTipText &0xffff0000)
        {
            delete[] psz;
        }
    }

    plsd->fMouseCaptured = FALSE;
    plsd->wpPrev = (WNDPROC)WszGetWindowLong(hwndEdit, GWLP_WNDPROC);
    WszSetWindowLong(hwndEdit, GWLP_USERDATA, (LONG_PTR)plsd);
    WszSetWindowLong(hwndEdit, GWLP_WNDPROC, (LONG_PTR)wndproc);
}

//+---------------------------------------------------------------------------
//
//  Function:   SubclassEditControlForArrowCursor
//
//  Synopsis:   subclasses edit control so that the arrow cursor can replace
//              the edit bar
//
//  Arguments:  [hwndEdit] -- edit control
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID IACUIControl::SubclassEditControlForArrowCursor (HWND hwndEdit)
{
    LONG_PTR PrevWndProc;

    PrevWndProc = WszGetWindowLong(hwndEdit, GWLP_WNDPROC);
    WszSetWindowLong(hwndEdit, GWLP_USERDATA, (LONG_PTR)PrevWndProc);
    WszSetWindowLong(hwndEdit, GWLP_WNDPROC, (LONG_PTR)ACUISetArrowCursorSubclass);
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUILinkSubclass
//
//  Synopsis:   subclass for the publisher link
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK IACUIControl::ACUILinkSubclass (HWND   hwnd,
                                                 UINT   uMsg,
                                                 WPARAM wParam,
                                                 LPARAM lParam)
{
    PTUI_LINK_SUBCLASS_DATA plsd;
    CInvokeInfoHelper*      piih;

    plsd = (PTUI_LINK_SUBCLASS_DATA)WszGetWindowLong(hwnd, GWLP_USERDATA);
    piih = (CInvokeInfoHelper *)plsd->pvData;

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        if (!plsd->fMouseCaptured)
        {
            SetCapture(hwnd);
            plsd->fMouseCaptured = TRUE;
        }

        SetCursor(WszLoadCursor((HINSTANCE) WszGetWindowLong(hwnd, GWLP_HINSTANCE),
                                MAKEINTRESOURCEW(IDC_TUIHAND)));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ')
        {
            break;
        }

        // fall through to wm_lbuttondown....

    case WM_LBUTTONDOWN:

        SetFocus(hwnd);
        return( TRUE );

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

    case EM_SETSEL:

        return( TRUE );

    case WM_PAINT:

        WszCallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

    case WM_SETFOCUS:

        if ( hwnd == GetFocus() )
        {
            InvalidateRect(hwnd, NULL, FALSE);
            UpdateWindow(hwnd);
            SetCursor(WszLoadCursor((HINSTANCE)WszGetWindowLong(hwnd, GWLP_HINSTANCE),
                                    MAKEINTRESOURCEW(IDC_TUIHAND)));
            return( TRUE );
        }
        break;

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        SetCursor(WszLoadCursor(NULL, IDC_ARROW));

        return( TRUE );

    case WM_MOUSEMOVE:

        MSG                 msg;
        RECT                rect;
        int                 xPos, yPos;

        memset(&msg, 0, sizeof(MSG));
        msg.hwnd    = hwnd;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;

        WszSendMessage(plsd->hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);

        // check to see if the mouse is in this windows rect, if not, then reset
        // the cursor to an arrow and release the mouse
        GetClientRect(hwnd, &rect);
        xPos = LOWORD(lParam);
        yPos = HIWORD(lParam);
        if ((xPos < 0) ||
            (yPos < 0) ||
            (xPos > (rect.right - rect.left)) ||
            (yPos > (rect.bottom - rect.top)))
        {
            SetCursor(WszLoadCursor(NULL, IDC_ARROW));
            ReleaseCapture();
            plsd->fMouseCaptured = FALSE;
        }

        return( TRUE );
    }

    return(WszCallWindowProc(plsd->wpPrev, hwnd, uMsg, wParam, lParam));
}

//+---------------------------------------------------------------------------
//
//  Function:   RenderACUIStringToEditControl
//
//  Synopsis:   renders a string to the control given and if requested, gives
//              it a link look and feel, subclassed to the wndproc and plsd
//              given
//
//  Arguments:  [hwndDlg]       -- dialog window handle
//              [ControlId]     -- control id
//              [NextControlId] -- next control id
//              [psz]           -- string
//              [deltavpos]     -- delta vertical position
//              [fLink]         -- a link?
//              [wndproc]       -- optional wndproc, valid if fLink == TRUE
//              [plsd]          -- optional plsd, valid if fLink === TRUE
//              [minsep]        -- minimum separation
//              [pszThisTextOnlyInLink -- only change this text.
//
//  Returns:    delta in height of the control
//
//  Notes:
//
//----------------------------------------------------------------------------
int IACUIControl::RenderACUIStringToEditControl (HINSTANCE                 resources,
                                                 HWND                      hwndDlg,
                                                 UINT                      ControlId,
                                                 UINT                      NextControlId,
                                                 LPCWSTR                   psz,
                                                 int                       deltavpos,
                                                 BOOL                      fLink,
                                                 WNDPROC                   wndproc,
                                                 PTUI_LINK_SUBCLASS_DATA   plsd,
                                                 int                       minsep,
                                                 LPCWSTR                   pszThisTextOnlyInLink)
{
    HWND hControl;
    int  deltaheight = 0;
    int  oline = 0;
    int  hkcharpos;

    //
    // Get the control and set the text on it, make sure the background
    // is right if it is a rich edit control
    //

    hControl = GetDlgItem(hwndDlg, ControlId);
    oline = (int)WszSendMessage(hControl, EM_GETLINECOUNT, 0, 0);
    CryptUISetRicheditTextW(hwndDlg, ControlId, L"");
    CryptUISetRicheditTextW(hwndDlg, ControlId, psz); //SetWindowTextU(hControl, psz);

    //
    // If there is a '&' in the string, then get rid of it
    //
    hkcharpos = GetHotKeyCharPosition(hControl);
    if (hkcharpos != 0)
    {
        CHARRANGE  cr;
        //CHARFORMAT cf;

        cr.cpMin = hkcharpos - 1;
        cr.cpMax = hkcharpos;

        WszSendMessage(hControl, EM_EXSETSEL, 0, (LPARAM) &cr);
        WszSendMessage(hControl, EM_REPLACESEL, FALSE, (LPARAM) "");

        cr.cpMin = -1;
        cr.cpMax = 0;
        WszSendMessage(hControl, EM_EXSETSEL, 0, (LPARAM) &cr);
    }

    WszSendMessage(
        hControl,
        EM_SETBKGNDCOLOR,
        0,
        (LPARAM)GetSysColor(COLOR_3DFACE)
        );

    //
    // If we have a link then update for the link look
    //

    if ( fLink == TRUE )
    {
        CHARFORMAT cf;

        memset(&cf, 0, sizeof(CHARFORMAT));
        cf.cbSize = sizeof(CHARFORMAT);
        cf.dwMask = CFM_COLOR | CFM_UNDERLINE;

        cf.crTextColor = RGB(0, 0, 255);
        cf.dwEffects |= CFM_UNDERLINE;

        if (pszThisTextOnlyInLink)
        {
            FINDTEXTEX  ft;
            DWORD       pos;
            char        *pszOnlyThis;
            DWORD       cb;

            cb = WideCharToMultiByte(
                        0, 
                        0, 
                        pszThisTextOnlyInLink, 
                        -1,
                        NULL, 
                        0, 
                        NULL, 
                        NULL);

            if (NULL == (pszOnlyThis = new char[cb]))
            {
                return 0;
            }

            WideCharToMultiByte(
                        0, 
                        0, 
                        pszThisTextOnlyInLink, 
                        -1,
                        pszOnlyThis, 
                        cb, 
                        NULL, 
                        NULL);


            memset(&ft, 0x00, sizeof(FINDTEXTEX));
            ft.chrg.cpMin   = 0;
            ft.chrg.cpMax   = (-1);
            ft.lpstrText    = (WCHAR *)pszOnlyThis;

            if ((pos = (DWORD)WszSendMessage(hControl, EM_FINDTEXTEX, 0, (LPARAM)&ft)) != (-1))
            {
                WszSendMessage(hControl, EM_EXSETSEL, 0, (LPARAM)&ft.chrgText);
                WszSendMessage(hControl, EM_SETCHARFORMAT, SCF_WORD | SCF_SELECTION, (LPARAM)&cf);
                ft.chrgText.cpMin   = 0;
                ft.chrgText.cpMax   = 0;
                WszSendMessage(hControl, EM_EXSETSEL, 0, (LPARAM)&ft.chrgText);
            }

            delete[] pszOnlyThis;
        }
        else
        {
            WszSendMessage(hControl, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
        }
    }

    //
    // Rebase the control
    //

    RebaseControlVertical(
                 hwndDlg,
                 hControl,
                 GetDlgItem(hwndDlg, NextControlId),
                 TRUE,
                 deltavpos,
                 oline,
                 minsep,
                 &deltaheight
                 );

    //
    // If we have the link look then we must subclass for the appropriate
    // link feel, otherwise we subclass for a static text control feel
    //

    if ( fLink == TRUE )
    {
        SubclassEditControlForLink(hwndDlg, hControl, wndproc, plsd, resources);
    }
    else
    {
        SubclassEditControlForArrowCursor(hControl);
    }

    return( deltaheight );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\acuihelp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#if !defined(__ACUIHELP_H__)
#define __ACUIHELP_H__

#include <windows.h>

typedef struct {
    LPSTR   psz;
    LPCWSTR pwsz;
    LONG    byteoffset;
    BOOL    fStreamIn;
} STREAMIN_HELPER_STRUCT;


//
// defined in DllMain
//
extern LPCWSTR GetModuleName();
extern HINSTANCE GetModuleInst();
extern HINSTANCE GetResourceInst();
extern BOOL GetRichEdit2Exists();


#if defined(__cplusplus)
extern "C" {
#endif

//
// Dialog helper routines.
//
    VOID RebaseControlVertical (HWND  hwndDlg,
                                HWND  hwnd,
                                HWND  hwndNext,
                                BOOL  fResizeForText,
                                int   deltavpos,
                                int   oline,
                                int   minsep,
                                int*  pdeltaheight);

    int GetRichEditControlLineHeight(HWND  hwnd);

    HRESULT FormatACUIResourceString (HINSTANCE hResources,
                                      UINT   StringResourceId,
                                      DWORD_PTR* aMessageArgument,
                                      LPWSTR* ppszFormatted);

    int CalculateControlVerticalDistance(HWND hwnd, 
                                         UINT Control1, 
                                         UINT Control2);

    int CalculateControlVerticalDistanceFromDlgBottom(HWND hwnd, 
                                                      UINT Control);

    VOID ACUICenterWindow (HWND hWndToCenter);

    VOID ACUIViewHTMLHelpTopic (HWND hwnd, LPSTR pszTopic);

    int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline);

    void DrawFocusRectangle (HWND hwnd, HDC hdc);

    int GetHotKeyCharPositionFromString (LPWSTR pwszText);

    int GetHotKeyCharPosition (HWND hwnd);

    VOID FormatHotKeyOnEditControl (HWND hwnd, int hkcharpos);

    void AdjustEditControlWidthToLineCount(HWND hwnd, int cline, TEXTMETRIC* ptm);

    DWORD CryptUISetRicheditTextW(HWND hwndDlg, UINT id, LPCWSTR pwsz);

    LRESULT CALLBACK ACUISetArrowCursorSubclass (HWND   hwnd,
                                                 UINT   uMsg,
                                                 WPARAM wParam,
                                                 LPARAM lParam);

    DWORD CALLBACK SetRicheditTextWCallback(DWORD_PTR dwCookie, // application-defined value
                                            LPBYTE  pbBuff,     // pointer to a buffer
                                            LONG    cb,         // number of bytes to read or write
                                            LONG    *pcb);      // pointer to number of bytes transferred

    void SetRicheditIMFOption(HWND hWndRichEdit);

    BOOL fRichedit20Usable(HWND hwndEdit);

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\acuihelp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************
#include "stdpch.h"

#include "richedit.h"
#include "commctrl.h"

#include "resource.h"
#include "corpolicy.h"
#include "corperm.h"
#include "corhlpr.h"
#include "winwrap.h"
#include "acuihelp.h"
#include "acui.h"



//+---------------------------------------------------------------------------
//
//  Function:   ACUISetArrowCursorSubclass
//
//  Synopsis:   subclass routine for setting the arrow cursor.  This can be
//              set on multiline edit routines used in the dialog UIs for
//              the default Authenticode provider
//
//  Arguments:  [hwnd]   -- window handle
//              [uMsg]   -- message id
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if message handled, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK ACUISetArrowCursorSubclass (
                  HWND   hwnd,
                  UINT   uMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    //HDC         hdc;
    WNDPROC     wndproc;
    //PAINTSTRUCT ps;

    wndproc = (WNDPROC)WszGetWindowLong(hwnd, GWLP_USERDATA);

    switch ( uMsg )
    {
    case WM_SETCURSOR:

        SetCursor(WszLoadCursor(NULL, IDC_ARROW));
        return( TRUE );

        break;

    case WM_CHAR:

        if ( wParam != (WPARAM)' ' )
        {
            break;
        }

    case WM_LBUTTONDOWN:

       return(TRUE);

    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:

        return( TRUE );

        break;

    case EM_SETSEL:

        return( TRUE );

        break;

    case WM_PAINT:

        WszCallWindowProc(wndproc, hwnd, uMsg, wParam, lParam);
        if ( hwnd == GetFocus() )
        {
            DrawFocusRectangle(hwnd, NULL);
        }
        return( TRUE );

        break;

    case WM_SETFOCUS:

        InvalidateRect(hwnd, NULL, FALSE);
        UpdateWindow(hwnd);
        SetCursor(WszLoadCursor(NULL, IDC_ARROW));
        return( TRUE );

    case WM_KILLFOCUS:

        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
        return( TRUE );

    }

    return(WszCallWindowProc(wndproc, hwnd, uMsg, wParam, lParam));
}


//+---------------------------------------------------------------------------
//
//  Function:   RebaseControlVertical
//
//  Synopsis:   Take the window control, if it has to be resized for text, do
//              so.  Reposition it adjusted for delta pos and return any
//              height difference for the text resizing
//
//  Arguments:  [hwndDlg]        -- host dialog
//              [hwnd]           -- control
//              [hwndNext]       -- next control
//              [fResizeForText] -- resize for text flag
//              [deltavpos]      -- delta vertical position
//              [oline]          -- original number of lines
//              [minsep]         -- minimum separator
//              [pdeltaheight]   -- delta in control height
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID RebaseControlVertical (
                  HWND  hwndDlg,
                  HWND  hwnd,
                  HWND  hwndNext,
                  BOOL  fResizeForText,
                  int   deltavpos,
                  int   oline,
                  int   minsep,
                  int*  pdeltaheight
                  )
{
    int        x = 0;
    int        y = 0;
    int        odn = 0;
    int         orig_w;
    RECT       rect;
    RECT       rectNext;
    RECT       rectDlg;
    TEXTMETRIC tm={0};

    //
    // Set the delta height to zero for now.  If we resize the text
    // a new one will be calculated
    //

    *pdeltaheight = 0;

    //
    // Get the control window rectangle
    //

    GetWindowRect(hwnd, &rect);
    GetWindowRect(hwndNext, &rectNext);

    odn     = rectNext.top - rect.bottom;

    orig_w  = rect.right - rect.left;

    MapWindowPoints(NULL, hwndDlg, (LPPOINT) &rect, 2);

    //
    // If we have to resize the control due to text, find out what font
    // is being used and the number of lines of text.  From that we'll
    // calculate what the new height for the control is and set it up
    //

    if ( fResizeForText == TRUE )
    {
        HDC        hdc;
        HFONT      hfont;
        HFONT      hfontOld;
        int        cline;
        int        h;
        int        w;
        int        dh;
        int        lineHeight;
        
        //
        // Get the metrics of the current control font
        //

        hdc = GetDC(hwnd);
        if (hdc == NULL)
        {
            hdc = GetDC(NULL);
            if (hdc == NULL)
            {
                return;
            }
        }

        hfont = (HFONT)WszSendMessage(hwnd, WM_GETFONT, 0, 0);
        if ( hfont == NULL )
        {
            hfont = (HFONT)WszSendMessage(hwndDlg, WM_GETFONT, 0, 0);
        }

        hfontOld = (HFONT)SelectObject(hdc, hfont);
        if(!GetTextMetrics(hdc, &tm))
        {
            tm.tmHeight=32;        //hopefully GetRichEditControlLineHeight will replace it. 
                                   // If not - we have to take a guess because we can't fail RebaseControlVertical
                                    
            tm.tmMaxCharWidth=16;  // doesn't matter that much but should be bigger than 0

        };


        lineHeight = GetRichEditControlLineHeight(hwnd);
        if (lineHeight == 0)
        {
            lineHeight = tm.tmHeight;
        }
        
        //
        // Set the minimum separation value
        //

        if ( minsep == 0 )
        {
            minsep = lineHeight;
        }

        //
        // Calculate the width and the new height needed
        //

        cline = (int)WszSendMessage(hwnd, EM_GETLINECOUNT, 0, 0);

        h = cline * lineHeight;

        w = GetEditControlMaxLineWidth(hwnd, hdc, cline);
        w += 3; // a little bump to make sure string will fit

        if (w > orig_w)
        {
            w = orig_w;
        }

        SelectObject(hdc, hfontOld);
        ReleaseDC(hwnd, hdc);

        //
        // Calculate an addition to height by checking how much space was
        // left when there were the original # of lines and making sure that
        // that amount is  still left when we do any adjustments
        //

        h += ( ( rect.bottom - rect.top ) - ( oline * lineHeight ) );
        dh = h - ( rect.bottom - rect.top );

        //
        // If the current height is too small, adjust for it, otherwise
        // leave the current height and just adjust for the width
        //

        if ( dh > 0 )
        {
            SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        }
        else
        {
            SetWindowPos(
               hwnd,
               NULL,
               0,
               0,
               w,
               ( rect.bottom - rect.top ),
               SWP_NOZORDER | SWP_NOMOVE
               );
        }

        if ( cline < WszSendMessage(hwnd, EM_GETLINECOUNT, 0, 0) )
        {
            AdjustEditControlWidthToLineCount(hwnd, cline, &tm);
        }
    }

    //
    // If we have to use deltavpos then calculate the X and the new Y
    // and set the window position appropriately
    //

    if ( deltavpos != 0 )
    {
        GetWindowRect(hwndDlg, &rectDlg);

        MapWindowPoints(NULL, hwndDlg, (LPPOINT) &rectDlg, 2);

        x = rect.left - rectDlg.left - GetSystemMetrics(SM_CXEDGE);
        y = rect.top - rectDlg.top - GetSystemMetrics(SM_CYCAPTION) + deltavpos;

        SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
    }

    //
    // Get the window rect for the next control and see what the distance
    // is between the current control and it.  With that we must now
    // adjust our deltaheight, if the distance to the next control is less
    // than a line height then make it a line height, otherwise just let it
    // be
    //

    if ( hwndNext != NULL )
    {
        int dn;

        GetWindowRect(hwnd, &rect);
        GetWindowRect(hwndNext, &rectNext);

        dn = rectNext.top - rect.bottom;

        if ( odn > minsep )
        {
            if ( dn < minsep )
            {
                *pdeltaheight = minsep - dn;
            }
        }
        else
        {
            if ( dn < odn )
            {
                *pdeltaheight = odn - dn;
            }
        }
    }
}

int GetRichEditControlLineHeight(HWND  hwnd)
{
    RECT        rect;
    POINT       pointInFirstRow;
    POINT       pointInSecondRow;
    int         secondLineCharIndex;
    int         i;
    RECT        originalRect;

    GetWindowRect(hwnd, &originalRect);

    //
    // HACK ALERT, believe it or not there is no way to get the height of the current
    // font in the edit control, so get the position a character in the first row and the position
    // of a character in the second row, and do the subtraction to get the
    // height of the font
    //
    WszSendMessage(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInFirstRow, (LPARAM) 0);

    //
    // HACK ON TOP OF HACK ALERT,
    // since there may not be a second row in the edit box, keep reducing the width
    // by half until the first row falls over into the second row, then get the position
    // of the first char in the second row and finally reset the edit box size back to
    // it's original size
    //
    secondLineCharIndex = (int)WszSendMessage(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
    if (secondLineCharIndex == -1)
    {
        for (i=0; i<20; i++)
        {
            GetWindowRect(hwnd, &rect);
            SetWindowPos(   hwnd,
                            NULL,
                            0,
                            0,
                            (rect.right-rect.left)/2,
                            rect.bottom-rect.top,
                            SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
            secondLineCharIndex = (int)WszSendMessage(hwnd, EM_LINEINDEX, (WPARAM) 1, (LPARAM) 0);
            if (secondLineCharIndex != -1)
            {
                break;
            }
        }

        if (secondLineCharIndex == -1)
        {
            // if we failed after twenty tries just reset the control to its original size
            // and get the heck outa here!!
            SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            return 0;
        }

        WszSendMessage(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);

        SetWindowPos(hwnd,
                    NULL,
                    0,
                    0,
                    originalRect.right-originalRect.left,
                    originalRect.bottom-originalRect.top,
                    SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
    }
    else
    {
        WszSendMessage(hwnd, EM_POSFROMCHAR, (WPARAM) &pointInSecondRow, (LPARAM) secondLineCharIndex);
    }
    
    return (pointInSecondRow.y - pointInFirstRow.y);
}


//+---------------------------------------------------------------------------
//
//  Function:   FormatACUIResourceString
//
//  Synopsis:   formats a string given a resource id and message arguments
//
//  Arguments:  [StringResourceId] -- resource id
//              [aMessageArgument] -- message arguments
//              [ppszFormatted]    -- formatted string goes here
//
//  Returns:    S_OK if successful, any valid HRESULT otherwise
//
//----------------------------------------------------------------------------
HRESULT FormatACUIResourceString (HINSTANCE hResources,
                                  UINT   StringResourceId,
                                  DWORD_PTR* aMessageArgument,
                                  LPWSTR* ppszFormatted)
{
    HRESULT hr = S_OK;
    WCHAR   sz[MAX_LOADSTRING_BUFFER];
    LPVOID  pvMsg;

    pvMsg = NULL;
    sz[0] = NULL;

    //
    // Load the string resource and format the message with that string and
    // the message arguments
    //

    if (StringResourceId != 0)
    {
        if ( WszLoadString(hResources, StringResourceId, sz, MAX_LOADSTRING_BUFFER) == 0 )
        {
            return(HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( WszFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
                              FORMAT_MESSAGE_ARGUMENT_ARRAY, sz, 0, 0, (LPWSTR)&pvMsg, 0,
                              (va_list *)aMessageArgument) == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        if ( WszFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY, (char *)aMessageArgument[0], 0, 0,
                            (LPWSTR)&pvMsg, 0, (va_list *)&aMessageArgument[1]) == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (pvMsg)
    {
        *ppszFormatted = new WCHAR[wcslen((WCHAR *)pvMsg) + 1];

        if (*ppszFormatted)
        {
            wcscpy(*ppszFormatted, (WCHAR *)pvMsg);
        }

        LocalFree(pvMsg);
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   CalculateControlVerticalDistance
//
//  Synopsis:   calculates the vertical distance from the bottom of Control1
//              to the top of Control2
//
//  Arguments:  [hwnd]     -- parent dialog
//              [Control1] -- first control
//              [Control2] -- second control
//
//  Returns:    the distance in pixels
//
//  Notes:      assumes control1 is above control2
//
//----------------------------------------------------------------------------
int CalculateControlVerticalDistance (HWND hwnd, UINT Control1, UINT Control2)
{
    RECT rect1;
    RECT rect2;

    GetWindowRect(GetDlgItem(hwnd, Control1), &rect1);
    GetWindowRect(GetDlgItem(hwnd, Control2), &rect2);

    return( rect2.top - rect1.bottom );
}

//+---------------------------------------------------------------------------
//
//  Function:   CalculateControlVerticalDistanceFromDlgBottom
//
//  Synopsis:   calculates the distance from the bottom of the control to
//              the bottom of the dialog
//
//  Arguments:  [hwnd]    -- dialog
//              [Control] -- control
//
//  Returns:    the distance in pixels
//
//  Notes:
//
//----------------------------------------------------------------------------
int CalculateControlVerticalDistanceFromDlgBottom (HWND hwnd, UINT Control)
{
    RECT rect;
    RECT rectControl;

    GetClientRect(hwnd, &rect);
    GetWindowRect(GetDlgItem(hwnd, Control), &rectControl);

    return( rect.bottom - rectControl.bottom );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUICenterWindow
//
//  Synopsis:   centers the given window
//
//  Arguments:  [hWndToCenter] -- window handle
//
//  Returns:    (none)
//
//  Notes:      This code was stolen from ATL and hacked upon madly :-)
//
//----------------------------------------------------------------------------
VOID ACUICenterWindow (HWND hWndToCenter)
{
    HWND  hWndCenter;

    // determine owner window to center against
    DWORD dwStyle = (DWORD) WszGetWindowLong(hWndToCenter, GWL_STYLE);

    if(dwStyle & WS_CHILD)
        hWndCenter = ::GetParent(hWndToCenter);
    else
        hWndCenter = ::GetWindow(hWndToCenter, GW_OWNER);

    if (hWndCenter == NULL)
    {
        return;
    }

    // get coordinates of the window relative to its parent
    RECT rcDlg;
    ::GetWindowRect(hWndToCenter, &rcDlg);
    RECT rcArea;
    RECT rcCenter;
    HWND hWndParent;
    if(!(dwStyle & WS_CHILD))
    {
        // don't center against invisible or minimized windows
        if(hWndCenter != NULL)
        {
            DWORD dwStyle2 = (DWORD) WszGetWindowLong(hWndCenter, GWL_STYLE);
            if(!(dwStyle2 & WS_VISIBLE) || (dwStyle2 & WS_MINIMIZE))
                hWndCenter = NULL;
        }

        // center within screen coordinates
        WszSystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

        if(hWndCenter == NULL)
            rcCenter = rcArea;
        else
            ::GetWindowRect(hWndCenter, &rcCenter);
    }
    else
    {
        // center within parent client coordinates
        hWndParent = ::GetParent(hWndToCenter);

        ::GetClientRect(hWndParent, &rcArea);
        ::GetClientRect(hWndCenter, &rcCenter);
        ::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
    }

    int DlgWidth = rcDlg.right - rcDlg.left;
    int DlgHeight = rcDlg.bottom - rcDlg.top;

    // find dialog's upper left based on rcCenter
    int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
    int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

    // if the dialog is outside the screen, move it inside
    if(xLeft < rcArea.left)
        xLeft = rcArea.left;
    else if(xLeft + DlgWidth > rcArea.right)
        xLeft = rcArea.right - DlgWidth;

    if(yTop < rcArea.top)
        yTop = rcArea.top;
    else if(yTop + DlgHeight > rcArea.bottom)
        yTop = rcArea.bottom - DlgHeight;

    // map screen coordinates to child coordinates
    ::SetWindowPos(
         hWndToCenter,
         HWND_TOPMOST,
         xLeft,
         yTop,
         -1,
         -1,
         SWP_NOSIZE | SWP_NOACTIVATE
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIViewHTMLHelpTopic
//
//  Synopsis:   html help viewer
//
//  Arguments:  [hwnd]     -- caller window
//              [pszTopic] -- topic
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID ACUIViewHTMLHelpTopic (HWND hwnd, LPSTR pszTopic)
{
//    HtmlHelpA(
//        hwnd,
//        "%SYSTEMROOT%\\help\\iexplore.chm>large_context",
//        HH_DISPLAY_TOPIC,
//        (DWORD)pszTopic
//        );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetEditControlMaxLineWidth
//
//  Synopsis:   gets the maximum line width of the edit control
//
//----------------------------------------------------------------------------
int GetEditControlMaxLineWidth (HWND hwndEdit, HDC hdc, int cline)
{
    int        index;
    int        line;
    int        charwidth;
    int        maxwidth = 0;
    CHAR       szMaxBuffer[1024];
    WCHAR      wsz[1024];
    TEXTRANGEA tr;
    SIZE       size;

    tr.lpstrText = szMaxBuffer;

    for ( line = 0; line < cline; line++ )
    {
        index = (int)WszSendMessage(hwndEdit, EM_LINEINDEX, (WPARAM)line, 0);
        charwidth = (int)WszSendMessage(hwndEdit, EM_LINELENGTH, (WPARAM)index, 0);

        tr.chrg.cpMin = index;
        tr.chrg.cpMax = index + charwidth;
        WszSendMessage(hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM)&tr);

        wsz[0] = NULL;

        MultiByteToWideChar(0, 0, (const char *)tr.lpstrText, -1, &wsz[0], 1024);

        if (wsz[0])
        {
            GetTextExtentPoint32W(hdc, &wsz[0], charwidth, &size);

            if ( size.cx > maxwidth )
            {
                maxwidth = size.cx;
            }
        }
    }

    return( maxwidth );
}

//+---------------------------------------------------------------------------
//
//  Function:   DrawFocusRectangle
//
//  Synopsis:   draws the focus rectangle for the edit control
//
//----------------------------------------------------------------------------
void DrawFocusRectangle (HWND hwnd, HDC hdc)
{
    RECT        rect;
    //PAINTSTRUCT ps;
    BOOL        fReleaseDC = FALSE;

    if ( hdc == NULL )
    {
        hdc = GetDC(hwnd);
        if ( hdc == NULL )
        {
            return;
        }
        fReleaseDC = TRUE;
    }

    GetClientRect(hwnd, &rect);
    DrawFocusRect(hdc, &rect);

    if ( fReleaseDC == TRUE )
    {
        ReleaseDC(hwnd, hdc);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetHotKeyCharPositionFromString
//
//  Synopsis:   gets the character position for the hotkey, zero means
//              no-hotkey
//
//----------------------------------------------------------------------------
int GetHotKeyCharPositionFromString (LPWSTR pwszText)
{
    LPWSTR psz = pwszText;

    while ( ( psz = wcschr(psz, L'&') ) != NULL )
    {
        psz++;
        if ( *psz != L'&' )
        {
            break;
        }
    }

    if ( psz == NULL )
    {
        return( 0 );
    }

    return (int)(( psz - pwszText ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetHotKeyCharPosition
//
//  Synopsis:   gets the character position for the hotkey, zero means
//              no-hotkey
//
//----------------------------------------------------------------------------
int GetHotKeyCharPosition (HWND hwnd)
{
    int   nPos = 0;
    WCHAR szText[MAX_LOADSTRING_BUFFER] = L"";

    if (WszGetWindowText(hwnd, szText, MAX_LOADSTRING_BUFFER))
    {
        nPos = GetHotKeyCharPositionFromString(szText);
    }

    return nPos;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatHotKeyOnEditControl
//
//  Synopsis:   formats the hot key on an edit control by making it underlined
//
//----------------------------------------------------------------------------
VOID FormatHotKeyOnEditControl (HWND hwnd, int hkcharpos)
{
    CHARRANGE  cr;
    CHARFORMAT cf;

    assert( hkcharpos != 0 );

    cr.cpMin = hkcharpos - 1;
    cr.cpMax = hkcharpos;

    WszSendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&cr);

    memset(&cf, 0, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_UNDERLINE;
    cf.dwEffects |= CFM_UNDERLINE;

    WszSendMessage(hwnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    cr.cpMin = -1;
    cr.cpMax = 0;
    WszSendMessage(hwnd, EM_EXSETSEL, 0, (LPARAM)&cr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdjustEditControlWidthToLineCount
//
//  Synopsis:   adjust edit control width to the given line count
//
//----------------------------------------------------------------------------
void AdjustEditControlWidthToLineCount(HWND hwnd, int cline, TEXTMETRIC* ptm)
{
    RECT rect;
    int  w;
    int  h;

    GetWindowRect(hwnd, &rect);
    h = rect.bottom - rect.top;
    w = rect.right - rect.left;

    while ( cline < WszSendMessage(hwnd, EM_GETLINECOUNT, 0, 0) )
    {
        w += ptm->tmMaxCharWidth?ptm->tmMaxCharWidth:16;
        SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOZORDER | SWP_NOMOVE);
        printf(
            "Line count adjusted to = %d\n",
            (DWORD) WszSendMessage(hwnd, EM_GETLINECOUNT, 0, 0)
            );
    }
}

DWORD CryptUISetRicheditTextW(HWND hwndDlg, UINT id, LPCWSTR pwsz)
{
    EDITSTREAM              editStream;
    STREAMIN_HELPER_STRUCT  helpStruct;

    SetRicheditIMFOption(GetDlgItem(hwndDlg, id));

    //
    // setup the edit stream struct since it is the same no matter what
    //
    editStream.dwCookie = (DWORD_PTR) &helpStruct;
    editStream.dwError = 0;
    editStream.pfnCallback = SetRicheditTextWCallback;


    if (!GetRichEdit2Exists() || !fRichedit20Usable(GetDlgItem(hwndDlg, id)))
    {
        WszSetDlgItemText(hwndDlg, id, pwsz);
        return 0;
    }

    helpStruct.pwsz = pwsz;
    helpStruct.byteoffset = 0;
    helpStruct.fStreamIn = TRUE;

    SendDlgItemMessageA(hwndDlg, id, EM_STREAMIN, SF_TEXT | SF_UNICODE, (LPARAM) &editStream);


    return editStream.dwError;
}


void SetRicheditIMFOption(HWND hWndRichEdit)
{
    DWORD dwOptions;

    if (GetRichEdit2Exists() && fRichedit20Usable(hWndRichEdit))
    {
        dwOptions = (DWORD)SendMessageA(hWndRichEdit, EM_GETLANGOPTIONS, 0, 0);
        dwOptions |= IMF_UIFONTS;
        SendMessageA(hWndRichEdit, EM_SETLANGOPTIONS, 0, dwOptions);
    }
}

DWORD CALLBACK SetRicheditTextWCallback(
    DWORD_PTR dwCookie, // application-defined value
    LPBYTE  pbBuff,     // pointer to a buffer
    LONG    cb,         // number of bytes to read or write
    LONG    *pcb        // pointer to number of bytes transferred
)
{
    STREAMIN_HELPER_STRUCT *pHelpStruct = (STREAMIN_HELPER_STRUCT *) dwCookie;
    LONG  lRemain = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);

    if (pHelpStruct->fStreamIn)
    {
        //
        // The whole string can be copied first time
        //
        if ((cb >= (LONG) (wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) && (pHelpStruct->byteoffset == 0))
        {
            memcpy(pbBuff, pHelpStruct->pwsz, wcslen(pHelpStruct->pwsz) * sizeof(WCHAR));
            *pcb = wcslen(pHelpStruct->pwsz) * sizeof(WCHAR);
            pHelpStruct->byteoffset = *pcb;
        }
        //
        // The whole string has been copied, so terminate the streamin callbacks
        // by setting the num bytes copied to 0
        //
        else if (((LONG)(wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) <= pHelpStruct->byteoffset)
        {
            *pcb = 0;
        }
        //
        // The rest of the string will fit in this buffer
        //
        else if (cb >= (LONG) ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset))
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset));
            *pcb = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
            pHelpStruct->byteoffset += ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
        }
        //
        // copy as much as possible
        //
        else
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                cb);
            *pcb = cb;
            pHelpStruct->byteoffset += cb;
        }
    }
    else
    {
        //
        // This is the EM_STREAMOUT which is only used during the testing of
        // the richedit2.0 functionality.  (we know our buffer is 32 bytes)
        //
        if (cb <= 32)
        {
            memcpy(pHelpStruct->psz, pbBuff, cb);
        }
        *pcb = cb;
    }

    return 0;
}


static BOOL fRichedit20UsableCheckMade = FALSE;
static BOOL fRichedit20UsableVar = FALSE;

BOOL fRichedit20Usable(HWND hwndEdit)
{
    EDITSTREAM              editStream;
    STREAMIN_HELPER_STRUCT  helpStruct;
    LPWSTR                  pwsz = L"Test String";
    LPSTR                   pwszCompare = "Test String";
    char                    compareBuf[32];

    if (fRichedit20UsableCheckMade)
    {
        return (fRichedit20UsableVar);
    }

    //
    // setup the edit stream struct since it is the same no matter what
    //
    editStream.dwCookie = (DWORD_PTR) &helpStruct;
    editStream.dwError = 0;
    editStream.pfnCallback = SetRicheditTextWCallback;

    helpStruct.pwsz = pwsz;
    helpStruct.byteoffset = 0;
    helpStruct.fStreamIn = TRUE;

    SendMessageA(hwndEdit, EM_SETSEL, 0, -1);
    SendMessageA(hwndEdit, EM_STREAMIN, SF_TEXT | SF_UNICODE | SFF_SELECTION, (LPARAM) &editStream);

    memset(&(compareBuf[0]), 0, 32 * sizeof(char));
    helpStruct.psz = compareBuf;
    helpStruct.fStreamIn = FALSE;
    SendMessageA(hwndEdit, EM_STREAMOUT, SF_TEXT, (LPARAM) &editStream);

    fRichedit20UsableVar = (strcmp(pwszCompare, compareBuf) == 0);

    fRichedit20UsableCheckMade = TRUE;
    SetWindowTextA(hwndEdit, "");

    return (fRichedit20UsableVar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\dllmain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// dllmain.cpp
//
// This module contains the public entry points for the COM+ Security dll.  
// This dll exists to keep the working set in the EE to a minimum. All routines
// that pull in the cryptography dll's or ASN dll's are exported from this dll
// and latebound into the EE.
//
//*****************************************************************************
#include "stdpch.h"
#include <commctrl.h>
#include "utilcode.h"
#include "CorPermP.h"

//
// Module instance
//
HINSTANCE       g_hThisInst;            // This library.
BOOL            fRichedit20Exists = FALSE;
WCHAR dllName[] = L"mscorsec.dll";

extern "C"
STDAPI DllRegisterServer ( void )
{
    return CorPermRegisterServer(L"mscorsec.dll");
}


//+-------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:   Remove registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------

static BOOL CheckRichedit20Exists()
{
    HMODULE hModRichedit20;

    hModRichedit20 = LoadLibraryA("RichEd20.dll");

    if (hModRichedit20 != NULL)
    {
        FreeLibrary(hModRichedit20);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


extern "C" 
STDAPI DllUnregisterServer ( void )
{
    return CorPermUnregisterServer();
}

extern "C" 
STDAPI DllCanUnloadNow(void)
{
    return S_OK;
}


STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv) 
{
    return E_NOTIMPL;
}

static int GetThreadUICultureName(LPWSTR szBuffer, int length);
static int GetThreadUICultureParentName(LPWSTR szBuffer, int length);
static int GetThreadUICultureId();

CCompRC* g_pResourceDll = NULL;  // MUI Resource string

BOOL WINAPI DllMain(HANDLE hInstDLL,
                    DWORD   dwReason,
                    LPVOID  lpvReserved)
{
    BOOL    fReturn = TRUE;
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls((HINSTANCE)hInstDLL);

        // Init unicode wrappers.
        OnUnicodeSystem();

        // Save the module handle.
        g_hThisInst = (HMODULE)hInstDLL;

        fRichedit20Exists =  CheckRichedit20Exists();
        //
        // Initialize the common controls
        //

        InitCommonControls();

        g_pResourceDll = new CCompRC(L"mscorsecr.dll");
        if(g_pResourceDll == NULL)
            fReturn = FALSE;
        else 
            g_pResourceDll->SetResourceCultureCallbacks(GetMUILanguageName,
                                                        GetMUILanguageID,
                                                        GetMUIParentLanguageName);

        break;

    case DLL_PROCESS_DETACH:
        if(g_pResourceDll) delete g_pResourceDll;

        break;
    }

    return fReturn;
}

HINSTANCE GetResourceInst()
{
    HINSTANCE hInstance;
    if(SUCCEEDED(g_pResourceDll->LoadMUILibrary(&hInstance)))
        return hInstance;
    else
        return NULL;
}

HINSTANCE GetModuleInst()
{
    return (g_hThisInst);
}

BOOL GetRichEdit2Exists()
{
    return fRichedit20Exists;
}

LPCWSTR GetModuleName()
{
    return dllName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\acui.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


//*****************************************************************************
//*****************************************************************************
#if !defined(__ACUI_H__)
#define __ACUI_H__

#include <windows.h>
#include "iih.h"

// Note:
//      When subclassing for Link pvData must be the HINSTANCE for the resources
typedef struct _TUI_LINK_SUBCLASS_DATA {
    
    HWND    hwndParent;
    WNDPROC wpPrev;
    DWORD_PTR uToolTipText;
    DWORD   uId;
    HWND    hwndTip;
    LPVOID  pvData;               // Must be the HINSTANCE for resources or be found in pvData
    BOOL    fMouseCaptured;
    
} TUI_LINK_SUBCLASS_DATA, *PTUI_LINK_SUBCLASS_DATA;

//
// IACUIControl abstract base class interface.  This is used by the
// invoke UI entry point to put up the appropriate UI.  There are different
// implementations of this interface based on the invoke reason code
//

class IACUIControl
{
public:
    IACUIControl(HINSTANCE hResources) :
        m_hResources(hResources)
    {}

    //
    // Virtual destructor
    //
    virtual ~IACUIControl ();

    //
    // UI Message processing
    //

    virtual BOOL OnUIMessage (
                     HWND   hwnd,
                     UINT   uMsg,
                     WPARAM wParam,
                     LPARAM lParam
                     );

    void SetupButtons(HWND hwnd);

    //
    // Pure virtual methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay) = 0;

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam) = 0;

    virtual BOOL OnYes (HWND hwnd) = 0;

    virtual BOOL OnNo (HWND hwnd) = 0;

    virtual BOOL OnMore (HWND hwnd) = 0;

    virtual BOOL ShowYes(LPWSTR*) = 0;
    virtual BOOL ShowNo(LPWSTR*) = 0;
    virtual BOOL ShowMore(LPWSTR*) = 0;

protected:
    HINSTANCE Resources() { return m_hResources; }

public:
    INT_PTR static CALLBACK ACUIMessageProc (HWND   hwnd,
                                      UINT   uMsg,
                                      WPARAM wParam,
                                      LPARAM lParam);

    VOID static SubclassEditControlForArrowCursor (HWND hwndEdit);

    VOID static SubclassEditControlForLink (HWND                       hwndDlg,
                                            HWND                       hwndEdit,
                                            WNDPROC                    wndproc,
                                            PTUI_LINK_SUBCLASS_DATA    plsd,
                                            HINSTANCE                  resources);

    LRESULT static CALLBACK ACUILinkSubclass(HWND   hwnd,
                                             UINT   uMsg,
                                             WPARAM wParam,
                                             LPARAM lParam);


    int static RenderACUIStringToEditControl(HINSTANCE                 resources,
                                             HWND                      hwndDlg,
                                             UINT                      ControlId,
                                             UINT                      NextControlId,
                                             LPCWSTR                   psz,
                                             int                       deltavpos,
                                             BOOL                      fLink,
                                             WNDPROC                   wndproc,
                                             PTUI_LINK_SUBCLASS_DATA   plsd,
                                             int                       minsep,
                                             LPCWSTR                   pszThisTextOnlyInLink);
    

private:
    HINSTANCE m_hResources;

};

#undef  IDC_CROSS
#define IDC_CROSS           MAKEINTRESOURCEW(32515)
#undef  IDC_ARROW
#define IDC_ARROW           MAKEINTRESOURCEW(32512)
#undef  IDC_WAIT
#define IDC_WAIT            MAKEINTRESOURCEW(32514)


#if defined(__cplusplus)
extern "C" {
#endif

#if defined(__cplusplus)
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\displayd.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************
#include "stdpch.h"
#include "Shlwapi.h"
#include "corpolicy.h"
#include "corperm.h"
#include "corhlpr.h"
#include "winwrap.h"
#include "mscoree.h"


#include "resource.h"
#include "acuihelp.h"
#include "iih.h"
#include "uicontrol.h"

HRESULT DisplayUnsignedRequestDialog(HWND hParent, 
                                     PCRYPT_PROVIDER_DATA pData, 
                                     LPCWSTR pURL, 
                                     LPCWSTR pZone, 
                                     DWORD* pdwState)
{
    HRESULT hr = S_OK;
    //
    // Initialize rich edit control DLL
    //
    if ( WszLoadLibrary(L"riched32.dll") == NULL )
    {
        return( E_FAIL );
    }

    if ( WszLoadLibrary(L"riched20.dll") == NULL )
    {
        return( E_FAIL );
    }

    HINSTANCE resources = GetResourceInst();
    if(resources == NULL)
        return E_FAIL;

    // 
    // Get the Site portion of the URL
    //
    if(pURL == NULL)
        return E_FAIL;

    DWORD lgth = wcslen(pURL);
    CQuickString url;
    
    if(lgth >= url.MaxSize())
        url.ReSize(lgth+1);
    
    lgth = url.MaxSize();
    hr = SUCCEEDED(UrlGetPart(pURL,
                              (LPWSTR) url.Ptr(), 
                              &lgth,
                              URL_PART_HOSTNAME,
                              URL_PARTFLAG_KEEPSCHEME));
    if(FAILED(hr)) return hr;

    CQuickString helpUrl;
    if(WszLoadString(resources, IDS_SECURITY, (LPWSTR) helpUrl.Ptr(), helpUrl.MaxSize()) == 0 )
    {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }
    
    CInvokeInfoHelper  helper(pData, (LPWSTR) url.Ptr(), pZone, (LPWSTR) helpUrl.Ptr(), resources, hr);
    
    if(SUCCEEDED(hr)) {
        CUnverifiedTrustUI ui(helper, hr);
        if(SUCCEEDED(hr)) {
            hr = ui.InvokeUI(hParent);
            if(SUCCEEDED(hr) || hr == TRUST_E_SUBJECT_NOT_TRUSTED)
                if(pdwState) *pdwState = helper.GetFlag();
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\iih.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       iih.cpp
//
//  Contents:   ACUI Invoke Info Helper class implementation
//
//  History:    10-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <stdpch.h>
#include "hlink.h"
#include "winwrap.h"
#include "resource.h"
#include "malloc.h"
#include "debugmacros.h"
#include "shellapi.h"
#include "corperm.h"

#include "acuihelp.h"
#include "acui.h"
#include "iih.h"

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::CInvokeInfoHelper, public
//
//  Synopsis:   Constructor, initializes member variables from data found
//              in the invoke info data structure
//
//  Arguments:  [pInvokeInfo] -- invoke info
//              [rhr]         -- result of construction
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CInvokeInfoHelper::CInvokeInfoHelper (
                          PCRYPT_PROVIDER_DATA pData,
                          LPCWSTR pSite,
                          LPCWSTR pZone,
                          LPCWSTR pHelpUrl,
                          HINSTANCE hResources,
                          HRESULT& rhr
                          )
                  : m_pData ( pData ),
                    m_pszSite(pSite),
                    m_pszZone(pZone),
                    m_pszErrorStatement ( NULL ),
                    m_pszHelpURL(pHelpUrl),
                    m_hResources(hResources),
                    m_dwFlag(COR_UNSIGNED_NO)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::~CInvokeInfoHelper, public
//
//  Synopsis:   Destructor, frees up member variables
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CInvokeInfoHelper::~CInvokeInfoHelper ()
{
    delete [] m_pszErrorStatement;

}


//+---------------------------------------------------------------------------
//
//  Member:     CInvokeInfoHelper::InitErrorStatement, private
//
//  Synopsis:   Initialize m_pszErrorStatement
//
//  Arguments:  (none)
//
//  Returns:    hr == S_OK, initialize succeeded
//              hr != S_OK, initialize failed
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CInvokeInfoHelper::InitErrorStatement ()
{
    return( ACUIMapErrorToString(m_hResources,
                                 m_hResult,
                                 &m_pszErrorStatement ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ACUIMapErrorToString
//
//  Synopsis:   maps error to string
//
//  Arguments:  [hr]   -- error
//              [ppsz] -- error string goes here
//
//  Returns:    S_OK if successful, any valid HRESULT otherwise
//
//----------------------------------------------------------------------------
HRESULT ACUIMapErrorToString (HINSTANCE hResources, HRESULT hr, LPWSTR* ppsz)
{
    UINT  ResourceId = 0;
    WCHAR psz[MAX_LOADSTRING_BUFFER];

    //
    // See if it maps to some non system error code
    //

    switch (hr)
    {

        case TRUST_E_SYSTEM_ERROR:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_INVALID_PARAMETER:
            //
            //  leave the resourceid zero...  these will be mapped to
            //  IDS_SPC_UNKNOWN and the error code displayed.
            //
            break;

    }

    //
    // If it does, load the string out of our resource string tables and
    // return that. Otherwise, try to format the message from the system
    //
    
    DWORD_PTR MessageArgument;
    CHAR  szError[13]; // for good luck
    WCHAR  wszError[13]; // for good luck
    LPVOID  pvMsg;

    pvMsg = NULL;

    if ( ResourceId != 0 )
    {
        if ( WszLoadString(hResources,
                           ResourceId,
                           psz,
                           MAX_LOADSTRING_BUFFER
                           ) == 0 )
        {
            return( HRESULT_FROM_WIN32(GetLastError()) );
        }

        *ppsz = new WCHAR[wcslen(psz) + 1];

        if ( *ppsz != NULL )
        {
            wcscpy(*ppsz, psz);
        }
        else
        {
            return( E_OUTOFMEMORY );
        }
    }
    else
    {
        if ( WszFormatMessage(
                   FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   hr,
                   0,
                   (LPWSTR)&pvMsg,
                   0,
                   NULL
                   ) == 0 )
        {
            if ( WszLoadString(hResources,
                               IDS_UNKNOWN,
                               psz,
                               MAX_LOADSTRING_BUFFER) == 0 )
            {
                return( HRESULT_FROM_WIN32(GetLastError()) );
            }

            sprintf(szError, "%lx", hr);
            MultiByteToWideChar(0, 0, szError, -1, &wszError[0], 13);
            MessageArgument = (DWORD_PTR)wszError;

            if ( WszFormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    psz,
                    0,
                    0,
                    (LPWSTR)&pvMsg,
                    0,
                    (va_list *)&MessageArgument
                    ) == 0 )
            {
                return( HRESULT_FROM_WIN32(GetLastError()) );
            }
        }
    }

    if (pvMsg)
    {
        *ppsz = new WCHAR[wcslen((WCHAR *)pvMsg) + 1];

        if (*ppsz)
        {
            wcscpy(*ppsz, (WCHAR *)pvMsg);
        }

        LocalFree(pvMsg);
    }

    return( S_OK );
}


//
// The following are stolen from SOFTPUB
//
void TUIGoLink(HWND hwndParent, WCHAR *pszWhere)
{
    HCURSOR hcursPrev;
    HMODULE hURLMon;


    //
    //  since we're a model dialog box, we want to go behind IE once it comes up!!!
    //
    SetWindowPos(hwndParent, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);

    hcursPrev = SetCursor(WszLoadCursor(NULL, IDC_WAIT));

    hURLMon = (HMODULE)WszLoadLibrary(L"urlmon.dll");

    if (!(hURLMon))
    {
        //
        // The hyperlink module is unavailable, go to fallback plan
        //
        //
        // This works in test cases, but causes deadlock problems when used from withing
        // the Internet Explorer itself. The dialog box is up (that is, IE is in a modal
        // dialog loop) and in comes this DDE request...).
        //
            ShellExecute(hwndParent, L"open", pszWhere, NULL, NULL, SW_SHOWNORMAL);

    } 
    else 
    {
        //
        // The hyperlink module is there. Use it
        //
        if (SUCCEEDED(CoInitialize(NULL)))       // Init OLE if no one else has
        {
            //
            //  allow com to fully init...
            //
            MSG     msg;

            WszPeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE); // peek but not remove

            typedef void (WINAPI *pfnHlinkSimpleNavigateToString)(LPCWSTR, LPCWSTR, LPCWSTR, IUnknown *,
                                                                  IBindCtx *, IBindStatusCallback *,
                                                                  DWORD, DWORD);

            pfnHlinkSimpleNavigateToString      pProcAddr;

            pProcAddr = (pfnHlinkSimpleNavigateToString)GetProcAddress(hURLMon, "HlinkSimpleNavigateToString");
            
            if (pProcAddr)
            {
                IBindCtx    *pbc;  

                pbc = NULL;

                CreateBindCtx( 0, &pbc ); 

                (*pProcAddr)(pszWhere, NULL, NULL, NULL, pbc, NULL, HLNF_OPENINNEWWINDOW, NULL);

                if (pbc)
                {
                    pbc->Release();
                }
            }
        
            CoUninitialize();
        }

        FreeLibrary(hURLMon);
    }

    SetCursor(hcursPrev);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// (C)

//----------------------------------------------------------------------------
// Private header file, used by pretty much all of perms
//----------------------------------------------------------------------------

#include <windows.h>
#include <winbase.h>
#include <windowsx.h>
#include <windef.h>
#include <limits.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>

#include "cor.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)

#ifdef __cplusplus
extern "C" {
#endif

HINSTANCE GetModule();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// 
//

#define IDD_DOWNLOADDIALOG              129
#define IDD_DIALOG_UNVERIFIED           130
#define IDD_DIALOG_CONFIRMATION         131
#define IDD_DIALOG_LEARNMORE            132

#define IDC_YESBUTTON                   133
#define IDC_NOBUTTON                    134
#define IDC_DIALOGTEXT                  135
#define IDC_ALWAYS                      136
#define IDC_SITETEXT                    137
#define IDC_LEARNTEXT                   138
#define IDC_QUESTIONTEXT                140

#define IDMORE                          151

#define IDC_SITE                        159
#define IDC_LINK                        160
#define IDC_ENCLOSED                    161
#define IDC_ZONE                        162
#define IDC_SEPARATORLINE               163
#define IDC_NOVERBMP                    164
#define IDC_NOAUTHENTICITY              165
#define IDC_TUIHAND                     166
#define IDC_CHECKACTION                 167
#define IDC_CONFIRMATION_TEXT1          168
#define IDC_CONFIRMATION_TEXT2          169
#define IDC_LEARNMORE                   170

#define IDS_NOAUTHENTICITY              223
#define IDS_SITE                        224
#define IDS_ZONE                        225
#define IDS_ENCLOSED                    226
#define IDS_UNKNOWN                     229
#define IDS_SECURITY                    230
#define IDS_CONFIRMATION_YES            231
#define IDS_CONFIRMATION_NO             232
#define IDS_CONFIRMATION_NEXT           233
#define IDS_LEARNMORE                   234
#define IDS_CONTINUE_BUTTONTEXT         235

#define IDB_BITMAP1                     300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\uicontrol.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


//*****************************************************************************
//*****************************************************************************
#include "stdpch.h"
#include "resource.h"
#include "corpolicy.h"
#include "corperm.h"
#include "corhlpr.h"
#include "Shlwapi.h"
#include "winwrap.h"
#include "resource.h"

#include "acuihelp.h"
#include "uicontrol.h"

CUnverifiedTrustUI::CUnverifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr) : 
    IACUIControl(riih.Resources()),
    m_riih( riih ),
    m_hrInvokeResult( TRUST_E_SUBJECT_NOT_TRUSTED ),
    m_pszNoAuthenticity( NULL ),
    m_pszSite( NULL ),
    m_pszZone( NULL ),
    m_pszEnclosed( NULL ),
    m_pszLink( NULL )
{
    DWORD_PTR aMessageArgument[3];

    //
    // Add the first line that states the managed control
    // is not signed with authenticode.
    //

    
    rhr = FormatACUIResourceString(Resources(),
                                   IDS_NOAUTHENTICITY,
                                   NULL,
                                   &m_pszNoAuthenticity);

    //
    // Format the site string
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR) m_riih.Site();

        rhr = FormatACUIResourceString(Resources(),
                                       IDS_SITE,
                                       aMessageArgument,
                                       &m_pszSite
                                       );
    }

    //
    // Format the Zone
    //

    if ( rhr == S_OK )
    {
        aMessageArgument[0] = (DWORD_PTR) m_riih.Zone();
        
        rhr = FormatACUIResourceString(Resources(),
                                       IDS_ZONE, 
                                       aMessageArgument, 
                                       &m_pszZone);
    }

    // 
    // Format the Enclosed caption
    //
    if ( rhr == S_OK )
    {
        rhr = FormatACUIResourceString(Resources(),
                                       IDS_ENCLOSED,
                                       NULL,
                                       &m_pszEnclosed);
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::~CUnverifiedTrustUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CUnverifiedTrustUI::~CUnverifiedTrustUI ()
{
    delete [] m_pszNoAuthenticity;
    delete [] m_pszSite;
    delete [] m_pszZone;
    delete [] m_pszEnclosed;
    delete [] m_pszLink;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CUnverifiedTrustUI::InvokeUI (HWND hDisplay)
{
    HRESULT hr = S_OK;

    //
    // Bring up the dialog
    //

    if ( WszDialogBoxParam(m_riih.Resources(),
                           (LPWSTR) MAKEINTRESOURCEW(IDD_DIALOG_UNVERIFIED),
                           hDisplay,
                           IACUIControl::ACUIMessageProc,
                           (LPARAM)this) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // The result has been stored as a member
    //

    return( m_hrInvokeResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
    int  bmptosep;
    int  septodlg;
    RECT rect;

    //
    // Render the Unsigned prompt
    //

    deltavpos = RenderACUIStringToEditControl(Resources(),
                                 hwnd,
                                 IDC_NOAUTHENTICITY,
                                 IDC_SITE,
                                 m_pszNoAuthenticity,
                                 deltavpos,
                                 FALSE,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL
           